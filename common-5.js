LavaPack.loadBundle([
["F:\\metamask-extension\\node_modules\\semver\\classes\\range.js", {"../internal/constants":"F:\\metamask-extension\\node_modules\\semver\\internal\\constants.js","../internal/debug":"F:\\metamask-extension\\node_modules\\semver\\internal\\debug.js","../internal/parse-options":"F:\\metamask-extension\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"F:\\metamask-extension\\node_modules\\semver\\internal\\re.js","./comparator":"F:\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","./semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js","lru-cache":"F:\\metamask-extension\\node_modules\\lru-cache\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cclasses%5Crange.js
      return function (require, module, exports) {
// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = require('lru-cache')
const cache = new LRU({ max: 1000 })

const parseOptions = require('../internal/parse-options')
const Comparator = require('./comparator')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = require('../internal/re')
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> -- > * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x -- > >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x -- > >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x -- > >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 -- > >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 -- > >=1.2.0 <1.3.0-0
// ~0.0.1 -- > >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceTilde(c, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ -- > * (any, kinda silly)
// ^2, ^2.x, ^2.x.x -- > >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x -- > >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x -- > >=1.2.0 <2.0.0-0
// ^1.2.3 -- > >=1.2.3 <2.0.0-0
// ^1.2.0 -- > >=1.2.0 <2.0.0-0
// ^0.0.1 -- > >=0.0.1 <0.0.2-0
// ^0.1.0 -- > >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceCaret(c, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((c) => {
    return replaceXRange(c, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\range.js",}],
["F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js", {"../internal/constants":"F:\\metamask-extension\\node_modules\\semver\\internal\\constants.js","../internal/debug":"F:\\metamask-extension\\node_modules\\semver\\internal\\debug.js","../internal/identifiers":"F:\\metamask-extension\\node_modules\\semver\\internal\\identifiers.js","../internal/parse-options":"F:\\metamask-extension\\node_modules\\semver\\internal\\parse-options.js","../internal/re":"F:\\metamask-extension\\node_modules\\semver\\internal\\re.js","util":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cclasses%5Csemver.js
      return function (require, module, exports) {
const debug = require('../internal/debug')
const { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')
const { re, t } = require('../internal/re')

const parseOptions = require('../internal/parse-options')
const { compareIdentifiers } = require('../internal/identifiers')
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${require('util').inspect(version)}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\classes\\semver.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\clean.js", {"./parse":"F:\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cclean.js
      return function (require, module, exports) {
const parse = require('./parse')
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\clean.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\cmp.js", {"./eq":"F:\\metamask-extension\\node_modules\\semver\\functions\\eq.js","./gt":"F:\\metamask-extension\\node_modules\\semver\\functions\\gt.js","./gte":"F:\\metamask-extension\\node_modules\\semver\\functions\\gte.js","./lt":"F:\\metamask-extension\\node_modules\\semver\\functions\\lt.js","./lte":"F:\\metamask-extension\\node_modules\\semver\\functions\\lte.js","./neq":"F:\\metamask-extension\\node_modules\\semver\\functions\\neq.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccmp.js
      return function (require, module, exports) {
const eq = require('./eq')
const neq = require('./neq')
const gt = require('./gt')
const gte = require('./gte')
const lt = require('./lt')
const lte = require('./lte')

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\cmp.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\coerce.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js","../internal/re":"F:\\metamask-extension\\node_modules\\semver\\internal\\re.js","./parse":"F:\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccoerce.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const parse = require('./parse')
const { re, t } = require('../internal/re')

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\coerce.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare-build.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare-build.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\compare-loose.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare-loose.js
      return function (require, module, exports) {
const compare = require('./compare')
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare-loose.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ccompare.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\compare.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\diff.js", {"./parse.js":"F:\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cdiff.js
      return function (require, module, exports) {
const parse = require('./parse.js')

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // at this point we know stable versions match but overall versions are not equal,
  // so either they are both prereleases, or the lower version is a prerelease

  if (highHasPre) {
    // high and low are preleases
    return 'prerelease'
  }

  if (lowVersion.patch) {
    // anything higher than a patch bump would result in the wrong version
    return 'patch'
  }

  if (lowVersion.minor) {
    // anything higher than a minor bump would result in the wrong version
    return 'minor'
  }

  // bumping major/minor/patch all have same result
  return 'major'
}

module.exports = diff

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\diff.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\eq.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Ceq.js
      return function (require, module, exports) {
const compare = require('./compare')
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\eq.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\gt.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cgt.js
      return function (require, module, exports) {
const compare = require('./compare')
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\gt.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\gte.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cgte.js
      return function (require, module, exports) {
const compare = require('./compare')
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\gte.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\inc.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cinc.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\inc.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\lt.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Clt.js
      return function (require, module, exports) {
const compare = require('./compare')
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\lt.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\lte.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Clte.js
      return function (require, module, exports) {
const compare = require('./compare')
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\lte.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\major.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cmajor.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\major.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\minor.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cminor.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\minor.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\neq.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cneq.js
      return function (require, module, exports) {
const compare = require('./compare')
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\neq.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\parse.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cparse.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\parse.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\patch.js", {"../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cpatch.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\patch.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\prerelease.js", {"./parse":"F:\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cprerelease.js
      return function (require, module, exports) {
const parse = require('./parse')
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\prerelease.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\rcompare.js", {"./compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Crcompare.js
      return function (require, module, exports) {
const compare = require('./compare')
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\rcompare.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\rsort.js", {"./compare-build":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Crsort.js
      return function (require, module, exports) {
const compareBuild = require('./compare-build')
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\rsort.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js", {"../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Csatisfies.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\satisfies.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\sort.js", {"./compare-build":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Csort.js
      return function (require, module, exports) {
const compareBuild = require('./compare-build')
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\sort.js",}],
["F:\\metamask-extension\\node_modules\\semver\\functions\\valid.js", {"./parse":"F:\\metamask-extension\\node_modules\\semver\\functions\\parse.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cfunctions%5Cvalid.js
      return function (require, module, exports) {
const parse = require('./parse')
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\functions\\valid.js",}],
["F:\\metamask-extension\\node_modules\\semver\\index.js", {"./classes/comparator":"F:\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","./classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js","./classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js","./functions/clean":"F:\\metamask-extension\\node_modules\\semver\\functions\\clean.js","./functions/cmp":"F:\\metamask-extension\\node_modules\\semver\\functions\\cmp.js","./functions/coerce":"F:\\metamask-extension\\node_modules\\semver\\functions\\coerce.js","./functions/compare":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js","./functions/compare-build":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare-build.js","./functions/compare-loose":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare-loose.js","./functions/diff":"F:\\metamask-extension\\node_modules\\semver\\functions\\diff.js","./functions/eq":"F:\\metamask-extension\\node_modules\\semver\\functions\\eq.js","./functions/gt":"F:\\metamask-extension\\node_modules\\semver\\functions\\gt.js","./functions/gte":"F:\\metamask-extension\\node_modules\\semver\\functions\\gte.js","./functions/inc":"F:\\metamask-extension\\node_modules\\semver\\functions\\inc.js","./functions/lt":"F:\\metamask-extension\\node_modules\\semver\\functions\\lt.js","./functions/lte":"F:\\metamask-extension\\node_modules\\semver\\functions\\lte.js","./functions/major":"F:\\metamask-extension\\node_modules\\semver\\functions\\major.js","./functions/minor":"F:\\metamask-extension\\node_modules\\semver\\functions\\minor.js","./functions/neq":"F:\\metamask-extension\\node_modules\\semver\\functions\\neq.js","./functions/parse":"F:\\metamask-extension\\node_modules\\semver\\functions\\parse.js","./functions/patch":"F:\\metamask-extension\\node_modules\\semver\\functions\\patch.js","./functions/prerelease":"F:\\metamask-extension\\node_modules\\semver\\functions\\prerelease.js","./functions/rcompare":"F:\\metamask-extension\\node_modules\\semver\\functions\\rcompare.js","./functions/rsort":"F:\\metamask-extension\\node_modules\\semver\\functions\\rsort.js","./functions/satisfies":"F:\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js","./functions/sort":"F:\\metamask-extension\\node_modules\\semver\\functions\\sort.js","./functions/valid":"F:\\metamask-extension\\node_modules\\semver\\functions\\valid.js","./internal/constants":"F:\\metamask-extension\\node_modules\\semver\\internal\\constants.js","./internal/identifiers":"F:\\metamask-extension\\node_modules\\semver\\internal\\identifiers.js","./internal/re":"F:\\metamask-extension\\node_modules\\semver\\internal\\re.js","./ranges/gtr":"F:\\metamask-extension\\node_modules\\semver\\ranges\\gtr.js","./ranges/intersects":"F:\\metamask-extension\\node_modules\\semver\\ranges\\intersects.js","./ranges/ltr":"F:\\metamask-extension\\node_modules\\semver\\ranges\\ltr.js","./ranges/max-satisfying":"F:\\metamask-extension\\node_modules\\semver\\ranges\\max-satisfying.js","./ranges/min-satisfying":"F:\\metamask-extension\\node_modules\\semver\\ranges\\min-satisfying.js","./ranges/min-version":"F:\\metamask-extension\\node_modules\\semver\\ranges\\min-version.js","./ranges/outside":"F:\\metamask-extension\\node_modules\\semver\\ranges\\outside.js","./ranges/simplify":"F:\\metamask-extension\\node_modules\\semver\\ranges\\simplify.js","./ranges/subset":"F:\\metamask-extension\\node_modules\\semver\\ranges\\subset.js","./ranges/to-comparators":"F:\\metamask-extension\\node_modules\\semver\\ranges\\to-comparators.js","./ranges/valid":"F:\\metamask-extension\\node_modules\\semver\\ranges\\valid.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cindex.js
      return function (require, module, exports) {
// just pre-load all the stuff that index.js lazily exports
const internalRe = require('./internal/re')
const constants = require('./internal/constants')
const SemVer = require('./classes/semver')
const identifiers = require('./internal/identifiers')
const parse = require('./functions/parse')
const valid = require('./functions/valid')
const clean = require('./functions/clean')
const inc = require('./functions/inc')
const diff = require('./functions/diff')
const major = require('./functions/major')
const minor = require('./functions/minor')
const patch = require('./functions/patch')
const prerelease = require('./functions/prerelease')
const compare = require('./functions/compare')
const rcompare = require('./functions/rcompare')
const compareLoose = require('./functions/compare-loose')
const compareBuild = require('./functions/compare-build')
const sort = require('./functions/sort')
const rsort = require('./functions/rsort')
const gt = require('./functions/gt')
const lt = require('./functions/lt')
const eq = require('./functions/eq')
const neq = require('./functions/neq')
const gte = require('./functions/gte')
const lte = require('./functions/lte')
const cmp = require('./functions/cmp')
const coerce = require('./functions/coerce')
const Comparator = require('./classes/comparator')
const Range = require('./classes/range')
const satisfies = require('./functions/satisfies')
const toComparators = require('./ranges/to-comparators')
const maxSatisfying = require('./ranges/max-satisfying')
const minSatisfying = require('./ranges/min-satisfying')
const minVersion = require('./ranges/min-version')
const validRange = require('./ranges/valid')
const outside = require('./ranges/outside')
const gtr = require('./ranges/gtr')
const ltr = require('./ranges/ltr')
const intersects = require('./ranges/intersects')
const simplifyRange = require('./ranges/simplify')
const subset = require('./ranges/subset')
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\index.js",}],
["F:\\metamask-extension\\node_modules\\semver\\internal\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cconstants.js
      return function (require, module, exports) {
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\constants.js",}],
["F:\\metamask-extension\\node_modules\\semver\\internal\\debug.js", {"_process":"F:\\metamask-extension\\node_modules\\process\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cdebug.js
      return function (require, module, exports) {
(function (process){(function (){
const debug = (
  typeof process === 'object' &&
  process.env &&
  "" &&
  /\bsemver\b/i.test("")
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\debug.js",}],
["F:\\metamask-extension\\node_modules\\semver\\internal\\identifiers.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cidentifiers.js
      return function (require, module, exports) {
const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\identifiers.js",}],
["F:\\metamask-extension\\node_modules\\semver\\internal\\parse-options.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cparse-options.js
      return function (require, module, exports) {
// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\parse-options.js",}],
["F:\\metamask-extension\\node_modules\\semver\\internal\\re.js", {"./constants":"F:\\metamask-extension\\node_modules\\semver\\internal\\constants.js","./debug":"F:\\metamask-extension\\node_modules\\semver\\internal\\debug.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cinternal%5Cre.js
      return function (require, module, exports) {
const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')
const debug = require('./debug')
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\internal\\re.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\gtr.js", {"./outside":"F:\\metamask-extension\\node_modules\\semver\\ranges\\outside.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cgtr.js
      return function (require, module, exports) {
// Determine if version is greater than all the versions possible in the range.
const outside = require('./outside')
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\gtr.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\intersects.js", {"../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cintersects.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\intersects.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\ltr.js", {"./outside":"F:\\metamask-extension\\node_modules\\semver\\ranges\\outside.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cltr.js
      return function (require, module, exports) {
const outside = require('./outside')
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\ltr.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\max-satisfying.js", {"../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cmax-satisfying.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\max-satisfying.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\min-satisfying.js", {"../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cmin-satisfying.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\min-satisfying.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\min-version.js", {"../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js","../functions/gt":"F:\\metamask-extension\\node_modules\\semver\\functions\\gt.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cmin-version.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const gt = require('../functions/gt')

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\min-version.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\outside.js", {"../classes/comparator":"F:\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js","../classes/semver":"F:\\metamask-extension\\node_modules\\semver\\classes\\semver.js","../functions/gt":"F:\\metamask-extension\\node_modules\\semver\\functions\\gt.js","../functions/gte":"F:\\metamask-extension\\node_modules\\semver\\functions\\gte.js","../functions/lt":"F:\\metamask-extension\\node_modules\\semver\\functions\\lt.js","../functions/lte":"F:\\metamask-extension\\node_modules\\semver\\functions\\lte.js","../functions/satisfies":"F:\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Coutside.js
      return function (require, module, exports) {
const SemVer = require('../classes/semver')
const Comparator = require('../classes/comparator')
const { ANY } = Comparator
const Range = require('../classes/range')
const satisfies = require('../functions/satisfies')
const gt = require('../functions/gt')
const lt = require('../functions/lt')
const lte = require('../functions/lte')
const gte = require('../functions/gte')

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\outside.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\simplify.js", {"../functions/compare.js":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js","../functions/satisfies.js":"F:\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Csimplify.js
      return function (require, module, exports) {
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\simplify.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\subset.js", {"../classes/comparator.js":"F:\\metamask-extension\\node_modules\\semver\\classes\\comparator.js","../classes/range.js":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js","../functions/compare.js":"F:\\metamask-extension\\node_modules\\semver\\functions\\compare.js","../functions/satisfies.js":"F:\\metamask-extension\\node_modules\\semver\\functions\\satisfies.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Csubset.js
      return function (require, module, exports) {
const Range = require('../classes/range.js')
const Comparator = require('../classes/comparator.js')
const { ANY } = Comparator
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\subset.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\to-comparators.js", {"../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cto-comparators.js
      return function (require, module, exports) {
const Range = require('../classes/range')

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\to-comparators.js",}],
["F:\\metamask-extension\\node_modules\\semver\\ranges\\valid.js", {"../classes/range":"F:\\metamask-extension\\node_modules\\semver\\classes\\range.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csemver%5Cranges%5Cvalid.js
      return function (require, module, exports) {
const Range = require('../classes/range')
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange

      };
    };
  }
  }
}, {package:"semver",file:"node_modules\\semver\\ranges\\valid.js",}],
["F:\\metamask-extension\\node_modules\\set-immediate-shim\\index.js", {"timers":"F:\\metamask-extension\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cset-immediate-shim%5Cindex.js
      return function (require, module, exports) {
(function (setImmediate){(function (){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

}).call(this)}).call(this,require("timers").setImmediate)

      };
    };
  }
  }
}, {package:"promise-to-callback>set-immediate-shim",file:"node_modules\\set-immediate-shim\\index.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\hash.js", {"safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Chash.js
      return function (require, module, exports) {
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\hash.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\index.js", {"./sha":"F:\\metamask-extension\\node_modules\\sha.js\\sha.js","./sha1":"F:\\metamask-extension\\node_modules\\sha.js\\sha1.js","./sha224":"F:\\metamask-extension\\node_modules\\sha.js\\sha224.js","./sha256":"F:\\metamask-extension\\node_modules\\sha.js\\sha256.js","./sha384":"F:\\metamask-extension\\node_modules\\sha.js\\sha384.js","./sha512":"F:\\metamask-extension\\node_modules\\sha.js\\sha512.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Cindex.js
      return function (require, module, exports) {
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\index.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\sha.js", {"./hash":"F:\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha.js
      return function (require, module, exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\sha1.js", {"./hash":"F:\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha1.js
      return function (require, module, exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha1.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\sha224.js", {"./hash":"F:\\metamask-extension\\node_modules\\sha.js\\hash.js","./sha256":"F:\\metamask-extension\\node_modules\\sha.js\\sha256.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha224.js
      return function (require, module, exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha224.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\sha256.js", {"./hash":"F:\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha256.js
      return function (require, module, exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha256.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\sha384.js", {"./hash":"F:\\metamask-extension\\node_modules\\sha.js\\hash.js","./sha512":"F:\\metamask-extension\\node_modules\\sha.js\\sha512.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha384.js
      return function (require, module, exports) {
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha384.js",}],
["F:\\metamask-extension\\node_modules\\sha.js\\sha512.js", {"./hash":"F:\\metamask-extension\\node_modules\\sha.js\\hash.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csha.js%5Csha512.js
      return function (require, module, exports) {
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

      };
    };
  }
  }
}, {package:"addons-linter>sha.js",file:"node_modules\\sha.js\\sha512.js",}],
["F:\\metamask-extension\\node_modules\\single-call-balance-checker-abi\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csingle-call-balance-checker-abi%5Cindex.js
      return function (require, module, exports) {

module.exports = [
    {
     "payable": true,
     "stateMutability": "payable",
     "type": "fallback"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "user",
       "type": "address"
      },
      {
       "name": "token",
       "type": "address"
      }
     ],
     "name": "tokenBalance",
     "outputs": [
      {
       "name": "",
       "type": "uint256"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "users",
       "type": "address[]"
      },
      {
       "name": "tokens",
       "type": "address[]"
      }
     ],
     "name": "balances",
     "outputs": [
      {
       "name": "",
       "type": "uint256[]"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    }
   ]

      };
    };
  }
  }
}, {package:"single-call-balance-checker-abi",file:"node_modules\\single-call-balance-checker-abi\\index.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\index.js", {"./lib/request":"F:\\metamask-extension\\node_modules\\stream-http\\lib\\request.js","./lib/response":"F:\\metamask-extension\\node_modules\\stream-http\\lib\\response.js","builtin-status-codes":"F:\\metamask-extension\\node_modules\\builtin-status-codes\\browser.js","url":"F:\\metamask-extension\\node_modules\\url\\url.js","xtend":"F:\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cindex.js
      return function (require, module, exports) {
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
      };
    };
  }
  }
}, {package:"browserify>stream-http",file:"node_modules\\stream-http\\index.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\lib\\capability.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Clib%5Ccapability.js
      return function (require, module, exports) {
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

      };
    };
  }
  }
}, {package:"browserify>stream-http",file:"node_modules\\stream-http\\lib\\capability.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\lib\\request.js", {"./capability":"F:\\metamask-extension\\node_modules\\stream-http\\lib\\capability.js","./response":"F:\\metamask-extension\\node_modules\\stream-http\\lib\\response.js","_process":"F:\\metamask-extension\\node_modules\\process\\browser.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","readable-stream":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Clib%5Crequest.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
        body = new Blob(self._body, {
            type: (headersObj['content-type'] || {}).value || ''
        });
    }

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"browserify>stream-http",file:"node_modules\\stream-http\\lib\\request.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\lib\\response.js", {"./capability":"F:\\metamask-extension\\node_modules\\stream-http\\lib\\capability.js","_process":"F:\\metamask-extension\\node_modules\\process\\browser.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","readable-stream":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Clib%5Cresponse.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(Buffer.from(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(Buffer.from(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text':
			response = xhr.responseText
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = Buffer.alloc(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"browserify>stream-http",file:"node_modules\\stream-http\\lib\\response.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Cerrors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_duplex.js", {"./_stream_readable":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_readable.js","./_stream_writable":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_writable.js","_process":"F:\\metamask-extension\\node_modules\\process\\browser.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5C_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_duplex.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_passthrough.js", {"./_stream_transform":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_transform.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5C_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_passthrough.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_readable.js", {"../errors":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./internal/streams/async_iterator":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js","./internal/streams/buffer_list":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js","./internal/streams/destroy":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","./internal/streams/from":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js","./internal/streams/state":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js","./internal/streams/stream":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js","_process":"F:\\metamask-extension\\node_modules\\process\\browser.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","string_decoder/":"F:\\metamask-extension\\node_modules\\string_decoder\\lib\\string_decoder.js","util":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5C_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_readable.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_transform.js", {"../errors":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_duplex.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5C_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_transform.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_writable.js", {"../errors":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./internal/streams/destroy":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","./internal/streams/state":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js","./internal/streams/stream":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js","_process":"F:\\metamask-extension\\node_modules\\process\\browser.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","inherits":"F:\\metamask-extension\\node_modules\\inherits\\inherits_browser.js","util-deprecate":"F:\\metamask-extension\\node_modules\\util-deprecate\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5C_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_writable.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js", {"./end-of-stream":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","_process":"F:\\metamask-extension\\node_modules\\process\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Casync_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","util":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Cbuffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js", {"_process":"F:\\metamask-extension\\node_modules\\process\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Cdestroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js", {"../../../errors":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Cend-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Cfrom-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js", {"../../../errors":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js","./end-of-stream":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Cpipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js", {"../../../errors":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\errors-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Cstate.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js", {"events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Clib%5Cinternal%5Cstreams%5Cstream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js",}],
["F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\readable-browser.js", {"./lib/_stream_duplex.js":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./lib/_stream_passthrough.js":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_passthrough.js","./lib/_stream_readable.js":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_readable.js","./lib/_stream_transform.js":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_transform.js","./lib/_stream_writable.js":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\_stream_writable.js","./lib/internal/streams/end-of-stream.js":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","./lib/internal/streams/pipeline.js":"F:\\metamask-extension\\node_modules\\stream-http\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstream-http%5Cnode_modules%5Creadable-stream%5Creadable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
  }
}, {package:"browserify>stream-http>readable-stream",file:"node_modules\\stream-http\\node_modules\\readable-stream\\readable-browser.js",}],
["F:\\metamask-extension\\node_modules\\string_decoder\\lib\\string_decoder.js", {"safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstring_decoder%5Clib%5Cstring_decoder.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
      };
    };
  }
  }
}, {package:"browserify>string_decoder",file:"node_modules\\string_decoder\\lib\\string_decoder.js",}],
["F:\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js", {"is-hex-prefixed":"F:\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cstrip-hex-prefix%5Csrc%5Cindex.js
      return function (require, module, exports) {
var isHexPrefixed = require('is-hex-prefixed');

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}

      };
    };
  }
  }
}, {package:"ethjs>ethjs-util>strip-hex-prefix",file:"node_modules\\strip-hex-prefix\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csuperstruct%5Cdist%5Cindex.cjs
      return function (require, module, exports) {
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Superstruct = {}));
})(this, (function (exports) { 'use strict';

    /**
     * A `StructFailure` represents a single specific failure in validation.
     */
    /**
     * `StructError` objects are thrown (or returned) when validation fails.
     *
     * Validation logic is design to exit early for maximum performance. The error
     * represents the first error encountered during validation. For more detail,
     * the `error.failures` property is a generator function that can be run to
     * continue validation and receive all the failures in the data.
     */
    class StructError extends TypeError {
        constructor(failure, failures) {
            let cached;
            const { message, explanation, ...rest } = failure;
            const { path } = failure;
            const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
            super(explanation ?? msg);
            if (explanation != null)
                this.cause = msg;
            Object.assign(this, rest);
            this.name = this.constructor.name;
            this.failures = () => {
                return (cached ?? (cached = [failure, ...failures()]));
            };
        }
    }

    /**
     * Check if a value is an iterator.
     */
    function isIterable(x) {
        return isObject(x) && typeof x[Symbol.iterator] === 'function';
    }
    /**
     * Check if a value is a plain object.
     */
    function isObject(x) {
        return typeof x === 'object' && x != null;
    }
    /**
     * Check if a value is a plain object.
     */
    function isPlainObject(x) {
        if (Object.prototype.toString.call(x) !== '[object Object]') {
            return false;
        }
        const prototype = Object.getPrototypeOf(x);
        return prototype === null || prototype === Object.prototype;
    }
    /**
     * Return a value as a printable string.
     */
    function print(value) {
        if (typeof value === 'symbol') {
            return value.toString();
        }
        return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
    }
    /**
     * Shifts (removes and returns) the first value from the `input` iterator.
     * Like `Array.prototype.shift()` but for an `Iterator`.
     */
    function shiftIterator(input) {
        const { done, value } = input.next();
        return done ? undefined : value;
    }
    /**
     * Convert a single validation result to a failure.
     */
    function toFailure(result, context, struct, value) {
        if (result === true) {
            return;
        }
        else if (result === false) {
            result = {};
        }
        else if (typeof result === 'string') {
            result = { message: result };
        }
        const { path, branch } = context;
        const { type } = struct;
        const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``, } = result;
        return {
            value,
            type,
            refinement,
            key: path[path.length - 1],
            path,
            branch,
            ...result,
            message,
        };
    }
    /**
     * Convert a validation result to an iterable of failures.
     */
    function* toFailures(result, context, struct, value) {
        if (!isIterable(result)) {
            result = [result];
        }
        for (const r of result) {
            const failure = toFailure(r, context, struct, value);
            if (failure) {
                yield failure;
            }
        }
    }
    /**
     * Check a value against a struct, traversing deeply into nested values, and
     * returning an iterator of failures or success.
     */
    function* run(value, struct, options = {}) {
        const { path = [], branch = [value], coerce = false, mask = false } = options;
        const ctx = { path, branch };
        if (coerce) {
            value = struct.coercer(value, ctx);
            if (mask &&
                struct.type !== 'type' &&
                isObject(struct.schema) &&
                isObject(value) &&
                !Array.isArray(value)) {
                for (const key in value) {
                    if (struct.schema[key] === undefined) {
                        delete value[key];
                    }
                }
            }
        }
        let status = 'valid';
        for (const failure of struct.validator(value, ctx)) {
            failure.explanation = options.message;
            status = 'not_valid';
            yield [failure, undefined];
        }
        for (let [k, v, s] of struct.entries(value, ctx)) {
            const ts = run(v, s, {
                path: k === undefined ? path : [...path, k],
                branch: k === undefined ? branch : [...branch, v],
                coerce,
                mask,
                message: options.message,
            });
            for (const t of ts) {
                if (t[0]) {
                    status = t[0].refinement != null ? 'not_refined' : 'not_valid';
                    yield [t[0], undefined];
                }
                else if (coerce) {
                    v = t[1];
                    if (k === undefined) {
                        value = v;
                    }
                    else if (value instanceof Map) {
                        value.set(k, v);
                    }
                    else if (value instanceof Set) {
                        value.add(v);
                    }
                    else if (isObject(value)) {
                        if (v !== undefined || k in value)
                            value[k] = v;
                    }
                }
            }
        }
        if (status !== 'not_valid') {
            for (const failure of struct.refiner(value, ctx)) {
                failure.explanation = options.message;
                status = 'not_refined';
                yield [failure, undefined];
            }
        }
        if (status === 'valid') {
            yield [undefined, value];
        }
    }

    /**
     * `Struct` objects encapsulate the validation logic for a specific type of
     * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
     * validate unknown input data against the struct.
     */
    class Struct {
        constructor(props) {
            const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;
            this.type = type;
            this.schema = schema;
            this.entries = entries;
            this.coercer = coercer;
            if (validator) {
                this.validator = (value, context) => {
                    const result = validator(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.validator = () => [];
            }
            if (refiner) {
                this.refiner = (value, context) => {
                    const result = refiner(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.refiner = () => [];
            }
        }
        /**
         * Assert that a value passes the struct's validation, throwing if it doesn't.
         */
        assert(value, message) {
            return assert(value, this, message);
        }
        /**
         * Create a value with the struct's coercion logic, then validate it.
         */
        create(value, message) {
            return create(value, this, message);
        }
        /**
         * Check if a value passes the struct's validation.
         */
        is(value) {
            return is(value, this);
        }
        /**
         * Mask a value, coercing and validating it, but returning only the subset of
         * properties defined by the struct's schema.
         */
        mask(value, message) {
            return mask(value, this, message);
        }
        /**
         * Validate a value with the struct's validation logic, returning a tuple
         * representing the result.
         *
         * You may optionally pass `true` for the `withCoercion` argument to coerce
         * the value before attempting to validate it. If you do, the result will
         * contain the coerced result when successful.
         */
        validate(value, options = {}) {
            return validate(value, this, options);
        }
    }
    /**
     * Assert that a value passes a struct, throwing if it doesn't.
     */
    function assert(value, struct, message) {
        const result = validate(value, struct, { message });
        if (result[0]) {
            throw result[0];
        }
    }
    /**
     * Create a value with the coercion logic of struct and validate it.
     */
    function create(value, struct, message) {
        const result = validate(value, struct, { coerce: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Mask a value, returning only the subset of properties defined by a struct.
     */
    function mask(value, struct, message) {
        const result = validate(value, struct, { coerce: true, mask: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Check if a value passes a struct.
     */
    function is(value, struct) {
        const result = validate(value, struct);
        return !result[0];
    }
    /**
     * Validate a value against a struct, returning an error if invalid, or the
     * value (with potential coercion) if valid.
     */
    function validate(value, struct, options = {}) {
        const tuples = run(value, struct, options);
        const tuple = shiftIterator(tuples);
        if (tuple[0]) {
            const error = new StructError(tuple[0], function* () {
                for (const t of tuples) {
                    if (t[0]) {
                        yield t[0];
                    }
                }
            });
            return [error, undefined];
        }
        else {
            const v = tuple[1];
            return [undefined, v];
        }
    }

    function assign(...Structs) {
        const isType = Structs[0].type === 'type';
        const schemas = Structs.map((s) => s.schema);
        const schema = Object.assign({}, ...schemas);
        return isType ? type(schema) : object(schema);
    }
    /**
     * Define a new struct type with a custom validation function.
     */
    function define(name, validator) {
        return new Struct({ type: name, schema: null, validator });
    }
    /**
     * Create a new struct based on an existing struct, but the value is allowed to
     * be `undefined`. `log` will be called if the value is not `undefined`.
     */
    function deprecated(struct, log) {
        return new Struct({
            ...struct,
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
            validator(value, ctx) {
                if (value === undefined) {
                    return true;
                }
                else {
                    log(value, ctx);
                    return struct.validator(value, ctx);
                }
            },
        });
    }
    /**
     * Create a struct with dynamic validation logic.
     *
     * The callback will receive the value currently being validated, and must
     * return a struct object to validate it with. This can be useful to model
     * validation logic that changes based on its input.
     */
    function dynamic(fn) {
        return new Struct({
            type: 'dynamic',
            schema: null,
            *entries(value, ctx) {
                const struct = fn(value, ctx);
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                const struct = fn(value, ctx);
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                const struct = fn(value, ctx);
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                const struct = fn(value, ctx);
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a struct with lazily evaluated validation logic.
     *
     * The first time validation is run with the struct, the callback will be called
     * and must return a struct object to use. This is useful for cases where you
     * want to have self-referential structs for nested data structures to avoid a
     * circular definition problem.
     */
    function lazy(fn) {
        let struct;
        return new Struct({
            type: 'lazy',
            schema: null,
            *entries(value, ctx) {
                struct ?? (struct = fn());
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                struct ?? (struct = fn());
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                struct ?? (struct = fn());
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                struct ?? (struct = fn());
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a new struct based on an existing object struct, but excluding
     * specific properties.
     *
     * Like TypeScript's `Omit` utility.
     */
    function omit(struct, keys) {
        const { schema } = struct;
        const subschema = { ...schema };
        for (const key of keys) {
            delete subschema[key];
        }
        switch (struct.type) {
            case 'type':
                return type(subschema);
            default:
                return object(subschema);
        }
    }
    /**
     * Create a new struct based on an existing object struct, but with all of its
     * properties allowed to be `undefined`.
     *
     * Like TypeScript's `Partial` utility.
     */
    function partial(struct) {
        const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };
        for (const key in schema) {
            schema[key] = optional(schema[key]);
        }
        return object(schema);
    }
    /**
     * Create a new struct based on an existing object struct, but only including
     * specific properties.
     *
     * Like TypeScript's `Pick` utility.
     */
    function pick(struct, keys) {
        const { schema } = struct;
        const subschema = {};
        for (const key of keys) {
            subschema[key] = schema[key];
        }
        return object(subschema);
    }
    /**
     * Define a new struct type with a custom validation function.
     *
     * @deprecated This function has been renamed to `define`.
     */
    function struct(name, validator) {
        console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
        return define(name, validator);
    }

    /**
     * Ensure that any value passes validation.
     */
    function any() {
        return define('any', () => true);
    }
    function array(Element) {
        return new Struct({
            type: 'array',
            schema: Element,
            *entries(value) {
                if (Element && Array.isArray(value)) {
                    for (const [i, v] of value.entries()) {
                        yield [i, v, Element];
                    }
                }
            },
            coercer(value) {
                return Array.isArray(value) ? value.slice() : value;
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array value, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a bigint.
     */
    function bigint() {
        return define('bigint', (value) => {
            return typeof value === 'bigint';
        });
    }
    /**
     * Ensure that a value is a boolean.
     */
    function boolean() {
        return define('boolean', (value) => {
            return typeof value === 'boolean';
        });
    }
    /**
     * Ensure that a value is a valid `Date`.
     *
     * Note: this also ensures that the value is *not* an invalid `Date` object,
     * which can occur when parsing a date fails but still returns a `Date`.
     */
    function date() {
        return define('date', (value) => {
            return ((value instanceof Date && !isNaN(value.getTime())) ||
                `Expected a valid \`Date\` object, but received: ${print(value)}`);
        });
    }
    function enums(values) {
        const schema = {};
        const description = values.map((v) => print(v)).join();
        for (const key of values) {
            schema[key] = key;
        }
        return new Struct({
            type: 'enums',
            schema,
            validator(value) {
                return (values.includes(value) ||
                    `Expected one of \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a function.
     */
    function func() {
        return define('func', (value) => {
            return (typeof value === 'function' ||
                `Expected a function, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an instance of a specific class.
     */
    function instance(Class) {
        return define('instance', (value) => {
            return (value instanceof Class ||
                `Expected a \`${Class.name}\` instance, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an integer.
     */
    function integer() {
        return define('integer', (value) => {
            return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||
                `Expected an integer, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value matches all of a set of types.
     */
    function intersection(Structs) {
        return new Struct({
            type: 'intersection',
            schema: null,
            *entries(value, ctx) {
                for (const S of Structs) {
                    yield* S.entries(value, ctx);
                }
            },
            *validator(value, ctx) {
                for (const S of Structs) {
                    yield* S.validator(value, ctx);
                }
            },
            *refiner(value, ctx) {
                for (const S of Structs) {
                    yield* S.refiner(value, ctx);
                }
            },
        });
    }
    function literal(constant) {
        const description = print(constant);
        const t = typeof constant;
        return new Struct({
            type: 'literal',
            schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
            validator(value) {
                return (value === constant ||
                    `Expected the literal \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    function map(Key, Value) {
        return new Struct({
            type: 'map',
            schema: null,
            *entries(value) {
                if (Key && Value && value instanceof Map) {
                    for (const [k, v] of value.entries()) {
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            coercer(value) {
                return value instanceof Map ? new Map(value) : value;
            },
            validator(value) {
                return (value instanceof Map ||
                    `Expected a \`Map\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that no value ever passes validation.
     */
    function never() {
        return define('never', () => false);
    }
    /**
     * Augment an existing struct to allow `null` values.
     */
    function nullable(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === null || struct.validator(value, ctx),
            refiner: (value, ctx) => value === null || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is a number.
     */
    function number() {
        return define('number', (value) => {
            return ((typeof value === 'number' && !isNaN(value)) ||
                `Expected a number, but received: ${print(value)}`);
        });
    }
    function object(schema) {
        const knowns = schema ? Object.keys(schema) : [];
        const Never = never();
        return new Struct({
            type: 'object',
            schema: schema ? schema : null,
            *entries(value) {
                if (schema && isObject(value)) {
                    const unknowns = new Set(Object.keys(value));
                    for (const key of knowns) {
                        unknowns.delete(key);
                        yield [key, value[key], schema[key]];
                    }
                    for (const key of unknowns) {
                        yield [key, value[key], Never];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Augment a struct to allow `undefined` values.
     */
    function optional(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is an object with keys and values of specific types, but
     * without ensuring any specific shape of properties.
     *
     * Like TypeScript's `Record` utility.
     */
    function record(Key, Value) {
        return new Struct({
            type: 'record',
            schema: null,
            *entries(value) {
                if (isObject(value)) {
                    for (const k in value) {
                        const v = value[k];
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a `RegExp`.
     *
     * Note: this does not test the value against the regular expression! For that
     * you need to use the `pattern()` refinement.
     */
    function regexp() {
        return define('regexp', (value) => {
            return value instanceof RegExp;
        });
    }
    function set(Element) {
        return new Struct({
            type: 'set',
            schema: null,
            *entries(value) {
                if (Element && value instanceof Set) {
                    for (const v of value) {
                        yield [v, v, Element];
                    }
                }
            },
            coercer(value) {
                return value instanceof Set ? new Set(value) : value;
            },
            validator(value) {
                return (value instanceof Set ||
                    `Expected a \`Set\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a string.
     */
    function string() {
        return define('string', (value) => {
            return (typeof value === 'string' ||
                `Expected a string, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is a tuple of a specific length, and that each of its
     * elements is of a specific type.
     */
    function tuple(Structs) {
        const Never = never();
        return new Struct({
            type: 'tuple',
            schema: null,
            *entries(value) {
                if (Array.isArray(value)) {
                    const length = Math.max(Structs.length, value.length);
                    for (let i = 0; i < length; i++) {
                        yield [i, value[i], Structs[i] || Never];
                    }
                }
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value has a set of known properties of specific types.
     *
     * Note: Unrecognized properties are allowed and untouched. This is similar to
     * how TypeScript's structural typing works.
     */
    function type(schema) {
        const keys = Object.keys(schema);
        return new Struct({
            type: 'type',
            schema,
            *entries(value) {
                if (isObject(value)) {
                    for (const k of keys) {
                        yield [k, value[k], schema[k]];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Ensure that a value matches one of a set of types.
     */
    function union(Structs) {
        const description = Structs.map((s) => s.type).join(' | ');
        return new Struct({
            type: 'union',
            schema: null,
            coercer(value) {
                for (const S of Structs) {
                    const [error, coerced] = S.validate(value, { coerce: true });
                    if (!error) {
                        return coerced;
                    }
                }
                return value;
            },
            validator(value, ctx) {
                const failures = [];
                for (const S of Structs) {
                    const [...tuples] = run(value, S, ctx);
                    const [first] = tuples;
                    if (!first[0]) {
                        return [];
                    }
                    else {
                        for (const [failure] of tuples) {
                            if (failure) {
                                failures.push(failure);
                            }
                        }
                    }
                }
                return [
                    `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
                    ...failures,
                ];
            },
        });
    }
    /**
     * Ensure that any value passes validation, without widening its type to `any`.
     */
    function unknown() {
        return define('unknown', () => true);
    }

    /**
     * Augment a `Struct` to add an additional coercion step to its input.
     *
     * This allows you to transform input data before validating it, to increase the
     * likelihood that it passes validationfor example for default values, parsing
     * different formats, etc.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function coerce(struct, condition, coercer) {
        return new Struct({
            ...struct,
            coercer: (value, ctx) => {
                return is(value, condition)
                    ? struct.coercer(coercer(value, ctx), ctx)
                    : struct.coercer(value, ctx);
            },
        });
    }
    /**
     * Augment a struct to replace `undefined` values with a default.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function defaulted(struct, fallback, options = {}) {
        return coerce(struct, unknown(), (x) => {
            const f = typeof fallback === 'function' ? fallback() : fallback;
            if (x === undefined) {
                return f;
            }
            if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
                const ret = { ...x };
                let changed = false;
                for (const key in f) {
                    if (ret[key] === undefined) {
                        ret[key] = f[key];
                        changed = true;
                    }
                }
                if (changed) {
                    return ret;
                }
            }
            return x;
        });
    }
    /**
     * Augment a struct to trim string inputs.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function trimmed(struct) {
        return coerce(struct, string(), (x) => x.trim());
    }

    /**
     * Ensure that a string, array, map, or set is empty.
     */
    function empty(struct) {
        return refine(struct, 'empty', (value) => {
            const size = getSize(value);
            return (size === 0 ||
                `Expected an empty ${struct.type} but received one with a size of \`${size}\``);
        });
    }
    function getSize(value) {
        if (value instanceof Map || value instanceof Set) {
            return value.size;
        }
        else {
            return value.length;
        }
    }
    /**
     * Ensure that a number or date is below a threshold.
     */
    function max(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'max', (value) => {
            return exclusive
                ? value < threshold
                : value <= threshold ||
                    `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a number or date is above a threshold.
     */
    function min(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'min', (value) => {
            return exclusive
                ? value > threshold
                : value >= threshold ||
                    `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a string, array, map or set is not empty.
     */
    function nonempty(struct) {
        return refine(struct, 'nonempty', (value) => {
            const size = getSize(value);
            return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);
        });
    }
    /**
     * Ensure that a string matches a regular expression.
     */
    function pattern(struct, regexp) {
        return refine(struct, 'pattern', (value) => {
            return (regexp.test(value) ||
                `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`);
        });
    }
    /**
     * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
     */
    function size(struct, min, max = min) {
        const expected = `Expected a ${struct.type}`;
        const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
        return refine(struct, 'size', (value) => {
            if (typeof value === 'number' || value instanceof Date) {
                return ((min <= value && value <= max) ||
                    `${expected} ${of} but received \`${value}\``);
            }
            else if (value instanceof Map || value instanceof Set) {
                const { size } = value;
                return ((min <= size && size <= max) ||
                    `${expected} with a size ${of} but received one with a size of \`${size}\``);
            }
            else {
                const { length } = value;
                return ((min <= length && length <= max) ||
                    `${expected} with a length ${of} but received one with a length of \`${length}\``);
            }
        });
    }
    /**
     * Augment a `Struct` to add an additional refinement to the validation.
     *
     * The refiner function is guaranteed to receive a value of the struct's type,
     * because the struct's existing validation will already have passed. This
     * allows you to layer additional validation on top of existing structs.
     */
    function refine(struct, name, refiner) {
        return new Struct({
            ...struct,
            *refiner(value, ctx) {
                yield* struct.refiner(value, ctx);
                const result = refiner(value, ctx);
                const failures = toFailures(result, ctx, struct, value);
                for (const failure of failures) {
                    yield { ...failure, refinement: name };
                }
            },
        });
    }

    exports.Struct = Struct;
    exports.StructError = StructError;
    exports.any = any;
    exports.array = array;
    exports.assert = assert;
    exports.assign = assign;
    exports.bigint = bigint;
    exports.boolean = boolean;
    exports.coerce = coerce;
    exports.create = create;
    exports.date = date;
    exports.defaulted = defaulted;
    exports.define = define;
    exports.deprecated = deprecated;
    exports.dynamic = dynamic;
    exports.empty = empty;
    exports.enums = enums;
    exports.func = func;
    exports.instance = instance;
    exports.integer = integer;
    exports.intersection = intersection;
    exports.is = is;
    exports.lazy = lazy;
    exports.literal = literal;
    exports.map = map;
    exports.mask = mask;
    exports.max = max;
    exports.min = min;
    exports.never = never;
    exports.nonempty = nonempty;
    exports.nullable = nullable;
    exports.number = number;
    exports.object = object;
    exports.omit = omit;
    exports.optional = optional;
    exports.partial = partial;
    exports.pattern = pattern;
    exports.pick = pick;
    exports.record = record;
    exports.refine = refine;
    exports.regexp = regexp;
    exports.set = set;
    exports.size = size;
    exports.string = string;
    exports.struct = struct;
    exports.trimmed = trimmed;
    exports.tuple = tuple;
    exports.type = type;
    exports.union = union;
    exports.unknown = unknown;
    exports.validate = validate;

}));
//# sourceMappingURL=index.cjs.map

      };
    };
  }
  }
}, {package:"superstruct",file:"node_modules\\superstruct\\dist\\index.cjs",}],
["F:\\metamask-extension\\node_modules\\timers-browserify\\main.js", {"process/browser.js":"F:\\metamask-extension\\node_modules\\process\\browser.js","timers":"F:\\metamask-extension\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctimers-browserify%5Cmain.js
      return function (require, module, exports) {
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

      };
    };
  }
  }
}, {package:"browserify>timers-browserify",file:"node_modules\\timers-browserify\\main.js",}],
["F:\\metamask-extension\\node_modules\\tslib\\tslib.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctslib%5Ctslib.js
      return function (require, module, exports) {
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __esDecorate;
var __runInitializers;
var __propKey;
var __setFunctionName;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __esDecorate = function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access) context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.push(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field") initializers.push(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    };

    __runInitializers = function (thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    };

    __propKey = function (x) {
        return typeof x === "symbol" ? x : "".concat(x);
    };

    __setFunctionName = function (f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
});

      };
    };
  }
  }
}, {package:"wait-on>rxjs>tslib",file:"node_modules\\tslib\\tslib.js",}],
["F:\\metamask-extension\\node_modules\\url\\url.js", {"./util":"F:\\metamask-extension\\node_modules\\url\\util.js","punycode":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\punycode\\punycode.js","querystring":"F:\\metamask-extension\\node_modules\\querystring-es3\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Curl%5Curl.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

      };
    };
  }
  }
}, {package:"browserify>url",file:"node_modules\\url\\url.js",}],
["F:\\metamask-extension\\node_modules\\url\\util.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Curl%5Cutil.js
      return function (require, module, exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

      };
    };
  }
  }
}, {package:"browserify>url",file:"node_modules\\url\\util.js",}],
["F:\\metamask-extension\\node_modules\\utf8\\utf8.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cutf8%5Cutf8.js
      return function (require, module, exports) {
/*! https://mths.be/utf8js v3.0.0 by @mathias */
;(function(root) {

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	root.version = '3.0.0';
	root.encode = utf8encode;
	root.decode = utf8decode;

}(typeof exports === 'undefined' ? this.utf8 = {} : exports));

      };
    };
  }
  }
}, {package:"@truffle/codec>utf8",file:"node_modules\\utf8\\utf8.js",}],
["F:\\metamask-extension\\node_modules\\util-deprecate\\browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cutil-deprecate%5Cbrowser.js
      return function (require, module, exports) {

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

      };
    };
  }
  }
}, {package:"readable-stream>util-deprecate",file:"node_modules\\util-deprecate\\browser.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\index.js", {"./nil.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\nil.js","./parse.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js","./v1.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\v1.js","./v3.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\v3.js","./v4.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\v4.js","./v5.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\v5.js","./validate.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\validate.js","./version.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\version.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\md5-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cmd5-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\md5-browser.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\nil.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cnil.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\nil.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\parse.js", {"./validate.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cparse.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\parse.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\regex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cregex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\regex.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\rng-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Crng-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\rng-browser.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\sha1-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Csha1-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\sha1-browser.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js", {"./validate.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cstringify.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\stringify.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\v1.js", {"./rng.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv1.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v1.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\v3.js", {"./md5.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\md5-browser.js","./v35.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv3.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v3.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\v35.js", {"./parse.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv35.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v35.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\v4.js", {"./rng.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv4.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v4.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\v5.js", {"./sha1.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\sha1-browser.js","./v35.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cv5.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\v5.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\validate.js", {"./regex.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\regex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cvalidate.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\validate.js",}],
["F:\\metamask-extension\\node_modules\\uuid\\dist\\version.js", {"./validate.js":"F:\\metamask-extension\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuuid%5Cdist%5Cversion.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
      };
    };
  }
  }
}, {package:"uuid",file:"node_modules\\uuid\\dist\\version.js",}],
["F:\\metamask-extension\\node_modules\\valid-url\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvalid-url%5Cindex.js
      return function (require, module, exports) {
(function(module) {
    'use strict';

    module.exports.is_uri = is_iri;
    module.exports.is_http_uri = is_http_iri;
    module.exports.is_https_uri = is_https_iri;
    module.exports.is_web_uri = is_web_iri;
    // Create aliases
    module.exports.isUri = is_iri;
    module.exports.isHttpUri = is_http_iri;
    module.exports.isHttpsUri = is_https_iri;
    module.exports.isWebUri = is_web_iri;


    // private function
    // internal URI spitter method - direct from RFC 3986
    var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
    };

    function is_iri(value) {
        if (!value) {
            return;
        }

        // check for illegal characters
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;

        // check for hex escapes that aren't complete
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        // scheme and path are required, though the path can be empty
        if (!(scheme && scheme.length && path.length >= 0)) return;

        // if authority is present, the path must be empty or begin with a /
        if (authority && authority.length) {
            if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
            // if authority is not present, the path must not start with //
            if (/^\/\//.test(path)) return;
        }

        // scheme must begin with a letter, then consist of letters, digits, +, ., or -
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))  return;

        // re-assemble the URL per section 5.3 in RFC 3986
        out += scheme + ':';
        if (authority && authority.length) {
            out += '//' + authority;
        }

        out += path;

        if (query && query.length) {
            out += '?' + query;
        }

        if (fragment && fragment.length) {
            out += '#' + fragment;
        }

        return out;
    }

    function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
            return;
        }

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var port = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        if (!scheme)  return;

        if(allowHttps) {
            if (scheme.toLowerCase() != 'https') return;
        } else {
            if (scheme.toLowerCase() != 'http') return;
        }

        // fully-qualified URIs must have an authority section that is
        // a valid host
        if (!authority) {
            return;
        }

        // enable port component
        if (/:(\d+)$/.test(authority)) {
            port = authority.match(/:(\d+)$/)[0];
            authority = authority.replace(/:\d+$/, '');
        }

        out += scheme + ':';
        out += '//' + authority;
        
        if (port) {
            out += port;
        }
        
        out += path;
        
        if(query && query.length){
            out += '?' + query;
        }

        if(fragment && fragment.length){
            out += '#' + fragment;
        }
        
        return out;
    }

    function is_https_iri(value) {
        return is_http_iri(value, true);
    }

    function is_web_iri(value) {
        return (is_http_iri(value) || is_https_iri(value));
    }

})(module);

      };
    };
  }
  }
}, {package:"valid-url",file:"node_modules\\valid-url\\index.js",}],
["F:\\metamask-extension\\node_modules\\varint\\decode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Cdecode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\decode.js",}],
["F:\\metamask-extension\\node_modules\\varint\\encode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Cencode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\encode.js",}],
["F:\\metamask-extension\\node_modules\\varint\\index.js", {"./decode.js":"F:\\metamask-extension\\node_modules\\varint\\decode.js","./encode.js":"F:\\metamask-extension\\node_modules\\varint\\encode.js","./length.js":"F:\\metamask-extension\\node_modules\\varint\\length.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Cindex.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\index.js",}],
["F:\\metamask-extension\\node_modules\\varint\\length.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvarint%5Clength.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>varint",file:"node_modules\\varint\\length.js",}],
["F:\\metamask-extension\\node_modules\\vm-browserify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvm-browserify%5Cindex.js
      return function (require, module, exports) {
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.(0,eval)() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return (0,eval)(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

      };
    };
  }
  }
}, {package:"browserify>vm-browserify",file:"node_modules\\vm-browserify\\index.js",}],
["F:\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cwebextension-polyfill%5Cdist%5Cbrowser-polyfill.js
      return function (require, module, exports) {
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("webextension-polyfill", ["module"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.browser = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.8.0 - Tue Apr 20 2021 11:27:38 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (typeof browser === "undefined" || Object.getPrototypeOf(browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
    const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      }); // Keep track if the deprecation warning has been logged at least once.

      let loggedSendResponseDeprecationWarning = false;
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              if (!loggedSendResponseDeprecationWarning) {
                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                loggedSendResponseDeprecationWarning = true;
              }

              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    };

    if (typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
      throw new Error("This script should only be loaded in a browser extension.");
    } // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map

      };
    };
  }
  }
}, {package:"webextension-polyfill",file:"node_modules\\webextension-polyfill\\dist\\browser-polyfill.js",}],
["F:\\metamask-extension\\node_modules\\wrappy\\wrappy.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cwrappy%5Cwrappy.js
      return function (require, module, exports) {
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

      };
    };
  }
  }
}, {package:"pump>once>wrappy",file:"node_modules\\wrappy\\wrappy.js",}],
["F:\\metamask-extension\\node_modules\\xtend\\immutable.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cxtend%5Cimmutable.js
      return function (require, module, exports) {
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

      };
    };
  }
  }
}, {package:"watchify>xtend",file:"node_modules\\xtend\\immutable.js",}],
["F:\\metamask-extension\\node_modules\\yallist\\iterator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cyallist%5Citerator.js
      return function (require, module, exports) {
'use strict'
module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}

      };
    };
  }
  }
}, {package:"semver>lru-cache>yallist",file:"node_modules\\yallist\\iterator.js",}],
["F:\\metamask-extension\\node_modules\\yallist\\yallist.js", {"./iterator.js":"F:\\metamask-extension\\node_modules\\yallist\\iterator.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cyallist%5Cyallist.js
      return function (require, module, exports) {
'use strict'
module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist)
} catch (er) {}

      };
    };
  }
  }
}, {package:"semver>lru-cache>yallist",file:"node_modules\\yallist\\yallist.js",}],
["F:\\metamask-extension\\shared\\constants\\alerts.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Calerts.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Web3ShimUsageAlertStates = exports.TOGGLEABLE_ALERT_TYPES = exports.AlertTypes = void 0;
let AlertTypes = /*#__PURE__*/function (AlertTypes) {
  AlertTypes["unconnectedAccount"] = "unconnectedAccount";
  AlertTypes["web3ShimUsage"] = "web3ShimUsage";
  AlertTypes["invalidCustomNetwork"] = "invalidCustomNetwork";
  return AlertTypes;
}({});
/**
 * Alerts that can be enabled or disabled by the user.
 */
exports.AlertTypes = AlertTypes;
const TOGGLEABLE_ALERT_TYPES = [AlertTypes.unconnectedAccount, AlertTypes.web3ShimUsage];
exports.TOGGLEABLE_ALERT_TYPES = TOGGLEABLE_ALERT_TYPES;
let Web3ShimUsageAlertStates = /*#__PURE__*/function (Web3ShimUsageAlertStates) {
  Web3ShimUsageAlertStates[Web3ShimUsageAlertStates["recorded"] = 1] = "recorded";
  Web3ShimUsageAlertStates[Web3ShimUsageAlertStates["dismissed"] = 2] = "dismissed";
  return Web3ShimUsageAlertStates;
}({});
exports.Web3ShimUsageAlertStates = Web3ShimUsageAlertStates;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\alerts.ts",}],
["F:\\metamask-extension\\shared\\constants\\app.ts", {"./permissions":"F:\\metamask-extension\\shared\\constants\\permissions.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Capp.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNKNOWN_TICKER_SYMBOL = exports.POLLING_TOKEN_ENVIRONMENT_TYPES = exports.PLATFORM_OPERA = exports.PLATFORM_FIREFOX = exports.PLATFORM_EDGE = exports.PLATFORM_CHROME = exports.PLATFORM_BRAVE = exports.ORIGIN_METAMASK = exports.METAMASK_PROD_CHROME_ID = exports.METAMASK_MMI_PROD_CHROME_ID = exports.METAMASK_MMI_BETA_CHROME_ID = exports.METAMASK_FLASK_CHROME_ID = exports.METAMASK_BETA_CHROME_ID = exports.MESSAGE_TYPE = exports.FIREFOX_BUILD_IDS = exports.EXTENSION_MESSAGES = exports.ENVIRONMENT_TYPE_POPUP = exports.ENVIRONMENT_TYPE_NOTIFICATION = exports.ENVIRONMENT_TYPE_FULLSCREEN = exports.ENVIRONMENT_TYPE_BACKGROUND = exports.CHROME_BUILD_IDS = void 0;
var _permissions = require("./permissions");
/**
 * A string representing the type of environment the application is currently running in
 * popup - When the user click's the icon in their browser's extension bar; the default view
 * notification - When the extension opens due to interaction with a Web3 enabled website
 * fullscreen - When the user clicks 'expand view' to open the extension in a new tab
 * background - The background process that powers the extension
 */

const ENVIRONMENT_TYPE_POPUP = 'popup';
exports.ENVIRONMENT_TYPE_POPUP = ENVIRONMENT_TYPE_POPUP;
const ENVIRONMENT_TYPE_NOTIFICATION = 'notification';
exports.ENVIRONMENT_TYPE_NOTIFICATION = ENVIRONMENT_TYPE_NOTIFICATION;
const ENVIRONMENT_TYPE_FULLSCREEN = 'fullscreen';
exports.ENVIRONMENT_TYPE_FULLSCREEN = ENVIRONMENT_TYPE_FULLSCREEN;
const ENVIRONMENT_TYPE_BACKGROUND = 'background';
exports.ENVIRONMENT_TYPE_BACKGROUND = ENVIRONMENT_TYPE_BACKGROUND;
const PLATFORM_BRAVE = 'Brave';
exports.PLATFORM_BRAVE = PLATFORM_BRAVE;
const PLATFORM_CHROME = 'Chrome';
exports.PLATFORM_CHROME = PLATFORM_CHROME;
const PLATFORM_EDGE = 'Edge';
exports.PLATFORM_EDGE = PLATFORM_EDGE;
const PLATFORM_FIREFOX = 'Firefox';
exports.PLATFORM_FIREFOX = PLATFORM_FIREFOX;
const PLATFORM_OPERA = 'Opera';
exports.PLATFORM_OPERA = PLATFORM_OPERA;
const MESSAGE_TYPE = {
  ADD_ETHEREUM_CHAIN: 'wallet_addEthereumChain',
  ETH_ACCOUNTS: _permissions.RestrictedMethods.eth_accounts,
  ETH_DECRYPT: 'eth_decrypt',
  ETH_GET_ENCRYPTION_PUBLIC_KEY: 'eth_getEncryptionPublicKey',
  ETH_REQUEST_ACCOUNTS: 'eth_requestAccounts',
  ETH_SIGN: 'eth_sign',
  ETH_SIGN_TYPED_DATA: 'eth_signTypedData',
  ETH_SIGN_TYPED_DATA_V3: 'eth_signTypedData_v3',
  ETH_SIGN_TYPED_DATA_V4: 'eth_signTypedData_v4',
  GET_PROVIDER_STATE: 'metamask_getProviderState',
  LOG_WEB3_SHIM_USAGE: 'metamask_logWeb3ShimUsage',
  PERSONAL_SIGN: 'personal_sign',
  SEND_METADATA: 'metamask_sendDomainMetadata',
  SWITCH_ETHEREUM_CHAIN: 'wallet_switchEthereumChain',
  TRANSACTION: 'transaction',
  WALLET_REQUEST_PERMISSIONS: 'wallet_requestPermissions',
  WATCH_ASSET: 'wallet_watchAsset',
  WATCH_ASSET_LEGACY: 'metamask_watchAsset'
};

/**
 * Custom messages to send and be received by the extension
 */
exports.MESSAGE_TYPE = MESSAGE_TYPE;
const EXTENSION_MESSAGES = {
  CONNECTION_READY: 'CONNECTION_READY',
  READY: 'METAMASK_EXTENSION_READY'
};
exports.EXTENSION_MESSAGES = EXTENSION_MESSAGES;
const POLLING_TOKEN_ENVIRONMENT_TYPES = {
  [ENVIRONMENT_TYPE_POPUP]: 'popupGasPollTokens',
  [ENVIRONMENT_TYPE_NOTIFICATION]: 'notificationGasPollTokens',
  [ENVIRONMENT_TYPE_FULLSCREEN]: 'fullScreenGasPollTokens',
  [ENVIRONMENT_TYPE_BACKGROUND]: 'none'
};
exports.POLLING_TOKEN_ENVIRONMENT_TYPES = POLLING_TOKEN_ENVIRONMENT_TYPES;
const ORIGIN_METAMASK = 'metamask';
exports.ORIGIN_METAMASK = ORIGIN_METAMASK;
const METAMASK_BETA_CHROME_ID = 'pbbkamfgmaedccnfkmjcofcecjhfgldn';
exports.METAMASK_BETA_CHROME_ID = METAMASK_BETA_CHROME_ID;
const METAMASK_PROD_CHROME_ID = 'nkbihfbeogaeaoehlefnkodbefgpgknn';
exports.METAMASK_PROD_CHROME_ID = METAMASK_PROD_CHROME_ID;
const METAMASK_FLASK_CHROME_ID = 'ljfoeinjpaedjfecbmggjgodbgkmjkjk';
exports.METAMASK_FLASK_CHROME_ID = METAMASK_FLASK_CHROME_ID;
const METAMASK_MMI_BETA_CHROME_ID = 'kmbhbcbadohhhgdgihejcicbgcehoaeg';
exports.METAMASK_MMI_BETA_CHROME_ID = METAMASK_MMI_BETA_CHROME_ID;
const METAMASK_MMI_PROD_CHROME_ID = 'ikkihjamdhfiojpdbnfllpjigpneipbc';
exports.METAMASK_MMI_PROD_CHROME_ID = METAMASK_MMI_PROD_CHROME_ID;
const CHROME_BUILD_IDS = [METAMASK_BETA_CHROME_ID, METAMASK_PROD_CHROME_ID, METAMASK_FLASK_CHROME_ID, METAMASK_MMI_BETA_CHROME_ID, METAMASK_MMI_PROD_CHROME_ID];
exports.CHROME_BUILD_IDS = CHROME_BUILD_IDS;
const METAMASK_BETA_FIREFOX_ID = 'webextension-beta@metamask.io';
const METAMASK_PROD_FIREFOX_ID = 'webextension@metamask.io';
const METAMASK_FLASK_FIREFOX_ID = 'webextension-flask@metamask.io';
const FIREFOX_BUILD_IDS = [METAMASK_BETA_FIREFOX_ID, METAMASK_PROD_FIREFOX_ID, METAMASK_FLASK_FIREFOX_ID];
exports.FIREFOX_BUILD_IDS = FIREFOX_BUILD_IDS;
const UNKNOWN_TICKER_SYMBOL = 'UNKNOWN';
exports.UNKNOWN_TICKER_SYMBOL = UNKNOWN_TICKER_SYMBOL;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\app.ts",}],
["F:\\metamask-extension\\shared\\constants\\common.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Ccommon.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EtherDenomination = void 0;
let EtherDenomination = /*#__PURE__*/function (EtherDenomination) {
  EtherDenomination["ETH"] = "ETH";
  EtherDenomination["GWEI"] = "GWEI";
  EtherDenomination["WEI"] = "WEI";
  return EtherDenomination;
}({});
exports.EtherDenomination = EtherDenomination;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\common.ts",}],
["F:\\metamask-extension\\shared\\constants\\gas.ts", {"ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Cgas.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PriorityLevels = exports.NetworkCongestionThresholds = exports.MIN_GAS_LIMIT_HEX = exports.GasRecommendations = exports.GasEstimateTypes = exports.GAS_LIMITS = exports.EditGasModes = exports.CUSTOM_GAS_ESTIMATE = void 0;
var _ethereumjsUtil = require("ethereumjs-util");
const ONE_HUNDRED_THOUSAND = 100000;
const MIN_GAS_LIMIT_DEC = '21000';
const MIN_GAS_LIMIT_HEX = parseInt(MIN_GAS_LIMIT_DEC, 10).toString(16);
exports.MIN_GAS_LIMIT_HEX = MIN_GAS_LIMIT_HEX;
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: (0, _ethereumjsUtil.addHexPrefix)(MIN_GAS_LIMIT_HEX),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: (0, _ethereumjsUtil.addHexPrefix)(ONE_HUNDRED_THOUSAND.toString(16))
};

/**
 * @typedef {object} GasEstimateTypes
 * @property {'fee-market'} FEE_MARKET - A gas estimate for a fee market transaction generated by our gas estimation API.
 * @property {'legacy'} LEGACY - A gas estimate for a legacy Transaction generated by our gas estimation API.
 * @property {'eth_gasPrice'} ETH_GAS_PRICE - A gas estimate provided by the Ethereum node via eth_gasPrice.
 * @property {'none'} NONE - No gas estimate available.
 */

/**
 * These are already declared in @metamask/controllers but importing them from
 * that module and re-exporting causes the UI bundle size to expand beyond 4MB
 *
 * (TODO: This comment was added before @metamask/controllers was split up 
 * revisit now that @metamask/gas-fee-controller is available)
 *
 * @type {GasEstimateTypes}
 */
exports.GAS_LIMITS = GAS_LIMITS;
let GasEstimateTypes = /*#__PURE__*/function (GasEstimateTypes) {
  GasEstimateTypes["feeMarket"] = "fee-market";
  GasEstimateTypes["legacy"] = "legacy";
  GasEstimateTypes["ethGasPrice"] = "eth_gasPrice";
  GasEstimateTypes["none"] = "none";
  return GasEstimateTypes;
}({});
/**
 * These represent gas recommendation levels presented in the UI
 */
exports.GasEstimateTypes = GasEstimateTypes;
let GasRecommendations = /*#__PURE__*/function (GasRecommendations) {
  GasRecommendations["low"] = "low";
  GasRecommendations["medium"] = "medium";
  GasRecommendations["high"] = "high";
  return GasRecommendations;
}({});
/**
 * These represent types of gas estimation
 */
exports.GasRecommendations = GasRecommendations;
let PriorityLevels = /*#__PURE__*/function (PriorityLevels) {
  PriorityLevels["tenPercentIncreased"] = "tenPercentIncreased";
  PriorityLevels["low"] = "low";
  PriorityLevels["medium"] = "medium";
  PriorityLevels["high"] = "high";
  PriorityLevels["custom"] = "custom";
  PriorityLevels["dAppSuggested"] = "dappSuggested";
  PriorityLevels["dappSuggestedHigh"] = "dappSuggestedHigh";
  return PriorityLevels;
}({});
/**
 * Represents the user customizing their gas preference
 */
exports.PriorityLevels = PriorityLevels;
const CUSTOM_GAS_ESTIMATE = 'custom';

/**
 * These represent the different edit modes presented in the UI
 */
exports.CUSTOM_GAS_ESTIMATE = CUSTOM_GAS_ESTIMATE;
let EditGasModes = /*#__PURE__*/function (EditGasModes) {
  EditGasModes["speedUp"] = "speed-up";
  EditGasModes["cancel"] = "cancel";
  EditGasModes["modifyInPlace"] = "modify-in-place";
  EditGasModes["swaps"] = "swaps";
  return EditGasModes;
}({});
/**
 * Represents levels for `networkCongestion` (calculated along with gas fee
 * estimates; represents a number between 0 and 1) that we use to render the
 * network status slider on the send transaction screen and inform users when
 * gas fees are high
 */
exports.EditGasModes = EditGasModes;
let NetworkCongestionThresholds = /*#__PURE__*/function (NetworkCongestionThresholds) {
  NetworkCongestionThresholds[NetworkCongestionThresholds["notBusy"] = 0] = "notBusy";
  NetworkCongestionThresholds[NetworkCongestionThresholds["stable"] = 0.33] = "stable";
  NetworkCongestionThresholds[NetworkCongestionThresholds["busy"] = 0.66] = "busy";
  return NetworkCongestionThresholds;
}({});
exports.NetworkCongestionThresholds = NetworkCongestionThresholds;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\gas.ts",}],
["F:\\metamask-extension\\shared\\constants\\hardware-wallets.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Chardware-wallets.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebHIDConnectedStatuses = exports.LedgerTransportTypes = exports.LEDGER_USB_VENDOR_ID = exports.HardwareTransportStates = exports.HardwareKeyringType = exports.HardwareKeyringNames = exports.HardwareDeviceNames = exports.HardwareAffiliateTutorialLinks = exports.HardwareAffiliateLinks = void 0;
/**
 * Hardware wallets supported by MetaMask.
 */
let HardwareKeyringType = /*#__PURE__*/function (HardwareKeyringType) {
  HardwareKeyringType["ledger"] = "Ledger Hardware";
  HardwareKeyringType["trezor"] = "Trezor Hardware";
  HardwareKeyringType["lattice"] = "Lattice Hardware";
  HardwareKeyringType["qr"] = "QR Hardware Wallet Device";
  return HardwareKeyringType;
}({});
exports.HardwareKeyringType = HardwareKeyringType;
let HardwareKeyringNames = /*#__PURE__*/function (HardwareKeyringNames) {
  HardwareKeyringNames["ledger"] = "Ledger";
  HardwareKeyringNames["trezor"] = "Trezor";
  HardwareKeyringNames["lattice"] = "Lattice1";
  HardwareKeyringNames["qr"] = "QR";
  return HardwareKeyringNames;
}({});
exports.HardwareKeyringNames = HardwareKeyringNames;
let HardwareDeviceNames = /*#__PURE__*/function (HardwareDeviceNames) {
  HardwareDeviceNames["ledger"] = "ledger";
  HardwareDeviceNames["trezor"] = "trezor";
  HardwareDeviceNames["lattice"] = "lattice";
  HardwareDeviceNames["qr"] = "QR Hardware";
  return HardwareDeviceNames;
}({});
exports.HardwareDeviceNames = HardwareDeviceNames;
let HardwareTransportStates = /*#__PURE__*/function (HardwareTransportStates) {
  HardwareTransportStates["none"] = "NONE";
  HardwareTransportStates["verified"] = "VERIFIED";
  HardwareTransportStates["deviceOpenFailure"] = "DEVICE_OPEN_FAILURE";
  HardwareTransportStates["unknownFailure"] = "UNKNOWN_FAILURE";
  return HardwareTransportStates;
}({});
exports.HardwareTransportStates = HardwareTransportStates;
let HardwareAffiliateLinks = /*#__PURE__*/function (HardwareAffiliateLinks) {
  HardwareAffiliateLinks["ledger"] = "https://shop.ledger.com/?r=17c4991a03fa";
  HardwareAffiliateLinks["gridplus"] = "https://gridplus.io/?afmc=7p";
  HardwareAffiliateLinks["trezor"] = "https://shop.trezor.io/product/trezor-one-black?offer_id=35&aff_id=11009";
  HardwareAffiliateLinks["keystone"] = "https://keyst.one/metamask?rfsn=6088257.656b3e9&utm_source=refersion&utm_medium=affiliate&utm_campaign=6088257.656b3e9";
  HardwareAffiliateLinks["airgap"] = "https://airgap.it/";
  HardwareAffiliateLinks["coolwallet"] = "https://www.coolwallet.io/";
  HardwareAffiliateLinks["dcent"] = "https://dcentwallet.com/";
  return HardwareAffiliateLinks;
}({});
exports.HardwareAffiliateLinks = HardwareAffiliateLinks;
let HardwareAffiliateTutorialLinks = /*#__PURE__*/function (HardwareAffiliateTutorialLinks) {
  HardwareAffiliateTutorialLinks["ledger"] = "https://support.ledger.com/hc/en-us/articles/4404366864657-Set-up-and-use-MetaMask-to-access-your-Ledger-Ethereum-ETH-account?docs=true";
  HardwareAffiliateTutorialLinks["gridplus"] = "https://docs.gridplus.io/setup/metamask";
  HardwareAffiliateTutorialLinks["trezor"] = "https://wiki.trezor.io/Apps:MetaMask";
  HardwareAffiliateTutorialLinks["keystone"] = "https://support.keyst.one/3rd-party-wallets/eth-and-web3-wallets-keystone/bind-metamask-with-keystone";
  HardwareAffiliateTutorialLinks["airgap"] = "https://support.airgap.it/guides/metamask/";
  HardwareAffiliateTutorialLinks["coolwallet"] = "https://www.coolwallet.io/metamask-step-by-step-guides/";
  HardwareAffiliateTutorialLinks["dcent"] = "https://medium.com/dcentwallet/dcent-wallet-now-supports-qr-based-protocol-to-link-with-metamask-57555f02603f";
  return HardwareAffiliateTutorialLinks;
}({});
/**
 * Used for setting the users preference for ledger transport type
 */
exports.HardwareAffiliateTutorialLinks = HardwareAffiliateTutorialLinks;
let LedgerTransportTypes = /*#__PURE__*/function (LedgerTransportTypes) {
  LedgerTransportTypes["live"] = "ledgerLive";
  LedgerTransportTypes["webhid"] = "webhid";
  LedgerTransportTypes["u2f"] = "u2f";
  return LedgerTransportTypes;
}({});
exports.LedgerTransportTypes = LedgerTransportTypes;
let WebHIDConnectedStatuses = /*#__PURE__*/function (WebHIDConnectedStatuses) {
  WebHIDConnectedStatuses["connected"] = "connected";
  WebHIDConnectedStatuses["notConnected"] = "notConnected";
  WebHIDConnectedStatuses["unknown"] = "unknown";
  return WebHIDConnectedStatuses;
}({});
exports.WebHIDConnectedStatuses = WebHIDConnectedStatuses;
const LEDGER_USB_VENDOR_ID = '0x2c97';
exports.LEDGER_USB_VENDOR_ID = LEDGER_USB_VENDOR_ID;


      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\hardware-wallets.ts",}],
["F:\\metamask-extension\\shared\\constants\\keyring.ts", {"./hardware-wallets":"F:\\metamask-extension\\shared\\constants\\hardware-wallets.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Ckeyring.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyringType = exports.InternalKeyringType = void 0;
var _hardwareWallets = require("./hardware-wallets");
/**
 * These are the keyrings that are managed entirely by MetaMask.
 */
let InternalKeyringType = /*#__PURE__*/function (InternalKeyringType) {
  InternalKeyringType["hdKeyTree"] = "HD Key Tree";
  InternalKeyringType["imported"] = "Simple Key Pair";
  return InternalKeyringType;
}({});
/**
 * All keyrings supported by MetaMask.
 */
exports.InternalKeyringType = InternalKeyringType;
const KeyringType = {
  ..._hardwareWallets.HardwareKeyringType,
  ...InternalKeyringType
};
exports.KeyringType = KeyringType;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\keyring.ts",}],
["F:\\metamask-extension\\shared\\constants\\labels.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Clabels.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUNCATED_NAME_CHAR_LIMIT = exports.TRUNCATED_ADDRESS_START_CHARS = exports.TRUNCATED_ADDRESS_END_CHARS = void 0;
// The character limit on ENS names, nicknames and addresses before we truncate
const TRUNCATED_NAME_CHAR_LIMIT = 11;

// The number of characters to slice from the beginning of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`
exports.TRUNCATED_NAME_CHAR_LIMIT = TRUNCATED_NAME_CHAR_LIMIT;
const TRUNCATED_ADDRESS_START_CHARS = 5;

// The number of characters to slice from the end of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`
exports.TRUNCATED_ADDRESS_START_CHARS = TRUNCATED_ADDRESS_START_CHARS;
const TRUNCATED_ADDRESS_END_CHARS = 4;
exports.TRUNCATED_ADDRESS_END_CHARS = TRUNCATED_ADDRESS_END_CHARS;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\labels.ts",}],
["F:\\metamask-extension\\shared\\constants\\metametrics.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Cmetametrics.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REJECT_NOTIFICATION_CLOSE_SIG = exports.REJECT_NOTIFICATION_CLOSE = exports.MetaMetricsUserTrait = exports.MetaMetricsTransactionEventSource = exports.MetaMetricsTokenEventSource = exports.MetaMetricsSwapsEventSource = exports.MetaMetricsNetworkEventSource = exports.MetaMetricsEventUiCustomization = exports.MetaMetricsEventName = exports.MetaMetricsEventLocation = exports.MetaMetricsEventLinkType = exports.MetaMetricsEventKeyType = exports.MetaMetricsEventCategory = exports.MetaMetricsEventAccountType = exports.MetaMetricsEventAccountImportType = exports.MetaMetricsContextProp = exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = exports.METAMETRICS_ANONYMOUS_ID = void 0;
/**
 * Used to attach context of where the user was at in the application when the
 * event was triggered. Also included as full details of the current page in
 * page events.
 */
/**
 * The dapp that triggered an interaction (MetaMask only).
 */
/**
 * We attach context to every meta metrics event that help to qualify our
 * analytics. This type has all optional values because it represents a
 * returned object from a method call. Ideally app and userAgent are
 * defined on every event. This is confirmed in the getTrackMetaMetricsEvent
 * function, but still provides the consumer a way to override these values if
 * necessary.
 */
/**
 * Data sent to the `segment.track` method.
 */
/**
 * Data sent to MetaMetrics for page views.
 */
/**
 * Data sent to MetaMetrics for user traits.
 */
let MetaMetricsUserTrait = /*#__PURE__*/function (MetaMetricsUserTrait) {
  MetaMetricsUserTrait["AddressBookEntries"] = "address_book_entries";
  MetaMetricsUserTrait["InstallDateExt"] = "install_date_ext";
  MetaMetricsUserTrait["LedgerConnectionType"] = "ledger_connection_type";
  MetaMetricsUserTrait["NetworksAdded"] = "networks_added";
  MetaMetricsUserTrait["NetworksWithoutTicker"] = "networks_without_ticker";
  MetaMetricsUserTrait["NftAutodetectionEnabled"] = "nft_autodetection_enabled";
  MetaMetricsUserTrait["NumberOfAccounts"] = "number_of_accounts";
  MetaMetricsUserTrait["NumberOfNftCollections"] = "number_of_nft_collections";
  MetaMetricsUserTrait["NumberOfNfts"] = "number_of_nfts";
  MetaMetricsUserTrait["NumberOfTokens"] = "number_of_tokens";
  MetaMetricsUserTrait["OpenSeaApiEnabled"] = "opensea_api_enabled";
  MetaMetricsUserTrait["Theme"] = "theme";
  MetaMetricsUserTrait["ThreeBoxEnabled"] = "three_box_enabled";
  MetaMetricsUserTrait["TokenDetectionEnabled"] = "token_detection_enabled";
  MetaMetricsUserTrait["DesktopEnabled"] = "desktop_enabled";
  MetaMetricsUserTrait["SecurityProviders"] = "security_providers";
  return MetaMetricsUserTrait;
}({});
/**
 * Mixpanel converts the zero address value to a truly anonymous event, which
 * speeds up reporting
 */
exports.MetaMetricsUserTrait = MetaMetricsUserTrait;
const METAMETRICS_ANONYMOUS_ID = '0x0000000000000000';

/**
 * Used to identify events that are triggered by the background process.
 */
exports.METAMETRICS_ANONYMOUS_ID = METAMETRICS_ANONYMOUS_ID;
const METAMETRICS_BACKGROUND_PAGE_OBJECT = {
  path: '/background-process',
  title: 'Background Process',
  url: '/background-process'
};
exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = METAMETRICS_BACKGROUND_PAGE_OBJECT;
const REJECT_NOTIFICATION_CLOSE = 'Cancel Via Notification Close';
exports.REJECT_NOTIFICATION_CLOSE = REJECT_NOTIFICATION_CLOSE;
const REJECT_NOTIFICATION_CLOSE_SIG = 'Cancel Sig Request Via Notification Close';
exports.REJECT_NOTIFICATION_CLOSE_SIG = REJECT_NOTIFICATION_CLOSE_SIG;
let MetaMetricsEventName = /*#__PURE__*/function (MetaMetricsEventName) {
  MetaMetricsEventName["AccountAdded"] = "Account Added";
  MetaMetricsEventName["AccountAddSelected"] = "Account Add Selected";
  MetaMetricsEventName["AccountAddFailed"] = "Account Add Failed";
  MetaMetricsEventName["AccountPasswordCreated"] = "Account Password Created";
  MetaMetricsEventName["AccountReset"] = "Account Reset";
  MetaMetricsEventName["AccountRenamed"] = "Account Renamed";
  MetaMetricsEventName["AppInstalled"] = "App Installed";
  MetaMetricsEventName["AppUnlocked"] = "App Unlocked";
  MetaMetricsEventName["AppUnlockedFailed"] = "App Unlocked Failed";
  MetaMetricsEventName["AppLocked"] = "App Locked";
  MetaMetricsEventName["AppWindowExpanded"] = "App Window Expanded";
  MetaMetricsEventName["BridgeLinkClicked"] = "Bridge Link Clicked";
  MetaMetricsEventName["DecryptionApproved"] = "Decryption Approved";
  MetaMetricsEventName["DecryptionRejected"] = "Decryption Rejected";
  MetaMetricsEventName["DecryptionRequested"] = "Decryption Requested";
  MetaMetricsEventName["EncryptionPublicKeyApproved"] = "Encryption Approved";
  MetaMetricsEventName["EncryptionPublicKeyRejected"] = "Encryption Rejected";
  MetaMetricsEventName["EncryptionPublicKeyRequested"] = "Encryption Requested";
  MetaMetricsEventName["ExternalLinkClicked"] = "External Link Clicked";
  MetaMetricsEventName["KeyExportSelected"] = "Key Export Selected";
  MetaMetricsEventName["KeyExportRequested"] = "Key Export Requested";
  MetaMetricsEventName["KeyExportFailed"] = "Key Export Failed";
  MetaMetricsEventName["KeyExportCanceled"] = "Key Export Canceled";
  MetaMetricsEventName["KeyExportRevealed"] = "Key Material Revealed";
  MetaMetricsEventName["KeyExportCopied"] = "Key Material Copied";
  MetaMetricsEventName["KeyTokenDetectionSelected"] = "Key Token Detection Selected";
  MetaMetricsEventName["KeyGlobalSecurityToggleSelected"] = "Key Global Security/Privacy Settings";
  MetaMetricsEventName["KeyBalanceTokenPriceChecker"] = "Key Show Balance and Token Price Checker Settings";
  MetaMetricsEventName["KeyGasFeeEstimationBuySwapTokens"] = "Key Show Gas Fee Estimation, Buy Crypto and Swap Tokens";
  MetaMetricsEventName["KeyAutoDetectTokens"] = "Key Autodetect tokens";
  MetaMetricsEventName["KeyBatchAccountBalanceRequests"] = "Key Batch account balance requests";
  MetaMetricsEventName["MetricsOptIn"] = "Metrics Opt In";
  MetaMetricsEventName["MetricsOptOut"] = "Metrics Opt Out";
  MetaMetricsEventName["NavAccountMenuOpened"] = "Account Menu Opened";
  MetaMetricsEventName["NavAccountDetailsOpened"] = "Account Details Opened";
  MetaMetricsEventName["NavConnectedSitesOpened"] = "Connected Sites Opened";
  MetaMetricsEventName["NavMainMenuOpened"] = "Main Menu Opened";
  MetaMetricsEventName["NavNetworkMenuOpened"] = "Network Menu Opened";
  MetaMetricsEventName["NavSettingsOpened"] = "Settings Opened";
  MetaMetricsEventName["NavAccountSwitched"] = "Account Switched";
  MetaMetricsEventName["NavNetworkSwitched"] = "Network Switched";
  MetaMetricsEventName["NavBuyButtonClicked"] = "Buy Button Clicked";
  MetaMetricsEventName["NavSendButtonClicked"] = "Send Button Clicked";
  MetaMetricsEventName["NavSwapButtonClicked"] = "Swap Button Clicked";
  MetaMetricsEventName["NftAdded"] = "NFT Added";
  MetaMetricsEventName["OnboardingWelcome"] = "App Installed";
  MetaMetricsEventName["OnboardingWalletCreationStarted"] = "Wallet Setup Selected";
  MetaMetricsEventName["OnboardingWalletImportStarted"] = "Wallet Import Started";
  MetaMetricsEventName["OnboardingWalletCreationAttempted"] = "Wallet Password Created";
  MetaMetricsEventName["OnboardingWalletSecurityStarted"] = "SRP Backup Selected";
  MetaMetricsEventName["OnboardingWalletSecuritySkipInitiated"] = "SRP Skip Backup Selected";
  MetaMetricsEventName["OnboardingWalletSecuritySkipConfirmed"] = "SRP Backup Skipped";
  MetaMetricsEventName["OnboardingWalletSecuritySkipCanceled"] = "SRP Skip Backup Canceled";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseRevealed"] = "SRP Revealed";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseWrittenDown"] = "SRP Backup Confirm Display";
  MetaMetricsEventName["OnboardingWalletSecurityPhraseConfirmed"] = "SRP Backup Confirmed";
  MetaMetricsEventName["OnboardingWalletCreationComplete"] = "Wallet Created";
  MetaMetricsEventName["OnboardingWalletSetupComplete"] = "Application Opened";
  MetaMetricsEventName["OnboardingWalletAdvancedSettings"] = "Settings Updated";
  MetaMetricsEventName["OnboardingWalletImportAttempted"] = "Wallet Import Attempted";
  MetaMetricsEventName["OnboardingWalletVideoPlay"] = "SRP Intro Video Played";
  MetaMetricsEventName["OnboardingTwitterClick"] = "External Link Clicked";
  MetaMetricsEventName["OnrampProviderSelected"] = "On-ramp Provider Selected";
  MetaMetricsEventName["PermissionsApproved"] = "Permissions Approved";
  MetaMetricsEventName["PermissionsRejected"] = "Permissions Rejected";
  MetaMetricsEventName["PermissionsRequested"] = "Permissions Requested";
  MetaMetricsEventName["PhishingPageDisplayed"] = "Phishing Page Displayed";
  MetaMetricsEventName["PortfolioLinkClicked"] = "Portfolio Link Clicked";
  MetaMetricsEventName["ProviderMethodCalled"] = "Provider Method Called";
  MetaMetricsEventName["PublicAddressCopied"] = "Public Address Copied";
  MetaMetricsEventName["ServiceWorkerRestarted"] = "Service Worker Restarted";
  MetaMetricsEventName["SignatureApproved"] = "Signature Approved";
  MetaMetricsEventName["SignatureFailed"] = "Signature Failed";
  MetaMetricsEventName["SignatureRejected"] = "Signature Rejected";
  MetaMetricsEventName["SignatureRequested"] = "Signature Requested";
  MetaMetricsEventName["SrpRevealStarted"] = "Reveal SRP Initiated";
  MetaMetricsEventName["SrpRevealClicked"] = "Clicked Reveal Secret Recovery";
  MetaMetricsEventName["SrpRevealViewed"] = "Views Reveal Secret Recovery";
  MetaMetricsEventName["SrpRevealBackButtonClicked"] = "Clicked Back on Reveal SRP Password Page";
  MetaMetricsEventName["SrpRevealCancelled"] = "Reveal SRP Cancelled";
  MetaMetricsEventName["SrpRevealCancelButtonClicked"] = "Clicks Cancel on Reveal Secret Recovery Phrase Page";
  MetaMetricsEventName["SrpRevealCloseClicked"] = "Clicks CLOSE with SRP";
  MetaMetricsEventName["SrpRevealNextClicked"] = "Clicks Next on Reveal Secret Recovery Phrase";
  MetaMetricsEventName["SrpHoldToRevealClickStarted"] = "Reveal SRP Click Started";
  MetaMetricsEventName["SrpHoldToRevealCloseClicked"] = "Closes Hold To Reveal SRP";
  MetaMetricsEventName["SrpHoldToRevealCompleted"] = "Reveal SRP Completed";
  MetaMetricsEventName["SrpViewsSrpQR"] = "Views SRP QR Code";
  MetaMetricsEventName["SrpViewSrpText"] = "Views SRP";
  MetaMetricsEventName["SrpCopiedToClipboard"] = "Copies SRP to clipboard";
  MetaMetricsEventName["SrpToConfirmBackup"] = "SRP Backup Confirm Displayed";
  MetaMetricsEventName["SupportLinkClicked"] = "Support Link Clicked";
  MetaMetricsEventName["TermsOfUseShown"] = "Terms of Use Shown";
  MetaMetricsEventName["TermsOfUseAccepted"] = "Terms of Use Accepted";
  MetaMetricsEventName["TokenImportButtonClicked"] = "Import Token Button Clicked";
  MetaMetricsEventName["TokenScreenOpened"] = "Token Screen Opened";
  MetaMetricsEventName["TokenAdded"] = "Token Added";
  MetaMetricsEventName["TokenDetected"] = "Token Detected";
  MetaMetricsEventName["TokenHidden"] = "Token Hidden";
  MetaMetricsEventName["TokenImportCanceled"] = "Token Import Canceled";
  MetaMetricsEventName["TokenImportClicked"] = "Token Import Clicked";
  MetaMetricsEventName["WalletSetupStarted"] = "Wallet Setup Selected";
  MetaMetricsEventName["WalletSetupCanceled"] = "Wallet Setup Canceled";
  MetaMetricsEventName["WalletSetupFailed"] = "Wallet Setup Failed";
  MetaMetricsEventName["WalletCreated"] = "Wallet Created";
  MetaMetricsEventName["AccountDetailMenuOpened"] = "Account Details Menu Opened";
  MetaMetricsEventName["BlockExplorerLinkClicked"] = "Block Explorer Clicked";
  MetaMetricsEventName["AccountRemoved"] = "Account Removed";
  MetaMetricsEventName["TestNetworksDisplayed"] = "Test Networks Displayed";
  MetaMetricsEventName["AddNetworkButtonClick"] = "Add Network Button Clicked";
  MetaMetricsEventName["CustomNetworkAdded"] = "Custom Network Added";
  MetaMetricsEventName["TokenDetailsOpened"] = "Token Details Opened";
  MetaMetricsEventName["NftScreenOpened"] = "NFT Screen Opened";
  MetaMetricsEventName["ActivityScreenOpened"] = "Activity Screen Opened";
  MetaMetricsEventName["WhatsNewViewed"] = "What's New Viewed";
  MetaMetricsEventName["WhatsNewClicked"] = "What's New Link Clicked";
  return MetaMetricsEventName;
}({});
exports.MetaMetricsEventName = MetaMetricsEventName;
let MetaMetricsEventAccountType = /*#__PURE__*/function (MetaMetricsEventAccountType) {
  MetaMetricsEventAccountType["Default"] = "metamask";
  MetaMetricsEventAccountType["Hardware"] = "hardware";
  MetaMetricsEventAccountType["Imported"] = "imported";
  return MetaMetricsEventAccountType;
}({});
exports.MetaMetricsEventAccountType = MetaMetricsEventAccountType;
let MetaMetricsEventAccountImportType = /*#__PURE__*/function (MetaMetricsEventAccountImportType) {
  MetaMetricsEventAccountImportType["Json"] = "json";
  MetaMetricsEventAccountImportType["PrivateKey"] = "private_key";
  MetaMetricsEventAccountImportType["Srp"] = "srp";
  return MetaMetricsEventAccountImportType;
}({});
exports.MetaMetricsEventAccountImportType = MetaMetricsEventAccountImportType;
let MetaMetricsEventCategory = /*#__PURE__*/function (MetaMetricsEventCategory) {
  MetaMetricsEventCategory["Accounts"] = "Accounts";
  MetaMetricsEventCategory["App"] = "App";
  MetaMetricsEventCategory["Auth"] = "Auth";
  MetaMetricsEventCategory["Background"] = "Background";
  MetaMetricsEventCategory["Desktop"] = "Desktop";
  MetaMetricsEventCategory["Error"] = "Error";
  MetaMetricsEventCategory["Footer"] = "Footer";
  MetaMetricsEventCategory["Home"] = "Home";
  MetaMetricsEventCategory["InpageProvider"] = "inpage_provider";
  MetaMetricsEventCategory["Keys"] = "Keys";
  MetaMetricsEventCategory["Messages"] = "Messages";
  MetaMetricsEventCategory["Navigation"] = "Navigation";
  MetaMetricsEventCategory["Network"] = "Network";
  MetaMetricsEventCategory["Onboarding"] = "Onboarding";
  MetaMetricsEventCategory["Phishing"] = "Phishing";
  MetaMetricsEventCategory["Retention"] = "Retention";
  MetaMetricsEventCategory["ServiceWorkers"] = "service_workers";
  MetaMetricsEventCategory["Settings"] = "Settings";
  MetaMetricsEventCategory["Snaps"] = "Snaps";
  MetaMetricsEventCategory["Swaps"] = "Swaps";
  MetaMetricsEventCategory["Transactions"] = "Transactions";
  MetaMetricsEventCategory["Wallet"] = "Wallet";
  MetaMetricsEventCategory["Tokens"] = "Tokens";
  return MetaMetricsEventCategory;
}({});
exports.MetaMetricsEventCategory = MetaMetricsEventCategory;
let MetaMetricsEventLinkType = /*#__PURE__*/function (MetaMetricsEventLinkType) {
  MetaMetricsEventLinkType["AccountTracker"] = "Account Tracker";
  MetaMetricsEventLinkType["BlockExplorer"] = "Block Explorer";
  MetaMetricsEventLinkType["TokenTracker"] = "Token Tracker";
  MetaMetricsEventLinkType["TransactionBlockExplorer"] = "Transaction Block Explorer";
  return MetaMetricsEventLinkType;
}({});
exports.MetaMetricsEventLinkType = MetaMetricsEventLinkType;
let MetaMetricsEventKeyType = /*#__PURE__*/function (MetaMetricsEventKeyType) {
  MetaMetricsEventKeyType["Pkey"] = "private_key";
  MetaMetricsEventKeyType["Srp"] = "srp";
  return MetaMetricsEventKeyType;
}({});
exports.MetaMetricsEventKeyType = MetaMetricsEventKeyType;
let MetaMetricsNetworkEventSource = /*#__PURE__*/function (MetaMetricsNetworkEventSource) {
  MetaMetricsNetworkEventSource["CustomNetworkForm"] = "custom_network_form";
  MetaMetricsNetworkEventSource["PopularNetworkList"] = "popular_network_list";
  MetaMetricsNetworkEventSource["Dapp"] = "dapp";
  return MetaMetricsNetworkEventSource;
}({});
exports.MetaMetricsNetworkEventSource = MetaMetricsNetworkEventSource;
let MetaMetricsSwapsEventSource = /*#__PURE__*/function (MetaMetricsSwapsEventSource) {
  MetaMetricsSwapsEventSource["MainView"] = "Main View";
  MetaMetricsSwapsEventSource["TokenView"] = "Token View";
  return MetaMetricsSwapsEventSource;
}({});
exports.MetaMetricsSwapsEventSource = MetaMetricsSwapsEventSource;
let MetaMetricsTokenEventSource = /*#__PURE__*/function (MetaMetricsTokenEventSource) {
  MetaMetricsTokenEventSource["Custom"] = "custom";
  MetaMetricsTokenEventSource["Dapp"] = "dapp";
  MetaMetricsTokenEventSource["Detected"] = "detected";
  MetaMetricsTokenEventSource["List"] = "list";
  return MetaMetricsTokenEventSource;
}({});
exports.MetaMetricsTokenEventSource = MetaMetricsTokenEventSource;
let MetaMetricsTransactionEventSource = /*#__PURE__*/function (MetaMetricsTransactionEventSource) {
  MetaMetricsTransactionEventSource["Dapp"] = "dapp";
  MetaMetricsTransactionEventSource["User"] = "user";
  return MetaMetricsTransactionEventSource;
}({});
exports.MetaMetricsTransactionEventSource = MetaMetricsTransactionEventSource;
let MetaMetricsEventLocation = /*#__PURE__*/function (MetaMetricsEventLocation) {
  MetaMetricsEventLocation["TokenDetails"] = "token_details";
  MetaMetricsEventLocation["TokenDetection"] = "token_detection";
  MetaMetricsEventLocation["TokenMenu"] = "token_menu";
  return MetaMetricsEventLocation;
}({});
exports.MetaMetricsEventLocation = MetaMetricsEventLocation;
let MetaMetricsEventUiCustomization = /*#__PURE__*/function (MetaMetricsEventUiCustomization) {
  MetaMetricsEventUiCustomization["FlaggedAsMalicious"] = "flagged_as_malicious";
  MetaMetricsEventUiCustomization["FlaggedAsSafetyUnknown"] = "flagged_as_safety_unknown";
  MetaMetricsEventUiCustomization["Siwe"] = "sign_in_with_ethereum";
  return MetaMetricsEventUiCustomization;
}({});
/**
 * Values that can used in the "properties" tracking object as keys, e.g. `{
 * location: 'Home' }`.
 */
exports.MetaMetricsEventUiCustomization = MetaMetricsEventUiCustomization;
let MetaMetricsContextProp = /*#__PURE__*/function (MetaMetricsContextProp) {
  MetaMetricsContextProp["PageTitle"] = "location";
  return MetaMetricsContextProp;
}({});
exports.MetaMetricsContextProp = MetaMetricsContextProp;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\metametrics.ts",}],
["F:\\metamask-extension\\shared\\constants\\network.ts", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Cnetwork.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.infuraProjectId = exports.getRpcUrl = exports.UNSUPPORTED_RPC_METHODS = exports.TEST_NETWORK_TICKER_MAP = exports.TEST_ETH_TOKEN_IMAGE_URL = exports.TEST_CHAINS = exports.SEPOLIA_RPC_URL = exports.SEPOLIA_DISPLAY_NAME = exports.POLYGON_DISPLAY_NAME = exports.PALM_TOKEN_IMAGE_URL = exports.PALM_DISPLAY_NAME = exports.OPTIMISM_TOKEN_IMAGE_URL = exports.OPTIMISM_DISPLAY_NAME = exports.NetworkStatus = exports.NETWORK_TYPES = exports.NETWORK_TO_NAME_MAP = exports.NETWORK_NAMES = exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = exports.NETWORK_IDS = exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = exports.MAX_SAFE_CHAIN_ID = exports.MATIC_TOKEN_IMAGE_URL = exports.MAINNET_RPC_URL = exports.MAINNET_DISPLAY_NAME = exports.LOCALHOST_RPC_URL = exports.LOCALHOST_DISPLAY_NAME = exports.LINEA_MAINNET_TOKEN_IMAGE_URL = exports.LINEA_MAINNET_RPC_URL = exports.LINEA_MAINNET_DISPLAY_NAME = exports.LINEA_GOERLI_TOKEN_IMAGE_URL = exports.LINEA_GOERLI_RPC_URL = exports.LINEA_GOERLI_DISPLAY_NAME = exports.IPFS_DEFAULT_GATEWAY_URL = exports.INFURA_PROVIDER_TYPES = exports.INFURA_BLOCKED_KEY = exports.HARMONY_ONE_TOKEN_IMAGE_URL = exports.HARMONY_DISPLAY_NAME = exports.GOERLI_RPC_URL = exports.GOERLI_DISPLAY_NAME = exports.FTM_TOKEN_IMAGE_URL = exports.FEATURED_RPCS = exports.FANTOM_DISPLAY_NAME = exports.ETH_TOKEN_IMAGE_URL = exports.ETHERSCAN_SUPPORTED_NETWORKS = exports.CURRENCY_SYMBOLS = exports.CHAIN_ID_TO_TYPE_MAP = exports.CHAIN_ID_TO_RPC_URL_MAP = exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = exports.CHAIN_ID_TO_NETWORK_ID_MAP = exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = exports.CHAIN_IDS = exports.CELO_TOKEN_IMAGE_URL = exports.CELO_DISPLAY_NAME = exports.BUYABLE_CHAINS_MAP = exports.BUILT_IN_NETWORKS = exports.BUILT_IN_INFURA_NETWORKS = exports.BSC_DISPLAY_NAME = exports.BNB_TOKEN_IMAGE_URL = exports.BNB_DISPLAY_NAME = exports.AVAX_TOKEN_IMAGE_URL = exports.AVALANCHE_DISPLAY_NAME = exports.AURORA_TOKEN_IMAGE_URL = exports.AURORA_DISPLAY_NAME = exports.ARBITRUM_DISPLAY_NAME = exports.AETH_TOKEN_IMAGE_URL = void 0;
var _lodash = require("lodash");
/**
 * A type representing any valid value for 'type' for setProviderType and other
 * methods that add or manipulate networks in MetaMask state.
 */

/**
 * A union type of all possible hard-coded chain ids. This type is not
 * exhaustive and cannot be used for typing chainId in areas where the user or
 * dapp may specify any chainId.
 */

/**
 * A type that is a union type of all possible hardcoded currency symbols.
 * This type is non-exhaustive, and cannot be used for areas where the user
 * or dapp may supply their own symbol.
 */

/**
 * Test networks have special symbols that combine the network name and 'ETH'
 * so that they are distinct from mainnet and other networks that use 'ETH'.
 */

/**
 * An object containing preferences for an RPC definition
 */

/**
 * An object that describes a network to be used inside of MetaMask
 */

/**
 * For each chain that we support fiat onramps for, we provide a set of
 * configuration options that help for initializing the connectiong to the
 * onramp providers.
 */

/**
 * Throughout the extension we set the current provider by referencing its
 * "type", which can be any of the values in the below object. These values
 * represent the built-in networks of MetaMask, including test nets, as well
 * as "rpc" which is the "type" of a custom network added by the user or via
 * wallet_addEthereumChain.
 */
const NETWORK_TYPES = {
  GOERLI: 'goerli',
  LOCALHOST: 'localhost',
  MAINNET: 'mainnet',
  RPC: 'rpc',
  SEPOLIA: 'sepolia',
  LINEA_GOERLI: 'linea-goerli',
  LINEA_MAINNET: 'linea-mainnet'
};

/**
 * An object containing shortcut names for any non-builtin network. We need
 * this to be able to differentiate between networks that require custom
 * sections of code for our various features, such as swaps or token lists.
 */
exports.NETWORK_TYPES = NETWORK_TYPES;
const NETWORK_NAMES = {
  HOMESTEAD: 'homestead'
};

/**
 * The Network ID for our builtin networks. This is the decimal equivalent of
 * the chain id for the network, but is expresssed as a string. Many moons ago
 * the decision was made on the extension team to expressly use chainId with
 * hex encoding over network id. Consider that when accessing this object. Note
 * for cross product purposes: alignment with mobile on this matter has not
 * been fully achieved, thus it is possible for some dependencies to still
 * ask for or require network id.
 */
exports.NETWORK_NAMES = NETWORK_NAMES;
const NETWORK_IDS = {
  MAINNET: '1',
  GOERLI: '5',
  LOCALHOST: '1337',
  SEPOLIA: '11155111',
  LINEA_GOERLI: '59140',
  LINEA_MAINNET: '59144'
};

/**
 * An object containing all of the chain ids for networks both built in and
 * those that we have added custom code to support our feature set.
 */
exports.NETWORK_IDS = NETWORK_IDS;
const CHAIN_IDS = {
  MAINNET: '0x1',
  GOERLI: '0x5',
  LOCALHOST: '0x539',
  BSC: '0x38',
  BSC_TESTNET: '0x61',
  OPTIMISM: '0xa',
  OPTIMISM_TESTNET: '0x1a4',
  POLYGON: '0x89',
  POLYGON_TESTNET: '0x13881',
  AVALANCHE: '0xa86a',
  AVALANCHE_TESTNET: '0xa869',
  FANTOM: '0xfa',
  FANTOM_TESTNET: '0xfa2',
  CELO: '0xa4ec',
  ARBITRUM: '0xa4b1',
  HARMONY: '0x63564c40',
  PALM: '0x2a15c308d',
  SEPOLIA: '0xaa36a7',
  LINEA_GOERLI: '0xe704',
  LINEA_MAINNET: '0xe708',
  AURORA: '0x4e454152',
  MOONBEAM: '0x504',
  MOONBEAM_TESTNET: '0x507',
  MOONRIVER: '0x505',
  CRONOS: '0x19'
};

/**
 * The largest possible chain ID we can handle.
 * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553
 */
exports.CHAIN_IDS = CHAIN_IDS;
const MAX_SAFE_CHAIN_ID = 4503599627370476;
exports.MAX_SAFE_CHAIN_ID = MAX_SAFE_CHAIN_ID;
const MAINNET_DISPLAY_NAME = 'Ethereum Mainnet';
exports.MAINNET_DISPLAY_NAME = MAINNET_DISPLAY_NAME;
const GOERLI_DISPLAY_NAME = 'Goerli';
exports.GOERLI_DISPLAY_NAME = GOERLI_DISPLAY_NAME;
const SEPOLIA_DISPLAY_NAME = 'Sepolia';
exports.SEPOLIA_DISPLAY_NAME = SEPOLIA_DISPLAY_NAME;
const LINEA_GOERLI_DISPLAY_NAME = 'Linea Goerli';
exports.LINEA_GOERLI_DISPLAY_NAME = LINEA_GOERLI_DISPLAY_NAME;
const LINEA_MAINNET_DISPLAY_NAME = 'Linea Mainnet';
exports.LINEA_MAINNET_DISPLAY_NAME = LINEA_MAINNET_DISPLAY_NAME;
const LOCALHOST_DISPLAY_NAME = 'Localhost 8545';
exports.LOCALHOST_DISPLAY_NAME = LOCALHOST_DISPLAY_NAME;
const BSC_DISPLAY_NAME = 'Binance Smart Chain';
exports.BSC_DISPLAY_NAME = BSC_DISPLAY_NAME;
const POLYGON_DISPLAY_NAME = 'Polygon';
exports.POLYGON_DISPLAY_NAME = POLYGON_DISPLAY_NAME;
const AVALANCHE_DISPLAY_NAME = 'Avalanche Network C-Chain';
exports.AVALANCHE_DISPLAY_NAME = AVALANCHE_DISPLAY_NAME;
const ARBITRUM_DISPLAY_NAME = 'Arbitrum One';
exports.ARBITRUM_DISPLAY_NAME = ARBITRUM_DISPLAY_NAME;
const BNB_DISPLAY_NAME = 'BNB Chain';
exports.BNB_DISPLAY_NAME = BNB_DISPLAY_NAME;
const OPTIMISM_DISPLAY_NAME = 'Optimism';
exports.OPTIMISM_DISPLAY_NAME = OPTIMISM_DISPLAY_NAME;
const FANTOM_DISPLAY_NAME = 'Fantom Opera';
exports.FANTOM_DISPLAY_NAME = FANTOM_DISPLAY_NAME;
const HARMONY_DISPLAY_NAME = 'Harmony Mainnet Shard 0';
exports.HARMONY_DISPLAY_NAME = HARMONY_DISPLAY_NAME;
const PALM_DISPLAY_NAME = 'Palm';
exports.PALM_DISPLAY_NAME = PALM_DISPLAY_NAME;
const AURORA_DISPLAY_NAME = 'Aurora Mainnet';
exports.AURORA_DISPLAY_NAME = AURORA_DISPLAY_NAME;
const CELO_DISPLAY_NAME = 'Celo Mainnet';
exports.CELO_DISPLAY_NAME = CELO_DISPLAY_NAME;
const infuraProjectId = "7e2c49dd161e4ddebc355d9fecfb9249";
exports.infuraProjectId = infuraProjectId;
const getRpcUrl = ({
  network,
  excludeProjectId = false
}) => `https://${network}.infura.io/v3/${excludeProjectId ? '' : infuraProjectId}`;
exports.getRpcUrl = getRpcUrl;
const MAINNET_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.MAINNET
});
exports.MAINNET_RPC_URL = MAINNET_RPC_URL;
const GOERLI_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.GOERLI
});
exports.GOERLI_RPC_URL = GOERLI_RPC_URL;
const SEPOLIA_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.SEPOLIA
});
exports.SEPOLIA_RPC_URL = SEPOLIA_RPC_URL;
const LINEA_GOERLI_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.LINEA_GOERLI
});
exports.LINEA_GOERLI_RPC_URL = LINEA_GOERLI_RPC_URL;
const LINEA_MAINNET_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.LINEA_MAINNET
});
exports.LINEA_MAINNET_RPC_URL = LINEA_MAINNET_RPC_URL;
const LOCALHOST_RPC_URL = 'http://localhost:8545';

/**
 * An object containing the token symbols for various tokens that are either
 * native currencies or those that have been special cased by the extension
 * for supporting our feature set.
 */
exports.LOCALHOST_RPC_URL = LOCALHOST_RPC_URL;
const CURRENCY_SYMBOLS = {
  ARBITRUM: 'ETH',
  AURORA_ETH: 'AURORA ETH',
  AVALANCHE: 'AVAX',
  BNB: 'BNB',
  BUSD: 'BUSD',
  CELO: 'CELO',
  DAI: 'DAI',
  ETH: 'ETH',
  FANTOM: 'FTM',
  HARMONY: 'ONE',
  PALM: 'PALM',
  MATIC: 'MATIC',
  TEST_ETH: 'TESTETH',
  USDC: 'USDC',
  USDT: 'USDT',
  WETH: 'WETH',
  OPTIMISM: 'OP',
  CRONOS: 'CRO',
  GLIMMER: 'GLMR',
  MOONRIVER: 'MOVR',
  ONE: 'ONE'
};
exports.CURRENCY_SYMBOLS = CURRENCY_SYMBOLS;
const ETH_TOKEN_IMAGE_URL = './images/eth_logo.png';
exports.ETH_TOKEN_IMAGE_URL = ETH_TOKEN_IMAGE_URL;
const LINEA_GOERLI_TOKEN_IMAGE_URL = './images/linea-logo-testnet.png';
exports.LINEA_GOERLI_TOKEN_IMAGE_URL = LINEA_GOERLI_TOKEN_IMAGE_URL;
const LINEA_MAINNET_TOKEN_IMAGE_URL = './images/linea-logo-mainnet.png';
exports.LINEA_MAINNET_TOKEN_IMAGE_URL = LINEA_MAINNET_TOKEN_IMAGE_URL;
const TEST_ETH_TOKEN_IMAGE_URL = './images/black-eth-logo.svg';
exports.TEST_ETH_TOKEN_IMAGE_URL = TEST_ETH_TOKEN_IMAGE_URL;
const BNB_TOKEN_IMAGE_URL = './images/bnb.png';
exports.BNB_TOKEN_IMAGE_URL = BNB_TOKEN_IMAGE_URL;
const MATIC_TOKEN_IMAGE_URL = './images/matic-token.png';
exports.MATIC_TOKEN_IMAGE_URL = MATIC_TOKEN_IMAGE_URL;
const AVAX_TOKEN_IMAGE_URL = './images/avax-token.png';
exports.AVAX_TOKEN_IMAGE_URL = AVAX_TOKEN_IMAGE_URL;
const AETH_TOKEN_IMAGE_URL = './images/arbitrum.svg';
exports.AETH_TOKEN_IMAGE_URL = AETH_TOKEN_IMAGE_URL;
const FTM_TOKEN_IMAGE_URL = './images/fantom-opera.svg';
exports.FTM_TOKEN_IMAGE_URL = FTM_TOKEN_IMAGE_URL;
const HARMONY_ONE_TOKEN_IMAGE_URL = './images/harmony-one.svg';
exports.HARMONY_ONE_TOKEN_IMAGE_URL = HARMONY_ONE_TOKEN_IMAGE_URL;
const OPTIMISM_TOKEN_IMAGE_URL = './images/optimism.svg';
exports.OPTIMISM_TOKEN_IMAGE_URL = OPTIMISM_TOKEN_IMAGE_URL;
const PALM_TOKEN_IMAGE_URL = './images/palm.svg';
exports.PALM_TOKEN_IMAGE_URL = PALM_TOKEN_IMAGE_URL;
const AURORA_TOKEN_IMAGE_URL = './images/aurora.png';
exports.AURORA_TOKEN_IMAGE_URL = AURORA_TOKEN_IMAGE_URL;
const CELO_TOKEN_IMAGE_URL = './images/celo.svg';
exports.CELO_TOKEN_IMAGE_URL = CELO_TOKEN_IMAGE_URL;
const INFURA_PROVIDER_TYPES = [NETWORK_TYPES.MAINNET, NETWORK_TYPES.GOERLI, NETWORK_TYPES.SEPOLIA, NETWORK_TYPES.LINEA_GOERLI, NETWORK_TYPES.LINEA_MAINNET];
exports.INFURA_PROVIDER_TYPES = INFURA_PROVIDER_TYPES;
const TEST_CHAINS = [CHAIN_IDS.GOERLI, CHAIN_IDS.SEPOLIA, CHAIN_IDS.LINEA_GOERLI, CHAIN_IDS.LOCALHOST];
exports.TEST_CHAINS = TEST_CHAINS;
const typedCapitalize = k => (0, _lodash.capitalize)(k);
const TEST_NETWORK_TICKER_MAP = {
  [NETWORK_TYPES.GOERLI]: `${typedCapitalize(NETWORK_TYPES.GOERLI)}${CURRENCY_SYMBOLS.ETH}`,
  [NETWORK_TYPES.SEPOLIA]: `${typedCapitalize(NETWORK_TYPES.SEPOLIA)}${CURRENCY_SYMBOLS.ETH}`,
  [NETWORK_TYPES.LINEA_GOERLI]: `Linea${CURRENCY_SYMBOLS.ETH}`
};

/**
 * Map of all build-in Infura networks to their network, ticker and chain IDs.
 */
exports.TEST_NETWORK_TICKER_MAP = TEST_NETWORK_TICKER_MAP;
const BUILT_IN_NETWORKS = {
  [NETWORK_TYPES.GOERLI]: {
    networkId: NETWORK_IDS.GOERLI,
    chainId: CHAIN_IDS.GOERLI,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.GOERLI],
    blockExplorerUrl: `https://${NETWORK_TYPES.GOERLI}.etherscan.io`
  },
  [NETWORK_TYPES.SEPOLIA]: {
    networkId: NETWORK_IDS.SEPOLIA,
    chainId: CHAIN_IDS.SEPOLIA,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
    blockExplorerUrl: `https://${NETWORK_TYPES.SEPOLIA}.etherscan.io`
  },
  [NETWORK_TYPES.LINEA_GOERLI]: {
    networkId: NETWORK_IDS.LINEA_GOERLI,
    chainId: CHAIN_IDS.LINEA_GOERLI,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.LINEA_GOERLI],
    blockExplorerUrl: 'https://goerli.lineascan.build'
  },
  [NETWORK_TYPES.MAINNET]: {
    networkId: NETWORK_IDS.MAINNET,
    chainId: CHAIN_IDS.MAINNET,
    blockExplorerUrl: `https://etherscan.io`
  },
  [NETWORK_TYPES.LINEA_MAINNET]: {
    networkId: NETWORK_IDS.LINEA_MAINNET,
    chainId: CHAIN_IDS.LINEA_MAINNET,
    blockExplorerUrl: 'https://lineascan.build'
  },
  [NETWORK_TYPES.LOCALHOST]: {
    networkId: NETWORK_IDS.LOCALHOST,
    chainId: CHAIN_IDS.LOCALHOST
  }
};
exports.BUILT_IN_NETWORKS = BUILT_IN_NETWORKS;
const BUILT_IN_INFURA_NETWORKS = (0, _lodash.pick)(BUILT_IN_NETWORKS, INFURA_PROVIDER_TYPES);
exports.BUILT_IN_INFURA_NETWORKS = BUILT_IN_INFURA_NETWORKS;
const NETWORK_TO_NAME_MAP = {
  [NETWORK_TYPES.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_TYPES.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_TYPES.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_TYPES.LINEA_GOERLI]: LINEA_GOERLI_DISPLAY_NAME,
  [NETWORK_TYPES.LINEA_MAINNET]: LINEA_MAINNET_DISPLAY_NAME,
  [NETWORK_TYPES.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [NETWORK_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_IDS.LINEA_GOERLI]: LINEA_GOERLI_DISPLAY_NAME,
  [NETWORK_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_IDS.LINEA_MAINNET]: LINEA_MAINNET_DISPLAY_NAME,
  [NETWORK_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [CHAIN_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [CHAIN_IDS.LINEA_GOERLI]: LINEA_GOERLI_DISPLAY_NAME,
  [CHAIN_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [CHAIN_IDS.LINEA_MAINNET]: LINEA_MAINNET_DISPLAY_NAME,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME
};
exports.NETWORK_TO_NAME_MAP = NETWORK_TO_NAME_MAP;
const CHAIN_ID_TO_TYPE_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_TYPES.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [CHAIN_IDS.LINEA_GOERLI]: NETWORK_TYPES.LINEA_GOERLI,
  [CHAIN_IDS.LINEA_MAINNET]: NETWORK_TYPES.LINEA_MAINNET,
  [CHAIN_IDS.LOCALHOST]: NETWORK_TYPES.LOCALHOST
};
exports.CHAIN_ID_TO_TYPE_MAP = CHAIN_ID_TO_TYPE_MAP;
const CHAIN_ID_TO_RPC_URL_MAP = {
  [CHAIN_IDS.GOERLI]: GOERLI_RPC_URL,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_RPC_URL,
  [CHAIN_IDS.LINEA_GOERLI]: LINEA_GOERLI_RPC_URL,
  [CHAIN_IDS.MAINNET]: MAINNET_RPC_URL,
  [CHAIN_IDS.LINEA_MAINNET]: LINEA_MAINNET_RPC_URL,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_RPC_URL
};
exports.CHAIN_ID_TO_RPC_URL_MAP = CHAIN_ID_TO_RPC_URL_MAP;
const CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = {
  [CHAIN_IDS.MAINNET]: ETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.LINEA_GOERLI]: LINEA_GOERLI_TOKEN_IMAGE_URL,
  [CHAIN_IDS.LINEA_MAINNET]: LINEA_MAINNET_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
  [CHAIN_IDS.BSC]: BNB_TOKEN_IMAGE_URL,
  [CHAIN_IDS.POLYGON]: MATIC_TOKEN_IMAGE_URL,
  [CHAIN_IDS.ARBITRUM]: AETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.FANTOM]: FTM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.HARMONY]: HARMONY_ONE_TOKEN_IMAGE_URL,
  [CHAIN_IDS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.PALM]: PALM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AURORA]: AURORA_TOKEN_IMAGE_URL,
  [CHAIN_IDS.CELO]: CELO_TOKEN_IMAGE_URL
};
exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP;
const NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = {
  [NETWORK_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [NETWORK_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [NETWORK_IDS.LINEA_GOERLI]: NETWORK_TYPES.LINEA_GOERLI,
  [NETWORK_IDS.MAINNET]: NETWORK_NAMES.HOMESTEAD,
  [NETWORK_IDS.LINEA_MAINNET]: NETWORK_TYPES.LINEA_MAINNET
};
exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP;
const CHAIN_ID_TO_NETWORK_ID_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_IDS.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_IDS.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_IDS.SEPOLIA,
  [CHAIN_IDS.LINEA_GOERLI]: NETWORK_IDS.LINEA_GOERLI,
  [CHAIN_IDS.LINEA_MAINNET]: NETWORK_IDS.LINEA_MAINNET,
  [CHAIN_IDS.LOCALHOST]: NETWORK_IDS.LOCALHOST
};
exports.CHAIN_ID_TO_NETWORK_ID_MAP = CHAIN_ID_TO_NETWORK_ID_MAP;
const NATIVE_CURRENCY_TOKEN_IMAGE_MAP = {
  [CURRENCY_SYMBOLS.ETH]: ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.TEST_ETH]: TEST_ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.BNB]: BNB_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.MATIC]: MATIC_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.CELO]: CELO_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.AURORA_ETH]: ETH_TOKEN_IMAGE_URL
};
exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = NATIVE_CURRENCY_TOKEN_IMAGE_MAP;
const INFURA_BLOCKED_KEY = 'countryBlocked';
exports.INFURA_BLOCKED_KEY = INFURA_BLOCKED_KEY;
const defaultEtherscanDomain = 'etherscan.io';
const defaultEtherscanSubdomainPrefix = 'api';
/**
 * Map of all Etherscan supported networks.
 */
const ETHERSCAN_SUPPORTED_NETWORKS = {
  [CHAIN_IDS.GOERLI]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-${CHAIN_ID_TO_TYPE_MAP[CHAIN_IDS.GOERLI]}`,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.GOERLI]
  },
  [CHAIN_IDS.MAINNET]: {
    domain: defaultEtherscanDomain,
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.MAINNET]
  },
  [CHAIN_IDS.SEPOLIA]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-${CHAIN_ID_TO_TYPE_MAP[CHAIN_IDS.SEPOLIA]}`,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.SEPOLIA]
  },
  [CHAIN_IDS.LINEA_GOERLI]: {
    domain: 'lineascan.build',
    subdomain: 'goerli',
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.LINEA_GOERLI]
  },
  [CHAIN_IDS.LINEA_MAINNET]: {
    domain: 'lineascan.build',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: CHAIN_ID_TO_NETWORK_ID_MAP[CHAIN_IDS.LINEA_MAINNET]
  },
  [CHAIN_IDS.BSC]: {
    domain: 'bscscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.BSC, 16).toString()
  },
  [CHAIN_IDS.BSC_TESTNET]: {
    domain: 'bscscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.BSC_TESTNET, 16).toString()
  },
  [CHAIN_IDS.OPTIMISM]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-optimistic`,
    networkId: parseInt(CHAIN_IDS.OPTIMISM, 16).toString()
  },
  [CHAIN_IDS.OPTIMISM_TESTNET]: {
    domain: defaultEtherscanDomain,
    subdomain: `${defaultEtherscanSubdomainPrefix}-goerli-optimistic`,
    networkId: parseInt(CHAIN_IDS.OPTIMISM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.POLYGON]: {
    domain: 'polygonscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.POLYGON, 16).toString()
  },
  [CHAIN_IDS.POLYGON_TESTNET]: {
    domain: 'polygonscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-mumbai`,
    networkId: parseInt(CHAIN_IDS.POLYGON_TESTNET, 16).toString()
  },
  [CHAIN_IDS.AVALANCHE]: {
    domain: 'snowtrace.io',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.AVALANCHE, 16).toString()
  },
  [CHAIN_IDS.AVALANCHE_TESTNET]: {
    domain: 'snowtrace.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.AVALANCHE_TESTNET, 16).toString()
  },
  [CHAIN_IDS.FANTOM]: {
    domain: 'ftmscan.com',
    subdomain: defaultEtherscanSubdomainPrefix,
    networkId: parseInt(CHAIN_IDS.FANTOM, 16).toString()
  },
  [CHAIN_IDS.FANTOM_TESTNET]: {
    domain: 'ftmscan.com',
    subdomain: `${defaultEtherscanSubdomainPrefix}-testnet`,
    networkId: parseInt(CHAIN_IDS.FANTOM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.MOONBEAM]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonbeam`,
    networkId: parseInt(CHAIN_IDS.MOONBEAM, 16).toString()
  },
  [CHAIN_IDS.MOONBEAM_TESTNET]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonbase`,
    networkId: parseInt(CHAIN_IDS.MOONBEAM_TESTNET, 16).toString()
  },
  [CHAIN_IDS.MOONRIVER]: {
    domain: 'moonscan.io',
    subdomain: `${defaultEtherscanSubdomainPrefix}-moonriver`,
    networkId: parseInt(CHAIN_IDS.MOONRIVER, 16).toString()
  }
};
exports.ETHERSCAN_SUPPORTED_NETWORKS = ETHERSCAN_SUPPORTED_NETWORKS;
const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
  [CHAIN_IDS.OPTIMISM]: 1,
  [CHAIN_IDS.OPTIMISM_TESTNET]: 1
};

/**
 * Ethereum JSON-RPC methods that are known to exist but that we intentionally
 * do not support.
 */
exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP;
const UNSUPPORTED_RPC_METHODS = new Set([
// This is implemented later in our middleware stack  specifically, in
// eth-json-rpc-middleware  but our UI does not support it.
'eth_signTransaction']);
exports.UNSUPPORTED_RPC_METHODS = UNSUPPORTED_RPC_METHODS;
const IPFS_DEFAULT_GATEWAY_URL = 'dweb.link';

// The first item in transakCurrencies must be the
// default crypto currency for the network
exports.IPFS_DEFAULT_GATEWAY_URL = IPFS_DEFAULT_GATEWAY_URL;
const BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME = 'ethereum';
const BUYABLE_CHAINS_MAP = {
  [CHAIN_IDS.MAINNET]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.SEPOLIA]: {
    nativeCurrency: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.BSC]: {
    nativeCurrency: CURRENCY_SYMBOLS.BNB,
    network: 'bsc'
  },
  [CHAIN_IDS.POLYGON]: {
    nativeCurrency: CURRENCY_SYMBOLS.MATIC,
    network: 'polygon'
  },
  [CHAIN_IDS.AVALANCHE]: {
    nativeCurrency: CURRENCY_SYMBOLS.AVALANCHE,
    network: 'avaxcchain'
  },
  [CHAIN_IDS.FANTOM]: {
    nativeCurrency: CURRENCY_SYMBOLS.FANTOM,
    network: 'fantom'
  },
  [CHAIN_IDS.CELO]: {
    nativeCurrency: CURRENCY_SYMBOLS.CELO,
    network: 'celo'
  },
  [CHAIN_IDS.OPTIMISM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: 'optimism'
  },
  [CHAIN_IDS.ARBITRUM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ARBITRUM,
    network: 'arbitrum'
  },
  [CHAIN_IDS.CRONOS]: {
    nativeCurrency: CURRENCY_SYMBOLS.CRONOS,
    network: 'cronos'
  },
  [CHAIN_IDS.MOONBEAM]: {
    nativeCurrency: CURRENCY_SYMBOLS.GLIMMER,
    network: 'moonbeam'
  },
  [CHAIN_IDS.MOONRIVER]: {
    nativeCurrency: CURRENCY_SYMBOLS.MOONRIVER,
    network: 'moonriver'
  },
  [CHAIN_IDS.AURORA]: {
    nativeCurrency: CURRENCY_SYMBOLS.AURORA_ETH,
    network: 'aurora'
  },
  [CHAIN_IDS.HARMONY]: {
    nativeCurrency: CURRENCY_SYMBOLS.ONE,
    network: 'harmony'
  },
  [CHAIN_IDS.PALM]: {
    nativeCurrency: CURRENCY_SYMBOLS.PALM,
    network: 'palm'
  },
  [CHAIN_IDS.LINEA_MAINNET]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: 'linea'
  }
};
exports.BUYABLE_CHAINS_MAP = BUYABLE_CHAINS_MAP;
const FEATURED_RPCS = [{
  chainId: CHAIN_IDS.ARBITRUM,
  nickname: ARBITRUM_DISPLAY_NAME,
  rpcUrl: `https://arbitrum-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ARBITRUM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.arbitrum.io',
    imageUrl: AETH_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AURORA,
  nickname: AURORA_DISPLAY_NAME,
  rpcUrl: `https://aurora-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AURORA_ETH,
  rpcPrefs: {
    blockExplorerUrl: 'https://aurorascan.dev/',
    imageUrl: AURORA_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AVALANCHE,
  nickname: AVALANCHE_DISPLAY_NAME,
  rpcUrl: `https://avalanche-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AVALANCHE,
  rpcPrefs: {
    blockExplorerUrl: 'https://snowtrace.io/',
    imageUrl: AVAX_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.BSC,
  nickname: BNB_DISPLAY_NAME,
  rpcUrl: 'https://bsc-dataseed.binance.org/',
  ticker: CURRENCY_SYMBOLS.BNB,
  rpcPrefs: {
    blockExplorerUrl: 'https://bscscan.com/',
    imageUrl: BNB_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.FANTOM,
  nickname: FANTOM_DISPLAY_NAME,
  rpcUrl: 'https://rpc.ftm.tools/',
  ticker: CURRENCY_SYMBOLS.FANTOM,
  rpcPrefs: {
    blockExplorerUrl: 'https://ftmscan.com/',
    imageUrl: FTM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.HARMONY,
  nickname: HARMONY_DISPLAY_NAME,
  rpcUrl: 'https://api.harmony.one/',
  ticker: CURRENCY_SYMBOLS.HARMONY,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.harmony.one/',
    imageUrl: HARMONY_ONE_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.OPTIMISM,
  nickname: OPTIMISM_DISPLAY_NAME,
  rpcUrl: `https://optimism-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ETH,
  rpcPrefs: {
    blockExplorerUrl: 'https://optimistic.etherscan.io/',
    imageUrl: OPTIMISM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.PALM,
  nickname: PALM_DISPLAY_NAME,
  rpcUrl: `https://palm-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.PALM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.palm.io/',
    imageUrl: PALM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.POLYGON,
  nickname: `${POLYGON_DISPLAY_NAME} ${(0, _lodash.capitalize)(NETWORK_TYPES.MAINNET)}`,
  rpcUrl: `https://polygon-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.MATIC,
  rpcPrefs: {
    blockExplorerUrl: 'https://polygonscan.com/',
    imageUrl: MATIC_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.CELO,
  nickname: CELO_DISPLAY_NAME,
  rpcUrl: `https://celo-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.CELO,
  rpcPrefs: {
    blockExplorerUrl: 'https://celoscan.io',
    imageUrl: CELO_TOKEN_IMAGE_URL
  }
}];

/**
 * Represents the availability state of the currently selected network.
 */
exports.FEATURED_RPCS = FEATURED_RPCS;
let NetworkStatus = /*#__PURE__*/function (NetworkStatus) {
  NetworkStatus["Unknown"] = "unknown";
  NetworkStatus["Available"] = "available";
  NetworkStatus["Unavailable"] = "unavailable";
  NetworkStatus["Blocked"] = "blocked";
  return NetworkStatus;
}({});
exports.NetworkStatus = NetworkStatus;


      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\network.ts",}],
["F:\\metamask-extension\\shared\\constants\\permissions.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Cpermissions.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestrictedMethods = exports.CaveatTypes = void 0;
const CaveatTypes = Object.freeze({
  restrictReturnedAccounts: 'restrictReturnedAccounts'
});
exports.CaveatTypes = CaveatTypes;
const RestrictedMethods = Object.freeze({
  eth_accounts: 'eth_accounts'
});
exports.RestrictedMethods = RestrictedMethods;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\permissions.ts",}],
["F:\\metamask-extension\\shared\\constants\\preferences.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Cpreferences.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeType = exports.DEFAULT_AUTO_LOCK_TIME_LIMIT = void 0;
let ThemeType = /*#__PURE__*/function (ThemeType) {
  ThemeType["light"] = "light";
  ThemeType["dark"] = "dark";
  ThemeType["os"] = "os";
  return ThemeType;
}({});
exports.ThemeType = ThemeType;
const DEFAULT_AUTO_LOCK_TIME_LIMIT = 0;
exports.DEFAULT_AUTO_LOCK_TIME_LIMIT = DEFAULT_AUTO_LOCK_TIME_LIMIT;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\preferences.ts",}],
["F:\\metamask-extension\\shared\\constants\\swaps.ts", {"./network":"F:\\metamask-extension\\shared\\constants\\network.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Cswaps.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WMATIC_CONTRACT_ADDRESS = exports.WETH_OPTIMISM_CONTRACT_ADDRESS = exports.WETH_GOERLI_CONTRACT_ADDRESS = exports.WETH_CONTRACT_ADDRESS = exports.WETH_ARBITRUM_CONTRACT_ADDRESS = exports.WBNB_CONTRACT_ADDRESS = exports.WAVAX_CONTRACT_ADDRESS = exports.TokenBucketPriority = exports.TEST_ETH_SWAPS_TOKEN_OBJECT = exports.Slippage = exports.SWAP_FAILED_ERROR = exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = exports.SWAPS_FETCH_ORDER_CONFLICT = exports.SWAPS_DEV_API_V2_BASE_URL = exports.SWAPS_CLIENT_ID = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = exports.SWAPS_API_V2_BASE_URL = exports.SLIPPAGE_VERY_HIGH_ERROR = exports.SLIPPAGE_TOO_LOW_ERROR = exports.SLIPPAGE_OVER_LIMIT_ERROR = exports.SLIPPAGE_NEGATIVE_ERROR = exports.QUOTES_NOT_AVAILABLE_ERROR = exports.QUOTES_EXPIRED_ERROR = exports.POLYGON = exports.OPTIMISM_SWAPS_TOKEN_OBJECT = exports.OPTIMISM = exports.OFFLINE_FOR_MAINTENANCE = exports.MATIC_SWAPS_TOKEN_OBJECT = exports.GOERLI_SWAPS_TOKEN_OBJECT = exports.GOERLI = exports.GAS_DEV_API_BASE_URL = exports.GAS_API_BASE_URL = exports.ETH_SWAPS_TOKEN_OBJECT = exports.ETHEREUM = exports.ERROR_FETCHING_QUOTES = exports.DEFAULT_ERC20_APPROVE_GAS = exports.CONTRACT_DATA_DISABLED_ERROR = exports.BSC = exports.BNB_SWAPS_TOKEN_OBJECT = exports.AVAX_SWAPS_TOKEN_OBJECT = exports.AVALANCHE = exports.ARBITRUM_SWAPS_TOKEN_OBJECT = exports.ARBITRUM = exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = exports.ALLOWED_CONTRACT_ADDRESSES = void 0;
var _network = require("./network");
const QUOTES_EXPIRED_ERROR = 'quotes-expired';
exports.QUOTES_EXPIRED_ERROR = QUOTES_EXPIRED_ERROR;
const SWAP_FAILED_ERROR = 'swap-failed-error';
exports.SWAP_FAILED_ERROR = SWAP_FAILED_ERROR;
const ERROR_FETCHING_QUOTES = 'error-fetching-quotes';
exports.ERROR_FETCHING_QUOTES = ERROR_FETCHING_QUOTES;
const QUOTES_NOT_AVAILABLE_ERROR = 'quotes-not-avilable';
exports.QUOTES_NOT_AVAILABLE_ERROR = QUOTES_NOT_AVAILABLE_ERROR;
const CONTRACT_DATA_DISABLED_ERROR = 'contract-data-disabled';
exports.CONTRACT_DATA_DISABLED_ERROR = CONTRACT_DATA_DISABLED_ERROR;
const OFFLINE_FOR_MAINTENANCE = 'offline-for-maintenance';
exports.OFFLINE_FOR_MAINTENANCE = OFFLINE_FOR_MAINTENANCE;
const SWAPS_FETCH_ORDER_CONFLICT = 'swaps-fetch-order-conflict';
exports.SWAPS_FETCH_ORDER_CONFLICT = SWAPS_FETCH_ORDER_CONFLICT;
const SLIPPAGE_OVER_LIMIT_ERROR = 'slippage-over-limit';
exports.SLIPPAGE_OVER_LIMIT_ERROR = SLIPPAGE_OVER_LIMIT_ERROR;
const SLIPPAGE_VERY_HIGH_ERROR = 'slippage-very-high';
exports.SLIPPAGE_VERY_HIGH_ERROR = SLIPPAGE_VERY_HIGH_ERROR;
const SLIPPAGE_TOO_LOW_ERROR = 'slippage-too-low';
exports.SLIPPAGE_TOO_LOW_ERROR = SLIPPAGE_TOO_LOW_ERROR;
const SLIPPAGE_NEGATIVE_ERROR = 'slippage-negative';

// An address that the metaswap-api recognizes as the default token for the current network,
// in place of the token address that ERC-20 tokens have
exports.SLIPPAGE_NEGATIVE_ERROR = SLIPPAGE_NEGATIVE_ERROR;
const DEFAULT_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000';
const ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.ETH_TOKEN_IMAGE_URL
};
exports.ETH_SWAPS_TOKEN_OBJECT = ETH_SWAPS_TOKEN_OBJECT;
const BNB_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.BNB,
  name: 'Binance Coin',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.BNB_TOKEN_IMAGE_URL
};
exports.BNB_SWAPS_TOKEN_OBJECT = BNB_SWAPS_TOKEN_OBJECT;
const MATIC_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.MATIC,
  name: 'Matic',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.MATIC_TOKEN_IMAGE_URL
};
exports.MATIC_SWAPS_TOKEN_OBJECT = MATIC_SWAPS_TOKEN_OBJECT;
const AVAX_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.AVALANCHE,
  name: 'Avalanche',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.AVAX_TOKEN_IMAGE_URL
};
exports.AVAX_SWAPS_TOKEN_OBJECT = AVAX_SWAPS_TOKEN_OBJECT;
const TEST_ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.TEST_ETH,
  name: 'Test Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
};
exports.TEST_ETH_SWAPS_TOKEN_OBJECT = TEST_ETH_SWAPS_TOKEN_OBJECT;
const GOERLI_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
};
exports.GOERLI_SWAPS_TOKEN_OBJECT = GOERLI_SWAPS_TOKEN_OBJECT;
const ARBITRUM_SWAPS_TOKEN_OBJECT = {
  ...ETH_SWAPS_TOKEN_OBJECT
};
exports.ARBITRUM_SWAPS_TOKEN_OBJECT = ARBITRUM_SWAPS_TOKEN_OBJECT;
const OPTIMISM_SWAPS_TOKEN_OBJECT = {
  ...ETH_SWAPS_TOKEN_OBJECT
};

// A gas value for ERC20 approve calls that should be sufficient for all ERC20 approve implementations
exports.OPTIMISM_SWAPS_TOKEN_OBJECT = OPTIMISM_SWAPS_TOKEN_OBJECT;
const DEFAULT_ERC20_APPROVE_GAS = '0x1d4c0';

// Contract addresses below should be in lowercase.
exports.DEFAULT_ERC20_APPROVE_GAS = DEFAULT_ERC20_APPROVE_GAS;
const MAINNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const TESTNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const BSC_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const POLYGON_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const AVALANCHE_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const OPTIMISM_CONTRACT_ADDRESS = '0x9dda6ef3d919c9bc8885d5560999a3640431e8e6';
const ARBITRUM_CONTRACT_ADDRESS = '0x9dda6ef3d919c9bc8885d5560999a3640431e8e6';
const WETH_CONTRACT_ADDRESS = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';
exports.WETH_CONTRACT_ADDRESS = WETH_CONTRACT_ADDRESS;
const WETH_GOERLI_CONTRACT_ADDRESS = '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6';
exports.WETH_GOERLI_CONTRACT_ADDRESS = WETH_GOERLI_CONTRACT_ADDRESS;
const WBNB_CONTRACT_ADDRESS = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c';
exports.WBNB_CONTRACT_ADDRESS = WBNB_CONTRACT_ADDRESS;
const WMATIC_CONTRACT_ADDRESS = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';
exports.WMATIC_CONTRACT_ADDRESS = WMATIC_CONTRACT_ADDRESS;
const WAVAX_CONTRACT_ADDRESS = '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7';
exports.WAVAX_CONTRACT_ADDRESS = WAVAX_CONTRACT_ADDRESS;
const WETH_OPTIMISM_CONTRACT_ADDRESS = '0x4200000000000000000000000000000000000006';
exports.WETH_OPTIMISM_CONTRACT_ADDRESS = WETH_OPTIMISM_CONTRACT_ADDRESS;
const WETH_ARBITRUM_CONTRACT_ADDRESS = '0x82af49447d8a07e3bd95bd0d56f35241523fbab1';
exports.WETH_ARBITRUM_CONTRACT_ADDRESS = WETH_ARBITRUM_CONTRACT_ADDRESS;
const SWAPS_TESTNET_CHAIN_ID = '0x539';
const SWAPS_API_V2_BASE_URL = 'https://swap.metaswap.codefi.network';
exports.SWAPS_API_V2_BASE_URL = SWAPS_API_V2_BASE_URL;
const SWAPS_DEV_API_V2_BASE_URL = 'https://swap.dev-api.cx.metamask.io';
exports.SWAPS_DEV_API_V2_BASE_URL = SWAPS_DEV_API_V2_BASE_URL;
const GAS_API_BASE_URL = 'https://gas-api.metaswap.codefi.network';
exports.GAS_API_BASE_URL = GAS_API_BASE_URL;
const GAS_DEV_API_BASE_URL = 'https://gas-api.metaswap-dev.codefi.network';
exports.GAS_DEV_API_BASE_URL = GAS_DEV_API_BASE_URL;
const BSC_DEFAULT_BLOCK_EXPLORER_URL = 'https://bscscan.com/';
const MAINNET_DEFAULT_BLOCK_EXPLORER_URL = 'https://etherscan.io/';
const GOERLI_DEFAULT_BLOCK_EXPLORER_URL = 'https://goerli.etherscan.io/';
const POLYGON_DEFAULT_BLOCK_EXPLORER_URL = 'https://polygonscan.com/';
const AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL = 'https://snowtrace.io/';
const OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL = 'https://optimistic.etherscan.io/';
const ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL = 'https://arbiscan.io/';
const ALLOWED_PROD_SWAPS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, SWAPS_TESTNET_CHAIN_ID, _network.CHAIN_IDS.BSC, _network.CHAIN_IDS.POLYGON, _network.CHAIN_IDS.AVALANCHE, _network.CHAIN_IDS.OPTIMISM, _network.CHAIN_IDS.ARBITRUM];
exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = ALLOWED_PROD_SWAPS_CHAIN_IDS;
const ALLOWED_DEV_SWAPS_CHAIN_IDS = [...ALLOWED_PROD_SWAPS_CHAIN_IDS, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = ALLOWED_DEV_SWAPS_CHAIN_IDS;
const ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS;
const SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = {
  [_network.CHAIN_IDS.MAINNET]: MAINNET_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: BSC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_CONTRACT_ADDRESS
};
exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = SWAPS_CHAINID_CONTRACT_ADDRESS_MAP;
const SWAPS_WRAPPED_TOKENS_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: WETH_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: WETH_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: WBNB_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: WMATIC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: WETH_GOERLI_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: WAVAX_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.OPTIMISM]: WETH_OPTIMISM_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.ARBITRUM]: WETH_ARBITRUM_CONTRACT_ADDRESS
};
exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = SWAPS_WRAPPED_TOKENS_ADDRESSES;
const ALLOWED_CONTRACT_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.MAINNET], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.MAINNET]],
  [SWAPS_TESTNET_CHAIN_ID]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[SWAPS_TESTNET_CHAIN_ID], SWAPS_WRAPPED_TOKENS_ADDRESSES[SWAPS_TESTNET_CHAIN_ID]],
  [_network.CHAIN_IDS.GOERLI]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.GOERLI], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.GOERLI]],
  [_network.CHAIN_IDS.BSC]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.BSC], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.BSC]],
  [_network.CHAIN_IDS.POLYGON]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.POLYGON], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.POLYGON]],
  [_network.CHAIN_IDS.AVALANCHE]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.AVALANCHE], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.AVALANCHE]],
  [_network.CHAIN_IDS.OPTIMISM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.OPTIMISM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.OPTIMISM]],
  [_network.CHAIN_IDS.ARBITRUM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.ARBITRUM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.ARBITRUM]]
};
exports.ALLOWED_CONTRACT_ADDRESSES = ALLOWED_CONTRACT_ADDRESSES;
const SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
  [_network.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
  [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT
};
exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = SWAPS_CHAINID_DEFAULT_TOKEN_MAP;
const SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = {
  [_network.CHAIN_IDS.BSC]: BSC_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.MAINNET]: MAINNET_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL
};
exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP;
const ETHEREUM = 'ethereum';
exports.ETHEREUM = ETHEREUM;
const POLYGON = 'polygon';
exports.POLYGON = POLYGON;
const BSC = 'bsc';
exports.BSC = BSC;
const GOERLI = 'goerli';
exports.GOERLI = GOERLI;
const AVALANCHE = 'avalanche';
exports.AVALANCHE = AVALANCHE;
const OPTIMISM = 'optimism';
exports.OPTIMISM = OPTIMISM;
const ARBITRUM = 'arbitrum';
exports.ARBITRUM = ARBITRUM;
const SWAPS_CLIENT_ID = 'extension';
exports.SWAPS_CLIENT_ID = SWAPS_CLIENT_ID;
let TokenBucketPriority = /*#__PURE__*/function (TokenBucketPriority) {
  TokenBucketPriority["owned"] = "owned";
  TokenBucketPriority["top"] = "top";
  return TokenBucketPriority;
}({});
exports.TokenBucketPriority = TokenBucketPriority;
let Slippage = /*#__PURE__*/function (Slippage) {
  Slippage[Slippage["default"] = 2] = "default";
  Slippage[Slippage["high"] = 3] = "high";
  return Slippage;
}({});
exports.Slippage = Slippage;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\swaps.ts",}],
["F:\\metamask-extension\\shared\\constants\\time.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Ctime.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECOND = exports.MINUTE = exports.MILLISECOND = exports.HOUR = exports.DAY = void 0;
const MILLISECOND = 1;
exports.MILLISECOND = MILLISECOND;
const SECOND = MILLISECOND * 1000;
exports.SECOND = SECOND;
const MINUTE = SECOND * 60;
exports.MINUTE = MINUTE;
const HOUR = MINUTE * 60;
exports.HOUR = HOUR;
const DAY = HOUR * 24;
exports.DAY = DAY;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\time.ts",}],
["F:\\metamask-extension\\shared\\constants\\tokens.js", {"@metamask/contract-metadata":"F:\\metamask-extension\\node_modules\\@metamask\\contract-metadata\\index.js","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Ctokens.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOKEN_API_METASWAP_CODEFI_URL = exports.STATIC_MAINNET_TOKEN_LIST = exports.NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = exports.MAX_TOKEN_ALLOWANCE_AMOUNT = exports.LISTED_CONTRACT_ADDRESSES = exports.DECIMAL_REGEX = void 0;
var _contractMetadata = _interopRequireDefault(require("@metamask/contract-metadata"));
var _bignumber = _interopRequireDefault(require("bignumber.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * A normalized list of addresses exported as part of the contractMap in
 * `@metamask/contract-metadata`. Used primarily to validate if manually entered
 * contract addresses do not match one of our listed tokens
 */
const LISTED_CONTRACT_ADDRESSES = Object.keys(_contractMetadata.default).map(address => address.toLowerCase());

/**
 * @typedef {object} TokenDetails
 * @property {string} address - The address of the selected 'TOKEN' or
 *  'NFT' contract.
 * @property {string} [symbol] - The symbol of the token.
 * @property {number} [decimals] - The number of decimals of the selected
 *  'ERC20' asset.
 * @property {number} [tokenId] - The id of the selected 'NFT' asset.
 * @property {TokenStandardStrings} [standard] - The standard of the selected
 *  asset.
 * @property {boolean} [isERC721] - True when the asset is a ERC721 token.
 */
exports.LISTED_CONTRACT_ADDRESSES = LISTED_CONTRACT_ADDRESSES;
const STATIC_MAINNET_TOKEN_LIST = Object.keys(_contractMetadata.default).reduce((acc, base) => {
  const {
    logo,
    ...tokenMetadata
  } = _contractMetadata.default[base];
  return {
    ...acc,
    [base.toLowerCase()]: {
      ...tokenMetadata,
      address: base.toLowerCase(),
      iconUrl: `images/contract/${logo}`,
      aggregators: []
    }
  };
}, {});
exports.STATIC_MAINNET_TOKEN_LIST = STATIC_MAINNET_TOKEN_LIST;
const TOKEN_API_METASWAP_CODEFI_URL = 'https://token-api.metaswap.codefi.network/tokens/';
exports.TOKEN_API_METASWAP_CODEFI_URL = TOKEN_API_METASWAP_CODEFI_URL;
const MAX_TOKEN_ALLOWANCE_AMOUNT = new _bignumber.default(2).pow(256).minus(1).toString(10);
// number with optional decimal point using a comma or dot
exports.MAX_TOKEN_ALLOWANCE_AMOUNT = MAX_TOKEN_ALLOWANCE_AMOUNT;
const NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = /^[0-9]{1,}([,.][0-9]{1,})?$/u;
exports.NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX = NUM_W_OPT_DECIMAL_COMMA_OR_DOT_REGEX;
const DECIMAL_REGEX = /\.(\d*)/u;
exports.DECIMAL_REGEX = DECIMAL_REGEX;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\tokens.js",}],
["F:\\metamask-extension\\shared\\constants\\transaction.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Ctransaction.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionType = exports.TransactionStatus = exports.TransactionMetaMetricsEvent = exports.TransactionGroupStatus = exports.TransactionGroupCategory = exports.TransactionEnvelopeType = exports.TransactionApprovalAmountType = exports.TokenStandard = exports.SmartTransactionStatus = exports.IN_PROGRESS_TRANSACTION_STATUSES = exports.AssetType = void 0;
let TransactionType = /*#__PURE__*/function (TransactionType) {
  TransactionType["cancel"] = "cancel";
  TransactionType["contractInteraction"] = "contractInteraction";
  TransactionType["deployContract"] = "contractDeployment";
  TransactionType["ethDecrypt"] = "eth_decrypt";
  TransactionType["ethGetEncryptionPublicKey"] = "eth_getEncryptionPublicKey";
  TransactionType["incoming"] = "incoming";
  TransactionType["personalSign"] = "personal_sign";
  TransactionType["retry"] = "retry";
  TransactionType["sign"] = "eth_sign";
  TransactionType["signTypedData"] = "eth_signTypedData";
  TransactionType["simpleSend"] = "simpleSend";
  TransactionType["smart"] = "smart";
  TransactionType["swap"] = "swap";
  TransactionType["swapApproval"] = "swapApproval";
  TransactionType["tokenMethodApprove"] = "approve";
  TransactionType["tokenMethodSafeTransferFrom"] = "safetransferfrom";
  TransactionType["tokenMethodTransfer"] = "transfer";
  TransactionType["tokenMethodTransferFrom"] = "transferfrom";
  TransactionType["tokenMethodSetApprovalForAll"] = "setapprovalforall";
  return TransactionType;
}({});
/**
 * In EIP-2718 typed transaction envelopes were specified, with the very first
 * typed envelope being 'legacy' and describing the shape of the base
 * transaction params that were hitherto the only transaction type sent on
 * Ethereum.
 */
exports.TransactionType = TransactionType;
let TransactionEnvelopeType = /*#__PURE__*/function (TransactionEnvelopeType) {
  TransactionEnvelopeType["legacy"] = "0x0";
  TransactionEnvelopeType["accessList"] = "0x1";
  TransactionEnvelopeType["feeMarket"] = "0x2";
  return TransactionEnvelopeType;
}({});
/**
 * Transaction Status is a mix of Ethereum and MetaMask terminology, used internally
 * for transaction processing.
 */
exports.TransactionEnvelopeType = TransactionEnvelopeType;
let TransactionStatus = /*#__PURE__*/function (TransactionStatus) {
  TransactionStatus["unapproved"] = "unapproved";
  TransactionStatus["approved"] = "approved";
  TransactionStatus["rejected"] = "rejected";
  TransactionStatus["signed"] = "signed";
  TransactionStatus["submitted"] = "submitted";
  TransactionStatus["failed"] = "failed";
  TransactionStatus["dropped"] = "dropped";
  TransactionStatus["confirmed"] = "confirmed";
  TransactionStatus["pending"] = "pending";
  return TransactionStatus;
}({});
/**
 * With this list we can detect if a transaction is still in progress.
 */
exports.TransactionStatus = TransactionStatus;
const IN_PROGRESS_TRANSACTION_STATUSES = [TransactionStatus.unapproved, TransactionStatus.approved, TransactionStatus.signed, TransactionStatus.submitted, TransactionStatus.pending];

/**
 * Transaction Group Status is a MetaMask construct to track the status of groups
 * of transactions.
 */
exports.IN_PROGRESS_TRANSACTION_STATUSES = IN_PROGRESS_TRANSACTION_STATUSES;
let TransactionGroupStatus = /*#__PURE__*/function (TransactionGroupStatus) {
  TransactionGroupStatus["cancelled"] = "cancelled";
  TransactionGroupStatus["pending"] = "pending";
  return TransactionGroupStatus;
}({});
/**
 * Statuses that are specific to Smart Transactions.
 */
exports.TransactionGroupStatus = TransactionGroupStatus;
let SmartTransactionStatus = /*#__PURE__*/function (SmartTransactionStatus) {
  SmartTransactionStatus["cancelled"] = "cancelled";
  SmartTransactionStatus["pending"] = "pending";
  SmartTransactionStatus["success"] = "success";
  return SmartTransactionStatus;
}({});
/**
 * Types that are specific to the transaction approval amount.
 */
exports.SmartTransactionStatus = SmartTransactionStatus;
let TransactionApprovalAmountType = /*#__PURE__*/function (TransactionApprovalAmountType) {
  TransactionApprovalAmountType["custom"] = "custom";
  TransactionApprovalAmountType["revoke"] = "revoke";
  TransactionApprovalAmountType["dappProposed"] = "dapp_proposed";
  return TransactionApprovalAmountType;
}({});
/**
 * Transaction Group Category is a MetaMask construct to categorize the intent
 * of a group of transactions for purposes of displaying in the UI
 */
exports.TransactionApprovalAmountType = TransactionApprovalAmountType;
let TransactionGroupCategory = /*#__PURE__*/function (TransactionGroupCategory) {
  TransactionGroupCategory["approval"] = "approval";
  TransactionGroupCategory["interaction"] = "interaction";
  TransactionGroupCategory["receive"] = "receive";
  TransactionGroupCategory["send"] = "send";
  TransactionGroupCategory["signatureRequest"] = "signature-request";
  TransactionGroupCategory["swap"] = "swap";
  return TransactionGroupCategory;
}({});
/**
 * An object representing parameters of a transaction to submit to the network
 */
/**
 * We attach an object to transactions proposed by dapps to show the values
 * that the dapp suggested for gas fees. This is used to compare to what our
 * internal gas price logic would have the transaction priced at for metrics
 * with the aim of improving our suggestions as well as giving the user the
 * option to return to the defaults suggested by the dapp if they have edited
 * the gas fees on the confirmation screen.
 */
/**
 * An object representing a transaction, in whatever state it is in.
 */
exports.TransactionGroupCategory = TransactionGroupCategory;
/**
 * Defines the possible types
 */
let TransactionMetaMetricsEvent = /*#__PURE__*/function (TransactionMetaMetricsEvent) {
  TransactionMetaMetricsEvent["added"] = "Transaction Added";
  TransactionMetaMetricsEvent["approved"] = "Transaction Approved";
  TransactionMetaMetricsEvent["finalized"] = "Transaction Finalized";
  TransactionMetaMetricsEvent["rejected"] = "Transaction Rejected";
  TransactionMetaMetricsEvent["submitted"] = "Transaction Submitted";
  return TransactionMetaMetricsEvent;
}({});
/**
 * The types of assets that a user can send
 *
 * @type {AssetTypes}
 */
exports.TransactionMetaMetricsEvent = TransactionMetaMetricsEvent;
let AssetType = /*#__PURE__*/function (AssetType) {
  AssetType["native"] = "NATIVE";
  AssetType["token"] = "TOKEN";
  AssetType["NFT"] = "NFT";
  AssetType["unknown"] = "UNKNOWN";
  return AssetType;
}({});
/**
 * Describes the standard which a token conforms to.
 */
exports.AssetType = AssetType;
let TokenStandard = /*#__PURE__*/function (TokenStandard) {
  TokenStandard["ERC20"] = "ERC20";
  TokenStandard["ERC721"] = "ERC721";
  TokenStandard["ERC1155"] = "ERC1155";
  TokenStandard["none"] = "NONE";
  return TokenStandard;
}({});
exports.TokenStandard = TokenStandard;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\transaction.ts",}],
["F:\\metamask-extension\\shared\\lib\\fetch-with-cache.js", {"../constants/time":"F:\\metamask-extension\\shared\\constants\\time.ts","../modules/fetch-with-timeout":"F:\\metamask-extension\\shared\\modules\\fetch-with-timeout.ts","./storage-helpers":"F:\\metamask-extension\\shared\\lib\\storage-helpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Clib%5Cfetch-with-cache.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _time = require("../constants/time");
var _fetchWithTimeout = _interopRequireDefault(require("../modules/fetch-with-timeout"));
var _storageHelpers = require("./storage-helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const fetchWithCache = async (url, fetchOptions = {}, {
  cacheRefreshTime = _time.MINUTE * 6,
  timeout = _time.SECOND * 30
} = {}) => {
  if (fetchOptions.body || fetchOptions.method && fetchOptions.method !== 'GET') {
    throw new Error('fetchWithCache only supports GET requests');
  }
  if (!(fetchOptions.headers instanceof window.Headers)) {
    fetchOptions.headers = new window.Headers(fetchOptions.headers);
  }
  if (fetchOptions.headers.has('Content-Type') && fetchOptions.headers.get('Content-Type') !== 'application/json') {
    throw new Error('fetchWithCache only supports JSON responses');
  }
  const currentTime = Date.now();
  const cacheKey = `cachedFetch:${url}`;
  const {
    cachedResponse,
    cachedTime
  } = (await (0, _storageHelpers.getStorageItem)(cacheKey)) || {};
  if (cachedResponse && currentTime - cachedTime < cacheRefreshTime) {
    return cachedResponse;
  }
  fetchOptions.headers.set('Content-Type', 'application/json');
  const fetchWithTimeout = (0, _fetchWithTimeout.default)(timeout);
  const response = await fetchWithTimeout(url, {
    referrerPolicy: 'no-referrer-when-downgrade',
    body: null,
    method: 'GET',
    mode: 'cors',
    ...fetchOptions
  });
  if (!response.ok) {
    throw new Error(`Fetch failed with status '${response.status}': '${response.statusText}'`);
  }
  const responseJson = await response.json();
  const cacheEntry = {
    cachedResponse: responseJson,
    cachedTime: currentTime
  };
  await (0, _storageHelpers.setStorageItem)(cacheKey, cacheEntry);
  return responseJson;
};
var _default = fetchWithCache;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\fetch-with-cache.js",}],
["F:\\metamask-extension\\shared\\lib\\metamask-controller-utils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Clib%5Cmetamask-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTokenValueParam = getTokenValueParam;
function getTokenValueParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args$_valu;
  return tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_valu = _tokenData$args._value) === null || _tokenData$args$_valu === void 0 ? void 0 : _tokenData$args$_valu.toString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\metamask-controller-utils.js",}],
["F:\\metamask-extension\\shared\\lib\\storage-helpers.js", {"localforage":"F:\\metamask-extension\\node_modules\\localforage\\dist\\localforage.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Clib%5Cstorage-helpers.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStorageItem = getStorageItem;
exports.setStorageItem = setStorageItem;
var _localforage = _interopRequireDefault(require("localforage"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function getStorageItem(key) {
  try {
    const serializedData = await _localforage.default.getItem(key);
    if (serializedData === null) {
      return undefined;
    }
    return JSON.parse(serializedData);
  } catch (err) {
    return undefined;
  }
}
async function setStorageItem(key, value) {
  try {
    const serializedData = JSON.stringify(value);
    await _localforage.default.setItem(key, serializedData);
  } catch (err) {
    console.warn(err);
  }
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\storage-helpers.js",}],
["F:\\metamask-extension\\shared\\lib\\swaps-utils.js", {"../../app/scripts/lib/util":"F:\\metamask-extension\\app\\scripts\\lib\\util.ts","../constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts","../constants/swaps":"F:\\metamask-extension\\shared\\constants\\swaps.ts","../constants/time":"F:\\metamask-extension\\shared\\constants\\time.ts","../modules/conversion.utils":"F:\\metamask-extension\\shared\\modules\\conversion.utils.ts","../modules/hexstring-utils":"F:\\metamask-extension\\shared\\modules\\hexstring-utils.ts","../modules/string-utils":"F:\\metamask-extension\\shared\\modules\\string-utils.ts","./fetch-with-cache":"F:\\metamask-extension\\shared\\lib\\fetch-with-cache.js","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","loglevel":"F:\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Clib%5Cswaps-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QUOTE_VALIDATORS = void 0;
exports.addHexPrefixToObjectValues = addHexPrefixToObjectValues;
exports.calcTokenValue = calcTokenValue;
exports.constructTxParams = constructTxParams;
exports.fetchTradesInfo = fetchTradesInfo;
exports.validHex = exports.truthyString = exports.truthyDigitString = exports.shouldEnableDirectWrapping = exports.getBaseApi = void 0;
exports.validateData = validateData;
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _loglevel = _interopRequireDefault(require("loglevel"));
var _network = require("../constants/network");
var _swaps = require("../constants/swaps");
var _time = require("../constants/time");
var _hexstringUtils = require("../modules/hexstring-utils");
var _stringUtils = require("../modules/string-utils");
var _util = require("../../app/scripts/lib/util");
var _conversion = require("../modules/conversion.utils");
var _fetchWithCache = _interopRequireDefault(require("./fetch-with-cache"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TEST_CHAIN_IDS = [_network.CHAIN_IDS.GOERLI, _network.CHAIN_IDS.LOCALHOST];
const clientIdHeader = {
  'X-Client-Id': _swaps.SWAPS_CLIENT_ID
};
const validHex = string => Boolean(string === null || string === void 0 ? void 0 : string.match(/^0x[a-f0-9]+$/u));
exports.validHex = validHex;
const truthyString = string => Boolean(string === null || string === void 0 ? void 0 : string.length);
exports.truthyString = truthyString;
const truthyDigitString = string => truthyString(string) && Boolean(string.match(/^\d+$/u));
exports.truthyDigitString = truthyDigitString;
function validateData(validators, object, urlUsed, logError = true) {
  return validators.every(({
    property,
    type,
    validator
  }) => {
    const types = type.split('|');
    const valid = types.some(_type => typeof object[property] === _type) && (!validator || validator(object[property]));
    if (!valid && logError) {
      _loglevel.default.error(`response to GET ${urlUsed} invalid for property ${property}; value was:`, object[property], '| type was: ', typeof object[property]);
    }
    return valid;
  });
}
const QUOTE_VALIDATORS = [{
  property: 'trade',
  type: 'object',
  validator: trade => trade && validHex(trade.data) && (0, _hexstringUtils.isValidHexAddress)(trade.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(trade.from, {
    allowNonPrefixed: false
  }) && truthyString(trade.value)
}, {
  property: 'approvalNeeded',
  type: 'object',
  validator: approvalTx => approvalTx === null || approvalTx && validHex(approvalTx.data) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.from, {
    allowNonPrefixed: false
  })
}, {
  property: 'sourceAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'destinationAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'sourceToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'destinationToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'aggregator',
  type: 'string',
  validator: truthyString
}, {
  property: 'aggType',
  type: 'string',
  validator: truthyString
}, {
  property: 'error',
  type: 'object',
  validator: error => error === null || typeof error === 'object'
}, {
  property: 'averageGas',
  type: 'number'
}, {
  property: 'maxGas',
  type: 'number'
}, {
  property: 'gasEstimate',
  type: 'number|undefined',
  validator: gasEstimate => gasEstimate === undefined || gasEstimate > 0
}, {
  property: 'fee',
  type: 'number'
}];

/**
 * @param {string} type - Type of an API call, e.g. "tokens"
 * @param {string} chainId
 * @returns string
 */
exports.QUOTE_VALIDATORS = QUOTE_VALIDATORS;
const getBaseUrlForNewSwapsApi = (type, chainId) => {
  const useDevApis = false;
  const v2ApiBaseUrl = useDevApis ? _swaps.SWAPS_DEV_API_V2_BASE_URL : _swaps.SWAPS_API_V2_BASE_URL;
  const gasApiBaseUrl = useDevApis ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
  const noNetworkSpecificTypes = ['refreshTime']; // These types don't need network info in the URL.
  if (noNetworkSpecificTypes.includes(type)) {
    return v2ApiBaseUrl;
  }
  const chainIdDecimal = chainId && parseInt(chainId, 16);
  const gasApiTypes = ['gasPrices'];
  if (gasApiTypes.includes(type)) {
    return `${gasApiBaseUrl}/networks/${chainIdDecimal}`; // Gas calculations are in its own repo.
  }

  return `${v2ApiBaseUrl}/networks/${chainIdDecimal}`;
};
const getBaseApi = function (type, chainId) {
  const _chainId = TEST_CHAIN_IDS.includes(chainId) ? _network.CHAIN_IDS.MAINNET : chainId;
  const baseUrl = getBaseUrlForNewSwapsApi(type, _chainId);
  if (!baseUrl) {
    throw new Error(`Swaps API calls are disabled for chainId: ${_chainId}`);
  }
  switch (type) {
    case 'trade':
      return `${baseUrl}/trades?`;
    case 'tokens':
      return `${baseUrl}/tokens`;
    case 'token':
      return `${baseUrl}/token`;
    case 'topAssets':
      return `${baseUrl}/topAssets`;
    case 'aggregatorMetadata':
      return `${baseUrl}/aggregatorMetadata`;
    case 'gasPrices':
      return `${baseUrl}/gasPrices`;
    case 'network':
      return baseUrl;
    default:
      throw new Error('getBaseApi requires an api call type');
  }
};
exports.getBaseApi = getBaseApi;
function calcTokenValue(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).times(multiplier);
}
const shouldEnableDirectWrapping = (chainId, sourceToken, destinationToken) => {
  var _SWAPS_CHAINID_DEFAUL;
  if (!sourceToken || !destinationToken) {
    return false;
  }
  const wrappedToken = _swaps.SWAPS_WRAPPED_TOKENS_ADDRESSES[chainId];
  const nativeToken = (_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address;
  return (0, _stringUtils.isEqualCaseInsensitive)(sourceToken, wrappedToken) && (0, _stringUtils.isEqualCaseInsensitive)(destinationToken, nativeToken) || (0, _stringUtils.isEqualCaseInsensitive)(sourceToken, nativeToken) && (0, _stringUtils.isEqualCaseInsensitive)(destinationToken, wrappedToken);
};

/**
 * Given and object where all values are strings, returns the same object with all values
 * now prefixed with '0x'
 *
 * @param obj
 */
exports.shouldEnableDirectWrapping = shouldEnableDirectWrapping;
function addHexPrefixToObjectValues(obj) {
  return Object.keys(obj).reduce((newObj, key) => {
    return {
      ...newObj,
      [key]: (0, _util.addHexPrefix)(obj[key])
    };
  }, {});
}

/**
 * Given the standard set of information about a transaction, returns a transaction properly formatted for
 * publishing via JSON RPC and web3
 *
 * @param {object} options
 * @param {boolean} [options.sendToken] - Indicates whether or not the transaciton is a token transaction
 * @param {string} options.data - A hex string containing the data to include in the transaction
 * @param {string} options.to - A hex address of the tx recipient address
 * @param options.amount
 * @param {string} options.from - A hex address of the tx sender address
 * @param {string} options.gas - A hex representation of the gas value for the transaction
 * @param {string} options.gasPrice - A hex representation of the gas price for the transaction
 * @returns {object} An object ready for submission to the blockchain, with all values appropriately hex prefixed
 */
function constructTxParams({
  sendToken,
  data,
  to,
  amount,
  from,
  gas,
  gasPrice
}) {
  const txParams = {
    data,
    from,
    value: '0',
    gas,
    gasPrice
  };
  if (!sendToken) {
    txParams.value = amount;
    txParams.to = to;
  }
  return addHexPrefixToObjectValues(txParams);
}
async function fetchTradesInfo({
  slippage,
  sourceToken,
  sourceDecimals,
  destinationToken,
  value,
  fromAddress,
  exchangeList
}, {
  chainId
}) {
  const urlParams = {
    destinationToken,
    sourceToken,
    sourceAmount: calcTokenValue(value, sourceDecimals).toString(10),
    slippage,
    timeout: _time.SECOND * 10,
    walletAddress: fromAddress
  };
  if (exchangeList) {
    urlParams.exchangeList = exchangeList;
  }
  if (shouldEnableDirectWrapping(chainId, sourceToken, destinationToken)) {
    urlParams.enableDirectWrapping = true;
  }
  const queryString = new URLSearchParams(urlParams).toString();
  const tradeURL = `${getBaseApi('trade', chainId)}${queryString}`;
  const tradesResponse = await (0, _fetchWithCache.default)(tradeURL, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: 0,
    timeout: _time.SECOND * 15
  });
  const newQuotes = tradesResponse.reduce((aggIdTradeMap, quote) => {
    if (quote.trade && !quote.error && validateData(QUOTE_VALIDATORS, quote, tradeURL)) {
      const constructedTrade = constructTxParams({
        to: quote.trade.to,
        from: quote.trade.from,
        data: quote.trade.data,
        amount: (0, _conversion.decimalToHex)(quote.trade.value),
        gas: (0, _conversion.decimalToHex)(quote.maxGas)
      });
      let {
        approvalNeeded
      } = quote;
      if (approvalNeeded) {
        approvalNeeded = constructTxParams({
          ...approvalNeeded
        });
      }
      return {
        ...aggIdTradeMap,
        [quote.aggregator]: {
          ...quote,
          slippage,
          trade: constructedTrade,
          approvalNeeded
        }
      };
    }
    return aggIdTradeMap;
  }, {});
  return newQuotes;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\swaps-utils.js",}],
["F:\\metamask-extension\\shared\\lib\\token-util.ts", {"@ethersproject/contracts":"F:\\metamask-extension\\node_modules\\@ethersproject\\contracts\\lib\\index.js","@ethersproject/providers":"F:\\metamask-extension\\node_modules\\@ethersproject\\providers\\lib\\index.js","@metamask/metamask-eth-abis":"F:\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Clib%5Ctoken-util.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchTokenBalance = fetchTokenBalance;
exports.getTokenIdParam = getTokenIdParam;
var _metamaskEthAbis = require("@metamask/metamask-eth-abis");
var _contracts = require("@ethersproject/contracts");
var _providers = require("@ethersproject/providers");
/**
 * Gets the '_value' parameter of the given token transaction data
 * (i.e function call) per the Human Standard Token ABI, if present.
 *
 * @param {object} tokenData - ethers Interface token data.
 * @returns {string | undefined} A decimal string value.
 */
/**
 * Gets either the '_tokenId' parameter or the 'id' param of the passed token transaction data.,
 * These are the parsed tokenId values returned by `parseStandardTokenTransactionData` as defined
 * in the ERC721 and ERC1155 ABIs from metamask-eth-abis (https://github.com/MetaMask/metamask-eth-abis/tree/main/src/abis)
 *
 * @param tokenData - ethers Interface token data.
 * @returns A decimal string value.
 */
function getTokenIdParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args$_toke, _tokenData$args2, _tokenData$args2$id;
  return (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_toke = _tokenData$args._tokenId) === null || _tokenData$args$_toke === void 0 ? void 0 : _tokenData$args$_toke.toString()) ?? (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args2 = tokenData.args) === null || _tokenData$args2 === void 0 ? void 0 : (_tokenData$args2$id = _tokenData$args2.id) === null || _tokenData$args2$id === void 0 ? void 0 : _tokenData$args2$id.toString());
}
async function fetchTokenBalance(address, userAddress, provider) {
  const ethersProvider = new _providers.Web3Provider(provider);
  const tokenContract = new _contracts.Contract(address, _metamaskEthAbis.abiERC20, ethersProvider);
  const tokenBalancePromise = tokenContract ? tokenContract.balanceOf(userAddress) : Promise.resolve();
  return await tokenBalancePromise;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\token-util.ts",}],
["F:\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", {"../constants/common":"F:\\metamask-extension\\shared\\constants\\common.ts","../constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","../modules/Numeric":"F:\\metamask-extension\\shared\\modules\\Numeric.ts","../modules/swaps.utils":"F:\\metamask-extension\\shared\\modules\\swaps.utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Clib%5Ctransactions-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = exports.TRANSACTION_ENVELOPE_TYPE_NAMES = exports.TOKEN_TRANSFER_LOG_TOPIC_HASH = exports.TEN_SECONDS_IN_MILLISECONDS = void 0;
exports.calcGasTotal = calcGasTotal;
exports.calcTokenAmount = calcTokenAmount;
exports.getSwapsTokensReceivedFromTxMeta = getSwapsTokensReceivedFromTxMeta;
exports.toPrecisionWithoutTrailingZeros = toPrecisionWithoutTrailingZeros;
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _common = require("../constants/common");
var _transaction = require("../constants/transaction");
var _Numeric = require("../modules/Numeric");
var _swaps = require("../modules/swaps.utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TOKEN_TRANSFER_LOG_TOPIC_HASH = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
exports.TOKEN_TRANSFER_LOG_TOPIC_HASH = TOKEN_TRANSFER_LOG_TOPIC_HASH;
const TRANSACTION_NO_CONTRACT_ERROR_KEY = 'transactionErrorNoContract';
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = TRANSACTION_NO_CONTRACT_ERROR_KEY;
const TEN_SECONDS_IN_MILLISECONDS = 10_000;
exports.TEN_SECONDS_IN_MILLISECONDS = TEN_SECONDS_IN_MILLISECONDS;
function calcGasTotal(gasLimit = '0', gasPrice = '0') {
  return new _Numeric.Numeric(gasLimit, 16).times(new _Numeric.Numeric(gasPrice, 16)).toString();
}

/**
 * Given a number and specified precision, returns that number in base 10 with a maximum of precision
 * significant digits, but without any trailing zeros after the decimal point To be used when wishing
 * to display only as much digits to the user as necessary
 *
 * @param {string | number | BigNumber} n - The number to format
 * @param {number} precision - The maximum number of significant digits in the return value
 * @returns {string} The number in decimal form, with <= precision significant digits and no decimal trailing zeros
 */
function toPrecisionWithoutTrailingZeros(n, precision) {
  return new _bignumber.default(n).toPrecision(precision).replace(/(\.[0-9]*[1-9])0*|(\.0*)/u, '$1');
}
function calcTokenAmount(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).div(multiplier);
}
function getSwapsTokensReceivedFromTxMeta(tokenSymbol, txMeta, tokenAddress, accountAddress, tokenDecimals, approvalTxMeta, chainId) {
  var _txMeta$txReceipt;
  const txReceipt = txMeta === null || txMeta === void 0 ? void 0 : txMeta.txReceipt;
  const networkAndAccountSupports1559 = (txMeta === null || txMeta === void 0 ? void 0 : (_txMeta$txReceipt = txMeta.txReceipt) === null || _txMeta$txReceipt === void 0 ? void 0 : _txMeta$txReceipt.type) === _transaction.TransactionEnvelopeType.feeMarket;
  if ((0, _swaps.isSwapsDefaultTokenSymbol)(tokenSymbol, chainId)) {
    if (!txReceipt || !txMeta || !txMeta.postTxBalance || !txMeta.preTxBalance) {
      return null;
    }
    if (txMeta.swapMetaData && txMeta.preTxBalance === txMeta.postTxBalance) {
      // If preTxBalance and postTxBalance are equal, postTxBalance hasn't been updated on time
      // because of the RPC provider delay, so we return an estimated receiving amount instead.
      return txMeta.swapMetaData.token_to_amount;
    }
    let approvalTxGasCost = new _Numeric.Numeric('0x0', 16);
    if (approvalTxMeta && approvalTxMeta.txReceipt) {
      approvalTxGasCost = new _Numeric.Numeric(calcGasTotal(approvalTxMeta.txReceipt.gasUsed, networkAndAccountSupports1559 ? approvalTxMeta.txReceipt.effectiveGasPrice // Base fee + priority fee.
      : approvalTxMeta.txParams.gasPrice), 16);
    }
    const gasCost = calcGasTotal(txReceipt.gasUsed, networkAndAccountSupports1559 ? txReceipt.effectiveGasPrice : txMeta.txParams.gasPrice);
    const totalGasCost = new _Numeric.Numeric(gasCost, 16).add(approvalTxGasCost);
    const preTxBalanceLessGasCost = new _Numeric.Numeric(txMeta.preTxBalance, 16).minus(totalGasCost);
    const ethReceived = new _Numeric.Numeric(txMeta.postTxBalance, 16, _common.EtherDenomination.WEI).minus(preTxBalanceLessGasCost).toDenomination(_common.EtherDenomination.ETH).toBase(10).round(6);
    return ethReceived.toString();
  }
  const txReceiptLogs = txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.logs;
  if (txReceiptLogs && (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) !== '0x0') {
    const tokenTransferLog = txReceiptLogs.find(txReceiptLog => {
      const isTokenTransfer = txReceiptLog.topics && txReceiptLog.topics[0] === TOKEN_TRANSFER_LOG_TOPIC_HASH;
      const isTransferFromGivenToken = txReceiptLog.address === tokenAddress;
      const isTransferFromGivenAddress = txReceiptLog.topics && txReceiptLog.topics[2] && txReceiptLog.topics[2].match(accountAddress.slice(2));
      return isTokenTransfer && isTransferFromGivenToken && isTransferFromGivenAddress;
    });
    return tokenTransferLog ? toPrecisionWithoutTrailingZeros(calcTokenAmount(tokenTransferLog.data, tokenDecimals).toString(10), 6) : '';
  }
  return null;
}
const TRANSACTION_ENVELOPE_TYPE_NAMES = {
  FEE_MARKET: 'fee-market',
  LEGACY: 'legacy'
};
exports.TRANSACTION_ENVELOPE_TYPE_NAMES = TRANSACTION_ENVELOPE_TYPE_NAMES;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\lib\\transactions-controller-utils.js",}],
["F:\\metamask-extension\\shared\\modules\\Numeric.ts", {"../constants/common":"F:\\metamask-extension\\shared\\constants\\common.ts","./hexstring-utils":"F:\\metamask-extension\\shared\\modules\\hexstring-utils.ts","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5CNumeric.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Numeric = void 0;
var _bignumber = require("bignumber.js");
var _bn = _interopRequireDefault(require("bn.js"));
var _utils = require("@metamask/utils");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("../constants/common");
var _hexstringUtils = require("./hexstring-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * All variations of isHexString from our own utilities and etherumjs-utils
 * return false for a '-' prefixed hex string. This utility method strips the
 * possible '-' from the string before testing its validity so that negative
 * hex values can be properly handled.
 *
 * @param value - The string to check
 * @returns true if the value is a hex string (negative or otherwise)
 */
function isHexStringOrNegatedHexString(value) {
  return (0, _utils.isHexString)(value.replace('-', '')) || (0, _utils.isHexString)(value);
}

/**
 * BigNumber supports hex strings with '.' (aka decimals) in the string.
 * No version of isHexString returs true if the string contains a decimal so
 * this method is used to check if both parts of the string split by the
 * decimal are hex strings. If so we can feed this value into BigNumber to get
 * a valid Numeric.
 *
 * @param value - The string to check
 * @returns true if the string is a hexadecimal split by '.'
 */
function isDecimalHex(value) {
  const parts = value.split('.');
  if (parts.length === 1) {
    return false;
  }
  return parts.every(part => isHexStringOrNegatedHexString(part));
}

/**
 * Converts a hexadecimal in string or number format to a BigNumber.
 * Note that in many places in our codebase we call 'addHexPrefix' on a negated
 * hexadecimal string resulting in '0x-a' which will fail checks for
 * isHexString. Sometimes we DO not add the 0x so we have to check for '-a'
 * as well.
 *
 * @param value - hexadecimal value in string or number format.
 * @returns A BigNumber representation of the value
 */
function hexadecimalToBigNumber(value) {
  const stringified = typeof value === 'number' ? `${value}` : value;
  const isNegative = (0, _hexstringUtils.stripHexPrefix)(stringified)[0] === '-';
  const valueWithoutNegation = stringified.replace('-', '');
  const valueAsBigNumber = new _bignumber.BigNumber((0, _hexstringUtils.stripHexPrefix)(valueWithoutNegation), 16);
  return isNegative ? valueAsBigNumber.negated() : valueAsBigNumber;
}

/**
 * Converts a decimal in string or number format to a BigNumber.
 *
 * @param value - decimal value in string or number format.
 * @returns A BigNumber representation of the value
 */
function decimalToBigNumber(value) {
  return new _bignumber.BigNumber(String(value), 10);
}

/**
 * This method is used to safely convert a string type value to a BigNumber.
 * The only valid strings for this method are those that are either hexadecimal
 * numeric values OR numeric strings that can be converted to BigNumbers. It is
 * impossible to tell the difference between a hex value of 100000 vs a decimal
 * value of 100000 so a second parameter indicating the numeric base of the
 * string value must be provided.
 *
 * @param value - A hexadecimal or decimal string
 * @param numericBase - Either 16 for a hexadeciaml or 10 for a decimal
 * @returns A BigNumber representation of the value
 */
function stringToBigNumber(value, numericBase) {
  if (typeof value !== 'string') {
    throw new Error(`Value of type ${typeof value} passed to stringToBigNumber`);
  }
  if (numericBase === 16 && (isHexStringOrNegatedHexString(value) || isDecimalHex(value))) {
    return hexadecimalToBigNumber(value);
  } else if (numericBase === 10 && (
  // check if we have a finite integer or float
  isFinite(parseInt(value, 10)) || isFinite(parseFloat(value)))) {
    return decimalToBigNumber(value);
  }
  throw new Error(`String provided to stringToBigNumber is not a hexadecimal or decimal string: ${value}, ${numericBase}`);
}

/**
 * This method will convert a hexadecimal or deciaml number into a BigNumber.
 * The second parameter must be supplied and determines whether to treat the
 * value as a hexadecimal or decimal value.
 *
 * @param value - hexadecimal or decimal number[]
 * @param numericBase - 10 for decimal, 16 for hexadecimal
 * @returns BigNumber representation of the value
 */
function numberToBigNumber(value, numericBase) {
  if (typeof value !== 'number') {
    throw new Error(`Value of type ${typeof value} passed to numberToBigNumber`);
  }
  if (numericBase === 16 && (0, _utils.isHexString)(`${value}`)) {
    return new _bignumber.BigNumber(`${value}`, 16);
  }
  return new _bignumber.BigNumber(value, 10);
}

/**
 * Method to convert a BN to a BigNumber
 *
 * @param value - A BN representation of a value
 * @returns A BigNumber representation of the BN's underlying value
 */
function bnToBigNumber(value) {
  if (value instanceof _bn.default === false) {
    throw new Error(`value passed to bnToBigNumber is not a BN. Received type ${typeof value}`);
  }
  return new _bignumber.BigNumber(value.toString(16), 16);
}

/**
 * Converts a value of the supported types (string, number, BN) to a BigNumber.
 *
 * @param value - The value to convert to a BigNumber
 * @param numericBase - The numeric base of the underlying value
 * @returns A BigNumber representation of the value
 */
function valueToBigNumber(value, numericBase) {
  if (typeof value === 'string') {
    return stringToBigNumber(value, numericBase);
  } else if (typeof value === 'number' && isNaN(value) === false) {
    return numberToBigNumber(value, numericBase);
  }
  throw new Error(`Value: ${value} is not a string, number, BigNumber or BN. Type is: ${typeof value}.`);
}

// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new _bignumber.BigNumber('1000000000000000000');
const BIG_NUMBER_GWEI_MULTIPLIER = new _bignumber.BigNumber('1000000000');
const BIG_NUMBER_ETH_MULTIPLIER = new _bignumber.BigNumber('1');
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).round(),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).round(9),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).round(9)
};

/**
 * Gets the value in ETH of the numeric supplied, used in this file only to
 * convert to ETH prior to converting to another denomination. The following
 * quirks were programmed into this method to replicate behavior of the
 * predecessor to Numeric, which was 'conversionUtil'. If a denomination is
 * not supplied, and toDenomination is called, then we assume the denomination
 * was originally ETH, otherwise we convert it to ETH.
 *
 * @param numeric
 * @returns value in ETH
 */
function getValueInETH(numeric) {
  if (numeric.denomination === _common.EtherDenomination.ETH || typeof numeric.denomination === 'undefined') {
    return numeric.value;
  }
  return toNormalizedDenomination[numeric.denomination](numeric.value);
}

/**
 * When applying operands to Numerics that have a specified Denomination then
 * we should first convert the provided inputNumeric to the same Denomination
 * as the baseNumeric. There are cases where this doesn't apply:
 *
 * 1. If the denominations are already the same. No conversion is necessary.
 * 2. If the inputNumeric does not have a denomination set. We assume in this
 * case that the value is already in the appropriate denomination.
 *
 * @param baseNumeric
 * @param inputNumeric
 * @returns
 */
function alignOperandDenominations(baseNumeric, inputNumeric) {
  if (typeof inputNumeric.denomination !== 'undefined' && baseNumeric.denomination !== inputNumeric.denomination) {
    return inputNumeric.toDenomination(baseNumeric.denomination);
  }
  return inputNumeric;
}

/**
 * Numeric is a class whose methods will always return a new, not mutated,
 * value. This allows for chaining of non-terminating methods. Previously we
 * had near a hundred helper methods that composed one-another, making tracking
 * through the chain near impossible. This API is designed such that no helper
 * methods should be needed. Take the case of hexWEIToDecGWEI, a helper method
 * for taking a hex string representing a value in WEI and converting that to a
 * decimal of GWEI. Prior to this class the method would call into our root
 * level 'conversionUtil' which was the proverbial kitchen sink doing
 * everything from denomination conversion, currency conversion (with provided
 * conversionRate prop) and more. The same opeartion can now be expressed as:
 * new Numeric(hexString, 16, EtherDenomination.WEI)
 * .toDenomination(EtherDenomination.GWEI)
 * .toBase(10)
 * .toString();
 * This has the benefit of being fairly transparent as you can read each step
 * in the chain and have a good sense of what is being done. It also is highly
 * composable so that we shouldn't need tons of helper methods for shortcuts.
 */
class Numeric {
  constructor(value, base, denomination) {
    /**
     * The underlying value of the Numeric, always in BigNumber form
     */
    _defineProperty(this, "value", void 0);
    /**
     * The numeric base for this Numeric, either 10 for decimal or 16 for Hex
     */
    _defineProperty(this, "base", void 0);
    /**
     * The current denomination, if any. The only supported denominations are
     * ETH, GWEI, WEI.
     */
    _defineProperty(this, "denomination", void 0);
    this.base = base;
    this.denomination = denomination;
    if (value instanceof _bignumber.BigNumber) {
      this.value = value;
    } else if (value instanceof _bn.default) {
      this.value = bnToBigNumber(value);
    } else if ((0, _utils.isNullOrUndefined)(value) || typeof value === 'number' && isNaN(value) || typeof value === 'string' && value === '') {
      // There are parts of the codebase that call this method without a value,
      // or with a 'NaN' (which is probably a bug somewhere in our tests?).
      // Over time of converting to TypeScript we will eradicate those, but the
      // helper methods that those instances employ would default the value to
      // 0. This block keeps that intact.
      this.value = new _bignumber.BigNumber('0', 10);
      this.base = 10;
    } else if (base) {
      this.value = valueToBigNumber(value, base);
    } else {
      throw new Error(`You must specify the base of the provided number if the value is not already a BigNumber`);
    }
  }

  /**
   * This is a tool used internally to check if a value is already a Numeric
   * and return it if it is, otherwise it uses the other provided arguments to
   * create a new Numeric.
   *
   * @param value - The value of the Numeric
   * @param base - Either undefined, 10 for decimal or 16 for hexadecimal
   * @param denomination - The Ether denomination to set, if any
   */
  static from(value, base, denomination) {
    if (value instanceof Numeric) {
      if (base || denomination) {
        throw new Error(`Numeric.from was called with a value (${value.toString()}) that is already a Numeric but a base and/or denomination was provided. Only supply base or denomination when creating a new Numeric`);
      }
      return value;
    }
    return new Numeric(value, base, denomination);
  }

  /** Conversions */

  /**
   * Returns a new Numeric with the base value changed to the provided base,
   * or the original Numeric if the base provided is the same as the current
   * base. No computation or conversion happens here but rather the result of
   * toString will be changed depending on the value of this.base when that
   * method is invoked.
   *
   * @param base - The numeric base to change the Numeric to, either 10 or 16
   * @returns A new Numeric with the base updated
   */
  toBase(base) {
    if (this.base !== base) {
      return new Numeric(this.value, base, this.denomination);
    }
    return this;
  }

  /**
   * Converts the value to the specified denomination. The following quirks of
   * the predecessor to Numeric, 'conversionUtil', were programmed into this
   * method:
   * 1. You may supply a denomination that is undefined, which will result in
   * nothing happening. Coincidently this is also useful due to the nature of
   * chaining operations on Numeric. You may pass an undefined value in this
   * method without breaking the chain to conditionally apply a operator.
   * 2. If the numeric that .toDenomination is called on does not have a
   * denomination set, that is it was constructed without the third parameter,
   * then it is assumed to be in ETH. Otherwise we convert it to ETH prior to
   * attempting to convert it to another denomination because all of the
   * toSpecifiedDenomination methods assume a value in ETH is passed.
   *
   * @param denomination - The denomination to convert to
   * @returns A new numeric with the same base as the previous, but the
   * value and denomination changed accordingly
   */
  toDenomination(denomination) {
    if (denomination && this.denomination !== denomination) {
      const result = new Numeric(toSpecifiedDenomination[denomination](getValueInETH(this)), this.base, denomination);
      return result;
    }
    return this;
  }

  /**
   * Replicates a method of BigNumber that is not in the version of BigNumber
   * that we use currently. Essentially shifting the decimal point backwards by
   * an amount equal to the positive number supplied to the decimals operator.
   * For example, calling shiftedBy(10) on the value 10000000000 will result in
   * a value of 1.0000000000. If passing a negative number, then the decimal
   * position will move forward. 1.0000000000 shiftedBy(-10) yields 10000000000
   *
   * @param decimals - The number of decimal places to move. Positive moves
   * decimal backwards, creating a smaller number. Negative values move the
   * decimal forwards, creating a larger number.
   * @returns A new numeric with the same base and denomination as the current
   * but with a new value.
   */
  shiftedBy(decimals) {
    const powerOf = new Numeric(Math.pow(10, decimals), 10);
    return this.divide(powerOf);
  }

  /**
   * Applies a conversion rate to the Numeric. If rate is undefined returns the
   * same instance that was operated on. Allowing an undefined value makes
   * chaining this operator feasible with undefined values from the user or
   * state without manipulating the number. For example:
   *
   * new Numeric(5, 10)
   * .applyConversionRate(possiblyUndefinedRate)
   * .toBase(16)
   * .toString();
   *
   * Will return a valid result as long as possiblyUndefinedRate is undefined,
   * a BigNumber or a number. In some areas of the codebase we check to see if
   * the target currency is different from the current currency before applying
   * a conversionRate. This functionality is not built into Numeric and will
   * require breaking the chain before calling this method:
   * let value = new Numeric(5, 10);
   *
   * if (fromCurrency !== toCurrency) {
   * value = value.applyConversionRate(possiblyUndefinedRate);
   * }
   *
   * return value.toBase(16).toString();
   *
   * @param rate - The multiplier to apply
   * @param invert - if true, inverts the rate
   * @returns New Numeric value with conversion rate applied.
   */
  applyConversionRate(rate, invert) {
    if (typeof rate === 'undefined') {
      return this;
    }
    let conversionRate = new Numeric(rate, 10);
    if (invert) {
      conversionRate = new Numeric(new _bignumber.BigNumber(1.0)).divide(conversionRate);
    }
    return this.times(conversionRate);
  }
  round(numberOfDecimals, roundingMode = _bignumber.BigNumber.ROUND_HALF_DOWN) {
    if (typeof numberOfDecimals === 'number') {
      return new Numeric(this.value.round(numberOfDecimals, roundingMode), this.base, this.denomination);
    }
    return this;
  }

  /**
   * TODO: make it possible to add ETH + GWEI value. So if you have
   * Numeric 1 with denomination ETH and Numeric 2 with Denomination WEI,
   * first convert Numeric 2 to ETH then add the amount to Numeric 1.
   *
   * @param value
   * @param base
   * @param denomination
   */
  add(value, base, denomination) {
    const numeric = Numeric.from(value, base, denomination);
    return new Numeric(this.value.add(alignOperandDenominations(this, numeric).value), this.base, this.denomination);
  }

  /**
   * TODO: make it possible to subtract ETH - GWEI value. So if you have
   * Numeric 1 with denomination ETH and Numeric 2 with Denomination WEI,
   * first convert Numeric 2 to ETH then subtract the amount from Numeric 1.
   *
   * @param value
   * @param base
   * @param denomination
   */
  minus(value, base, denomination) {
    const numeric = Numeric.from(value, base, denomination);
    return new Numeric(this.value.minus(alignOperandDenominations(this, numeric).value), this.base, this.denomination);
  }
  times(multiplier, base, denomination) {
    const multiplierNumeric = Numeric.from(multiplier, base, denomination);
    return new Numeric(this.value.times(alignOperandDenominations(this, multiplierNumeric).value), this.base, this.denomination);
  }

  /**
   * Divides the Numeric by another supplied Numeric, carrying over the base
   * and denomination from the current Numeric.
   *
   * @param divisor - The Numeric to divide this Numeric by
   * @param base
   * @param denomination
   * @returns A new Numeric that contains the result of the division
   */
  divide(divisor, base, denomination) {
    return new Numeric(this.value.div(alignOperandDenominations(this, Numeric.from(divisor, base, denomination)).value), this.base, this.denomination);
  }
  greaterThan(comparator, base, denomination) {
    return this.value.greaterThan(Numeric.from(comparator, base, denomination).value);
  }
  greaterThanOrEqualTo(comparator, base, denomination) {
    return this.value.greaterThanOrEqualTo(Numeric.from(comparator, base, denomination).value);
  }
  lessThan(comparator, base, denomination) {
    return this.value.lessThan(Numeric.from(comparator, base, denomination).value);
  }
  lessThanOrEqualTo(comparator, base, denomination) {
    return this.value.lessThanOrEqualTo(Numeric.from(comparator, base, denomination).value);
  }
  isNegative() {
    return this.value.isNegative();
  }
  isPositive() {
    return this.isNegative() === false;
  }

  /**
   * Get a base 16 hexadecimal string representation of the Numeric that is
   * 0x prefixed. This operation bypasses the currently set base of the
   * Numeric.
   *
   * @returns 0x prefixed hexstring.
   */
  toPrefixedHexString() {
    return (0, _ethereumjsUtil.addHexPrefix)(this.value.toString(16));
  }

  /**
   * Gets the string representation of the Numeric, using the current value of
   * this.base to determine if it should be a decimal or hexadecimal string.
   *
   * @returns the string representation of the Numeric
   */
  toString() {
    return this.value.toString(this.base);
  }

  /**
   * Returns a fixed-point decimal string representation of the Numeric
   *
   * @param decimals - the amount of decimal precision to use when rounding
   * @returns A fixed point decimal string represenation of the Numeric
   */
  toFixed(decimals) {
    return this.value.toFixed(decimals);
  }

  /**
   * Converts the value to a JavaScript Number, with all of the inaccuracy that
   * could come with that.
   *
   * @returns The value as a JS Number
   */
  toNumber() {
    return this.value.toNumber();
  }
}
exports.Numeric = Numeric;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\Numeric.ts",}],
["F:\\metamask-extension\\shared\\modules\\browser-runtime.utils.js", {"loglevel":"F:\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js","webextension-polyfill":"F:\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cbrowser-runtime.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkForLastError = checkForLastError;
exports.checkForLastErrorAndLog = checkForLastErrorAndLog;
exports.checkForLastErrorAndWarn = checkForLastErrorAndWarn;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _loglevel = _interopRequireDefault(require("loglevel"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Utility Functions to support browser.runtime JavaScript API
 */

/**
 * Returns an Error if extension.runtime.lastError is present
 * this is a workaround for the non-standard error object that's used
 *
 * According to the docs, we are expected to check lastError in runtime API callbacks:
 * "
 * If you call an asynchronous function that may set lastError, you are expected to
 * check for the error when you handle the result of the function. If lastError has been
 * set and you don't check it within the callback function, then an error will be raised.
 * "
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/lastError}
 * @returns {Error|undefined}
 */
function checkForLastError() {
  const {
    lastError
  } = _webextensionPolyfill.default.runtime;
  if (!lastError) {
    return undefined;
  }
  // if it quacks like an Error, its an Error
  if (lastError.stack && lastError.message) {
    return lastError;
  }
  // repair incomplete error object (eg chromium v77)
  return new Error(lastError.message);
}

/** @returns {Error|undefined} */
function checkForLastErrorAndLog() {
  const error = checkForLastError();
  if (error) {
    _loglevel.default.error(error);
  }
  return error;
}

/** @returns {Error|undefined} */
function checkForLastErrorAndWarn() {
  const error = checkForLastError();
  if (error) {
    console.warn(error);
  }
  return error;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\browser-runtime.utils.js",}],
["F:\\metamask-extension\\shared\\modules\\contract-utils.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Ccontract-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readAddressAsContract = void 0;
const readAddressAsContract = async (ethQuery, address) => {
  let contractCode;
  try {
    contractCode = await ethQuery.getCode(address);
  } catch (e) {
    contractCode = null;
  }
  const isContractAddress = contractCode ? contractCode !== '0x' && contractCode !== '0x0' : false;
  return {
    contractCode,
    isContractAddress
  };
};
exports.readAddressAsContract = readAddressAsContract;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\contract-utils.ts",}],
["F:\\metamask-extension\\shared\\modules\\conversion.utils.ts", {"../constants/common":"F:\\metamask-extension\\shared\\constants\\common.ts","./Numeric":"F:\\metamask-extension\\shared\\modules\\Numeric.ts","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cconversion.utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addHexes = addHexes;
exports.bnToHex = bnToHex;
exports.decEthToConvertedCurrency = decEthToConvertedCurrency;
exports.decGWEIToHexWEI = decGWEIToHexWEI;
exports.decWEIToDecETH = decWEIToDecETH;
exports.decimalToHex = decimalToHex;
exports.getEthConversionFromWeiHex = getEthConversionFromWeiHex;
exports.getValueFromWeiHex = getValueFromWeiHex;
exports.getWeiHexFromDecimalValue = getWeiHexFromDecimalValue;
exports.hexToDecimal = hexToDecimal;
exports.hexWEIToDecETH = hexWEIToDecETH;
exports.hexWEIToDecGWEI = hexWEIToDecGWEI;
exports.subtractHexes = subtractHexes;
exports.sumHexes = sumHexes;
var _bignumber = require("bignumber.js");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("../constants/common");
var _Numeric = require("./Numeric");
function decGWEIToHexWEI(decGWEI) {
  return new _Numeric.Numeric(decGWEI, 10, _common.EtherDenomination.GWEI).toBase(16).toDenomination(_common.EtherDenomination.WEI).toString();
}
function subtractHexes(aHexWEI, bHexWEI) {
  return new _Numeric.Numeric(aHexWEI, 16).minus(new _Numeric.Numeric(bHexWEI, 16)).round(6, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function addHexes(aHexWEI, bHexWEI) {
  return new _Numeric.Numeric(aHexWEI, 16).add(new _Numeric.Numeric(bHexWEI, 16)).round(6, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function decWEIToDecETH(decWEI) {
  return new _Numeric.Numeric(decWEI, 10, _common.EtherDenomination.WEI).toDenomination(_common.EtherDenomination.ETH).toString();
}
function hexWEIToDecETH(hexWEI) {
  return new _Numeric.Numeric(hexWEI, 16, _common.EtherDenomination.WEI).toDenomination(_common.EtherDenomination.ETH).toBase(10).toString();
}
function decEthToConvertedCurrency(ethTotal, convertedCurrency, conversionRate) {
  let numeric = new _Numeric.Numeric(ethTotal, 10, _common.EtherDenomination.ETH);
  if (convertedCurrency !== _common.EtherDenomination.ETH) {
    numeric = numeric.applyConversionRate(conversionRate);
  }
  return numeric.round(2);
}
function getWeiHexFromDecimalValue({
  value,
  conversionRate = 1,
  fromDenomination,
  fromCurrency,
  invertConversionRate = false
}) {
  let numeric = new _Numeric.Numeric(value, 10, fromDenomination);
  if (fromCurrency !== _common.EtherDenomination.ETH) {
    numeric = numeric.applyConversionRate(conversionRate, invertConversionRate);
  }
  return numeric.toBase(16).toDenomination(_common.EtherDenomination.WEI).toString();
}

/**
 * Converts a BN object to a hex string with a '0x' prefix
 *
 * @param inputBn - The BN to convert to a hex string
 * @returns A '0x' prefixed hex string
 */
function bnToHex(inputBn) {
  return (0, _ethereumjsUtil.addHexPrefix)(inputBn.toString(16));
}
function getEthConversionFromWeiHex({
  value,
  fromCurrency = _common.EtherDenomination.ETH,
  conversionRate,
  numberOfDecimals = 6
}) {
  const denominations = [_common.EtherDenomination.ETH, _common.EtherDenomination.GWEI, _common.EtherDenomination.WEI];
  let nonZeroDenomination;
  for (let i = 0; i < denominations.length; i++) {
    const convertedValue = getValueFromWeiHex({
      value,
      conversionRate,
      fromCurrency,
      toCurrency: fromCurrency,
      numberOfDecimals,
      toDenomination: denominations[i]
    });
    if (convertedValue !== '0' || i === denominations.length - 1) {
      nonZeroDenomination = `${convertedValue} ${denominations[i]}`;
      break;
    }
  }
  return nonZeroDenomination;
}
function getValueFromWeiHex({
  value,
  fromCurrency = _common.EtherDenomination.ETH,
  toCurrency,
  conversionRate,
  numberOfDecimals,
  toDenomination = _common.EtherDenomination.ETH
}) {
  let numeric = new _Numeric.Numeric(value, 16, _common.EtherDenomination.WEI);
  if (fromCurrency !== toCurrency) {
    numeric = numeric.applyConversionRate(conversionRate);
  }
  return numeric.toBase(10).toDenomination(toDenomination).round(numberOfDecimals, _bignumber.BigNumber.ROUND_HALF_DOWN).toString();
}
function sumHexes(first, ...args) {
  const firstValue = new _Numeric.Numeric(first, 16);
  const total = args.reduce((acc, hexAmount) => acc.add(new _Numeric.Numeric(hexAmount, 16)), firstValue);
  return total.toPrefixedHexString();
}
function hexWEIToDecGWEI(value) {
  return new _Numeric.Numeric(value, 16, _common.EtherDenomination.WEI).toBase(10).toDenomination(_common.EtherDenomination.GWEI).toString();
}
function decimalToHex(decimal) {
  return new _Numeric.Numeric(decimal, 10).toBase(16).toString();
}
function hexToDecimal(hexValue) {
  return new _Numeric.Numeric(hexValue, 16).toBase(10).toString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\conversion.utils.ts",}],
["F:\\metamask-extension\\shared\\modules\\fetch-with-timeout.ts", {"../constants/time":"F:\\metamask-extension\\shared\\constants\\time.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cfetch-with-timeout.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _time = require("../constants/time");
/**
 * Returns a function that can be used to make an HTTP request but timing out
 * automatically after a desired amount of time.
 *
 * @param timeout - The number of milliseconds to wait until the request times
 * out.
 * @returns A function that, when called, returns a promise that either resolves
 * to the HTTP response object or is rejected if a network error is encountered
 * or the request times out.
 */
const getFetchWithTimeout = (0, _lodash.memoize)((timeout = _time.SECOND * 30) => {
  if (!Number.isInteger(timeout) || timeout < 1) {
    throw new Error('Must specify positive integer timeout.');
  }
  return async function fetchWithTimeout(url, opts) {
    const abortController = new window.AbortController();
    const {
      signal
    } = abortController;
    const f = window.fetch(url, {
      ...opts,
      signal
    });
    const timer = setTimeout(() => abortController.abort(), timeout);
    try {
      return await f;
    } finally {
      clearTimeout(timer);
    }
  };
});
var _default = getFetchWithTimeout;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\fetch-with-timeout.ts",}],
["F:\\metamask-extension\\shared\\modules\\hexstring-utils.ts", {"ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Chexstring-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BURN_ADDRESS = void 0;
exports.isBurnAddress = isBurnAddress;
exports.isEmptyHexString = isEmptyHexString;
exports.isValidHexAddress = isValidHexAddress;
exports.stripHexPrefix = stripHexPrefix;
exports.toChecksumHexAddress = toChecksumHexAddress;
var _ethereumjsUtil = require("ethereumjs-util");
const BURN_ADDRESS = (0, _ethereumjsUtil.zeroAddress)();
exports.BURN_ADDRESS = BURN_ADDRESS;
function isBurnAddress(address) {
  return address === BURN_ADDRESS;
}
function isEmptyHexString(value) {
  return [undefined, null, '0x', '0x0', '0x0000000000000000000000000000000000000000000000000000000000000000'].includes(value);
}

/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 *
 * @param possibleAddress - Input parameter to check against
 * @param [options] - options bag
 * @param [options.allowNonPrefixed] - If true will first ensure '0x'
 * is prepended to the string
 * @param [options.mixedCaseUseChecksum] - If true will treat mixed
 * case addresses as checksum addresses and validate that proper checksum
 * format is used
 * @returns whether or not the input is a valid hex address
 */
function isValidHexAddress(possibleAddress, {
  allowNonPrefixed = true,
  mixedCaseUseChecksum = false
} = {}) {
  const addressToCheck = allowNonPrefixed ? (0, _ethereumjsUtil.addHexPrefix)(possibleAddress) : possibleAddress;
  if (!(0, _ethereumjsUtil.isHexString)(addressToCheck)) {
    return false;
  }
  if (mixedCaseUseChecksum) {
    const prefixRemoved = addressToCheck.slice(2);
    const lower = prefixRemoved.toLowerCase();
    const upper = prefixRemoved.toUpperCase();
    const allOneCase = prefixRemoved === lower || prefixRemoved === upper;
    if (!allOneCase) {
      return (0, _ethereumjsUtil.isValidChecksumAddress)(addressToCheck);
    }
  }
  return (0, _ethereumjsUtil.isValidAddress)(addressToCheck);
}
function toChecksumHexAddress(address) {
  if (!address) {
    // our internal checksumAddress function that this method replaces would
    // return an empty string for nullish input. If any direct usages of
    // ethereumjs-util.toChecksumAddress were called with nullish input it
    // would have resulted in an error on version 5.1.
    return '';
  }
  const hexPrefixed = (0, _ethereumjsUtil.addHexPrefix)(address);
  if (!(0, _ethereumjsUtil.isHexString)(hexPrefixed)) {
    // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
    // but we shouldn't waste effort trying to change case on a clearly invalid
    // string. Instead just return the hex prefixed original string which most
    // closely mimics the original behavior.
    return hexPrefixed;
  }
  return (0, _ethereumjsUtil.toChecksumAddress)(hexPrefixed);
}
function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }
  return (0, _ethereumjsUtil.isHexPrefixed)(str) ? str.slice(2) : str;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\hexstring-utils.ts",}],
["F:\\metamask-extension\\shared\\modules\\i18n.ts", {"./fetch-with-timeout":"F:\\metamask-extension\\shared\\modules\\fetch-with-timeout.ts","loglevel":"F:\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Ci18n.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FALLBACK_LOCALE = void 0;
exports.clearCaches = clearCaches;
exports.fetchLocale = fetchLocale;
exports.getMessage = void 0;
exports.loadRelativeTimeFormatLocaleData = loadRelativeTimeFormatLocaleData;
var _loglevel = _interopRequireDefault(require("loglevel"));
var _fetchWithTimeout = _interopRequireDefault(require("./fetch-with-timeout"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const fetchWithTimeout = (0, _fetchWithTimeout.default)();

// From app/_locales folders there is a messages.json file such as app/_locales/en, comes with key and translated results
// and we use as t('reject') to get the translated message in the codebase
// and in i18n lib, the translated message is an object (I18NMessage) with message & description -
// message is the string that will replace the translationKey, and that message may contain replacement variables such as $1, $2, etc.
// Description is key describing the usage of the message.
// The overall translation file is made of same entries
// translationKey (string) and the I18NMessage as the value.
// A parameterized type (or generic type) of maps that use the same structure (translationKey) key
const FALLBACK_LOCALE = 'en';
exports.FALLBACK_LOCALE = FALLBACK_LOCALE;
const warned = {};
const missingMessageErrors = {};
const missingSubstitutionErrors = {};
const relativeTimeFormatLocaleData = new Set();

/**
 * Returns a localized message for the given key
 *
 * @param localeCode - The code for the current locale
 * @param localeMessages - The map of messages for the current locale
 * @param key - The message key
 * @param substitutions - A list of message substitution replacements can replace $n in given message
 * @param onError - An optional callback to provide additional processing on any errors
 * @param join - An optional callback to join the substituted parts using custom logic
 * @returns The localized message
 */
const getMessage = (localeCode, localeMessages, key, substitutions, onError, join) => {
  if (!localeMessages) {
    return null;
  }
  const message = localeMessages[key];
  if (!message) {
    missingKeyError(key, localeCode, onError);
    return null;
  }
  const text = message.message;
  const parts = hasSubstitutions(substitutions) ? applySubstitutions(text, substitutions, key, localeCode, onError) : [text];
  return join ? join(parts) : parts.join('');
};
exports.getMessage = getMessage;
async function fetchLocale(localeCode) {
  try {
    const response = await fetchWithTimeout(`./_locales/${localeCode}/messages.json`);
    return await response.json();
  } catch (error) {
    _loglevel.default.error(`failed to fetch ${localeCode} locale because of ${error}`);
    return {};
  }
}
async function loadRelativeTimeFormatLocaleData(localeCode) {
  const languageTag = localeCode.split('_')[0];
  if (Intl.RelativeTimeFormat && typeof Intl.RelativeTimeFormat.__addLocaleData === 'function' && !relativeTimeFormatLocaleData.has(languageTag)) {
    const localeData = await fetchRelativeTimeFormatData(languageTag);
    Intl.RelativeTimeFormat.__addLocaleData(localeData);
    relativeTimeFormatLocaleData.add(languageTag);
  }
}
function clearCaches() {
  Object.keys(warned).forEach(key => {
    delete warned[key];
  });
  Object.keys(missingMessageErrors).forEach(key => {
    delete missingMessageErrors[key];
  });
  Object.keys(missingSubstitutionErrors).forEach(key => {
    delete missingSubstitutionErrors[key];
  });
  relativeTimeFormatLocaleData.clear();
}
function applySubstitutions(message, substitutions, key, localeCode, onError) {
  const parts = message.split(/(\$\d)/gu);
  return parts.map(part => {
    const subMatch = part.match(/\$(\d)/u);
    if (!subMatch) {
      return part;
    }
    const substituteIndex = Number(subMatch[1]) - 1;
    const substitution = substitutions[substituteIndex];
    if (substitution === null || substitution === undefined) {
      missingSubstitutionError(key, localeCode, onError);
    }
    return substitutions === null || substitutions === void 0 ? void 0 : substitutions[substituteIndex];
  });
}
function missingKeyError(key, localeCode, onError) {
  var _warned$localeCode;
  if (localeCode === FALLBACK_LOCALE && !missingMessageErrors[key]) {
    const error = new Error(`Unable to find value of key "${key}" for locale "${localeCode}"`);
    missingMessageErrors[key] = error;
    onError === null || onError === void 0 ? void 0 : onError(error);
    _loglevel.default.error(error);
    if (false) {
      throw error;
    }
  }
  if (localeCode === FALLBACK_LOCALE || (_warned$localeCode = warned[localeCode]) !== null && _warned$localeCode !== void 0 && _warned$localeCode[key]) {
    return;
  }
  warned[localeCode] = warned[localeCode] ?? {};
  warned[localeCode][key] = true;
  _loglevel.default.warn(`Translator - Unable to find value of key "${key}" for locale "${localeCode}"`);
}
function missingSubstitutionError(key, localeCode, onError) {
  var _missingSubstitutionE;
  if ((_missingSubstitutionE = missingSubstitutionErrors[localeCode]) !== null && _missingSubstitutionE !== void 0 && _missingSubstitutionE[key]) {
    return;
  }
  missingSubstitutionErrors[localeCode] = missingSubstitutionErrors[localeCode] ?? {};
  missingSubstitutionErrors[localeCode][key] = true;
  const error = new Error(`Insufficient number of substitutions for key "${key}" with locale "${localeCode}"`);
  _loglevel.default.error(error);
  onError === null || onError === void 0 ? void 0 : onError(error);
}
function hasSubstitutions(substitutions) {
  return ((substitutions === null || substitutions === void 0 ? void 0 : substitutions.length) ?? 0) > 0;
}
async function fetchRelativeTimeFormatData(languageTag) {
  const response = await fetchWithTimeout(`./intl/${languageTag}/relative-time-format-data.json`);
  return await response.json();
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\i18n.ts",}],
["F:\\metamask-extension\\shared\\modules\\mv3.utils.js", {"webextension-polyfill":"F:\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cmv3.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isManifestV3 = void 0;
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const isManifestV3 = _webextensionPolyfill.default.runtime.getManifest().manifest_version === 3;
exports.isManifestV3 = isManifestV3;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\mv3.utils.js",}],
["F:\\metamask-extension\\shared\\modules\\network.utils.ts", {"../constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cnetwork.utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPrefixedFormattedHexString = isPrefixedFormattedHexString;
exports.isSafeChainId = isSafeChainId;
exports.isTokenDetectionEnabledForNetwork = isTokenDetectionEnabledForNetwork;
exports.shouldShowLineaMainnet = shouldShowLineaMainnet;
var _network = require("../constants/network");
/**
 * Checks whether the given number primitive chain ID is safe.
 * Because some cryptographic libraries we use expect the chain ID to be a
 * number primitive, it must not exceed a certain size.
 *
 * @param chainId - The chain ID to check for safety.
 * @returns Whether the given chain ID is safe.
 */
function isSafeChainId(chainId) {
  return isSafeInteger(chainId) && chainId > 0 && chainId <= _network.MAX_SAFE_CHAIN_ID;
}

/**
 * Checks whether the given value is a 0x-prefixed, non-zero, non-zero-padded,
 * hexadecimal string.
 *
 * @param value - The value to check.
 * @returns True if the value is a correctly formatted hex string,
 * false otherwise.
 */
function isPrefixedFormattedHexString(value) {
  if (typeof value !== 'string') {
    return false;
  }
  return /^0x[1-9a-f]+[0-9a-f]*$/iu.test(value);
}

/**
 * Check if token detection is enabled for certain networks
 *
 * @param chainId - ChainID of network
 * @returns Whether the current network supports token detection
 */
function isTokenDetectionEnabledForNetwork(chainId) {
  switch (chainId) {
    case _network.CHAIN_IDS.MAINNET:
    case _network.CHAIN_IDS.BSC:
    case _network.CHAIN_IDS.POLYGON:
    case _network.CHAIN_IDS.AVALANCHE:
    case _network.CHAIN_IDS.AURORA:
      return true;
    default:
      return false;
  }
}

/**
 * Like {@link Number.isSafeInteger}, but types the input as a `number` if it is
 * indeed a safe integer.
 *
 * @param value - The value to check.
 * @returns True if the value is a safe integer, false otherwise.
 */
function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}
function shouldShowLineaMainnet() {
  return new Date().getTime() > Date.UTC(2023, 6, 11, 18);
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\network.utils.ts",}],
["F:\\metamask-extension\\shared\\modules\\object.utils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cobject.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maskObject = maskObject;
/**
 * Return a "masked" copy of the given object.
 *
 * The returned object includes only the properties present in the mask. The
 * mask is an object that mirrors the structure of the given object, except
 * the only values are `true` or a sub-mask. `true` implies the property
 * should be included, and a sub-mask implies the property should be further
 * masked according to that sub-mask.
 *
 * @param {object} object - The object to mask
 * @param {Object<object | boolean>} mask - The mask to apply to the object
 */
function maskObject(object, mask) {
  return Object.keys(object).reduce((state, key) => {
    if (mask[key] === true) {
      state[key] = object[key];
    } else if (mask[key]) {
      state[key] = maskObject(object[key], mask[key]);
    }
    return state;
  }, {});
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\object.utils.js",}],
["F:\\metamask-extension\\shared\\modules\\random-id.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Crandom-id.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRandomId;
const MAX = Number.MAX_SAFE_INTEGER;
let idCounter = Math.round(Math.random() * MAX);
function createRandomId() {
  idCounter %= MAX;
  // eslint-disable-next-line no-plusplus
  return idCounter++;
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\random-id.js",}],
["F:\\metamask-extension\\shared\\modules\\string-utils.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cstring-utils.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEqualCaseInsensitive = isEqualCaseInsensitive;
exports.prependZero = prependZero;
/**
 * Compare 2 given strings and return boolean
 * eg: "foo" and "FOO" => true
 * eg: "foo" and "bar" => false
 * eg: "foo" and 123 => false
 *
 * @param value1 - first string to compare
 * @param value2 - first string to compare
 * @returns true if 2 strings are identical when they are lowercase
 */
function isEqualCaseInsensitive(value1, value2) {
  if (typeof value1 !== 'string' || typeof value2 !== 'string') {
    return false;
  }
  return value1.toLowerCase() === value2.toLowerCase();
}

/**
 * Takes a number with max length until the resulting string reaches the given length
 *
 * @param num
 * @param maxLength
 */
function prependZero(num, maxLength) {
  return num.toString().padStart(maxLength, '0');
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\string-utils.ts",}],
["F:\\metamask-extension\\shared\\modules\\swaps.utils.js", {"../constants/swaps":"F:\\metamask-extension\\shared\\constants\\swaps.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Cswaps.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwapsDefaultTokenAddress = isSwapsDefaultTokenAddress;
exports.isSwapsDefaultTokenSymbol = isSwapsDefaultTokenSymbol;
var _swaps = require("../constants/swaps");
/**
 * Checks whether the provided address is strictly equal to the address for
 * the default swaps token of the provided chain.
 *
 * @param {string} address - The string to compare to the default token address
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the address is the provided chain's default token address
 */
function isSwapsDefaultTokenAddress(address, chainId) {
  var _SWAPS_CHAINID_DEFAUL;
  if (!address || !chainId) {
    return false;
  }
  return address === ((_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address);
}

/**
 * Checks whether the provided symbol is strictly equal to the symbol for
 * the default swaps token of the provided chain.
 *
 * @param {string} symbol - The string to compare to the default token symbol
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the symbl is the provided chain's default token symbol
 */
function isSwapsDefaultTokenSymbol(symbol, chainId) {
  var _SWAPS_CHAINID_DEFAUL2;
  if (!symbol || !chainId) {
    return false;
  }
  return symbol === ((_SWAPS_CHAINID_DEFAUL2 = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL2 === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL2.symbol);
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\swaps.utils.js",}],
["F:\\metamask-extension\\shared\\modules\\transaction.utils.js", {"../constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","./contract-utils":"F:\\metamask-extension\\shared\\modules\\contract-utils.ts","./string-utils":"F:\\metamask-extension\\shared\\modules\\string-utils.ts","@ethersproject/abi":"F:\\metamask-extension\\node_modules\\@ethersproject\\abi\\lib\\index.js","@metamask/metamask-eth-abis":"F:\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","loglevel":"F:\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cmodules%5Ctransaction.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.determineTransactionAssetType = determineTransactionAssetType;
exports.determineTransactionContractCode = determineTransactionContractCode;
exports.determineTransactionType = determineTransactionType;
exports.isEIP1559Transaction = isEIP1559Transaction;
exports.isLegacyTransaction = isLegacyTransaction;
exports.parseStandardTokenTransactionData = parseStandardTokenTransactionData;
exports.transactionMatchesNetwork = transactionMatchesNetwork;
exports.txParamsAreDappSuggested = txParamsAreDappSuggested;
var _ethereumjsUtil = require("ethereumjs-util");
var _abi = require("@ethersproject/abi");
var _metamaskEthAbis = require("@metamask/metamask-eth-abis");
var _loglevel = _interopRequireDefault(require("loglevel"));
var _transaction = require("../constants/transaction");
var _contractUtils = require("./contract-utils");
var _stringUtils = require("./string-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @typedef { 'transfer' | 'approve' | 'setapprovalforall' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes
 */

/**
 * @typedef {object} InferTransactionTypeResult
 * @property {InferrableTransactionTypes} type - The type of transaction
 * @property {string} getCodeResponse - The contract code, in hex format if
 *  it exists. '0x0' or '0x' are also indicators of non-existent contract
 *  code
 */
/**
 * @typedef EthersContractCall
 * @type object
 * @property {any[]} args - The args/params to the function call.
 * An array-like object with numerical and string indices.
 * @property {string} name - The name of the function.
 * @property {string} signature - The function signature.
 * @property {string} sighash - The function signature hash.
 * @property {EthersBigNumber} value - The ETH value associated with the call.
 * @property {FunctionFragment} functionFragment - The Ethers function fragment
 * representation of the function.
 */
const erc20Interface = new _abi.Interface(_metamaskEthAbis.abiERC20);
const erc721Interface = new _abi.Interface(_metamaskEthAbis.abiERC721);
const erc1155Interface = new _abi.Interface(_metamaskEthAbis.abiERC1155);
function transactionMatchesNetwork(transaction, chainId, networkId) {
  if (typeof transaction.chainId !== 'undefined') {
    return transaction.chainId === chainId;
  }
  return transaction.metamaskNetworkId === networkId;
}

/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid EIP1559 fields
 */
function isEIP1559Transaction(transaction) {
  var _transaction$txParams, _transaction$txParams2;
  return (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams = transaction.txParams) === null || _transaction$txParams === void 0 ? void 0 : _transaction$txParams.maxFeePerGas) && (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams2 = transaction.txParams) === null || _transaction$txParams2 === void 0 ? void 0 : _transaction$txParams2.maxPriorityFeePerGas);
}

/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */
function isLegacyTransaction(transaction) {
  return typeof transaction.txParams.maxFeePerGas === 'undefined' && typeof transaction.txParams.maxPriorityFeePerGas === 'undefined' && (typeof transaction.txParams.gasPrice === 'undefined' || (0, _ethereumjsUtil.isHexString)(transaction.txParams.gasPrice));
}

/**
 * Determine if a transactions gas fees in txParams match those in its dappSuggestedGasFees property
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if both the txParams and dappSuggestedGasFees are objects with truthy gas fee properties,
 *   and those properties are strictly equal
 */
function txParamsAreDappSuggested(transaction) {
  var _transaction$dappSugg, _transaction$dappSugg2, _transaction$dappSugg3;
  const {
    gasPrice,
    maxPriorityFeePerGas,
    maxFeePerGas
  } = (transaction === null || transaction === void 0 ? void 0 : transaction.txParams) || {};
  return gasPrice && gasPrice === (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg === void 0 ? void 0 : _transaction$dappSugg.gasPrice) || maxPriorityFeePerGas && maxFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg2 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg2 === void 0 ? void 0 : _transaction$dappSugg2.maxPriorityFeePerGas) === maxPriorityFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg3 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg3 === void 0 ? void 0 : _transaction$dappSugg3.maxFeePerGas) === maxFeePerGas;
}

/**
 * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.
 * The data will decode correctly if the transaction is an interaction with a contract that matches one of these
 * contract standards
 *
 * @param data - encoded transaction data
 * @returns {EthersContractCall | undefined}
 */
function parseStandardTokenTransactionData(data) {
  try {
    return erc20Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and next try to parse with erc721 ABI
  }
  try {
    return erc721Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and next try to parse with erc1155 ABI
  }
  try {
    return erc1155Interface.parseTransaction({
      data
    });
  } catch {
    // ignore and return undefined
  }
  return undefined;
}

/**
 * Determines the contractCode of the transaction by analyzing the txParams.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */
async function determineTransactionContractCode(txParams, query) {
  const {
    to
  } = txParams;
  const {
    contractCode
  } = await (0, _contractUtils.readAddressAsContract)(query, to);
  return contractCode;
}

/**
 * Determines the type of the transaction by analyzing the txParams.
 * This method will return one of the types defined in shared/constants/transactions
 * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
 * represent specific events that we control from the extension and are added manually
 * at transaction creation.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */
async function determineTransactionType(txParams, query) {
  const {
    data,
    to
  } = txParams;
  let name;
  try {
    ({
      name
    } = data && parseStandardTokenTransactionData(data));
  } catch (error) {
    _loglevel.default.debug('Failed to parse transaction data.', error, data);
  }
  let result;
  let contractCode;
  if (data && !to) {
    result = _transaction.TransactionType.deployContract;
  } else {
    const {
      contractCode: resultCode,
      isContractAddress
    } = await (0, _contractUtils.readAddressAsContract)(query, to);
    contractCode = resultCode;
    if (isContractAddress) {
      const hasValue = txParams.value && Number(txParams.value) !== 0;
      const tokenMethodName = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom, _transaction.TransactionType.tokenMethodSafeTransferFrom].find(methodName => (0, _stringUtils.isEqualCaseInsensitive)(methodName, name));
      result = data && tokenMethodName && !hasValue ? tokenMethodName : _transaction.TransactionType.contractInteraction;
    } else {
      result = _transaction.TransactionType.simpleSend;
    }
  }
  return {
    type: result,
    getCodeResponse: contractCode
  };
}
const INFERRABLE_TRANSACTION_TYPES = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom, _transaction.TransactionType.contractInteraction, _transaction.TransactionType.simpleSend];

/**
 * Given a transaction meta object, determine the asset type that the
 * transaction is dealing with, as well as the standard for the token if it
 * is a token transaction.
 *
 * @param {__import__('../constants/transaction').TransactionMeta} txMeta -
 *  transaction meta object
 * @param {EthQuery} query - EthQuery instance
 * @param {Function} getTokenStandardAndDetails - function to get token
 *  standards and details.
 * @returns {{ assetType: string, tokenStandard: string}}
 */
async function determineTransactionAssetType(txMeta, query, getTokenStandardAndDetails) {
  // If the transaction type is already one of the inferrable types, then we do
  // not need to re-establish the type.
  let inferrableType = txMeta.type;
  if (INFERRABLE_TRANSACTION_TYPES.includes(txMeta.type) === false) {
    // Because we will deal with all types of transactions (including swaps)
    // we want to get an inferrable type of transaction that isn't special cased
    // that way we can narrow the number of logic gates required.
    const result = await determineTransactionType(txMeta.txParams, query);
    inferrableType = result.type;
  }

  // If the inferred type of the transaction is one of those that are part of
  // the token contract standards, we can use the getTokenStandardAndDetails
  // method to get the asset type.
  const isTokenMethod = [_transaction.TransactionType.tokenMethodApprove, _transaction.TransactionType.tokenMethodSetApprovalForAll, _transaction.TransactionType.tokenMethodTransfer, _transaction.TransactionType.tokenMethodTransferFrom].find(methodName => methodName === inferrableType);
  if (isTokenMethod ||
  // We can also check any contract interaction type to see if the to address
  // is a token contract. If it isn't, then the method will throw and we can
  // fall through to the other checks.
  inferrableType === _transaction.TransactionType.contractInteraction) {
    try {
      // We don't need a balance check, so the second parameter to
      // getTokenStandardAndDetails is omitted.
      const details = await getTokenStandardAndDetails(txMeta.txParams.to);
      if (details.standard) {
        return {
          assetType: details.standard === _transaction.TokenStandard.ERC20 ? _transaction.AssetType.token : _transaction.AssetType.NFT,
          tokenStandard: details.standard
        };
      }
    } catch {
      // noop, We expect errors here but we don't need to report them or do
      // anything in response.
    }
  }

  // If the transaction is interacting with a contract but isn't a token method
  // we use the 'UNKNOWN' value to show that it isn't a transaction sending any
  // particular asset.
  if (inferrableType === _transaction.TransactionType.contractInteraction) {
    return {
      assetType: _transaction.AssetType.unknown,
      tokenStandard: _transaction.TokenStandard.none
    };
  }
  return {
    assetType: _transaction.AssetType.native,
    tokenStandard: _transaction.TokenStandard.none
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\modules\\transaction.utils.js",}],
["F:\\metamask-extension\\shared\\notifications\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cnotifications%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTranslatedUINotifications = exports.UI_NOTIFICATIONS = void 0;
// Messages and descriptions for these locale keys are in app/_locales/en/messages.json
const UI_NOTIFICATIONS = {
  1: {
    id: 1,
    date: '2021-03-17',
    image: {
      src: 'images/mobile-link-qr.svg',
      height: '230px',
      width: '230px',
      placeImageBelowDescription: true
    }
  },
  3: {
    id: 3,
    date: '2021-03-08'
  },
  4: {
    id: 4,
    date: '2021-05-11',
    image: {
      src: 'images/source-logos-bsc.svg',
      width: '100%'
    }
  },
  5: {
    id: 5,
    date: '2021-06-09'
  },
  6: {
    id: 6,
    date: '2021-05-26'
  },
  7: {
    id: 7,
    date: '2021-09-17'
  },
  8: {
    id: 8,
    date: '2021-11-01'
  },
  9: {
    id: 9,
    date: '2021-12-07',
    image: {
      src: 'images/txinsights.png',
      width: '80%'
    }
  },
  10: {
    id: 10,
    date: '2022-09-15',
    image: {
      src: 'images/token-detection.svg',
      width: '100%'
    }
  },
  11: {
    id: 11,
    date: '2022-09-15'
  },
  12: {
    id: 12,
    date: '2022-05-18',
    image: {
      src: 'images/darkmode-banner.png',
      width: '100%'
    }
  },
  13: {
    id: 13,
    date: '2022-09-15'
  },
  14: {
    id: 14,
    date: '2022-09-15'
  },
  15: {
    id: 15,
    date: '2022-09-15'
  },
  16: {
    id: 16,
    date: null
  },
  17: {
    id: 17,
    date: null
  },
  18: {
    id: 18,
    date: null,
    image: {
      src: 'images/open-sea-security-provider.svg',
      width: '100%'
    }
  },
  19: {
    id: 19,
    date: null,
    image: {
      src: 'images/nfts.svg',
      width: '100%'
    }
  },
  20: {
    id: 20,
    date: null
  },
  21: {
    id: 21,
    date: null,
    image: {
      src: 'images/swaps-redesign.svg',
      width: '100%'
    }
  }
};
exports.UI_NOTIFICATIONS = UI_NOTIFICATIONS;
const getTranslatedUINotifications = (t, locale) => {
  const formattedLocale = locale.replace('_', '-');
  return {
    1: {
      ...UI_NOTIFICATIONS[1],
      title: t('notifications1Title'),
      description: t('notifications1Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[1].date))
    },
    3: {
      ...UI_NOTIFICATIONS[3],
      title: t('notifications3Title'),
      description: t('notifications3Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[3].date))
    },
    4: {
      ...UI_NOTIFICATIONS[4],
      title: t('notifications4Title'),
      description: t('notifications4Description'),
      actionText: t('notifications4ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[4].date))
    },
    5: {
      ...UI_NOTIFICATIONS[5],
      title: t('secretRecoveryPhrase'),
      description: t('notifications5Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[5].date))
    },
    6: {
      ...UI_NOTIFICATIONS[6],
      title: t('notifications6Title'),
      description: [t('notifications6DescriptionOne'), t('notifications6DescriptionTwo'), t('notifications6DescriptionThree')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[6].date))
    },
    7: {
      ...UI_NOTIFICATIONS[7],
      title: t('notifications7Title'),
      description: [t('notifications7DescriptionOne'), t('notifications7DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[7].date))
    },
    8: {
      ...UI_NOTIFICATIONS[8],
      title: t('notifications8Title'),
      description: [t('notifications8DescriptionOne'), t('notifications8DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[8].date)),
      actionText: t('notifications8ActionText')
    },
    9: {
      ...UI_NOTIFICATIONS[9],
      title: t('notifications9Title'),
      description: [t('notifications9DescriptionOne'), t('notifications9DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[9].date))
    },
    10: {
      ...UI_NOTIFICATIONS[10],
      title: t('notifications10Title'),
      description: [t('notifications10DescriptionOne'), t('notifications10DescriptionTwo'), t('notifications10DescriptionThree')],
      actionText: t('notifications10ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[10].date))
    },
    11: {
      ...UI_NOTIFICATIONS[11],
      title: t('notifications11Title'),
      description: t('notifications11Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[11].date))
    },
    12: {
      ...UI_NOTIFICATIONS[12],
      title: t('notifications12Title'),
      description: t('notifications12Description'),
      actionText: t('notifications12ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[12].date))
    },
    13: {
      ...UI_NOTIFICATIONS[13],
      title: t('notifications13Title'),
      description: t('notifications13Description'),
      actionText: t('notifications13ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[13].date))
    },
    14: {
      ...UI_NOTIFICATIONS[14],
      title: t('notifications14Title'),
      description: t('notifications14Description'),
      actionText: t('notifications14ActionText'),
      date: UI_NOTIFICATIONS[14].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[14].date)) : ''
    },
    15: {
      ...UI_NOTIFICATIONS[15],
      title: t('notifications15Title'),
      description: t('notifications15Description'),
      date: UI_NOTIFICATIONS[15].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[15].date)) : ''
    },
    18: {
      ...UI_NOTIFICATIONS[18],
      title: t('notifications18Title'),
      description: [t('notifications18DescriptionOne'), t('notifications18DescriptionTwo'), t('notifications18DescriptionThree')],
      actionText: t('notifications18ActionText'),
      date: UI_NOTIFICATIONS[18].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[18].date)) : ''
    },
    19: {
      ...UI_NOTIFICATIONS[19],
      title: t('notifications19Title'),
      description: [t('notifications19DescriptionOne'), t('notifications19DescriptionTwo'), t('notifications19DescriptionThree')],
      actionText: t('notifications19ActionText'),
      date: UI_NOTIFICATIONS[19].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[19].date)) : ''
    },
    20: {
      ...UI_NOTIFICATIONS[20],
      title: t('notifications20Title'),
      description: [t('notifications20Description')],
      actionText: t('notifications20ActionText'),
      date: UI_NOTIFICATIONS[20].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[20].date)) : ''
    },
    21: {
      ...UI_NOTIFICATIONS[21],
      title: t('notifications21Title'),
      description: t('notifications21Description'),
      actionText: t('notifications21ActionText'),
      date: UI_NOTIFICATIONS[21].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[21].date)) : ''
    }
  };
};
exports.getTranslatedUINotifications = getTranslatedUINotifications;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\notifications\\index.js",}],
["F:\\metamask-extension\\ui\\helpers\\constants\\common.ts", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cui%5Chelpers%5Cconstants%5Ccommon.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SUPPORT_REQUEST_LINK = exports.SECONDARY = exports.PRIMARY = exports.PASSWORD_MIN_LENGTH = exports.OUTDATED_BROWSER_VERSIONS = exports.CONTRACT_ADDRESS_LINK = void 0;
const PRIMARY = 'PRIMARY';
exports.PRIMARY = PRIMARY;
const SECONDARY = 'SECONDARY';
exports.SECONDARY = SECONDARY;
const _contractAddressLink = 'https://metamask.zendesk.com/hc/en-us/articles/360020028092-What-is-the-known-contract-address-warning-';

// eslint-disable-next-line prefer-destructuring
const SUPPORT_REQUEST_LINK = "https://metamask.zendesk.com/hc/en-us";
exports.SUPPORT_REQUEST_LINK = SUPPORT_REQUEST_LINK;
const CONTRACT_ADDRESS_LINK = _contractAddressLink;
exports.CONTRACT_ADDRESS_LINK = CONTRACT_ADDRESS_LINK;
const PASSWORD_MIN_LENGTH = 8;
exports.PASSWORD_MIN_LENGTH = PASSWORD_MIN_LENGTH;
const OUTDATED_BROWSER_VERSIONS = {
  // Chrome and Edge should match the latest Chrome version released ~2 years ago
  chrome: '<90',
  edge: '<90',
  // Firefox should match the most recent end-of-life extended support release
  firefox: '<91',
  // Opera should be set to the equivalent of the Chrome version set
  // See https://en.wikipedia.org/wiki/History_of_the_Opera_web_browser
  opera: '<76'
};
exports.OUTDATED_BROWSER_VERSIONS = OUTDATED_BROWSER_VERSIONS;

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\constants\\common.ts",}],
["F:\\metamask-extension\\ui\\helpers\\utils\\build-types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Cbuild-types.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuildSpecificAsset = getBuildSpecificAsset;
exports.isBeta = isBeta;
const assetList = {
  main: {
    // Will use default provided by the @metamask/logo library
    foxMeshJson: undefined
  }
};
function isBeta() {
  return "main" === 'beta';
}

// Returns a specific version of an asset based on
// the current metamask version (i.e. main, beta, etc.)
function getBuildSpecificAsset(assetName) {
  const buildType = "main";
  if (!assetList[buildType] || !Object.keys(assetList[buildType]).includes(assetName)) {
    console.error(`Cannot find asset "${assetName}" for build "${buildType}", returning main build asset.`);
    return assetList.main[assetName];
  }
  return assetList[buildType][assetName];
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\build-types.js",}],
["F:\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js", {"../../../../shared/modules/hexstring-utils":"F:\\metamask-extension\\shared\\modules\\hexstring-utils.ts","@ethereumjs/common":"F:\\metamask-extension\\node_modules\\@ethereumjs\\common\\dist\\index.js","@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Coptimism%5CbuildUnserializedTransaction.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildUnserializedTransaction;
var _lodash = require("lodash");
var _ethereumjsUtil = require("ethereumjs-util");
var _common = require("@ethereumjs/common");
var _tx = require("@ethereumjs/tx");
var _hexstringUtils = require("../../../../shared/modules/hexstring-utils");
function buildTxParams(txMeta) {
  return {
    ...(0, _lodash.omit)(txMeta.txParams, 'gas'),
    gasLimit: txMeta.txParams.gas
  };
}
function buildTransactionCommon(txMeta) {
  // This produces a transaction whose information does not completely match an
  // Optimism transaction  for instance, DEFAULT_CHAIN is still 'mainnet' and
  // genesis points to the mainnet genesis, not the Optimism genesis  but
  // considering that all we want to do is serialize a transaction, this works
  // fine for our use case.
  return _common.Common.custom({
    chainId: new _ethereumjsUtil.BN((0, _hexstringUtils.stripHexPrefix)(txMeta.chainId), 16),
    networkId: new _ethereumjsUtil.BN(txMeta.metamaskNetworkId, 10),
    // Optimism only supports type-0 transactions; it does not support any of
    // the newer EIPs since EIP-155. Source:
    // <https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md>
    defaultHardfork: _common.Hardfork.SpuriousDragon
  });
}
function buildUnserializedTransaction(txMeta) {
  const txParams = buildTxParams(txMeta);
  const common = buildTransactionCommon(txMeta);
  return _tx.TransactionFactory.fromTxData(txParams, {
    common
  });
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js",}],
["F:\\metamask-extension\\ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js", {"../../../../shared/modules/conversion.utils":"F:\\metamask-extension\\shared\\modules\\conversion.utils.ts","./buildUnserializedTransaction":"F:\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js","@ethersproject/contracts":"F:\\metamask-extension\\node_modules\\@ethersproject\\contracts\\lib\\index.js","@ethersproject/providers":"F:\\metamask-extension\\node_modules\\@ethersproject\\providers\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Coptimism%5CfetchEstimatedL1Fee.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchEstimatedL1Fee;
var _contracts = require("@ethersproject/contracts");
var _providers = require("@ethersproject/providers");
var _conversion = require("../../../../shared/modules/conversion.utils");
var _buildUnserializedTransaction = _interopRequireDefault(require("./buildUnserializedTransaction"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Snippet of the ABI that we need
// Should we need more of it at some point, the full ABI can be found here:
// https://github.com/ethereum-optimism/optimism/blob/develop/gas-oracle/abis/OVM_GasPriceOracle.json
const OPTIMISM_GAS_PRICE_ORACLE_ABI = [{
  inputs: [{
    internalType: 'bytes',
    name: '_data',
    type: 'bytes'
  }],
  name: 'getL1Fee',
  outputs: [{
    internalType: 'uint256',
    name: '',
    type: 'uint256'
  }],
  stateMutability: 'view',
  type: 'function'
}];

// BlockExplorer link: https://optimistic.etherscan.io/address/0x420000000000000000000000000000000000000f#code
const OPTIMISM_GAS_PRICE_ORACLE_ADDRESS = '0x420000000000000000000000000000000000000F';
async function fetchEstimatedL1Fee(chainId, txMeta, ethersProvider) {
  const chainIdAsDecimalNumber = Number((0, _conversion.hexToDecimal)(chainId));
  const provider = global.ethereumProvider ? new _providers.Web3Provider(global.ethereumProvider, chainIdAsDecimalNumber) : ethersProvider;
  if (false) {
    provider.detectNetwork = async () => ({
      name: 'optimism',
      chainId: chainIdAsDecimalNumber
    });
  }
  const contract = new _contracts.Contract(OPTIMISM_GAS_PRICE_ORACLE_ADDRESS, OPTIMISM_GAS_PRICE_ORACLE_ABI, provider);
  const serializedTransaction = (0, _buildUnserializedTransaction.default)(txMeta).serialize();
  const result = await contract.getL1Fee(serializedTransaction);
  return result === null || result === void 0 ? void 0 : result.toHexString();
}

      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js",}],
["F:\\metamask-extension\\ui\\helpers\\utils\\util.js", {"../../../shared/constants/labels":"F:\\metamask-extension\\shared\\constants\\labels.ts","../../../shared/constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts","../../../shared/modules/Numeric":"F:\\metamask-extension\\shared\\modules\\Numeric.ts","../../../shared/modules/hexstring-utils":"F:\\metamask-extension\\shared\\modules\\hexstring-utils.ts","../constants/common":"F:\\metamask-extension\\ui\\helpers\\constants\\common.ts","@metamask/assets-controllers":"F:\\metamask-extension\\node_modules\\@metamask\\assets-controllers\\dist\\index.js","@metamask/slip44":"F:\\metamask-extension\\node_modules\\@metamask\\slip44\\slip44.json","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","bowser":"F:\\metamask-extension\\node_modules\\bowser\\es5.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","human-standard-token-abi":"F:\\metamask-extension\\node_modules\\human-standard-token-abi\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","luxon":"F:\\metamask-extension\\node_modules\\luxon\\build\\cjs-browser\\luxon.js","punycode/punycode":"F:\\metamask-extension\\node_modules\\punycode\\punycode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cui%5Chelpers%5Cutils%5Cutil.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addressSummary = addressSummary;
exports.bnGreaterThan = bnGreaterThan;
exports.bnGreaterThanEqualTo = bnGreaterThanEqualTo;
exports.bnLessThan = bnLessThan;
exports.bnLessThanEqualTo = bnLessThanEqualTo;
exports.checkExistingAddresses = checkExistingAddresses;
exports.clearClipboard = clearClipboard;
exports.coinTypeToProtocolName = coinTypeToProtocolName;
exports.formatBalance = formatBalance;
exports.formatDate = formatDate;
exports.formatDateWithYearContext = formatDateWithYearContext;
exports.getAccountByAddress = getAccountByAddress;
exports.getAssetImageURL = getAssetImageURL;
exports.getContractAtAddress = getContractAtAddress;
exports.getIsBrowserDeprecated = getIsBrowserDeprecated;
exports.getNetworkNameFromProviderType = void 0;
exports.getRandomFileName = getRandomFileName;
exports.getURL = getURL;
exports.getURLHost = getURLHost;
exports.getURLHostName = getURLHostName;
exports.isAbleToExportAccount = void 0;
exports.isDefaultMetaMaskChain = isDefaultMetaMaskChain;
exports.isExtensionUrl = isExtensionUrl;
exports.isNullish = isNullish;
exports.isOriginContractAddress = isOriginContractAddress;
exports.isValidDomainName = isValidDomainName;
exports.numericBalance = numericBalance;
exports.parseBalance = parseBalance;
exports.roundToDecimalPlacesRemovingExtraZeroes = roundToDecimalPlacesRemovingExtraZeroes;
exports.sanitizeString = exports.sanitizeMessage = void 0;
exports.shortenAddress = shortenAddress;
exports.stripHttpSchemes = stripHttpSchemes;
exports.stripHttpsScheme = stripHttpsScheme;
exports.stripHttpsSchemeWithoutPort = stripHttpsSchemeWithoutPort;
exports.toHumanReadableTime = void 0;
exports.valuesFor = valuesFor;
var _punycode = _interopRequireDefault(require("punycode/punycode"));
var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var ethUtil = _interopRequireWildcard(require("ethereumjs-util"));
var _luxon = require("luxon");
var _assetsControllers = require("@metamask/assets-controllers");
var _slip = _interopRequireDefault(require("@metamask/slip44"));
var lodash = _interopRequireWildcard(require("lodash"));
var _bowser = _interopRequireDefault(require("bowser"));
var _network = require("../../../shared/constants/network");
var _hexstringUtils = require("../../../shared/modules/hexstring-utils");
var _labels = require("../../../shared/constants/labels");
var _Numeric = require("../../../shared/modules/Numeric");
var _common = require("../constants/common");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// formatData :: ( date: <Unix Timestamp> ) -> String
function formatDate(date, format = "M/d/y 'at' T") {
  if (!date) {
    return '';
  }
  return _luxon.DateTime.fromMillis(date).toFormat(format);
}
function formatDateWithYearContext(date, formatThisYear = 'MMM d', fallback = 'MMM d, y') {
  if (!date) {
    return '';
  }
  const dateTime = _luxon.DateTime.fromMillis(date);
  const now = _luxon.DateTime.local();
  return dateTime.toFormat(now.year === dateTime.year ? formatThisYear : fallback);
}
/**
 * Determines if the provided chainId is a default MetaMask chain
 *
 * @param {string} chainId - chainId to check
 */
function isDefaultMetaMaskChain(chainId) {
  if (!chainId || chainId === _network.CHAIN_IDS.MAINNET || chainId === _network.CHAIN_IDS.LINEA_MAINNET || chainId === _network.CHAIN_IDS.GOERLI || chainId === _network.CHAIN_IDS.SEPOLIA || chainId === _network.CHAIN_IDS.LINEA_GOERLI || chainId === _network.CHAIN_IDS.LOCALHOST) {
    return true;
  }
  return false;
}
function valuesFor(obj) {
  if (!obj) {
    return [];
  }
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}
function addressSummary(address, firstSegLength = 10, lastSegLength = 4, includeHex = true) {
  if (!address) {
    return '';
  }
  let checked = (0, _hexstringUtils.toChecksumHexAddress)(address);
  if (!includeHex) {
    checked = (0, _hexstringUtils.stripHexPrefix)(checked);
  }
  return checked ? `${checked.slice(0, firstSegLength)}...${checked.slice(checked.length - lastSegLength)}` : '...';
}
function isValidDomainName(address) {
  const match = _punycode.default.toASCII(address).toLowerCase()
  // Checks that the domain consists of at least one valid domain pieces separated by periods, followed by a tld
  // Each piece of domain name has only the characters a-z, 0-9, and a hyphen (but not at the start or end of chunk)
  // A chunk has minimum length of 1, but minimum tld is set to 2 for now (no 1-character tlds exist yet)
  .match(/^(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z0-9][-a-z0-9]*[a-z0-9]$/u);
  return match !== null;
}
function isOriginContractAddress(to, sendTokenAddress) {
  if (!to || !sendTokenAddress) {
    return false;
  }
  return to.toLowerCase() === sendTokenAddress.toLowerCase();
}

// Takes wei Hex, returns wei BN, even if input is null
function numericBalance(balance) {
  if (!balance) {
    return new ethUtil.BN(0, 16);
  }
  const stripped = (0, _hexstringUtils.stripHexPrefix)(balance);
  return new ethUtil.BN(stripped, 16);
}

// Takes  hex, returns [beforeDecimal, afterDecimal]
function parseBalance(balance) {
  let afterDecimal;
  const wei = numericBalance(balance);
  const weiString = wei.toString();
  const trailingZeros = /0+$/u;
  const beforeDecimal = weiString.length > 18 ? weiString.slice(0, weiString.length - 18) : '0';
  afterDecimal = `000000000000000000${wei}`.slice(-18).replace(trailingZeros, '');
  if (afterDecimal === '') {
    afterDecimal = '0';
  }
  return [beforeDecimal, afterDecimal];
}

// Takes wei hex, returns an object with three properties.
// Its "formatted" property is what we generally use to render values.
function formatBalance(balance, decimalsToKeep, needsParse = true, ticker = 'ETH') {
  const parsed = needsParse ? parseBalance(balance) : balance.split('.');
  const beforeDecimal = parsed[0];
  let afterDecimal = parsed[1];
  let formatted = 'None';
  if (decimalsToKeep === undefined) {
    if (beforeDecimal === '0') {
      if (afterDecimal !== '0') {
        const sigFigs = afterDecimal.match(/^0*(.{2})/u); // default: grabs 2 most significant digits
        if (sigFigs) {
          afterDecimal = sigFigs[0];
        }
        formatted = `0.${afterDecimal} ${ticker}`;
      }
    } else {
      formatted = `${beforeDecimal}.${afterDecimal.slice(0, 3)} ${ticker}`;
    }
  } else {
    afterDecimal += Array(decimalsToKeep).join('0');
    formatted = `${beforeDecimal}.${afterDecimal.slice(0, decimalsToKeep)} ${ticker}`;
  }
  return formatted;
}
function getContractAtAddress(tokenAddress) {
  return global.eth.contract(_humanStandardTokenAbi.default).at(tokenAddress);
}
function getRandomFileName() {
  let fileName = '';
  const charBank = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'];
  const fileNameLength = Math.floor(Math.random() * 7 + 6);
  for (let i = 0; i < fileNameLength; i++) {
    fileName += charBank[Math.floor(Math.random() * charBank.length)];
  }
  return fileName;
}

/**
 * Shortens an Ethereum address for display, preserving the beginning and end.
 * Returns the given address if it is no longer than 10 characters.
 * Shortened addresses are 13 characters long.
 *
 * Example output: 0xabcd...1234
 *
 * @param {string} address - The address to shorten.
 * @returns {string} The shortened address, or the original if it was no longer
 * than 10 characters.
 */
function shortenAddress(address = '') {
  if (address.length < _labels.TRUNCATED_NAME_CHAR_LIMIT) {
    return address;
  }
  return `${address.slice(0, _labels.TRUNCATED_ADDRESS_START_CHARS)}...${address.slice(-_labels.TRUNCATED_ADDRESS_END_CHARS)}`;
}
function getAccountByAddress(accounts = [], targetAddress) {
  return accounts.find(({
    address
  }) => address === targetAddress);
}

/**
 * Strips the following schemes from URL strings:
 * - http
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpSchemes(urlString) {
  return urlString.replace(/^https?:\/\//u, '');
}

/**
 * Strips the following schemes from URL strings:
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpsScheme(urlString) {
  return urlString.replace(/^https:\/\//u, '');
}

/**
 * Strips `https` schemes from URL strings, if the URL does not have a port.
 * This is useful
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */
function stripHttpsSchemeWithoutPort(urlString) {
  if (getURL(urlString).port) {
    return urlString;
  }
  return stripHttpsScheme(urlString);
}

/**
 * Checks whether a URL-like value (object or string) is an extension URL.
 *
 * @param {string | URL | object} urlLike - The URL-like value to test.
 * @returns {boolean} Whether the URL-like value is an extension URL.
 */
function isExtensionUrl(urlLike) {
  const EXT_PROTOCOLS = ['chrome-extension:', 'moz-extension:'];
  if (typeof urlLike === 'string') {
    for (const protocol of EXT_PROTOCOLS) {
      if (urlLike.startsWith(protocol)) {
        return true;
      }
    }
  }
  if (urlLike !== null && urlLike !== void 0 && urlLike.protocol) {
    return EXT_PROTOCOLS.includes(urlLike.protocol);
  }
  return false;
}

/**
 * Checks whether an address is in a passed list of objects with address properties. The check is performed on the
 * lowercased version of the addresses.
 *
 * @param {string} address - The hex address to check
 * @param {Array} list - The array of objects to check
 * @returns {boolean} Whether or not the address is in the list
 */
function checkExistingAddresses(address, list = []) {
  if (!address) {
    return false;
  }
  const matchesAddress = obj => {
    return obj.address.toLowerCase() === address.toLowerCase();
  };
  return list.some(matchesAddress);
}
function bnGreaterThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).gt(b, 10);
}
function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).lt(b, 10);
}
function bnGreaterThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).gte(b, 10);
}
function bnLessThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new _bignumber.default(a, 10).lte(b, 10);
}
function getURL(url) {
  try {
    return new URL(url);
  } catch (err) {
    return '';
  }
}
function getIsBrowserDeprecated(browser = _bowser.default.getParser(window.navigator.userAgent)) {
  return browser.satisfies(_common.OUTDATED_BROWSER_VERSIONS) ?? false;
}
function getURLHost(url) {
  var _getURL;
  return ((_getURL = getURL(url)) === null || _getURL === void 0 ? void 0 : _getURL.host) || '';
}
function getURLHostName(url) {
  var _getURL2;
  return ((_getURL2 = getURL(url)) === null || _getURL2 === void 0 ? void 0 : _getURL2.hostname) || '';
}

// Once we reach this threshold, we switch to higher unit
const MINUTE_CUTOFF = 90 * 60;
const SECOND_CUTOFF = 90;
const toHumanReadableTime = (t, milliseconds) => {
  if (milliseconds === undefined || milliseconds === null) {
    return '';
  }
  const seconds = Math.ceil(milliseconds / 1000);
  if (seconds <= SECOND_CUTOFF) {
    return t('gasTimingSecondsShort', [seconds]);
  }
  if (seconds <= MINUTE_CUTOFF) {
    return t('gasTimingMinutesShort', [Math.ceil(seconds / 60)]);
  }
  return t('gasTimingHoursShort', [Math.ceil(seconds / 3600)]);
};
exports.toHumanReadableTime = toHumanReadableTime;
function clearClipboard() {
  window.navigator.clipboard.writeText('');
}
const solidityTypes = () => {
  const types = ['bool', 'address', 'string', 'bytes', 'int', 'uint', 'fixed', 'ufixed'];
  const ints = Array.from(new Array(32)).map((_, index) => `int${(index + 1) * 8}`);
  const uints = Array.from(new Array(32)).map((_, index) => `uint${(index + 1) * 8}`);
  const bytes = Array.from(new Array(32)).map((_, index) => `bytes${index + 1}`);

  /**
   * fixed and ufixed
   * This value type also can be declared keywords such as ufixedMxN and fixedMxN.
   * The M represents the amount of bits that the type takes,
   * with N representing the number of decimal points that are available.
   *  M has to be divisible by 8, and a number from 8 to 256.
   * N has to be a value between 0 and 80, also being inclusive.
   */
  const fixedM = Array.from(new Array(32)).map((_, index) => `fixed${(index + 1) * 8}`);
  const ufixedM = Array.from(new Array(32)).map((_, index) => `ufixed${(index + 1) * 8}`);
  const fixed = Array.from(new Array(80)).map((_, index) => fixedM.map(aFixedM => `${aFixedM}x${index + 1}`));
  const ufixed = Array.from(new Array(80)).map((_, index) => ufixedM.map(auFixedM => `${auFixedM}x${index + 1}`));
  return [...types, ...ints, ...uints, ...bytes, ...fixed.flat(), ...ufixed.flat()];
};
const SOLIDITY_TYPES = solidityTypes();
const stripArrayType = potentialArrayType => potentialArrayType.replace(/\[[[0-9]*\]*/gu, '');
const stripOneLayerofNesting = potentialArrayType => potentialArrayType.replace(/\[[[0-9]*\]/u, '');
const isArrayType = potentialArrayType => potentialArrayType.match(/\[[[0-9]*\]*/u) !== null;
const isSolidityType = type => SOLIDITY_TYPES.includes(type);
const sanitizeMessage = (msg, primaryType, types) => {
  if (!types) {
    throw new Error(`Invalid types definition`);
  }

  // Primary type can be an array.
  const isArray = primaryType && isArrayType(primaryType);
  if (isArray) {
    return {
      value: msg.map(value => sanitizeMessage(value, stripOneLayerofNesting(primaryType), types)),
      type: primaryType
    };
  } else if (isSolidityType(primaryType)) {
    return {
      value: msg,
      type: primaryType
    };
  }

  // If not, assume to be struct
  const baseType = isArray ? stripArrayType(primaryType) : primaryType;
  const baseTypeDefinitions = types[baseType];
  if (!baseTypeDefinitions) {
    throw new Error(`Invalid primary type definition`);
  }
  const sanitizedStruct = {};
  const msgKeys = Object.keys(msg);
  msgKeys.forEach(msgKey => {
    const definedType = Object.values(baseTypeDefinitions).find(baseTypeDefinition => baseTypeDefinition.name === msgKey);
    if (!definedType) {
      return;
    }
    sanitizedStruct[msgKey] = sanitizeMessage(msg[msgKey], definedType.type, types);
  });
  return {
    value: sanitizedStruct,
    type: primaryType
  };
};
exports.sanitizeMessage = sanitizeMessage;
function getAssetImageURL(image, ipfsGateway) {
  if (!image || typeof image !== 'string') {
    return '';
  }
  if (ipfsGateway && image.startsWith('ipfs://')) {
    return (0, _assetsControllers.getFormattedIpfsUrl)(ipfsGateway, image, true);
  }
  return image;
}
function roundToDecimalPlacesRemovingExtraZeroes(numberish, numberOfDecimalPlaces) {
  if (numberish === undefined || numberish === null) {
    return '';
  }
  return new _Numeric.Numeric(new _Numeric.Numeric(numberish, 10).toFixed(numberOfDecimalPlaces), 10).toNumber();
}

/**
 * Gets the name of the SLIP-44 protocol corresponding to the specified
 * `coin_type`.
 *
 * @param {string | number} coinType - The SLIP-44 `coin_type` value whose name
 * to retrieve.
 * @returns {string | undefined} The name of the protocol if found.
 */
function coinTypeToProtocolName(coinType) {
  var _slip44$coinType;
  if (String(coinType) === '1') {
    return 'Test Networks';
  }
  return ((_slip44$coinType = _slip.default[coinType]) === null || _slip44$coinType === void 0 ? void 0 : _slip44$coinType.name) || undefined;
}

/**
 * Tests "nullishness". Used to guard a section of a component from being
 * rendered based on a value.
 *
 * @param {any} value - A value (literally anything).
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullish(value) {
  return value === null || value === undefined;
}

/**
 * The method escape RTL character in string
 *
 * @param {*} value
 * @returns {(string|*)} escaped string or original param value
 */
const sanitizeString = value => {
  if (!value) {
    return value;
  }
  if (!lodash.isString(value)) {
    return value;
  }
  const regex = /\u202E/giu;
  return value.replace(regex, '\\u202E');
};

/**
 * This method checks current provider type and returns its string representation
 *
 * @param {*} provider
 * @param {*} t
 * @returns
 */
exports.sanitizeString = sanitizeString;
const getNetworkNameFromProviderType = providerName => {
  if (providerName === _network.NETWORK_TYPES.RPC) {
    return '';
  }
  return providerName;
};

/**
 * Checks if the given keyring type is able to export an account.
 *
 * @param keyringType - The type of the keyring.
 * @returns {boolean} `false` if the keyring type includes 'Hardware' or 'Snap', `true` otherwise.
 */
exports.getNetworkNameFromProviderType = getNetworkNameFromProviderType;
const isAbleToExportAccount = (keyringType = '') => {
  return !keyringType.includes('Hardware') && !keyringType.includes('Snap');
};
exports.isAbleToExportAccount = isAbleToExportAccount;


      };
    };
  }
  }
}, {package:"$root$",file:"ui\\helpers\\utils\\util.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NtcC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvZXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9lcS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvaW5jLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHQuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21pbm9yLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ByZXJlbGVhc2UuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yY29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jzb3J0LmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvaW50ZXJzZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXNhdGlzZnlpbmcuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3N1YnNldC5qcyIsIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdmFsaWQuanMiLCJub2RlX21vZHVsZXMvc2V0LWltbWVkaWF0ZS1zaGltL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhLmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiLCJub2RlX21vZHVsZXMvc2luZ2xlLWNhbGwtYmFsYW5jZS1jaGVja2VyLWFiaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVzcG9uc2UuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmlwLWhleC1wcmVmaXgvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGY4L3V0ZjguanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L21kNS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9uaWwuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9yZWdleC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3Qvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3NoYTEtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3Qvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92MS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjMuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzNS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjQuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y1LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZC11cmwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2Rpc3QvYnJvd3Nlci1wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsInNoYXJlZC9jb25zdGFudHMvYWxlcnRzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9hcHAudHMiLCJzaGFyZWQvY29uc3RhbnRzL2NvbW1vbi50cyIsInNoYXJlZC9jb25zdGFudHMvZ2FzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9oYXJkd2FyZS13YWxsZXRzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9rZXlyaW5nLnRzIiwic2hhcmVkL2NvbnN0YW50cy9sYWJlbHMudHMiLCJzaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzLnRzIiwic2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrLnRzIiwic2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucy50cyIsInNoYXJlZC9jb25zdGFudHMvcHJlZmVyZW5jZXMudHMiLCJzaGFyZWQvY29uc3RhbnRzL3N3YXBzLnRzIiwic2hhcmVkL2NvbnN0YW50cy90aW1lLnRzIiwic2hhcmVkL2NvbnN0YW50cy90b2tlbnMuanMiLCJzaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uLnRzIiwic2hhcmVkL2xpYi9mZXRjaC13aXRoLWNhY2hlLmpzIiwic2hhcmVkL2xpYi9tZXRhbWFzay1jb250cm9sbGVyLXV0aWxzLmpzIiwic2hhcmVkL2xpYi9zdG9yYWdlLWhlbHBlcnMuanMiLCJzaGFyZWQvbGliL3N3YXBzLXV0aWxzLmpzIiwic2hhcmVkL2xpYi90b2tlbi11dGlsLnRzIiwic2hhcmVkL2xpYi90cmFuc2FjdGlvbnMtY29udHJvbGxlci11dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL051bWVyaWMudHMiLCJzaGFyZWQvbW9kdWxlcy9icm93c2VyLXJ1bnRpbWUudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscy50cyIsInNoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMudHMiLCJzaGFyZWQvbW9kdWxlcy9mZXRjaC13aXRoLXRpbWVvdXQudHMiLCJzaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMudHMiLCJzaGFyZWQvbW9kdWxlcy9pMThuLnRzIiwic2hhcmVkL21vZHVsZXMvbXYzLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvbmV0d29yay51dGlscy50cyIsInNoYXJlZC9tb2R1bGVzL29iamVjdC51dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZC5qcyIsInNoYXJlZC9tb2R1bGVzL3N0cmluZy11dGlscy50cyIsInNoYXJlZC9tb2R1bGVzL3N3YXBzLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvdHJhbnNhY3Rpb24udXRpbHMuanMiLCJzaGFyZWQvbm90aWZpY2F0aW9ucy9pbmRleC5qcyIsInVpL2hlbHBlcnMvY29uc3RhbnRzL2NvbW1vbi50cyIsInVpL2hlbHBlcnMvdXRpbHMvYnVpbGQtdHlwZXMuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL29wdGltaXNtL2J1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24uanMiLCJ1aS9oZWxwZXJzL3V0aWxzL29wdGltaXNtL2ZldGNoRXN0aW1hdGVkTDFGZWUuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDNWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFwQixvQkFBb0I7RUFBcEIsb0JBQW9CO0VBQXBCLG9CQUFvQjtFQUFBLE9BQXBCLG9CQUFvQjtBQUFBO0FB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RUFBRSxDQUFDLENBQUMsNEJBQTRCLENBQUM7TUFDNUMsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxNQUFNLENBQ25ELElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDcEM7SUFDRixDQUFDO0lBQ0QsRUFBRSxFQUFFO01BQ0YsR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7TUFDdkIsS0FBSyxFQUFFLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQztNQUNoQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLDRCQUE0QixDQUFDO01BQzVDLFVBQVUsRUFBRSxDQUFDLENBQUMsMkJBQTJCLENBQUM7TUFDMUMsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxNQUFNLENBQ25ELElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDcEM7SUFDRixDQUFDO0lBQ0QsRUFBRSxFQUFFO01BQ0YsR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7TUFDdkIsS0FBSyxFQUFFLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQztNQUNoQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLDRCQUE0QixDQUFDO01BQzVDLFVBQVUsRUFBRSxDQUFDLENBQUMsMkJBQTJCLENBQUM7TUFDMUMsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxNQUFNLENBQ25ELElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDcEM7SUFDRixDQUFDO0lBQ0QsRUFBRSxFQUFFO01BQ0YsR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7TUFDdkIsS0FBSyxFQUFFLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQztNQUNoQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLDRCQUE0QixDQUFDO01BQzVDLFVBQVUsRUFBRSxDQUFDLENBQUMsMkJBQTJCLENBQUM7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QUE7QUFDQSxJQUFBLFFBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsa0JBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFNBQUEsdUJBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsVUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQSxDQUFBO0FBRUEsSUFBQSxXQUFBLE9BQUEsQ0FBQSxtQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLGtCQUFBLE9BQUEsQ0FBQSx5Q0FBQSxDQUFBLENBQUE7QUFJQSxJQUFBLFVBQUEsT0FBQSxDQUFBLGtDQUFBLENBQUEsQ0FBQTtBQUtBLElBQUEsV0FBQSxPQUFBLENBQUEsaUNBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUE7QUFBZ0UsK0NBQUEsRUFBQSxJQUFBLE9BQUEsT0FBQSxLQUFBLFVBQUEsRUFBQSxPQUFBLElBQUEsQ0FBQSxDQUFBLElBQUEsb0JBQUEsSUFBQSxPQUFBLEVBQUEsQ0FBQSxDQUFBLElBQUEsbUJBQUEsSUFBQSxPQUFBLEVBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSwyQkFBQSx1QkFBQSxFQUFBLE9BQUEsV0FBQSxHQUFBLGdCQUFBLEdBQUEsaUJBQUEsQ0FBQSxFQUFBLEVBQUEsV0FBQSxDQUFBLENBQUEsRUFBQTtBQUFBLG1EQUFBLEVBQUEsSUFBQSxDQUFBLFdBQUEsSUFBQSxHQUFBLElBQUEsR0FBQSxXQUFBLEVBQUEsRUFBQSxPQUFBLEdBQUEsQ0FBQSxFQUFBLENBQUEsSUFBQSxHQUFBLEtBQUEsSUFBQSxJQUFBLE9BQUEsR0FBQSxLQUFBLFFBQUEsSUFBQSxPQUFBLEdBQUEsS0FBQSxVQUFBLEVBQUEsRUFBQSxPQUFBLEVBQUEsU0FBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBLENBQUEsSUFBQSxRQUFBLHdCQUFBLENBQUEsV0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLEtBQUEsSUFBQSxLQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsRUFBQSxFQUFBLE9BQUEsS0FBQSxJQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsRUFBQSxDQUFBLElBQUEsU0FBQSxFQUFBLENBQUEsQ0FBQSxJQUFBLHdCQUFBLE1BQUEsZUFBQSxJQUFBLE1BQUEseUJBQUEsQ0FBQSxDQUFBLEtBQUEsSUFBQSxHQUFBLElBQUEsR0FBQSxFQUFBLEVBQUEsSUFBQSxHQUFBLEtBQUEsU0FBQSxJQUFBLE1BQUEsVUFBQSxlQUFBLEtBQUEsQ0FBQSxHQUFBLEVBQUEsR0FBQSxDQUFBLEVBQUEsRUFBQSxJQUFBLE9BQUEscUJBQUEsR0FBQSxNQUFBLHlCQUFBLENBQUEsR0FBQSxFQUFBLEdBQUEsQ0FBQSxHQUFBLElBQUEsQ0FBQSxDQUFBLElBQUEsSUFBQSxLQUFBLElBQUEsSUFBQSxJQUFBLElBQUEsSUFBQSxDQUFBLEVBQUEsRUFBQSxNQUFBLGVBQUEsQ0FBQSxNQUFBLEVBQUEsR0FBQSxFQUFBLElBQUEsQ0FBQSxDQUFBLEVBQUEsTUFBQSxFQUFBLE1BQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsRUFBQSxFQUFBLEVBQUEsQ0FBQSxNQUFBLFFBQUEsR0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLEtBQUEsRUFBQSxFQUFBLEtBQUEsSUFBQSxDQUFBLEdBQUEsRUFBQSxNQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsT0FBQSxNQUFBLENBQUEsRUFBQTtBQUFBLHFDQUFBLEVBQUEsT0FBQSxHQUFBLElBQUEsR0FBQSxXQUFBLEdBQUEsR0FBQSxHQUFBLEVBQUEsU0FBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBOztBQUl6RCwwQkFBMEIsU0FBUyxjQUFjLEVBQUU7RUFDeEQsSUFBSSxDQUFDLElBQUksRUFBRTtJQUNULE9BQU8sRUFBRSxDQUFBO0dBQ1g7RUFDQSxPQUFPLE1BQUEsU0FBUSxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQTtDQUNuRDtBQUVPLHlDQUVMLGlCQUFpQixPQUFPLEVBQ3hCLFdBQVcsVUFBVSxFQUNyQjtFQUNBLElBQUksQ0FBQyxJQUFJLEVBQUU7SUFDVCxPQUFPLEVBQUUsQ0FBQTtHQUNYO0VBQ0EsTUFBTSxXQUFXLE1BQUEsU0FBUSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUE7RUFDMUMsTUFBTSxNQUFNLE1BQUEsU0FBUSxNQUFNLEVBQUUsQ0FBQTtFQUM1QixPQUFPLFFBQVEsU0FBUyxDQUN0QixHQUFHLEtBQUssS0FBSyxRQUFRLEtBQUssR0FBRyxjQUFjLEdBQUcsUUFDaEQsQ0FBQyxDQUFBO0NBQ0g7Ozs7OztBQU1PLHlDQUF5QztFQUM5QyxJQUNFLENBQUMsT0FBTyxJQUNSLE9BQU8sS0FBSyxRQUFBLFVBQVMsUUFBUSxJQUM3QixPQUFPLEtBQUssUUFBQSxVQUFTLGNBQWMsSUFDbkMsT0FBTyxLQUFLLFFBQUEsVUFBUyxPQUFPLElBQzVCLE9BQU8sS0FBSyxRQUFBLFVBQVMsUUFBUSxJQUM3QixPQUFPLEtBQUssUUFBQSxVQUFTLGFBQWEsSUFDbEMsT0FBTyxLQUFLLFFBQUEsVUFBUyxVQUFVLEVBQy9CO0lBQ0EsT0FBTyxJQUFJLENBQUE7R0FDYjtFQUVBLE9BQU8sS0FBSyxDQUFBO0NBQ2Q7QUFFTyx3QkFBd0I7RUFDN0IsSUFBSSxDQUFDLEdBQUcsRUFBRTtJQUNSLE9BQU8sRUFBRSxDQUFBO0dBQ1g7RUFDQSxPQUFPLE1BQU0sS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZUFBZTtJQUN6QyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtHQUNoQixDQUFDLENBQUE7Q0FDSjtBQUVPLGlDQUVMLGlCQUFpQixFQUFFLEVBQ25CLGdCQUFnQixDQUFDLEVBQ2pCLGFBQWEsSUFBSSxFQUNqQjtFQUNBLElBQUksQ0FBQyxPQUFPLEVBQUU7SUFDWixPQUFPLEVBQUUsQ0FBQTtHQUNYO0VBQ0EsSUFBSSxVQUFVLENBQUEsQ0FBQSxFQUFBLGVBQUEscUJBQW9CLEVBQUMsT0FBTyxDQUFDLENBQUE7RUFDM0MsSUFBSSxDQUFDLFVBQVUsRUFBRTtJQUNmLFVBQVUsQ0FBQSxDQUFBLEVBQUEsZUFBQSxlQUFjLEVBQUMsT0FBTyxDQUFDLENBQUE7R0FDbkM7RUFDQSxPQUFPLE9BQU8sR0FDVCxDQUFBLEVBQUUsT0FBTyxNQUFNLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBRSxDQUFBLEdBQUEsRUFBSyxPQUFPLE1BQU0sQ0FDcEQsT0FBTyxPQUFPLEdBQUcsYUFDbkIsQ0FBRSxDQUFBLENBQUMsR0FDSCxLQUFLLENBQUE7Q0FDWDtBQUVPLG9DQUFvQztFQUN6QyxNQUFNLFFBQVEsU0FBQSxRQUFRLFFBQ1osQ0FBQyxPQUFPLENBQUMsWUFDTCxFQUFDOzs7O1FBSVAsQ0FDSixxRUFDRixDQUFDLENBQUE7RUFDSCxPQUFPLEtBQUssS0FBSyxJQUFJLENBQUE7Q0FDdkI7QUFFTyx1REFBdUQ7RUFDNUQsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFO0lBQzVCLE9BQU8sS0FBSyxDQUFBO0dBQ2Q7RUFDQSxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssZ0JBQWdCLFlBQVksRUFBRSxDQUFBO0NBQzVEOzs7QUFHTyxpQ0FBaUM7RUFDdEMsSUFBSSxDQUFDLE9BQU8sRUFBRTtJQUNaLE9BQU8sSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7R0FDOUI7RUFDQSxNQUFNLFdBQVcsQ0FBQSxDQUFBLEVBQUEsZUFBQSxlQUFjLEVBQUMsT0FBTyxDQUFDLENBQUE7RUFDeEMsT0FBTyxJQUFJLE9BQU8sR0FBRyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQTtDQUNyQzs7O0FBR08sK0JBQStCO0VBQ3BDLElBQUksWUFBWSxDQUFBO0VBQ2hCLE1BQU0sTUFBTSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUE7RUFDbkMsTUFBTSxZQUFZLEdBQUcsU0FBUyxFQUFFLENBQUE7RUFDaEMsTUFBTSxnQkFBZ0IsTUFBTSxDQUFBO0VBRTVCLE1BQU0sZ0JBQ0osU0FBUyxPQUFPLEdBQUcsRUFBRSxHQUFHLFNBQVMsTUFBTSxDQUFDLENBQUMsRUFBRSxTQUFTLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUE7RUFDekUsZUFBZ0IsQ0FBQSxrQkFBQSxFQUFvQixHQUFJLENBQUEsQ0FBQyxNQUNqQyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQ0gsQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDLENBQUE7RUFDN0IsSUFBSSxZQUFZLEtBQUssRUFBRSxFQUFFO0lBQ3ZCLGVBQWUsR0FBRyxDQUFBO0dBQ3BCO0VBQ0EsT0FBTyxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQTtDQUN0Qzs7OztBQUlPLGdEQUdMLGFBQWEsSUFBSSxFQUNqQixTQUFTLEtBQUssRUFDZDtFQUNBLE1BQU0sU0FBUyxVQUFVLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0VBQ3RFLE1BQU0sZ0JBQWdCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtFQUMvQixJQUFJLGVBQWUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO0VBQzVCLElBQUksWUFBWSxNQUFNLENBQUE7RUFDdEIsSUFBSSxjQUFjLEtBQUssU0FBUyxFQUFFO0lBQ2hDLElBQUksYUFBYSxLQUFLLEdBQUcsRUFBRTtNQUN6QixJQUFJLFlBQVksS0FBSyxHQUFHLEVBQUU7UUFDeEIsTUFBTSxVQUFVLFlBQVksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ2pELElBQUksT0FBTyxFQUFFO1VBQ1gsZUFBZSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDM0I7UUFDQSxZQUFhLENBQUEsRUFBQSxFQUFJLFlBQWEsQ0FBQSxDQUFBLEVBQUcsTUFBTyxDQUFBLENBQUMsQ0FBQTtPQUMzQztLQUNELE1BQU07TUFDTCxZQUFhLENBQUEsRUFBRSxhQUFjLENBQUEsQ0FBQSxFQUFHLFlBQVksTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFBLEVBQUcsTUFBTyxDQUFBLENBQUMsQ0FBQTtLQUN0RTtHQUNELE1BQU07SUFDTCxnQkFBZ0IsS0FBSyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDL0MsWUFBYSxDQUFBLEVBQUUsYUFBYyxDQUFBLENBQUEsRUFBRyxZQUFZLE1BQU0sQ0FDaEQsQ0FBQyxFQUNELGNBQ0YsQ0FBRSxDQUFBLENBQUEsRUFBRyxNQUFPLENBQUEsQ0FBQyxDQUFBO0dBQ2Y7RUFDQSxPQUFPLFNBQVMsQ0FBQTtDQUNsQjtBQUVPLDRDQUE0QztFQUNqRCxPQUFPLE1BQU0sSUFBSSxTQUFTLENBQUMsc0JBQUEsUUFBRyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQTtDQUNsRDtBQUVPLDZCQUE2QjtFQUNsQyxJQUFJLFdBQVcsRUFBRSxDQUFBO0VBQ2pCLE1BQU0sV0FBVyxDQUNmLEdBQUcsZ0VBQWdFLENBQ3BFLENBQUE7RUFDRCxNQUFNLGlCQUFpQixJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtFQUV4RCxLQUFLLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUN2QyxZQUFZLFFBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sRUFBRSxHQUFHLFFBQVEsT0FBTyxDQUFDLENBQUMsQ0FBQTtHQUNuRTtFQUVBLE9BQU8sUUFBUSxDQUFBO0NBQ2pCOzs7Ozs7Ozs7Ozs7O0FBYU8sd0JBQXdCLFVBQVUsRUFBRSxFQUFFO0VBQzNDLElBQUksT0FBTyxPQUFPLEdBQUcsT0FBQSwwQkFBeUIsRUFBRTtJQUM5QyxPQUFPLE9BQU8sQ0FBQTtHQUNoQjtFQUVBLE9BQVEsQ0FBQSxFQUFFLE9BQU8sTUFBTSxDQUFDLENBQUMsRUFBRSxPQUFBLDhCQUE2QixDQUFFLENBQUEsR0FBQSxFQUFLLE9BQU8sTUFBTSxDQUMxRSxDQUFDLE9BQUEsNEJBQ0gsQ0FBRSxDQUFBLENBQUMsQ0FBQTtDQUNMO0FBRU8sNkJBQTZCLFdBQVcsRUFBRSxpQkFBaUI7RUFDaEUsT0FBTyxRQUFRLEtBQUssQ0FBQyxDQUFDOztHQUFXLEtBQUssT0FBTyxLQUFLLGFBQWEsQ0FBQyxDQUFBO0NBQ2xFOzs7Ozs7Ozs7O0FBVU8scUNBQXFDO0VBQzFDLE9BQU8sU0FBUyxRQUFRLENBQUMsZUFBZSxFQUFFLEVBQUUsQ0FBQyxDQUFBO0NBQy9DOzs7Ozs7Ozs7QUFTTyxxQ0FBcUM7RUFDMUMsT0FBTyxTQUFTLFFBQVEsQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLENBQUE7Q0FDOUM7Ozs7Ozs7OztBQVNPLGdEQUFnRDtFQUNyRCxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFO0lBQzFCLE9BQU8sU0FBUyxDQUFBO0dBQ2xCO0VBRUEsT0FBTyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQTtDQUNwQzs7Ozs7Ozs7QUFRTyxpQ0FBaUM7RUFDdEMsTUFBTSxnQkFBZ0IsQ0FBQyxtQkFBbUIsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFBO0VBRTdELElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0lBQy9CLEtBQUssTUFBTSxRQUFRLElBQUksYUFBYSxFQUFFO01BQ3BDLElBQUksT0FBTyxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDaEMsT0FBTyxJQUFJLENBQUE7T0FDYjtLQUNGO0dBQ0Y7RUFFQSxJQUFJLE9BQU8sS0FBQSxJQUFBLElBQVAsT0FBTyxLQUFBLEtBQUEsQ0FBQSxJQUFQLE9BQU8sU0FBVSxFQUFFO0lBQ3JCLE9BQU8sYUFBYSxTQUFTLENBQUMsT0FBTyxTQUFTLENBQUMsQ0FBQTtHQUNqRDtFQUNBLE9BQU8sS0FBSyxDQUFBO0NBQ2Q7Ozs7Ozs7Ozs7QUFVTyx5Q0FBeUMsT0FBTyxFQUFFLEVBQUU7RUFDekQsSUFBSSxDQUFDLE9BQU8sRUFBRTtJQUNaLE9BQU8sS0FBSyxDQUFBO0dBQ2Q7RUFFQSxNQUFNLGlCQUFrQixPQUFRO0lBQzlCLE9BQU8sR0FBRyxRQUFRLFlBQVksRUFBRSxLQUFLLE9BQU8sWUFBWSxFQUFFLENBQUE7R0FDM0QsQ0FBQTtFQUVELE9BQU8sSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUE7Q0FDbEM7QUFFTyw2QkFBNkI7RUFDbEMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxTQUFTLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssU0FBUyxFQUFFO0lBQ2xFLE9BQU8sSUFBSSxDQUFBO0dBQ2I7RUFDQSxPQUFPLElBQUksVUFBQSxRQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO0NBQ3ZDO0FBRU8sMEJBQTBCO0VBQy9CLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssU0FBUyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBRTtJQUNsRSxPQUFPLElBQUksQ0FBQTtHQUNiO0VBQ0EsT0FBTyxJQUFJLFVBQUEsUUFBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQTtDQUN2QztBQUVPLG9DQUFvQztFQUN6QyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLFNBQVMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxTQUFTLEVBQUU7SUFDbEUsT0FBTyxJQUFJLENBQUE7R0FDYjtFQUNBLE9BQU8sSUFBSSxVQUFBLFFBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7Q0FDeEM7QUFFTyxpQ0FBaUM7RUFDdEMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxTQUFTLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssU0FBUyxFQUFFO0lBQ2xFLE9BQU8sSUFBSSxDQUFBO0dBQ2I7RUFDQSxPQUFPLElBQUksVUFBQSxRQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO0NBQ3hDO0FBRU8scUJBQXFCO0VBQzFCLElBQUk7SUFDRixPQUFPLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQ3BCLENBQUMsWUFBWTtJQUNaLE9BQU8sRUFBRSxDQUFBO0dBQ1g7Q0FDRjtBQUVPLGdDQUNMLFVBQVUsT0FBQSxRQUFNLFVBQVUsQ0FBQyxNQUFNLFVBQVUsVUFBVSxDQUFDLEVBQ3REO0VBQ0EsT0FBTyxPQUFPLFVBQVUsQ0FBQyxPQUFBLDBCQUF5QixDQUFDLElBQUksS0FBSyxDQUFBO0NBQzlEO0FBRU8seUJBQXlCO0VBQUEsSUFBQSxPQUFBLENBQUE7RUFDOUIsT0FBTyxDQUFBLENBQUEsVUFBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQUEsSUFBQSxJQUFBLE9BQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBWCxPQUFBLEtBQWlCLEtBQUksRUFBRSxDQUFBO0NBQ2hDO0FBRU8sNkJBQTZCO0VBQUEsSUFBQSxRQUFBLENBQUE7RUFDbEMsT0FBTyxDQUFBLENBQUEsV0FBQSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQUEsSUFBQSxJQUFBLFFBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBWCxRQUFBLFNBQXFCLEtBQUksRUFBRSxDQUFBO0NBQ3BDOzs7QUFHQSxNQUFNLGdCQUFnQixFQUFFLEdBQUcsRUFBRSxDQUFBO0FBQzdCLE1BQU0sZ0JBQWdCLEVBQUUsQ0FBQTtBQUVqQixNQUFNLHNCQUFzQixxQkFBcUI7RUFDdEQsSUFBSSxZQUFZLEtBQUssU0FBUyxJQUFJLFlBQVksS0FBSyxJQUFJLEVBQUU7SUFDdkQsT0FBTyxFQUFFLENBQUE7R0FDWDtFQUNBLE1BQU0sVUFBVSxJQUFJLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUE7RUFDOUMsSUFBSSxPQUFPLElBQUksYUFBYSxFQUFFO0lBQzVCLE9BQU8sQ0FBQyxDQUFDLHVCQUF1QixFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQTtHQUM5QztFQUNBLElBQUksT0FBTyxJQUFJLGFBQWEsRUFBRTtJQUM1QixPQUFPLENBQUMsQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUE7R0FDOUQ7RUFDQSxPQUFPLENBQUMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7Q0FDN0QsQ0FBQTtBQUFDLE9BQUEsb0JBQUEsR0FBQSxtQkFBQSxDQUFBO0FBRUssMEJBQTBCO0VBQy9CLE1BQU0sVUFBVSxVQUFVLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQTtDQUMxQztBQUVBLE1BQU0sZ0JBQWdCLE1BQU07RUFDMUIsTUFBTSxRQUFRLENBQ1osTUFBTSxFQUNOLFNBQVMsRUFDVCxRQUFRLEVBQ1IsT0FBTyxFQUNQLEtBQUssRUFDTCxNQUFNLEVBQ04sT0FBTyxFQUNQLFFBQVEsQ0FDVCxDQUFBO0VBRUQsTUFBTSxPQUFPLEtBQUssS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDeEMsY0FBZSxDQUFBLEdBQUEsRUFBSyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBRSxDQUFBLENBQ3RDLENBQUMsQ0FBQTtFQUNELE1BQU0sUUFBUSxLQUFLLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQ3pDLGNBQWUsQ0FBQSxJQUFBLEVBQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUUsQ0FBQSxDQUN2QyxDQUFDLENBQUE7RUFDRCxNQUFNLFFBQVEsS0FBSyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUN6QyxjQUFlLENBQUEsS0FBQSxFQUFPLEtBQUssR0FBRyxDQUFFLENBQUEsQ0FDbEMsQ0FBQyxDQUFBOzs7Ozs7Ozs7O0VBVUQsTUFBTSxTQUFTLEtBQUssS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDMUMsY0FBZSxDQUFBLEtBQUEsRUFBTyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBRSxDQUFBLENBQ3hDLENBQUMsQ0FBQTtFQUNELE1BQU0sVUFBVSxLQUFLLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQzNDLGNBQWUsQ0FBQSxNQUFBLEVBQVEsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUUsQ0FBQSxDQUN6QyxDQUFDLENBQUE7RUFDRCxNQUFNLFFBQVEsS0FBSyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQzFDLE1BQU0sSUFBSSxDQUFFLFdBQWEsQ0FBQSxFQUFFLE9BQVEsQ0FBQSxDQUFBLEVBQUcsS0FBSyxHQUFHLENBQUUsQ0FBQSxDQUFDLENBQ25ELENBQUMsQ0FBQTtFQUNELE1BQU0sU0FBUyxLQUFLLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FDM0MsT0FBTyxJQUFJLENBQUUsWUFBYyxDQUFBLEVBQUUsUUFBUyxDQUFBLENBQUEsRUFBRyxLQUFLLEdBQUcsQ0FBRSxDQUFBLENBQUMsQ0FDdEQsQ0FBQyxDQUFBO0VBRUQsT0FBTyxDQUNMLEdBQUcsS0FBSyxFQUNSLEdBQUcsSUFBSSxFQUNQLEdBQUcsS0FBSyxFQUNSLEdBQUcsS0FBSyxFQUNSLEdBQUcsS0FBSyxLQUFLLEVBQUUsRUFDZixHQUFHLE1BQU0sS0FBSyxFQUFFLENBQ2pCLENBQUE7Q0FDRixDQUFBO0FBRUQsTUFBTSxpQkFBaUIsYUFBYSxFQUFFLENBQUE7QUFFdEMsTUFBTSxpQkFBa0Isc0JBQ3RCLGtCQUFrQixRQUFRLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLENBQUE7QUFFbEQsTUFBTSx5QkFBMEIsc0JBQzlCLGtCQUFrQixRQUFRLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFBO0FBRWhELE1BQU0sY0FBZSxzQkFDbkIsa0JBQWtCLE1BQU0sQ0FBQyxlQUFlLENBQUMsS0FBSyxJQUFJLENBQUE7QUFFcEQsTUFBTSxpQkFBa0IsUUFBUyxjQUFjLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUV2RCxNQUFNLGtCQUFrQiw2QkFBNkI7RUFDMUQsSUFBSSxDQUFDLEtBQUssRUFBRTtJQUNWLE1BQU0sSUFBSSxLQUFLLENBQUUsQ0FBQSx3QkFBQSxDQUF5QixDQUFDLENBQUE7R0FDN0M7OztFQUdBLE1BQU0sVUFBVSxXQUFXLElBQUksV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFBO0VBQ3ZELElBQUksT0FBTyxFQUFFO0lBQ1gsT0FBTztNQUNMLE9BQU8sR0FBRyxJQUFJLENBQUUsU0FDZCxlQUFlLENBQUMsS0FBSyxFQUFFLHNCQUFzQixDQUFDLFdBQVcsQ0FBQyxFQUFFLEtBQUssQ0FDbkUsQ0FBQztNQUNELE1BQU0sV0FBQTtLQUNQLENBQUE7R0FDRixNQUFNLElBQUksY0FBYyxDQUFDLFdBQVcsQ0FBQyxFQUFFO0lBQ3RDLE9BQU87TUFBRSxPQUFPLEdBQUc7TUFBRSxNQUFNLFdBQUE7S0FBYSxDQUFBO0dBQzFDOzs7RUFHQSxNQUFNLFdBQVcsT0FBTyxHQUFHLGNBQWMsQ0FBQyxXQUFXLENBQUMsR0FBRyxXQUFXLENBQUE7RUFFcEUsTUFBTSxzQkFBc0IsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0VBQzNDLElBQUksQ0FBQyxtQkFBbUIsRUFBRTtJQUN4QixNQUFNLElBQUksS0FBSyxDQUFFLENBQUEsK0JBQUEsQ0FBZ0MsQ0FBQyxDQUFBO0dBQ3BEO0VBRUEsTUFBTSxrQkFBa0IsRUFBRSxDQUFBO0VBQzFCLE1BQU0sVUFBVSxNQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQTtFQUNoQyxPQUFPLFFBQVEsQ0FBRSxVQUFXO0lBQzFCLE1BQU0sY0FBYyxNQUFNLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQ3hELHNCQUF1QixrQkFBa0IsS0FBSyxLQUFLLE1BQ3RELENBQUMsQ0FBQTtJQUVELElBQUksQ0FBQyxXQUFXLEVBQUU7TUFDaEIsT0FBQTtLQUNGO0lBRUEsZUFBZSxDQUFDLE1BQU0sQ0FBQyxHQUFHLGVBQWUsQ0FDdkMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUNYLFdBQVcsS0FBSyxFQUNoQixLQUNGLENBQUMsQ0FBQTtHQUNGLENBQUMsQ0FBQTtFQUNGLE9BQU87SUFBRSxPQUFPLGVBQWU7SUFBRSxNQUFNLFdBQUE7R0FBYSxDQUFBO0NBQ3JELENBQUE7QUFBQyxPQUFBLGdCQUFBLEdBQUEsZUFBQSxDQUFBO0FBRUssOENBQThDO0VBQ25ELElBQUksQ0FBQyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQ3ZDLE9BQU8sRUFBRSxDQUFBO0dBQ1g7RUFFQSxJQUFJLFdBQVcsSUFBSSxLQUFLLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUM5QyxPQUFPLENBQUEsQ0FBQSxFQUFBLGtCQUFBLG9CQUFtQixFQUFDLFdBQVcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7R0FDdEQ7RUFDQSxPQUFPLEtBQUssQ0FBQTtDQUNkO0FBRU8sbUZBR0w7RUFDQSxJQUFJLFNBQVMsS0FBSyxTQUFTLElBQUksU0FBUyxLQUFLLElBQUksRUFBRTtJQUNqRCxPQUFPLEVBQUUsQ0FBQTtHQUNYO0VBQ0EsT0FBTyxJQUFJLFFBQUEsUUFBTyxDQUNoQixJQUFJLFFBQUEsUUFBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLHFCQUFxQixDQUFDLEVBQ3pELEVBQ0YsQ0FBQyxTQUFTLEVBQUUsQ0FBQTtDQUNkOzs7Ozs7Ozs7O0FBVU8sMENBQTBDO0VBQUEsSUFBQSxnQkFBQSxDQUFBO0VBQy9DLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsRUFBRTtJQUM1QixPQUFPLGVBQWUsQ0FBQTtHQUN4QjtFQUNBLE9BQU8sQ0FBQSxDQUFBLG1CQUFBLEtBQUEsUUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFBLElBQUEsSUFBQSxnQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFoQixnQkFBQSxLQUFzQixLQUFJLFNBQVMsQ0FBQTtDQUM1Qzs7Ozs7Ozs7O0FBU08sMEJBQTBCO0VBQy9CLE9BQU8sS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxDQUFBO0NBQzlDOzs7Ozs7OztBQVVPLE1BQU0saUJBQWtCLFNBQVU7RUFDdkMsSUFBSSxDQUFDLEtBQUssRUFBRTtJQUNWLE9BQU8sS0FBSyxDQUFBO0dBQ2Q7RUFDQSxJQUFJLENBQUMsTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDM0IsT0FBTyxLQUFLLENBQUE7R0FDZDtFQUNBLE1BQU0sUUFBUSxXQUFXLENBQUE7RUFDekIsT0FBTyxLQUFLLFFBQVEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUE7Q0FDdkMsQ0FBQTs7Ozs7Ozs7O0FBRUQsT0FBQSxlQUFBLEdBQUEsY0FBQSxDQUFBO0FBUU8sTUFBTSxpQ0FBa0MsZ0JBQWlCO0VBQzlELElBQUksWUFBWSxLQUFLLFFBQUEsY0FBYSxJQUFJLEVBQUU7SUFDdEMsT0FBTyxFQUFFLENBQUE7R0FDWDtFQUNBLE9BQU8sWUFBWSxDQUFBO0NBQ3BCLENBQUE7Ozs7Ozs7O0FBRUQsT0FBQSwrQkFBQSxHQUFBLDhCQUFBLENBQUE7QUFNTyxNQUFNLHdCQUF3QixDQUFDLGNBQWMsRUFBRSxLQUFLO0VBQ3pELE9BQU8sQ0FBQyxXQUFXLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0NBQzFFLENBQUE7QUFBQyxPQUFBLHNCQUFBLEdBQUEscUJBQUEsQ0FBQSIsImZpbGUiOiJjb21tb24tNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBSYW5nZSB7XG4gIGNvbnN0cnVjdG9yIChyYW5nZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICB0aGlzLnJhdyA9IHJhbmdlLnZhbHVlXG4gICAgICB0aGlzLnNldCA9IFtbcmFuZ2VdXVxuICAgICAgdGhpcy5mb3JtYXQoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gICAgdGhpcy5yYXcgPSByYW5nZVxuICAgIHRoaXMuc2V0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnfHwnKVxuICAgICAgLy8gbWFwIHRoZSByYW5nZSB0byBhIDJkIGFycmF5IG9mIGNvbXBhcmF0b3JzXG4gICAgICAubWFwKHIgPT4gdGhpcy5wYXJzZVJhbmdlKHIudHJpbSgpKSlcbiAgICAgIC8vIHRocm93IG91dCBhbnkgY29tcGFyYXRvciBsaXN0cyB0aGF0IGFyZSBlbXB0eVxuICAgICAgLy8gdGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCBpdCB3YXMgbm90IGEgdmFsaWQgcmFuZ2UsIHdoaWNoIGlzIGFsbG93ZWRcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIGJ1dCB3aWxsIHN0aWxsIHRocm93IGlmIHRoZSBXSE9MRSByYW5nZSBpcyBpbnZhbGlkLlxuICAgICAgLmZpbHRlcihjID0+IGMubGVuZ3RoKVxuXG4gICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgU2VtVmVyIFJhbmdlOiAke3JhbmdlfWApXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgbm90IHRoZSBudWxsIHNldCwgdGhyb3cgb3V0IG51bGwgc2V0cy5cbiAgICBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgLy8ga2VlcCB0aGUgZmlyc3Qgb25lLCBpbiBjYXNlIHRoZXkncmUgYWxsIG51bGwgc2V0c1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLnNldFswXVxuICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5maWx0ZXIoYyA9PiAhaXNOdWxsU2V0KGNbMF0pKVxuICAgICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID1cbiAgICAgICh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UpIHxcbiAgICAgICh0aGlzLm9wdGlvbnMubG9vc2UgJiYgRkxBR19MT09TRSlcbiAgICBjb25zdCBtZW1vS2V5ID0gbWVtb09wdHMgKyAnOicgKyByYW5nZVxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KVxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRcbiAgICB9XG5cbiAgICBjb25zdCBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSlcbiAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcbiAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBsZXQgcmFuZ2VMaXN0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGNvbXAgPT4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAuam9pbignICcpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLy8gPj0wLjAuMCBpcyBlcXVpdmFsZW50IHRvICpcbiAgICAgIC5tYXAoY29tcCA9PiByZXBsYWNlR1RFMChjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgaWYgKGxvb3NlKSB7XG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgcmFuZ2VMaXN0ID0gcmFuZ2VMaXN0LmZpbHRlcihjb21wID0+IHtcbiAgICAgICAgZGVidWcoJ2xvb3NlIGludmFsaWQgZmlsdGVyJywgY29tcCwgdGhpcy5vcHRpb25zKVxuICAgICAgICByZXR1cm4gISFjb21wLm1hdGNoKHJlW3QuQ09NUEFSQVRPUkxPT1NFXSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGRlYnVnKCdyYW5nZSBsaXN0JywgcmFuZ2VMaXN0KVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IHJhbmdlTWFwID0gbmV3IE1hcCgpXG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZUxpc3QubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcGFyYXRvcnMpIHtcbiAgICAgIGlmIChpc051bGxTZXQoY29tcCkpIHtcbiAgICAgICAgcmV0dXJuIFtjb21wXVxuICAgICAgfVxuICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApXG4gICAgfVxuICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoJycpKSB7XG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXVxuICAgIGNhY2hlLnNldChtZW1vS2V5LCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaW50ZXJzZWN0cyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoKHRoaXNDb21wYXJhdG9ycykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeSgodGhpc0NvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoKHJhbmdlQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2UsXG59ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgeyBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSwgRkxBR19MT09TRSB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcblxuY29uc3QgaXNOdWxsU2V0ID0gYyA9PiBjLnZhbHVlID09PSAnPDAuMC4wLTAnXG5jb25zdCBpc0FueSA9IGMgPT4gYy52YWx1ZSA9PT0gJydcblxuLy8gdGFrZSBhIHNldCBvZiBjb21wYXJhdG9ycyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmVcbi8vIGV4aXN0cyBhIHZlcnNpb24gd2hpY2ggY2FuIHNhdGlzZnkgaXRcbmNvbnN0IGlzU2F0aXNmaWFibGUgPSAoY29tcGFyYXRvcnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlc3VsdCA9IHRydWVcbiAgY29uc3QgcmVtYWluaW5nQ29tcGFyYXRvcnMgPSBjb21wYXJhdG9ycy5zbGljZSgpXG4gIGxldCB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG5cbiAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeSgob3RoZXJDb21wYXJhdG9yKSA9PiB7XG4gICAgICByZXR1cm4gdGVzdENvbXBhcmF0b3IuaW50ZXJzZWN0cyhvdGhlckNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgfSlcblxuICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuY29uc3QgcGFyc2VDb21wYXJhdG9yID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKVxuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygnY2FyZXQnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygndGlsZGVzJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdzdGFycycsIGNvbXApXG4gIHJldHVybiBjb21wXG59XG5cbmNvbnN0IGlzWCA9IGlkID0+ICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJ1xuXG4vLyB+LCB+PiAtLSA+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0gPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tID4gPj0yLjAuMCA8Mi4xLjAtMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLSA+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLSA+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLSA+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4wLjAuMSAtLSA+ID49MC4wLjEgPDAuMS4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT5cbiAgY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGMpID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVRpbGRlKGMsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxuXG5jb25zdCByZXBsYWNlVGlsZGUgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuVElMREVMT09TRV0gOiByZVt0LlRJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wIDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAgPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIF4gLS0gPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLSA+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLSA+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4xLjIsIF4xLjIueCAtLSA+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLSA+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLSA+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4wLjAuMSAtLSA+ID49MC4wLjEgPDAuMC4yLTBcbi8vIF4wLjEuMCAtLSA+ID49MC4xLjAgPDAuMi4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT5cbiAgY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKGMpID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGMsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxuXG5jb25zdCByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29tcCA9IGNvbXAudHJpbSgpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5YUkFOR0VMT09TRV0gOiByZVt0LlhSQU5HRV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKVxuICAgIGNvbnN0IHhNID0gaXNYKE0pXG4gICAgY29uc3QgeG0gPSB4TSB8fCBpc1gobSlcbiAgICBjb25zdCB4cCA9IHhtIHx8IGlzWChwKVxuICAgIGNvbnN0IGFueVggPSB4cFxuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICBndGx0ID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG4gICAgcHIgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wLTAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLlxuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKSB7XG4gICAgICAgIG0gPSAwXG4gICAgICB9XG4gICAgICBwID0gMFxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIGd0bHQgPSAnPj0nXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgICBtID0gMFxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChndGx0ID09PSAnPCcpIHtcbiAgICAgICAgcHIgPSAnLTAnXG4gICAgICB9XG5cbiAgICAgIHJldCA9IGAke2d0bHQgKyBNfS4ke219LiR7cH0ke3ByfWBcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7cHJ9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5jb25zdCByZXBsYWNlU3RhcnMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgb3B0aW9ucylcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW3QuU1RBUl0sICcnKVxufVxuXG5jb25zdCByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlR1RFMCcsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnRyaW0oKVxuICAgIC5yZXBsYWNlKHJlW29wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyB0LkdURTBQUkUgOiB0LkdURTBdLCAnJylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTBcbmNvbnN0IGh5cGhlblJlcGxhY2UgPSBpbmNQciA9PiAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSA9PiB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4wLjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LiR7Zm19LjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChmcHIpIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfWBcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfSR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gYDwkeyt0TSArIDF9LjAuMC0wYFxuICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICB0byA9IGA8JHt0TX0uJHsrdG0gKyAxfS4wLTBgXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSBgPD0ke3RNfS4ke3RtfS4ke3RwfS0ke3Rwcn1gXG4gIH0gZWxzZSBpZiAoaW5jUHIpIHtcbiAgICB0byA9IGA8JHt0TX0uJHt0bX0uJHsrdHAgKyAxfS0wYFxuICB9IGVsc2Uge1xuICAgIHRvID0gYDw9JHt0b31gXG4gIH1cblxuICByZXR1cm4gKGAke2Zyb219ICR7dG99YCkudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3JlcXVpcmUoJ3V0aWwnKS5pbnNwZWN0KHZlcnNpb24pfWApXG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYHZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJHtNQVhfTEVOR1RIfSBjaGFyYWN0ZXJzYFxuICAgICAgKVxuICAgIH1cblxuICAgIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgLy8gdGhpcyBpc24ndCBhY3R1YWxseSByZWxldmFudCBmb3IgdmVyc2lvbnMsIGJ1dCBrZWVwIGl0IHNvIHRoYXQgd2VcbiAgICAvLyBkb24ndCBydW4gaW50byB0cm91YmxlIHBhc3NpbmcgdGhpcy5vcHRpb25zIGFyb3VuZC5cbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICBjb25zdCBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gob3B0aW9ucy5sb29zZSA/IHJlW3QuTE9PU0VdIDogcmVbdC5GVUxMXSlcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICB0aGlzLnJhdyA9IHZlcnNpb25cblxuICAgIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gICAgdGhpcy5tYWpvciA9ICttWzFdXG4gICAgdGhpcy5taW5vciA9ICttWzJdXG4gICAgdGhpcy5wYXRjaCA9ICttWzNdXG5cbiAgICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgICBpZiAoIW1bNF0pIHtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoJy4nKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK2lkXG4gICAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW11cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IGAke3RoaXMubWFqb3J9LiR7dGhpcy5taW5vcn0uJHt0aGlzLnBhdGNofWBcbiAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgdGhpcy52ZXJzaW9uICs9IGAtJHt0aGlzLnByZXJlbGVhc2Uuam9pbignLicpfWBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIGNvbXBhcmUgKG90aGVyKSB7XG4gICAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMsIG90aGVyKVxuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgaWYgKHR5cGVvZiBvdGhlciA9PT0gJ3N0cmluZycgJiYgb3RoZXIgPT09IHRoaXMudmVyc2lvbikge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKG90aGVyLnZlcnNpb24gPT09IHRoaXMudmVyc2lvbikge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKVxuICB9XG5cbiAgY29tcGFyZU1haW4gKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fFxuICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKVxuICAgIClcbiAgfVxuXG4gIGNvbXBhcmVQcmUgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMucHJlcmVsZWFzZVtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLnByZXJlbGVhc2VbaV1cbiAgICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIGNvbXBhcmVCdWlsZCAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmJ1aWxkW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIuYnVpbGRbaV1cbiAgICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuICBpbmMgKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSB7XG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6IHtcbiAgICAgICAgY29uc3QgYmFzZSA9IE51bWJlcihpZGVudGlmaWVyQmFzZSkgPyAxIDogMFxuXG4gICAgICAgIGlmICghaWRlbnRpZmllciAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiBpZGVudGlmaWVyIGlzIGVtcHR5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2Jhc2VdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIgPT09IHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJykgJiYgaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goYmFzZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgbGV0IHByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgYmFzZV1cbiAgICAgICAgICBpZiAoaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcmVyZWxlYXNlID0gW2lkZW50aWZpZXJdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21wYXJlSWRlbnRpZmllcnModGhpcy5wcmVyZWxlYXNlWzBdLCBpZGVudGlmaWVyKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQoKVxuICAgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbVZlclxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGNsZWFuID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBjb2VyY2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGxldCBtYXRjaCA9IG51bGxcbiAgaWYgKCFvcHRpb25zLnJ0bCkge1xuICAgIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVt0LkNPRVJDRV0pXG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQtbW9zdCBjb2VyY2libGUgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc2hhcmVcbiAgICAvLyBhIHRlcm1pbnVzIHdpdGggYSBtb3JlIGxlZnQtd2FyZCBjb2VyY2libGUgc3RyaW5nLlxuICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAvL1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgc3RyaW5nIGNoZWNraW5nIHdpdGggYSAvZyByZWdleHBcbiAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAvLyBTdG9wIHdoZW4gd2UgZ2V0IGEgbWF0Y2ggdGhhdCBlbmRzIGF0IHRoZSBzdHJpbmcgZW5kLCBzaW5jZSBub1xuICAgIC8vIGNvZXJjaWJsZSBzdHJpbmcgY2FuIGJlIG1vcmUgcmlnaHQtd2FyZCB3aXRob3V0IHRoZSBzYW1lIHRlcm1pbnVzLlxuICAgIGxldCBuZXh0XG4gICAgd2hpbGUgKChuZXh0ID0gcmVbdC5DT0VSQ0VSVExdLmV4ZWModmVyc2lvbikpICYmXG4gICAgICAgICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggIT09IHZlcnNpb24ubGVuZ3RoKVxuICAgICkge1xuICAgICAgaWYgKCFtYXRjaCB8fFxuICAgICAgICAgICAgbmV4dC5pbmRleCArIG5leHRbMF0ubGVuZ3RoICE9PSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkge1xuICAgICAgICBtYXRjaCA9IG5leHRcbiAgICAgIH1cbiAgICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IC0xXG4gIH1cblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHBhcnNlKGAke21hdGNoWzJdfS4ke21hdGNoWzNdIHx8ICcwJ30uJHttYXRjaFs0XSB8fCAnMCd9YCwgb3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzID0gY29lcmNlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlQnVpbGQgPSAoYSwgYiwgbG9vc2UpID0+IHtcbiAgY29uc3QgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICBjb25zdCB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVCdWlsZFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTG9vc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMiwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgY29tcGFyaXNvbiA9IHYxLmNvbXBhcmUodjIpXG5cbiAgaWYgKGNvbXBhcmlzb24gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdjFIaWdoZXIgPSBjb21wYXJpc29uID4gMFxuICBjb25zdCBoaWdoVmVyc2lvbiA9IHYxSGlnaGVyID8gdjEgOiB2MlxuICBjb25zdCBsb3dWZXJzaW9uID0gdjFIaWdoZXIgPyB2MiA6IHYxXG4gIGNvbnN0IGhpZ2hIYXNQcmUgPSAhIWhpZ2hWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG5cbiAgLy8gYWRkIHRoZSBgcHJlYCBwcmVmaXggaWYgd2UgYXJlIGdvaW5nIHRvIGEgcHJlcmVsZWFzZSB2ZXJzaW9uXG4gIGNvbnN0IHByZWZpeCA9IGhpZ2hIYXNQcmUgPyAncHJlJyA6ICcnXG5cbiAgaWYgKHYxLm1ham9yICE9PSB2Mi5tYWpvcikge1xuICAgIHJldHVybiBwcmVmaXggKyAnbWFqb3InXG4gIH1cblxuICBpZiAodjEubWlub3IgIT09IHYyLm1pbm9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtaW5vcidcbiAgfVxuXG4gIGlmICh2MS5wYXRjaCAhPT0gdjIucGF0Y2gpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ3BhdGNoJ1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCB3ZSBrbm93IHN0YWJsZSB2ZXJzaW9ucyBtYXRjaCBidXQgb3ZlcmFsbCB2ZXJzaW9ucyBhcmUgbm90IGVxdWFsLFxuICAvLyBzbyBlaXRoZXIgdGhleSBhcmUgYm90aCBwcmVyZWxlYXNlcywgb3IgdGhlIGxvd2VyIHZlcnNpb24gaXMgYSBwcmVyZWxlYXNlXG5cbiAgaWYgKGhpZ2hIYXNQcmUpIHtcbiAgICAvLyBoaWdoIGFuZCBsb3cgYXJlIHByZWxlYXNlc1xuICAgIHJldHVybiAncHJlcmVsZWFzZSdcbiAgfVxuXG4gIGlmIChsb3dWZXJzaW9uLnBhdGNoKSB7XG4gICAgLy8gYW55dGhpbmcgaGlnaGVyIHRoYW4gYSBwYXRjaCBidW1wIHdvdWxkIHJlc3VsdCBpbiB0aGUgd3JvbmcgdmVyc2lvblxuICAgIHJldHVybiAncGF0Y2gnXG4gIH1cblxuICBpZiAobG93VmVyc2lvbi5taW5vcikge1xuICAgIC8vIGFueXRoaW5nIGhpZ2hlciB0aGFuIGEgbWlub3IgYnVtcCB3b3VsZCByZXN1bHQgaW4gdGhlIHdyb25nIHZlcnNpb25cbiAgICByZXR1cm4gJ21pbm9yJ1xuICB9XG5cbiAgLy8gYnVtcGluZyBtYWpvci9taW5vci9wYXRjaCBhbGwgaGF2ZSBzYW1lIHJlc3VsdFxuICByZXR1cm4gJ21ham9yJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpID0+IHtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllckJhc2UgPSBpZGVudGlmaWVyXG4gICAgaWRlbnRpZmllciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKFxuICAgICAgdmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlciA/IHZlcnNpb24udmVyc2lvbiA6IHZlcnNpb24sXG4gICAgICBvcHRpb25zXG4gICAgKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMFxubW9kdWxlLmV4cG9ydHMgPSBsdGVcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IG5lcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbm1vZHVsZS5leHBvcnRzID0gbmVxXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zLCB0aHJvd0Vycm9ycyA9IGZhbHNlKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKCF0aHJvd0Vycm9ycykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhyb3cgZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXRjaCA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2hcbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGIsIGEsIGxvb3NlKVxubW9kdWxlLmV4cG9ydHMgPSByY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYSwgYiwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSBzb3J0XG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgdmFsaWQgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkXG4iLCIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBpZGVudGlmaWVycyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpXG5jb25zdCB2YWxpZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJylcbmNvbnN0IGNsZWFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKVxuY29uc3QgaW5jID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJylcbmNvbnN0IGRpZmYgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJylcbmNvbnN0IG1ham9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKVxuY29uc3QgbWlub3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpXG5jb25zdCBwYXRjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJylcbmNvbnN0IHByZXJlbGVhc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JylcbmNvbnN0IHJzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGNvZXJjZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblZlcnNpb24gPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpXG5jb25zdCB2YWxpZFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKVxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKVxuY29uc3QgZ3RyID0gcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJylcbmNvbnN0IGx0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpXG5jb25zdCBpbnRlcnNlY3RzID0gcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpXG5jb25zdCBzaW1wbGlmeVJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKVxuY29uc3Qgc3Vic2V0ID0gcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0Jylcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZSxcbiAgdmFsaWQsXG4gIGNsZWFuLFxuICBpbmMsXG4gIGRpZmYsXG4gIG1ham9yLFxuICBtaW5vcixcbiAgcGF0Y2gsXG4gIHByZXJlbGVhc2UsXG4gIGNvbXBhcmUsXG4gIHJjb21wYXJlLFxuICBjb21wYXJlTG9vc2UsXG4gIGNvbXBhcmVCdWlsZCxcbiAgc29ydCxcbiAgcnNvcnQsXG4gIGd0LFxuICBsdCxcbiAgZXEsXG4gIG5lcSxcbiAgZ3RlLFxuICBsdGUsXG4gIGNtcCxcbiAgY29lcmNlLFxuICBDb21wYXJhdG9yLFxuICBSYW5nZSxcbiAgc2F0aXNmaWVzLFxuICB0b0NvbXBhcmF0b3JzLFxuICBtYXhTYXRpc2Z5aW5nLFxuICBtaW5TYXRpc2Z5aW5nLFxuICBtaW5WZXJzaW9uLFxuICB2YWxpZFJhbmdlLFxuICBvdXRzaWRlLFxuICBndHIsXG4gIGx0cixcbiAgaW50ZXJzZWN0cyxcbiAgc2ltcGxpZnlSYW5nZSxcbiAgc3Vic2V0LFxuICBTZW1WZXIsXG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogY29uc3RhbnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFJFTEVBU0VfVFlQRVM6IGNvbnN0YW50cy5SRUxFQVNFX1RZUEVTLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMucmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsIi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmNvbnN0IFNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnXG5cbmNvbnN0IE1BWF9MRU5HVEggPSAyNTZcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG5jb25zdCBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxuY29uc3QgUkVMRUFTRV9UWVBFUyA9IFtcbiAgJ21ham9yJyxcbiAgJ3ByZW1ham9yJyxcbiAgJ21pbm9yJyxcbiAgJ3ByZW1pbm9yJyxcbiAgJ3BhdGNoJyxcbiAgJ3ByZXBhdGNoJyxcbiAgJ3ByZXJlbGVhc2UnLFxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfSU5URUdFUixcbiAgUkVMRUFTRV9UWVBFUyxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgRkxBR19JTkNMVURFX1BSRVJFTEVBU0U6IDBiMDAxLFxuICBGTEFHX0xPT1NFOiAwYjAxMCxcbn1cbiIsImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgXCJcIiAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChcIlwiKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsImNvbnN0IG51bWVyaWMgPSAvXlswLTldKyQvXG5jb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIGNvbnN0IGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iLCIvLyBwYXJzZSBvdXQganVzdCB0aGUgb3B0aW9ucyB3ZSBjYXJlIGFib3V0XG5jb25zdCBsb29zZU9wdGlvbiA9IE9iamVjdC5mcmVlemUoeyBsb29zZTogdHJ1ZSB9KVxuY29uc3QgZW1wdHlPcHRzID0gT2JqZWN0LmZyZWV6ZSh7IH0pXG5jb25zdCBwYXJzZU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVtcHR5T3B0c1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBsb29zZU9wdGlvblxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnNcbn1cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VPcHRpb25zXG4iLCJjb25zdCB7IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fVxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuY29uc3QgcmUgPSBleHBvcnRzLnJlID0gW11cbmNvbnN0IHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhuYW1lLCBpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJylcbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1swLTldKycpXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJylcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsICdbMC05QS1aYS16LV0rJylcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRCcsIGAoPzpcXFxcKygke3NyY1t0LkJVSUxESURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuQlVJTERJREVOVElGSUVSXX0pKikpYClcblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbmNyZWF0ZVRva2VuKCdGVUxMUExBSU4nLCBgdj8ke3NyY1t0Lk1BSU5WRVJTSU9OXVxufSR7c3JjW3QuUFJFUkVMRUFTRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0ZVTEwnLCBgXiR7c3JjW3QuRlVMTFBMQUlOXX0kYClcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxuY3JlYXRlVG9rZW4oJ0xPT1NFUExBSU4nLCBgW3Y9XFxcXHNdKiR7c3JjW3QuTUFJTlZFUlNJT05MT09TRV1cbn0ke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0xPT1NFJywgYF4ke3NyY1t0LkxPT1NFUExBSU5dfSRgKVxuXG5jcmVhdGVUb2tlbignR1RMVCcsICcoKD86PHw+KT89PyknKVxuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUkxPT1NFJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX18eHxYfFxcXFwqYClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOTE9PU0UnLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuY3JlYXRlVG9rZW4oJ0NPRVJDRScsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpIHtcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICAgIH1cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IGZpcnN0ID0gbnVsbFxuICBsZXQgcHJldiA9IG51bGxcbiAgY29uc3QgdiA9IHZlcnNpb25zLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgb3B0aW9ucykpXG4gIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2KSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgaWYgKGluY2x1ZGVkKSB7XG4gICAgICBwcmV2ID0gdmVyc2lvblxuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IHZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2V0LnB1c2goW2ZpcnN0LCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBmaXJzdCA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0KSB7XG4gICAgc2V0LnB1c2goW2ZpcnN0LCBudWxsXSlcbiAgfVxuXG4gIGNvbnN0IHJhbmdlcyA9IFtdXG4gIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICB9IGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaCgnKicpXG4gICAgfSBlbHNlIGlmICghbWF4KSB7XG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIH0gZWxzZSBpZiAobWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMucHVzaChgJHttaW59IC0gJHttYXh9YClcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKV1cbmNvbnN0IG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgICB9XG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSAocmFuZ2UsIG9wdGlvbnMpID0+XG4gIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykuc2V0XG4gICAgLm1hcChjb21wID0+IGNvbXAubWFwKGMgPT4gYy52YWx1ZSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQ29tcGFyYXRvcnNcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCB2YWxpZFJhbmdlID0gKHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJ1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRSYW5nZVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nID8gc2V0SW1tZWRpYXRlIDpcblx0ZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcblx0XHRhcmdzLnNwbGljZSgxLCAwLCAwKTtcblx0XHRzZXRUaW1lb3V0LmFwcGx5KG51bGwsIGFyZ3MpO1xuXHR9O1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuX2Jsb2NrU2l6ZVxuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgdmFyIGFjY3VtID0gdGhpcy5fbGVuXG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOykge1xuICAgIHZhciBhc3NpZ25lZCA9IGFjY3VtICUgYmxvY2tTaXplXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGgubWluKGxlbmd0aCAtIG9mZnNldCwgYmxvY2tTaXplIC0gYXNzaWduZWQpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmRlcjsgaSsrKSB7XG4gICAgICBibG9ja1thc3NpZ25lZCArIGldID0gZGF0YVtvZmZzZXQgKyBpXVxuICAgIH1cblxuICAgIGFjY3VtICs9IHJlbWFpbmRlclxuICAgIG9mZnNldCArPSByZW1haW5kZXJcblxuICAgIGlmICgoYWNjdW0gJSBibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYmxvY2spXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fbGVuICs9IGxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciByZW0gPSB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVcblxuICB0aGlzLl9ibG9ja1tyZW1dID0gMHg4MFxuXG4gIC8vIHplcm8gKHJlbSArIDEpIHRyYWlsaW5nIGJpdHMsIHdoZXJlIChyZW0gKyAxKSBpcyB0aGUgc21hbGxlc3RcbiAgLy8gbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobGVuZ3RoICsgMSArIChyZW0gKyAxKSkgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgcmVtICsgMSlcblxuICBpZiAocmVtID49IHRoaXMuX2ZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICB2YXIgYml0cyA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyB1aW50MzJcbiAgaWYgKGJpdHMgPD0gMHhmZmZmZmZmZikge1xuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoYml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICAvLyB1aW50NjRcbiAgfSBlbHNlIHtcbiAgICB2YXIgbG93Qml0cyA9IChiaXRzICYgMHhmZmZmZmZmZikgPj4+IDBcbiAgICB2YXIgaGlnaEJpdHMgPSAoYml0cyAtIGxvd0JpdHMpIC8gMHgxMDAwMDAwMDBcblxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoaGlnaEJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDgpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShsb3dCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyMjQgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyMjQsIFNoYTI1NilcblxuU2hhMjI0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjMTA1OWVkOFxuICB0aGlzLl9iID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nID0gMHg2NGY5OGZhN1xuICB0aGlzLl9oID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBjaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAyIHwgeCA8PCAzMCkgXiAoeCA+Pj4gMTMgfCB4IDw8IDE5KSBeICh4ID4+PiAyMiB8IHggPDwgMTApXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxufVxuXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA3IHwgeCA8PCAyNSkgXiAoeCA+Pj4gMTggfCB4IDw8IDE0KSBeICh4ID4+PiAzKVxufVxuXG5mdW5jdGlvbiBnYW1tYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAxNyB8IHggPDwgMTUpIF4gKHggPj4+IDE5IHwgeCA8PCAxMykgXiAoeCA+Pj4gMTApXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgKytqKSB7XG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcbiAgICB2YXIgVDIgPSAoc2lnbWEwKGEpICsgbWFqKGEsIGIsIGMpKSB8IDBcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSAoZCArIFQxKSB8IDBcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gKFQxICsgVDIpIHwgMFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZ2gsIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICAge1xuICAgICBcInBheWFibGVcIjogdHJ1ZSxcbiAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJwYXlhYmxlXCIsXG4gICAgIFwidHlwZVwiOiBcImZhbGxiYWNrXCJcbiAgICB9LFxuICAgIHtcbiAgICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgXCJuYW1lXCI6IFwidXNlclwiLFxuICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJ0b2tlblwiLFxuICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgICBdLFxuICAgICBcIm5hbWVcIjogXCJ0b2tlbkJhbGFuY2VcIixcbiAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICAgXSxcbiAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAge1xuICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJ1c2Vyc1wiLFxuICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcInRva2Vuc1wiLFxuICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NbXVwiXG4gICAgICB9XG4gICAgIF0sXG4gICAgIFwibmFtZVwiOiBcImJhbGFuY2VzXCIsXG4gICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgXCJuYW1lXCI6IFwiXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwidWludDI1NltdXCJcbiAgICAgIH1cbiAgICAgXSxcbiAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgIH1cbiAgIF1cbiIsInZhciBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi9yZXNwb25zZScpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHN0YXR1c0NvZGVzID0gcmVxdWlyZSgnYnVpbHRpbi1zdGF0dXMtY29kZXMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwID0gZXhwb3J0c1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcblx0XHRvcHRzID0gdXJsLnBhcnNlKG9wdHMpXG5cdGVsc2Vcblx0XHRvcHRzID0gZXh0ZW5kKG9wdHMpXG5cblx0Ly8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcblx0Ly8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG5cdC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG5cdHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuXHR2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuXHR2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cdHZhciBwb3J0ID0gb3B0cy5wb3J0XG5cdHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG5cdC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcblx0aWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuXHRcdGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cblx0Ly8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXHRvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuXHRvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuXHQvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cblx0dmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG5cdGlmIChjYilcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgY2IpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5nZXQgPSBmdW5jdGlvbiBnZXQgKG9wdHMsIGNiKSB7XG5cdHZhciByZXEgPSBodHRwLnJlcXVlc3Qob3B0cywgY2IpXG5cdHJlcS5lbmQoKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuQ2xpZW50UmVxdWVzdCA9IENsaWVudFJlcXVlc3Rcbmh0dHAuSW5jb21pbmdNZXNzYWdlID0gcmVzcG9uc2UuSW5jb21pbmdNZXNzYWdlXG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fVxuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDRcblxuaHR0cC5nbG9iYWxBZ2VudCA9IG5ldyBodHRwLkFnZW50KClcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSBzdGF0dXNDb2Rlc1xuXG5odHRwLk1FVEhPRFMgPSBbXG5cdCdDSEVDS09VVCcsXG5cdCdDT05ORUNUJyxcblx0J0NPUFknLFxuXHQnREVMRVRFJyxcblx0J0dFVCcsXG5cdCdIRUFEJyxcblx0J0xPQ0snLFxuXHQnTS1TRUFSQ0gnLFxuXHQnTUVSR0UnLFxuXHQnTUtBQ1RJVklUWScsXG5cdCdNS0NPTCcsXG5cdCdNT1ZFJyxcblx0J05PVElGWScsXG5cdCdPUFRJT05TJyxcblx0J1BBVENIJyxcblx0J1BPU1QnLFxuXHQnUFJPUEZJTkQnLFxuXHQnUFJPUFBBVENIJyxcblx0J1BVUkdFJyxcblx0J1BVVCcsXG5cdCdSRVBPUlQnLFxuXHQnU0VBUkNIJyxcblx0J1NVQlNDUklCRScsXG5cdCdUUkFDRScsXG5cdCdVTkxPQ0snLFxuXHQnVU5TVUJTQ1JJQkUnXG5dIiwiZXhwb3J0cy5mZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsLmZldGNoKSAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5SZWFkYWJsZVN0cmVhbSlcblxuZXhwb3J0cy53cml0YWJsZVN0cmVhbSA9IGlzRnVuY3Rpb24oZ2xvYmFsLldyaXRhYmxlU3RyZWFtKVxuXG5leHBvcnRzLmFib3J0Q29udHJvbGxlciA9IGlzRnVuY3Rpb24oZ2xvYmFsLkFib3J0Q29udHJvbGxlcilcblxuLy8gVGhlIHhociByZXF1ZXN0IHRvIGV4YW1wbGUuY29tIG1heSB2aW9sYXRlIHNvbWUgcmVzdHJpY3RpdmUgQ1NQIGNvbmZpZ3VyYXRpb25zLFxuLy8gc28gaWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyBgZmV0Y2hgLCBhdm9pZCBjYWxsaW5nIGdldFhIUigpXG4vLyBhbmQgYXNzdW1lIHN1cHBvcnQgZm9yIGNlcnRhaW4gZmVhdHVyZXMgYmVsb3cuXG52YXIgeGhyXG5mdW5jdGlvbiBnZXRYSFIgKCkge1xuXHQvLyBDYWNoZSB0aGUgeGhyIHZhbHVlXG5cdGlmICh4aHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHhoclxuXG5cdGlmIChnbG9iYWwuWE1MSHR0cFJlcXVlc3QpIHtcblx0XHR4aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcblx0XHQvLyBJZiBYRG9tYWluUmVxdWVzdCBpcyBhdmFpbGFibGUgKGllIG9ubHksIHdoZXJlIHhociBtaWdodCBub3Qgd29ya1xuXHRcdC8vIGNyb3NzIGRvbWFpbiksIHVzZSB0aGUgcGFnZSBsb2NhdGlvbi4gT3RoZXJ3aXNlIHVzZSBleGFtcGxlLmNvbVxuXHRcdC8vIE5vdGU6IHRoaXMgZG9lc24ndCBhY3R1YWxseSBtYWtlIGFuIGh0dHAgcmVxdWVzdC5cblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oJ0dFVCcsIGdsb2JhbC5YRG9tYWluUmVxdWVzdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJylcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHhociA9IG51bGxcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VydmljZSB3b3JrZXJzIGRvbid0IGhhdmUgWEhSXG5cdFx0eGhyID0gbnVsbFxuXHR9XG5cdHJldHVybiB4aHJcbn1cblxuZnVuY3Rpb24gY2hlY2tUeXBlU3VwcG9ydCAodHlwZSkge1xuXHR2YXIgeGhyID0gZ2V0WEhSKClcblx0aWYgKCF4aHIpIHJldHVybiBmYWxzZVxuXHR0cnkge1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSB0eXBlXG5cdFx0cmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09IHR5cGVcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlXG59XG5cbi8vIElmIGZldGNoIGlzIHN1cHBvcnRlZCwgdGhlbiBhcnJheWJ1ZmZlciB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gY2hlY2tUeXBlU3VwcG9ydCgpLCBzaW5jZSB0aGF0IGNhbGxzIGdldFhIUigpLlxuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IGV4cG9ydHMuZmV0Y2ggfHwgY2hlY2tUeXBlU3VwcG9ydCgnYXJyYXlidWZmZXInKVxuXG4vLyBUaGVzZSBuZXh0IHR3byB0ZXN0cyB1bmF2b2lkYWJseSBzaG93IHdhcm5pbmdzIGluIENocm9tZS4gU2luY2UgZmV0Y2ggd2lsbCBhbHdheXNcbi8vIGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGp1c3QgcmV0dXJuIGZhbHNlIGZvciB0aGVzZSB0byBhdm9pZCB0aGUgd2FybmluZ3MuXG5leHBvcnRzLm1zc3RyZWFtID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKVxuXG4vLyBJZiBmZXRjaCBpcyBzdXBwb3J0ZWQsIHRoZW4gb3ZlcnJpZGVNaW1lVHlwZSB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gZ2V0WEhSKCkuXG5leHBvcnRzLm92ZXJyaWRlTWltZVR5cGUgPSBleHBvcnRzLmZldGNoIHx8IChnZXRYSFIoKSA/IGlzRnVuY3Rpb24oZ2V0WEhSKCkub3ZlcnJpZGVNaW1lVHlwZSkgOiBmYWxzZSlcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG54aHIgPSBudWxsIC8vIEhlbHAgZ2NcbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5LCB1c2VGZXRjaCkge1xuXHRpZiAoY2FwYWJpbGl0eS5mZXRjaCAmJiB1c2VGZXRjaCkge1xuXHRcdHJldHVybiAnZmV0Y2gnXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tb3pjaHVua2VkYXJyYXlidWZmZXIpIHtcblx0XHRyZXR1cm4gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubXNzdHJlYW0pIHtcblx0XHRyZXR1cm4gJ21zLXN0cmVhbSdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LmFycmF5YnVmZmVyICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAnYXJyYXlidWZmZXInXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICd0ZXh0J1xuXHR9XG59XG5cbnZhciBDbGllbnRSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9vcHRzID0gb3B0c1xuXHRzZWxmLl9ib2R5ID0gW11cblx0c2VsZi5faGVhZGVycyA9IHt9XG5cdGlmIChvcHRzLmF1dGgpXG5cdFx0c2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpKVxuXHRPYmplY3Qua2V5cyhvcHRzLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRzZWxmLnNldEhlYWRlcihuYW1lLCBvcHRzLmhlYWRlcnNbbmFtZV0pXG5cdH0pXG5cblx0dmFyIHByZWZlckJpbmFyeVxuXHR2YXIgdXNlRmV0Y2ggPSB0cnVlXG5cdGlmIChvcHRzLm1vZGUgPT09ICdkaXNhYmxlLWZldGNoJyB8fCAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmICFjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikpIHtcblx0XHQvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkLiBOb3QgdHlwaWNhbGx5IG5lZWRlZC5cblx0XHR1c2VGZXRjaCA9IGZhbHNlXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cblx0c2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuX29uRmluaXNoKClcblx0fSlcbn1cblxuaW5oZXJpdHMoQ2xpZW50UmVxdWVzdCwgc3RyZWFtLldyaXRhYmxlKVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHZhciBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblx0Ly8gVGhpcyBjaGVjayBpcyBub3QgbmVjZXNzYXJ5LCBidXQgaXQgcHJldmVudHMgd2FybmluZ3MgZnJvbSBicm93c2VycyBhYm91dCBzZXR0aW5nIHVuc2FmZVxuXHQvLyBoZWFkZXJzLiBUbyBiZSBob25lc3QgSSdtIG5vdCBlbnRpcmVseSBzdXJlIGhpZGluZyB0aGVzZSB3YXJuaW5ncyBpcyBhIGdvb2QgdGhpbmcsIGJ1dFxuXHQvLyBodHRwLWJyb3dzZXJpZnkgZGlkIGl0LCBzbyBJIHdpbGwgdG9vLlxuXHRpZiAodW5zYWZlSGVhZGVycy5pbmRleE9mKGxvd2VyTmFtZSkgIT09IC0xKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX2hlYWRlcnNbbG93ZXJOYW1lXSA9IHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBoZWFkZXIgPSB0aGlzLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV1cblx0aWYgKGhlYWRlcilcblx0XHRyZXR1cm4gaGVhZGVyLnZhbHVlXG5cdHJldHVybiBudWxsXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblx0dmFyIG9wdHMgPSBzZWxmLl9vcHRzXG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5ID0gbnVsbFxuXHRpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnICYmIG9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgYm9keSA9IG5ldyBCbG9iKHNlbGYuX2JvZHksIHtcbiAgICAgICAgICAgIHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cdC8vIGNyZWF0ZSBmbGF0dGVuZWQgbGlzdCBvZiBoZWFkZXJzXG5cdHZhciBoZWFkZXJzTGlzdCA9IFtdXG5cdE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLmZvckVhY2goZnVuY3Rpb24gKGtleU5hbWUpIHtcblx0XHR2YXIgbmFtZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0ubmFtZVxuXHRcdHZhciB2YWx1ZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0udmFsdWVcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0aGVhZGVyc0xpc3QucHVzaChbbmFtZSwgdl0pXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkZXJzTGlzdC5wdXNoKFtuYW1lLCB2YWx1ZV0pXG5cdFx0fVxuXHR9KVxuXG5cdGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0dmFyIHNpZ25hbCA9IG51bGxcblx0XHRpZiAoY2FwYWJpbGl0eS5hYm9ydENvbnRyb2xsZXIpIHtcblx0XHRcdHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cdFx0XHRzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbFxuXHRcdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIgPSBjb250cm9sbGVyXG5cblx0XHRcdGlmICgncmVxdWVzdFRpbWVvdXQnIGluIG9wdHMgJiYgb3B0cy5yZXF1ZXN0VGltZW91dCAhPT0gMCkge1xuXHRcdFx0XHRzZWxmLl9mZXRjaFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0XHRcdGlmIChzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlcilcblx0XHRcdFx0XHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcblx0XHRcdFx0fSwgb3B0cy5yZXF1ZXN0VGltZW91dClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbG9iYWwuZmV0Y2goc2VsZi5fb3B0cy51cmwsIHtcblx0XHRcdG1ldGhvZDogc2VsZi5fb3B0cy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzTGlzdCxcblx0XHRcdGJvZHk6IGJvZHkgfHwgdW5kZWZpbmVkLFxuXHRcdFx0bW9kZTogJ2NvcnMnLFxuXHRcdFx0Y3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJyxcblx0XHRcdHNpZ25hbDogc2lnbmFsXG5cdFx0fSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXHRcdFx0c2VsZi5fY29ubmVjdCgpXG5cdFx0fSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0Z2xvYmFsLmNsZWFyVGltZW91dChzZWxmLl9mZXRjaFRpbWVyKVxuXHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCByZWFzb24pXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHR2YXIgeGhyID0gc2VsZi5feGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKHNlbGYuX29wdHMubWV0aG9kLCBzZWxmLl9vcHRzLnVybCwgdHJ1ZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuXHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZVxuXG5cdFx0aWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocilcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzXG5cblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ3RleHQnICYmICdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpXG5cblx0XHRpZiAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzKSB7XG5cdFx0XHR4aHIudGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXRcblx0XHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlYWRlcnNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG5cdFx0fSlcblxuXHRcdHNlbGYuX3Jlc3BvbnNlID0gbnVsbFxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5MT0FESU5HOlxuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuRE9ORTpcblx0XHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkXG5cdFx0Ly8gaW4gb25wcm9ncmVzcywgbm90IGluIG9ucmVhZHlzdGF0ZWNoYW5nZSB3aXRoIHhoci5yZWFkeVN0YXRlID0gM1xuXHRcdGlmIChzZWxmLl9tb2RlID09PSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKSB7XG5cdFx0XHR4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1hIUiBlcnJvcicpKVxuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR4aHIuc2VuZChib2R5KVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHhoci5zdGF0dXMgaXMgcmVhZGFibGUgYW5kIG5vbi16ZXJvLCBpbmRpY2F0aW5nIG5vIGVycm9yLlxuICogRXZlbiB0aG91Z2ggdGhlIHNwZWMgc2F5cyBpdCBzaG91bGQgYmUgYXZhaWxhYmxlIGluIHJlYWR5U3RhdGUgMyxcbiAqIGFjY2Vzc2luZyBpdCB0aHJvd3MgYW4gZXhjZXB0aW9uIGluIElFOFxuICovXG5mdW5jdGlvbiBzdGF0dXNWYWxpZCAoeGhyKSB7XG5cdHRyeSB7XG5cdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXNcblx0XHRyZXR1cm4gKHN0YXR1cyAhPT0gbnVsbCAmJiBzdGF0dXMgIT09IDApXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKCFzdGF0dXNWYWxpZChzZWxmLl94aHIpIHx8IHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRpZiAoIXNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX2Nvbm5lY3QoKVxuXG5cdHNlbGYuX3Jlc3BvbnNlLl9vblhIUlByb2dyZXNzKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5fcmVzcG9uc2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKHNlbGYuX3hociwgc2VsZi5fZmV0Y2hSZXNwb25zZSwgc2VsZi5fbW9kZSwgc2VsZi5fZmV0Y2hUaW1lcilcblx0c2VsZi5fcmVzcG9uc2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0fSlcblxuXHRzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgc2VsZi5fcmVzcG9uc2UpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX2JvZHkucHVzaChjaHVuaylcblx0Y2IoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IENsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9kZXN0cm95ZWQgPSB0cnVlXG5cdGdsb2JhbC5jbGVhclRpbWVvdXQoc2VsZi5fZmV0Y2hUaW1lcilcblx0aWYgKHNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX3Jlc3BvbnNlLl9kZXN0cm95ZWQgPSB0cnVlXG5cdGlmIChzZWxmLl94aHIpXG5cdFx0c2VsZi5feGhyLmFib3J0KClcblx0ZWxzZSBpZiAoc2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIpXG5cdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYiA9IGRhdGFcblx0XHRkYXRhID0gdW5kZWZpbmVkXG5cdH1cblxuXHRzdHJlYW0uV3JpdGFibGUucHJvdG90eXBlLmVuZC5jYWxsKHNlbGYsIGRhdGEsIGVuY29kaW5nLCBjYilcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZmx1c2hIZWFkZXJzID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0Tm9EZWxheSA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRTb2NrZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtc2V0cmVxdWVzdGhlYWRlciUyOCUyOS1tZXRob2RcbnZhciB1bnNhZmVIZWFkZXJzID0gW1xuXHQnYWNjZXB0LWNoYXJzZXQnLFxuXHQnYWNjZXB0LWVuY29kaW5nJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZCcsXG5cdCdjb25uZWN0aW9uJyxcblx0J2NvbnRlbnQtbGVuZ3RoJyxcblx0J2Nvb2tpZScsXG5cdCdjb29raWUyJyxcblx0J2RhdGUnLFxuXHQnZG50Jyxcblx0J2V4cGVjdCcsXG5cdCdob3N0Jyxcblx0J2tlZXAtYWxpdmUnLFxuXHQnb3JpZ2luJyxcblx0J3JlZmVyZXInLFxuXHQndGUnLFxuXHQndHJhaWxlcicsXG5cdCd0cmFuc2Zlci1lbmNvZGluZycsXG5cdCd1cGdyYWRlJyxcblx0J3ZpYSdcbl1cbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgclN0YXRlcyA9IGV4cG9ydHMucmVhZHlTdGF0ZXMgPSB7XG5cdFVOU0VOVDogMCxcblx0T1BFTkVEOiAxLFxuXHRIRUFERVJTX1JFQ0VJVkVEOiAyLFxuXHRMT0FESU5HOiAzLFxuXHRET05FOiA0XG59XG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSBleHBvcnRzLkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uICh4aHIsIHJlc3BvbnNlLCBtb2RlLCBmZXRjaFRpbWVyKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uUmVhZGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX21vZGUgPSBtb2RlXG5cdHNlbGYuaGVhZGVycyA9IHt9XG5cdHNlbGYucmF3SGVhZGVycyA9IFtdXG5cdHNlbGYudHJhaWxlcnMgPSB7fVxuXHRzZWxmLnJhd1RyYWlsZXJzID0gW11cblxuXHQvLyBGYWtlIHRoZSAnY2xvc2UnIGV2ZW50LCBidXQgb25seSBvbmNlICdlbmQnIGZpcmVzXG5cdHNlbGYub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUaGUgbmV4dFRpY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgdGhlICdyZXF1ZXN0JyBtb2R1bGUgZnJvbSBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3Bcblx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuZW1pdCgnY2xvc2UnKVxuXHRcdH0pXG5cdH0pXG5cblx0aWYgKG1vZGUgPT09ICdmZXRjaCcpIHtcblx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2VcblxuXHRcdHNlbGYudXJsID0gcmVzcG9uc2UudXJsXG5cdFx0c2VsZi5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dFxuXHRcdFxuXHRcdHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyLCBrZXkpe1xuXHRcdFx0c2VsZi5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlclxuXHRcdFx0c2VsZi5yYXdIZWFkZXJzLnB1c2goa2V5LCBoZWFkZXIpXG5cdFx0fSlcblxuXHRcdGlmIChjYXBhYmlsaXR5LndyaXRhYmxlU3RyZWFtKSB7XG5cdFx0XHR2YXIgd3JpdGFibGUgPSBuZXcgV3JpdGFibGVTdHJlYW0oe1xuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KClcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihzZWxmLnB1c2goQnVmZmVyLmZyb20oY2h1bmspKSkge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKClcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuX3Jlc3VtZUZldGNoID0gcmVzb2x2ZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Z2xvYmFsLmNsZWFyVGltZW91dChmZXRjaFRpbWVyKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNwb25zZS5ib2R5LnBpcGVUbyh3cml0YWJsZSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRcdGdsb2JhbC5jbGVhclRpbWVvdXQoZmV0Y2hUaW1lcilcblx0XHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fSBjYXRjaCAoZSkge30gLy8gcGlwZVRvIG1ldGhvZCBpc24ndCBkZWZpbmVkLiBDYW4ndCBmaW5kIGEgYmV0dGVyIHdheSB0byBmZWF0dXJlIHRlc3QgdGhpc1xuXHRcdH1cblx0XHQvLyBmYWxsYmFjayBmb3Igd2hlbiB3cml0YWJsZVN0cmVhbSBvciBwaXBlVG8gYXJlbid0IGF2YWlsYWJsZVxuXHRcdHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpXG5cdFx0ZnVuY3Rpb24gcmVhZCAoKSB7XG5cdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0XHRnbG9iYWwuY2xlYXJUaW1lb3V0KGZldGNoVGltZXIpXG5cdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKHJlc3VsdC52YWx1ZSkpXG5cdFx0XHRcdHJlYWQoKVxuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRnbG9iYWwuY2xlYXJUaW1lb3V0KGZldGNoVGltZXIpXG5cdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRyZWFkKClcblx0fSBlbHNlIHtcblx0XHRzZWxmLl94aHIgPSB4aHJcblx0XHRzZWxmLl9wb3MgPSAwXG5cblx0XHRzZWxmLnVybCA9IHhoci5yZXNwb25zZVVSTFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSB4aHIuc3RhdHVzVGV4dFxuXHRcdHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLylcblx0XHRoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBoZWFkZXIubWF0Y2goL14oW146XSspOlxccyooLiopLylcblx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0ucHVzaChtYXRjaGVzWzJdKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgbWF0Y2hlc1syXVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gbWF0Y2hlc1syXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHNlbGYuX2NoYXJzZXQgPSAneC11c2VyLWRlZmluZWQnXG5cdFx0aWYgKCFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ11cblx0XHRcdGlmIChtaW1lVHlwZSkge1xuXHRcdFx0XHR2YXIgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0oW147XSkoO3wkKS8pXG5cdFx0XHRcdGlmIChjaGFyc2V0TWF0Y2gpIHtcblx0XHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gJ3V0Zi04JyAvLyBiZXN0IGd1ZXNzXG5cdFx0fVxuXHR9XG59XG5cbmluaGVyaXRzKEluY29taW5nTWVzc2FnZSwgc3RyZWFtLlJlYWRhYmxlKVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgcmVzb2x2ZSA9IHNlbGYuX3Jlc3VtZUZldGNoXG5cdGlmIChyZXNvbHZlKSB7XG5cdFx0c2VsZi5fcmVzdW1lRmV0Y2ggPSBudWxsXG5cdFx0cmVzb2x2ZSgpXG5cdH1cbn1cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHhociA9IHNlbGYuX3hoclxuXG5cdHZhciByZXNwb25zZSA9IG51bGxcblx0c3dpdGNoIChzZWxmLl9tb2RlKSB7XG5cdFx0Y2FzZSAndGV4dCc6XG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHRcblx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0dmFyIG5ld0RhdGEgPSByZXNwb25zZS5zdWJzdHIoc2VsZi5fcG9zKVxuXHRcdFx0XHRpZiAoc2VsZi5fY2hhcnNldCA9PT0gJ3gtdXNlci1kZWZpbmVkJykge1xuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MobmV3RGF0YS5sZW5ndGgpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0YnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZlxuXG5cdFx0XHRcdFx0c2VsZi5wdXNoKGJ1ZmZlcilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3RGF0YSwgc2VsZi5fY2hhcnNldClcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9wb3MgPSByZXNwb25zZS5sZW5ndGhcblx0XHRcdH1cblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUgfHwgIXhoci5yZXNwb25zZSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInOiAvLyB0YWtlIHdob2xlXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKSkpXG5cdFx0XHRicmVha1xuXHRcdGNhc2UgJ21zLXN0cmVhbSc6XG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IGdsb2JhbC5NU1N0cmVhbVJlYWRlcigpXG5cdFx0XHRyZWFkZXIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHJlYWRlci5yZXN1bHQuYnl0ZUxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHRcdHNlbGYucHVzaChCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0LnNsaWNlKHNlbGYuX3BvcykpKSlcblx0XHRcdFx0XHRzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHR9XG5cdFx0XHQvLyByZWFkZXIub25lcnJvciA9ID8/PyAvLyBUT0RPOiB0aGlzXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpXG5cdFx0XHRicmVha1xuXHR9XG5cblx0Ly8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG5cdGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG5cdFx0c2VsZi5wdXNoKG51bGwpXG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb2RlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9XG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ1RoZSAnICsgbmFtZSArICcgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07IC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuXG5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59OyAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7IC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwidmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcblxuLyoqXG4gKiBSZW1vdmVzICcweCcgZnJvbSBhIGdpdmVuIGBTdHJpbmdgIGlzIHByZXNlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfE9wdGlvbmFsfSBhIHN0cmluZyBieSBwYXNzIGlmIG5lY2Vzc2FyeVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuU3VwZXJzdHJ1Y3QgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gICAgICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAgICAgKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAgICAgKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZDtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBgQXQgcGF0aDogJHtwYXRoLmpvaW4oJy4nKX0gLS0gJHttZXNzYWdlfWA7XG4gICAgICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBtc2cpO1xuICAgICAgICAgICAgaWYgKGV4cGxhbmF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG1zZztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KTtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICAgICAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICAgICAgY29uc3QgeyByZWZpbmVtZW50LCBtZXNzYWdlID0gYEV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgJHtyZWZpbmVtZW50ID8gYCB3aXRoIHJlZmluZW1lbnQgXFxgJHtyZWZpbmVtZW50fVxcYGAgOiAnJ30sIGJ1dCByZWNlaXZlZDogXFxgJHtwcmludCh2YWx1ZSl9XFxgYCwgfSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJlZmluZW1lbnQsXG4gICAgICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBicmFuY2gsXG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmFsaWRhdGlvbiByZXN1bHQgdG8gYW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24qIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBmYWlsdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAgICAgKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHBhdGggPSBbXSwgYnJhbmNoID0gW3ZhbHVlXSwgY29lcmNlID0gZmFsc2UsIG1hc2sgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY3R4ID0geyBwYXRoLCBicmFuY2ggfTtcbiAgICAgICAgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmXG4gICAgICAgICAgICAgICAgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHN0cnVjdC5zY2hlbWEpICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICAgICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgICAgICAgICAgIHBhdGg6IGsgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwga10sXG4gICAgICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgICAgICBjb2VyY2UsXG4gICAgICAgICAgICAgICAgbWFzayxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHRbMF0ucmVmaW5lbWVudCAhPSBudWxsID8gJ25vdF9yZWZpbmVkJyA6ICdub3RfdmFsaWQnO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29lcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNldChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCB8fCBrIGluIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzICE9PSAnbm90X3ZhbGlkJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnbm90X3JlZmluZWQnO1xuICAgICAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBTdHJ1Y3RgIG9iamVjdHMgZW5jYXBzdWxhdGUgdGhlIHZhbGlkYXRpb24gbG9naWMgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZlxuICAgICAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gICAgICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAgICAgKi9cbiAgICBjbGFzcyBTdHJ1Y3Qge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBzY2hlbWEsIHZhbGlkYXRvciwgcmVmaW5lciwgY29lcmNlciA9ICh2YWx1ZSkgPT4gdmFsdWUsIGVudHJpZXMgPSBmdW5jdGlvbiogKCkgeyB9LCB9ID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICAgICAgdGhpcy5jb2VyY2VyID0gY29lcmNlcjtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAoKSA9PiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZpbmVyID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgICAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgICAgICovXG4gICAgICAgIG1hc2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAgICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICAgICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICAgICAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgICAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgICAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgICAgIHJldHVybiAhcmVzdWx0WzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHJldHVybmluZyBhbiBlcnJvciBpZiBpbnZhbGlkLCBvciB0aGVcbiAgICAgKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgICAgICBpZiAodHVwbGVbMF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NpZ24oLi4uU3RydWN0cykge1xuICAgICAgICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdLnR5cGUgPT09ICd0eXBlJztcbiAgICAgICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICAgICAgICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7IHR5cGU6IG5hbWUsIHNjaGVtYTogbnVsbCwgdmFsaWRhdG9yIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gICAgICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZChzdHJ1Y3QsIGxvZykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2codmFsdWUsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gICAgICpcbiAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICAgICAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gICAgICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICAgICAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICAgICAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgICAgIGxldCBzdHJ1Y3Q7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gICAgICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQoc3RydWN0LCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgd2l0aCBhbGwgb2YgaXRzXG4gICAgICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogTGlrZSBUeXBlU2NyaXB0J3MgYFBhcnRpYWxgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RydWN0IGluc3RhbmNlb2YgU3RydWN0ID8geyAuLi5zdHJ1Y3Quc2NoZW1hIH0gOiB7IC4uLnN0cnVjdCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAgICAgKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhzdHJ1Y3QsIGtleXMpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICAgICAgICByZXR1cm4gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFueSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnYW55JywgKCkgPT4gdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaSwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJvb2xlYW4oKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBgRGF0ZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gICAgICogd2hpY2ggY2FuIG9jY3VyIHdoZW4gcGFyc2luZyBhIGRhdGUgZmFpbHMgYnV0IHN0aWxsIHJldHVybnMgYSBgRGF0ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSgnZGF0ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHt9O1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHYpID0+IHByaW50KHYpKS5qb2luKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2VudW1zJyxcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWVzLmluY2x1ZGVzKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdmdW5jJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIHNwZWNpZmljIGNsYXNzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2luc3RhbmNlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVnZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ2ludGVnZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBhbGwgb2YgYSBzZXQgb2YgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIFMucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KTtcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICAgICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlID09PSBjb25zdGFudCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fFxuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IG5vIHZhbHVlIGV2ZXIgcGFzc2VzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ25ldmVyJywgKCkgPT4gZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgICAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGEgc3RydWN0IHRvIGFsbG93IGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gICAgICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3JkKEtleSwgVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAgICAgKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVnZXhwKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFt2LCB2LCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYFNldFxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICAgICAqIGVsZW1lbnRzIGlzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0dXBsZShTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFN0cnVjdHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaSwgdmFsdWVbaV0sIFN0cnVjdHNbaV0gfHwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyBhcmUgYWxsb3dlZCBhbmQgdW50b3VjaGVkLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAgICAgKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHMpID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2Vycm9yLCBjb2VyY2VkXSA9IFMudmFsaWRhdGUodmFsdWUsIHsgY29lcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmtub3duKCkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICAgICAqXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAgICAgKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAgICAgKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICAgICAqXG4gICAgICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICAgICAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdWdtZW50IGEgc3RydWN0IHRvIHJlcGxhY2UgYHVuZGVmaW5lZGAgdmFsdWVzIHdpdGggYSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICAgICAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHVua25vd24oKSwgKHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoeCkgJiYgaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHsgLi4ueCB9O1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gICAgICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCAoeCkgPT4geC50cmltKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gICAgICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBlbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgICAgICA/IHZhbHVlIDwgdGhyZXNob2xkXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbGVzcyB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ30ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWluJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZSA+IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKHNpemUgPiAwIHx8IGBFeHBlY3RlZCBhIG5vbmVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocmVnZXhwLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCA9IG1pbikge1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YDtcbiAgICAgICAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IGBvZiBcXGAke21pbn1cXGBgIDogYGJldHdlZW4gXFxgJHttaW59XFxgIGFuZCBcXGAke21heH1cXGBgO1xuICAgICAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSAke29mfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBsZW5ndGggJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIFxcYCR7bGVuZ3RofVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAgICAgKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICAgICAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSwgcmVmaW5lbWVudDogbmFtZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydHMuU3RydWN0ID0gU3RydWN0O1xuICAgIGV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbiAgICBleHBvcnRzLmFueSA9IGFueTtcbiAgICBleHBvcnRzLmFycmF5ID0gYXJyYXk7XG4gICAgZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4gICAgZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG4gICAgZXhwb3J0cy5iaWdpbnQgPSBiaWdpbnQ7XG4gICAgZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbiAgICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbiAgICBleHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBleHBvcnRzLmRhdGUgPSBkYXRlO1xuICAgIGV4cG9ydHMuZGVmYXVsdGVkID0gZGVmYXVsdGVkO1xuICAgIGV4cG9ydHMuZGVmaW5lID0gZGVmaW5lO1xuICAgIGV4cG9ydHMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG4gICAgZXhwb3J0cy5keW5hbWljID0gZHluYW1pYztcbiAgICBleHBvcnRzLmVtcHR5ID0gZW1wdHk7XG4gICAgZXhwb3J0cy5lbnVtcyA9IGVudW1zO1xuICAgIGV4cG9ydHMuZnVuYyA9IGZ1bmM7XG4gICAgZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGV4cG9ydHMuaW50ZWdlciA9IGludGVnZXI7XG4gICAgZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgZXhwb3J0cy5pcyA9IGlzO1xuICAgIGV4cG9ydHMubGF6eSA9IGxhenk7XG4gICAgZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbDtcbiAgICBleHBvcnRzLm1hcCA9IG1hcDtcbiAgICBleHBvcnRzLm1hc2sgPSBtYXNrO1xuICAgIGV4cG9ydHMubWF4ID0gbWF4O1xuICAgIGV4cG9ydHMubWluID0gbWluO1xuICAgIGV4cG9ydHMubmV2ZXIgPSBuZXZlcjtcbiAgICBleHBvcnRzLm5vbmVtcHR5ID0gbm9uZW1wdHk7XG4gICAgZXhwb3J0cy5udWxsYWJsZSA9IG51bGxhYmxlO1xuICAgIGV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuICAgIGV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuICAgIGV4cG9ydHMub21pdCA9IG9taXQ7XG4gICAgZXhwb3J0cy5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIGV4cG9ydHMucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgZXhwb3J0cy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICBleHBvcnRzLnBpY2sgPSBwaWNrO1xuICAgIGV4cG9ydHMucmVjb3JkID0gcmVjb3JkO1xuICAgIGV4cG9ydHMucmVmaW5lID0gcmVmaW5lO1xuICAgIGV4cG9ydHMucmVnZXhwID0gcmVnZXhwO1xuICAgIGV4cG9ydHMuc2V0ID0gc2V0O1xuICAgIGV4cG9ydHMuc2l6ZSA9IHNpemU7XG4gICAgZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZXhwb3J0cy5zdHJ1Y3QgPSBzdHJ1Y3Q7XG4gICAgZXhwb3J0cy50cmltbWVkID0gdHJpbW1lZDtcbiAgICBleHBvcnRzLnR1cGxlID0gdHVwbGU7XG4gICAgZXhwb3J0cy50eXBlID0gdHlwZTtcbiAgICBleHBvcnRzLnVuaW9uID0gdW5pb247XG4gICAgZXhwb3J0cy51bmtub3duID0gdW5rbm93bjtcbiAgICBleHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fZXNEZWNvcmF0ZTtcclxudmFyIF9fcnVuSW5pdGlhbGl6ZXJzO1xyXG52YXIgX19wcm9wS2V5O1xyXG52YXIgX19zZXRGdW5jdGlvbk5hbWU7XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19zcHJlYWRBcnJheXM7XHJcbnZhciBfX3NwcmVhZEFycmF5O1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkSW47XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmc7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXNEZWNvcmF0ZSA9IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxyXG4gICAgICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XHJcbiAgICAgICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcclxuICAgICAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XHJcbiAgICAgICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy5wdXNoKF8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnB1c2goXyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3J1bkluaXRpYWxpemVycyA9IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcclxuICAgIH07XHJcblxyXG4gICAgX19wcm9wS2V5ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24gKGYsIG5hbWUsIHByZWZpeCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24obSwgbykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbiAgICB9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgb1trMl0gPSBtW2tdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXkgPSBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxuICAgIH0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4gPSBmdW5jdGlvbiAoc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19lc0RlY29yYXRlXCIsIF9fZXNEZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcnVuSW5pdGlhbGl6ZXJzXCIsIF9fcnVuSW5pdGlhbGl6ZXJzKTtcclxuICAgIGV4cG9ydGVyKFwiX19wcm9wS2V5XCIsIF9fcHJvcEtleSk7XHJcbiAgICBleHBvcnRlcihcIl9fc2V0RnVuY3Rpb25OYW1lXCIsIF9fc2V0RnVuY3Rpb25OYW1lKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG59KTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2My4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHJvb3QudmVyc2lvbiA9ICczLjAuMCc7XG5cdHJvb3QuZW5jb2RlID0gdXRmOGVuY29kZTtcblx0cm9vdC5kZWNvZGUgPSB1dGY4ZGVjb2RlO1xuXG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMudXRmOCA9IHt9IDogZXhwb3J0cykpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2MVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92Mi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92My5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY1XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92NC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5JTFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbmlsLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmVyc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0ZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3BhcnNlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YxLmpzXCIpKTtcblxudmFyIF92MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjMuanNcIikpO1xuXG52YXIgX3YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NC5qc1wiKSk7XG5cbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y1LmpzXCIpKTtcblxudmFyIF9uaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25pbC5qc1wiKSk7XG5cbnZhciBfdmVyc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKSk7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIGNvbnN0IGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICBjb25zdCB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICBjb25zdCBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIGxldCBhID0gMTczMjU4NDE5MztcbiAgbGV0IGIgPSAtMjcxNzMzODc5O1xuICBsZXQgYyA9IC0xNzMyNTg0MTk0O1xuICBsZXQgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgY29uc3Qgb2xkYSA9IGE7XG4gICAgY29uc3Qgb2xkYiA9IGI7XG4gICAgY29uc3Qgb2xkYyA9IGM7XG4gICAgY29uc3Qgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIGNvbnN0IGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgY29uc3QgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG1kNTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0ID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBfZGVmYXVsdCA9IHBhcnNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJuZztcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgY29uc3QgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgY29uc3QgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIGNvbnN0IE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgY29uc3QgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tpICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tpICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1baV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW2ldW3RdO1xuICAgIH1cblxuICAgIGZvciAobGV0IHQgPSAxNjsgdCA8IDgwOyArK3QpIHtcbiAgICAgIFdbdF0gPSBST1RMKFdbdCAtIDNdIF4gV1t0IC0gOF0gXiBXW3QgLSAxNF0gXiBXW3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIGxldCBhID0gSFswXTtcbiAgICBsZXQgYiA9IEhbMV07XG4gICAgbGV0IGMgPSBIWzJdO1xuICAgIGxldCBkID0gSFszXTtcbiAgICBsZXQgZSA9IEhbNF07XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDgwOyArK3QpIHtcbiAgICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKHQgLyAyMCk7XG4gICAgICBjb25zdCBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbdF0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxudmFyIF9kZWZhdWx0ID0gc2hhMTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIGNvbnN0IHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbnZhciBfZGVmYXVsdCA9IHN0cmluZ2lmeTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHYxO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjM1LmpzXCIpKTtcblxudmFyIF9tZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWQ1LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgdjMgPSAoMCwgX3YuZGVmYXVsdCkoJ3YzJywgMHgzMCwgX21kLmRlZmF1bHQpO1xudmFyIF9kZWZhdWx0ID0gdjM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLkROUyA9IEROUztcbmNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5VUkwgPSBVUkw7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gKDAsIF9wYXJzZS5kZWZhdWx0KShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShybmRzKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX3NoYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2hhMS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHY1ID0gKDAsIF92LmRlZmF1bHQpKCd2NScsIDB4NTAsIF9zaGEuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2NTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2V4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWdleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBfcmVnZXguZGVmYXVsdC50ZXN0KHV1aWQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2YWxpZGF0ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2ZXJzaW9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiKGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzX3VyaSA9IGlzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc19odHRwX3VyaSA9IGlzX2h0dHBfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzX2h0dHBzX3VyaSA9IGlzX2h0dHBzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc193ZWJfdXJpID0gaXNfd2ViX2lyaTtcbiAgICAvLyBDcmVhdGUgYWxpYXNlc1xuICAgIG1vZHVsZS5leHBvcnRzLmlzVXJpID0gaXNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzSHR0cFVyaSA9IGlzX2h0dHBfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzSHR0cHNVcmkgPSBpc19odHRwc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNXZWJVcmkgPSBpc193ZWJfaXJpO1xuXG5cbiAgICAvLyBwcml2YXRlIGZ1bmN0aW9uXG4gICAgLy8gaW50ZXJuYWwgVVJJIHNwaXR0ZXIgbWV0aG9kIC0gZGlyZWN0IGZyb20gUkZDIDM5ODZcbiAgICB2YXIgc3BsaXRVcmkgPSBmdW5jdGlvbih1cmkpIHtcbiAgICAgICAgdmFyIHNwbGl0dGVkID0gdXJpLm1hdGNoKC8oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oW15cXC8/I10qKSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/Lyk7XG4gICAgICAgIHJldHVybiBzcGxpdHRlZDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfaXJpKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKC9bXmEtejAtOVxcOlxcL1xcP1xcI1xcW1xcXVxcQFxcIVxcJFxcJlxcJ1xcKFxcKVxcKlxcK1xcLFxcO1xcPVxcLlxcLVxcX1xcflxcJV0vaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBoZXggZXNjYXBlcyB0aGF0IGFyZW4ndCBjb21wbGV0ZVxuICAgICAgICBpZiAoLyVbXjAtOWEtZl0vaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICBpZiAoLyVbMC05YS1mXSg6P1teMC05YS1mXXwkKS9pLnRlc3QodmFsdWUpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHNwbGl0dGVkID0gW107XG4gICAgICAgIHZhciBzY2hlbWUgPSAnJztcbiAgICAgICAgdmFyIGF1dGhvcml0eSA9ICcnO1xuICAgICAgICB2YXIgcGF0aCA9ICcnO1xuICAgICAgICB2YXIgcXVlcnkgPSAnJztcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgICAgIHZhciBvdXQgPSAnJztcblxuICAgICAgICAvLyBmcm9tIFJGQyAzOTg2XG4gICAgICAgIHNwbGl0dGVkID0gc3BsaXRVcmkodmFsdWUpO1xuICAgICAgICBzY2hlbWUgPSBzcGxpdHRlZFsxXTsgXG4gICAgICAgIGF1dGhvcml0eSA9IHNwbGl0dGVkWzJdO1xuICAgICAgICBwYXRoID0gc3BsaXR0ZWRbM107XG4gICAgICAgIHF1ZXJ5ID0gc3BsaXR0ZWRbNF07XG4gICAgICAgIGZyYWdtZW50ID0gc3BsaXR0ZWRbNV07XG5cbiAgICAgICAgLy8gc2NoZW1lIGFuZCBwYXRoIGFyZSByZXF1aXJlZCwgdGhvdWdoIHRoZSBwYXRoIGNhbiBiZSBlbXB0eVxuICAgICAgICBpZiAoIShzY2hlbWUgJiYgc2NoZW1lLmxlbmd0aCAmJiBwYXRoLmxlbmd0aCA+PSAwKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGlmIGF1dGhvcml0eSBpcyBwcmVzZW50LCB0aGUgcGF0aCBtdXN0IGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSAvXG4gICAgICAgIGlmIChhdXRob3JpdHkgJiYgYXV0aG9yaXR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aC5sZW5ndGggPT09IDAgfHwgL15cXC8vLnRlc3QocGF0aCkpKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBhdXRob3JpdHkgaXMgbm90IHByZXNlbnQsIHRoZSBwYXRoIG11c3Qgbm90IHN0YXJ0IHdpdGggLy9cbiAgICAgICAgICAgIGlmICgvXlxcL1xcLy8udGVzdChwYXRoKSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NoZW1lIG11c3QgYmVnaW4gd2l0aCBhIGxldHRlciwgdGhlbiBjb25zaXN0IG9mIGxldHRlcnMsIGRpZ2l0cywgKywgLiwgb3IgLVxuICAgICAgICBpZiAoIS9eW2Etel1bYS16MC05XFwrXFwtXFwuXSokLy50ZXN0KHNjaGVtZS50b0xvd2VyQ2FzZSgpKSkgIHJldHVybjtcblxuICAgICAgICAvLyByZS1hc3NlbWJsZSB0aGUgVVJMIHBlciBzZWN0aW9uIDUuMyBpbiBSRkMgMzk4NlxuICAgICAgICBvdXQgKz0gc2NoZW1lICsgJzonO1xuICAgICAgICBpZiAoYXV0aG9yaXR5ICYmIGF1dGhvcml0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnLy8nICsgYXV0aG9yaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IHBhdGg7XG5cbiAgICAgICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICc/JyArIHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19odHRwX2lyaSh2YWx1ZSwgYWxsb3dIdHRwcykge1xuICAgICAgICBpZiAoIWlzX2lyaSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1lID0gJyc7XG4gICAgICAgIHZhciBhdXRob3JpdHkgPSAnJztcbiAgICAgICAgdmFyIHBhdGggPSAnJztcbiAgICAgICAgdmFyIHBvcnQgPSAnJztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gJyc7XG4gICAgICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgICAgLy8gZnJvbSBSRkMgMzk4NlxuICAgICAgICBzcGxpdHRlZCA9IHNwbGl0VXJpKHZhbHVlKTtcbiAgICAgICAgc2NoZW1lID0gc3BsaXR0ZWRbMV07IFxuICAgICAgICBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgICAgICAgcGF0aCA9IHNwbGl0dGVkWzNdO1xuICAgICAgICBxdWVyeSA9IHNwbGl0dGVkWzRdO1xuICAgICAgICBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuXG4gICAgICAgIGlmICghc2NoZW1lKSAgcmV0dXJuO1xuXG4gICAgICAgIGlmKGFsbG93SHR0cHMpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWUudG9Mb3dlckNhc2UoKSAhPSAnaHR0cHMnKSByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2h0dHAnKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmdWxseS1xdWFsaWZpZWQgVVJJcyBtdXN0IGhhdmUgYW4gYXV0aG9yaXR5IHNlY3Rpb24gdGhhdCBpc1xuICAgICAgICAvLyBhIHZhbGlkIGhvc3RcbiAgICAgICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuYWJsZSBwb3J0IGNvbXBvbmVudFxuICAgICAgICBpZiAoLzooXFxkKykkLy50ZXN0KGF1dGhvcml0eSkpIHtcbiAgICAgICAgICAgIHBvcnQgPSBhdXRob3JpdHkubWF0Y2goLzooXFxkKykkLylbMF07XG4gICAgICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkucmVwbGFjZSgvOlxcZCskLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IHNjaGVtZSArICc6JztcbiAgICAgICAgb3V0ICs9ICcvLycgKyBhdXRob3JpdHk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9ydCkge1xuICAgICAgICAgICAgb3V0ICs9IHBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG91dCArPSBwYXRoO1xuICAgICAgICBcbiAgICAgICAgaWYocXVlcnkgJiYgcXVlcnkubGVuZ3RoKXtcbiAgICAgICAgICAgIG91dCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGZyYWdtZW50ICYmIGZyYWdtZW50Lmxlbmd0aCl7XG4gICAgICAgICAgICBvdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfaHR0cHNfaXJpKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc19odHRwX2lyaSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfd2ViX2lyaSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKGlzX2h0dHBfaXJpKHZhbHVlKSB8fCBpc19odHRwc19pcmkodmFsdWUpKTtcbiAgICB9XG5cbn0pKG1vZHVsZSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDBcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHZhcmludCcpXG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXVxuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCkgPDwgc2hpZnRcbiAgICAgIDogKGIgJiBSRVNUKSAqIE1hdGgucG93KDIsIHNoaWZ0KVxuICAgIHNoaWZ0ICs9IDdcbiAgfSB3aGlsZSAoYiA+PSBNU0IpXG5cbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXRcblxuICByZXR1cm4gcmVzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCJ2YXIgaW5kZXhPZiA9IGZ1bmN0aW9uICh4cywgaXRlbSkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZihpdGVtKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbnZhciBPYmplY3Rfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfJywge30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG52YXIgZ2xvYmFscyA9IFsnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdGdW5jdGlvbicsXG4nSW5maW5pdHknLCAnSlNPTicsICdNYXRoJywgJ05hTicsICdOdW1iZXInLCAnT2JqZWN0JywgJ1JhbmdlRXJyb3InLFxuJ1JlZmVyZW5jZUVycm9yJywgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJyxcbidkZWNvZGVVUkknLCAnZGVjb2RlVVJJQ29tcG9uZW50JywgJ2VuY29kZVVSSScsICdlbmNvZGVVUklDb21wb25lbnQnLCAnZXNjYXBlJyxcbidldmFsJywgJ2lzRmluaXRlJywgJ2lzTmFOJywgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAndW5kZWZpbmVkJywgJ3VuZXNjYXBlJ107XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuQ29udGV4dC5wcm90b3R5cGUgPSB7fTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibmVlZHMgYSAnY29udGV4dCcgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWYgKCFpZnJhbWUuc3R5bGUpIGlmcmFtZS5zdHlsZSA9IHt9O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICB2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgdmFyIHdFdmFsID0gd2luLmV2YWwsIHdFeGVjU2NyaXB0ID0gd2luLmV4ZWNTY3JpcHQ7XG5cbiAgICBpZiAoIXdFdmFsICYmIHdFeGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi4oMCxldmFsKSgpIG1hZ2ljYWxseSBhcHBlYXJzIHdoZW4gdGhpcyBpcyBjYWxsZWQgaW4gSUU6XG4gICAgICAgIHdFeGVjU2NyaXB0LmNhbGwod2luLCAnbnVsbCcpO1xuICAgICAgICB3RXZhbCA9IHdpbi5ldmFsO1xuICAgIH1cbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgIH0pO1xuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoY29udGV4dFtrZXldKSB7XG4gICAgICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHZhciB3aW5LZXlzID0gT2JqZWN0X2tleXMod2luKTtcblxuICAgIHZhciByZXMgPSB3RXZhbC5jYWxsKHdpbiwgdGhpcy5jb2RlKTtcbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKHdpbiksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gQXZvaWQgY29weWluZyBjaXJjdWxhciBvYmplY3RzIGxpa2UgYHRvcGAgYW5kIGB3aW5kb3dgIGJ5IG9ubHlcbiAgICAgICAgLy8gdXBkYXRpbmcgZXhpc3RpbmcgY29udGV4dCBwcm9wZXJ0aWVzIG9yIG5ldyBwcm9wZXJ0aWVzIGluIHRoZSBgd2luYFxuICAgICAgICAvLyB0aGF0IHdhcyBvbmx5IGludHJvZHVjZWQgYWZ0ZXIgdGhlIGV2YWwuXG4gICAgICAgIGlmIChrZXkgaW4gY29udGV4dCB8fCBpbmRleE9mKHdpbktleXMsIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSB3aW5ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcChjb250ZXh0LCBrZXksIHdpbltrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JblRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCxldmFsKSh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuaXNDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQ7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFwid2ViZXh0ZW5zaW9uLXBvbHlmaWxsXCIsIFtcIm1vZHVsZVwiXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KG1vZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZCk7XG4gICAgZ2xvYmFsLmJyb3dzZXIgPSBtb2QuZXhwb3J0cztcbiAgfVxufSkodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAvKiB3ZWJleHRlbnNpb24tcG9seWZpbGwgLSB2MC44LjAgLSBUdWUgQXByIDIwIDIwMjEgMTE6Mjc6MzggKi9cblxuICAvKiAtKi0gTW9kZTogaW5kZW50LXRhYnMtbW9kZTogbmlsOyBqcy1pbmRlbnQtbGV2ZWw6IDIgLSotICovXG5cbiAgLyogdmltOiBzZXQgc3RzPTIgc3c9MiBldCB0dz04MDogKi9cblxuICAvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gICAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAgICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBicm93c2VyID09PSBcInVuZGVmaW5lZFwiIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihicm93c2VyKSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIGNvbnN0IENIUk9NRV9TRU5EX01FU1NBR0VfQ0FMTEJBQ0tfTk9fUkVTUE9OU0VfTUVTU0FHRSA9IFwiVGhlIG1lc3NhZ2UgcG9ydCBjbG9zZWQgYmVmb3JlIGEgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkLlwiO1xuICAgIGNvbnN0IFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORyA9IFwiUmV0dXJuaW5nIGEgUHJvbWlzZSBpcyB0aGUgcHJlZmVycmVkIHdheSB0byBzZW5kIGEgcmVwbHkgZnJvbSBhbiBvbk1lc3NhZ2Uvb25NZXNzYWdlRXh0ZXJuYWwgbGlzdGVuZXIsIGFzIHRoZSBzZW5kUmVzcG9uc2Ugd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHNwZWNzIChTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9Nb3ppbGxhL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9vbk1lc3NhZ2UpXCI7IC8vIFdyYXBwaW5nIHRoZSBidWxrIG9mIHRoaXMgcG9seWZpbGwgaW4gYSBvbmUtdGltZS11c2UgZnVuY3Rpb24gaXMgYSBtaW5vclxuICAgIC8vIG9wdGltaXphdGlvbiBmb3IgRmlyZWZveC4gU2luY2UgU3BpZGVybW9ua2V5IGRvZXMgbm90IGZ1bGx5IHBhcnNlIHRoZVxuICAgIC8vIGNvbnRlbnRzIG9mIGEgZnVuY3Rpb24gdW50aWwgdGhlIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCBzaW5jZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYWN0dWFsbHkgbmVlZCB0byBiZSBjYWxsZWQsIHRoaXMgYWxsb3dzIHRoZSBwb2x5ZmlsbCB0byBiZSBpbmNsdWRlZFxuICAgIC8vIGluIEZpcmVmb3ggbmVhcmx5IGZvciBmcmVlLlxuXG4gICAgY29uc3Qgd3JhcEFQSXMgPSBleHRlbnNpb25BUElzID0+IHtcbiAgICAgIC8vIE5PVEU6IGFwaU1ldGFkYXRhIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRlbnQgb2YgdGhlIGFwaS1tZXRhZGF0YS5qc29uIGZpbGVcbiAgICAgIC8vIGF0IGJ1aWxkIHRpbWUgYnkgcmVwbGFjaW5nIHRoZSBmb2xsb3dpbmcgXCJpbmNsdWRlXCIgd2l0aCB0aGUgY29udGVudCBvZiB0aGVcbiAgICAgIC8vIEpTT04gZmlsZS5cbiAgICAgIGNvbnN0IGFwaU1ldGFkYXRhID0ge1xuICAgICAgICBcImFsYXJtc1wiOiB7XG4gICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNsZWFyQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYm9va21hcmtzXCI6IHtcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldENoaWxkcmVuXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UmVjZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0U3ViVHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlVHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJyb3dzZXJBY3Rpb25cIjoge1xuICAgICAgICAgIFwiZGlzYWJsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVuYWJsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEJhZGdlQmFja2dyb3VuZENvbG9yXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QmFkZ2VUZXh0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5Qb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEJhZGdlQmFja2dyb3VuZENvbG9yXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0QmFkZ2VUZXh0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0SWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJicm93c2luZ0RhdGFcIjoge1xuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ2FjaGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDb29raWVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRG93bmxvYWRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRm9ybURhdGFcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVIaXN0b3J5XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlTG9jYWxTdG9yYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlUGFzc3dvcmRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlUGx1Z2luRGF0YVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldHRpbmdzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29tbWFuZHNcIjoge1xuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29udGV4dE1lbnVzXCI6IHtcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvb2tpZXNcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsQ29va2llU3RvcmVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGV2dG9vbHNcIjoge1xuICAgICAgICAgIFwiaW5zcGVjdGVkV2luZG93XCI6IHtcbiAgICAgICAgICAgIFwiZXZhbFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMixcbiAgICAgICAgICAgICAgXCJzaW5nbGVDYWxsYmFja0FyZ1wiOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwYW5lbHNcIjoge1xuICAgICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMyxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDMsXG4gICAgICAgICAgICAgIFwic2luZ2xlQ2FsbGJhY2tBcmdcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1xuICAgICAgICAgICAgICBcImNyZWF0ZVNpZGViYXJQYW5lXCI6IHtcbiAgICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRvd25sb2Fkc1wiOiB7XG4gICAgICAgICAgXCJjYW5jZWxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkb3dubG9hZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVyYXNlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0RmlsZUljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicGF1c2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVGaWxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVzdW1lXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2hvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImV4dGVuc2lvblwiOiB7XG4gICAgICAgICAgXCJpc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaXNBbGxvd2VkSW5jb2duaXRvQWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaGlzdG9yeVwiOiB7XG4gICAgICAgICAgXCJhZGRVcmxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVSYW5nZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZVVybFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFZpc2l0c1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImkxOG5cIjoge1xuICAgICAgICAgIFwiZGV0ZWN0TGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBY2NlcHRMYW5ndWFnZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpZGVudGl0eVwiOiB7XG4gICAgICAgICAgXCJsYXVuY2hXZWJBdXRoRmxvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImlkbGVcIjoge1xuICAgICAgICAgIFwicXVlcnlTdGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1hbmFnZW1lbnRcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0U2VsZlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1bmluc3RhbGxTZWxmXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBlcm1pc3Npb25MZXZlbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBhZ2VBY3Rpb25cIjoge1xuICAgICAgICAgIFwiZ2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpZGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwZXJtaXNzaW9uc1wiOiB7XG4gICAgICAgICAgXCJjb250YWluc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVlc3RcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJydW50aW1lXCI6IHtcbiAgICAgICAgICBcImdldEJhY2tncm91bmRQYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UGxhdGZvcm1JbmZvXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3Blbk9wdGlvbnNQYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVxdWVzdFVwZGF0ZUNoZWNrXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogM1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTmF0aXZlTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFVuaW5zdGFsbFVSTFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNlc3Npb25zXCI6IHtcbiAgICAgICAgICBcImdldERldmljZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRSZWNlbnRseUNsb3NlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzdG9yYWdlXCI6IHtcbiAgICAgICAgICBcImxvY2FsXCI6IHtcbiAgICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibWFuYWdlZFwiOiB7XG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzeW5jXCI6IHtcbiAgICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0Qnl0ZXNJblVzZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidGFic1wiOiB7XG4gICAgICAgICAgXCJjYXB0dXJlVmlzaWJsZVRhYlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRldGVjdExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGlzY2FyZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImR1cGxpY2F0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImV4ZWN1dGVTY3JpcHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDdXJyZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Wm9vbVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFpvb21TZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdvQmFja1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdvRm9yd2FyZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpZ2hsaWdodFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImluc2VydENTU1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJxdWVyeVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbG9hZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNTU1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmRNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0Wm9vbVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFpvb21TZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRvcFNpdGVzXCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIndlYk5hdmlnYXRpb25cIjoge1xuICAgICAgICAgIFwiZ2V0QWxsRnJhbWVzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0RnJhbWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3ZWJSZXF1ZXN0XCI6IHtcbiAgICAgICAgICBcImhhbmRsZXJCZWhhdmlvckNoYW5nZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3aW5kb3dzXCI6IHtcbiAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEN1cnJlbnRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRMYXN0Rm9jdXNlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXMoYXBpTWV0YWRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcGktbWV0YWRhdGEuanNvbiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgaW4gYnJvd3Nlci1wb2x5ZmlsbFwiKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQSBXZWFrTWFwIHN1YmNsYXNzIHdoaWNoIGNyZWF0ZXMgYW5kIHN0b3JlcyBhIHZhbHVlIGZvciBhbnkga2V5IHdoaWNoIGRvZXNcbiAgICAgICAqIG5vdCBleGlzdCB3aGVuIGFjY2Vzc2VkLCBidXQgYmVoYXZlcyBleGFjdGx5IGFzIGFuIG9yZGluYXJ5IFdlYWtNYXBcbiAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjcmVhdGVJdGVtXG4gICAgICAgKiAgICAgICAgQSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBpbiBvcmRlciB0byBjcmVhdGUgdGhlIHZhbHVlIGZvciBhbnlcbiAgICAgICAqICAgICAgICBrZXkgd2hpY2ggZG9lcyBub3QgZXhpc3QsIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGFjY2Vzc2VkLiBUaGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiByZWNlaXZlcywgYXMgaXRzIG9ubHkgYXJndW1lbnQsIHRoZSBrZXkgYmVpbmcgY3JlYXRlZC5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNsYXNzIERlZmF1bHRXZWFrTWFwIGV4dGVuZHMgV2Vha01hcCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNyZWF0ZUl0ZW0sIGl0ZW1zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3VwZXIoaXRlbXMpO1xuICAgICAgICAgIHRoaXMuY3JlYXRlSXRlbSA9IGNyZWF0ZUl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHRoaXMuY3JlYXRlSXRlbShrZXkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBvYmplY3Qgd2l0aCBhIGB0aGVuYCBtZXRob2QsIGFuZCBjYW5cbiAgICAgICAqIHRoZXJlZm9yZSBiZSBhc3N1bWVkIHRvIGJlaGF2ZSBhcyBhIFByb21pc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGVuYWJsZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IGlzVGhlbmFibGUgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBjYWxsZWQsIHdpbGwgcmVzb2x2ZSBvciByZWplY3RcbiAgICAgICAqIHRoZSBnaXZlbiBwcm9taXNlIGJhc2VkIG9uIGhvdyBpdCBpcyBjYWxsZWQ6XG4gICAgICAgKlxuICAgICAgICogLSBJZiwgd2hlbiBjYWxsZWQsIGBjaHJvbWUucnVudGltZS5sYXN0RXJyb3JgIGNvbnRhaW5zIGEgbm9uLW51bGwgb2JqZWN0LFxuICAgICAgICogICB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoYXQgdmFsdWUuXG4gICAgICAgKiAtIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBleGFjdGx5IG9uZSBhcmd1bWVudCwgdGhlIHByb21pc2UgaXNcbiAgICAgICAqICAgcmVzb2x2ZWQgdG8gdGhhdCB2YWx1ZS5cbiAgICAgICAqIC0gT3RoZXJ3aXNlLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCB0byBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGVcbiAgICAgICAqICAgZnVuY3Rpb24ncyBhcmd1bWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb21pc2VcbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzb2x1dGlvbiBhbmQgcmVqZWN0aW9uIGZ1bmN0aW9ucyBvZiBhXG4gICAgICAgKiAgICAgICAgcHJvbWlzZS5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb21pc2UucmVzb2x2ZVxuICAgICAgICogICAgICAgIFRoZSBwcm9taXNlJ3MgcmVzb2x1dGlvbiBmdW5jdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb21pc2UucmVqZWN0XG4gICAgICAgKiAgICAgICAgVGhlIHByb21pc2UncyByZWplY3Rpb24gZnVuY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGFcbiAgICAgICAqICAgICAgICBNZXRhZGF0YSBhYm91dCB0aGUgd3JhcHBlZCBtZXRob2Qgd2hpY2ggaGFzIGNyZWF0ZWQgdGhlIGNhbGxiYWNrLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZ1xuICAgICAgICogICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggb25seSB0aGUgZmlyc3RcbiAgICAgICAqICAgICAgICBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2ssIGFsdGVybmF0aXZlbHkgYW4gYXJyYXkgb2YgYWxsIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGFyZ3VtZW50cyBpcyByZXNvbHZlZC4gQnkgZGVmYXVsdCwgaWYgdGhlIGNhbGxiYWNrXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIG9ubHkgYSBzaW5nbGUgYXJndW1lbnQsIHRoYXQgd2lsbCBiZVxuICAgICAgICogICAgICAgIHJlc29sdmVkIHRvIHRoZSBwcm9taXNlLCB3aGlsZSBhbGwgYXJndW1lbnRzIHdpbGwgYmUgcmVzb2x2ZWQgYXNcbiAgICAgICAqICAgICAgICBhbiBhcnJheSBpZiBtdWx0aXBsZSBhcmUgZ2l2ZW4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9ufVxuICAgICAgICogICAgICAgIFRoZSBnZW5lcmF0ZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBtYWtlQ2FsbGJhY2sgPSAocHJvbWlzZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuICguLi5jYWxsYmFja0FyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmcgfHwgY2FsbGJhY2tBcmdzLmxlbmd0aCA8PSAxICYmIG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrQXJnc1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBsdXJhbGl6ZUFyZ3VtZW50cyA9IG51bUFyZ3MgPT4gbnVtQXJncyA9PSAxID8gXCJhcmd1bWVudFwiIDogXCJhcmd1bWVudHNcIjtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB3aGljaCBpcyBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5taW5BcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbi4gSWYgY2FsbGVkIHdpdGggZmV3ZXIgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heEFyZ3NcbiAgICAgICAqICAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHdoaWNoIG1heSBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnXG4gICAgICAgKiAgICAgICAgV2hldGhlciBvciBub3QgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBvbmx5IHRoZSBmaXJzdFxuICAgICAgICogICAgICAgIGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjaywgYWx0ZXJuYXRpdmVseSBhbiBhcnJheSBvZiBhbGwgdGhlXG4gICAgICAgKiAgICAgICAgY2FsbGJhY2sgYXJndW1lbnRzIGlzIHJlc29sdmVkLiBCeSBkZWZhdWx0LCBpZiB0aGUgY2FsbGJhY2tcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggb25seSBhIHNpbmdsZSBhcmd1bWVudCwgdGhhdCB3aWxsIGJlXG4gICAgICAgKiAgICAgICAgcmVzb2x2ZWQgdG8gdGhlIHByb21pc2UsIHdoaWxlIGFsbCBhcmd1bWVudHMgd2lsbCBiZSByZXNvbHZlZCBhc1xuICAgICAgICogICAgICAgIGFuIGFycmF5IGlmIG11bHRpcGxlIGFyZSBnaXZlbi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24ob2JqZWN0LCAuLi4qKX1cbiAgICAgICAqICAgICAgIFRoZSBnZW5lcmF0ZWQgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBBc3luY0Z1bmN0aW9uID0gKG5hbWUsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhc3luY0Z1bmN0aW9uV3JhcHBlcih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBtZXRhZGF0YS5taW5BcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0ICR7bWV0YWRhdGEubWluQXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWluQXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1ldGFkYXRhLm1heEFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbW9zdCAke21ldGFkYXRhLm1heEFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1heEFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmZhbGxiYWNrVG9Ob0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgQVBJIG1ldGhvZCBoYXMgY3VycmVudGx5IG5vIGNhbGxiYWNrIG9uIENocm9tZSwgYnV0IGl0IHJldHVybiBhIHByb21pc2Ugb24gRmlyZWZveCxcbiAgICAgICAgICAgICAgLy8gYW5kIHNvIHRoZSBwb2x5ZmlsbCB3aWxsIHRyeSB0byBjYWxsIGl0IHdpdGggYSBjYWxsYmFjayBmaXJzdCwgYW5kIGl0IHdpbGwgZmFsbGJhY2tcbiAgICAgICAgICAgICAgLy8gdG8gbm90IHBhc3NpbmcgdGhlIGNhbGxiYWNrIGlmIHRoZSBmaXJzdCBjYWxsIGZhaWxzLlxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzLCBtYWtlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgIH0sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGNiRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gQVBJIG1ldGhvZCBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyLCBgICsgXCJmYWxsaW5nIGJhY2sgdG8gY2FsbCBpdCB3aXRob3V0IGEgY2FsbGJhY2s6IFwiLCBjYkVycm9yKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncyk7IC8vIFVwZGF0ZSB0aGUgQVBJIG1ldGhvZCBtZXRhZGF0YSwgc28gdGhhdCB0aGUgbmV4dCBBUEkgY2FsbHMgd2lsbCBub3QgdHJ5IHRvXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSB1bnN1cHBvcnRlZCBjYWxsYmFjayBhbnltb3JlLlxuXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuZmFsbGJhY2tUb05vQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5ub0NhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEubm9DYWxsYmFjaykge1xuICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncyk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzLCBtYWtlQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgIH0sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBhbiBleGlzdGluZyBtZXRob2Qgb2YgdGhlIHRhcmdldCBvYmplY3QsIHNvIHRoYXQgY2FsbHMgdG8gaXQgYXJlXG4gICAgICAgKiBpbnRlcmNlcHRlZCBieSB0aGUgZ2l2ZW4gd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgZnVuY3Rpb24gcmVjZWl2ZXMsXG4gICAgICAgKiBhcyBpdHMgZmlyc3QgYXJndW1lbnQsIHRoZSBvcmlnaW5hbCBgdGFyZ2V0YCBvYmplY3QsIGZvbGxvd2VkIGJ5IGVhY2ggb2ZcbiAgICAgICAqIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICAgICAgICogICAgICAgIFRoZSBvcmlnaW5hbCB0YXJnZXQgb2JqZWN0IHRoYXQgdGhlIHdyYXBwZWQgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2RcbiAgICAgICAqICAgICAgICBUaGUgbWV0aG9kIGJlaW5nIHdyYXBwZWQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBQcm94eVxuICAgICAgICogICAgICAgIG9iamVjdCB3aGljaCBpcyBjcmVhdGVkIHRvIHdyYXAgdGhlIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHdyYXBwZXJcbiAgICAgICAqICAgICAgICBUaGUgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgaW4gcGxhY2Ugb2YgYSBkaXJlY3QgaW52b2NhdGlvblxuICAgICAgICogICAgICAgIG9mIHRoZSB3cmFwcGVkIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7UHJveHk8ZnVuY3Rpb24+fVxuICAgICAgICogICAgICAgIEEgUHJveHkgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLCB3aGljaCBpbnZva2VzIHRoZSBnaXZlbiB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgbWV0aG9kIGluIGl0cyBwbGFjZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBNZXRob2QgPSAodGFyZ2V0LCBtZXRob2QsIHdyYXBwZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShtZXRob2QsIHtcbiAgICAgICAgICBhcHBseSh0YXJnZXRNZXRob2QsIHRoaXNPYmosIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLmNhbGwodGhpc09iaiwgdGFyZ2V0LCAuLi5hcmdzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgaGFzT3duUHJvcGVydHkgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIGFuIG9iamVjdCBpbiBhIFByb3h5IHdoaWNoIGludGVyY2VwdHMgYW5kIHdyYXBzIGNlcnRhaW4gbWV0aG9kc1xuICAgICAgICogYmFzZWQgb24gdGhlIGdpdmVuIGB3cmFwcGVyc2AgYW5kIGBtZXRhZGF0YWAgb2JqZWN0cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gICAgICAgKiAgICAgICAgVGhlIHRhcmdldCBvYmplY3QgdG8gd3JhcC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW3dyYXBwZXJzID0ge31dXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IHRyZWUgY29udGFpbmluZyB3cmFwcGVyIGZ1bmN0aW9ucyBmb3Igc3BlY2lhbCBjYXNlcy4gQW55XG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gcHJlc2VudCBpbiB0aGlzIG9iamVjdCB0cmVlIGlzIGNhbGxlZCBpbiBwbGFjZSBvZiB0aGVcbiAgICAgICAqICAgICAgICBtZXRob2QgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIGB0YXJnZXRgIG9iamVjdCB0cmVlLiBUaGVzZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgbWV0aG9kcyBhcmUgaW52b2tlZCBhcyBkZXNjcmliZWQgaW4ge0BzZWUgd3JhcE1ldGhvZH0uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFttZXRhZGF0YSA9IHt9XVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCB0cmVlIGNvbnRhaW5pbmcgbWV0YWRhdGEgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlXG4gICAgICAgKiAgICAgICAgUHJvbWlzZS1iYXNlZCB3cmFwcGVyIGZ1bmN0aW9ucyBmb3IgYXN5bmNocm9ub3VzLiBBbnkgZnVuY3Rpb24gaW5cbiAgICAgICAqICAgICAgICB0aGUgYHRhcmdldGAgb2JqZWN0IHRyZWUgd2hpY2ggaGFzIGEgY29ycmVzcG9uZGluZyBtZXRhZGF0YSBvYmplY3RcbiAgICAgICAqICAgICAgICBpbiB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgYG1ldGFkYXRhYCB0cmVlIGlzIHJlcGxhY2VkIHdpdGggYW5cbiAgICAgICAqICAgICAgICBhdXRvbWF0aWNhbGx5LWdlbmVyYXRlZCB3cmFwcGVyIGZ1bmN0aW9uLCBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAqICAgICAgICB7QHNlZSB3cmFwQXN5bmNGdW5jdGlvbn1cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7UHJveHk8b2JqZWN0Pn1cbiAgICAgICAqL1xuXG4gICAgICBjb25zdCB3cmFwT2JqZWN0ID0gKHRhcmdldCwgd3JhcHBlcnMgPSB7fSwgbWV0YWRhdGEgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgaGFzKHByb3h5VGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQgfHwgcHJvcCBpbiBjYWNoZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0KHByb3h5VGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3Byb3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1ldGhvZCBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuIENoZWNrIGlmIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgICAgLy8gYW55IHdyYXBwaW5nLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdyYXBwZXJzW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc3BlY2lhbC1jYXNlIHdyYXBwZXIgZm9yIHRoaXMgbWV0aG9kLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcE1ldGhvZCh0YXJnZXQsIHRhcmdldFtwcm9wXSwgd3JhcHBlcnNbcHJvcF0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgbWV0aG9kIHRoYXQgd2UgaGF2ZSBtZXRhZGF0YSBmb3IuIENyZWF0ZSBhXG4gICAgICAgICAgICAgICAgLy8gUHJvbWlzZSB3cmFwcGVyIGZvciBpdC5cbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlciA9IHdyYXBBc3luY0Z1bmN0aW9uKHByb3AsIG1ldGFkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBNZXRob2QodGFyZ2V0LCB0YXJnZXRbcHJvcF0sIHdyYXBwZXIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2QgdGhhdCB3ZSBkb24ndCBrbm93IG9yIGNhcmUgYWJvdXQuIFJldHVybiB0aGVcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBtZXRob2QsIGJvdW5kIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgKGhhc093blByb3BlcnR5KHdyYXBwZXJzLCBwcm9wKSB8fCBoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgcHJvcCkpKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb2JqZWN0IHRoYXQgd2UgbmVlZCB0byBkbyBzb21lIHdyYXBwaW5nIGZvciB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgLy8gb2YuIENyZWF0ZSBhIHN1Yi1vYmplY3Qgd3JhcHBlciBmb3IgaXQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY2hpbGRcbiAgICAgICAgICAgICAgLy8gbWV0YWRhdGEuXG4gICAgICAgICAgICAgIHZhbHVlID0gd3JhcE9iamVjdCh2YWx1ZSwgd3JhcHBlcnNbcHJvcF0sIG1ldGFkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIFwiKlwiKSkge1xuICAgICAgICAgICAgICAvLyBXcmFwIGFsbCBwcm9wZXJ0aWVzIGluICogbmFtZXNwYWNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBPYmplY3QodmFsdWUsIHdyYXBwZXJzW3Byb3BdLCBtZXRhZGF0YVtcIipcIl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgd3JhcHBpbmcgZm9yIHRoaXMgcHJvcGVydHksXG4gICAgICAgICAgICAgIC8vIHNvIGp1c3QgZm9yd2FyZCBhbGwgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhY2hlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzZXQocHJveHlUYXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkocHJveHlUYXJnZXQsIHByb3AsIGRlc2MpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGNhY2hlLCBwcm9wLCBkZXNjKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVsZXRlUHJvcGVydHkocHJveHlUYXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KGNhY2hlLCBwcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTsgLy8gUGVyIGNvbnRyYWN0IG9mIHRoZSBQcm94eSBBUEksIHRoZSBcImdldFwiIHByb3h5IGhhbmRsZXIgbXVzdCByZXR1cm4gdGhlXG4gICAgICAgIC8vIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSB0YXJnZXQgaWYgdGhhdCB2YWx1ZSBpcyBkZWNsYXJlZCByZWFkLW9ubHkgYW5kXG4gICAgICAgIC8vIG5vbi1jb25maWd1cmFibGUuIEZvciB0aGlzIHJlYXNvbiwgd2UgY3JlYXRlIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAgICAvLyBwcm90b3R5cGUgc2V0IHRvIGB0YXJnZXRgIGluc3RlYWQgb2YgdXNpbmcgYHRhcmdldGAgZGlyZWN0bHkuXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW5ub3QgcmV0dXJuIGEgY3VzdG9tIG9iamVjdCBmb3IgQVBJcyB0aGF0XG4gICAgICAgIC8vIGFyZSBkZWNsYXJlZCByZWFkLW9ubHkgYW5kIG5vbi1jb25maWd1cmFibGUsIHN1Y2ggYXMgYGNocm9tZS5kZXZ0b29sc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBwcm94eSBoYW5kbGVycyB0aGVtc2VsdmVzIHdpbGwgc3RpbGwgdXNlIHRoZSBvcmlnaW5hbCBgdGFyZ2V0YFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBgcHJveHlUYXJnZXRgLCBzbyB0aGF0IHRoZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAgICAvLyBkZXJlZmVyZW5jZWQgdmlhIHRoZSBvcmlnaW5hbCB0YXJnZXRzLlxuXG4gICAgICAgIGxldCBwcm94eVRhcmdldCA9IE9iamVjdC5jcmVhdGUodGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShwcm94eVRhcmdldCwgaGFuZGxlcnMpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHNldCBvZiB3cmFwcGVyIGZ1bmN0aW9ucyBmb3IgYW4gZXZlbnQgb2JqZWN0LCB3aGljaCBoYW5kbGVzXG4gICAgICAgKiB3cmFwcGluZyBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB0aG9zZSBtZXNzYWdlcyBhcmUgcGFzc2VkLlxuICAgICAgICpcbiAgICAgICAqIEEgc2luZ2xlIHdyYXBwZXIgaXMgY3JlYXRlZCBmb3IgZWFjaCBsaXN0ZW5lciBmdW5jdGlvbiwgYW5kIHN0b3JlZCBpbiBhXG4gICAgICAgKiBtYXAuIFN1YnNlcXVlbnQgY2FsbHMgdG8gYGFkZExpc3RlbmVyYCwgYGhhc0xpc3RlbmVyYCwgb3IgYHJlbW92ZUxpc3RlbmVyYFxuICAgICAgICogcmV0cmlldmUgdGhlIG9yaWdpbmFsIHdyYXBwZXIsIHNvIHRoYXQgIGF0dGVtcHRzIHRvIHJlbW92ZSBhXG4gICAgICAgKiBwcmV2aW91c2x5LWFkZGVkIGxpc3RlbmVyIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtEZWZhdWx0V2Vha01hcDxmdW5jdGlvbiwgZnVuY3Rpb24+fSB3cmFwcGVyTWFwXG4gICAgICAgKiAgICAgICAgQSBEZWZhdWx0V2Vha01hcCBvYmplY3Qgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHdyYXBwZXJcbiAgICAgICAqICAgICAgICBmb3IgYSBnaXZlbiBsaXN0ZW5lciBmdW5jdGlvbiB3aGVuIG9uZSBkb2VzIG5vdCBleGlzdCwgYW5kIHJldHJpZXZlXG4gICAgICAgKiAgICAgICAgYW4gZXhpc3Rpbmcgb25lIHdoZW4gaXQgZG9lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICovXG5cblxuICAgICAgY29uc3Qgd3JhcEV2ZW50ID0gd3JhcHBlck1hcCA9PiAoe1xuICAgICAgICBhZGRMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyLCAuLi5hcmdzKSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZExpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSwgLi4uYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQuaGFzTGlzdGVuZXIod3JhcHBlck1hcC5nZXQobGlzdGVuZXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSk7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG9uUmVxdWVzdEZpbmlzaGVkV3JhcHBlcnMgPSBuZXcgRGVmYXVsdFdlYWtNYXAobGlzdGVuZXIgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXBzIGFuIG9uUmVxdWVzdEZpbmlzaGVkIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgd2lsbCByZXR1cm4gYVxuICAgICAgICAgKiBgZ2V0Q29udGVudCgpYCBwcm9wZXJ0eSB3aGljaCByZXR1cm5zIGEgYFByb21pc2VgIHJhdGhlciB0aGFuIHVzaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2sgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVxXG4gICAgICAgICAqICAgICAgICBUaGUgSEFSIGVudHJ5IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5ldHdvcmsgcmVxdWVzdC5cbiAgICAgICAgICovXG5cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gb25SZXF1ZXN0RmluaXNoZWQocmVxKSB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZFJlcSA9IHdyYXBPYmplY3QocmVxLCB7fVxuICAgICAgICAgIC8qIHdyYXBwZXJzICovXG4gICAgICAgICAgLCB7XG4gICAgICAgICAgICBnZXRDb250ZW50OiB7XG4gICAgICAgICAgICAgIG1pbkFyZ3M6IDAsXG4gICAgICAgICAgICAgIG1heEFyZ3M6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0ZW5lcih3cmFwcGVkUmVxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pOyAvLyBLZWVwIHRyYWNrIGlmIHRoZSBkZXByZWNhdGlvbiB3YXJuaW5nIGhhcyBiZWVuIGxvZ2dlZCBhdCBsZWFzdCBvbmNlLlxuXG4gICAgICBsZXQgbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBvbk1lc3NhZ2VXcmFwcGVycyA9IG5ldyBEZWZhdWx0V2Vha01hcChsaXN0ZW5lciA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHMgYSBtZXNzYWdlIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgbWF5IHNlbmQgcmVzcG9uc2VzIGJhc2VkIG9uXG4gICAgICAgICAqIGl0cyByZXR1cm4gdmFsdWUsIHJhdGhlciB0aGFuIGJ5IHJldHVybmluZyBhIHNlbnRpbmVsIHZhbHVlIGFuZCBjYWxsaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2suIElmIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZSwgdGhlIHJlc3BvbnNlIGlzXG4gICAgICAgICAqIHNlbnQgd2hlbiB0aGUgcHJvbWlzZSBlaXRoZXIgcmVzb2x2ZXMgb3IgcmVqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAgICAgICAqICAgICAgICBUaGUgbWVzc2FnZSBzZW50IGJ5IHRoZSBvdGhlciBlbmQgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZW5kZXJcbiAgICAgICAgICogICAgICAgIERldGFpbHMgYWJvdXQgdGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gc2VuZFJlc3BvbnNlXG4gICAgICAgICAqICAgICAgICBBIGNhbGxiYWNrIHdoaWNoLCB3aGVuIGNhbGxlZCB3aXRoIGFuIGFyYml0cmFyeSBhcmd1bWVudCwgc2VuZHNcbiAgICAgICAgICogICAgICAgIHRoYXQgdmFsdWUgYXMgYSByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqICAgICAgICBUcnVlIGlmIHRoZSB3cmFwcGVkIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBsYXRlclxuICAgICAgICAgKiAgICAgICAgeWllbGQgYSByZXNwb25zZS4gRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBvbk1lc3NhZ2UobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICBsZXQgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCB3cmFwcGVkU2VuZFJlc3BvbnNlO1xuICAgICAgICAgIGxldCBzZW5kUmVzcG9uc2VQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkU2VuZFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICghbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaWRDYWxsU2VuZFJlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIobWVzc2FnZSwgc2VuZGVyLCB3cmFwcGVkU2VuZFJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNSZXN1bHRUaGVuYWJsZSA9IHJlc3VsdCAhPT0gdHJ1ZSAmJiBpc1RoZW5hYmxlKHJlc3VsdCk7IC8vIElmIHRoZSBsaXN0ZW5lciBkaWRuJ3QgcmV0dXJuZWQgdHJ1ZSBvciBhIFByb21pc2UsIG9yIGNhbGxlZFxuICAgICAgICAgIC8vIHdyYXBwZWRTZW5kUmVzcG9uc2Ugc3luY2hyb25vdXNseSwgd2UgY2FuIGV4aXQgZWFybGllclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBubyByZXNwb25zZSBzZW50IGZyb20gdGhpcyBsaXN0ZW5lci5cblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUgJiYgIWlzUmVzdWx0VGhlbmFibGUgJiYgIWRpZENhbGxTZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIEEgc21hbGwgaGVscGVyIHRvIHNlbmQgdGhlIG1lc3NhZ2UgaWYgdGhlIHByb21pc2UgcmVzb2x2ZXNcbiAgICAgICAgICAvLyBhbmQgYW4gZXJyb3IgaWYgdGhlIHByb21pc2UgcmVqZWN0cyAoYSB3cmFwcGVkIHNlbmRNZXNzYWdlIGhhc1xuICAgICAgICAgIC8vIHRvIHRyYW5zbGF0ZSB0aGUgbWVzc2FnZSBpbnRvIGEgcmVzb2x2ZWQgcHJvbWlzZSBvciBhIHJlamVjdGVkXG4gICAgICAgICAgLy8gcHJvbWlzZSkuXG5cblxuICAgICAgICAgIGNvbnN0IHNlbmRQcm9taXNlZFJlc3VsdCA9IHByb21pc2UgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKG1zZyA9PiB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1lc3NhZ2UgdmFsdWUuXG4gICAgICAgICAgICAgIHNlbmRSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAvLyBTZW5kIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaWYgdGhlIHJlamVjdGVkIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGlzIGFuIGluc3RhbmNlIG9mIGVycm9yLCBvciB0aGUgb2JqZWN0IGl0c2VsZiBvdGhlcndpc2UuXG4gICAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuXG4gICAgICAgICAgICAgIGlmIChlcnJvciAmJiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIF9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgLy8gUHJpbnQgYW4gZXJyb3Igb24gdGhlIGNvbnNvbGUgaWYgdW5hYmxlIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgb25NZXNzYWdlIHJlamVjdGVkIHJlcGx5XCIsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJuZWQgYSBQcm9taXNlLCBzZW5kIHRoZSByZXNvbHZlZCB2YWx1ZSBhcyBhXG4gICAgICAgICAgLy8gcmVzdWx0LCBvdGhlcndpc2Ugd2FpdCB0aGUgcHJvbWlzZSByZWxhdGVkIHRvIHRoZSB3cmFwcGVkU2VuZFJlc3BvbnNlXG4gICAgICAgICAgLy8gY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbmQgc2VuZCBpdCBhcyBhIHJlc3BvbnNlLlxuXG5cbiAgICAgICAgICBpZiAoaXNSZXN1bHRUaGVuYWJsZSkge1xuICAgICAgICAgICAgc2VuZFByb21pc2VkUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChzZW5kUmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICB9IC8vIExldCBDaHJvbWUga25vdyB0aGF0IHRoZSBsaXN0ZW5lciBpcyByZXBseWluZy5cblxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2sgPSAoe1xuICAgICAgICByZWplY3QsXG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0sIHJlcGx5KSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IHdoZW4gbm9uZSBvZiB0aGUgbGlzdGVuZXJzIHJlcGxpZWQgdG8gdGhlIHNlbmRNZXNzYWdlIGNhbGwgYW5kIHJlc29sdmVcbiAgICAgICAgICAvLyB0aGUgcHJvbWlzZSB0byB1bmRlZmluZWQgYXMgaW4gRmlyZWZveC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2lzc3Vlcy8xMzBcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlID09PSBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVwbHkgJiYgcmVwbHkuX19tb3pXZWJFeHRlbnNpb25Qb2x5ZmlsbFJlamVjdF9fKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBiYWNrIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvciBpbnRvXG4gICAgICAgICAgLy8gYW4gRXJyb3IgaW5zdGFuY2UuXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXBseS5tZXNzYWdlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXBseSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRTZW5kTWVzc2FnZSA9IChuYW1lLCBtZXRhZGF0YSwgYXBpTmFtZXNwYWNlT2JqLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IG1ldGFkYXRhLm1pbkFyZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0ICR7bWV0YWRhdGEubWluQXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWluQXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gbWV0YWRhdGEubWF4QXJncykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbW9zdCAke21ldGFkYXRhLm1heEFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1heEFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZENiID0gd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2suYmluZChudWxsLCB7XG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJncy5wdXNoKHdyYXBwZWRDYik7XG4gICAgICAgICAgYXBpTmFtZXNwYWNlT2JqLnNlbmRNZXNzYWdlKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0YXRpY1dyYXBwZXJzID0ge1xuICAgICAgICBkZXZ0b29sczoge1xuICAgICAgICAgIG5ldHdvcms6IHtcbiAgICAgICAgICAgIG9uUmVxdWVzdEZpbmlzaGVkOiB3cmFwRXZlbnQob25SZXF1ZXN0RmluaXNoZWRXcmFwcGVycylcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICBvbk1lc3NhZ2U6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgb25NZXNzYWdlRXh0ZXJuYWw6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB0YWJzOiB7XG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMixcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0dGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjbGVhcjoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhcGlNZXRhZGF0YS5wcml2YWN5ID0ge1xuICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgd2Vic2l0ZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gd3JhcE9iamVjdChleHRlbnNpb25BUElzLCBzdGF0aWNXcmFwcGVycywgYXBpTWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNocm9tZSAhPSBcIm9iamVjdFwiIHx8ICFjaHJvbWUgfHwgIWNocm9tZS5ydW50aW1lIHx8ICFjaHJvbWUucnVudGltZS5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY3JpcHQgc2hvdWxkIG9ubHkgYmUgbG9hZGVkIGluIGEgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgIH0gLy8gVGhlIGJ1aWxkIHByb2Nlc3MgYWRkcyBhIFVNRCB3cmFwcGVyIGFyb3VuZCB0aGlzIGZpbGUsIHdoaWNoIG1ha2VzIHRoZVxuICAgIC8vIGBtb2R1bGVgIHZhcmlhYmxlIGF2YWlsYWJsZS5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3cmFwQVBJcyhjaHJvbWUpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYnJvd3NlcjtcbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXBvbHlmaWxsLmpzLm1hcFxuIiwiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsImV4cG9ydCBlbnVtIEFsZXJ0VHlwZXMge1xyXG4gIHVuY29ubmVjdGVkQWNjb3VudCA9ICd1bmNvbm5lY3RlZEFjY291bnQnLFxyXG4gIHdlYjNTaGltVXNhZ2UgPSAnd2ViM1NoaW1Vc2FnZScsXHJcbiAgaW52YWxpZEN1c3RvbU5ldHdvcmsgPSAnaW52YWxpZEN1c3RvbU5ldHdvcmsnLFxyXG59XHJcblxyXG4vKipcclxuICogQWxlcnRzIHRoYXQgY2FuIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQgYnkgdGhlIHVzZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVE9HR0xFQUJMRV9BTEVSVF9UWVBFUyA9IFtcclxuICBBbGVydFR5cGVzLnVuY29ubmVjdGVkQWNjb3VudCxcclxuICBBbGVydFR5cGVzLndlYjNTaGltVXNhZ2UsXHJcbl07XHJcblxyXG5leHBvcnQgZW51bSBXZWIzU2hpbVVzYWdlQWxlcnRTdGF0ZXMge1xyXG4gIHJlY29yZGVkID0gMSxcclxuICBkaXNtaXNzZWQgPSAyLFxyXG59XHJcbiIsIlxuaW1wb3J0IHsgUmVzdHJpY3RlZE1ldGhvZHMgfSBmcm9tICcuL3Blcm1pc3Npb25zJztcclxuXHJcbi8qKlxyXG4gKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgZW52aXJvbm1lbnQgdGhlIGFwcGxpY2F0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nIGluXHJcbiAqIHBvcHVwIC0gV2hlbiB0aGUgdXNlciBjbGljaydzIHRoZSBpY29uIGluIHRoZWlyIGJyb3dzZXIncyBleHRlbnNpb24gYmFyOyB0aGUgZGVmYXVsdCB2aWV3XHJcbiAqIG5vdGlmaWNhdGlvbiAtIFdoZW4gdGhlIGV4dGVuc2lvbiBvcGVucyBkdWUgdG8gaW50ZXJhY3Rpb24gd2l0aCBhIFdlYjMgZW5hYmxlZCB3ZWJzaXRlXHJcbiAqIGZ1bGxzY3JlZW4gLSBXaGVuIHRoZSB1c2VyIGNsaWNrcyAnZXhwYW5kIHZpZXcnIHRvIG9wZW4gdGhlIGV4dGVuc2lvbiBpbiBhIG5ldyB0YWJcclxuICogYmFja2dyb3VuZCAtIFRoZSBiYWNrZ3JvdW5kIHByb2Nlc3MgdGhhdCBwb3dlcnMgdGhlIGV4dGVuc2lvblxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRW52aXJvbm1lbnRUeXBlID1cclxuICB8ICdwb3B1cCdcclxuICB8ICdub3RpZmljYXRpb24nXHJcbiAgfCAnZnVsbHNjcmVlbidcclxuICB8ICdiYWNrZ3JvdW5kJztcclxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfUE9QVVAgPSAncG9wdXAnO1xyXG5leHBvcnQgY29uc3QgRU5WSVJPTk1FTlRfVFlQRV9OT1RJRklDQVRJT04gPSAnbm90aWZpY2F0aW9uJztcclxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTiA9ICdmdWxsc2NyZWVuJztcclxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfQkFDS0dST1VORCA9ICdiYWNrZ3JvdW5kJztcclxuXHJcbmV4cG9ydCBjb25zdCBQTEFURk9STV9CUkFWRSA9ICdCcmF2ZSc7XHJcbmV4cG9ydCBjb25zdCBQTEFURk9STV9DSFJPTUUgPSAnQ2hyb21lJztcclxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0VER0UgPSAnRWRnZSc7XHJcbmV4cG9ydCBjb25zdCBQTEFURk9STV9GSVJFRk9YID0gJ0ZpcmVmb3gnO1xyXG5leHBvcnQgY29uc3QgUExBVEZPUk1fT1BFUkEgPSAnT3BlcmEnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1FU1NBR0VfVFlQRSA9IHtcclxuICBBRERfRVRIRVJFVU1fQ0hBSU46ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXHJcbiAgRVRIX0FDQ09VTlRTOiBSZXN0cmljdGVkTWV0aG9kcy5ldGhfYWNjb3VudHMsXHJcbiAgRVRIX0RFQ1JZUFQ6ICdldGhfZGVjcnlwdCcsXHJcbiAgRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVk6ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXHJcbiAgRVRIX1JFUVVFU1RfQUNDT1VOVFM6ICdldGhfcmVxdWVzdEFjY291bnRzJyxcclxuICBFVEhfU0lHTjogJ2V0aF9zaWduJyxcclxuICBFVEhfU0lHTl9UWVBFRF9EQVRBOiAnZXRoX3NpZ25UeXBlZERhdGEnLFxyXG4gIEVUSF9TSUdOX1RZUEVEX0RBVEFfVjM6ICdldGhfc2lnblR5cGVkRGF0YV92MycsXHJcbiAgRVRIX1NJR05fVFlQRURfREFUQV9WNDogJ2V0aF9zaWduVHlwZWREYXRhX3Y0JyxcclxuICBHRVRfUFJPVklERVJfU1RBVEU6ICdtZXRhbWFza19nZXRQcm92aWRlclN0YXRlJyxcclxuICBMT0dfV0VCM19TSElNX1VTQUdFOiAnbWV0YW1hc2tfbG9nV2ViM1NoaW1Vc2FnZScsXHJcbiAgUEVSU09OQUxfU0lHTjogJ3BlcnNvbmFsX3NpZ24nLFxyXG4gIFNFTkRfTUVUQURBVEE6ICdtZXRhbWFza19zZW5kRG9tYWluTWV0YWRhdGEnLFxyXG4gIFNXSVRDSF9FVEhFUkVVTV9DSEFJTjogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcclxuICBUUkFOU0FDVElPTjogJ3RyYW5zYWN0aW9uJyxcclxuICBXQUxMRVRfUkVRVUVTVF9QRVJNSVNTSU9OUzogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxyXG4gIFdBVENIX0FTU0VUOiAnd2FsbGV0X3dhdGNoQXNzZXQnLFxyXG4gIFdBVENIX0FTU0VUX0xFR0FDWTogJ21ldGFtYXNrX3dhdGNoQXNzZXQnLFxyXG5cblxufSBhcyBjb25zdDtcclxuXHJcblxuXHJcblxuXHJcbi8qKlxyXG4gKiBDdXN0b20gbWVzc2FnZXMgdG8gc2VuZCBhbmQgYmUgcmVjZWl2ZWQgYnkgdGhlIGV4dGVuc2lvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEVYVEVOU0lPTl9NRVNTQUdFUyA9IHtcclxuICBDT05ORUNUSU9OX1JFQURZOiAnQ09OTkVDVElPTl9SRUFEWScsXHJcbiAgUkVBRFk6ICdNRVRBTUFTS19FWFRFTlNJT05fUkVBRFknLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFBPTExJTkdfVE9LRU5fRU5WSVJPTk1FTlRfVFlQRVMgPSB7XHJcbiAgW0VOVklST05NRU5UX1RZUEVfUE9QVVBdOiAncG9wdXBHYXNQb2xsVG9rZW5zJyxcclxuICBbRU5WSVJPTk1FTlRfVFlQRV9OT1RJRklDQVRJT05dOiAnbm90aWZpY2F0aW9uR2FzUG9sbFRva2VucycsXHJcbiAgW0VOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTl06ICdmdWxsU2NyZWVuR2FzUG9sbFRva2VucycsXHJcbiAgW0VOVklST05NRU5UX1RZUEVfQkFDS0dST1VORF06ICdub25lJyxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBPUklHSU5fTUVUQU1BU0sgPSAnbWV0YW1hc2snO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0JFVEFfQ0hST01FX0lEID0gJ3BiYmthbWZnbWFlZGNjbmZrbWpjb2ZjZWNqaGZnbGRuJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX1BST0RfQ0hST01FX0lEID0gJ25rYmloZmJlb2dhZWFvZWhsZWZua29kYmVmZ3Bna25uJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0ZMQVNLX0NIUk9NRV9JRCA9ICdsamZvZWluanBhZWRqZmVjYm1nZ2pnb2RiZ2ttamtqayc7XHJcblxyXG5leHBvcnQgY29uc3QgTUVUQU1BU0tfTU1JX0JFVEFfQ0hST01FX0lEID0gJ2ttYmhiY2JhZG9oaGhnZGdpaGVqY2ljYmdjZWhvYWVnJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX01NSV9QUk9EX0NIUk9NRV9JRCA9ICdpa2tpaGphbWRoZmlvanBkYm5mbGxwamlncG5laXBiYyc7XHJcblxyXG5leHBvcnQgY29uc3QgQ0hST01FX0JVSUxEX0lEUyA9IFtcclxuICBNRVRBTUFTS19CRVRBX0NIUk9NRV9JRCxcclxuICBNRVRBTUFTS19QUk9EX0NIUk9NRV9JRCxcclxuICBNRVRBTUFTS19GTEFTS19DSFJPTUVfSUQsXHJcbiAgTUVUQU1BU0tfTU1JX0JFVEFfQ0hST01FX0lELFxyXG4gIE1FVEFNQVNLX01NSV9QUk9EX0NIUk9NRV9JRCxcclxuXSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IE1FVEFNQVNLX0JFVEFfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb24tYmV0YUBtZXRhbWFzay5pbyc7XHJcbmNvbnN0IE1FVEFNQVNLX1BST0RfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb25AbWV0YW1hc2suaW8nO1xyXG5jb25zdCBNRVRBTUFTS19GTEFTS19GSVJFRk9YX0lEID0gJ3dlYmV4dGVuc2lvbi1mbGFza0BtZXRhbWFzay5pbyc7XHJcblxyXG5leHBvcnQgY29uc3QgRklSRUZPWF9CVUlMRF9JRFMgPSBbXHJcbiAgTUVUQU1BU0tfQkVUQV9GSVJFRk9YX0lELFxyXG4gIE1FVEFNQVNLX1BST0RfRklSRUZPWF9JRCxcclxuICBNRVRBTUFTS19GTEFTS19GSVJFRk9YX0lELFxyXG5dIGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFVOS05PV05fVElDS0VSX1NZTUJPTCA9ICdVTktOT1dOJztcclxuIiwiZXhwb3J0IGVudW0gRXRoZXJEZW5vbWluYXRpb24ge1xyXG4gIEVUSCA9ICdFVEgnLFxyXG4gIEdXRUkgPSAnR1dFSScsXHJcbiAgV0VJID0gJ1dFSScsXHJcbn1cclxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuXHJcbmNvbnN0IE9ORV9IVU5EUkVEX1RIT1VTQU5EID0gMTAwMDAwO1xyXG5jb25zdCBNSU5fR0FTX0xJTUlUX0RFQyA9ICcyMTAwMCc7XHJcblxyXG5leHBvcnQgY29uc3QgTUlOX0dBU19MSU1JVF9IRVggPSBwYXJzZUludChNSU5fR0FTX0xJTUlUX0RFQywgMTApLnRvU3RyaW5nKDE2KTtcclxuXHJcbmV4cG9ydCBjb25zdCBHQVNfTElNSVRTID0ge1xyXG4gIC8vIG1heGltdW0gZ2FzTGltaXQgb2YgYSBzaW1wbGUgc2VuZFxyXG4gIFNJTVBMRTogYWRkSGV4UHJlZml4KE1JTl9HQVNfTElNSVRfSEVYKSxcclxuICAvLyBhIGJhc2UgZXN0aW1hdGUgZm9yIHRva2VuIHRyYW5zZmVycy5cclxuICBCQVNFX1RPS0VOX0VTVElNQVRFOiBhZGRIZXhQcmVmaXgoT05FX0hVTkRSRURfVEhPVVNBTkQudG9TdHJpbmcoMTYpKSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBHYXNFc3RpbWF0ZVR5cGVzXHJcbiAqIEBwcm9wZXJ0eSB7J2ZlZS1tYXJrZXQnfSBGRUVfTUFSS0VUIC0gQSBnYXMgZXN0aW1hdGUgZm9yIGEgZmVlIG1hcmtldCB0cmFuc2FjdGlvbiBnZW5lcmF0ZWQgYnkgb3VyIGdhcyBlc3RpbWF0aW9uIEFQSS5cclxuICogQHByb3BlcnR5IHsnbGVnYWN5J30gTEVHQUNZIC0gQSBnYXMgZXN0aW1hdGUgZm9yIGEgbGVnYWN5IFRyYW5zYWN0aW9uIGdlbmVyYXRlZCBieSBvdXIgZ2FzIGVzdGltYXRpb24gQVBJLlxyXG4gKiBAcHJvcGVydHkgeydldGhfZ2FzUHJpY2UnfSBFVEhfR0FTX1BSSUNFIC0gQSBnYXMgZXN0aW1hdGUgcHJvdmlkZWQgYnkgdGhlIEV0aGVyZXVtIG5vZGUgdmlhIGV0aF9nYXNQcmljZS5cclxuICogQHByb3BlcnR5IHsnbm9uZSd9IE5PTkUgLSBObyBnYXMgZXN0aW1hdGUgYXZhaWxhYmxlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGVzZSBhcmUgYWxyZWFkeSBkZWNsYXJlZCBpbiBAbWV0YW1hc2svY29udHJvbGxlcnMgYnV0IGltcG9ydGluZyB0aGVtIGZyb21cclxuICogdGhhdCBtb2R1bGUgYW5kIHJlLWV4cG9ydGluZyBjYXVzZXMgdGhlIFVJIGJ1bmRsZSBzaXplIHRvIGV4cGFuZCBiZXlvbmQgNE1CXHJcbiAqXHJcbiAqIChUT0RPOiBUaGlzIGNvbW1lbnQgd2FzIGFkZGVkIGJlZm9yZSBAbWV0YW1hc2svY29udHJvbGxlcnMgd2FzIHNwbGl0IHVwIOKAlFxyXG4gKiByZXZpc2l0IG5vdyB0aGF0IEBtZXRhbWFzay9nYXMtZmVlLWNvbnRyb2xsZXIgaXMgYXZhaWxhYmxlKVxyXG4gKlxyXG4gKiBAdHlwZSB7R2FzRXN0aW1hdGVUeXBlc31cclxuICovXHJcbmV4cG9ydCBlbnVtIEdhc0VzdGltYXRlVHlwZXMge1xyXG4gIGZlZU1hcmtldCA9ICdmZWUtbWFya2V0JyxcclxuICBsZWdhY3kgPSAnbGVnYWN5JyxcclxuICBldGhHYXNQcmljZSA9ICdldGhfZ2FzUHJpY2UnLFxyXG4gIG5vbmUgPSAnbm9uZScsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgZ2FzIHJlY29tbWVuZGF0aW9uIGxldmVscyBwcmVzZW50ZWQgaW4gdGhlIFVJXHJcbiAqL1xyXG5leHBvcnQgZW51bSBHYXNSZWNvbW1lbmRhdGlvbnMge1xyXG4gIGxvdyA9ICdsb3cnLFxyXG4gIG1lZGl1bSA9ICdtZWRpdW0nLFxyXG4gIGhpZ2ggPSAnaGlnaCcsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgdHlwZXMgb2YgZ2FzIGVzdGltYXRpb25cclxuICovXHJcbmV4cG9ydCBlbnVtIFByaW9yaXR5TGV2ZWxzIHtcclxuICB0ZW5QZXJjZW50SW5jcmVhc2VkID0gJ3RlblBlcmNlbnRJbmNyZWFzZWQnLFxyXG4gIGxvdyA9ICdsb3cnLFxyXG4gIG1lZGl1bSA9ICdtZWRpdW0nLFxyXG4gIGhpZ2ggPSAnaGlnaCcsXHJcbiAgY3VzdG9tID0gJ2N1c3RvbScsXHJcbiAgZEFwcFN1Z2dlc3RlZCA9ICdkYXBwU3VnZ2VzdGVkJyxcclxuICBkYXBwU3VnZ2VzdGVkSGlnaCA9ICdkYXBwU3VnZ2VzdGVkSGlnaCcsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSB1c2VyIGN1c3RvbWl6aW5nIHRoZWlyIGdhcyBwcmVmZXJlbmNlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ1VTVE9NX0dBU19FU1RJTUFURSA9ICdjdXN0b20nO1xyXG5cclxuLyoqXHJcbiAqIFRoZXNlIHJlcHJlc2VudCB0aGUgZGlmZmVyZW50IGVkaXQgbW9kZXMgcHJlc2VudGVkIGluIHRoZSBVSVxyXG4gKi9cclxuZXhwb3J0IGVudW0gRWRpdEdhc01vZGVzIHtcclxuICBzcGVlZFVwID0gJ3NwZWVkLXVwJyxcclxuICBjYW5jZWwgPSAnY2FuY2VsJyxcclxuICBtb2RpZnlJblBsYWNlID0gJ21vZGlmeS1pbi1wbGFjZScsXHJcbiAgc3dhcHMgPSAnc3dhcHMnLFxyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBsZXZlbHMgZm9yIGBuZXR3b3JrQ29uZ2VzdGlvbmAgKGNhbGN1bGF0ZWQgYWxvbmcgd2l0aCBnYXMgZmVlXHJcbiAqIGVzdGltYXRlczsgcmVwcmVzZW50cyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEpIHRoYXQgd2UgdXNlIHRvIHJlbmRlciB0aGVcclxuICogbmV0d29yayBzdGF0dXMgc2xpZGVyIG9uIHRoZSBzZW5kIHRyYW5zYWN0aW9uIHNjcmVlbiBhbmQgaW5mb3JtIHVzZXJzIHdoZW5cclxuICogZ2FzIGZlZXMgYXJlIGhpZ2hcclxuICovXHJcbmV4cG9ydCBlbnVtIE5ldHdvcmtDb25nZXN0aW9uVGhyZXNob2xkcyB7XHJcbiAgbm90QnVzeSA9IDAsXHJcbiAgc3RhYmxlID0gMC4zMyxcclxuICBidXN5ID0gMC42NixcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUeEdhc0ZlZXMge1xyXG4gIC8qKiBNYXhtaW11bSBudW1iZXIgb2YgdW5pdHMgb2YgZ2FzIHRvIHVzZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi4gKi9cclxuICBnYXNMaW1pdDogc3RyaW5nO1xyXG4gIC8qKiBQcmljZSBwZXIgZ2FzIGZvciBsZWdhY3kgdHhzICovXHJcbiAgZ2FzUHJpY2U6IHN0cmluZztcclxuICAvKipcclxuICAgKiBNYXhpbXVtIGFtb3VudCBwZXIgZ2FzIHRvIHBheSBmb3IgdGhlIHRyYW5zYWN0aW9uLCBpbmNsdWRpbmcgdGhlIHByaW9yaXR5XHJcbiAgICogZmVlLlxyXG4gICAqL1xyXG4gIG1heEZlZVBlckdhczogc3RyaW5nO1xyXG4gIC8qKiBNYXhpbXVtIGFtb3VudCBwZXIgZ2FzIHRvIGdpdmUgdG8gdmFsaWRhdG9yIGFzIGluY2VudGl2ZS4gKi9cclxuICBtYXhQcmlvcml0eUZlZVBlckdhczogc3RyaW5nO1xyXG4gIC8qKiBXaGljaCBlc3RpbWF0ZSBsZXZlbCB3YXMgdXNlZCAqL1xyXG4gIGVzdGltYXRlVXNlZDogc3RyaW5nO1xyXG4gIC8qKiBXaGljaCBlc3RpbWF0ZSBsZXZlbCB0aGF0IHRoZSBBUEkgc3VnZ2VzdGVkLiAqL1xyXG4gIGVzdGltYXRlU3VnZ2VzdGVkOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBkZWZhdWx0IGVzdGltYXRlIGZvciBnYXMuICovXHJcbiAgZGVmYXVsdEdhc0VzdGltYXRlczogc3RyaW5nO1xyXG4gIC8qKiBzYW1lIGFzIGdhc0xpbWl0PyAqL1xyXG4gIGdhczogc3RyaW5nO1xyXG4gIC8qKiBPcmlnaW5hbCBlc3RpbWF0ZSBmb3IgZ2FzLiAqL1xyXG4gIG9yaWdpbmFsR2FzRXN0aW1hdGU6IHN0cmluZztcclxuICAvKiogVGhlIGdhcyBsaW1pdCBzdXBwbGllZCBieSB1c2VyLiAqL1xyXG4gIHVzZXJFZGl0ZWRHYXNMaW1pdDogc3RyaW5nO1xyXG4gIC8qKiBFc3RpbWF0ZSBsZXZlbCB1c2VyIHNlbGVjdGVkLiAqL1xyXG4gIHVzZXJGZWVMZXZlbDogc3RyaW5nO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBIYXJkd2FyZSB3YWxsZXRzIHN1cHBvcnRlZCBieSBNZXRhTWFzay5cclxuICovXHJcbmV4cG9ydCBlbnVtIEhhcmR3YXJlS2V5cmluZ1R5cGUge1xyXG4gIGxlZGdlciA9ICdMZWRnZXIgSGFyZHdhcmUnLFxyXG4gIHRyZXpvciA9ICdUcmV6b3IgSGFyZHdhcmUnLFxyXG4gIGxhdHRpY2UgPSAnTGF0dGljZSBIYXJkd2FyZScsXHJcbiAgcXIgPSAnUVIgSGFyZHdhcmUgV2FsbGV0IERldmljZScsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEhhcmR3YXJlS2V5cmluZ05hbWVzIHtcclxuICBsZWRnZXIgPSAnTGVkZ2VyJyxcclxuICB0cmV6b3IgPSAnVHJlem9yJyxcclxuICBsYXR0aWNlID0gJ0xhdHRpY2UxJyxcclxuICBxciA9ICdRUicsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEhhcmR3YXJlRGV2aWNlTmFtZXMge1xyXG4gIGxlZGdlciA9ICdsZWRnZXInLFxyXG4gIHRyZXpvciA9ICd0cmV6b3InLFxyXG4gIGxhdHRpY2UgPSAnbGF0dGljZScsXHJcbiAgcXIgPSAnUVIgSGFyZHdhcmUnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBIYXJkd2FyZVRyYW5zcG9ydFN0YXRlcyB7XHJcbiAgbm9uZSA9ICdOT05FJyxcclxuICB2ZXJpZmllZCA9ICdWRVJJRklFRCcsXHJcbiAgZGV2aWNlT3BlbkZhaWx1cmUgPSAnREVWSUNFX09QRU5fRkFJTFVSRScsXHJcbiAgdW5rbm93bkZhaWx1cmUgPSAnVU5LTk9XTl9GQUlMVVJFJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gSGFyZHdhcmVBZmZpbGlhdGVMaW5rcyB7XHJcbiAgbGVkZ2VyID0gJ2h0dHBzOi8vc2hvcC5sZWRnZXIuY29tLz9yPTE3YzQ5OTFhMDNmYScsXHJcbiAgZ3JpZHBsdXMgPSAnaHR0cHM6Ly9ncmlkcGx1cy5pby8/YWZtYz03cCcsXHJcbiAgdHJlem9yID0gJ2h0dHBzOi8vc2hvcC50cmV6b3IuaW8vcHJvZHVjdC90cmV6b3Itb25lLWJsYWNrP29mZmVyX2lkPTM1JmFmZl9pZD0xMTAwOScsXHJcbiAga2V5c3RvbmUgPSAnaHR0cHM6Ly9rZXlzdC5vbmUvbWV0YW1hc2s/cmZzbj02MDg4MjU3LjY1NmIzZTkmdXRtX3NvdXJjZT1yZWZlcnNpb24mdXRtX21lZGl1bT1hZmZpbGlhdGUmdXRtX2NhbXBhaWduPTYwODgyNTcuNjU2YjNlOScsXHJcbiAgYWlyZ2FwID0gJ2h0dHBzOi8vYWlyZ2FwLml0LycsXHJcbiAgY29vbHdhbGxldCA9ICdodHRwczovL3d3dy5jb29sd2FsbGV0LmlvLycsXHJcbiAgZGNlbnQgPSAnaHR0cHM6Ly9kY2VudHdhbGxldC5jb20vJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gSGFyZHdhcmVBZmZpbGlhdGVUdXRvcmlhbExpbmtzIHtcclxuICBsZWRnZXIgPSAnaHR0cHM6Ly9zdXBwb3J0LmxlZGdlci5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvNDQwNDM2Njg2NDY1Ny1TZXQtdXAtYW5kLXVzZS1NZXRhTWFzay10by1hY2Nlc3MteW91ci1MZWRnZXItRXRoZXJldW0tRVRILWFjY291bnQ/ZG9jcz10cnVlJyxcclxuICBncmlkcGx1cyA9ICdodHRwczovL2RvY3MuZ3JpZHBsdXMuaW8vc2V0dXAvbWV0YW1hc2snLFxyXG4gIHRyZXpvciA9ICdodHRwczovL3dpa2kudHJlem9yLmlvL0FwcHM6TWV0YU1hc2snLFxyXG4gIGtleXN0b25lID0gJ2h0dHBzOi8vc3VwcG9ydC5rZXlzdC5vbmUvM3JkLXBhcnR5LXdhbGxldHMvZXRoLWFuZC13ZWIzLXdhbGxldHMta2V5c3RvbmUvYmluZC1tZXRhbWFzay13aXRoLWtleXN0b25lJyxcclxuICBhaXJnYXAgPSAnaHR0cHM6Ly9zdXBwb3J0LmFpcmdhcC5pdC9ndWlkZXMvbWV0YW1hc2svJyxcclxuICBjb29sd2FsbGV0ID0gJ2h0dHBzOi8vd3d3LmNvb2x3YWxsZXQuaW8vbWV0YW1hc2stc3RlcC1ieS1zdGVwLWd1aWRlcy8nLFxyXG4gIGRjZW50ID0gJ2h0dHBzOi8vbWVkaXVtLmNvbS9kY2VudHdhbGxldC9kY2VudC13YWxsZXQtbm93LXN1cHBvcnRzLXFyLWJhc2VkLXByb3RvY29sLXRvLWxpbmstd2l0aC1tZXRhbWFzay01NzU1NWYwMjYwM2YnLFxyXG59XHJcblxyXG4vKipcclxuICogVXNlZCBmb3Igc2V0dGluZyB0aGUgdXNlcnMgcHJlZmVyZW5jZSBmb3IgbGVkZ2VyIHRyYW5zcG9ydCB0eXBlXHJcbiAqL1xyXG5leHBvcnQgZW51bSBMZWRnZXJUcmFuc3BvcnRUeXBlcyB7XHJcbiAgbGl2ZSA9ICdsZWRnZXJMaXZlJyxcclxuICB3ZWJoaWQgPSAnd2ViaGlkJyxcclxuICB1MmYgPSAndTJmJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gV2ViSElEQ29ubmVjdGVkU3RhdHVzZXMge1xyXG4gIGNvbm5lY3RlZCA9ICdjb25uZWN0ZWQnLFxyXG4gIG5vdENvbm5lY3RlZCA9ICdub3RDb25uZWN0ZWQnLFxyXG4gIHVua25vd24gPSAndW5rbm93bicsXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBMRURHRVJfVVNCX1ZFTkRPUl9JRCA9ICcweDJjOTcnO1xyXG4iLCJpbXBvcnQgeyBIYXJkd2FyZUtleXJpbmdUeXBlIH0gZnJvbSAnLi9oYXJkd2FyZS13YWxsZXRzJztcclxuXHJcbi8qKlxyXG4gKiBUaGVzZSBhcmUgdGhlIGtleXJpbmdzIHRoYXQgYXJlIG1hbmFnZWQgZW50aXJlbHkgYnkgTWV0YU1hc2suXHJcbiAqL1xyXG5leHBvcnQgZW51bSBJbnRlcm5hbEtleXJpbmdUeXBlIHtcclxuICBoZEtleVRyZWUgPSAnSEQgS2V5IFRyZWUnLFxyXG4gIGltcG9ydGVkID0gJ1NpbXBsZSBLZXkgUGFpcicsXHJcbn1cclxuXHJcblxuXHJcbi8qKlxyXG4gKiBBbGwga2V5cmluZ3Mgc3VwcG9ydGVkIGJ5IE1ldGFNYXNrLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEtleXJpbmdUeXBlID0ge1xyXG4gIC4uLkhhcmR3YXJlS2V5cmluZ1R5cGUsXHJcbiAgLi4uSW50ZXJuYWxLZXlyaW5nVHlwZSxcclxuXG59O1xyXG4iLCIvLyBUaGUgY2hhcmFjdGVyIGxpbWl0IG9uIEVOUyBuYW1lcywgbmlja25hbWVzIGFuZCBhZGRyZXNzZXMgYmVmb3JlIHdlIHRydW5jYXRlXHJcbmV4cG9ydCBjb25zdCBUUlVOQ0FURURfTkFNRV9DSEFSX0xJTUlUID0gMTE7XHJcblxyXG4vLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2xpY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFuIGFkZHJlc3MgZm9yIHRydW5jYXRlZCBmb3JtYXQ6XHJcbi8vIGAke1RSVU5DQVRFRF9BRERSRVNTX1NUQVJUX0NIQVJTfS4uLiR7VFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTfWBcclxuZXhwb3J0IGNvbnN0IFRSVU5DQVRFRF9BRERSRVNTX1NUQVJUX0NIQVJTID0gNTtcclxuXHJcbi8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzbGljZSBmcm9tIHRoZSBlbmQgb2YgYW4gYWRkcmVzcyBmb3IgdHJ1bmNhdGVkIGZvcm1hdDpcclxuLy8gYCR7VFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlN9Li4uJHtUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlN9YFxyXG5leHBvcnQgY29uc3QgVFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTID0gNDtcclxuIiwiaW1wb3J0IHR5cGUgeyBFbnZpcm9ubWVudFR5cGUgfSBmcm9tICcuL2FwcCc7XHJcbmltcG9ydCB7IExlZGdlclRyYW5zcG9ydFR5cGVzIH0gZnJvbSAnLi9oYXJkd2FyZS13YWxsZXRzJztcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIGF0dGFjaCBjb250ZXh0IG9mIHdoZXJlIHRoZSB1c2VyIHdhcyBhdCBpbiB0aGUgYXBwbGljYXRpb24gd2hlbiB0aGVcclxuICogZXZlbnQgd2FzIHRyaWdnZXJlZC4gQWxzbyBpbmNsdWRlZCBhcyBmdWxsIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZSBpblxyXG4gKiBwYWdlIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzUGFnZU9iamVjdCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgcGF0aCBvZiB0aGUgY3VycmVudCBwYWdlIChlLmcuIFwiL2hvbWVcIikuXHJcbiAgICovXHJcbiAgcGF0aD86IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgcGFnZSAoZS5nLiBcImhvbWVcIikuXHJcbiAgICovXHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgcGFnZS5cclxuICAgKi9cclxuICB1cmw/OiBzdHJpbmc7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGRhcHAgdGhhdCB0cmlnZ2VyZWQgYW4gaW50ZXJhY3Rpb24gKE1ldGFNYXNrIG9ubHkpLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgb3JpZ2luIG9mIHRoZSBkYXBwIGlzc3VpbmcgdGhlIG5vdGlmaWNhdGlvbi5cclxuICAgKi9cclxuICB1cmw/OiBzdHJpbmc7XHJcbn07XHJcblxyXG4vKipcclxuICogV2UgYXR0YWNoIGNvbnRleHQgdG8gZXZlcnkgbWV0YSBtZXRyaWNzIGV2ZW50IHRoYXQgaGVscCB0byBxdWFsaWZ5IG91clxyXG4gKiBhbmFseXRpY3MuIFRoaXMgdHlwZSBoYXMgYWxsIG9wdGlvbmFsIHZhbHVlcyBiZWNhdXNlIGl0IHJlcHJlc2VudHMgYVxyXG4gKiByZXR1cm5lZCBvYmplY3QgZnJvbSBhIG1ldGhvZCBjYWxsLiBJZGVhbGx5IGFwcCBhbmQgdXNlckFnZW50IGFyZVxyXG4gKiBkZWZpbmVkIG9uIGV2ZXJ5IGV2ZW50LiBUaGlzIGlzIGNvbmZpcm1lZCBpbiB0aGUgZ2V0VHJhY2tNZXRhTWV0cmljc0V2ZW50XHJcbiAqIGZ1bmN0aW9uLCBidXQgc3RpbGwgcHJvdmlkZXMgdGhlIGNvbnN1bWVyIGEgd2F5IHRvIG92ZXJyaWRlIHRoZXNlIHZhbHVlcyBpZlxyXG4gKiBuZWNlc3NhcnkuXHJcbiAqL1xyXG50eXBlIE1ldGFNZXRyaWNzQ29udGV4dCA9IHtcclxuICAvKipcclxuICAgKiBBcHBsaWNhdGlvbiBtZXRhZGF0YS5cclxuICAgKi9cclxuICBhcHA6IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uIHRyYWNraW5nIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHZlcnNpb246IHN0cmluZztcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIFRoZSB1c2VyIGFnZW50IG9mIHRoZSBhcHBsaWNhdGlvbi5cclxuICAgKi9cclxuICB1c2VyQWdlbnQ6IHN0cmluZztcclxuICAvKipcclxuICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZS5cclxuICAgKi9cclxuICBwYWdlPzogTWV0YU1ldHJpY3NQYWdlT2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBkYXBwIHRoYXQgdHJpZ2dlcmVkIGFuIGludGVyYWN0aW9uIChNZXRhTWFzayBvbmx5KS5cclxuICAgKi9cclxuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBNZXRhTWV0cmljc0V2ZW50UGF5bG9hZCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgZXZlbnQgbmFtZSB0byB0cmFjay5cclxuICAgKi9cclxuICBldmVudDogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBjYXRlZ29yeSB0byBhc3NvY2lhdGUgdGhlIGV2ZW50IHRvLlxyXG4gICAqL1xyXG4gIGNhdGVnb3J5OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGFjdGlvbiBJRCB0byBkZWR1cGxpY2F0ZSBldmVudCByZXF1ZXN0cyBmcm9tIHRoZSBVSS5cclxuICAgKi9cclxuICBhY3Rpb25JZD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBUaGUgdHlwZSBvZiBlbnZpcm9ubWVudCB0aGlzIGV2ZW50IG9jY3VycmVkIGluLiBEZWZhdWx0cyB0byB0aGUgYmFja2dyb3VuZFxyXG4gICAqIHByb2Nlc3MgdHlwZS5cclxuICAgKi9cclxuICBlbnZpcm9ubWVudFR5cGU/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQ3VzdG9tIHZhbHVlcyB0byB0cmFjay4gS2V5cyBpbiB0aGlzIG9iamVjdCBtdXN0IGJlIGBzbmFrZV9jYXNlYC5cclxuICAgKi9cclxuICBwcm9wZXJ0aWVzPzogb2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFNlbnNpdGl2ZSB2YWx1ZXMgdG8gdHJhY2suIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSBzZW50IGluIGFuIGFkZGl0aW9uYWxcclxuICAgKiBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgYG1ldGFNZXRyaWNzSWRgLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmVcclxuICAgKiBpbiBgc25ha2VfY2FzZWAuXHJcbiAgICovXHJcbiAgc2Vuc2l0aXZlUHJvcGVydGllcz86IG9iamVjdDtcclxuICAvKipcclxuICAgKiBBbW91bnQgb2YgY3VycmVuY3kgdGhhdCB0aGUgZXZlbnQgY3JlYXRlcyBpbiByZXZlbnVlIGZvciBNZXRhTWFzay5cclxuICAgKi9cclxuICByZXZlbnVlPzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIElTTy00MTI3LWZvcm1hdHRlZCBjdXJyZW5jeSBmb3IgZXZlbnRzIHdpdGggcmV2ZW51ZS4gRGVmYXVsdHMgdG8gVVNcclxuICAgKiBkb2xsYXJzLlxyXG4gICAqL1xyXG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0IGJ1c2luZXNzIFwidmFsdWVcIiBhdHRyaWJ1dGFibGUgdG8gY3VzdG9tZXJzIHdobyB0cmlnZ2VyIHRoaXMgZXZlbnQuXHJcbiAgICovXHJcbiAgdmFsdWU/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogVGhlIHBhZ2Uvcm91dGUgdGhhdCB0aGUgZXZlbnQgb2NjdXJyZWQgb24uXHJcbiAgICovXHJcbiAgcGFnZT86IE1ldGFNZXRyaWNzUGFnZU9iamVjdDtcclxuICAvKipcclxuICAgKiBUaGUgb3JpZ2luIG9mIHRoZSBkYXBwIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXHJcbiAgICovXHJcbiAgcmVmZXJyZXI/OiBNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0O1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NFdmVudE9wdGlvbnMgPSB7XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciBvciBub3QgdGhlIGV2ZW50IGhhcHBlbmVkIGR1cmluZyB0aGUgb3B0LWluIHdvcmtmbG93LlxyXG4gICAqL1xyXG4gIGlzT3B0SW4/OiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHNlZ21lbnQgcXVldWUgc2hvdWxkIGJlIGZsdXNoZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxyXG4gICAqIFJlY29tbWVuZGVkIGlmIHRoZSByZXN1bHQgb2YgdHJhY2tpbmcgdGhlIGV2ZW50IG11c3QgYmUga25vd24gYmVmb3JlIFVJXHJcbiAgICogdHJhbnNpdGlvbiBvciB1cGRhdGUuXHJcbiAgICovXHJcbiAgZmx1c2hJbW1lZGlhdGVseT86IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBleGNsdWRlIHRoZSB1c2VyJ3MgYG1ldGFNZXRyaWNzSWRgIGZvciBhbm9ueW1pdHkuXHJcbiAgICovXHJcbiAgZXhjbHVkZU1ldGFNZXRyaWNzSWQ/OiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIEFuIG92ZXJyaWRlIGZvciB0aGUgYG1ldGFNZXRyaWNzSWRgIGluIHRoZSBldmVudCAobm8gcHVuIGludGVuZGVkKSBvbmUgaXNcclxuICAgKiBjcmVhdGVkIGFzIGEgcGFydCBvZiBhbiBhc3luY2hyb25vdXMgd29ya2Zsb3csIHN1Y2ggYXMgYXdhaXRpbmcgdGhlIHJlc3VsdFxyXG4gICAqIG9mIHRoZSBNZXRhTWV0cmljcyBvcHQtaW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIHVzZXInc1xyXG4gICAqIGBtZXRhTWV0cmljc0lkYC5cclxuICAgKi9cclxuICBtZXRhTWV0cmljc0lkPzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIElzIHRoaXMgZXZlbnQgYSBob2xkb3ZlciBmcm9tIE1hdG9tbyB0aGF0IG5lZWRzIGZ1cnRoZXIgbWlncmF0aW9uPyBXaGVuXHJcbiAgICogdHJ1ZSwgc2VuZHMgdGhlIGRhdGEgdG8gYSBzcGVjaWFsIFNlZ21lbnQgc291cmNlIHRoYXQgbWFya3MgdGhlIGV2ZW50IGRhdGFcclxuICAgKiBhcyBub3QgY29uZm9ybWluZyB0byBvdXIgc2NoZW1hLlxyXG4gICAqL1xyXG4gIG1hdG9tb0V2ZW50PzogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzRXZlbnRGcmFnbWVudCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgZXZlbnQgbmFtZSB0byBmaXJlIHdoZW4gdGhlIGZyYWdtZW50IGlzIGNsb3NlZCBpbiBhbiBhZmZpcm1hdGl2ZSBhY3Rpb24uXHJcbiAgICovXHJcbiAgc3VjY2Vzc0V2ZW50OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGV2ZW50IG5hbWUgdG8gZmlyZSB3aGVuIHRoZSBmcmFnbWVudCBpcyBjbG9zZWQgd2l0aCBhIHJlamVjdGlvbi5cclxuICAgKi9cclxuICBmYWlsdXJlRXZlbnQ/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgbmFtZSB0byBmaXJlIGltbWVkaWF0ZWx5IHVwb24gZnJhZ21lbnQgY3JlYXRpb24uIFRoaXMgaXMgdXNlZnVsXHJcbiAgICogZm9yIGJ1aWxkaW5nIGZ1bm5lbHMgaW4gbWl4cGFuZWwgYW5kIGZvciByZWR1Y3Rpb24gb2YgY29kZSBkdXBsaWNhdGlvbi5cclxuICAgKi9cclxuICBpbml0aWFsRXZlbnQ/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGV2ZW50IGNhdGVnb3J5IHRvIHVzZSBmb3IgYm90aCB0aGUgc3VjY2VzcyBhbmQgZmFpbHVyZSBldmVudHMuXHJcbiAgICovXHJcbiAgY2F0ZWdvcnk6IHN0cmluZztcclxuICAvKipcclxuICAgKiBTaG91bGQgdGhpcyBmcmFnbWVudCBiZSBwZXJzaXN0ZWQgaW4gc3RhdGUgYW5kIHByb2dyZXNzZWQgYWZ0ZXIgdGhlXHJcbiAgICogZXh0ZW5zaW9uIGlzIGxvY2tlZCBhbmQgdW5sb2NrZWQuXHJcbiAgICovXHJcbiAgcGVyc2lzdD86IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogVGltZSBpbiBzZWNvbmRzIHRoZSBldmVudCBzaG91bGQgYmUgcGVyc2lzdGVkIGZvci4gQWZ0ZXIgdGhlIHRpbWVvdXQgdGhlXHJcbiAgICogZnJhZ21lbnQgd2lsbCBiZSBjbG9zZWQgYXMgYWJhbmRvbmVkLiBJZiBub3Qgc3VwcGxpZWQgdGhlIGZyYWdtZW50IGlzXHJcbiAgICogc3RvcmVkIGluZGVmaW5pdGVseS5cclxuICAgKi9cclxuICB0aW1lb3V0PzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIGBEYXRlLm5vdygpYCB3aGVuIHRoZSBmcmFnbWVudCB3YXMgbGFzdCB1cGRhdGVkLiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVcclxuICAgKiB0aW1lb3V0IGhhcyBleHBpcmVkIGFuZCB0aGUgZnJhZ21lbnQgc2hvdWxkIGJlIGNsb3NlZC5cclxuICAgKi9cclxuICBsYXN0VXBkYXRlZD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBDdXN0b20gdmFsdWVzIHRvIHRyYWNrLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmUgYHNuYWtlX2Nhc2VgLlxyXG4gICAqL1xyXG4gIHByb3BlcnRpZXM/OiBvYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogU2Vuc2l0aXZlIHZhbHVlcyB0byB0cmFjay4gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHNlbnQgaW4gYW4gYWRkaXRpb25hbFxyXG4gICAqIGV2ZW50IHRoYXQgZXhjbHVkZXMgdGhlIHVzZXIncyBgbWV0YU1ldHJpY3NJZGAuIEtleXMgaW4gdGhpcyBvYmplY3QgbXVzdCBiZVxyXG4gICAqIGluIGBzbmFrZV9jYXNlYC5cclxuICAgKi9cclxuICBzZW5zaXRpdmVQcm9wZXJ0aWVzPzogb2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIEFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IHRoZSBldmVudCBjcmVhdGVzIGluIHJldmVudWUgZm9yIE1ldGFNYXNrLlxyXG4gICAqL1xyXG4gIHJldmVudWU/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogSVNPLTQxMjctZm9ybWF0dGVkIGN1cnJlbmN5IGZvciBldmVudHMgd2l0aCByZXZlbnVlLiBEZWZhdWx0cyB0byBVU1xyXG4gICAqIGRvbGxhcnMuXHJcbiAgICovXHJcbiAgY3VycmVuY3k/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3QgYnVzaW5lc3MgXCJ2YWx1ZVwiIGF0dHJpYnV0YWJsZSB0byBjdXN0b21lcnMgd2hvIHRyaWdnZXIgdGhpcyBldmVudC5cclxuICAgKi9cclxuICB2YWx1ZT86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBUaGUgcGFnZS9yb3V0ZSB0aGF0IHRoZSBldmVudCBvY2N1cnJlZCBvbi5cclxuICAgKi9cclxuICBwYWdlPzogTWV0YU1ldHJpY3NQYWdlT2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBvcmlnaW4gb2YgdGhlIGRhcHAgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC5cclxuICAgKi9cclxuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWMgZ2VuZXJhdGlvbiBvZiBVVUlEIGZvciB0aGUgZXZlbnQgZnJhZ21lbnQuIFRoaXMgaXNcclxuICAgKiB1c2VmdWwgd2hlbiB0cmFja2luZyBldmVudHMgZm9yIHN1YnN5c3RlbXMgdGhhdCBhbHJlYWR5IGdlbmVyYXRlIFVVSURzIHNvXHJcbiAgICogdG8gYXZvaWQgdW5uZWNlc3NhcnkgbG9va3VwcyBhbmQgcmVkdWNlIGFjY2lkZW50YWwgZHVwbGljYXRpb24uXHJcbiAgICovXHJcbiAgdW5pcXVlSWRlbnRpZmllcj86IHN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEYXRhIHNlbnQgdG8gdGhlIGBzZWdtZW50LnRyYWNrYCBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTZWdtZW50RXZlbnRQYXlsb2FkID0ge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBNZXRhTWV0cmljcyBpZCBmb3IgdGhlIHVzZXIuXHJcbiAgICovXHJcbiAgdXNlcklkPzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIEFuIGFub255bW91cyBJRCB0aGF0IGlzIHVzZWQgdG8gdHJhY2sgc2Vuc2l0aXZlIGRhdGEgd2hpbGUgcHJlc2VydmluZ1xyXG4gICAqIGFub255bWl0eS5cclxuICAgKi9cclxuICBhbm9ueW1vdXNJZD86IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2suXHJcbiAgICovXHJcbiAgZXZlbnQ6IHN0cmluZztcclxuICAvKipcclxuICAgKiBQcm9wZXJ0aWVzIHRvIGF0dGFjaCB0byB0aGUgZXZlbnQuXHJcbiAgICovXHJcbiAgcHJvcGVydGllczogb2JqZWN0O1xyXG4gIC8qKlxyXG4gICAqIFRoZSBjb250ZXh0IHRoZSBldmVudCBvY2N1cnJlZCBpbi5cclxuICAgKi9cclxuICBjb250ZXh0OiBNZXRhTWV0cmljc0NvbnRleHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRGF0YSBzZW50IHRvIE1ldGFNZXRyaWNzIGZvciBwYWdlIHZpZXdzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgTWV0YU1ldHJpY3NQYWdlUGF5bG9hZCA9IHtcclxuICAvKipcclxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFnZSB0aGF0IHdhcyB2aWV3ZWQuXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSB2YXJpYWRpYyBwYXJ0cyBvZiB0aGUgcGFnZSBVUkwuXHJcbiAgICpcclxuICAgKiBFeGFtcGxlOiBJZiB0aGUgcm91dGUgaXMgYC9hc3NldC86YXNzZXRgIGFuZCB0aGUgcGF0aCBpcyBgL2Fzc2V0L0VUSGAsXHJcbiAgICogdGhlIGBwYXJhbXNgIHByb3BlcnR5IHdvdWxkIGJlIGB7IGFzc2V0OiAnRVRIJyB9YC5cclxuICAgKi9cclxuICBwYXJhbXM/OiBvYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogVGhlIGVudmlyb25tZW50IHR5cGUgdGhhdCB0aGUgcGFnZSB3YXMgdmlld2VkIGluLlxyXG4gICAqL1xyXG4gIGVudmlyb25tZW50VHlwZTogRW52aXJvbm1lbnRUeXBlO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBkZXRhaWxzIG9mIHRoZSBwYWdlLlxyXG4gICAqL1xyXG4gIHBhZ2U/OiBNZXRhTWV0cmljc1BhZ2VPYmplY3Q7XHJcbiAgLyoqXHJcbiAgICogVGhlIGRhcHAgdGhhdCB0cmlnZ2VyZWQgdGhlIHBhZ2Ugdmlldy5cclxuICAgKi9cclxuICByZWZlcnJlcj86IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3Q7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBNZXRhTWV0cmljc1BhZ2VPcHRpb25zID0ge1xyXG4gIC8qKlxyXG4gICAqIElzIHRoZSBjdXJyZW50IHBhdGggb25lIG9mIHRoZSBwYWdlcyBpbiB0aGUgb25ib2FyZGluZyB3b3JrZmxvdz8gKElmIHRoaXNcclxuICAgKiBpcyB0cnVlIGFuZCBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgaXMgbnVsbCwgdGhlbiB0aGUgcGFnZSB2aWV3IHdpbGwgYmVcclxuICAgKiB0cmFja2VkLilcclxuICAgKi9cclxuICBpc09wdEluUGF0aD86IGJvb2xlYW47XHJcbn07XHJcblxyXG4vKipcclxuICogRGF0YSBzZW50IHRvIE1ldGFNZXRyaWNzIGZvciB1c2VyIHRyYWl0cy5cclxuICovXHJcbmV4cG9ydCB0eXBlIE1ldGFNZXRyaWNzVXNlclRyYWl0cyA9IHtcclxuICAvKipcclxuICAgKiBUaGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHVzZXIncyBhZGRyZXNzIGJvb2suXHJcbiAgICovXHJcbiAgYWRkcmVzc19ib29rX2VudHJpZXM/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogVGhlIHR5cGUgb2YgbGVkZ2VyIGNvbm5lY3Rpb24gc2V0IGJ5IHVzZXIgcHJlZmVyZW5jZS5cclxuICAgKi9cclxuICBsZWRnZXJfY29ubmVjdGlvbl90eXBlPzogTGVkZ2VyVHJhbnNwb3J0VHlwZXM7XHJcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgY29uc2lzdGluZyBvZiBjaGFpbiBJRHMgdGhhdCByZXByZXNlbnQgdGhlIG5ldHdvcmtzIGFkZGVkIGJ5IHRoZVxyXG4gICAqIHVzZXIuXHJcbiAgICovXHJcbiAgbmV0d29ya3NfYWRkZWQ/OiBzdHJpbmdbXTtcclxuICAvKipcclxuICAgKiBBbiBhcnJheSBjb25zaXN0aW5nIG9mIGNoYWluIElEcyB0aGF0IHJlcHJlc2VudCB0aGUgbmV0d29ya3MgYWRkZWQgYnkgdGhlXHJcbiAgICogdXNlciB0aGF0IGRvIG5vdCBoYXZlIGEgdGlja2VyLlxyXG4gICAqL1xyXG4gIG5ldHdvcmtzX3dpdGhvdXRfdGlja2VyPzogc3RyaW5nW107XHJcbiAgLyoqXHJcbiAgICogRG9lcyB0aGUgdXNlciBoYXZlIHRoZSBBdXRvZGV0ZWN0IE5GVHMgZmVhdHVyZSBlbmFibGVkP1xyXG4gICAqL1xyXG4gIG5mdF9hdXRvZGV0ZWN0aW9uX2VuYWJsZWQ/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgaWRlbnRpdGllcyAoYWNjb3VudHMpIGFkZGVkIHRvIHRoZVxyXG4gICAqIHVzZXIncyB3YWxsZXQuXHJcbiAgICovXHJcbiAgbnVtYmVyX29mX2FjY291bnRzPzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgYW1vdW50IG9mIE5GVCBjb2xsZWN0aW9ucyBmcm9tIHdoaWNoIHRoZSB1c2VyXHJcbiAgICogcG9zc2Vzc2VzIE5GVHMuXHJcbiAgICovXHJcbiAgbnVtYmVyX29mX25mdF9jb2xsZWN0aW9ucz86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGFtb3VudCBvZiBhbGwgTkZUcyB0aGUgdXNlciBwb3NzZXNzZXMgYWNyb3NzIGFsbFxyXG4gICAqIG5ldHdvcmtzIGFuZCBhY2NvdW50cy5cclxuICAgKi9cclxuICBudW1iZXJfb2ZfbmZ0cz86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VuIGNvbnRyYWN0cyB0aGUgdXNlciBoYXMgYWNyb3NzIGFsbCBuZXR3b3JrcyBhbmRcclxuICAgKiBhY2NvdW50cy5cclxuICAgKi9cclxuICBudW1iZXJfb2ZfdG9rZW5zPzogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIERvZXMgdGhlIHVzZXIgaGF2ZSB0aGUgT3BlblNlYSBBUEkgZW5hYmxlZD9cclxuICAgKi9cclxuICBvcGVuc2VhX2FwaV9lbmFibGVkPzogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBEb2VzIHRoZSB1c2VyIGhhdmUgM0JveCBzeW5jIGVuYWJsZWQ/XHJcbiAgICpcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqL1xyXG4gIHRocmVlX2JveF9lbmFibGVkPzogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBXaGljaCB0aGVtZSB0aGUgdXNlciBoYXMgc2VsZWN0ZWQuXHJcbiAgICovXHJcbiAgdGhlbWU/OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogRG9lcyB0aGUgdXNlciBoYXZlIHRva2VuIGRldGVjdGlvbiBlbmFibGVkP1xyXG4gICAqL1xyXG4gIHRva2VuX2RldGVjdGlvbl9lbmFibGVkPzogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBEb2VzIHRoZSB1c2VyIGhhdmUgZGVza3RvcCBlbmFibGVkP1xyXG4gICAqL1xyXG4gIGRlc2t0b3BfZW5hYmxlZD86IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgc2VjdXJpdHkgcHJvdmlkZXIgZmVhdHVyZSBoYXMgYmVlbiBlbmFibGVkLlxyXG4gICAqL1xyXG4gIHNlY3VyaXR5X3Byb3ZpZGVycz86IHN0cmluZ1tdO1xyXG5cbn07XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc1VzZXJUcmFpdCB7XHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSB1c2VyIGFkZHMgb3IgbW9kaWZpZXMgYWRkcmVzc2VzIGluIHRoZSBhZGRyZXNzIGJvb2suXHJcbiAgICovXHJcbiAgQWRkcmVzc0Jvb2tFbnRyaWVzID0gJ2FkZHJlc3NfYm9va19lbnRyaWVzJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgaW5zdGFsbGVkIHRoZSBleHRlbnNpb24uXHJcbiAgICovXHJcbiAgSW5zdGFsbERhdGVFeHQgPSAnaW5zdGFsbF9kYXRlX2V4dCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBMZWRnZXIgTGl2ZSBjb25uZWN0aW9uIHR5cGUgaXMgY2hhbmdlZC5cclxuICAgKi9cclxuICBMZWRnZXJDb25uZWN0aW9uVHlwZSA9ICdsZWRnZXJfY29ubmVjdGlvbl90eXBlJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgbW9kaWZpZXMgbmV0d29ya3MuXHJcbiAgICovXHJcbiAgTmV0d29ya3NBZGRlZCA9ICduZXR3b3Jrc19hZGRlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIG5ldHdvcmtzIHRoYXQgbGFjayBhIHRpY2tlci5cclxuICAgKi9cclxuICBOZXR3b3Jrc1dpdGhvdXRUaWNrZXIgPSAnbmV0d29ya3Nfd2l0aG91dF90aWNrZXInLFxyXG4gIC8qKlxyXG4gICAqIElkZW50aWZpZWQgd2hlbiB0aGUgXCJBdXRvZGV0ZWN0IE5GVHNcIiBmZWF0dXJlIGlzIHRvZ2dsZWQuXHJcbiAgICovXHJcbiAgTmZ0QXV0b2RldGVjdGlvbkVuYWJsZWQgPSAnbmZ0X2F1dG9kZXRlY3Rpb25fZW5hYmxlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIGlkZW50aXRpZXMgY2hhbmdlLlxyXG4gICAqL1xyXG4gIE51bWJlck9mQWNjb3VudHMgPSAnbnVtYmVyX29mX2FjY291bnRzJyxcclxuICAvKipcclxuICAgKiBUaGUgbnVtYmVyIG9mIHVuaXF1ZSBORlQgYWRkcmVzc2VzLlxyXG4gICAqL1xyXG4gIE51bWJlck9mTmZ0Q29sbGVjdGlvbnMgPSAnbnVtYmVyX29mX25mdF9jb2xsZWN0aW9ucycsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBudW1iZXIgb2YgTkZUcyBvd25lZCBieSB0aGUgdXNlciBjaGFuZ2VzLlxyXG4gICAqL1xyXG4gIE51bWJlck9mTmZ0cyA9ICdudW1iZXJfb2ZfbmZ0cycsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBudW1iZXIgb2YgdG9rZW5zIGNoYW5nZS5cclxuICAgKi9cclxuICBOdW1iZXJPZlRva2VucyA9ICdudW1iZXJfb2ZfdG9rZW5zJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIE9wZW5TZWEgQVBJIGlzIGVuYWJsZWQuXHJcbiAgICovXHJcbiAgT3BlblNlYUFwaUVuYWJsZWQgPSAnb3BlbnNlYV9hcGlfZW5hYmxlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSB1c2VyJ3MgdGhlbWUgY2hhbmdlcy5cclxuICAgKi9cclxuICBUaGVtZSA9ICd0aGVtZScsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSAzQm94IGZlYXR1cmUgaXMgdG9nZ2xlZC5cclxuICAgKlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICovXHJcbiAgVGhyZWVCb3hFbmFibGVkID0gJ3RocmVlX2JveF9lbmFibGVkJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHRva2VuIGRldGVjdGlvbiBmZWF0dXJlIGlzIHRvZ2dsZWQuXHJcbiAgICovXHJcbiAgVG9rZW5EZXRlY3Rpb25FbmFibGVkID0gJ3Rva2VuX2RldGVjdGlvbl9lbmFibGVkJyxcclxuICAvKipcclxuICAgKiBJZGVudGlmaWVkIHdoZW4gdGhlIHVzZXIgZW5hYmxlcyBkZXNrdG9wLlxyXG4gICAqL1xyXG4gIERlc2t0b3BFbmFibGVkID0gJ2Rlc2t0b3BfZW5hYmxlZCcsXHJcbiAgLyoqXHJcbiAgICogSWRlbnRpZmllZCB3aGVuIHRoZSBzZWN1cml0eSBwcm92aWRlciBmZWF0dXJlIGlzIGVuYWJsZWQuXHJcbiAgICovXHJcbiAgU2VjdXJpdHlQcm92aWRlcnMgPSAnc2VjdXJpdHlfcHJvdmlkZXJzJyxcclxuXG59XHJcblxyXG4vKipcclxuICogTWl4cGFuZWwgY29udmVydHMgdGhlIHplcm8gYWRkcmVzcyB2YWx1ZSB0byBhIHRydWx5IGFub255bW91cyBldmVudCwgd2hpY2hcclxuICogc3BlZWRzIHVwIHJlcG9ydGluZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1FVEFNRVRSSUNTX0FOT05ZTU9VU19JRCA9ICcweDAwMDAwMDAwMDAwMDAwMDAnO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gaWRlbnRpZnkgZXZlbnRzIHRoYXQgYXJlIHRyaWdnZXJlZCBieSB0aGUgYmFja2dyb3VuZCBwcm9jZXNzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1FVEFNRVRSSUNTX0JBQ0tHUk9VTkRfUEFHRV9PQkpFQ1Q6IE1ldGFNZXRyaWNzUGFnZU9iamVjdCA9IHtcclxuICBwYXRoOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXHJcbiAgdGl0bGU6ICdCYWNrZ3JvdW5kIFByb2Nlc3MnLFxyXG4gIHVybDogJy9iYWNrZ3JvdW5kLXByb2Nlc3MnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RJRklDQVRJT05fQ0xPU0UgPSAnQ2FuY2VsIFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RJRklDQVRJT05fQ0xPU0VfU0lHID1cclxuICAnQ2FuY2VsIFNpZyBSZXF1ZXN0IFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudE5hbWUge1xyXG4gIEFjY291bnRBZGRlZCA9ICdBY2NvdW50IEFkZGVkJyxcclxuICBBY2NvdW50QWRkU2VsZWN0ZWQgPSAnQWNjb3VudCBBZGQgU2VsZWN0ZWQnLFxyXG4gIEFjY291bnRBZGRGYWlsZWQgPSAnQWNjb3VudCBBZGQgRmFpbGVkJyxcclxuICBBY2NvdW50UGFzc3dvcmRDcmVhdGVkID0gJ0FjY291bnQgUGFzc3dvcmQgQ3JlYXRlZCcsXHJcbiAgQWNjb3VudFJlc2V0ID0gJ0FjY291bnQgUmVzZXQnLFxyXG4gIEFjY291bnRSZW5hbWVkID0gJ0FjY291bnQgUmVuYW1lZCcsXHJcbiAgQXBwSW5zdGFsbGVkID0gJ0FwcCBJbnN0YWxsZWQnLFxyXG4gIEFwcFVubG9ja2VkID0gJ0FwcCBVbmxvY2tlZCcsXHJcbiAgQXBwVW5sb2NrZWRGYWlsZWQgPSAnQXBwIFVubG9ja2VkIEZhaWxlZCcsXHJcbiAgQXBwTG9ja2VkID0gJ0FwcCBMb2NrZWQnLFxyXG4gIEFwcFdpbmRvd0V4cGFuZGVkID0gJ0FwcCBXaW5kb3cgRXhwYW5kZWQnLFxyXG4gIEJyaWRnZUxpbmtDbGlja2VkID0gJ0JyaWRnZSBMaW5rIENsaWNrZWQnLFxyXG4gIERlY3J5cHRpb25BcHByb3ZlZCA9ICdEZWNyeXB0aW9uIEFwcHJvdmVkJyxcclxuICBEZWNyeXB0aW9uUmVqZWN0ZWQgPSAnRGVjcnlwdGlvbiBSZWplY3RlZCcsXHJcbiAgRGVjcnlwdGlvblJlcXVlc3RlZCA9ICdEZWNyeXB0aW9uIFJlcXVlc3RlZCcsXHJcbiAgRW5jcnlwdGlvblB1YmxpY0tleUFwcHJvdmVkID0gJ0VuY3J5cHRpb24gQXBwcm92ZWQnLFxyXG4gIEVuY3J5cHRpb25QdWJsaWNLZXlSZWplY3RlZCA9ICdFbmNyeXB0aW9uIFJlamVjdGVkJyxcclxuICBFbmNyeXB0aW9uUHVibGljS2V5UmVxdWVzdGVkID0gJ0VuY3J5cHRpb24gUmVxdWVzdGVkJyxcclxuICBFeHRlcm5hbExpbmtDbGlja2VkID0gJ0V4dGVybmFsIExpbmsgQ2xpY2tlZCcsXHJcbiAgS2V5RXhwb3J0U2VsZWN0ZWQgPSAnS2V5IEV4cG9ydCBTZWxlY3RlZCcsXHJcbiAgS2V5RXhwb3J0UmVxdWVzdGVkID0gJ0tleSBFeHBvcnQgUmVxdWVzdGVkJyxcclxuICBLZXlFeHBvcnRGYWlsZWQgPSAnS2V5IEV4cG9ydCBGYWlsZWQnLFxyXG4gIEtleUV4cG9ydENhbmNlbGVkID0gJ0tleSBFeHBvcnQgQ2FuY2VsZWQnLFxyXG4gIEtleUV4cG9ydFJldmVhbGVkID0gJ0tleSBNYXRlcmlhbCBSZXZlYWxlZCcsXHJcbiAgS2V5RXhwb3J0Q29waWVkID0gJ0tleSBNYXRlcmlhbCBDb3BpZWQnLFxyXG4gIEtleVRva2VuRGV0ZWN0aW9uU2VsZWN0ZWQgPSAnS2V5IFRva2VuIERldGVjdGlvbiBTZWxlY3RlZCcsXHJcbiAgS2V5R2xvYmFsU2VjdXJpdHlUb2dnbGVTZWxlY3RlZCA9ICdLZXkgR2xvYmFsIFNlY3VyaXR5L1ByaXZhY3kgU2V0dGluZ3MnLFxyXG4gIEtleUJhbGFuY2VUb2tlblByaWNlQ2hlY2tlciA9ICdLZXkgU2hvdyBCYWxhbmNlIGFuZCBUb2tlbiBQcmljZSBDaGVja2VyIFNldHRpbmdzJyxcclxuICBLZXlHYXNGZWVFc3RpbWF0aW9uQnV5U3dhcFRva2VucyA9ICdLZXkgU2hvdyBHYXMgRmVlIEVzdGltYXRpb24sIEJ1eSBDcnlwdG8gYW5kIFN3YXAgVG9rZW5zJyxcclxuICBLZXlBdXRvRGV0ZWN0VG9rZW5zID0gJ0tleSBBdXRvZGV0ZWN0IHRva2VucycsXHJcbiAgS2V5QmF0Y2hBY2NvdW50QmFsYW5jZVJlcXVlc3RzID0gJ0tleSBCYXRjaCBhY2NvdW50IGJhbGFuY2UgcmVxdWVzdHMnLFxyXG4gIE1ldHJpY3NPcHRJbiA9ICdNZXRyaWNzIE9wdCBJbicsXHJcbiAgTWV0cmljc09wdE91dCA9ICdNZXRyaWNzIE9wdCBPdXQnLFxyXG4gIE5hdkFjY291bnRNZW51T3BlbmVkID0gJ0FjY291bnQgTWVudSBPcGVuZWQnLFxyXG4gIE5hdkFjY291bnREZXRhaWxzT3BlbmVkID0gJ0FjY291bnQgRGV0YWlscyBPcGVuZWQnLFxyXG4gIE5hdkNvbm5lY3RlZFNpdGVzT3BlbmVkID0gJ0Nvbm5lY3RlZCBTaXRlcyBPcGVuZWQnLFxyXG4gIE5hdk1haW5NZW51T3BlbmVkID0gJ01haW4gTWVudSBPcGVuZWQnLFxyXG4gIE5hdk5ldHdvcmtNZW51T3BlbmVkID0gJ05ldHdvcmsgTWVudSBPcGVuZWQnLFxyXG4gIE5hdlNldHRpbmdzT3BlbmVkID0gJ1NldHRpbmdzIE9wZW5lZCcsXHJcbiAgTmF2QWNjb3VudFN3aXRjaGVkID0gJ0FjY291bnQgU3dpdGNoZWQnLFxyXG4gIE5hdk5ldHdvcmtTd2l0Y2hlZCA9ICdOZXR3b3JrIFN3aXRjaGVkJyxcclxuICBOYXZCdXlCdXR0b25DbGlja2VkID0gJ0J1eSBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgTmF2U2VuZEJ1dHRvbkNsaWNrZWQgPSAnU2VuZCBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgTmF2U3dhcEJ1dHRvbkNsaWNrZWQgPSAnU3dhcCBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgTmZ0QWRkZWQgPSAnTkZUIEFkZGVkJyxcclxuICBPbmJvYXJkaW5nV2VsY29tZSA9ICdBcHAgSW5zdGFsbGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0Q3JlYXRpb25TdGFydGVkID0gJ1dhbGxldCBTZXR1cCBTZWxlY3RlZCcsXHJcbiAgT25ib2FyZGluZ1dhbGxldEltcG9ydFN0YXJ0ZWQgPSAnV2FsbGV0IEltcG9ydCBTdGFydGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0Q3JlYXRpb25BdHRlbXB0ZWQgPSAnV2FsbGV0IFBhc3N3b3JkIENyZWF0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVN0YXJ0ZWQgPSAnU1JQIEJhY2t1cCBTZWxlY3RlZCcsXHJcbiAgT25ib2FyZGluZ1dhbGxldFNlY3VyaXR5U2tpcEluaXRpYXRlZCA9ICdTUlAgU2tpcCBCYWNrdXAgU2VsZWN0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVNraXBDb25maXJtZWQgPSAnU1JQIEJhY2t1cCBTa2lwcGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlTa2lwQ2FuY2VsZWQgPSAnU1JQIFNraXAgQmFja3VwIENhbmNlbGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlQaHJhc2VSZXZlYWxlZCA9ICdTUlAgUmV2ZWFsZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRTZWN1cml0eVBocmFzZVdyaXR0ZW5Eb3duID0gJ1NSUCBCYWNrdXAgQ29uZmlybSBEaXNwbGF5JyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2VjdXJpdHlQaHJhc2VDb25maXJtZWQgPSAnU1JQIEJhY2t1cCBDb25maXJtZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRDcmVhdGlvbkNvbXBsZXRlID0gJ1dhbGxldCBDcmVhdGVkJyxcclxuICBPbmJvYXJkaW5nV2FsbGV0U2V0dXBDb21wbGV0ZSA9ICdBcHBsaWNhdGlvbiBPcGVuZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRBZHZhbmNlZFNldHRpbmdzID0gJ1NldHRpbmdzIFVwZGF0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRJbXBvcnRBdHRlbXB0ZWQgPSAnV2FsbGV0IEltcG9ydCBBdHRlbXB0ZWQnLFxyXG4gIE9uYm9hcmRpbmdXYWxsZXRWaWRlb1BsYXkgPSAnU1JQIEludHJvIFZpZGVvIFBsYXllZCcsXHJcbiAgT25ib2FyZGluZ1R3aXR0ZXJDbGljayA9ICdFeHRlcm5hbCBMaW5rIENsaWNrZWQnLFxyXG4gIE9ucmFtcFByb3ZpZGVyU2VsZWN0ZWQgPSAnT24tcmFtcCBQcm92aWRlciBTZWxlY3RlZCcsXHJcbiAgUGVybWlzc2lvbnNBcHByb3ZlZCA9ICdQZXJtaXNzaW9ucyBBcHByb3ZlZCcsXHJcbiAgUGVybWlzc2lvbnNSZWplY3RlZCA9ICdQZXJtaXNzaW9ucyBSZWplY3RlZCcsXHJcbiAgUGVybWlzc2lvbnNSZXF1ZXN0ZWQgPSAnUGVybWlzc2lvbnMgUmVxdWVzdGVkJyxcclxuICBQaGlzaGluZ1BhZ2VEaXNwbGF5ZWQgPSAnUGhpc2hpbmcgUGFnZSBEaXNwbGF5ZWQnLFxyXG4gIFBvcnRmb2xpb0xpbmtDbGlja2VkID0gJ1BvcnRmb2xpbyBMaW5rIENsaWNrZWQnLFxyXG4gIFByb3ZpZGVyTWV0aG9kQ2FsbGVkID0gJ1Byb3ZpZGVyIE1ldGhvZCBDYWxsZWQnLFxyXG4gIFB1YmxpY0FkZHJlc3NDb3BpZWQgPSAnUHVibGljIEFkZHJlc3MgQ29waWVkJyxcclxuICBTZXJ2aWNlV29ya2VyUmVzdGFydGVkID0gJ1NlcnZpY2UgV29ya2VyIFJlc3RhcnRlZCcsXHJcbiAgU2lnbmF0dXJlQXBwcm92ZWQgPSAnU2lnbmF0dXJlIEFwcHJvdmVkJyxcclxuICBTaWduYXR1cmVGYWlsZWQgPSAnU2lnbmF0dXJlIEZhaWxlZCcsXHJcbiAgU2lnbmF0dXJlUmVqZWN0ZWQgPSAnU2lnbmF0dXJlIFJlamVjdGVkJyxcclxuICBTaWduYXR1cmVSZXF1ZXN0ZWQgPSAnU2lnbmF0dXJlIFJlcXVlc3RlZCcsXHJcbiAgU3JwUmV2ZWFsU3RhcnRlZCA9ICdSZXZlYWwgU1JQIEluaXRpYXRlZCcsXHJcbiAgU3JwUmV2ZWFsQ2xpY2tlZCA9ICdDbGlja2VkIFJldmVhbCBTZWNyZXQgUmVjb3ZlcnknLFxyXG4gIFNycFJldmVhbFZpZXdlZCA9ICdWaWV3cyBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5JyxcclxuICBTcnBSZXZlYWxCYWNrQnV0dG9uQ2xpY2tlZCA9ICdDbGlja2VkIEJhY2sgb24gUmV2ZWFsIFNSUCBQYXNzd29yZCBQYWdlJyxcclxuICBTcnBSZXZlYWxDYW5jZWxsZWQgPSAnUmV2ZWFsIFNSUCBDYW5jZWxsZWQnLFxyXG4gIFNycFJldmVhbENhbmNlbEJ1dHRvbkNsaWNrZWQgPSAnQ2xpY2tzIENhbmNlbCBvbiBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5IFBocmFzZSBQYWdlJyxcclxuICBTcnBSZXZlYWxDbG9zZUNsaWNrZWQgPSAnQ2xpY2tzIENMT1NFIHdpdGggU1JQJyxcclxuICBTcnBSZXZlYWxOZXh0Q2xpY2tlZCA9ICdDbGlja3MgTmV4dCBvbiBSZXZlYWwgU2VjcmV0IFJlY292ZXJ5IFBocmFzZScsXHJcbiAgU3JwSG9sZFRvUmV2ZWFsQ2xpY2tTdGFydGVkID0gJ1JldmVhbCBTUlAgQ2xpY2sgU3RhcnRlZCcsXHJcbiAgU3JwSG9sZFRvUmV2ZWFsQ2xvc2VDbGlja2VkID0gJ0Nsb3NlcyBIb2xkIFRvIFJldmVhbCBTUlAnLFxyXG4gIFNycEhvbGRUb1JldmVhbENvbXBsZXRlZCA9ICdSZXZlYWwgU1JQIENvbXBsZXRlZCcsXHJcbiAgU3JwVmlld3NTcnBRUiA9ICdWaWV3cyBTUlAgUVIgQ29kZScsXHJcbiAgU3JwVmlld1NycFRleHQgPSAnVmlld3MgU1JQJyxcclxuICBTcnBDb3BpZWRUb0NsaXBib2FyZCA9ICdDb3BpZXMgU1JQIHRvIGNsaXBib2FyZCcsXHJcbiAgU3JwVG9Db25maXJtQmFja3VwID0gJ1NSUCBCYWNrdXAgQ29uZmlybSBEaXNwbGF5ZWQnLFxyXG4gIFN1cHBvcnRMaW5rQ2xpY2tlZCA9ICdTdXBwb3J0IExpbmsgQ2xpY2tlZCcsXHJcbiAgVGVybXNPZlVzZVNob3duID0gJ1Rlcm1zIG9mIFVzZSBTaG93bicsXHJcbiAgVGVybXNPZlVzZUFjY2VwdGVkID0gJ1Rlcm1zIG9mIFVzZSBBY2NlcHRlZCcsXHJcbiAgVG9rZW5JbXBvcnRCdXR0b25DbGlja2VkID0gJ0ltcG9ydCBUb2tlbiBCdXR0b24gQ2xpY2tlZCcsXHJcbiAgVG9rZW5TY3JlZW5PcGVuZWQgPSAnVG9rZW4gU2NyZWVuIE9wZW5lZCcsXHJcbiAgVG9rZW5BZGRlZCA9ICdUb2tlbiBBZGRlZCcsXHJcbiAgVG9rZW5EZXRlY3RlZCA9ICdUb2tlbiBEZXRlY3RlZCcsXHJcbiAgVG9rZW5IaWRkZW4gPSAnVG9rZW4gSGlkZGVuJyxcclxuICBUb2tlbkltcG9ydENhbmNlbGVkID0gJ1Rva2VuIEltcG9ydCBDYW5jZWxlZCcsXHJcbiAgVG9rZW5JbXBvcnRDbGlja2VkID0gJ1Rva2VuIEltcG9ydCBDbGlja2VkJyxcclxuICBXYWxsZXRTZXR1cFN0YXJ0ZWQgPSAnV2FsbGV0IFNldHVwIFNlbGVjdGVkJyxcclxuICBXYWxsZXRTZXR1cENhbmNlbGVkID0gJ1dhbGxldCBTZXR1cCBDYW5jZWxlZCcsXHJcbiAgV2FsbGV0U2V0dXBGYWlsZWQgPSAnV2FsbGV0IFNldHVwIEZhaWxlZCcsXHJcbiAgV2FsbGV0Q3JlYXRlZCA9ICdXYWxsZXQgQ3JlYXRlZCcsXHJcblxuICBBY2NvdW50RGV0YWlsTWVudU9wZW5lZCA9ICdBY2NvdW50IERldGFpbHMgTWVudSBPcGVuZWQnLFxyXG4gIEJsb2NrRXhwbG9yZXJMaW5rQ2xpY2tlZCA9ICdCbG9jayBFeHBsb3JlciBDbGlja2VkJyxcclxuICBBY2NvdW50UmVtb3ZlZCA9ICdBY2NvdW50IFJlbW92ZWQnLFxyXG4gIFRlc3ROZXR3b3Jrc0Rpc3BsYXllZCA9ICdUZXN0IE5ldHdvcmtzIERpc3BsYXllZCcsXHJcbiAgQWRkTmV0d29ya0J1dHRvbkNsaWNrID0gJ0FkZCBOZXR3b3JrIEJ1dHRvbiBDbGlja2VkJyxcclxuICBDdXN0b21OZXR3b3JrQWRkZWQgPSAnQ3VzdG9tIE5ldHdvcmsgQWRkZWQnLFxyXG4gIFRva2VuRGV0YWlsc09wZW5lZCA9ICdUb2tlbiBEZXRhaWxzIE9wZW5lZCcsXHJcbiAgTmZ0U2NyZWVuT3BlbmVkID0gJ05GVCBTY3JlZW4gT3BlbmVkJyxcclxuICBBY3Rpdml0eVNjcmVlbk9wZW5lZCA9ICdBY3Rpdml0eSBTY3JlZW4gT3BlbmVkJyxcclxuICBXaGF0c05ld1ZpZXdlZCA9IGBXaGF0J3MgTmV3IFZpZXdlZGAsXHJcbiAgV2hhdHNOZXdDbGlja2VkID0gYFdoYXQncyBOZXcgTGluayBDbGlja2VkYCxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudEFjY291bnRUeXBlIHtcclxuICBEZWZhdWx0ID0gJ21ldGFtYXNrJyxcclxuICBIYXJkd2FyZSA9ICdoYXJkd2FyZScsXHJcbiAgSW1wb3J0ZWQgPSAnaW1wb3J0ZWQnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc0V2ZW50QWNjb3VudEltcG9ydFR5cGUge1xyXG4gIEpzb24gPSAnanNvbicsXHJcbiAgUHJpdmF0ZUtleSA9ICdwcml2YXRlX2tleScsXHJcbiAgU3JwID0gJ3NycCcsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRDYXRlZ29yeSB7XHJcbiAgQWNjb3VudHMgPSAnQWNjb3VudHMnLFxyXG4gIEFwcCA9ICdBcHAnLFxyXG4gIEF1dGggPSAnQXV0aCcsXHJcbiAgQmFja2dyb3VuZCA9ICdCYWNrZ3JvdW5kJyxcclxuICBEZXNrdG9wID0gJ0Rlc2t0b3AnLFxyXG4gIC8vIFRoZSBUeXBlU2NyaXB0IEVTTGludCBydWxlIGlzIGluY29ycmVjdGx5IG1hcmtpbmcgdGhpcyBsaW5lLlxyXG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93ICovXHJcbiAgRXJyb3IgPSAnRXJyb3InLFxyXG4gIEZvb3RlciA9ICdGb290ZXInLFxyXG4gIEhvbWUgPSAnSG9tZScsXHJcbiAgSW5wYWdlUHJvdmlkZXIgPSAnaW5wYWdlX3Byb3ZpZGVyJyxcclxuICBLZXlzID0gJ0tleXMnLFxyXG4gIE1lc3NhZ2VzID0gJ01lc3NhZ2VzJyxcclxuICBOYXZpZ2F0aW9uID0gJ05hdmlnYXRpb24nLFxyXG4gIE5ldHdvcmsgPSAnTmV0d29yaycsXHJcbiAgT25ib2FyZGluZyA9ICdPbmJvYXJkaW5nJyxcclxuICBQaGlzaGluZyA9ICdQaGlzaGluZycsXHJcbiAgUmV0ZW50aW9uID0gJ1JldGVudGlvbicsXHJcbiAgU2VydmljZVdvcmtlcnMgPSAnc2VydmljZV93b3JrZXJzJyxcclxuICBTZXR0aW5ncyA9ICdTZXR0aW5ncycsXHJcbiAgU25hcHMgPSAnU25hcHMnLFxyXG4gIFN3YXBzID0gJ1N3YXBzJyxcclxuICBUcmFuc2FjdGlvbnMgPSAnVHJhbnNhY3Rpb25zJyxcclxuICBXYWxsZXQgPSAnV2FsbGV0JyxcclxuXG4gIFRva2VucyA9ICdUb2tlbnMnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc0V2ZW50TGlua1R5cGUge1xyXG4gIEFjY291bnRUcmFja2VyID0gJ0FjY291bnQgVHJhY2tlcicsXHJcbiAgQmxvY2tFeHBsb3JlciA9ICdCbG9jayBFeHBsb3JlcicsXHJcbiAgVG9rZW5UcmFja2VyID0gJ1Rva2VuIFRyYWNrZXInLFxyXG4gIFRyYW5zYWN0aW9uQmxvY2tFeHBsb3JlciA9ICdUcmFuc2FjdGlvbiBCbG9jayBFeHBsb3JlcicsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRLZXlUeXBlIHtcclxuICBQa2V5ID0gJ3ByaXZhdGVfa2V5JyxcclxuICBTcnAgPSAnc3JwJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NOZXR3b3JrRXZlbnRTb3VyY2Uge1xyXG4gIEN1c3RvbU5ldHdvcmtGb3JtID0gJ2N1c3RvbV9uZXR3b3JrX2Zvcm0nLFxyXG4gIFBvcHVsYXJOZXR3b3JrTGlzdCA9ICdwb3B1bGFyX25ldHdvcmtfbGlzdCcsXHJcbiAgRGFwcCA9ICdkYXBwJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NTd2Fwc0V2ZW50U291cmNlIHtcclxuICBNYWluVmlldyA9ICdNYWluIFZpZXcnLFxyXG4gIFRva2VuVmlldyA9ICdUb2tlbiBWaWV3JyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NUb2tlbkV2ZW50U291cmNlIHtcclxuICBDdXN0b20gPSAnY3VzdG9tJyxcclxuICBEYXBwID0gJ2RhcHAnLFxyXG4gIERldGVjdGVkID0gJ2RldGVjdGVkJyxcclxuICBMaXN0ID0gJ2xpc3QnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBNZXRhTWV0cmljc1RyYW5zYWN0aW9uRXZlbnRTb3VyY2Uge1xyXG4gIERhcHAgPSAnZGFwcCcsXHJcbiAgVXNlciA9ICd1c2VyJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWV0YU1ldHJpY3NFdmVudExvY2F0aW9uIHtcclxuICBUb2tlbkRldGFpbHMgPSAndG9rZW5fZGV0YWlscycsXHJcbiAgVG9rZW5EZXRlY3Rpb24gPSAndG9rZW5fZGV0ZWN0aW9uJyxcclxuICBUb2tlbk1lbnUgPSAndG9rZW5fbWVudScsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzRXZlbnRVaUN1c3RvbWl6YXRpb24ge1xyXG4gIEZsYWdnZWRBc01hbGljaW91cyA9ICdmbGFnZ2VkX2FzX21hbGljaW91cycsXHJcbiAgRmxhZ2dlZEFzU2FmZXR5VW5rbm93biA9ICdmbGFnZ2VkX2FzX3NhZmV0eV91bmtub3duJyxcclxuICBTaXdlID0gJ3NpZ25faW5fd2l0aF9ldGhlcmV1bScsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWx1ZXMgdGhhdCBjYW4gdXNlZCBpbiB0aGUgXCJwcm9wZXJ0aWVzXCIgdHJhY2tpbmcgb2JqZWN0IGFzIGtleXMsIGUuZy4gYHtcclxuICogbG9jYXRpb246ICdIb21lJyB9YC5cclxuICovXHJcbmV4cG9ydCBlbnVtIE1ldGFNZXRyaWNzQ29udGV4dFByb3Age1xyXG4gIFBhZ2VUaXRsZSA9ICdsb2NhdGlvbicsXHJcbn1cclxuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSwgcGljayB9IGZyb20gJ2xvZGFzaCc7XHJcbi8qKlxyXG4gKiBBIHR5cGUgcmVwcmVzZW50aW5nIGFueSB2YWxpZCB2YWx1ZSBmb3IgJ3R5cGUnIGZvciBzZXRQcm92aWRlclR5cGUgYW5kIG90aGVyXHJcbiAqIG1ldGhvZHMgdGhhdCBhZGQgb3IgbWFuaXB1bGF0ZSBuZXR3b3JrcyBpbiBNZXRhTWFzayBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIE5ldHdvcmtUeXBlID0gKHR5cGVvZiBORVRXT1JLX1RZUEVTKVtrZXlvZiB0eXBlb2YgTkVUV09SS19UWVBFU107XHJcblxyXG4vKipcclxuICogQSB1bmlvbiB0eXBlIG9mIGFsbCBwb3NzaWJsZSBoYXJkLWNvZGVkIGNoYWluIGlkcy4gVGhpcyB0eXBlIGlzIG5vdFxyXG4gKiBleGhhdXN0aXZlIGFuZCBjYW5ub3QgYmUgdXNlZCBmb3IgdHlwaW5nIGNoYWluSWQgaW4gYXJlYXMgd2hlcmUgdGhlIHVzZXIgb3JcclxuICogZGFwcCBtYXkgc3BlY2lmeSBhbnkgY2hhaW5JZC5cclxuICovXHJcbmV4cG9ydCB0eXBlIENoYWluSWQgPSAodHlwZW9mIENIQUlOX0lEUylba2V5b2YgdHlwZW9mIENIQUlOX0lEU107XHJcblxyXG4vKipcclxuICogQSB0eXBlIHRoYXQgaXMgYSB1bmlvbiB0eXBlIG9mIGFsbCBwb3NzaWJsZSBoYXJkY29kZWQgY3VycmVuY3kgc3ltYm9scy5cclxuICogVGhpcyB0eXBlIGlzIG5vbi1leGhhdXN0aXZlLCBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIGFyZWFzIHdoZXJlIHRoZSB1c2VyXHJcbiAqIG9yIGRhcHAgbWF5IHN1cHBseSB0aGVpciBvd24gc3ltYm9sLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ3VycmVuY3lTeW1ib2wgPVxyXG4gICh0eXBlb2YgQ1VSUkVOQ1lfU1lNQk9MUylba2V5b2YgdHlwZW9mIENVUlJFTkNZX1NZTUJPTFNdO1xyXG4vKipcclxuICogVGVzdCBuZXR3b3JrcyBoYXZlIHNwZWNpYWwgc3ltYm9scyB0aGF0IGNvbWJpbmUgdGhlIG5ldHdvcmsgbmFtZSBhbmQgJ0VUSCdcclxuICogc28gdGhhdCB0aGV5IGFyZSBkaXN0aW5jdCBmcm9tIG1haW5uZXQgYW5kIG90aGVyIG5ldHdvcmtzIHRoYXQgdXNlICdFVEgnLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgVGVzdE5ldHdvcmtDdXJyZW5jeVN5bWJvbCA9XHJcbiAgKHR5cGVvZiBURVNUX05FVFdPUktfVElDS0VSX01BUClba2V5b2YgdHlwZW9mIFRFU1RfTkVUV09SS19USUNLRVJfTUFQXTtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBwcmVmZXJlbmNlcyBmb3IgYW4gUlBDIGRlZmluaXRpb25cclxuICovXHJcbnR5cGUgUlBDUHJlZmVyZW5jZXMgPSB7XHJcbiAgLyoqXHJcbiAgICogQSBVUkwgZm9yIHRoZSBibG9jayBleHBsb3JlciBmb3IgdGhlIFJQQydzIG5ldHdvcmtcclxuICAgKi9cclxuICBibG9ja0V4cGxvcmVyVXJsOiBgaHR0cHM6Ly8ke3N0cmluZ31gO1xyXG4gIC8qKlxyXG4gICAqIEEgaW1hZ2UgcmVmbGVjdGluZyB0aGUgYXNzZXQgc3ltYm9sIGZvciB0aGUgbmV0d29ya1xyXG4gICAqL1xyXG4gIGltYWdlVXJsOiBzdHJpbmc7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbmV0d29yayB0byBiZSB1c2VkIGluc2lkZSBvZiBNZXRhTWFza1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgUlBDRGVmaW5pdGlvbiA9IHtcclxuICAvKipcclxuICAgKiBUaGUgaGV4IGVuY29kZWQgQ2hhaW5JZCBmb3IgdGhlIG5ldHdvcmtcclxuICAgKi9cclxuICBjaGFpbklkOiBDaGFpbklkO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBuaWNrbmFtZSBmb3IgdGhlIG5ldHdvcmtcclxuICAgKi9cclxuICBuaWNrbmFtZTogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBVUkwgZm9yIHRoZSBjbGllbnQgdG8gc2VuZCBuZXR3b3JrIHJlcXVlc3RzIHRvXHJcbiAgICovXHJcbiAgcnBjVXJsOiBgaHR0cHM6Ly8ke3N0cmluZ31gO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBDdXJyZW5jeSBTeW1ib2wgZm9yIHRoZSBuZXR3b3JrXHJcbiAgICovXHJcbiAgdGlja2VyOiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQWRkaXRpb25hbCBwcmVmZXJlbmNlcyBmb3IgdGhlIG5ldHdvcmssIHN1Y2ggYXMgYmxvY2tFeHBsb3JlclVybFxyXG4gICAqL1xyXG4gIHJwY1ByZWZzOiBSUENQcmVmZXJlbmNlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGb3IgZWFjaCBjaGFpbiB0aGF0IHdlIHN1cHBvcnQgZmlhdCBvbnJhbXBzIGZvciwgd2UgcHJvdmlkZSBhIHNldCBvZlxyXG4gKiBjb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBoZWxwIGZvciBpbml0aWFsaXppbmcgdGhlIGNvbm5lY3Rpb25nIHRvIHRoZVxyXG4gKiBvbnJhbXAgcHJvdmlkZXJzLlxyXG4gKi9cclxudHlwZSBCdXlhYmxlQ2hhaW5TZXR0aW5ncyA9IHtcclxuICAvKipcclxuICAgKiBUaGUgbmF0aXZlIGN1cnJlbmN5IGZvciB0aGUgZ2l2ZW4gY2hhaW5cclxuICAgKi9cclxuICBuYXRpdmVDdXJyZW5jeTogQ3VycmVuY3lTeW1ib2wgfCBUZXN0TmV0d29ya0N1cnJlbmN5U3ltYm9sO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBuZXR3b3JrIG5hbWUgb3IgaWRlbnRpZmllclxyXG4gICAqL1xyXG4gIG5ldHdvcms6IHN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaHJvdWdob3V0IHRoZSBleHRlbnNpb24gd2Ugc2V0IHRoZSBjdXJyZW50IHByb3ZpZGVyIGJ5IHJlZmVyZW5jaW5nIGl0c1xyXG4gKiBcInR5cGVcIiwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgdmFsdWVzIGluIHRoZSBiZWxvdyBvYmplY3QuIFRoZXNlIHZhbHVlc1xyXG4gKiByZXByZXNlbnQgdGhlIGJ1aWx0LWluIG5ldHdvcmtzIG9mIE1ldGFNYXNrLCBpbmNsdWRpbmcgdGVzdCBuZXRzLCBhcyB3ZWxsXHJcbiAqIGFzIFwicnBjXCIgd2hpY2ggaXMgdGhlIFwidHlwZVwiIG9mIGEgY3VzdG9tIG5ldHdvcmsgYWRkZWQgYnkgdGhlIHVzZXIgb3IgdmlhXHJcbiAqIHdhbGxldF9hZGRFdGhlcmV1bUNoYWluLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE5FVFdPUktfVFlQRVMgPSB7XHJcbiAgR09FUkxJOiAnZ29lcmxpJyxcclxuICBMT0NBTEhPU1Q6ICdsb2NhbGhvc3QnLFxyXG4gIE1BSU5ORVQ6ICdtYWlubmV0JyxcclxuICBSUEM6ICdycGMnLFxyXG4gIFNFUE9MSUE6ICdzZXBvbGlhJyxcclxuICBMSU5FQV9HT0VSTEk6ICdsaW5lYS1nb2VybGknLFxyXG4gIExJTkVBX01BSU5ORVQ6ICdsaW5lYS1tYWlubmV0JyxcclxufSBhcyBjb25zdDtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBzaG9ydGN1dCBuYW1lcyBmb3IgYW55IG5vbi1idWlsdGluIG5ldHdvcmsuIFdlIG5lZWRcclxuICogdGhpcyB0byBiZSBhYmxlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBuZXR3b3JrcyB0aGF0IHJlcXVpcmUgY3VzdG9tXHJcbiAqIHNlY3Rpb25zIG9mIGNvZGUgZm9yIG91ciB2YXJpb3VzIGZlYXR1cmVzLCBzdWNoIGFzIHN3YXBzIG9yIHRva2VuIGxpc3RzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE5FVFdPUktfTkFNRVMgPSB7XHJcbiAgSE9NRVNURUFEOiAnaG9tZXN0ZWFkJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgTmV0d29yayBJRCBmb3Igb3VyIGJ1aWx0aW4gbmV0d29ya3MuIFRoaXMgaXMgdGhlIGRlY2ltYWwgZXF1aXZhbGVudCBvZlxyXG4gKiB0aGUgY2hhaW4gaWQgZm9yIHRoZSBuZXR3b3JrLCBidXQgaXMgZXhwcmVzc3NlZCBhcyBhIHN0cmluZy4gTWFueSBtb29ucyBhZ29cclxuICogdGhlIGRlY2lzaW9uIHdhcyBtYWRlIG9uIHRoZSBleHRlbnNpb24gdGVhbSB0byBleHByZXNzbHkgdXNlIGNoYWluSWQgd2l0aFxyXG4gKiBoZXggZW5jb2Rpbmcgb3ZlciBuZXR3b3JrIGlkLiBDb25zaWRlciB0aGF0IHdoZW4gYWNjZXNzaW5nIHRoaXMgb2JqZWN0LiBOb3RlXHJcbiAqIGZvciBjcm9zcyBwcm9kdWN0IHB1cnBvc2VzOiBhbGlnbm1lbnQgd2l0aCBtb2JpbGUgb24gdGhpcyBtYXR0ZXIgaGFzIG5vdFxyXG4gKiBiZWVuIGZ1bGx5IGFjaGlldmVkLCB0aHVzIGl0IGlzIHBvc3NpYmxlIGZvciBzb21lIGRlcGVuZGVuY2llcyB0byBzdGlsbFxyXG4gKiBhc2sgZm9yIG9yIHJlcXVpcmUgbmV0d29yayBpZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBORVRXT1JLX0lEUyA9IHtcclxuICBNQUlOTkVUOiAnMScsXHJcbiAgR09FUkxJOiAnNScsXHJcbiAgTE9DQUxIT1NUOiAnMTMzNycsXHJcbiAgU0VQT0xJQTogJzExMTU1MTExJyxcclxuICBMSU5FQV9HT0VSTEk6ICc1OTE0MCcsXHJcbiAgTElORUFfTUFJTk5FVDogJzU5MTQ0JyxcclxufSBhcyBjb25zdDtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIGNoYWluIGlkcyBmb3IgbmV0d29ya3MgYm90aCBidWlsdCBpbiBhbmRcclxuICogdGhvc2UgdGhhdCB3ZSBoYXZlIGFkZGVkIGN1c3RvbSBjb2RlIHRvIHN1cHBvcnQgb3VyIGZlYXR1cmUgc2V0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENIQUlOX0lEUyA9IHtcclxuICBNQUlOTkVUOiAnMHgxJyxcclxuICBHT0VSTEk6ICcweDUnLFxyXG4gIExPQ0FMSE9TVDogJzB4NTM5JyxcclxuICBCU0M6ICcweDM4JyxcclxuICBCU0NfVEVTVE5FVDogJzB4NjEnLFxyXG4gIE9QVElNSVNNOiAnMHhhJyxcclxuICBPUFRJTUlTTV9URVNUTkVUOiAnMHgxYTQnLFxyXG4gIFBPTFlHT046ICcweDg5JyxcclxuICBQT0xZR09OX1RFU1RORVQ6ICcweDEzODgxJyxcclxuICBBVkFMQU5DSEU6ICcweGE4NmEnLFxyXG4gIEFWQUxBTkNIRV9URVNUTkVUOiAnMHhhODY5JyxcclxuICBGQU5UT006ICcweGZhJyxcclxuICBGQU5UT01fVEVTVE5FVDogJzB4ZmEyJyxcclxuICBDRUxPOiAnMHhhNGVjJyxcclxuICBBUkJJVFJVTTogJzB4YTRiMScsXHJcbiAgSEFSTU9OWTogJzB4NjM1NjRjNDAnLFxyXG4gIFBBTE06ICcweDJhMTVjMzA4ZCcsXHJcbiAgU0VQT0xJQTogJzB4YWEzNmE3JyxcclxuICBMSU5FQV9HT0VSTEk6ICcweGU3MDQnLFxyXG4gIExJTkVBX01BSU5ORVQ6ICcweGU3MDgnLFxyXG4gIEFVUk9SQTogJzB4NGU0NTQxNTInLFxyXG4gIE1PT05CRUFNOiAnMHg1MDQnLFxyXG4gIE1PT05CRUFNX1RFU1RORVQ6ICcweDUwNycsXHJcbiAgTU9PTlJJVkVSOiAnMHg1MDUnLFxyXG4gIENST05PUzogJzB4MTknLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBsYXJnZXN0IHBvc3NpYmxlIGNoYWluIElEIHdlIGNhbiBoYW5kbGUuXHJcbiAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yZWttYXJrcy9hNDdiZDVmMjUyNTkzNmM0YjhlZWUzMWExNjM0NTU1M1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0NIQUlOX0lEID0gNDUwMzU5OTYyNzM3MDQ3NjtcclxuXHJcbmV4cG9ydCBjb25zdCBNQUlOTkVUX0RJU1BMQVlfTkFNRSA9ICdFdGhlcmV1bSBNYWlubmV0JztcclxuZXhwb3J0IGNvbnN0IEdPRVJMSV9ESVNQTEFZX05BTUUgPSAnR29lcmxpJztcclxuZXhwb3J0IGNvbnN0IFNFUE9MSUFfRElTUExBWV9OQU1FID0gJ1NlcG9saWEnO1xyXG5leHBvcnQgY29uc3QgTElORUFfR09FUkxJX0RJU1BMQVlfTkFNRSA9ICdMaW5lYSBHb2VybGknO1xyXG5leHBvcnQgY29uc3QgTElORUFfTUFJTk5FVF9ESVNQTEFZX05BTUUgPSAnTGluZWEgTWFpbm5ldCc7XHJcbmV4cG9ydCBjb25zdCBMT0NBTEhPU1RfRElTUExBWV9OQU1FID0gJ0xvY2FsaG9zdCA4NTQ1JztcclxuZXhwb3J0IGNvbnN0IEJTQ19ESVNQTEFZX05BTUUgPSAnQmluYW5jZSBTbWFydCBDaGFpbic7XHJcbmV4cG9ydCBjb25zdCBQT0xZR09OX0RJU1BMQVlfTkFNRSA9ICdQb2x5Z29uJztcclxuZXhwb3J0IGNvbnN0IEFWQUxBTkNIRV9ESVNQTEFZX05BTUUgPSAnQXZhbGFuY2hlIE5ldHdvcmsgQy1DaGFpbic7XHJcbmV4cG9ydCBjb25zdCBBUkJJVFJVTV9ESVNQTEFZX05BTUUgPSAnQXJiaXRydW0gT25lJztcclxuZXhwb3J0IGNvbnN0IEJOQl9ESVNQTEFZX05BTUUgPSAnQk5CIENoYWluJztcclxuZXhwb3J0IGNvbnN0IE9QVElNSVNNX0RJU1BMQVlfTkFNRSA9ICdPcHRpbWlzbSc7XHJcbmV4cG9ydCBjb25zdCBGQU5UT01fRElTUExBWV9OQU1FID0gJ0ZhbnRvbSBPcGVyYSc7XHJcbmV4cG9ydCBjb25zdCBIQVJNT05ZX0RJU1BMQVlfTkFNRSA9ICdIYXJtb255IE1haW5uZXQgU2hhcmQgMCc7XHJcbmV4cG9ydCBjb25zdCBQQUxNX0RJU1BMQVlfTkFNRSA9ICdQYWxtJztcclxuZXhwb3J0IGNvbnN0IEFVUk9SQV9ESVNQTEFZX05BTUUgPSAnQXVyb3JhIE1haW5uZXQnO1xyXG5leHBvcnQgY29uc3QgQ0VMT19ESVNQTEFZX05BTUUgPSAnQ2VsbyBNYWlubmV0JztcclxuXHJcbmV4cG9ydCBjb25zdCBpbmZ1cmFQcm9qZWN0SWQgPSBwcm9jZXNzLmVudi5JTkZVUkFfUFJPSkVDVF9JRDtcclxuZXhwb3J0IGNvbnN0IGdldFJwY1VybCA9ICh7XHJcbiAgbmV0d29yayxcclxuICBleGNsdWRlUHJvamVjdElkID0gZmFsc2UsXHJcbn06IHtcclxuICBuZXR3b3JrOiBOZXR3b3JrVHlwZTtcclxuICBleGNsdWRlUHJvamVjdElkPzogYm9vbGVhbjtcclxufSkgPT5cclxuICBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pby92My8ke2V4Y2x1ZGVQcm9qZWN0SWQgPyAnJyA6IGluZnVyYVByb2plY3RJZH1gO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1BSU5ORVRfUlBDX1VSTCA9IGdldFJwY1VybCh7XHJcbiAgbmV0d29yazogTkVUV09SS19UWVBFUy5NQUlOTkVULFxyXG59KTtcclxuZXhwb3J0IGNvbnN0IEdPRVJMSV9SUENfVVJMID0gZ2V0UnBjVXJsKHsgbmV0d29yazogTkVUV09SS19UWVBFUy5HT0VSTEkgfSk7XHJcbmV4cG9ydCBjb25zdCBTRVBPTElBX1JQQ19VUkwgPSBnZXRScGNVcmwoeyBuZXR3b3JrOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEgfSk7XHJcbmV4cG9ydCBjb25zdCBMSU5FQV9HT0VSTElfUlBDX1VSTCA9IGdldFJwY1VybCh7XHJcbiAgbmV0d29yazogTkVUV09SS19UWVBFUy5MSU5FQV9HT0VSTEksXHJcbn0pO1xyXG5leHBvcnQgY29uc3QgTElORUFfTUFJTk5FVF9SUENfVVJMID0gZ2V0UnBjVXJsKHtcclxuICBuZXR3b3JrOiBORVRXT1JLX1RZUEVTLkxJTkVBX01BSU5ORVQsXHJcbn0pO1xyXG5leHBvcnQgY29uc3QgTE9DQUxIT1NUX1JQQ19VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JztcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW4gc3ltYm9scyBmb3IgdmFyaW91cyB0b2tlbnMgdGhhdCBhcmUgZWl0aGVyXHJcbiAqIG5hdGl2ZSBjdXJyZW5jaWVzIG9yIHRob3NlIHRoYXQgaGF2ZSBiZWVuIHNwZWNpYWwgY2FzZWQgYnkgdGhlIGV4dGVuc2lvblxyXG4gKiBmb3Igc3VwcG9ydGluZyBvdXIgZmVhdHVyZSBzZXQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ1VSUkVOQ1lfU1lNQk9MUyA9IHtcclxuICBBUkJJVFJVTTogJ0VUSCcsXHJcbiAgQVVST1JBX0VUSDogJ0FVUk9SQSBFVEgnLFxyXG4gIEFWQUxBTkNIRTogJ0FWQVgnLFxyXG4gIEJOQjogJ0JOQicsXHJcbiAgQlVTRDogJ0JVU0QnLFxyXG4gIENFTE86ICdDRUxPJyxcclxuICBEQUk6ICdEQUknLFxyXG4gIEVUSDogJ0VUSCcsXHJcbiAgRkFOVE9NOiAnRlRNJyxcclxuICBIQVJNT05ZOiAnT05FJyxcclxuICBQQUxNOiAnUEFMTScsXHJcbiAgTUFUSUM6ICdNQVRJQycsXHJcbiAgVEVTVF9FVEg6ICdURVNURVRIJyxcclxuICBVU0RDOiAnVVNEQycsXHJcbiAgVVNEVDogJ1VTRFQnLFxyXG4gIFdFVEg6ICdXRVRIJyxcclxuICBPUFRJTUlTTTogJ09QJyxcclxuICBDUk9OT1M6ICdDUk8nLFxyXG4gIEdMSU1NRVI6ICdHTE1SJyxcclxuICBNT09OUklWRVI6ICdNT1ZSJyxcclxuICBPTkU6ICdPTkUnLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEVUSF9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvZXRoX2xvZ28ucG5nJztcclxuZXhwb3J0IGNvbnN0IExJTkVBX0dPRVJMSV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvbGluZWEtbG9nby10ZXN0bmV0LnBuZyc7XHJcbmV4cG9ydCBjb25zdCBMSU5FQV9NQUlOTkVUX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9saW5lYS1sb2dvLW1haW5uZXQucG5nJztcclxuZXhwb3J0IGNvbnN0IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ibGFjay1ldGgtbG9nby5zdmcnO1xyXG5leHBvcnQgY29uc3QgQk5CX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ibmIucG5nJztcclxuZXhwb3J0IGNvbnN0IE1BVElDX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9tYXRpYy10b2tlbi5wbmcnO1xyXG5leHBvcnQgY29uc3QgQVZBWF9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvYXZheC10b2tlbi5wbmcnO1xyXG5leHBvcnQgY29uc3QgQUVUSF9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvYXJiaXRydW0uc3ZnJztcclxuZXhwb3J0IGNvbnN0IEZUTV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvZmFudG9tLW9wZXJhLnN2Zyc7XHJcbmV4cG9ydCBjb25zdCBIQVJNT05ZX09ORV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvaGFybW9ueS1vbmUuc3ZnJztcclxuZXhwb3J0IGNvbnN0IE9QVElNSVNNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9vcHRpbWlzbS5zdmcnO1xyXG5leHBvcnQgY29uc3QgUEFMTV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvcGFsbS5zdmcnO1xyXG5leHBvcnQgY29uc3QgQVVST1JBX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9hdXJvcmEucG5nJztcclxuZXhwb3J0IGNvbnN0IENFTE9fVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2NlbG8uc3ZnJztcclxuXHJcbmV4cG9ydCBjb25zdCBJTkZVUkFfUFJPVklERVJfVFlQRVMgPSBbXHJcbiAgTkVUV09SS19UWVBFUy5NQUlOTkVULFxyXG4gIE5FVFdPUktfVFlQRVMuR09FUkxJLFxyXG4gIE5FVFdPUktfVFlQRVMuU0VQT0xJQSxcclxuICBORVRXT1JLX1RZUEVTLkxJTkVBX0dPRVJMSSxcclxuICBORVRXT1JLX1RZUEVTLkxJTkVBX01BSU5ORVQsXHJcbl0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgVEVTVF9DSEFJTlMgPSBbXHJcbiAgQ0hBSU5fSURTLkdPRVJMSSxcclxuICBDSEFJTl9JRFMuU0VQT0xJQSxcclxuICBDSEFJTl9JRFMuTElORUFfR09FUkxJLFxyXG4gIENIQUlOX0lEUy5MT0NBTEhPU1QsXHJcbl07XHJcblxyXG5jb25zdCB0eXBlZENhcGl0YWxpemUgPSA8SyBleHRlbmRzIHN0cmluZz4oazogSyk6IENhcGl0YWxpemU8Sz4gPT5cclxuICBjYXBpdGFsaXplKGspIGFzIENhcGl0YWxpemU8dHlwZW9mIGs+O1xyXG5cclxuZXhwb3J0IGNvbnN0IFRFU1RfTkVUV09SS19USUNLRVJfTUFQOiB7XHJcbiAgW0sgaW4gRXhjbHVkZTxcclxuICAgIE5ldHdvcmtUeXBlLFxyXG4gICAgJ2xvY2FsaG9zdCcgfCAnbWFpbm5ldCcgfCAncnBjJyB8ICdsaW5lYS1tYWlubmV0J1xyXG4gID5dOiBzdHJpbmc7XHJcbn0gPSB7XHJcbiAgW05FVFdPUktfVFlQRVMuR09FUkxJXTogYCR7dHlwZWRDYXBpdGFsaXplKE5FVFdPUktfVFlQRVMuR09FUkxJKX0ke1xyXG4gICAgQ1VSUkVOQ1lfU1lNQk9MUy5FVEhcclxuICB9YCxcclxuICBbTkVUV09SS19UWVBFUy5TRVBPTElBXTogYCR7dHlwZWRDYXBpdGFsaXplKE5FVFdPUktfVFlQRVMuU0VQT0xJQSl9JHtcclxuICAgIENVUlJFTkNZX1NZTUJPTFMuRVRIXHJcbiAgfWAsXHJcbiAgW05FVFdPUktfVFlQRVMuTElORUFfR09FUkxJXTogYExpbmVhJHtDVVJSRU5DWV9TWU1CT0xTLkVUSH1gLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcCBvZiBhbGwgYnVpbGQtaW4gSW5mdXJhIG5ldHdvcmtzIHRvIHRoZWlyIG5ldHdvcmssIHRpY2tlciBhbmQgY2hhaW4gSURzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEJVSUxUX0lOX05FVFdPUktTID0ge1xyXG4gIFtORVRXT1JLX1RZUEVTLkdPRVJMSV06IHtcclxuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuR09FUkxJLFxyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkdPRVJMSSxcclxuICAgIHRpY2tlcjogVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBbTkVUV09SS19UWVBFUy5HT0VSTEldLFxyXG4gICAgYmxvY2tFeHBsb3JlclVybDogYGh0dHBzOi8vJHtORVRXT1JLX1RZUEVTLkdPRVJMSX0uZXRoZXJzY2FuLmlvYCxcclxuICB9LFxyXG4gIFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdOiB7XHJcbiAgICBuZXR3b3JrSWQ6IE5FVFdPUktfSURTLlNFUE9MSUEsXHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuU0VQT0xJQSxcclxuICAgIHRpY2tlcjogVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBbTkVUV09SS19UWVBFUy5TRVBPTElBXSxcclxuICAgIGJsb2NrRXhwbG9yZXJVcmw6IGBodHRwczovLyR7TkVUV09SS19UWVBFUy5TRVBPTElBfS5ldGhlcnNjYW4uaW9gLFxyXG4gIH0sXHJcbiAgW05FVFdPUktfVFlQRVMuTElORUFfR09FUkxJXToge1xyXG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5MSU5FQV9HT0VSTEksXHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuTElORUFfR09FUkxJLFxyXG4gICAgdGlja2VyOiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLkxJTkVBX0dPRVJMSV0sXHJcbiAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9nb2VybGkubGluZWFzY2FuLmJ1aWxkJyxcclxuICB9LFxyXG4gIFtORVRXT1JLX1RZUEVTLk1BSU5ORVRdOiB7XHJcbiAgICBuZXR3b3JrSWQ6IE5FVFdPUktfSURTLk1BSU5ORVQsXHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuTUFJTk5FVCxcclxuICAgIGJsb2NrRXhwbG9yZXJVcmw6IGBodHRwczovL2V0aGVyc2Nhbi5pb2AsXHJcbiAgfSxcclxuICBbTkVUV09SS19UWVBFUy5MSU5FQV9NQUlOTkVUXToge1xyXG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5MSU5FQV9NQUlOTkVULFxyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkxJTkVBX01BSU5ORVQsXHJcbiAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9saW5lYXNjYW4uYnVpbGQnLFxyXG4gIH0sXHJcbiAgW05FVFdPUktfVFlQRVMuTE9DQUxIT1NUXToge1xyXG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5MT0NBTEhPU1QsXHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuTE9DQUxIT1NULFxyXG4gIH0sXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgQlVJTFRfSU5fSU5GVVJBX05FVFdPUktTID0gcGljayhcclxuICBCVUlMVF9JTl9ORVRXT1JLUyxcclxuICBJTkZVUkFfUFJPVklERVJfVFlQRVMsXHJcbik7XHJcblxyXG5leHBvcnQgdHlwZSBCdWlsdEluSW5mdXJhTmV0d29yayA9IGtleW9mIHR5cGVvZiBCVUlMVF9JTl9JTkZVUkFfTkVUV09SS1M7XHJcblxyXG5leHBvcnQgY29uc3QgTkVUV09SS19UT19OQU1FX01BUCA9IHtcclxuICBbTkVUV09SS19UWVBFUy5NQUlOTkVUXTogTUFJTk5FVF9ESVNQTEFZX05BTUUsXHJcbiAgW05FVFdPUktfVFlQRVMuR09FUkxJXTogR09FUkxJX0RJU1BMQVlfTkFNRSxcclxuICBbTkVUV09SS19UWVBFUy5TRVBPTElBXTogU0VQT0xJQV9ESVNQTEFZX05BTUUsXHJcbiAgW05FVFdPUktfVFlQRVMuTElORUFfR09FUkxJXTogTElORUFfR09FUkxJX0RJU1BMQVlfTkFNRSxcclxuICBbTkVUV09SS19UWVBFUy5MSU5FQV9NQUlOTkVUXTogTElORUFfTUFJTk5FVF9ESVNQTEFZX05BTUUsXHJcbiAgW05FVFdPUktfVFlQRVMuTE9DQUxIT1NUXTogTE9DQUxIT1NUX0RJU1BMQVlfTkFNRSxcclxuXHJcbiAgW05FVFdPUktfSURTLkdPRVJMSV06IEdPRVJMSV9ESVNQTEFZX05BTUUsXHJcbiAgW05FVFdPUktfSURTLlNFUE9MSUFdOiBTRVBPTElBX0RJU1BMQVlfTkFNRSxcclxuICBbTkVUV09SS19JRFMuTElORUFfR09FUkxJXTogTElORUFfR09FUkxJX0RJU1BMQVlfTkFNRSxcclxuICBbTkVUV09SS19JRFMuTUFJTk5FVF06IE1BSU5ORVRfRElTUExBWV9OQU1FLFxyXG4gIFtORVRXT1JLX0lEUy5MSU5FQV9NQUlOTkVUXTogTElORUFfTUFJTk5FVF9ESVNQTEFZX05BTUUsXHJcbiAgW05FVFdPUktfSURTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9ESVNQTEFZX05BTUUsXHJcblxyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX0RJU1BMQVlfTkFNRSxcclxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBTRVBPTElBX0RJU1BMQVlfTkFNRSxcclxuICBbQ0hBSU5fSURTLkxJTkVBX0dPRVJMSV06IExJTkVBX0dPRVJMSV9ESVNQTEFZX05BTUUsXHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTUFJTk5FVF9ESVNQTEFZX05BTUUsXHJcbiAgW0NIQUlOX0lEUy5MSU5FQV9NQUlOTkVUXTogTElORUFfTUFJTk5FVF9ESVNQTEFZX05BTUUsXHJcbiAgW0NIQUlOX0lEUy5MT0NBTEhPU1RdOiBMT0NBTEhPU1RfRElTUExBWV9OQU1FLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX1RZUEVfTUFQID0ge1xyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE5FVFdPUktfVFlQRVMuTUFJTk5FVCxcclxuICBbQ0hBSU5fSURTLkdPRVJMSV06IE5FVFdPUktfVFlQRVMuR09FUkxJLFxyXG4gIFtDSEFJTl9JRFMuU0VQT0xJQV06IE5FVFdPUktfVFlQRVMuU0VQT0xJQSxcclxuICBbQ0hBSU5fSURTLkxJTkVBX0dPRVJMSV06IE5FVFdPUktfVFlQRVMuTElORUFfR09FUkxJLFxyXG4gIFtDSEFJTl9JRFMuTElORUFfTUFJTk5FVF06IE5FVFdPUktfVFlQRVMuTElORUFfTUFJTk5FVCxcclxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IE5FVFdPUktfVFlQRVMuTE9DQUxIT1NULFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX1JQQ19VUkxfTUFQID0ge1xyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX1JQQ19VUkwsXHJcbiAgW0NIQUlOX0lEUy5TRVBPTElBXTogU0VQT0xJQV9SUENfVVJMLFxyXG4gIFtDSEFJTl9JRFMuTElORUFfR09FUkxJXTogTElORUFfR09FUkxJX1JQQ19VUkwsXHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTUFJTk5FVF9SUENfVVJMLFxyXG4gIFtDSEFJTl9JRFMuTElORUFfTUFJTk5FVF06IExJTkVBX01BSU5ORVRfUlBDX1VSTCxcclxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9SUENfVVJMLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX05FVFdPUktfSU1BR0VfVVJMX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBFVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuTElORUFfR09FUkxJXTogTElORUFfR09FUkxJX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLkxJTkVBX01BSU5ORVRdOiBMSU5FQV9NQUlOTkVUX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuQlNDXTogQk5CX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IEFFVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDSEFJTl9JRFMuRkFOVE9NXTogRlRNX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLkhBUk1PTlldOiBIQVJNT05ZX09ORV9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IE9QVElNSVNNX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLlBBTE1dOiBQQUxNX1RPS0VOX0lNQUdFX1VSTCxcclxuICBbQ0hBSU5fSURTLkFVUk9SQV06IEFVUk9SQV9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NIQUlOX0lEUy5DRUxPXTogQ0VMT19UT0tFTl9JTUFHRV9VUkwsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgTkVUV09SS19JRF9UT19FVEhFUlNfTkVUV09SS19OQU1FX01BUCA9IHtcclxuICBbTkVUV09SS19JRFMuR09FUkxJXTogTkVUV09SS19UWVBFUy5HT0VSTEksXHJcbiAgW05FVFdPUktfSURTLlNFUE9MSUFdOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEsXHJcbiAgW05FVFdPUktfSURTLkxJTkVBX0dPRVJMSV06IE5FVFdPUktfVFlQRVMuTElORUFfR09FUkxJLFxyXG4gIFtORVRXT1JLX0lEUy5NQUlOTkVUXTogTkVUV09SS19OQU1FUy5IT01FU1RFQUQsXHJcbiAgW05FVFdPUktfSURTLkxJTkVBX01BSU5ORVRdOiBORVRXT1JLX1RZUEVTLkxJTkVBX01BSU5ORVQsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVAgPSB7XHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTkVUV09SS19JRFMuTUFJTk5FVCxcclxuICBbQ0hBSU5fSURTLkdPRVJMSV06IE5FVFdPUktfSURTLkdPRVJMSSxcclxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBORVRXT1JLX0lEUy5TRVBPTElBLFxyXG4gIFtDSEFJTl9JRFMuTElORUFfR09FUkxJXTogTkVUV09SS19JRFMuTElORUFfR09FUkxJLFxyXG4gIFtDSEFJTl9JRFMuTElORUFfTUFJTk5FVF06IE5FVFdPUktfSURTLkxJTkVBX01BSU5ORVQsXHJcbiAgW0NIQUlOX0lEUy5MT0NBTEhPU1RdOiBORVRXT1JLX0lEUy5MT0NBTEhPU1QsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgTkFUSVZFX0NVUlJFTkNZX1RPS0VOX0lNQUdFX01BUCA9IHtcclxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5FVEhdOiBFVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDVVJSRU5DWV9TWU1CT0xTLlRFU1RfRVRIXTogVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDVVJSRU5DWV9TWU1CT0xTLkJOQl06IEJOQl9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NVUlJFTkNZX1NZTUJPTFMuTUFUSUNdOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFXTogQVZBWF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NVUlJFTkNZX1NZTUJPTFMuT1BUSU1JU01dOiBPUFRJTUlTTV9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgW0NVUlJFTkNZX1NZTUJPTFMuQ0VMT106IENFTE9fVE9LRU5fSU1BR0VfVVJMLFxyXG4gIFtDVVJSRU5DWV9TWU1CT0xTLkFVUk9SQV9FVEhdOiBFVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IElORlVSQV9CTE9DS0VEX0tFWSA9ICdjb3VudHJ5QmxvY2tlZCc7XHJcblxyXG5jb25zdCBkZWZhdWx0RXRoZXJzY2FuRG9tYWluID0gJ2V0aGVyc2Nhbi5pbyc7XHJcbmNvbnN0IGRlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXggPSAnYXBpJztcclxuLyoqXHJcbiAqIE1hcCBvZiBhbGwgRXRoZXJzY2FuIHN1cHBvcnRlZCBuZXR3b3Jrcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBFVEhFUlNDQU5fU1VQUE9SVEVEX05FVFdPUktTID0ge1xyXG4gIFtDSEFJTl9JRFMuR09FUkxJXToge1xyXG4gICAgZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuRG9tYWluLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS0ke1xyXG4gICAgICBDSEFJTl9JRF9UT19UWVBFX01BUFtDSEFJTl9JRFMuR09FUkxJXVxyXG4gICAgfWAsXHJcbiAgICBuZXR3b3JrSWQ6IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW0NIQUlOX0lEUy5HT0VSTEldLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXToge1xyXG4gICAgZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuRG9tYWluLFxyXG4gICAgc3ViZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4LFxyXG4gICAgbmV0d29ya0lkOiBDSEFJTl9JRF9UT19ORVRXT1JLX0lEX01BUFtDSEFJTl9JRFMuTUFJTk5FVF0sXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiB7XHJcbiAgICBkb21haW46IGRlZmF1bHRFdGhlcnNjYW5Eb21haW4sXHJcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LSR7XHJcbiAgICAgIENIQUlOX0lEX1RPX1RZUEVfTUFQW0NIQUlOX0lEUy5TRVBPTElBXVxyXG4gICAgfWAsXHJcbiAgICBuZXR3b3JrSWQ6IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW0NIQUlOX0lEUy5TRVBPTElBXSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuTElORUFfR09FUkxJXToge1xyXG4gICAgZG9tYWluOiAnbGluZWFzY2FuLmJ1aWxkJyxcclxuICAgIHN1YmRvbWFpbjogJ2dvZXJsaScsXHJcbiAgICBuZXR3b3JrSWQ6IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW0NIQUlOX0lEUy5MSU5FQV9HT0VSTEldLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5MSU5FQV9NQUlOTkVUXToge1xyXG4gICAgZG9tYWluOiAnbGluZWFzY2FuLmJ1aWxkJyxcclxuICAgIHN1YmRvbWFpbjogZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeCxcclxuICAgIG5ldHdvcmtJZDogQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbQ0hBSU5fSURTLkxJTkVBX01BSU5ORVRdLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5CU0NdOiB7XHJcbiAgICBkb21haW46ICdic2NzY2FuLmNvbScsXHJcbiAgICBzdWJkb21haW46IGRlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXgsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5CU0MsIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5CU0NfVEVTVE5FVF06IHtcclxuICAgIGRvbWFpbjogJ2JzY3NjYW4uY29tJyxcclxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tdGVzdG5ldGAsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5CU0NfVEVTVE5FVCwgMTYpLnRvU3RyaW5nKCksXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLk9QVElNSVNNXToge1xyXG4gICAgZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuRG9tYWluLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS1vcHRpbWlzdGljYCxcclxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLk9QVElNSVNNLCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01fVEVTVE5FVF06IHtcclxuICAgIGRvbWFpbjogZGVmYXVsdEV0aGVyc2NhbkRvbWFpbixcclxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tZ29lcmxpLW9wdGltaXN0aWNgLFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuT1BUSU1JU01fVEVTVE5FVCwgMTYpLnRvU3RyaW5nKCksXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiB7XHJcbiAgICBkb21haW46ICdwb2x5Z29uc2Nhbi5jb20nLFxyXG4gICAgc3ViZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4LFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuUE9MWUdPTiwgMTYpLnRvU3RyaW5nKCksXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLlBPTFlHT05fVEVTVE5FVF06IHtcclxuICAgIGRvbWFpbjogJ3BvbHlnb25zY2FuLmNvbScsXHJcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LW11bWJhaWAsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5QT0xZR09OX1RFU1RORVQsIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiB7XHJcbiAgICBkb21haW46ICdzbm93dHJhY2UuaW8nLFxyXG4gICAgc3ViZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4LFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuQVZBTEFOQ0hFLCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFX1RFU1RORVRdOiB7XHJcbiAgICBkb21haW46ICdzbm93dHJhY2UuaW8nLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS10ZXN0bmV0YCxcclxuICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoQ0hBSU5fSURTLkFWQUxBTkNIRV9URVNUTkVULCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuRkFOVE9NXToge1xyXG4gICAgZG9tYWluOiAnZnRtc2Nhbi5jb20nLFxyXG4gICAgc3ViZG9tYWluOiBkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4LFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuRkFOVE9NLCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuRkFOVE9NX1RFU1RORVRdOiB7XHJcbiAgICBkb21haW46ICdmdG1zY2FuLmNvbScsXHJcbiAgICBzdWJkb21haW46IGAke2RlZmF1bHRFdGhlcnNjYW5TdWJkb21haW5QcmVmaXh9LXRlc3RuZXRgLFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuRkFOVE9NX1RFU1RORVQsIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5NT09OQkVBTV06IHtcclxuICAgIGRvbWFpbjogJ21vb25zY2FuLmlvJyxcclxuICAgIHN1YmRvbWFpbjogYCR7ZGVmYXVsdEV0aGVyc2NhblN1YmRvbWFpblByZWZpeH0tbW9vbmJlYW1gLFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuTU9PTkJFQU0sIDE2KS50b1N0cmluZygpLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5NT09OQkVBTV9URVNUTkVUXToge1xyXG4gICAgZG9tYWluOiAnbW9vbnNjYW4uaW8nLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS1tb29uYmFzZWAsXHJcbiAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KENIQUlOX0lEUy5NT09OQkVBTV9URVNUTkVULCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuTU9PTlJJVkVSXToge1xyXG4gICAgZG9tYWluOiAnbW9vbnNjYW4uaW8nLFxyXG4gICAgc3ViZG9tYWluOiBgJHtkZWZhdWx0RXRoZXJzY2FuU3ViZG9tYWluUHJlZml4fS1tb29ucml2ZXJgLFxyXG4gICAgbmV0d29ya0lkOiBwYXJzZUludChDSEFJTl9JRFMuTU9PTlJJVkVSLCAxNikudG9TdHJpbmcoKSxcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX0dBU19MSU1JVF9CVUZGRVJfTUFQID0ge1xyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiAxLFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01fVEVTVE5FVF06IDEsXHJcbn07XHJcblxyXG4vKipcclxuICogRXRoZXJldW0gSlNPTi1SUEMgbWV0aG9kcyB0aGF0IGFyZSBrbm93biB0byBleGlzdCBidXQgdGhhdCB3ZSBpbnRlbnRpb25hbGx5XHJcbiAqIGRvIG5vdCBzdXBwb3J0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFVOU1VQUE9SVEVEX1JQQ19NRVRIT0RTID0gbmV3IFNldChbXHJcbiAgLy8gVGhpcyBpcyBpbXBsZW1lbnRlZCBsYXRlciBpbiBvdXIgbWlkZGxld2FyZSBzdGFjayDigJMgc3BlY2lmaWNhbGx5LCBpblxyXG4gIC8vIGV0aC1qc29uLXJwYy1taWRkbGV3YXJlIOKAkyBidXQgb3VyIFVJIGRvZXMgbm90IHN1cHBvcnQgaXQuXHJcbiAgJ2V0aF9zaWduVHJhbnNhY3Rpb24nIGFzIGNvbnN0LFxyXG5dKTtcclxuXHJcbmV4cG9ydCBjb25zdCBJUEZTX0RFRkFVTFRfR0FURVdBWV9VUkwgPSAnZHdlYi5saW5rJztcclxuXHJcbi8vIFRoZSBmaXJzdCBpdGVtIGluIHRyYW5zYWtDdXJyZW5jaWVzIG11c3QgYmUgdGhlXHJcbi8vIGRlZmF1bHQgY3J5cHRvIGN1cnJlbmN5IGZvciB0aGUgbmV0d29ya1xyXG5jb25zdCBCVVlBQkxFX0NIQUlOX0VUSEVSRVVNX05FVFdPUktfTkFNRSA9ICdldGhlcmV1bSc7XHJcblxyXG5leHBvcnQgY29uc3QgQlVZQUJMRV9DSEFJTlNfTUFQOiB7XHJcbiAgW0sgaW4gRXhjbHVkZTxcclxuICAgIENoYWluSWQsXHJcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuTE9DQUxIT1NUXHJcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuT1BUSU1JU01fVEVTVE5FVFxyXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLkJTQ19URVNUTkVUXHJcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuUE9MWUdPTl9URVNUTkVUXHJcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuQVZBTEFOQ0hFX1RFU1RORVRcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5GQU5UT01fVEVTVE5FVFxyXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLk1PT05CRUFNX1RFU1RORVRcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5MSU5FQV9HT0VSTElcclxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5HT0VSTElcclxuICA+XTogQnV5YWJsZUNoYWluU2V0dGluZ3M7XHJcbn0gPSB7XHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxyXG4gICAgbmV0d29yazogQlVZQUJMRV9DSEFJTl9FVEhFUkVVTV9ORVRXT1JLX05BTUUsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBbTkVUV09SS19UWVBFUy5TRVBPTElBXSxcclxuICAgIG5ldHdvcms6IEJVWUFCTEVfQ0hBSU5fRVRIRVJFVU1fTkVUV09SS19OQU1FLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5CU0NdOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5CTkIsXHJcbiAgICBuZXR3b3JrOiAnYnNjJyxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IHtcclxuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxyXG4gICAgbmV0d29yazogJ3BvbHlnb24nLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXHJcbiAgICBuZXR3b3JrOiAnYXZheGNjaGFpbicsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLkZBTlRPTV06IHtcclxuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkZBTlRPTSxcclxuICAgIG5ldHdvcms6ICdmYW50b20nLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5DRUxPXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQ0VMTyxcclxuICAgIG5ldHdvcms6ICdjZWxvJyxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXHJcbiAgICBuZXR3b3JrOiAnb3B0aW1pc20nLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IHtcclxuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkFSQklUUlVNLFxyXG4gICAgbmV0d29yazogJ2FyYml0cnVtJyxcclxuICB9LFxyXG4gIFtDSEFJTl9JRFMuQ1JPTk9TXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQ1JPTk9TLFxyXG4gICAgbmV0d29yazogJ2Nyb25vcycsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLk1PT05CRUFNXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuR0xJTU1FUixcclxuICAgIG5ldHdvcms6ICdtb29uYmVhbScsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLk1PT05SSVZFUl06IHtcclxuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLk1PT05SSVZFUixcclxuICAgIG5ldHdvcms6ICdtb29ucml2ZXInLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5BVVJPUkFdOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5BVVJPUkFfRVRILFxyXG4gICAgbmV0d29yazogJ2F1cm9yYScsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLkhBUk1PTlldOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5PTkUsXHJcbiAgICBuZXR3b3JrOiAnaGFybW9ueScsXHJcbiAgfSxcclxuICBbQ0hBSU5fSURTLlBBTE1dOiB7XHJcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5QQUxNLFxyXG4gICAgbmV0d29yazogJ3BhbG0nLFxyXG4gIH0sXHJcbiAgW0NIQUlOX0lEUy5MSU5FQV9NQUlOTkVUXToge1xyXG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxyXG4gICAgbmV0d29yazogJ2xpbmVhJyxcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEZFQVRVUkVEX1JQQ1M6IFJQQ0RlZmluaXRpb25bXSA9IFtcclxuICB7XHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuQVJCSVRSVU0sXHJcbiAgICBuaWNrbmFtZTogQVJCSVRSVU1fRElTUExBWV9OQU1FLFxyXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hcmJpdHJ1bS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxyXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkFSQklUUlVNLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZXhwbG9yZXIuYXJiaXRydW0uaW8nLFxyXG4gICAgICBpbWFnZVVybDogQUVUSF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkFVUk9SQSxcclxuICAgIG5pY2tuYW1lOiBBVVJPUkFfRElTUExBWV9OQU1FLFxyXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hdXJvcmEtbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcclxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5BVVJPUkFfRVRILFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vYXVyb3Jhc2Nhbi5kZXYvJyxcclxuICAgICAgaW1hZ2VVcmw6IEFVUk9SQV9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkFWQUxBTkNIRSxcclxuICAgIG5pY2tuYW1lOiBBVkFMQU5DSEVfRElTUExBWV9OQU1FLFxyXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hdmFsYW5jaGUtbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcclxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXHJcbiAgICBycGNQcmVmczoge1xyXG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9zbm93dHJhY2UuaW8vJyxcclxuICAgICAgaW1hZ2VVcmw6IEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIHtcclxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5CU0MsXHJcbiAgICBuaWNrbmFtZTogQk5CX0RJU1BMQVlfTkFNRSxcclxuICAgIHJwY1VybDogJ2h0dHBzOi8vYnNjLWRhdGFzZWVkLmJpbmFuY2Uub3JnLycsXHJcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuQk5CLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vYnNjc2Nhbi5jb20vJyxcclxuICAgICAgaW1hZ2VVcmw6IEJOQl9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkZBTlRPTSxcclxuICAgIG5pY2tuYW1lOiBGQU5UT01fRElTUExBWV9OQU1FLFxyXG4gICAgcnBjVXJsOiAnaHR0cHM6Ly9ycGMuZnRtLnRvb2xzLycsXHJcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuRkFOVE9NLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZnRtc2Nhbi5jb20vJyxcclxuICAgICAgaW1hZ2VVcmw6IEZUTV9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkhBUk1PTlksXHJcbiAgICBuaWNrbmFtZTogSEFSTU9OWV9ESVNQTEFZX05BTUUsXHJcbiAgICBycGNVcmw6ICdodHRwczovL2FwaS5oYXJtb255Lm9uZS8nLFxyXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkhBUk1PTlksXHJcbiAgICBycGNQcmVmczoge1xyXG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5oYXJtb255Lm9uZS8nLFxyXG4gICAgICBpbWFnZVVybDogSEFSTU9OWV9PTkVfVE9LRU5fSU1BR0VfVVJMLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIHtcclxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5PUFRJTUlTTSxcclxuICAgIG5pY2tuYW1lOiBPUFRJTUlTTV9ESVNQTEFZX05BTUUsXHJcbiAgICBycGNVcmw6IGBodHRwczovL29wdGltaXNtLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXHJcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW8vJyxcclxuICAgICAgaW1hZ2VVcmw6IE9QVElNSVNNX1RPS0VOX0lNQUdFX1VSTCxcclxuICAgIH0sXHJcbiAgfSxcclxuICB7XHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuUEFMTSxcclxuICAgIG5pY2tuYW1lOiBQQUxNX0RJU1BMQVlfTkFNRSxcclxuICAgIHJwY1VybDogYGh0dHBzOi8vcGFsbS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxyXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLlBBTE0sXHJcbiAgICBycGNQcmVmczoge1xyXG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5wYWxtLmlvLycsXHJcbiAgICAgIGltYWdlVXJsOiBQQUxNX1RPS0VOX0lNQUdFX1VSTCxcclxuICAgIH0sXHJcbiAgfSxcclxuICB7XHJcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuUE9MWUdPTixcclxuICAgIG5pY2tuYW1lOiBgJHtQT0xZR09OX0RJU1BMQVlfTkFNRX0gJHtjYXBpdGFsaXplKE5FVFdPUktfVFlQRVMuTUFJTk5FVCl9YCxcclxuICAgIHJwY1VybDogYGh0dHBzOi8vcG9seWdvbi1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxyXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vcG9seWdvbnNjYW4uY29tLycsXHJcbiAgICAgIGltYWdlVXJsOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkNFTE8sXHJcbiAgICBuaWNrbmFtZTogQ0VMT19ESVNQTEFZX05BTUUsXHJcbiAgICBycGNVcmw6IGBodHRwczovL2NlbG8tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcclxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5DRUxPLFxyXG4gICAgcnBjUHJlZnM6IHtcclxuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vY2Vsb3NjYW4uaW8nLFxyXG4gICAgICBpbWFnZVVybDogQ0VMT19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgICB9LFxyXG4gIH0sXHJcbl07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgYXZhaWxhYmlsaXR5IHN0YXRlIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbmV0d29yay5cclxuICovXHJcbmV4cG9ydCBlbnVtIE5ldHdvcmtTdGF0dXMge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBuZXR3b3JrIG1heSBvciBtYXkgbm90IGJlIGFibGUgdG8gcmVjZWl2ZSByZXF1ZXN0cywgYnV0IGVpdGhlciBub1xyXG4gICAqIGF0dGVtcHQgaGFzIGJlZW4gbWFkZSB0byBkZXRlcm1pbmUgdGhpcywgb3IgYW4gYXR0ZW1wdCB3YXMgbWFkZSBidXQgd2FzXHJcbiAgICogdW5zdWNjZXNzZnVsLlxyXG4gICAqL1xyXG4gIFVua25vd24gPSAndW5rbm93bicsXHJcbiAgLyoqXHJcbiAgICogVGhlIG5ldHdvcmsgaXMgYWJsZSB0byByZWNlaXZlIGFuZCByZXNwb25kIHRvIHJlcXVlc3RzLlxyXG4gICAqL1xyXG4gIEF2YWlsYWJsZSA9ICdhdmFpbGFibGUnLFxyXG4gIC8qKlxyXG4gICAqIFRoZSBuZXR3b3JrIGlzIHVuYWJsZSB0byByZWNlaXZlIGFuZCByZXNwb25kIHRvIHJlcXVlc3RzIGZvciB1bmtub3duXHJcbiAgICogcmVhc29ucy5cclxuICAgKi9cclxuICBVbmF2YWlsYWJsZSA9ICd1bmF2YWlsYWJsZScsXHJcbiAgLyoqXHJcbiAgICogVGhlIG5ldHdvcmsgaXMgbm90IG9ubHkgdW5hdmFpbGFibGUsIGJ1dCBpcyBhbHNvIGluYWNjZXNzaWJsZSBmb3IgdGhlIHVzZXJcclxuICAgKiBzcGVjaWZpY2FsbHkgYmFzZWQgb24gdGhlaXIgbG9jYXRpb24uIFRoaXMgc3RhdGUgb25seSBhcHBsaWVzIHRvIEluZnVyYVxyXG4gICAqIG5ldHdvcmtzLlxyXG4gICAqL1xyXG4gIEJsb2NrZWQgPSAnYmxvY2tlZCcsXHJcbn1cclxuIiwiZXhwb3J0IGNvbnN0IENhdmVhdFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgcmVzdHJpY3RSZXR1cm5lZEFjY291bnRzOiAncmVzdHJpY3RSZXR1cm5lZEFjY291bnRzJyBhcyBjb25zdCxcclxufSk7XHJcblxyXG5leHBvcnQgY29uc3QgUmVzdHJpY3RlZE1ldGhvZHMgPSBPYmplY3QuZnJlZXplKHtcclxuICBldGhfYWNjb3VudHM6ICdldGhfYWNjb3VudHMnLFxyXG5cblxufSBhcyBjb25zdCk7XHJcblxyXG5cbiIsImV4cG9ydCBlbnVtIFRoZW1lVHlwZSB7XHJcbiAgbGlnaHQgPSAnbGlnaHQnLFxyXG4gIGRhcmsgPSAnZGFyaycsXHJcbiAgb3MgPSAnb3MnLFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9BVVRPX0xPQ0tfVElNRV9MSU1JVCA9IDA7XHJcbiIsImltcG9ydCB7XHJcbiAgRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxuICBURVNUX0VUSF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgQk5CX1RPS0VOX0lNQUdFX1VSTCxcclxuICBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXHJcbiAgQVZBWF9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgQ1VSUkVOQ1lfU1lNQk9MUyxcclxuICBDSEFJTl9JRFMsXHJcbn0gZnJvbSAnLi9uZXR3b3JrJztcclxuXHJcbmV4cG9ydCBjb25zdCBRVU9URVNfRVhQSVJFRF9FUlJPUiA9ICdxdW90ZXMtZXhwaXJlZCc7XHJcbmV4cG9ydCBjb25zdCBTV0FQX0ZBSUxFRF9FUlJPUiA9ICdzd2FwLWZhaWxlZC1lcnJvcic7XHJcbmV4cG9ydCBjb25zdCBFUlJPUl9GRVRDSElOR19RVU9URVMgPSAnZXJyb3ItZmV0Y2hpbmctcXVvdGVzJztcclxuZXhwb3J0IGNvbnN0IFFVT1RFU19OT1RfQVZBSUxBQkxFX0VSUk9SID0gJ3F1b3Rlcy1ub3QtYXZpbGFibGUnO1xyXG5leHBvcnQgY29uc3QgQ09OVFJBQ1RfREFUQV9ESVNBQkxFRF9FUlJPUiA9ICdjb250cmFjdC1kYXRhLWRpc2FibGVkJztcclxuZXhwb3J0IGNvbnN0IE9GRkxJTkVfRk9SX01BSU5URU5BTkNFID0gJ29mZmxpbmUtZm9yLW1haW50ZW5hbmNlJztcclxuZXhwb3J0IGNvbnN0IFNXQVBTX0ZFVENIX09SREVSX0NPTkZMSUNUID0gJ3N3YXBzLWZldGNoLW9yZGVyLWNvbmZsaWN0JztcclxuZXhwb3J0IGNvbnN0IFNMSVBQQUdFX09WRVJfTElNSVRfRVJST1IgPSAnc2xpcHBhZ2Utb3Zlci1saW1pdCc7XHJcbmV4cG9ydCBjb25zdCBTTElQUEFHRV9WRVJZX0hJR0hfRVJST1IgPSAnc2xpcHBhZ2UtdmVyeS1oaWdoJztcclxuZXhwb3J0IGNvbnN0IFNMSVBQQUdFX1RPT19MT1dfRVJST1IgPSAnc2xpcHBhZ2UtdG9vLWxvdyc7XHJcbmV4cG9ydCBjb25zdCBTTElQUEFHRV9ORUdBVElWRV9FUlJPUiA9ICdzbGlwcGFnZS1uZWdhdGl2ZSc7XHJcblxyXG4vLyBBbiBhZGRyZXNzIHRoYXQgdGhlIG1ldGFzd2FwLWFwaSByZWNvZ25pemVzIGFzIHRoZSBkZWZhdWx0IHRva2VuIGZvciB0aGUgY3VycmVudCBuZXR3b3JrLFxyXG4vLyBpbiBwbGFjZSBvZiB0aGUgdG9rZW4gYWRkcmVzcyB0aGF0IEVSQy0yMCB0b2tlbnMgaGF2ZVxyXG5jb25zdCBERUZBVUxUX1RPS0VOX0FERFJFU1MgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3dhcHNUb2tlbk9iamVjdCB7XHJcbiAgLyoqXHJcbiAgICogVGhlIHN5bWJvbCBvZiB0b2tlbiBvYmplY3RcclxuICAgKi9cclxuICBzeW1ib2w6IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgbmFtZSBmb3IgdGhlIG5ldHdvcmtcclxuICAgKi9cclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogQW4gYWRkcmVzcyB0aGF0IHRoZSBtZXRhc3dhcC1hcGkgcmVjb2duaXplcyBhcyB0aGUgZGVmYXVsdCB0b2tlblxyXG4gICAqL1xyXG4gIGFkZHJlc3M6IHN0cmluZztcclxuICAvKipcclxuICAgKiBOdW1iZXIgb2YgZGlnaXRzIGFmdGVyIGRlY2ltYWwgcG9pbnRcclxuICAgKi9cclxuICBkZWNpbWFsczogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIFVSTCBmb3IgdG9rZW4gaWNvblxyXG4gICAqL1xyXG4gIGljb25Vcmw6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEVUSF9TV0FQU19UT0tFTl9PQkpFQ1Q6IFN3YXBzVG9rZW5PYmplY3QgPSB7XHJcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcclxuICBuYW1lOiAnRXRoZXInLFxyXG4gIGFkZHJlc3M6IERFRkFVTFRfVE9LRU5fQUREUkVTUyxcclxuICBkZWNpbWFsczogMTgsXHJcbiAgaWNvblVybDogRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBCTkJfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5CTkIsXHJcbiAgbmFtZTogJ0JpbmFuY2UgQ29pbicsXHJcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxyXG4gIGRlY2ltYWxzOiAxOCxcclxuICBpY29uVXJsOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IE1BVElDX1NXQVBTX1RPS0VOX09CSkVDVDogU3dhcHNUb2tlbk9iamVjdCA9IHtcclxuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuTUFUSUMsXHJcbiAgbmFtZTogJ01hdGljJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6IE1BVElDX1RPS0VOX0lNQUdFX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBBVkFYX1NXQVBTX1RPS0VOX09CSkVDVDogU3dhcHNUb2tlbk9iamVjdCA9IHtcclxuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFLFxyXG4gIG5hbWU6ICdBdmFsYW5jaGUnLFxyXG4gIGFkZHJlc3M6IERFRkFVTFRfVE9LRU5fQUREUkVTUyxcclxuICBkZWNpbWFsczogMTgsXHJcbiAgaWNvblVybDogQVZBWF9UT0tFTl9JTUFHRV9VUkwsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgVEVTVF9FVEhfU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5URVNUX0VUSCxcclxuICBuYW1lOiAnVGVzdCBFdGhlcicsXHJcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxyXG4gIGRlY2ltYWxzOiAxOCxcclxuICBpY29uVXJsOiBURVNUX0VUSF9UT0tFTl9JTUFHRV9VUkwsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgR09FUkxJX1NXQVBTX1RPS0VOX09CSkVDVDogU3dhcHNUb2tlbk9iamVjdCA9IHtcclxuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxyXG4gIG5hbWU6ICdFdGhlcicsXHJcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxyXG4gIGRlY2ltYWxzOiAxOCxcclxuICBpY29uVXJsOiBURVNUX0VUSF9UT0tFTl9JTUFHRV9VUkwsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgQVJCSVRSVU1fU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xyXG4gIC4uLkVUSF9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgT1BUSU1JU01fU1dBUFNfVE9LRU5fT0JKRUNUOiBTd2Fwc1Rva2VuT2JqZWN0ID0ge1xyXG4gIC4uLkVUSF9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG4vLyBBIGdhcyB2YWx1ZSBmb3IgRVJDMjAgYXBwcm92ZSBjYWxscyB0aGF0IHNob3VsZCBiZSBzdWZmaWNpZW50IGZvciBhbGwgRVJDMjAgYXBwcm92ZSBpbXBsZW1lbnRhdGlvbnNcclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRVJDMjBfQVBQUk9WRV9HQVMgPSAnMHgxZDRjMCc7XHJcblxyXG4vLyBDb250cmFjdCBhZGRyZXNzZXMgYmVsb3cgc2hvdWxkIGJlIGluIGxvd2VyY2FzZS5cclxuY29uc3QgTUFJTk5FVF9DT05UUkFDVF9BRERSRVNTID0gJzB4ODgxZDQwMjM3NjU5YzI1MTgxMWNlYzljMzY0ZWY5MWRjMDhkMzAwYyc7XHJcbmNvbnN0IFRFU1RORVRfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDg4MWQ0MDIzNzY1OWMyNTE4MTFjZWM5YzM2NGVmOTFkYzA4ZDMwMGMnO1xyXG5jb25zdCBCU0NfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDFhMWVjMjVkYzA4ZTk4ZTVlOTNmMTEwNGI1ZTVjZGQyOTg3MDdkMzEnO1xyXG5jb25zdCBQT0xZR09OX0NPTlRSQUNUX0FERFJFU1MgPSAnMHgxYTFlYzI1ZGMwOGU5OGU1ZTkzZjExMDRiNWU1Y2RkMjk4NzA3ZDMxJztcclxuY29uc3QgQVZBTEFOQ0hFX0NPTlRSQUNUX0FERFJFU1MgPSAnMHgxYTFlYzI1ZGMwOGU5OGU1ZTkzZjExMDRiNWU1Y2RkMjk4NzA3ZDMxJztcclxuY29uc3QgT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyA9ICcweDlkZGE2ZWYzZDkxOWM5YmM4ODg1ZDU1NjA5OTlhMzY0MDQzMWU4ZTYnO1xyXG5jb25zdCBBUkJJVFJVTV9DT05UUkFDVF9BRERSRVNTID0gJzB4OWRkYTZlZjNkOTE5YzliYzg4ODVkNTU2MDk5OWEzNjQwNDMxZThlNic7XHJcblxyXG5leHBvcnQgY29uc3QgV0VUSF9DT05UUkFDVF9BRERSRVNTID1cclxuICAnMHhjMDJhYWEzOWIyMjNmZThkMGEwZTVjNGYyN2VhZDkwODNjNzU2Y2MyJztcclxuZXhwb3J0IGNvbnN0IFdFVEhfR09FUkxJX0NPTlRSQUNUX0FERFJFU1MgPVxyXG4gICcweEI0RkJGMjcxMTQzRjRGQmY3QjkxQTVkZWQzMTgwNWU0MmIyMjA4ZDYnO1xyXG5leHBvcnQgY29uc3QgV0JOQl9DT05UUkFDVF9BRERSRVNTID1cclxuICAnMHhiYjRjZGI5Y2JkMzZiMDFiZDFjYmFlYmYyZGUwOGQ5MTczYmMwOTVjJztcclxuZXhwb3J0IGNvbnN0IFdNQVRJQ19DT05UUkFDVF9BRERSRVNTID1cclxuICAnMHgwZDUwMGIxZDhlOGVmMzFlMjFjOTlkMWRiOWE2NDQ0ZDNhZGYxMjcwJztcclxuZXhwb3J0IGNvbnN0IFdBVkFYX0NPTlRSQUNUX0FERFJFU1MgPVxyXG4gICcweGIzMWY2NmFhM2MxZTc4NTM2M2YwODc1YTFiNzRlMjdiODVmZDY2YzcnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFdFVEhfT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyA9XHJcbiAgJzB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNic7XHJcbmV4cG9ydCBjb25zdCBXRVRIX0FSQklUUlVNX0NPTlRSQUNUX0FERFJFU1MgPVxyXG4gICcweDgyYWY0OTQ0N2Q4YTA3ZTNiZDk1YmQwZDU2ZjM1MjQxNTIzZmJhYjEnO1xyXG5cclxuY29uc3QgU1dBUFNfVEVTVE5FVF9DSEFJTl9JRCA9ICcweDUzOSc7XHJcblxyXG5leHBvcnQgY29uc3QgU1dBUFNfQVBJX1YyX0JBU0VfVVJMID0gJ2h0dHBzOi8vc3dhcC5tZXRhc3dhcC5jb2RlZmkubmV0d29yayc7XHJcbmV4cG9ydCBjb25zdCBTV0FQU19ERVZfQVBJX1YyX0JBU0VfVVJMID0gJ2h0dHBzOi8vc3dhcC5kZXYtYXBpLmN4Lm1ldGFtYXNrLmlvJztcclxuZXhwb3J0IGNvbnN0IEdBU19BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9nYXMtYXBpLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrJztcclxuZXhwb3J0IGNvbnN0IEdBU19ERVZfQVBJX0JBU0VfVVJMID1cclxuICAnaHR0cHM6Ly9nYXMtYXBpLm1ldGFzd2FwLWRldi5jb2RlZmkubmV0d29yayc7XHJcblxyXG5jb25zdCBCU0NfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9ic2NzY2FuLmNvbS8nO1xyXG5jb25zdCBNQUlOTkVUX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMID0gJ2h0dHBzOi8vZXRoZXJzY2FuLmlvLyc7XHJcbmNvbnN0IEdPRVJMSV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2dvZXJsaS5ldGhlcnNjYW4uaW8vJztcclxuY29uc3QgUE9MWUdPTl9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL3BvbHlnb25zY2FuLmNvbS8nO1xyXG5jb25zdCBBVkFMQU5DSEVfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9zbm93dHJhY2UuaW8vJztcclxuY29uc3QgT1BUSU1JU01fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9vcHRpbWlzdGljLmV0aGVyc2Nhbi5pby8nO1xyXG5jb25zdCBBUkJJVFJVTV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2FyYmlzY2FuLmlvLyc7XHJcblxyXG5leHBvcnQgY29uc3QgQUxMT1dFRF9QUk9EX1NXQVBTX0NIQUlOX0lEUyA9IFtcclxuICBDSEFJTl9JRFMuTUFJTk5FVCxcclxuICBTV0FQU19URVNUTkVUX0NIQUlOX0lELFxyXG4gIENIQUlOX0lEUy5CU0MsXHJcbiAgQ0hBSU5fSURTLlBPTFlHT04sXHJcbiAgQ0hBSU5fSURTLkFWQUxBTkNIRSxcclxuICBDSEFJTl9JRFMuT1BUSU1JU00sXHJcbiAgQ0hBSU5fSURTLkFSQklUUlVNLFxyXG5dIGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMTE9XRURfREVWX1NXQVBTX0NIQUlOX0lEUyA9IFtcclxuICAuLi5BTExPV0VEX1BST0RfU1dBUFNfQ0hBSU5fSURTLFxyXG4gIENIQUlOX0lEUy5HT0VSTEksXHJcbl0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgQUxMT1dFRF9TTUFSVF9UUkFOU0FDVElPTlNfQ0hBSU5fSURTID0gW1xyXG4gIENIQUlOX0lEUy5NQUlOTkVULFxyXG4gIENIQUlOX0lEUy5HT0VSTEksXHJcbl0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBURVNUTkVUX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5CU0NdOiBCU0NfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBQT0xZR09OX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBURVNUTkVUX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFMQU5DSEVfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogQVJCSVRSVU1fQ09OVFJBQ1RfQUREUkVTUyxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVMgPSB7XHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogV0VUSF9DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXTogV0VUSF9DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuQlNDXTogV0JOQl9DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFdNQVRJQ19DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogV0VUSF9HT0VSTElfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IFdBVkFYX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IFdFVEhfT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogV0VUSF9BUkJJVFJVTV9DT05UUkFDVF9BRERSRVNTLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMTE9XRURfQ09OVFJBQ1RfQUREUkVTU0VTID0ge1xyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLk1BSU5ORVRdLFxyXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5NQUlOTkVUXSxcclxuICBdLFxyXG4gIFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tTV0FQU19URVNUTkVUX0NIQUlOX0lEXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuR09FUkxJXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuR09FUkxJXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuQlNDXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuQlNDXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuQlNDXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLlBPTFlHT05dLFxyXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5QT0xZR09OXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogW1xyXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuQVZBTEFOQ0hFXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuQVZBTEFOQ0hFXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBbXHJcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5PUFRJTUlTTV0sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLk9QVElNSVNNXSxcclxuICBdLFxyXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBbXHJcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5BUkJJVFJVTV0sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkFSQklUUlVNXSxcclxuICBdLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVAgPSB7XHJcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcclxuICBbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF06IFRFU1RfRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcclxuICBbQ0hBSU5fSURTLkJTQ106IEJOQl9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbiAgW0NIQUlOX0lEUy5QT0xZR09OXTogTUFUSUNfU1dBUFNfVE9LRU5fT0JKRUNULFxyXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX1NXQVBTX1RPS0VOX09CSkVDVCxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IEFWQVhfU1dBUFNfVE9LRU5fT0JKRUNULFxyXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBPUFRJTUlTTV9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IEFSQklUUlVNX1NXQVBTX1RPS0VOX09CSkVDVCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLkJTQ106IEJTQ19ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFBPTFlHT05fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBHT0VSTElfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFMQU5DSEVfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IE9QVElNSVNNX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxyXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBBUkJJVFJVTV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBFVEhFUkVVTSA9ICdldGhlcmV1bSc7XHJcbmV4cG9ydCBjb25zdCBQT0xZR09OID0gJ3BvbHlnb24nO1xyXG5leHBvcnQgY29uc3QgQlNDID0gJ2JzYyc7XHJcbmV4cG9ydCBjb25zdCBHT0VSTEkgPSAnZ29lcmxpJztcclxuZXhwb3J0IGNvbnN0IEFWQUxBTkNIRSA9ICdhdmFsYW5jaGUnO1xyXG5leHBvcnQgY29uc3QgT1BUSU1JU00gPSAnb3B0aW1pc20nO1xyXG5leHBvcnQgY29uc3QgQVJCSVRSVU0gPSAnYXJiaXRydW0nO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNXQVBTX0NMSUVOVF9JRCA9ICdleHRlbnNpb24nO1xyXG5cclxuZXhwb3J0IGVudW0gVG9rZW5CdWNrZXRQcmlvcml0eSB7XHJcbiAgb3duZWQgPSAnb3duZWQnLFxyXG4gIHRvcCA9ICd0b3AnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBTbGlwcGFnZSB7XHJcbiAgZGVmYXVsdCA9IDIsXHJcbiAgaGlnaCA9IDMsXHJcbn1cclxuIiwiZXhwb3J0IGNvbnN0IE1JTExJU0VDT05EID0gMTtcclxuZXhwb3J0IGNvbnN0IFNFQ09ORCA9IE1JTExJU0VDT05EICogMTAwMDtcclxuZXhwb3J0IGNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xyXG5leHBvcnQgY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwO1xyXG5leHBvcnQgY29uc3QgREFZID0gSE9VUiAqIDI0O1xyXG4iLCJpbXBvcnQgY29udHJhY3RNYXAgZnJvbSAnQG1ldGFtYXNrL2NvbnRyYWN0LW1ldGFkYXRhJztcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgbm9ybWFsaXplZCBsaXN0IG9mIGFkZHJlc3NlcyBleHBvcnRlZCBhcyBwYXJ0IG9mIHRoZSBjb250cmFjdE1hcCBpblxyXG4gKiBgQG1ldGFtYXNrL2NvbnRyYWN0LW1ldGFkYXRhYC4gVXNlZCBwcmltYXJpbHkgdG8gdmFsaWRhdGUgaWYgbWFudWFsbHkgZW50ZXJlZFxyXG4gKiBjb250cmFjdCBhZGRyZXNzZXMgZG8gbm90IG1hdGNoIG9uZSBvZiBvdXIgbGlzdGVkIHRva2Vuc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExJU1RFRF9DT05UUkFDVF9BRERSRVNTRVMgPSBPYmplY3Qua2V5cyhjb250cmFjdE1hcCkubWFwKFxyXG4gIChhZGRyZXNzKSA9PiBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXHJcbik7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gVG9rZW5EZXRhaWxzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlbGVjdGVkICdUT0tFTicgb3JcclxuICogICdORlQnIGNvbnRyYWN0LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N5bWJvbF0gLSBUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbi5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWNpbWFsc10gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9mIHRoZSBzZWxlY3RlZFxyXG4gKiAgJ0VSQzIwJyBhc3NldC5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b2tlbklkXSAtIFRoZSBpZCBvZiB0aGUgc2VsZWN0ZWQgJ05GVCcgYXNzZXQuXHJcbiAqIEBwcm9wZXJ0eSB7VG9rZW5TdGFuZGFyZFN0cmluZ3N9IFtzdGFuZGFyZF0gLSBUaGUgc3RhbmRhcmQgb2YgdGhlIHNlbGVjdGVkXHJcbiAqICBhc3NldC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBbaXNFUkM3MjFdIC0gVHJ1ZSB3aGVuIHRoZSBhc3NldCBpcyBhIEVSQzcyMSB0b2tlbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBTVEFUSUNfTUFJTk5FVF9UT0tFTl9MSVNUID0gT2JqZWN0LmtleXMoY29udHJhY3RNYXApLnJlZHVjZShcclxuICAoYWNjLCBiYXNlKSA9PiB7XHJcbiAgICBjb25zdCB7IGxvZ28sIC4uLnRva2VuTWV0YWRhdGEgfSA9IGNvbnRyYWN0TWFwW2Jhc2VdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4uYWNjLFxyXG4gICAgICBbYmFzZS50b0xvd2VyQ2FzZSgpXToge1xyXG4gICAgICAgIC4uLnRva2VuTWV0YWRhdGEsXHJcbiAgICAgICAgYWRkcmVzczogYmFzZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgIGljb25Vcmw6IGBpbWFnZXMvY29udHJhY3QvJHtsb2dvfWAsXHJcbiAgICAgICAgYWdncmVnYXRvcnM6IFtdLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9LFxyXG4gIHt9LFxyXG4pO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRPS0VOX0FQSV9NRVRBU1dBUF9DT0RFRklfVVJMID1cclxuICAnaHR0cHM6Ly90b2tlbi1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsvdG9rZW5zLyc7XHJcbmV4cG9ydCBjb25zdCBNQVhfVE9LRU5fQUxMT1dBTkNFX0FNT1VOVCA9IG5ldyBCaWdOdW1iZXIoMilcclxuICAucG93KDI1NilcclxuICAubWludXMoMSlcclxuICAudG9TdHJpbmcoMTApO1xyXG4vLyBudW1iZXIgd2l0aCBvcHRpb25hbCBkZWNpbWFsIHBvaW50IHVzaW5nIGEgY29tbWEgb3IgZG90XHJcbmV4cG9ydCBjb25zdCBOVU1fV19PUFRfREVDSU1BTF9DT01NQV9PUl9ET1RfUkVHRVggPVxyXG4gIC9eWzAtOV17MSx9KFssLl1bMC05XXsxLH0pPyQvdTtcclxuZXhwb3J0IGNvbnN0IERFQ0lNQUxfUkVHRVggPSAvXFwuKFxcZCopL3U7XHJcbiIsImltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdAZXRoZXJldW1qcy90eCc7XHJcblxyXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvblR5cGUge1xyXG4gIC8qKlxyXG4gICAqIEEgdHJhbnNhY3Rpb24gc3VibWl0dGVkIHdpdGggdGhlIHNhbWUgbm9uY2UgYXMgYSBwcmV2aW91cyB0cmFuc2FjdGlvbiwgYVxyXG4gICAqIGhpZ2hlciBnYXMgcHJpY2UgYW5kIGEgemVyb2VkIG91dCBzZW5kIGFtb3VudC4gVXNlZnVsIGZvciB1c2VycyB3aG9cclxuICAgKiBhY2NpZGVudGFsbHkgc2VuZCB0byBlcnJvbmVvdXMgYWRkcmVzc2VzIG9yIGlmIHRoZXkgc2VuZCB0b28gbXVjaC5cclxuICAgKi9cclxuICBjYW5jZWwgPSAnY2FuY2VsJyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIHRoYXQgaXMgaW50ZXJhY3Rpbmcgd2l0aCBhIHNtYXJ0IGNvbnRyYWN0J3MgbWV0aG9kcyB0aGF0IHdlXHJcbiAgICogaGF2ZSBub3QgdHJlYXRlZCBhcyBhIHNwZWNpYWwgY2FzZSwgc3VjaCBhcyBhcHByb3ZlLCB0cmFuc2ZlciwgYW5kXHJcbiAgICogdHJhbnNmZXJmcm9tXHJcbiAgICovXHJcbiAgY29udHJhY3RJbnRlcmFjdGlvbiA9ICdjb250cmFjdEludGVyYWN0aW9uJyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIHRoYXQgZGVwbG95ZWQgYSBzbWFydCBjb250cmFjdFxyXG4gICAqL1xyXG4gIGRlcGxveUNvbnRyYWN0ID0gJ2NvbnRyYWN0RGVwbG95bWVudCcsXHJcbiAgZXRoRGVjcnlwdCA9ICdldGhfZGVjcnlwdCcsXHJcbiAgZXRoR2V0RW5jcnlwdGlvblB1YmxpY0tleSA9ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXHJcbiAgLyoqXHJcbiAgICogQW4gaW5jb21pbmcgKGRlcG9zaXQpIHRyYW5zYWN0aW9uXHJcbiAgICovXHJcbiAgaW5jb21pbmcgPSAnaW5jb21pbmcnLFxyXG4gIHBlcnNvbmFsU2lnbiA9ICdwZXJzb25hbF9zaWduJyxcclxuICAvKipcclxuICAgKiBXaGVuIGEgdHJhbnNhY3Rpb24gaXMgZmFpbGVkIGl0IGNhbiBiZSByZXRyaWVkIGJ5XHJcbiAgICogcmVzdWJtaXR0aW5nIHRoZSBzYW1lIHRyYW5zYWN0aW9uIHdpdGggYSBoaWdoZXIgZ2FzIGZlZS4gVGhpcyB0eXBlIGlzIGFsc28gdXNlZFxyXG4gICAqIHRvIHNwZWVkIHVwIHBlbmRpbmcgdHJhbnNhY3Rpb25zLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBjcmVhdGluZyBhIG5ldyB0eCB3aXRoXHJcbiAgICogdGhlIHNhbWUgbm9uY2UgYW5kIGhpZ2hlciBnYXMgZmVlcy5cclxuICAgKi9cclxuICByZXRyeSA9ICdyZXRyeScsXHJcbiAgc2lnbiA9ICdldGhfc2lnbicsXHJcbiAgc2lnblR5cGVkRGF0YSA9ICdldGhfc2lnblR5cGVkRGF0YScsXHJcbiAgLyoqIEEgdHJhbnNhY3Rpb24gc2VuZGluZyBhIG5ldHdvcmsncyBuYXRpdmUgYXNzZXQgdG8gYSByZWNpcGllbnQgKi9cclxuICBzaW1wbGVTZW5kID0gJ3NpbXBsZVNlbmQnLFxyXG4gIHNtYXJ0ID0gJ3NtYXJ0JyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIHN3YXBwaW5nIG9uZSB0b2tlbiBmb3IgYW5vdGhlciB0aHJvdWdoIE1ldGFNYXNrIFN3YXBzXHJcbiAgICovXHJcbiAgc3dhcCA9ICdzd2FwJyxcclxuICAvKipcclxuICAgKiBTaW1pbGFyIHRvIHRoZSBhcHByb3ZlIHR5cGUsIGEgc3dhcCBhcHByb3ZhbCBpcyBhIHNwZWNpYWwgY2FzZSBvZiBFUkMyMFxyXG4gICAqIGFwcHJvdmUgbWV0aG9kIHRoYXQgcmVxdWVzdHMgYW4gYWxsb3dhbmNlIG9mIHRoZSB0b2tlbiB0byBzcGVuZCBvbiBiZWhhbGZcclxuICAgKiBvZiB0aGUgdXNlciBmb3IgdGhlIE1ldGFNYXNrIFN3YXBzIGNvbnRyYWN0LiBUaGUgZmlyc3Qgc3dhcCBmb3IgYW55IHRva2VuXHJcbiAgICogd2lsbCBoYXZlIGFuIGFjY29tcGFueWluZyBzd2FwQXBwcm92YWwgdHJhbnNhY3Rpb24uXHJcbiAgICovXHJcbiAgc3dhcEFwcHJvdmFsID0gJ3N3YXBBcHByb3ZhbCcsXHJcbiAgLyoqXHJcbiAgICogQSB0b2tlbiB0cmFuc2FjdGlvbiByZXF1ZXN0aW5nIGFuIGFsbG93YW5jZSBvZiB0aGUgdG9rZW4gdG8gc3BlbmQgb25cclxuICAgKiBiZWhhbGYgb2YgdGhlIHVzZXJcclxuICAgKi9cclxuICB0b2tlbk1ldGhvZEFwcHJvdmUgPSAnYXBwcm92ZScsXHJcbiAgLyoqXHJcbiAgICogQSB0b2tlbiB0cmFuc2FjdGlvbiB0cmFuc2ZlcnJpbmcgdG9rZW5zIGZyb20gYW4gYWNjb3VudCB0aGF0IHRoZSBzZW5kZXJcclxuICAgKiBoYXMgYW4gYWxsb3dhbmNlIG9mLiBUaGUgbWV0aG9kIGlzIHByZWZpeGVkIHdpdGggc2FmZSBiZWNhdXNlIHdoZW4gY2FsbGluZ1xyXG4gICAqIHRoaXMgbWV0aG9kIHRoZSBjb250cmFjdCBjaGVja3MgdG8gZW5zdXJlIHRoYXQgdGhlIHJlY2VpdmVyIGlzIGFuIGFkZHJlc3NcclxuICAgKiBjYXBhYmxlIG9mIGhhbmRsaW5nIHdpdGggdGhlIHRva2VuIGJlaW5nIHNlbnQuXHJcbiAgICovXHJcbiAgdG9rZW5NZXRob2RTYWZlVHJhbnNmZXJGcm9tID0gJ3NhZmV0cmFuc2ZlcmZyb20nLFxyXG4gIC8qKlxyXG4gICAqIEEgdG9rZW4gdHJhbnNhY3Rpb24gd2hlcmUgdGhlIHVzZXIgaXMgc2VuZGluZyB0b2tlbnMgdGhhdCB0aGV5IG93biB0b1xyXG4gICAqIGFub3RoZXIgYWRkcmVzc1xyXG4gICAqL1xyXG4gIHRva2VuTWV0aG9kVHJhbnNmZXIgPSAndHJhbnNmZXInLFxyXG4gIC8qKlxyXG4gICAqIEEgdG9rZW4gdHJhbnNhY3Rpb24gdHJhbnNmZXJyaW5nIHRva2VucyBmcm9tIGFuIGFjY291bnQgdGhhdCB0aGUgc2VuZGVyXHJcbiAgICogaGFzIGFuIGFsbG93YW5jZSBvZi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYWxsb3dhbmNlcywgc2VlIHRoZSBhcHByb3ZlXHJcbiAgICogdHlwZS5cclxuICAgKi9cclxuICB0b2tlbk1ldGhvZFRyYW5zZmVyRnJvbSA9ICd0cmFuc2ZlcmZyb20nLFxyXG4gIC8qKlxyXG4gICAqIEEgdG9rZW4gdHJhbnNhY3Rpb24gcmVxdWVzdGluZyBhbiBhbGxvd2FuY2Ugb2YgYWxsIG9mIGEgdXNlcidzIHRva2VuIHRvXHJcbiAgICogc3BlbmQgb24gYmVoYWxmIG9mIHRoZSB1c2VyXHJcbiAgICovXHJcbiAgdG9rZW5NZXRob2RTZXRBcHByb3ZhbEZvckFsbCA9ICdzZXRhcHByb3ZhbGZvcmFsbCcsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbiBFSVAtMjcxOCB0eXBlZCB0cmFuc2FjdGlvbiBlbnZlbG9wZXMgd2VyZSBzcGVjaWZpZWQsIHdpdGggdGhlIHZlcnkgZmlyc3RcclxuICogdHlwZWQgZW52ZWxvcGUgYmVpbmcgJ2xlZ2FjeScgYW5kIGRlc2NyaWJpbmcgdGhlIHNoYXBlIG9mIHRoZSBiYXNlXHJcbiAqIHRyYW5zYWN0aW9uIHBhcmFtcyB0aGF0IHdlcmUgaGl0aGVydG8gdGhlIG9ubHkgdHJhbnNhY3Rpb24gdHlwZSBzZW50IG9uXHJcbiAqIEV0aGVyZXVtLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gVHJhbnNhY3Rpb25FbnZlbG9wZVR5cGUge1xyXG4gIC8qKlxyXG4gICAqIEEgbGVnYWN5IHRyYW5zYWN0aW9uLCB0aGUgdmVyeSBmaXJzdCB0eXBlLlxyXG4gICAqL1xyXG4gIGxlZ2FjeSA9ICcweDAnLFxyXG4gIC8qKlxyXG4gICAqIEVJUC0yOTMwIGRlZmluZWQgdGhlIGFjY2VzcyBsaXN0IHRyYW5zYWN0aW9uIHR5cGUgdGhhdCBhbGxvd2VkIGZvclxyXG4gICAqIHNwZWNpZnlpbmcgdGhlIHN0YXRlIHRoYXQgYSB0cmFuc2FjdGlvbiB3b3VsZCBhY3QgdXBvbiBpbiBhZHZhbmNlIGFuZFxyXG4gICAqIHRoZW9yZXRpY2FsbHkgc2F2ZSBvbiBnYXMgZmVlcy5cclxuICAgKi9cclxuICBhY2Nlc3NMaXN0ID0gJzB4MScsXHJcbiAgLyoqXHJcbiAgICogVGhlIHR5cGUgaW50cm9kdWNlZCBjb21lcyBmcm9tIEVJUC0xNTU5LCBGZWUgTWFya2V0IGRlc2NyaWJlcyB0aGUgYWRkaXRpb25cclxuICAgKiBvZiBhIGJhc2VGZWUgdG8gYmxvY2tzIHRoYXQgd2lsbCBiZSBidXJuZWQgaW5zdGVhZCBvZiBkaXN0cmlidXRlZCB0b1xyXG4gICAqIG1pbmVycy4gVHJhbnNhY3Rpb25zIG9mIHRoaXMgdHlwZSBoYXZlIGJvdGggYSBtYXhGZWVQZXJHYXMgKG1heGltdW0gdG90YWxcclxuICAgKiBhbW91bnQgaW4gZ3dlaSBwZXIgZ2FzIHRvIHNwZW5kIG9uIHRoZSB0cmFuc2FjdGlvbikgd2hpY2ggaXMgaW5jbHVzaXZlIG9mXHJcbiAgICogdGhlIG1heFByaW9yaXR5RmVlUGVyR2FzIChtYXhpbXVtIGFtb3VudCBvZiBnd2VpIHBlciBnYXMgZnJvbSB0aGVcclxuICAgKiB0cmFuc2FjdGlvbiBmZWUgdG8gZGlzdHJpYnV0ZSB0byBtaW5lcikuXHJcbiAgICovXHJcbiAgZmVlTWFya2V0ID0gJzB4MicsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2FjdGlvbiBTdGF0dXMgaXMgYSBtaXggb2YgRXRoZXJldW0gYW5kIE1ldGFNYXNrIHRlcm1pbm9sb2d5LCB1c2VkIGludGVybmFsbHlcclxuICogZm9yIHRyYW5zYWN0aW9uIHByb2Nlc3NpbmcuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvblN0YXR1cyB7XHJcbiAgLyoqXHJcbiAgICogQSBuZXcgdHJhbnNhY3Rpb24gdGhhdCB0aGUgdXNlciBoYXMgbm90IGFwcHJvdmVkIG9yIHJlamVjdGVkXHJcbiAgICovXHJcbiAgdW5hcHByb3ZlZCA9ICd1bmFwcHJvdmVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdXNlciBoYXMgYXBwcm92ZWQgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBNZXRhTWFzayBVSVxyXG4gICAqL1xyXG4gIGFwcHJvdmVkID0gJ2FwcHJvdmVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdXNlciBoYXMgcmVqZWN0ZWQgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBNZXRhTWFzayBVSVxyXG4gICAqL1xyXG4gIHJlamVjdGVkID0gJ3JlamVjdGVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkXHJcbiAgICovXHJcbiAgc2lnbmVkID0gJ3NpZ25lZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHN1Ym1pdHRlZCB0byBuZXR3b3JrXHJcbiAgICovXHJcbiAgc3VibWl0dGVkID0gJ3N1Ym1pdHRlZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIGhhcyBmYWlsZWQgZm9yIHNvbWUgcmVhc29uXHJcbiAgICovXHJcbiAgZmFpbGVkID0gJ2ZhaWxlZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIHdhcyBkcm9wcGVkIGR1ZSB0byBhIHR4IHdpdGggc2FtZSBub25jZSBiZWluZyBhY2NlcHRlZFxyXG4gICAqL1xyXG4gIGRyb3BwZWQgPSAnZHJvcHBlZCcsXHJcbiAgLyoqXHJcbiAgICogVGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgYnkgdGhlIG5ldHdvcmtcclxuICAgKi9cclxuICBjb25maXJtZWQgPSAnY29uZmlybWVkJyxcclxuICAvKipcclxuICAgKiBUaGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkIGFuZCBpcyB3YWl0aW5nIHRvIGVpdGhlciBiZSBjb25maXJtZWQsXHJcbiAgICogZHJvcHBlZCBvciBmYWlsZWQuIFRoaXMgaXMgYSBcImZha2VcIiBzdGF0dXMgdGhhdCB3ZSB1c2UgdG8gZ3JvdXAgc3RhdHVzZXNcclxuICAgKiB0aGF0IGFyZSB2ZXJ5IHNpbWlsYXIgZnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlIChhcHByb3ZlZCxcclxuICAgKiBzaWduZWQsIHN1Ym1pdHRlZCkuIFRoZSBvbmx5IG5vdGFibGUgY2FzZSB3aGVyZSBhcHByb3ZlIGFuZCBzaWduZWQgYXJlXHJcbiAgICogZGlmZmVyZW50IGZyb20gdXNlciBwZXJzcGVjdGl2ZSBpcyBpbiBoYXJkd2FyZSB3YWxsZXRzIHdoZXJlIHRoZVxyXG4gICAqIHRyYW5zYWN0aW9uIGlzIHNpZ25lZCBvbiBhbiBleHRlcm5hbCBkZXZpY2UuIE90aGVyd2lzZSBzaWduaW5nIGhhcHBlbnNcclxuICAgKiB0cmFuc3BhcmVudGx5IHRvIHVzZXJzLlxyXG4gICAqL1xyXG4gIHBlbmRpbmcgPSAncGVuZGluZycsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXaXRoIHRoaXMgbGlzdCB3ZSBjYW4gZGV0ZWN0IGlmIGEgdHJhbnNhY3Rpb24gaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSU5fUFJPR1JFU1NfVFJBTlNBQ1RJT05fU1RBVFVTRVMgPSBbXHJcbiAgVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCxcclxuICBUcmFuc2FjdGlvblN0YXR1cy5hcHByb3ZlZCxcclxuICBUcmFuc2FjdGlvblN0YXR1cy5zaWduZWQsXHJcbiAgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkLFxyXG4gIFRyYW5zYWN0aW9uU3RhdHVzLnBlbmRpbmcsXHJcbl07XHJcblxyXG5cblxyXG4vKipcclxuICogVHJhbnNhY3Rpb24gR3JvdXAgU3RhdHVzIGlzIGEgTWV0YU1hc2sgY29uc3RydWN0IHRvIHRyYWNrIHRoZSBzdGF0dXMgb2YgZ3JvdXBzXHJcbiAqIG9mIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uR3JvdXBTdGF0dXMge1xyXG4gIC8qKlxyXG4gICAqIEEgY2FuY2VsIHR5cGUgdHJhbnNhY3Rpb24gaW4gdGhlIGdyb3VwIHdhcyBjb25maXJtZWRcclxuICAgKi9cclxuICBjYW5jZWxsZWQgPSAnY2FuY2VsbGVkJyxcclxuICAvKipcclxuICAgKiBUaGUgcHJpbWFyeVRyYW5zYWN0aW9uIG9mIHRoZSBncm91cCBoYXMgYSBzdGF0dXMgdGhhdCBpcyBvbmUgb2ZcclxuICAgKiBUcmFuc2FjdGlvblN0YXR1cy5hcHByb3ZlZCwgVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCBvclxyXG4gICAqIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZFxyXG4gICAqL1xyXG4gIHBlbmRpbmcgPSAncGVuZGluZycsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGF0dXNlcyB0aGF0IGFyZSBzcGVjaWZpYyB0byBTbWFydCBUcmFuc2FjdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBTbWFydFRyYW5zYWN0aW9uU3RhdHVzIHtcclxuICAvKiogSXQgY2FuIGJlIGNhbmNlbGxlZCBmb3IgdmFyaW91cyByZWFzb25zLiAqL1xyXG4gIGNhbmNlbGxlZCA9ICdjYW5jZWxsZWQnLFxyXG4gIC8qKiBTbWFydCB0cmFuc2FjdGlvbiBpcyBiZWluZyBwcm9jZXNzZWQuICovXHJcbiAgcGVuZGluZyA9ICdwZW5kaW5nJyxcclxuICAvKiogU21hcnQgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBtaW5lZC4gKi9cclxuICBzdWNjZXNzID0gJ3N1Y2Nlc3MnLFxyXG59XHJcblxyXG4vKipcclxuICogVHlwZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhlIHRyYW5zYWN0aW9uIGFwcHJvdmFsIGFtb3VudC5cclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uQXBwcm92YWxBbW91bnRUeXBlIHtcclxuICAvKiogVGhlIHVzZXIgaGFzIGVkaXRlZCB0aGUgdG9rZW4gYW1vdW50LiAqL1xyXG4gIGN1c3RvbSA9ICdjdXN0b20nLFxyXG4gIC8qKiBUaGUgc2VsZWN0ZWQgYW1vdW50IChlaXRoZXIgY3VzdG9tIG9yIGRhcHBQcm9wb3NlZCkgaXMgMC4gKi9cclxuICByZXZva2UgPSAncmV2b2tlJyxcclxuICAvKiogVGhlIGRhcHAgcHJvcG9zZWQgdG9rZW4gYW1vdW50LiAqL1xyXG4gIGRhcHBQcm9wb3NlZCA9ICdkYXBwX3Byb3Bvc2VkJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYW5zYWN0aW9uIEdyb3VwIENhdGVnb3J5IGlzIGEgTWV0YU1hc2sgY29uc3RydWN0IHRvIGNhdGVnb3JpemUgdGhlIGludGVudFxyXG4gKiBvZiBhIGdyb3VwIG9mIHRyYW5zYWN0aW9ucyBmb3IgcHVycG9zZXMgb2YgZGlzcGxheWluZyBpbiB0aGUgVUlcclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uR3JvdXBDYXRlZ29yeSB7XHJcbiAgLyoqXHJcbiAgICogVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGEgcmVxdWVzdCBmb3IgYW4gYWxsb3dhbmNlIG9mIGEgdG9rZW4gdG9cclxuICAgKiBzcGVuZCBvbiB0aGUgdXNlcidzIGJlaGFsZi5cclxuICAgKi9cclxuICBhcHByb3ZhbCA9ICdhcHByb3ZhbCcsXHJcbiAgLyoqXHJcbiAgICogVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGFuIGludGVyYWN0aW9uIHdpdGggYSBzbWFydCBjb250cmFjdCdzIG1ldGhvZHMuXHJcbiAgICovXHJcbiAgaW50ZXJhY3Rpb24gPSAnaW50ZXJhY3Rpb24nLFxyXG4gIC8qKlxyXG4gICAqIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBhIGRlcG9zaXQvaW5jb21pbmcgdHJhbnNhY3Rpb24uIFRoaXNcclxuICAgKiBjYXRlZ29yeSBtYXBzIDE6MSB3aXRoIFRyYW5zYWN0aW9uVHlwZS5pbmNvbWluZy5cclxuICAgKi9cclxuICByZWNlaXZlID0gJ3JlY2VpdmUnLFxyXG4gIC8qKlxyXG4gICAqIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyB0aGUgbmV0d29yayBuYXRpdmUgY3VycmVuY3kgYmVpbmcgc2VudCBmcm9tXHJcbiAgICogdGhlIHVzZXIuXHJcbiAgICovXHJcbiAgc2VuZCA9ICdzZW5kJyxcclxuICAvKipcclxuICAgKiBUcmFuc2FjdGlvbiBncm91cCByZXByZXNlbnRpbmcgYSBzaWduYXR1cmUgcmVxdWVzdCBUaGlzIGN1cnJlbnRseSBvbmx5XHJcbiAgICogc2hvd3MgdXAgaW4gdGhlIFVJIHdoZW4gaXRzIHBlbmRpbmcgdXNlciBhcHByb3ZhbCBpbiB0aGUgVUkuIE9uY2UgdGhlIHVzZXJcclxuICAgKiBhcHByb3ZlcyBvciByZWplY3RzIGl0IHdpbGwgbm8gbG9uZ2VyIHNob3cgaW4gYWN0aXZpdHkuXHJcbiAgICovXHJcbiAgc2lnbmF0dXJlUmVxdWVzdCA9ICdzaWduYXR1cmUtcmVxdWVzdCcsXHJcbiAgLyoqXHJcbiAgICogVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGEgdG9rZW4gc3dhcCB0aHJvdWdoIE1ldGFNYXNrIFN3YXBzLiBUaGlzXHJcbiAgICogdHJhbnNhY3Rpb24gZ3JvdXAncyBwcmltYXJ5IGN1cnJlbmN5IGNoYW5nZXMgZGVwZW5kaW5nIG9uIGNvbnRleHQuIElmIHRoZVxyXG4gICAqIHVzZXIgaXMgdmlld2luZyBhbiBhc3NldCBwYWdlIGZvciBhIHRva2VuIHJlY2VpdmVkIGZyb20gYSBzd2FwLCB0aGVcclxuICAgKiBwcmltYXJ5IGN1cnJlbmN5IHdpbGwgYmUgdGhlIHJlY2VpdmVkIHRva2VuLiBPdGhlcndpc2UgdGhlIHRva2VuIGV4Y2hhbmdlZFxyXG4gICAqIHdpbGwgYmUgc2hvd24uXHJcbiAgICovXHJcbiAgc3dhcCA9ICdzd2FwJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgcGFyYW1ldGVycyBvZiBhIHRyYW5zYWN0aW9uIHRvIHN1Ym1pdCB0byB0aGUgbmV0d29ya1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUeFBhcmFtcyB7XHJcbiAgLyoqIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiBpcyBzZW50IGZyb20gKi9cclxuICBmcm9tOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiBpcyBzZW50IHRvICovXHJcbiAgdG86IHN0cmluZztcclxuICAvKiogVGhlIGFtb3VudCBvZiB3ZWksIGluIGhleGFkZWNpbWFsLCB0byBzZW5kICovXHJcbiAgdmFsdWU6IHN0cmluZztcclxuICAvKiogVGhlIHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGUgY3VycmVudCBhY2NvdW50L25ldHdvcmsgKi9cclxuICBub25jZTogbnVtYmVyO1xyXG4gIC8qKiBUaGUgYW1vdW50IG9mIGd3ZWksIGluIGhleGFkZWNpbWFsLCBwZXIgdW5pdCBvZiBnYXMgKi9cclxuICBnYXNQcmljZT86IHN0cmluZztcclxuICAvKiogVGhlIG1heCBhbW91bnQgb2YgZ3dlaSwgaW4gaGV4YWRlY2ltYWwsIHRoZSB1c2VyIGlzIHdpbGxpbmcgdG8gcGF5ICovXHJcbiAgZ2FzOiBzdHJpbmc7XHJcbiAgLyoqIEhleGFkZWNpbWFsIGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyBjYWxscyB0byB0aGUgRVZNJ3MgQUJJICovXHJcbiAgZGF0YT86IHN0cmluZztcclxuICAvKipcclxuICAgKiBFSVAtMjkzMCBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI5MzAgYWRkZWQgdGhlIGFiaWxpdHkgZm9yXHJcbiAgICogdHJhbnNhY3Rpb25zIHRvIHNwZWNpZnkgd2hpY2ggYWRkcmVzc2VzIHRoZXkgd2lsbCBpbnRlcmFjdCB3aXRoIGFuZCBhbGxvd3NcclxuICAgKiBmb3IgbG93ZXIgZ2FzIGZlZXMgb24gc3BlY2lmaWMgb3Bjb2Rlcy4gU2VlIHRoZSBFSVAgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgKi9cclxuICBhY2Nlc3NMaXN0PzogQWNjZXNzTGlzdDtcclxuICBtYXhGZWVQZXJHYXM/OiBzdHJpbmc7XHJcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHhSZWNlaXB0IHtcclxuICBibG9ja0hhc2g/OiBzdHJpbmc7XHJcbiAgYmxvY2tOdW1iZXI/OiBzdHJpbmc7XHJcbiAgdHJhbnNhY3Rpb25JbmRleD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUeEVycm9yIHtcclxuICAvKiogVGhlIG1lc3NhZ2UgZnJvbSB0aGUgZW5jb3VudGVyZWQgZXJyb3IuICovXHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgXCJ2YWx1ZVwiIG9mIHRoZSBlcnJvci4gKi9cclxuICBycGM6IGFueTtcclxuICAvKiogdGhlIHN0YWNrIHRyYWNlIGZyb20gdGhlIGVycm9yLCBpZiBhdmFpbGFibGUuICovXHJcbiAgc3RhY2s/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXZSBhdHRhY2ggYW4gb2JqZWN0IHRvIHRyYW5zYWN0aW9ucyBwcm9wb3NlZCBieSBkYXBwcyB0byBzaG93IHRoZSB2YWx1ZXNcclxuICogdGhhdCB0aGUgZGFwcCBzdWdnZXN0ZWQgZm9yIGdhcyBmZWVzLiBUaGlzIGlzIHVzZWQgdG8gY29tcGFyZSB0byB3aGF0IG91clxyXG4gKiBpbnRlcm5hbCBnYXMgcHJpY2UgbG9naWMgd291bGQgaGF2ZSB0aGUgdHJhbnNhY3Rpb24gcHJpY2VkIGF0IGZvciBtZXRyaWNzXHJcbiAqIHdpdGggdGhlIGFpbSBvZiBpbXByb3Zpbmcgb3VyIHN1Z2dlc3Rpb25zIGFzIHdlbGwgYXMgZ2l2aW5nIHRoZSB1c2VyIHRoZVxyXG4gKiBvcHRpb24gdG8gcmV0dXJuIHRvIHRoZSBkZWZhdWx0cyBzdWdnZXN0ZWQgYnkgdGhlIGRhcHAgaWYgdGhleSBoYXZlIGVkaXRlZFxyXG4gKiB0aGUgZ2FzIGZlZXMgb24gdGhlIGNvbmZpcm1hdGlvbiBzY3JlZW4uXHJcbiAqL1xyXG5pbnRlcmZhY2UgRGFwcFN1Z2dlc3RlZEdhc0ZlZXMge1xyXG4gIGdhc1ByaWNlPzogc3RyaW5nO1xyXG4gIG1heEZlZVBlckdhcz86IHN0cmluZztcclxuICBtYXhQcmlvcml0eUZlZVBlckdhcz86IHN0cmluZztcclxuICBnYXM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHJhbnNhY3Rpb24sIGluIHdoYXRldmVyIHN0YXRlIGl0IGlzIGluLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbk1ldGEge1xyXG5cbiAgLyoqXHJcbiAgICogVGhlIGJsb2NrIG51bWJlciB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi4gQ3VycmVudGx5IG9ubHkgcHJlc2VudFxyXG4gICAqIG9uIGluY29taW5nIHRyYW5zYWN0aW9ucyFcclxuICAgKi9cclxuICBibG9ja051bWJlcj86IHN0cmluZztcclxuICAvKiogQW4gaW50ZXJuYWxseSB1bmlxdWUgdHggaWRlbnRpZmllci4gKi9cclxuICBpZDogbnVtYmVyO1xyXG4gIC8qKiBUaW1lIHRoZSB0cmFuc2FjdGlvbiB3YXMgZmlyc3Qgc3VnZ2VzdGVkLCBpbiB1bml4IGVwb2NoIHRpbWUgKG1zKS4gKi9cclxuICB0aW1lOiBudW1iZXI7XHJcbiAgLyoqIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhIG5hbWUgb2YgdHJhbnNhY3Rpb24gY29udHJhY3QgbWV0aG9kLiAqL1xyXG4gIGNvbnRyYWN0TWV0aG9kTmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgY3VzdG9tIHRva2VuIGFtb3VudCBpcyB0aGUgYW1vdW50IHNldCBieSB0aGUgdXNlciAqL1xyXG4gIGN1c3RvbVRva2VuQW1vdW50OiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBkYXBwIHByb3Bvc2VkIHRva2VuIGFtb3VudCAqL1xyXG4gIGRhcHBQcm9wb3NlZFRva2VuQW1vdW50OiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBvcmlnaW5hbCBnYXMgZmVlcyBzdWdnZXN0ZWQgYnkgdGhlIGRhcHAgdGhhdCBwcm9wb3NlZCB0aGlzIHRyYW5zYWN0aW9uICovXHJcbiAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXM/OiBEYXBwU3VnZ2VzdGVkR2FzRmVlcztcclxuICAvKiogVGhlIGJhbGFuY2Ugb2YgdGhlIHRva2VuIHRoYXQgaXMgYmVpbmcgc2VudCAqL1xyXG4gIGN1cnJlbnRUb2tlbkJhbGFuY2U6IHN0cmluZztcclxuICAvKiogVGhlIG9yaWdpbmFsIGRhcHAgcHJvcG9zZWQgdG9rZW4gYXBwcm92YWwgYW1vdW50IGJlZm9yZSBlZGl0IGJ5IHVzZXIgKi9cclxuICBvcmlnaW5hbEFwcHJvdmFsQW1vdW50OiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgICogVGhlIGNob3NlbiBhbW91bnQgd2hpY2ggd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luYWxseSBwcm9wb3NlZCB0b2tlblxyXG4gICAqIGFtb3VudCBpZiB0aGUgdXNlciBkb2VzIG5vdCBlZGl0IHRoZSAgYW1vdW50IG9yIHdpbGwgYmUgYSBjdXN0b20gdG9rZW5cclxuICAgKiBhbW91bnQgc2V0IGJ5IHRoZSB1c2VyXHJcbiAgICovXHJcbiAgZmluYWxBcHByb3ZhbEFtb3VudDogc3RyaW5nO1xyXG4gIC8qKiBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvbiB0aGlzIHR4TWV0YSByZXByZXNlbnRzLiAqL1xyXG4gIHR5cGU6IFRyYW5zYWN0aW9uVHlwZTtcclxuICAvKipcclxuICAgKiBXaGVuIHdlIHNwZWVkIHVwIGEgdHJhbnNhY3Rpb24sIHdlIHNldCB0aGUgdHlwZSBhcyBSZXRyeSBhbmQgd2UgbG9zZVxyXG4gICAqIGluZm9ybWF0aW9uIGFib3V0IHR5cGUgb2YgdHJhbnNhY3Rpb24gdGhhdCBpcyBiZWluZyBzZXQgdXAsIHNvIHdlIHVzZVxyXG4gICAqIG9yaWdpbmFsIHR5cGUgdG8gdHJhY2sgdGhhdCBpbmZvcm1hdGlvbi5cclxuICAgKi9cclxuICBvcmlnaW5hbFR5cGU6IFRyYW5zYWN0aW9uVHlwZTtcclxuICAvKiogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSB0cmFuc2FjdGlvbi4gKi9cclxuICBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzO1xyXG4gIC8qKiBUaGUgdHJhbnNhY3Rpb24ncyBuZXR3b3JrIElELCB1c2VkIGZvciBFSVAtMTU1IGNvbXBsaWFuY2UuICovXHJcbiAgbWV0YW1hc2tOZXR3b3JrSWQ6IHN0cmluZztcclxuICAvKiogVE9ETzogRmluZCBvdXQgd2hhdCB0aGlzIGlzIGFuZCBkb2N1bWVudCBpdCAqL1xyXG4gIGxvYWRpbmdEZWZhdWx0czogYm9vbGVhbjtcclxuICAvKiogVGhlIHRyYW5zYWN0aW9uIHBhcmFtcyBhcyBwYXNzZWQgdG8gdGhlIG5ldHdvcmsgcHJvdmlkZXIuICovXHJcbiAgdHhQYXJhbXM6IFR4UGFyYW1zO1xyXG4gIHR4UmVjZWlwdDogVHhSZWNlaXB0O1xyXG4gIC8qKiBBIGhpc3Rvcnkgb2YgbXV0YXRpb25zIHRvIHRoaXMgVHJhbnNhY3Rpb25NZXRhIG9iamVjdC4gKi9cclxuICBoaXN0b3J5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+W107XHJcbiAgLyoqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaW50ZXJmYWNlIHRoYXQgc3VnZ2VzdGVkIHRoZSB0cmFuc2FjdGlvbi4gKi9cclxuICBvcmlnaW46IHN0cmluZztcclxuICAvKipcclxuICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yaWdpbmFsIGdhcyBlc3RpbWF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvblxyXG4gICAqIG1ldGFkYXRhLlxyXG4gICAqL1xyXG4gIG9yaWdpbmFsR2FzRXN0aW1hdGU6IHN0cmluZztcclxuICAvKiogQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGVuIHRoZSB1c2VyIG1hbnVhbGx5IGVkaXRlZCB0aGUgZ2FzIGxpbWl0LiAqL1xyXG4gIHVzZXJFZGl0ZWRHYXNMaW1pdDogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBBIG1ldGFkYXRhIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIHVzZWQgdG8gZGVyaXZlIHRoZSBzdWdnZXN0ZWRcclxuICAgKiBub25jZSwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgbm9uY2UgaXNzdWVzLlxyXG4gICAqL1xyXG4gIG5vbmNlRGV0YWlsczogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICAvKipcclxuICAgKiBBIGhleCBzdHJpbmcgb2YgdGhlIGZpbmFsIHNpZ25lZCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gc3VibWl0IHRvIHRoZVxyXG4gICAqIG5ldHdvcmsuXHJcbiAgICovXHJcbiAgcmF3VHg6IHN0cmluZztcclxuICAvKipcclxuICAgKiBBIGhleCBzdHJpbmcgb2YgdGhlIHRyYW5zYWN0aW9uIGhhc2gsIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICogb24gdGhlIG5ldHdvcmsuXHJcbiAgICovXHJcbiAgaGFzaDogc3RyaW5nO1xyXG4gIHY/OiBzdHJpbmc7XHJcbiAgcj86IHN0cmluZztcclxuICBzPzogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSB0aW1lIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VibWl0dGVkIHRvIHRoZSBuZXR3b3JrLCBpbiBVbml4IGVwb2NoIHRpbWVcclxuICAgKiAobXMpLlxyXG4gICAqL1xyXG4gIHN1Ym1pdHRlZFRpbWU/OiBudW1iZXI7XHJcbiAgLyoqIFRoZSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uICovXHJcbiAgdHhFcnI/OiBUeEVycm9yO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lcyB0aGUgcG9zc2libGUgdHlwZXNcclxuICovXHJcbmV4cG9ydCBlbnVtIFRyYW5zYWN0aW9uTWV0YU1ldHJpY3NFdmVudCB7XHJcbiAgLyoqXHJcbiAgICogQWxsIHRyYW5zYWN0aW9ucywgZXhjZXB0IGluY29taW5nIG9uZXMsIGFyZSBhZGRlZCB0byB0aGUgY29udHJvbGxlciBzdGF0ZVxyXG4gICAqIGluIGFuIHVuYXBwcm92ZWQgc3RhdHVzLiBXaGVuIHRoaXMgaGFwcGVucyB3ZSBmaXJlIHRoZSBUcmFuc2FjdGlvbiBBZGRlZFxyXG4gICAqIGV2ZW50IHRvIHNob3cgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHVzZXIncyBNZXRhTWFzay5cclxuICAgKi9cclxuICBhZGRlZCA9ICdUcmFuc2FjdGlvbiBBZGRlZCcsXHJcbiAgLyoqXHJcbiAgICogV2hlbiBhbiB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uIGlzIGluIHRoZSBjb250cm9sbGVyIHN0YXRlLCBNZXRhTWFzayB3aWxsXHJcbiAgICogcmVuZGVyIGEgY29uZmlybWF0aW9uIHNjcmVlbiBmb3IgdGhhdCB0cmFuc2FjdGlvbi4gSWYgdGhlIHVzZXIgYXBwcm92ZXNcclxuICAgKiB0aGUgdHJhbnNhY3Rpb24gd2UgZmlyZSB0aGlzIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZXIgaGFzIGFwcHJvdmVkXHJcbiAgICogdGhlIHRyYW5zYWN0aW9uIGZvciBzdWJtaXNzaW9uIHRvIHRoZSBuZXR3b3JrLlxyXG4gICAqL1xyXG4gIGFwcHJvdmVkID0gJ1RyYW5zYWN0aW9uIEFwcHJvdmVkJyxcclxuICAvKipcclxuICAgKiBBbGwgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIHN1Ym1pdHRlZCB3aWxsIGZpbmFsaXplZCAoZXZlbnR1YWxseSkgYnkgZWl0aGVyXHJcbiAgICogYmVpbmcgZHJvcHBlZCwgZmFpbGluZyBvciBiZWluZyBjb25maXJtZWQuIFdoZW4gdGhpcyBoYXBwZW5zIHdlIHRyYWNrIHRoaXNcclxuICAgKiBldmVudCwgYWxvbmcgd2l0aCB0aGUgc3RhdHVzLlxyXG4gICAqL1xyXG4gIGZpbmFsaXplZCA9ICdUcmFuc2FjdGlvbiBGaW5hbGl6ZWQnLFxyXG4gIC8qKlxyXG4gICAqIFdoZW4gYW4gdW5hcHByb3ZlZCB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgY29udHJvbGxlciBzdGF0ZSwgTWV0YU1hc2sgd2lsbFxyXG4gICAqIHJlbmRlciBhIGNvbmZpcm1hdGlvbiBzY3JlZW4gZm9yIHRoYXQgdHJhbnNhY3Rpb24uIElmIHRoZSB1c2VyIHJlamVjdHMgdGhlXHJcbiAgICogdHJhbnNhY3Rpb24gd2UgZmlyZSB0aGlzIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZXIgaGFzIHJlamVjdGVkIHRoZVxyXG4gICAqIHRyYW5zYWN0aW9uLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBzdGF0ZSBhcyBhIHJlc3VsdC5cclxuICAgKi9cclxuICByZWplY3RlZCA9ICdUcmFuc2FjdGlvbiBSZWplY3RlZCcsXHJcbiAgLyoqXHJcbiAgICogQWZ0ZXIgYSB0cmFuc2FjdGlvbiBpcyBhcHByb3ZlZCBieSB0aGUgdXNlciwgaXQgaXMgdGhlbiBzdWJtaXR0ZWQgdG8gdGhlXHJcbiAgICogbmV0d29yayBmb3IgaW5jbHVzaW9uIGluIGEgYmxvY2suIFdoZW4gdGhpcyBoYXBwZW5zIHdlIGZpcmUgdGhlXHJcbiAgICogVHJhbnNhY3Rpb24gU3VibWl0dGVkIGV2ZW50IHRvIGluZGljYXRlIHRoYXQgTWV0YU1hc2sgaXMgc3VibWl0dGluZyBhXHJcbiAgICogdHJhbnNhY3Rpb24gYXQgdGhlIHVzZXIncyByZXF1ZXN0LlxyXG4gICAqL1xyXG4gIHN1Ym1pdHRlZCA9ICdUcmFuc2FjdGlvbiBTdWJtaXR0ZWQnLFxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHR5cGVzIG9mIGFzc2V0cyB0aGF0IGEgdXNlciBjYW4gc2VuZFxyXG4gKlxyXG4gKiBAdHlwZSB7QXNzZXRUeXBlc31cclxuICovXHJcbmV4cG9ydCBlbnVtIEFzc2V0VHlwZSB7XHJcbiAgLyoqIFRoZSBuYXRpdmUgYXNzZXQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmssIHN1Y2ggYXMgRVRIICovXHJcbiAgbmF0aXZlID0gJ05BVElWRScsXHJcbiAgLyoqIEFuIEVSQzIwIHRva2VuICovXHJcbiAgdG9rZW4gPSAnVE9LRU4nLFxyXG4gIC8qKiBBbiBFUkM3MjEgb3IgRVJDMTE1NSB0b2tlbi4gKi9cclxuICBORlQgPSAnTkZUJyxcclxuICAvKipcclxuICAgKiBBIHRyYW5zYWN0aW9uIGludGVyYWN0aW5nIHdpdGggYSBjb250cmFjdCB0aGF0IGlzbid0IGEgdG9rZW4gbWV0aG9kXHJcbiAgICogaW50ZXJhY3Rpb24gd2lsbCBiZSBtYXJrZWQgYXMgZGVhbGluZyB3aXRoIGFuIHVua25vd24gYXNzZXQgdHlwZS5cclxuICAgKi9cclxuICB1bmtub3duID0gJ1VOS05PV04nLFxyXG59XHJcblxyXG4vKipcclxuICogRGVzY3JpYmVzIHRoZSBzdGFuZGFyZCB3aGljaCBhIHRva2VuIGNvbmZvcm1zIHRvLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gVG9rZW5TdGFuZGFyZCB7XHJcbiAgLyoqIEEgdG9rZW4gdGhhdCBjb25mb3JtcyB0byB0aGUgRVJDMjAgc3RhbmRhcmQuICovXHJcbiAgRVJDMjAgPSAnRVJDMjAnLFxyXG4gIC8qKiBBIHRva2VuIHRoYXQgY29uZm9ybXMgdG8gdGhlIEVSQzcyMSBzdGFuZGFyZC4gKi9cclxuICBFUkM3MjEgPSAnRVJDNzIxJyxcclxuICAvKiogQSB0b2tlbiB0aGF0IGNvbmZvcm1zIHRvIHRoZSBFUkMxMTU1IHN0YW5kYXJkLiAqL1xyXG4gIEVSQzExNTUgPSAnRVJDMTE1NScsXHJcbiAgLyoqIE5vdCBhIHRva2VuLCBidXQgcmF0aGVyIHRoZSBiYXNlIGFzc2V0IG9mIHRoZSBzZWxlY3RlZCBjaGFpbi4gKi9cclxuICBub25lID0gJ05PTkUnLFxyXG59XHJcbiIsImltcG9ydCB7IE1JTlVURSwgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xyXG5pbXBvcnQgZ2V0RmV0Y2hXaXRoVGltZW91dCBmcm9tICcuLi9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XHJcbmltcG9ydCB7IGdldFN0b3JhZ2VJdGVtLCBzZXRTdG9yYWdlSXRlbSB9IGZyb20gJy4vc3RvcmFnZS1oZWxwZXJzJztcclxuXHJcbmNvbnN0IGZldGNoV2l0aENhY2hlID0gYXN5bmMgKFxyXG4gIHVybCxcclxuICBmZXRjaE9wdGlvbnMgPSB7fSxcclxuICB7IGNhY2hlUmVmcmVzaFRpbWUgPSBNSU5VVEUgKiA2LCB0aW1lb3V0ID0gU0VDT05EICogMzAgfSA9IHt9LFxyXG4pID0+IHtcclxuICBpZiAoXHJcbiAgICBmZXRjaE9wdGlvbnMuYm9keSB8fFxyXG4gICAgKGZldGNoT3B0aW9ucy5tZXRob2QgJiYgZmV0Y2hPcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcpXHJcbiAgKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoV2l0aENhY2hlIG9ubHkgc3VwcG9ydHMgR0VUIHJlcXVlc3RzJyk7XHJcbiAgfVxyXG4gIGlmICghKGZldGNoT3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2Ygd2luZG93LkhlYWRlcnMpKSB7XHJcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyB3aW5kb3cuSGVhZGVycyhmZXRjaE9wdGlvbnMuaGVhZGVycyk7XHJcbiAgfVxyXG4gIGlmIChcclxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykgJiZcclxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT09ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaFdpdGhDYWNoZSBvbmx5IHN1cHBvcnRzIEpTT04gcmVzcG9uc2VzJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XHJcbiAgY29uc3QgY2FjaGVLZXkgPSBgY2FjaGVkRmV0Y2g6JHt1cmx9YDtcclxuICBjb25zdCB7IGNhY2hlZFJlc3BvbnNlLCBjYWNoZWRUaW1lIH0gPSAoYXdhaXQgZ2V0U3RvcmFnZUl0ZW0oY2FjaGVLZXkpKSB8fCB7fTtcclxuICBpZiAoY2FjaGVkUmVzcG9uc2UgJiYgY3VycmVudFRpbWUgLSBjYWNoZWRUaW1lIDwgY2FjaGVSZWZyZXNoVGltZSkge1xyXG4gICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xyXG4gIH1cclxuICBmZXRjaE9wdGlvbnMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XHJcbiAgY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQodGltZW91dCk7XHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KHVybCwge1xyXG4gICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXHJcbiAgICBib2R5OiBudWxsLFxyXG4gICAgbWV0aG9kOiAnR0VUJyxcclxuICAgIG1vZGU6ICdjb3JzJyxcclxuICAgIC4uLmZldGNoT3B0aW9ucyxcclxuICB9KTtcclxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBGZXRjaCBmYWlsZWQgd2l0aCBzdGF0dXMgJyR7cmVzcG9uc2Uuc3RhdHVzfSc6ICcke3Jlc3BvbnNlLnN0YXR1c1RleHR9J2AsXHJcbiAgICApO1xyXG4gIH1cclxuICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgY29uc3QgY2FjaGVFbnRyeSA9IHtcclxuICAgIGNhY2hlZFJlc3BvbnNlOiByZXNwb25zZUpzb24sXHJcbiAgICBjYWNoZWRUaW1lOiBjdXJyZW50VGltZSxcclxuICB9O1xyXG5cclxuICBhd2FpdCBzZXRTdG9yYWdlSXRlbShjYWNoZUtleSwgY2FjaGVFbnRyeSk7XHJcbiAgcmV0dXJuIHJlc3BvbnNlSnNvbjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZldGNoV2l0aENhY2hlO1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5WYWx1ZVBhcmFtKHRva2VuRGF0YSA9IHt9KSB7XHJcbiAgcmV0dXJuIHRva2VuRGF0YT8uYXJncz8uX3ZhbHVlPy50b1N0cmluZygpO1xyXG59XHJcbiIsImltcG9ydCBsb2NhbGZvcmFnZSBmcm9tICdsb2NhbGZvcmFnZSc7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZUl0ZW0oa2V5KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gYXdhaXQgbG9jYWxmb3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgaWYgKHNlcmlhbGl6ZWREYXRhID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VyaWFsaXplZERhdGEpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRTdG9yYWdlSXRlbShrZXksIHZhbHVlKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgYXdhaXQgbG9jYWxmb3JhZ2Uuc2V0SXRlbShrZXksIHNlcmlhbGl6ZWREYXRhKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUud2FybihlcnIpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgeyBDSEFJTl9JRFMgfSBmcm9tICcuLi9jb25zdGFudHMvbmV0d29yayc7XHJcbmltcG9ydCB7XHJcbiAgR0FTX0FQSV9CQVNFX1VSTCxcclxuICBHQVNfREVWX0FQSV9CQVNFX1VSTCxcclxuICBTV0FQU19BUElfVjJfQkFTRV9VUkwsXHJcbiAgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUCxcclxuICBTV0FQU19DTElFTlRfSUQsXHJcbiAgU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTCxcclxuICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVMsXHJcbn0gZnJvbSAnLi4vY29uc3RhbnRzL3N3YXBzJztcclxuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xyXG5pbXBvcnQgeyBpc1ZhbGlkSGV4QWRkcmVzcyB9IGZyb20gJy4uL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcclxuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uL21vZHVsZXMvc3RyaW5nLXV0aWxzJztcclxuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vYXBwL3NjcmlwdHMvbGliL3V0aWwnO1xyXG5pbXBvcnQgeyBkZWNpbWFsVG9IZXggfSBmcm9tICcuLi9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMnO1xyXG5pbXBvcnQgZmV0Y2hXaXRoQ2FjaGUgZnJvbSAnLi9mZXRjaC13aXRoLWNhY2hlJztcclxuXHJcbmNvbnN0IFRFU1RfQ0hBSU5fSURTID0gW0NIQUlOX0lEUy5HT0VSTEksIENIQUlOX0lEUy5MT0NBTEhPU1RdO1xyXG5cclxuY29uc3QgY2xpZW50SWRIZWFkZXIgPSB7ICdYLUNsaWVudC1JZCc6IFNXQVBTX0NMSUVOVF9JRCB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkSGV4ID0gKHN0cmluZykgPT4gQm9vbGVhbihzdHJpbmc/Lm1hdGNoKC9eMHhbYS1mMC05XSskL3UpKTtcclxuZXhwb3J0IGNvbnN0IHRydXRoeVN0cmluZyA9IChzdHJpbmcpID0+IEJvb2xlYW4oc3RyaW5nPy5sZW5ndGgpO1xyXG5leHBvcnQgY29uc3QgdHJ1dGh5RGlnaXRTdHJpbmcgPSAoc3RyaW5nKSA9PlxyXG4gIHRydXRoeVN0cmluZyhzdHJpbmcpICYmIEJvb2xlYW4oc3RyaW5nLm1hdGNoKC9eXFxkKyQvdSkpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRGF0YSh2YWxpZGF0b3JzLCBvYmplY3QsIHVybFVzZWQsIGxvZ0Vycm9yID0gdHJ1ZSkge1xyXG4gIHJldHVybiB2YWxpZGF0b3JzLmV2ZXJ5KCh7IHByb3BlcnR5LCB0eXBlLCB2YWxpZGF0b3IgfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KCd8Jyk7XHJcblxyXG4gICAgY29uc3QgdmFsaWQgPVxyXG4gICAgICB0eXBlcy5zb21lKChfdHlwZSkgPT4gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV0gPT09IF90eXBlKSAmJlxyXG4gICAgICAoIXZhbGlkYXRvciB8fCB2YWxpZGF0b3Iob2JqZWN0W3Byb3BlcnR5XSkpO1xyXG4gICAgaWYgKCF2YWxpZCAmJiBsb2dFcnJvcikge1xyXG4gICAgICBsb2cuZXJyb3IoXHJcbiAgICAgICAgYHJlc3BvbnNlIHRvIEdFVCAke3VybFVzZWR9IGludmFsaWQgZm9yIHByb3BlcnR5ICR7cHJvcGVydHl9OyB2YWx1ZSB3YXM6YCxcclxuICAgICAgICBvYmplY3RbcHJvcGVydHldLFxyXG4gICAgICAgICd8IHR5cGUgd2FzOiAnLFxyXG4gICAgICAgIHR5cGVvZiBvYmplY3RbcHJvcGVydHldLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgUVVPVEVfVkFMSURBVE9SUyA9IFtcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ3RyYWRlJyxcclxuICAgIHR5cGU6ICdvYmplY3QnLFxyXG4gICAgdmFsaWRhdG9yOiAodHJhZGUpID0+XHJcbiAgICAgIHRyYWRlICYmXHJcbiAgICAgIHZhbGlkSGV4KHRyYWRlLmRhdGEpICYmXHJcbiAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyYWRlLnRvLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pICYmXHJcbiAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyYWRlLmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkgJiZcclxuICAgICAgdHJ1dGh5U3RyaW5nKHRyYWRlLnZhbHVlKSxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnYXBwcm92YWxOZWVkZWQnLFxyXG4gICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICB2YWxpZGF0b3I6IChhcHByb3ZhbFR4KSA9PlxyXG4gICAgICBhcHByb3ZhbFR4ID09PSBudWxsIHx8XHJcbiAgICAgIChhcHByb3ZhbFR4ICYmXHJcbiAgICAgICAgdmFsaWRIZXgoYXBwcm92YWxUeC5kYXRhKSAmJlxyXG4gICAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKGFwcHJvdmFsVHgudG8sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkgJiZcclxuICAgICAgICBpc1ZhbGlkSGV4QWRkcmVzcyhhcHByb3ZhbFR4LmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkpLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdzb3VyY2VBbW91bnQnLFxyXG4gICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICB2YWxpZGF0b3I6IHRydXRoeURpZ2l0U3RyaW5nLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvbkFtb3VudCcsXHJcbiAgICB0eXBlOiAnc3RyaW5nJyxcclxuICAgIHZhbGlkYXRvcjogdHJ1dGh5RGlnaXRTdHJpbmcsXHJcbiAgfSxcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ3NvdXJjZVRva2VuJyxcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvblRva2VuJyxcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdhZ2dyZWdhdG9yJyxcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgdmFsaWRhdG9yOiB0cnV0aHlTdHJpbmcsXHJcbiAgfSxcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ2FnZ1R5cGUnLFxyXG4gICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICB2YWxpZGF0b3I6IHRydXRoeVN0cmluZyxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnZXJyb3InLFxyXG4gICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICB2YWxpZGF0b3I6IChlcnJvcikgPT4gZXJyb3IgPT09IG51bGwgfHwgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnYXZlcmFnZUdhcycsXHJcbiAgICB0eXBlOiAnbnVtYmVyJyxcclxuICB9LFxyXG4gIHtcclxuICAgIHByb3BlcnR5OiAnbWF4R2FzJyxcclxuICAgIHR5cGU6ICdudW1iZXInLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcHJvcGVydHk6ICdnYXNFc3RpbWF0ZScsXHJcbiAgICB0eXBlOiAnbnVtYmVyfHVuZGVmaW5lZCcsXHJcbiAgICB2YWxpZGF0b3I6IChnYXNFc3RpbWF0ZSkgPT4gZ2FzRXN0aW1hdGUgPT09IHVuZGVmaW5lZCB8fCBnYXNFc3RpbWF0ZSA+IDAsXHJcbiAgfSxcclxuICB7XHJcbiAgICBwcm9wZXJ0eTogJ2ZlZScsXHJcbiAgICB0eXBlOiAnbnVtYmVyJyxcclxuICB9LFxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBhbiBBUEkgY2FsbCwgZS5nLiBcInRva2Vuc1wiXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkXHJcbiAqIEByZXR1cm5zIHN0cmluZ1xyXG4gKi9cclxuY29uc3QgZ2V0QmFzZVVybEZvck5ld1N3YXBzQXBpID0gKHR5cGUsIGNoYWluSWQpID0+IHtcclxuICBjb25zdCB1c2VEZXZBcGlzID0gcHJvY2Vzcy5lbnYuU1dBUFNfVVNFX0RFVl9BUElTO1xyXG4gIGNvbnN0IHYyQXBpQmFzZVVybCA9IHVzZURldkFwaXNcclxuICAgID8gU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTFxyXG4gICAgOiBTV0FQU19BUElfVjJfQkFTRV9VUkw7XHJcbiAgY29uc3QgZ2FzQXBpQmFzZVVybCA9IHVzZURldkFwaXMgPyBHQVNfREVWX0FQSV9CQVNFX1VSTCA6IEdBU19BUElfQkFTRV9VUkw7XHJcbiAgY29uc3Qgbm9OZXR3b3JrU3BlY2lmaWNUeXBlcyA9IFsncmVmcmVzaFRpbWUnXTsgLy8gVGhlc2UgdHlwZXMgZG9uJ3QgbmVlZCBuZXR3b3JrIGluZm8gaW4gdGhlIFVSTC5cclxuICBpZiAobm9OZXR3b3JrU3BlY2lmaWNUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xyXG4gICAgcmV0dXJuIHYyQXBpQmFzZVVybDtcclxuICB9XHJcbiAgY29uc3QgY2hhaW5JZERlY2ltYWwgPSBjaGFpbklkICYmIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcclxuICBjb25zdCBnYXNBcGlUeXBlcyA9IFsnZ2FzUHJpY2VzJ107XHJcbiAgaWYgKGdhc0FwaVR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XHJcbiAgICByZXR1cm4gYCR7Z2FzQXBpQmFzZVVybH0vbmV0d29ya3MvJHtjaGFpbklkRGVjaW1hbH1gOyAvLyBHYXMgY2FsY3VsYXRpb25zIGFyZSBpbiBpdHMgb3duIHJlcG8uXHJcbiAgfVxyXG4gIHJldHVybiBgJHt2MkFwaUJhc2VVcmx9L25ldHdvcmtzLyR7Y2hhaW5JZERlY2ltYWx9YDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRCYXNlQXBpID0gZnVuY3Rpb24gKHR5cGUsIGNoYWluSWQpIHtcclxuICBjb25zdCBfY2hhaW5JZCA9IFRFU1RfQ0hBSU5fSURTLmluY2x1ZGVzKGNoYWluSWQpXHJcbiAgICA/IENIQUlOX0lEUy5NQUlOTkVUXHJcbiAgICA6IGNoYWluSWQ7XHJcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmxGb3JOZXdTd2Fwc0FwaSh0eXBlLCBfY2hhaW5JZCk7XHJcbiAgaWYgKCFiYXNlVXJsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFN3YXBzIEFQSSBjYWxscyBhcmUgZGlzYWJsZWQgZm9yIGNoYWluSWQ6ICR7X2NoYWluSWR9YCk7XHJcbiAgfVxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSAndHJhZGUnOlxyXG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdHJhZGVzP2A7XHJcbiAgICBjYXNlICd0b2tlbnMnOlxyXG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9rZW5zYDtcclxuICAgIGNhc2UgJ3Rva2VuJzpcclxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3Rva2VuYDtcclxuICAgIGNhc2UgJ3RvcEFzc2V0cyc6XHJcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS90b3BBc3NldHNgO1xyXG4gICAgY2FzZSAnYWdncmVnYXRvck1ldGFkYXRhJzpcclxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FnZ3JlZ2F0b3JNZXRhZGF0YWA7XHJcbiAgICBjYXNlICdnYXNQcmljZXMnOlxyXG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vZ2FzUHJpY2VzYDtcclxuICAgIGNhc2UgJ25ldHdvcmsnOlxyXG4gICAgICByZXR1cm4gYmFzZVVybDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0QmFzZUFwaSByZXF1aXJlcyBhbiBhcGkgY2FsbCB0eXBlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNUb2tlblZhbHVlKHZhbHVlLCBkZWNpbWFscykge1xyXG4gIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTnVtYmVyKGRlY2ltYWxzIHx8IDApKTtcclxuICByZXR1cm4gbmV3IEJpZ051bWJlcihTdHJpbmcodmFsdWUpKS50aW1lcyhtdWx0aXBsaWVyKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNob3VsZEVuYWJsZURpcmVjdFdyYXBwaW5nID0gKFxyXG4gIGNoYWluSWQsXHJcbiAgc291cmNlVG9rZW4sXHJcbiAgZGVzdGluYXRpb25Ub2tlbixcclxuKSA9PiB7XHJcbiAgaWYgKCFzb3VyY2VUb2tlbiB8fCAhZGVzdGluYXRpb25Ub2tlbikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCB3cmFwcGVkVG9rZW4gPSBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbY2hhaW5JZF07XHJcbiAgY29uc3QgbmF0aXZlVG9rZW4gPSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5hZGRyZXNzO1xyXG4gIHJldHVybiAoXHJcbiAgICAoaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShzb3VyY2VUb2tlbiwgd3JhcHBlZFRva2VuKSAmJlxyXG4gICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGRlc3RpbmF0aW9uVG9rZW4sIG5hdGl2ZVRva2VuKSkgfHxcclxuICAgIChpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKHNvdXJjZVRva2VuLCBuYXRpdmVUb2tlbikgJiZcclxuICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShkZXN0aW5hdGlvblRva2VuLCB3cmFwcGVkVG9rZW4pKVxyXG4gICk7XHJcbn07XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW5kIG9iamVjdCB3aGVyZSBhbGwgdmFsdWVzIGFyZSBzdHJpbmdzLCByZXR1cm5zIHRoZSBzYW1lIG9iamVjdCB3aXRoIGFsbCB2YWx1ZXNcclxuICogbm93IHByZWZpeGVkIHdpdGggJzB4J1xyXG4gKlxyXG4gKiBAcGFyYW0gb2JqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkSGV4UHJlZml4VG9PYmplY3RWYWx1ZXMob2JqKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChuZXdPYmosIGtleSkgPT4ge1xyXG4gICAgcmV0dXJuIHsgLi4ubmV3T2JqLCBba2V5XTogYWRkSGV4UHJlZml4KG9ialtrZXldKSB9O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBzdGFuZGFyZCBzZXQgb2YgaW5mb3JtYXRpb24gYWJvdXQgYSB0cmFuc2FjdGlvbiwgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHByb3Blcmx5IGZvcm1hdHRlZCBmb3JcclxuICogcHVibGlzaGluZyB2aWEgSlNPTiBSUEMgYW5kIHdlYjNcclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kVG9rZW5dIC0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc2FjaXRvbiBpcyBhIHRva2VuIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRhdGEgLSBBIGhleCBzdHJpbmcgY29udGFpbmluZyB0aGUgZGF0YSB0byBpbmNsdWRlIGluIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50byAtIEEgaGV4IGFkZHJlc3Mgb2YgdGhlIHR4IHJlY2lwaWVudCBhZGRyZXNzXHJcbiAqIEBwYXJhbSBvcHRpb25zLmFtb3VudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mcm9tIC0gQSBoZXggYWRkcmVzcyBvZiB0aGUgdHggc2VuZGVyIGFkZHJlc3NcclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZ2FzIC0gQSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGdhcyB2YWx1ZSBmb3IgdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmdhc1ByaWNlIC0gQSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGdhcyBwcmljZSBmb3IgdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCByZWFkeSBmb3Igc3VibWlzc2lvbiB0byB0aGUgYmxvY2tjaGFpbiwgd2l0aCBhbGwgdmFsdWVzIGFwcHJvcHJpYXRlbHkgaGV4IHByZWZpeGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0VHhQYXJhbXMoe1xyXG4gIHNlbmRUb2tlbixcclxuICBkYXRhLFxyXG4gIHRvLFxyXG4gIGFtb3VudCxcclxuICBmcm9tLFxyXG4gIGdhcyxcclxuICBnYXNQcmljZSxcclxufSkge1xyXG4gIGNvbnN0IHR4UGFyYW1zID0ge1xyXG4gICAgZGF0YSxcclxuICAgIGZyb20sXHJcbiAgICB2YWx1ZTogJzAnLFxyXG4gICAgZ2FzLFxyXG4gICAgZ2FzUHJpY2UsXHJcbiAgfTtcclxuXHJcbiAgaWYgKCFzZW5kVG9rZW4pIHtcclxuICAgIHR4UGFyYW1zLnZhbHVlID0gYW1vdW50O1xyXG4gICAgdHhQYXJhbXMudG8gPSB0bztcclxuICB9XHJcbiAgcmV0dXJuIGFkZEhleFByZWZpeFRvT2JqZWN0VmFsdWVzKHR4UGFyYW1zKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVHJhZGVzSW5mbyhcclxuICB7XHJcbiAgICBzbGlwcGFnZSxcclxuICAgIHNvdXJjZVRva2VuLFxyXG4gICAgc291cmNlRGVjaW1hbHMsXHJcbiAgICBkZXN0aW5hdGlvblRva2VuLFxyXG4gICAgdmFsdWUsXHJcbiAgICBmcm9tQWRkcmVzcyxcclxuICAgIGV4Y2hhbmdlTGlzdCxcclxuICB9LFxyXG4gIHsgY2hhaW5JZCB9LFxyXG4pIHtcclxuICBjb25zdCB1cmxQYXJhbXMgPSB7XHJcbiAgICBkZXN0aW5hdGlvblRva2VuLFxyXG4gICAgc291cmNlVG9rZW4sXHJcbiAgICBzb3VyY2VBbW91bnQ6IGNhbGNUb2tlblZhbHVlKHZhbHVlLCBzb3VyY2VEZWNpbWFscykudG9TdHJpbmcoMTApLFxyXG4gICAgc2xpcHBhZ2UsXHJcbiAgICB0aW1lb3V0OiBTRUNPTkQgKiAxMCxcclxuICAgIHdhbGxldEFkZHJlc3M6IGZyb21BZGRyZXNzLFxyXG4gIH07XHJcblxyXG4gIGlmIChleGNoYW5nZUxpc3QpIHtcclxuICAgIHVybFBhcmFtcy5leGNoYW5nZUxpc3QgPSBleGNoYW5nZUxpc3Q7XHJcbiAgfVxyXG4gIGlmIChzaG91bGRFbmFibGVEaXJlY3RXcmFwcGluZyhjaGFpbklkLCBzb3VyY2VUb2tlbiwgZGVzdGluYXRpb25Ub2tlbikpIHtcclxuICAgIHVybFBhcmFtcy5lbmFibGVEaXJlY3RXcmFwcGluZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBxdWVyeVN0cmluZyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsUGFyYW1zKS50b1N0cmluZygpO1xyXG4gIGNvbnN0IHRyYWRlVVJMID0gYCR7Z2V0QmFzZUFwaSgndHJhZGUnLCBjaGFpbklkKX0ke3F1ZXJ5U3RyaW5nfWA7XHJcbiAgY29uc3QgdHJhZGVzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhDYWNoZShcclxuICAgIHRyYWRlVVJMLFxyXG4gICAgeyBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBjbGllbnRJZEhlYWRlciB9LFxyXG4gICAgeyBjYWNoZVJlZnJlc2hUaW1lOiAwLCB0aW1lb3V0OiBTRUNPTkQgKiAxNSB9LFxyXG4gICk7XHJcbiAgY29uc3QgbmV3UXVvdGVzID0gdHJhZGVzUmVzcG9uc2UucmVkdWNlKChhZ2dJZFRyYWRlTWFwLCBxdW90ZSkgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICBxdW90ZS50cmFkZSAmJlxyXG4gICAgICAhcXVvdGUuZXJyb3IgJiZcclxuICAgICAgdmFsaWRhdGVEYXRhKFFVT1RFX1ZBTElEQVRPUlMsIHF1b3RlLCB0cmFkZVVSTClcclxuICAgICkge1xyXG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFRyYWRlID0gY29uc3RydWN0VHhQYXJhbXMoe1xyXG4gICAgICAgIHRvOiBxdW90ZS50cmFkZS50byxcclxuICAgICAgICBmcm9tOiBxdW90ZS50cmFkZS5mcm9tLFxyXG4gICAgICAgIGRhdGE6IHF1b3RlLnRyYWRlLmRhdGEsXHJcbiAgICAgICAgYW1vdW50OiBkZWNpbWFsVG9IZXgocXVvdGUudHJhZGUudmFsdWUpLFxyXG4gICAgICAgIGdhczogZGVjaW1hbFRvSGV4KHF1b3RlLm1heEdhcyksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGV0IHsgYXBwcm92YWxOZWVkZWQgfSA9IHF1b3RlO1xyXG5cclxuICAgICAgaWYgKGFwcHJvdmFsTmVlZGVkKSB7XHJcbiAgICAgICAgYXBwcm92YWxOZWVkZWQgPSBjb25zdHJ1Y3RUeFBhcmFtcyh7XHJcbiAgICAgICAgICAuLi5hcHByb3ZhbE5lZWRlZCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5hZ2dJZFRyYWRlTWFwLFxyXG4gICAgICAgIFtxdW90ZS5hZ2dyZWdhdG9yXToge1xyXG4gICAgICAgICAgLi4ucXVvdGUsXHJcbiAgICAgICAgICBzbGlwcGFnZSxcclxuICAgICAgICAgIHRyYWRlOiBjb25zdHJ1Y3RlZFRyYWRlLFxyXG4gICAgICAgICAgYXBwcm92YWxOZWVkZWQsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBhZ2dJZFRyYWRlTWFwO1xyXG4gIH0sIHt9KTtcclxuXHJcbiAgcmV0dXJuIG5ld1F1b3RlcztcclxufVxyXG4iLCJpbXBvcnQgeyBhYmlFUkMyMCB9IGZyb20gJ0BtZXRhbWFzay9tZXRhbWFzay1ldGgtYWJpcyc7XHJcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJztcclxuaW1wb3J0IHsgV2ViM1Byb3ZpZGVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJztcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSAnX3ZhbHVlJyBwYXJhbWV0ZXIgb2YgdGhlIGdpdmVuIHRva2VuIHRyYW5zYWN0aW9uIGRhdGFcclxuICogKGkuZSBmdW5jdGlvbiBjYWxsKSBwZXIgdGhlIEh1bWFuIFN0YW5kYXJkIFRva2VuIEFCSSwgaWYgcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHRva2VuRGF0YSAtIGV0aGVycyBJbnRlcmZhY2UgdG9rZW4gZGF0YS5cclxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gQSBkZWNpbWFsIHN0cmluZyB2YWx1ZS5cclxuICovXHJcbi8qKlxyXG4gKiBHZXRzIGVpdGhlciB0aGUgJ190b2tlbklkJyBwYXJhbWV0ZXIgb3IgdGhlICdpZCcgcGFyYW0gb2YgdGhlIHBhc3NlZCB0b2tlbiB0cmFuc2FjdGlvbiBkYXRhLixcclxuICogVGhlc2UgYXJlIHRoZSBwYXJzZWQgdG9rZW5JZCB2YWx1ZXMgcmV0dXJuZWQgYnkgYHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YWAgYXMgZGVmaW5lZFxyXG4gKiBpbiB0aGUgRVJDNzIxIGFuZCBFUkMxMTU1IEFCSXMgZnJvbSBtZXRhbWFzay1ldGgtYWJpcyAoaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV0aC1hYmlzL3RyZWUvbWFpbi9zcmMvYWJpcylcclxuICpcclxuICogQHBhcmFtIHRva2VuRGF0YSAtIGV0aGVycyBJbnRlcmZhY2UgdG9rZW4gZGF0YS5cclxuICogQHJldHVybnMgQSBkZWNpbWFsIHN0cmluZyB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUb2tlbklkUGFyYW0odG9rZW5EYXRhOiBhbnkgPSB7fSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgcmV0dXJuIChcclxuICAgIHRva2VuRGF0YT8uYXJncz8uX3Rva2VuSWQ/LnRvU3RyaW5nKCkgPz8gdG9rZW5EYXRhPy5hcmdzPy5pZD8udG9TdHJpbmcoKVxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRva2VuQmFsYW5jZShcclxuICBhZGRyZXNzOiBzdHJpbmcsXHJcbiAgdXNlckFkZHJlc3M6IHN0cmluZyxcclxuICBwcm92aWRlcjogYW55LFxyXG4pOiBQcm9taXNlPGFueT4ge1xyXG4gIGNvbnN0IGV0aGVyc1Byb3ZpZGVyID0gbmV3IFdlYjNQcm92aWRlcihwcm92aWRlcik7XHJcbiAgY29uc3QgdG9rZW5Db250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBhYmlFUkMyMCwgZXRoZXJzUHJvdmlkZXIpO1xyXG4gIGNvbnN0IHRva2VuQmFsYW5jZVByb21pc2UgPSB0b2tlbkNvbnRyYWN0XHJcbiAgICA/IHRva2VuQ29udHJhY3QuYmFsYW5jZU9mKHVzZXJBZGRyZXNzKVxyXG4gICAgOiBQcm9taXNlLnJlc29sdmUoKTtcclxuICByZXR1cm4gYXdhaXQgdG9rZW5CYWxhbmNlUHJvbWlzZTtcclxufVxyXG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCB7IEV0aGVyRGVub21pbmF0aW9uIH0gZnJvbSAnLi4vY29uc3RhbnRzL2NvbW1vbic7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVUeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuaW1wb3J0IHsgTnVtZXJpYyB9IGZyb20gJy4uL21vZHVsZXMvTnVtZXJpYyc7XHJcbmltcG9ydCB7IGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2wgfSBmcm9tICcuLi9tb2R1bGVzL3N3YXBzLnV0aWxzJztcclxuXHJcbmV4cG9ydCBjb25zdCBUT0tFTl9UUkFOU0ZFUl9MT0dfVE9QSUNfSEFTSCA9XHJcbiAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZic7XHJcblxyXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fTk9fQ09OVFJBQ1RfRVJST1JfS0VZID0gJ3RyYW5zYWN0aW9uRXJyb3JOb0NvbnRyYWN0JztcclxuXHJcbmV4cG9ydCBjb25zdCBURU5fU0VDT05EU19JTl9NSUxMSVNFQ09ORFMgPSAxMF8wMDA7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY0dhc1RvdGFsKGdhc0xpbWl0ID0gJzAnLCBnYXNQcmljZSA9ICcwJykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhnYXNMaW1pdCwgMTYpLnRpbWVzKG5ldyBOdW1lcmljKGdhc1ByaWNlLCAxNikpLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG51bWJlciBhbmQgc3BlY2lmaWVkIHByZWNpc2lvbiwgcmV0dXJucyB0aGF0IG51bWJlciBpbiBiYXNlIDEwIHdpdGggYSBtYXhpbXVtIG9mIHByZWNpc2lvblxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMsIGJ1dCB3aXRob3V0IGFueSB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCBUbyBiZSB1c2VkIHdoZW4gd2lzaGluZ1xyXG4gKiB0byBkaXNwbGF5IG9ubHkgYXMgbXVjaCBkaWdpdHMgdG8gdGhlIHVzZXIgYXMgbmVjZXNzYXJ5XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgQmlnTnVtYmVyfSBuIC0gVGhlIG51bWJlciB0byBmb3JtYXRcclxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJldHVybiB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbnVtYmVyIGluIGRlY2ltYWwgZm9ybSwgd2l0aCA8PSBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGlnaXRzIGFuZCBubyBkZWNpbWFsIHRyYWlsaW5nIHplcm9zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9QcmVjaXNpb25XaXRob3V0VHJhaWxpbmdaZXJvcyhuLCBwcmVjaXNpb24pIHtcclxuICByZXR1cm4gbmV3IEJpZ051bWJlcihuKVxyXG4gICAgLnRvUHJlY2lzaW9uKHByZWNpc2lvbilcclxuICAgIC5yZXBsYWNlKC8oXFwuWzAtOV0qWzEtOV0pMCp8KFxcLjAqKS91LCAnJDEnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNUb2tlbkFtb3VudCh2YWx1ZSwgZGVjaW1hbHMpIHtcclxuICBjb25zdCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIE51bWJlcihkZWNpbWFscyB8fCAwKSk7XHJcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoU3RyaW5nKHZhbHVlKSkuZGl2KG11bHRpcGxpZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3dhcHNUb2tlbnNSZWNlaXZlZEZyb21UeE1ldGEoXHJcbiAgdG9rZW5TeW1ib2wsXHJcbiAgdHhNZXRhLFxyXG4gIHRva2VuQWRkcmVzcyxcclxuICBhY2NvdW50QWRkcmVzcyxcclxuICB0b2tlbkRlY2ltYWxzLFxyXG4gIGFwcHJvdmFsVHhNZXRhLFxyXG4gIGNoYWluSWQsXHJcbikge1xyXG4gIGNvbnN0IHR4UmVjZWlwdCA9IHR4TWV0YT8udHhSZWNlaXB0O1xyXG4gIGNvbnN0IG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5ID1cclxuICAgIHR4TWV0YT8udHhSZWNlaXB0Py50eXBlID09PSBUcmFuc2FjdGlvbkVudmVsb3BlVHlwZS5mZWVNYXJrZXQ7XHJcbiAgaWYgKGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2wodG9rZW5TeW1ib2wsIGNoYWluSWQpKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgICF0eFJlY2VpcHQgfHxcclxuICAgICAgIXR4TWV0YSB8fFxyXG4gICAgICAhdHhNZXRhLnBvc3RUeEJhbGFuY2UgfHxcclxuICAgICAgIXR4TWV0YS5wcmVUeEJhbGFuY2VcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHhNZXRhLnN3YXBNZXRhRGF0YSAmJiB0eE1ldGEucHJlVHhCYWxhbmNlID09PSB0eE1ldGEucG9zdFR4QmFsYW5jZSkge1xyXG4gICAgICAvLyBJZiBwcmVUeEJhbGFuY2UgYW5kIHBvc3RUeEJhbGFuY2UgYXJlIGVxdWFsLCBwb3N0VHhCYWxhbmNlIGhhc24ndCBiZWVuIHVwZGF0ZWQgb24gdGltZVxyXG4gICAgICAvLyBiZWNhdXNlIG9mIHRoZSBSUEMgcHJvdmlkZXIgZGVsYXksIHNvIHdlIHJldHVybiBhbiBlc3RpbWF0ZWQgcmVjZWl2aW5nIGFtb3VudCBpbnN0ZWFkLlxyXG4gICAgICByZXR1cm4gdHhNZXRhLnN3YXBNZXRhRGF0YS50b2tlbl90b19hbW91bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFwcHJvdmFsVHhHYXNDb3N0ID0gbmV3IE51bWVyaWMoJzB4MCcsIDE2KTtcclxuICAgIGlmIChhcHByb3ZhbFR4TWV0YSAmJiBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQpIHtcclxuICAgICAgYXBwcm92YWxUeEdhc0Nvc3QgPSBuZXcgTnVtZXJpYyhcclxuICAgICAgICBjYWxjR2FzVG90YWwoXHJcbiAgICAgICAgICBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQuZ2FzVXNlZCxcclxuICAgICAgICAgIG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5XHJcbiAgICAgICAgICAgID8gYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0LmVmZmVjdGl2ZUdhc1ByaWNlIC8vIEJhc2UgZmVlICsgcHJpb3JpdHkgZmVlLlxyXG4gICAgICAgICAgICA6IGFwcHJvdmFsVHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgMTYsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2FzQ29zdCA9IGNhbGNHYXNUb3RhbChcclxuICAgICAgdHhSZWNlaXB0Lmdhc1VzZWQsXHJcbiAgICAgIG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5XHJcbiAgICAgICAgPyB0eFJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2VcclxuICAgICAgICA6IHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSxcclxuICAgICk7XHJcbiAgICBjb25zdCB0b3RhbEdhc0Nvc3QgPSBuZXcgTnVtZXJpYyhnYXNDb3N0LCAxNikuYWRkKGFwcHJvdmFsVHhHYXNDb3N0KTtcclxuXHJcbiAgICBjb25zdCBwcmVUeEJhbGFuY2VMZXNzR2FzQ29zdCA9IG5ldyBOdW1lcmljKHR4TWV0YS5wcmVUeEJhbGFuY2UsIDE2KS5taW51cyhcclxuICAgICAgdG90YWxHYXNDb3N0LFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBldGhSZWNlaXZlZCA9IG5ldyBOdW1lcmljKFxyXG4gICAgICB0eE1ldGEucG9zdFR4QmFsYW5jZSxcclxuICAgICAgMTYsXHJcbiAgICAgIEV0aGVyRGVub21pbmF0aW9uLldFSSxcclxuICAgIClcclxuICAgICAgLm1pbnVzKHByZVR4QmFsYW5jZUxlc3NHYXNDb3N0KVxyXG4gICAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxyXG4gICAgICAudG9CYXNlKDEwKVxyXG4gICAgICAucm91bmQoNik7XHJcbiAgICByZXR1cm4gZXRoUmVjZWl2ZWQudG9TdHJpbmcoKTtcclxuICB9XHJcbiAgY29uc3QgdHhSZWNlaXB0TG9ncyA9IHR4UmVjZWlwdD8ubG9ncztcclxuICBpZiAodHhSZWNlaXB0TG9ncyAmJiB0eFJlY2VpcHQ/LnN0YXR1cyAhPT0gJzB4MCcpIHtcclxuICAgIGNvbnN0IHRva2VuVHJhbnNmZXJMb2cgPSB0eFJlY2VpcHRMb2dzLmZpbmQoKHR4UmVjZWlwdExvZykgPT4ge1xyXG4gICAgICBjb25zdCBpc1Rva2VuVHJhbnNmZXIgPVxyXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3MgJiZcclxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzBdID09PSBUT0tFTl9UUkFOU0ZFUl9MT0dfVE9QSUNfSEFTSDtcclxuICAgICAgY29uc3QgaXNUcmFuc2ZlckZyb21HaXZlblRva2VuID0gdHhSZWNlaXB0TG9nLmFkZHJlc3MgPT09IHRva2VuQWRkcmVzcztcclxuICAgICAgY29uc3QgaXNUcmFuc2ZlckZyb21HaXZlbkFkZHJlc3MgPVxyXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3MgJiZcclxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzJdICYmXHJcbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljc1syXS5tYXRjaChhY2NvdW50QWRkcmVzcy5zbGljZSgyKSk7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgaXNUb2tlblRyYW5zZmVyICYmXHJcbiAgICAgICAgaXNUcmFuc2ZlckZyb21HaXZlblRva2VuICYmXHJcbiAgICAgICAgaXNUcmFuc2ZlckZyb21HaXZlbkFkZHJlc3NcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRva2VuVHJhbnNmZXJMb2dcclxuICAgICAgPyB0b1ByZWNpc2lvbldpdGhvdXRUcmFpbGluZ1plcm9zKFxyXG4gICAgICAgICAgY2FsY1Rva2VuQW1vdW50KHRva2VuVHJhbnNmZXJMb2cuZGF0YSwgdG9rZW5EZWNpbWFscykudG9TdHJpbmcoMTApLFxyXG4gICAgICAgICAgNixcclxuICAgICAgICApXHJcbiAgICAgIDogJyc7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRV9OQU1FUyA9IHtcclxuICBGRUVfTUFSS0VUOiAnZmVlLW1hcmtldCcsXHJcbiAgTEVHQUNZOiAnbGVnYWN5JyxcclxufTtcclxuIiwiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcclxuaW1wb3J0IHsgaXNIZXhTdHJpbmcsIGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcclxuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHsgRXRoZXJEZW5vbWluYXRpb24gfSBmcm9tICcuLi9jb25zdGFudHMvY29tbW9uJztcclxuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuL2hleHN0cmluZy11dGlscyc7XHJcblxyXG5leHBvcnQgdHlwZSBOdW1lcmljVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgfCBCTiB8IEJpZ051bWJlcjtcclxuZXhwb3J0IHR5cGUgTnVtZXJpY0Jhc2UgPSAxMCB8IDE2O1xyXG5cclxuLyoqXHJcbiAqIEFsbCB2YXJpYXRpb25zIG9mIGlzSGV4U3RyaW5nIGZyb20gb3VyIG93biB1dGlsaXRpZXMgYW5kIGV0aGVydW1qcy11dGlsc1xyXG4gKiByZXR1cm4gZmFsc2UgZm9yIGEgJy0nIHByZWZpeGVkIGhleCBzdHJpbmcuIFRoaXMgdXRpbGl0eSBtZXRob2Qgc3RyaXBzIHRoZVxyXG4gKiBwb3NzaWJsZSAnLScgZnJvbSB0aGUgc3RyaW5nIGJlZm9yZSB0ZXN0aW5nIGl0cyB2YWxpZGl0eSBzbyB0aGF0IG5lZ2F0aXZlXHJcbiAqIGhleCB2YWx1ZXMgY2FuIGJlIHByb3Blcmx5IGhhbmRsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY2hlY2tcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChuZWdhdGl2ZSBvciBvdGhlcndpc2UpXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0hleFN0cmluZ09yTmVnYXRlZEhleFN0cmluZyh2YWx1ZTogc3RyaW5nKTogdmFsdWUgaXMgc3RyaW5nIHtcclxuICByZXR1cm4gaXNIZXhTdHJpbmcodmFsdWUucmVwbGFjZSgnLScsICcnKSkgfHwgaXNIZXhTdHJpbmcodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQmlnTnVtYmVyIHN1cHBvcnRzIGhleCBzdHJpbmdzIHdpdGggJy4nIChha2EgZGVjaW1hbHMpIGluIHRoZSBzdHJpbmcuXHJcbiAqIE5vIHZlcnNpb24gb2YgaXNIZXhTdHJpbmcgcmV0dXJzIHRydWUgaWYgdGhlIHN0cmluZyBjb250YWlucyBhIGRlY2ltYWwgc29cclxuICogdGhpcyBtZXRob2QgaXMgdXNlZCB0byBjaGVjayBpZiBib3RoIHBhcnRzIG9mIHRoZSBzdHJpbmcgc3BsaXQgYnkgdGhlXHJcbiAqIGRlY2ltYWwgYXJlIGhleCBzdHJpbmdzLiBJZiBzbyB3ZSBjYW4gZmVlZCB0aGlzIHZhbHVlIGludG8gQmlnTnVtYmVyIHRvIGdldFxyXG4gKiBhIHZhbGlkIE51bWVyaWMuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY2hlY2tcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgaGV4YWRlY2ltYWwgc3BsaXQgYnkgJy4nXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RlY2ltYWxIZXgodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoJy4nKTtcclxuICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBwYXJ0cy5ldmVyeSgocGFydCkgPT4gaXNIZXhTdHJpbmdPck5lZ2F0ZWRIZXhTdHJpbmcocGFydCkpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBpbiBzdHJpbmcgb3IgbnVtYmVyIGZvcm1hdCB0byBhIEJpZ051bWJlci5cclxuICogTm90ZSB0aGF0IGluIG1hbnkgcGxhY2VzIGluIG91ciBjb2RlYmFzZSB3ZSBjYWxsICdhZGRIZXhQcmVmaXgnIG9uIGEgbmVnYXRlZFxyXG4gKiBoZXhhZGVjaW1hbCBzdHJpbmcgcmVzdWx0aW5nIGluICcweC1hJyB3aGljaCB3aWxsIGZhaWwgY2hlY2tzIGZvclxyXG4gKiBpc0hleFN0cmluZy4gU29tZXRpbWVzIHdlIERPIG5vdCBhZGQgdGhlIDB4IHNvIHdlIGhhdmUgdG8gY2hlY2sgZm9yICctYSdcclxuICogYXMgd2VsbC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gaGV4YWRlY2ltYWwgdmFsdWUgaW4gc3RyaW5nIG9yIG51bWJlciBmb3JtYXQuXHJcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0JpZ051bWJlcih2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogQmlnTnVtYmVyIHtcclxuICBjb25zdCBzdHJpbmdpZmllZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBgJHt2YWx1ZX1gIDogdmFsdWU7XHJcbiAgY29uc3QgaXNOZWdhdGl2ZSA9IHN0cmlwSGV4UHJlZml4KHN0cmluZ2lmaWVkKVswXSA9PT0gJy0nO1xyXG4gIGNvbnN0IHZhbHVlV2l0aG91dE5lZ2F0aW9uID0gc3RyaW5naWZpZWQucmVwbGFjZSgnLScsICcnKTtcclxuXHJcbiAgY29uc3QgdmFsdWVBc0JpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIoXHJcbiAgICBzdHJpcEhleFByZWZpeCh2YWx1ZVdpdGhvdXROZWdhdGlvbiksXHJcbiAgICAxNixcclxuICApO1xyXG5cclxuICByZXR1cm4gaXNOZWdhdGl2ZSA/IHZhbHVlQXNCaWdOdW1iZXIubmVnYXRlZCgpIDogdmFsdWVBc0JpZ051bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgZGVjaW1hbCBpbiBzdHJpbmcgb3IgbnVtYmVyIGZvcm1hdCB0byBhIEJpZ051bWJlci5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gZGVjaW1hbCB2YWx1ZSBpbiBzdHJpbmcgb3IgbnVtYmVyIGZvcm1hdC5cclxuICogQHJldHVybnMgQSBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNpbWFsVG9CaWdOdW1iZXIodmFsdWU6IHN0cmluZyB8IG51bWJlcikge1xyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKFN0cmluZyh2YWx1ZSksIDEwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2FmZWx5IGNvbnZlcnQgYSBzdHJpbmcgdHlwZSB2YWx1ZSB0byBhIEJpZ051bWJlci5cclxuICogVGhlIG9ubHkgdmFsaWQgc3RyaW5ncyBmb3IgdGhpcyBtZXRob2QgYXJlIHRob3NlIHRoYXQgYXJlIGVpdGhlciBoZXhhZGVjaW1hbFxyXG4gKiBudW1lcmljIHZhbHVlcyBPUiBudW1lcmljIHN0cmluZ3MgdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIEJpZ051bWJlcnMuIEl0IGlzXHJcbiAqIGltcG9zc2libGUgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgaGV4IHZhbHVlIG9mIDEwMDAwMCB2cyBhIGRlY2ltYWxcclxuICogdmFsdWUgb2YgMTAwMDAwIHNvIGEgc2Vjb25kIHBhcmFtZXRlciBpbmRpY2F0aW5nIHRoZSBudW1lcmljIGJhc2Ugb2YgdGhlXHJcbiAqIHN0cmluZyB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBBIGhleGFkZWNpbWFsIG9yIGRlY2ltYWwgc3RyaW5nXHJcbiAqIEBwYXJhbSBudW1lcmljQmFzZSAtIEVpdGhlciAxNiBmb3IgYSBoZXhhZGVjaWFtbCBvciAxMCBmb3IgYSBkZWNpbWFsXHJcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5nVG9CaWdOdW1iZXIodmFsdWU6IHN0cmluZywgbnVtZXJpY0Jhc2U6IE51bWVyaWNCYXNlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYFZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9IHBhc3NlZCB0byBzdHJpbmdUb0JpZ051bWJlcmAsXHJcbiAgICApO1xyXG4gIH1cclxuICBpZiAoXHJcbiAgICBudW1lcmljQmFzZSA9PT0gMTYgJiZcclxuICAgIChpc0hleFN0cmluZ09yTmVnYXRlZEhleFN0cmluZyh2YWx1ZSkgfHwgaXNEZWNpbWFsSGV4KHZhbHVlKSlcclxuICApIHtcclxuICAgIHJldHVybiBoZXhhZGVjaW1hbFRvQmlnTnVtYmVyKHZhbHVlKTtcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgbnVtZXJpY0Jhc2UgPT09IDEwICYmXHJcbiAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgZmluaXRlIGludGVnZXIgb3IgZmxvYXRcclxuICAgIChpc0Zpbml0ZShwYXJzZUludCh2YWx1ZSwgMTApKSB8fCBpc0Zpbml0ZShwYXJzZUZsb2F0KHZhbHVlKSkpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gZGVjaW1hbFRvQmlnTnVtYmVyKHZhbHVlKTtcclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgYFN0cmluZyBwcm92aWRlZCB0byBzdHJpbmdUb0JpZ051bWJlciBpcyBub3QgYSBoZXhhZGVjaW1hbCBvciBkZWNpbWFsIHN0cmluZzogJHt2YWx1ZX0sICR7bnVtZXJpY0Jhc2V9YCxcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2Qgd2lsbCBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgb3IgZGVjaWFtbCBudW1iZXIgaW50byBhIEJpZ051bWJlci5cclxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIgbXVzdCBiZSBzdXBwbGllZCBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHRyZWF0IHRoZVxyXG4gKiB2YWx1ZSBhcyBhIGhleGFkZWNpbWFsIG9yIGRlY2ltYWwgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIGhleGFkZWNpbWFsIG9yIGRlY2ltYWwgbnVtYmVyW11cclxuICogQHBhcmFtIG51bWVyaWNCYXNlIC0gMTAgZm9yIGRlY2ltYWwsIDE2IGZvciBoZXhhZGVjaW1hbFxyXG4gKiBAcmV0dXJucyBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBudW1iZXJUb0JpZ051bWJlcih2YWx1ZTogbnVtYmVyLCBudW1lcmljQmFzZTogTnVtZXJpY0Jhc2UpIHtcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgVmFsdWUgb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0gcGFzc2VkIHRvIG51bWJlclRvQmlnTnVtYmVyYCxcclxuICAgICk7XHJcbiAgfVxyXG4gIGlmIChudW1lcmljQmFzZSA9PT0gMTYgJiYgaXNIZXhTdHJpbmcoYCR7dmFsdWV9YCkpIHtcclxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGAke3ZhbHVlfWAsIDE2KTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDEwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ldGhvZCB0byBjb252ZXJ0IGEgQk4gdG8gYSBCaWdOdW1iZXJcclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gQSBCTiByZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlXHJcbiAqIEByZXR1cm5zIEEgQmlnTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCTidzIHVuZGVybHlpbmcgdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIGJuVG9CaWdOdW1iZXIodmFsdWU6IEJOKSB7XHJcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQk4gPT09IGZhbHNlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGB2YWx1ZSBwYXNzZWQgdG8gYm5Ub0JpZ051bWJlciBpcyBub3QgYSBCTi4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiB2YWx1ZX1gLFxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUudG9TdHJpbmcoMTYpLCAxNik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHZhbHVlIG9mIHRoZSBzdXBwb3J0ZWQgdHlwZXMgKHN0cmluZywgbnVtYmVyLCBCTikgdG8gYSBCaWdOdW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgQmlnTnVtYmVyXHJcbiAqIEBwYXJhbSBudW1lcmljQmFzZSAtIFRoZSBudW1lcmljIGJhc2Ugb2YgdGhlIHVuZGVybHlpbmcgdmFsdWVcclxuICogQHJldHVybnMgQSBCaWdOdW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWx1ZVRvQmlnTnVtYmVyKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIG51bWVyaWNCYXNlOiBOdW1lcmljQmFzZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nVG9CaWdOdW1iZXIodmFsdWUsIG51bWVyaWNCYXNlKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIG51bWJlclRvQmlnTnVtYmVyKHZhbHVlLCBudW1lcmljQmFzZSk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICBgVmFsdWU6ICR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZywgbnVtYmVyLCBCaWdOdW1iZXIgb3IgQk4uIFR5cGUgaXM6ICR7dHlwZW9mIHZhbHVlfS5gLFxyXG4gICk7XHJcbn1cclxuXHJcbi8vIEJpZyBOdW1iZXIgQ29uc3RhbnRzXHJcbmNvbnN0IEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIgPSBuZXcgQmlnTnVtYmVyKCcxMDAwMDAwMDAwMDAwMDAwMDAwJyk7XHJcbmNvbnN0IEJJR19OVU1CRVJfR1dFSV9NVUxUSVBMSUVSID0gbmV3IEJpZ051bWJlcignMTAwMDAwMDAwMCcpO1xyXG5jb25zdCBCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSID0gbmV3IEJpZ051bWJlcignMScpO1xyXG5cclxuY29uc3QgdG9Ob3JtYWxpemVkRGVub21pbmF0aW9uID0ge1xyXG4gIFdFSTogKGJpZ051bWJlcjogQmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIuZGl2KEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIpLFxyXG4gIEdXRUk6IChiaWdOdW1iZXI6IEJpZ051bWJlcikgPT4gYmlnTnVtYmVyLmRpdihCSUdfTlVNQkVSX0dXRUlfTVVMVElQTElFUiksXHJcbiAgRVRIOiAoYmlnTnVtYmVyOiBCaWdOdW1iZXIpID0+IGJpZ051bWJlci5kaXYoQklHX05VTUJFUl9FVEhfTVVMVElQTElFUiksXHJcbn07XHJcbmNvbnN0IHRvU3BlY2lmaWVkRGVub21pbmF0aW9uID0ge1xyXG4gIFdFSTogKGJpZ051bWJlcjogQmlnTnVtYmVyKSA9PlxyXG4gICAgYmlnTnVtYmVyLnRpbWVzKEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIpLnJvdW5kKCksXHJcbiAgR1dFSTogKGJpZ051bWJlcjogQmlnTnVtYmVyKSA9PlxyXG4gICAgYmlnTnVtYmVyLnRpbWVzKEJJR19OVU1CRVJfR1dFSV9NVUxUSVBMSUVSKS5yb3VuZCg5KSxcclxuICBFVEg6IChiaWdOdW1iZXI6IEJpZ051bWJlcikgPT5cclxuICAgIGJpZ051bWJlci50aW1lcyhCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSKS5yb3VuZCg5KSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB2YWx1ZSBpbiBFVEggb2YgdGhlIG51bWVyaWMgc3VwcGxpZWQsIHVzZWQgaW4gdGhpcyBmaWxlIG9ubHkgdG9cclxuICogY29udmVydCB0byBFVEggcHJpb3IgdG8gY29udmVydGluZyB0byBhbm90aGVyIGRlbm9taW5hdGlvbi4gVGhlIGZvbGxvd2luZ1xyXG4gKiBxdWlya3Mgd2VyZSBwcm9ncmFtbWVkIGludG8gdGhpcyBtZXRob2QgdG8gcmVwbGljYXRlIGJlaGF2aW9yIG9mIHRoZVxyXG4gKiBwcmVkZWNlc3NvciB0byBOdW1lcmljLCB3aGljaCB3YXMgJ2NvbnZlcnNpb25VdGlsJy4gSWYgYSBkZW5vbWluYXRpb24gaXNcclxuICogbm90IHN1cHBsaWVkLCBhbmQgdG9EZW5vbWluYXRpb24gaXMgY2FsbGVkLCB0aGVuIHdlIGFzc3VtZSB0aGUgZGVub21pbmF0aW9uXHJcbiAqIHdhcyBvcmlnaW5hbGx5IEVUSCwgb3RoZXJ3aXNlIHdlIGNvbnZlcnQgaXQgdG8gRVRILlxyXG4gKlxyXG4gKiBAcGFyYW0gbnVtZXJpY1xyXG4gKiBAcmV0dXJucyB2YWx1ZSBpbiBFVEhcclxuICovXHJcbmZ1bmN0aW9uIGdldFZhbHVlSW5FVEgobnVtZXJpYzogTnVtZXJpYykge1xyXG4gIGlmIChcclxuICAgIG51bWVyaWMuZGVub21pbmF0aW9uID09PSBFdGhlckRlbm9taW5hdGlvbi5FVEggfHxcclxuICAgIHR5cGVvZiBudW1lcmljLmRlbm9taW5hdGlvbiA9PT0gJ3VuZGVmaW5lZCdcclxuICApIHtcclxuICAgIHJldHVybiBudW1lcmljLnZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gdG9Ob3JtYWxpemVkRGVub21pbmF0aW9uW251bWVyaWMuZGVub21pbmF0aW9uXShudW1lcmljLnZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZW4gYXBwbHlpbmcgb3BlcmFuZHMgdG8gTnVtZXJpY3MgdGhhdCBoYXZlIGEgc3BlY2lmaWVkIERlbm9taW5hdGlvbiB0aGVuXHJcbiAqIHdlIHNob3VsZCBmaXJzdCBjb252ZXJ0IHRoZSBwcm92aWRlZCBpbnB1dE51bWVyaWMgdG8gdGhlIHNhbWUgRGVub21pbmF0aW9uXHJcbiAqIGFzIHRoZSBiYXNlTnVtZXJpYy4gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoaXMgZG9lc24ndCBhcHBseTpcclxuICpcclxuICogMS4gSWYgdGhlIGRlbm9taW5hdGlvbnMgYXJlIGFscmVhZHkgdGhlIHNhbWUuIE5vIGNvbnZlcnNpb24gaXMgbmVjZXNzYXJ5LlxyXG4gKiAyLiBJZiB0aGUgaW5wdXROdW1lcmljIGRvZXMgbm90IGhhdmUgYSBkZW5vbWluYXRpb24gc2V0LiBXZSBhc3N1bWUgaW4gdGhpc1xyXG4gKiBjYXNlIHRoYXQgdGhlIHZhbHVlIGlzIGFscmVhZHkgaW4gdGhlIGFwcHJvcHJpYXRlIGRlbm9taW5hdGlvbi5cclxuICpcclxuICogQHBhcmFtIGJhc2VOdW1lcmljXHJcbiAqIEBwYXJhbSBpbnB1dE51bWVyaWNcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGFsaWduT3BlcmFuZERlbm9taW5hdGlvbnMoXHJcbiAgYmFzZU51bWVyaWM6IE51bWVyaWMsXHJcbiAgaW5wdXROdW1lcmljOiBOdW1lcmljLFxyXG4pIHtcclxuICBpZiAoXHJcbiAgICB0eXBlb2YgaW5wdXROdW1lcmljLmRlbm9taW5hdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIGJhc2VOdW1lcmljLmRlbm9taW5hdGlvbiAhPT0gaW5wdXROdW1lcmljLmRlbm9taW5hdGlvblxyXG4gICkge1xyXG4gICAgcmV0dXJuIGlucHV0TnVtZXJpYy50b0Rlbm9taW5hdGlvbihiYXNlTnVtZXJpYy5kZW5vbWluYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlucHV0TnVtZXJpYztcclxufVxyXG5cclxuLyoqXHJcbiAqIE51bWVyaWMgaXMgYSBjbGFzcyB3aG9zZSBtZXRob2RzIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ldywgbm90IG11dGF0ZWQsXHJcbiAqIHZhbHVlLiBUaGlzIGFsbG93cyBmb3IgY2hhaW5pbmcgb2Ygbm9uLXRlcm1pbmF0aW5nIG1ldGhvZHMuIFByZXZpb3VzbHkgd2VcclxuICogaGFkIG5lYXIgYSBodW5kcmVkIGhlbHBlciBtZXRob2RzIHRoYXQgY29tcG9zZWQgb25lLWFub3RoZXIsIG1ha2luZyB0cmFja2luZ1xyXG4gKiB0aHJvdWdoIHRoZSBjaGFpbiBuZWFyIGltcG9zc2libGUuIFRoaXMgQVBJIGlzIGRlc2lnbmVkIHN1Y2ggdGhhdCBubyBoZWxwZXJcclxuICogbWV0aG9kcyBzaG91bGQgYmUgbmVlZGVkLiBUYWtlIHRoZSBjYXNlIG9mIGhleFdFSVRvRGVjR1dFSSwgYSBoZWxwZXIgbWV0aG9kXHJcbiAqIGZvciB0YWtpbmcgYSBoZXggc3RyaW5nIHJlcHJlc2VudGluZyBhIHZhbHVlIGluIFdFSSBhbmQgY29udmVydGluZyB0aGF0IHRvIGFcclxuICogZGVjaW1hbCBvZiBHV0VJLiBQcmlvciB0byB0aGlzIGNsYXNzIHRoZSBtZXRob2Qgd291bGQgY2FsbCBpbnRvIG91ciByb290XHJcbiAqIGxldmVsICdjb252ZXJzaW9uVXRpbCcgd2hpY2ggd2FzIHRoZSBwcm92ZXJiaWFsIGtpdGNoZW4gc2luayBkb2luZ1xyXG4gKiBldmVyeXRoaW5nIGZyb20gZGVub21pbmF0aW9uIGNvbnZlcnNpb24sIGN1cnJlbmN5IGNvbnZlcnNpb24gKHdpdGggcHJvdmlkZWRcclxuICogY29udmVyc2lvblJhdGUgcHJvcCkgYW5kIG1vcmUuIFRoZSBzYW1lIG9wZWFydGlvbiBjYW4gbm93IGJlIGV4cHJlc3NlZCBhczpcclxuICogbmV3IE51bWVyaWMoaGV4U3RyaW5nLCAxNiwgRXRoZXJEZW5vbWluYXRpb24uV0VJKVxyXG4gKiAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uR1dFSSlcclxuICogLnRvQmFzZSgxMClcclxuICogLnRvU3RyaW5nKCk7XHJcbiAqIFRoaXMgaGFzIHRoZSBiZW5lZml0IG9mIGJlaW5nIGZhaXJseSB0cmFuc3BhcmVudCBhcyB5b3UgY2FuIHJlYWQgZWFjaCBzdGVwXHJcbiAqIGluIHRoZSBjaGFpbiBhbmQgaGF2ZSBhIGdvb2Qgc2Vuc2Ugb2Ygd2hhdCBpcyBiZWluZyBkb25lLiBJdCBhbHNvIGlzIGhpZ2hseVxyXG4gKiBjb21wb3NhYmxlIHNvIHRoYXQgd2Ugc2hvdWxkbid0IG5lZWQgdG9ucyBvZiBoZWxwZXIgbWV0aG9kcyBmb3Igc2hvcnRjdXRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE51bWVyaWMge1xyXG4gIC8qKlxyXG4gICAqIFRoZSB1bmRlcmx5aW5nIHZhbHVlIG9mIHRoZSBOdW1lcmljLCBhbHdheXMgaW4gQmlnTnVtYmVyIGZvcm1cclxuICAgKi9cclxuICB2YWx1ZTogQmlnTnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgbnVtZXJpYyBiYXNlIGZvciB0aGlzIE51bWVyaWMsIGVpdGhlciAxMCBmb3IgZGVjaW1hbCBvciAxNiBmb3IgSGV4XHJcbiAgICovXHJcbiAgYmFzZT86IE51bWVyaWNCYXNlO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgY3VycmVudCBkZW5vbWluYXRpb24sIGlmIGFueS4gVGhlIG9ubHkgc3VwcG9ydGVkIGRlbm9taW5hdGlvbnMgYXJlXHJcbiAgICogRVRILCBHV0VJLCBXRUkuXHJcbiAgICovXHJcbiAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb247XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgdmFsdWU6IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgdGhpcy5iYXNlID0gYmFzZTtcclxuICAgIHRoaXMuZGVub21pbmF0aW9uID0gZGVub21pbmF0aW9uO1xyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCTikge1xyXG4gICAgICB0aGlzLnZhbHVlID0gYm5Ub0JpZ051bWJlcih2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHxcclxuICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB8fFxyXG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gJycpXHJcbiAgICApIHtcclxuICAgICAgLy8gVGhlcmUgYXJlIHBhcnRzIG9mIHRoZSBjb2RlYmFzZSB0aGF0IGNhbGwgdGhpcyBtZXRob2Qgd2l0aG91dCBhIHZhbHVlLFxyXG4gICAgICAvLyBvciB3aXRoIGEgJ05hTicgKHdoaWNoIGlzIHByb2JhYmx5IGEgYnVnIHNvbWV3aGVyZSBpbiBvdXIgdGVzdHM/KS5cclxuICAgICAgLy8gT3ZlciB0aW1lIG9mIGNvbnZlcnRpbmcgdG8gVHlwZVNjcmlwdCB3ZSB3aWxsIGVyYWRpY2F0ZSB0aG9zZSwgYnV0IHRoZVxyXG4gICAgICAvLyBoZWxwZXIgbWV0aG9kcyB0aGF0IHRob3NlIGluc3RhbmNlcyBlbXBsb3kgd291bGQgZGVmYXVsdCB0aGUgdmFsdWUgdG9cclxuICAgICAgLy8gMC4gVGhpcyBibG9jayBrZWVwcyB0aGF0IGludGFjdC5cclxuICAgICAgdGhpcy52YWx1ZSA9IG5ldyBCaWdOdW1iZXIoJzAnLCAxMCk7XHJcbiAgICAgIHRoaXMuYmFzZSA9IDEwO1xyXG4gICAgfSBlbHNlIGlmIChiYXNlKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZVRvQmlnTnVtYmVyKHZhbHVlLCBiYXNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgWW91IG11c3Qgc3BlY2lmeSB0aGUgYmFzZSBvZiB0aGUgcHJvdmlkZWQgbnVtYmVyIGlmIHRoZSB2YWx1ZSBpcyBub3QgYWxyZWFkeSBhIEJpZ051bWJlcmAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIGEgdG9vbCB1c2VkIGludGVybmFsbHkgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhbHJlYWR5IGEgTnVtZXJpY1xyXG4gICAqIGFuZCByZXR1cm4gaXQgaWYgaXQgaXMsIG90aGVyd2lzZSBpdCB1c2VzIHRoZSBvdGhlciBwcm92aWRlZCBhcmd1bWVudHMgdG9cclxuICAgKiBjcmVhdGUgYSBuZXcgTnVtZXJpYy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgTnVtZXJpY1xyXG4gICAqIEBwYXJhbSBiYXNlIC0gRWl0aGVyIHVuZGVmaW5lZCwgMTAgZm9yIGRlY2ltYWwgb3IgMTYgZm9yIGhleGFkZWNpbWFsXHJcbiAgICogQHBhcmFtIGRlbm9taW5hdGlvbiAtIFRoZSBFdGhlciBkZW5vbWluYXRpb24gdG8gc2V0LCBpZiBhbnlcclxuICAgKi9cclxuICBzdGF0aWMgZnJvbShcclxuICAgIHZhbHVlOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1lcmljKSB7XHJcbiAgICAgIGlmIChiYXNlIHx8IGRlbm9taW5hdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBOdW1lcmljLmZyb20gd2FzIGNhbGxlZCB3aXRoIGEgdmFsdWUgKCR7dmFsdWUudG9TdHJpbmcoKX0pIHRoYXQgaXMgYWxyZWFkeSBhIE51bWVyaWMgYnV0IGEgYmFzZSBhbmQvb3IgZGVub21pbmF0aW9uIHdhcyBwcm92aWRlZC4gT25seSBzdXBwbHkgYmFzZSBvciBkZW5vbWluYXRpb24gd2hlbiBjcmVhdGluZyBhIG5ldyBOdW1lcmljYCxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTnVtZXJpYyh2YWx1ZSwgYmFzZSwgZGVub21pbmF0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKiBDb252ZXJzaW9ucyAqL1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IE51bWVyaWMgd2l0aCB0aGUgYmFzZSB2YWx1ZSBjaGFuZ2VkIHRvIHRoZSBwcm92aWRlZCBiYXNlLFxyXG4gICAqIG9yIHRoZSBvcmlnaW5hbCBOdW1lcmljIGlmIHRoZSBiYXNlIHByb3ZpZGVkIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XHJcbiAgICogYmFzZS4gTm8gY29tcHV0YXRpb24gb3IgY29udmVyc2lvbiBoYXBwZW5zIGhlcmUgYnV0IHJhdGhlciB0aGUgcmVzdWx0IG9mXHJcbiAgICogdG9TdHJpbmcgd2lsbCBiZSBjaGFuZ2VkIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgdGhpcy5iYXNlIHdoZW4gdGhhdFxyXG4gICAqIG1ldGhvZCBpcyBpbnZva2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJhc2UgLSBUaGUgbnVtZXJpYyBiYXNlIHRvIGNoYW5nZSB0aGUgTnVtZXJpYyB0bywgZWl0aGVyIDEwIG9yIDE2XHJcbiAgICogQHJldHVybnMgQSBuZXcgTnVtZXJpYyB3aXRoIHRoZSBiYXNlIHVwZGF0ZWRcclxuICAgKi9cclxuICB0b0Jhc2UoYmFzZTogTnVtZXJpY0Jhc2UpIHtcclxuICAgIGlmICh0aGlzLmJhc2UgIT09IGJhc2UpIHtcclxuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljKHRoaXMudmFsdWUsIGJhc2UsIHRoaXMuZGVub21pbmF0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdGhlIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgZGVub21pbmF0aW9uLiBUaGUgZm9sbG93aW5nIHF1aXJrcyBvZlxyXG4gICAqIHRoZSBwcmVkZWNlc3NvciB0byBOdW1lcmljLCAnY29udmVyc2lvblV0aWwnLCB3ZXJlIHByb2dyYW1tZWQgaW50byB0aGlzXHJcbiAgICogbWV0aG9kOlxyXG4gICAqIDEuIFlvdSBtYXkgc3VwcGx5IGEgZGVub21pbmF0aW9uIHRoYXQgaXMgdW5kZWZpbmVkLCB3aGljaCB3aWxsIHJlc3VsdCBpblxyXG4gICAqIG5vdGhpbmcgaGFwcGVuaW5nLiBDb2luY2lkZW50bHkgdGhpcyBpcyBhbHNvIHVzZWZ1bCBkdWUgdG8gdGhlIG5hdHVyZSBvZlxyXG4gICAqIGNoYWluaW5nIG9wZXJhdGlvbnMgb24gTnVtZXJpYy4gWW91IG1heSBwYXNzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGlzXHJcbiAgICogbWV0aG9kIHdpdGhvdXQgYnJlYWtpbmcgdGhlIGNoYWluIHRvIGNvbmRpdGlvbmFsbHkgYXBwbHkgYSBvcGVyYXRvci5cclxuICAgKiAyLiBJZiB0aGUgbnVtZXJpYyB0aGF0IC50b0Rlbm9taW5hdGlvbiBpcyBjYWxsZWQgb24gZG9lcyBub3QgaGF2ZSBhXHJcbiAgICogZGVub21pbmF0aW9uIHNldCwgdGhhdCBpcyBpdCB3YXMgY29uc3RydWN0ZWQgd2l0aG91dCB0aGUgdGhpcmQgcGFyYW1ldGVyLFxyXG4gICAqIHRoZW4gaXQgaXMgYXNzdW1lZCB0byBiZSBpbiBFVEguIE90aGVyd2lzZSB3ZSBjb252ZXJ0IGl0IHRvIEVUSCBwcmlvciB0b1xyXG4gICAqIGF0dGVtcHRpbmcgdG8gY29udmVydCBpdCB0byBhbm90aGVyIGRlbm9taW5hdGlvbiBiZWNhdXNlIGFsbCBvZiB0aGVcclxuICAgKiB0b1NwZWNpZmllZERlbm9taW5hdGlvbiBtZXRob2RzIGFzc3VtZSBhIHZhbHVlIGluIEVUSCBpcyBwYXNzZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGVub21pbmF0aW9uIC0gVGhlIGRlbm9taW5hdGlvbiB0byBjb252ZXJ0IHRvXHJcbiAgICogQHJldHVybnMgQSBuZXcgbnVtZXJpYyB3aXRoIHRoZSBzYW1lIGJhc2UgYXMgdGhlIHByZXZpb3VzLCBidXQgdGhlXHJcbiAgICogdmFsdWUgYW5kIGRlbm9taW5hdGlvbiBjaGFuZ2VkIGFjY29yZGluZ2x5XHJcbiAgICovXHJcbiAgdG9EZW5vbWluYXRpb24oZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24pIHtcclxuICAgIGlmIChkZW5vbWluYXRpb24gJiYgdGhpcy5kZW5vbWluYXRpb24gIT09IGRlbm9taW5hdGlvbikge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgTnVtZXJpYyhcclxuICAgICAgICB0b1NwZWNpZmllZERlbm9taW5hdGlvbltkZW5vbWluYXRpb25dKGdldFZhbHVlSW5FVEgodGhpcykpLFxyXG4gICAgICAgIHRoaXMuYmFzZSxcclxuICAgICAgICBkZW5vbWluYXRpb24sXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcGxpY2F0ZXMgYSBtZXRob2Qgb2YgQmlnTnVtYmVyIHRoYXQgaXMgbm90IGluIHRoZSB2ZXJzaW9uIG9mIEJpZ051bWJlclxyXG4gICAqIHRoYXQgd2UgdXNlIGN1cnJlbnRseS4gRXNzZW50aWFsbHkgc2hpZnRpbmcgdGhlIGRlY2ltYWwgcG9pbnQgYmFja3dhcmRzIGJ5XHJcbiAgICogYW4gYW1vdW50IGVxdWFsIHRvIHRoZSBwb3NpdGl2ZSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIGRlY2ltYWxzIG9wZXJhdG9yLlxyXG4gICAqIEZvciBleGFtcGxlLCBjYWxsaW5nIHNoaWZ0ZWRCeSgxMCkgb24gdGhlIHZhbHVlIDEwMDAwMDAwMDAwIHdpbGwgcmVzdWx0IGluXHJcbiAgICogYSB2YWx1ZSBvZiAxLjAwMDAwMDAwMDAuIElmIHBhc3NpbmcgYSBuZWdhdGl2ZSBudW1iZXIsIHRoZW4gdGhlIGRlY2ltYWxcclxuICAgKiBwb3NpdGlvbiB3aWxsIG1vdmUgZm9yd2FyZC4gMS4wMDAwMDAwMDAwIHNoaWZ0ZWRCeSgtMTApIHlpZWxkcyAxMDAwMDAwMDAwMFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byBtb3ZlLiBQb3NpdGl2ZSBtb3Zlc1xyXG4gICAqIGRlY2ltYWwgYmFja3dhcmRzLCBjcmVhdGluZyBhIHNtYWxsZXIgbnVtYmVyLiBOZWdhdGl2ZSB2YWx1ZXMgbW92ZSB0aGVcclxuICAgKiBkZWNpbWFsIGZvcndhcmRzLCBjcmVhdGluZyBhIGxhcmdlciBudW1iZXIuXHJcbiAgICogQHJldHVybnMgQSBuZXcgbnVtZXJpYyB3aXRoIHRoZSBzYW1lIGJhc2UgYW5kIGRlbm9taW5hdGlvbiBhcyB0aGUgY3VycmVudFxyXG4gICAqIGJ1dCB3aXRoIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNoaWZ0ZWRCeShkZWNpbWFsczogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBwb3dlck9mID0gbmV3IE51bWVyaWMoTWF0aC5wb3coMTAsIGRlY2ltYWxzKSwgMTApO1xyXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlKHBvd2VyT2YpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbGllcyBhIGNvbnZlcnNpb24gcmF0ZSB0byB0aGUgTnVtZXJpYy4gSWYgcmF0ZSBpcyB1bmRlZmluZWQgcmV0dXJucyB0aGVcclxuICAgKiBzYW1lIGluc3RhbmNlIHRoYXQgd2FzIG9wZXJhdGVkIG9uLiBBbGxvd2luZyBhbiB1bmRlZmluZWQgdmFsdWUgbWFrZXNcclxuICAgKiBjaGFpbmluZyB0aGlzIG9wZXJhdG9yIGZlYXNpYmxlIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHRoZSB1c2VyIG9yXHJcbiAgICogc3RhdGUgd2l0aG91dCBtYW5pcHVsYXRpbmcgdGhlIG51bWJlci4gRm9yIGV4YW1wbGU6XHJcbiAgICpcclxuICAgKiBuZXcgTnVtZXJpYyg1LCAxMClcclxuICAgKiAuYXBwbHlDb252ZXJzaW9uUmF0ZShwb3NzaWJseVVuZGVmaW5lZFJhdGUpXHJcbiAgICogLnRvQmFzZSgxNilcclxuICAgKiAudG9TdHJpbmcoKTtcclxuICAgKlxyXG4gICAqIFdpbGwgcmV0dXJuIGEgdmFsaWQgcmVzdWx0IGFzIGxvbmcgYXMgcG9zc2libHlVbmRlZmluZWRSYXRlIGlzIHVuZGVmaW5lZCxcclxuICAgKiBhIEJpZ051bWJlciBvciBhIG51bWJlci4gSW4gc29tZSBhcmVhcyBvZiB0aGUgY29kZWJhc2Ugd2UgY2hlY2sgdG8gc2VlIGlmXHJcbiAgICogdGhlIHRhcmdldCBjdXJyZW5jeSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBjdXJyZW5jeSBiZWZvcmUgYXBwbHlpbmdcclxuICAgKiBhIGNvbnZlcnNpb25SYXRlLiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgbm90IGJ1aWx0IGludG8gTnVtZXJpYyBhbmQgd2lsbFxyXG4gICAqIHJlcXVpcmUgYnJlYWtpbmcgdGhlIGNoYWluIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kOlxyXG4gICAqIGxldCB2YWx1ZSA9IG5ldyBOdW1lcmljKDUsIDEwKTtcclxuICAgKlxyXG4gICAqIGlmIChmcm9tQ3VycmVuY3kgIT09IHRvQ3VycmVuY3kpIHtcclxuICAgKiB2YWx1ZSA9IHZhbHVlLmFwcGx5Q29udmVyc2lvblJhdGUocG9zc2libHlVbmRlZmluZWRSYXRlKTtcclxuICAgKiB9XHJcbiAgICpcclxuICAgKiByZXR1cm4gdmFsdWUudG9CYXNlKDE2KS50b1N0cmluZygpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHJhdGUgLSBUaGUgbXVsdGlwbGllciB0byBhcHBseVxyXG4gICAqIEBwYXJhbSBpbnZlcnQgLSBpZiB0cnVlLCBpbnZlcnRzIHRoZSByYXRlXHJcbiAgICogQHJldHVybnMgTmV3IE51bWVyaWMgdmFsdWUgd2l0aCBjb252ZXJzaW9uIHJhdGUgYXBwbGllZC5cclxuICAgKi9cclxuICBhcHBseUNvbnZlcnNpb25SYXRlKHJhdGU/OiBudW1iZXIgfCBCaWdOdW1iZXIsIGludmVydD86IGJvb2xlYW4pIHtcclxuICAgIGlmICh0eXBlb2YgcmF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbnZlcnNpb25SYXRlID0gbmV3IE51bWVyaWMocmF0ZSwgMTApO1xyXG4gICAgaWYgKGludmVydCkge1xyXG4gICAgICBjb252ZXJzaW9uUmF0ZSA9IG5ldyBOdW1lcmljKG5ldyBCaWdOdW1iZXIoMS4wKSkuZGl2aWRlKGNvbnZlcnNpb25SYXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnRpbWVzKGNvbnZlcnNpb25SYXRlKTtcclxuICB9XHJcblxyXG4gIHJvdW5kKFxyXG4gICAgbnVtYmVyT2ZEZWNpbWFscz86IG51bWJlcixcclxuICAgIHJvdW5kaW5nTW9kZTogbnVtYmVyID0gQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTixcclxuICApIHtcclxuICAgIGlmICh0eXBlb2YgbnVtYmVyT2ZEZWNpbWFscyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljKFxyXG4gICAgICAgIHRoaXMudmFsdWUucm91bmQobnVtYmVyT2ZEZWNpbWFscywgcm91bmRpbmdNb2RlKSxcclxuICAgICAgICB0aGlzLmJhc2UsXHJcbiAgICAgICAgdGhpcy5kZW5vbWluYXRpb24sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86IG1ha2UgaXQgcG9zc2libGUgdG8gYWRkIEVUSCArIEdXRUkgdmFsdWUuIFNvIGlmIHlvdSBoYXZlXHJcbiAgICogTnVtZXJpYyAxIHdpdGggZGVub21pbmF0aW9uIEVUSCBhbmQgTnVtZXJpYyAyIHdpdGggRGVub21pbmF0aW9uIFdFSSxcclxuICAgKiBmaXJzdCBjb252ZXJ0IE51bWVyaWMgMiB0byBFVEggdGhlbiBhZGQgdGhlIGFtb3VudCB0byBOdW1lcmljIDEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFsdWVcclxuICAgKiBAcGFyYW0gYmFzZVxyXG4gICAqIEBwYXJhbSBkZW5vbWluYXRpb25cclxuICAgKi9cclxuICBhZGQoXHJcbiAgICB2YWx1ZTogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgY29uc3QgbnVtZXJpYyA9IE51bWVyaWMuZnJvbSh2YWx1ZSwgYmFzZSwgZGVub21pbmF0aW9uKTtcclxuICAgIHJldHVybiBuZXcgTnVtZXJpYyhcclxuICAgICAgdGhpcy52YWx1ZS5hZGQoYWxpZ25PcGVyYW5kRGVub21pbmF0aW9ucyh0aGlzLCBudW1lcmljKS52YWx1ZSksXHJcbiAgICAgIHRoaXMuYmFzZSxcclxuICAgICAgdGhpcy5kZW5vbWluYXRpb24sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVE9ETzogbWFrZSBpdCBwb3NzaWJsZSB0byBzdWJ0cmFjdCBFVEggLSBHV0VJIHZhbHVlLiBTbyBpZiB5b3UgaGF2ZVxyXG4gICAqIE51bWVyaWMgMSB3aXRoIGRlbm9taW5hdGlvbiBFVEggYW5kIE51bWVyaWMgMiB3aXRoIERlbm9taW5hdGlvbiBXRUksXHJcbiAgICogZmlyc3QgY29udmVydCBOdW1lcmljIDIgdG8gRVRIIHRoZW4gc3VidHJhY3QgdGhlIGFtb3VudCBmcm9tIE51bWVyaWMgMS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAqIEBwYXJhbSBiYXNlXHJcbiAgICogQHBhcmFtIGRlbm9taW5hdGlvblxyXG4gICAqL1xyXG4gIG1pbnVzKFxyXG4gICAgdmFsdWU6IE51bWVyaWMgfCBOdW1lcmljVmFsdWUsXHJcbiAgICBiYXNlPzogTnVtZXJpY0Jhc2UsXHJcbiAgICBkZW5vbWluYXRpb24/OiBFdGhlckRlbm9taW5hdGlvbixcclxuICApIHtcclxuICAgIGNvbnN0IG51bWVyaWMgPSBOdW1lcmljLmZyb20odmFsdWUsIGJhc2UsIGRlbm9taW5hdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBOdW1lcmljKFxyXG4gICAgICB0aGlzLnZhbHVlLm1pbnVzKGFsaWduT3BlcmFuZERlbm9taW5hdGlvbnModGhpcywgbnVtZXJpYykudmFsdWUpLFxyXG4gICAgICB0aGlzLmJhc2UsXHJcbiAgICAgIHRoaXMuZGVub21pbmF0aW9uLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHRpbWVzKFxyXG4gICAgbXVsdGlwbGllcjogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgY29uc3QgbXVsdGlwbGllck51bWVyaWMgPSBOdW1lcmljLmZyb20obXVsdGlwbGllciwgYmFzZSwgZGVub21pbmF0aW9uKTtcclxuICAgIHJldHVybiBuZXcgTnVtZXJpYyhcclxuICAgICAgdGhpcy52YWx1ZS50aW1lcyhcclxuICAgICAgICBhbGlnbk9wZXJhbmREZW5vbWluYXRpb25zKHRoaXMsIG11bHRpcGxpZXJOdW1lcmljKS52YWx1ZSxcclxuICAgICAgKSxcclxuICAgICAgdGhpcy5iYXNlLFxyXG4gICAgICB0aGlzLmRlbm9taW5hdGlvbixcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXZpZGVzIHRoZSBOdW1lcmljIGJ5IGFub3RoZXIgc3VwcGxpZWQgTnVtZXJpYywgY2Fycnlpbmcgb3ZlciB0aGUgYmFzZVxyXG4gICAqIGFuZCBkZW5vbWluYXRpb24gZnJvbSB0aGUgY3VycmVudCBOdW1lcmljLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRpdmlzb3IgLSBUaGUgTnVtZXJpYyB0byBkaXZpZGUgdGhpcyBOdW1lcmljIGJ5XHJcbiAgICogQHBhcmFtIGJhc2VcclxuICAgKiBAcGFyYW0gZGVub21pbmF0aW9uXHJcbiAgICogQHJldHVybnMgQSBuZXcgTnVtZXJpYyB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uXHJcbiAgICovXHJcbiAgZGl2aWRlKFxyXG4gICAgZGl2aXNvcjogTnVtZXJpYyB8IE51bWVyaWNWYWx1ZSxcclxuICAgIGJhc2U/OiBOdW1lcmljQmFzZSxcclxuICAgIGRlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uLFxyXG4gICkge1xyXG4gICAgcmV0dXJuIG5ldyBOdW1lcmljKFxyXG4gICAgICB0aGlzLnZhbHVlLmRpdihcclxuICAgICAgICBhbGlnbk9wZXJhbmREZW5vbWluYXRpb25zKFxyXG4gICAgICAgICAgdGhpcyxcclxuICAgICAgICAgIE51bWVyaWMuZnJvbShkaXZpc29yLCBiYXNlLCBkZW5vbWluYXRpb24pLFxyXG4gICAgICAgICkudmFsdWUsXHJcbiAgICAgICksXHJcbiAgICAgIHRoaXMuYmFzZSxcclxuICAgICAgdGhpcy5kZW5vbWluYXRpb24sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ3JlYXRlclRoYW4oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5ncmVhdGVyVGhhbihcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ3JlYXRlclRoYW5PckVxdWFsVG8oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5ncmVhdGVyVGhhbk9yRXF1YWxUbyhcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbGVzc1RoYW4oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sZXNzVGhhbihcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbGVzc1RoYW5PckVxdWFsVG8oXHJcbiAgICBjb21wYXJhdG9yOiBOdW1lcmljIHwgTnVtZXJpY1ZhbHVlLFxyXG4gICAgYmFzZT86IE51bWVyaWNCYXNlLFxyXG4gICAgZGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb24sXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sZXNzVGhhbk9yRXF1YWxUbyhcclxuICAgICAgTnVtZXJpYy5mcm9tKGNvbXBhcmF0b3IsIGJhc2UsIGRlbm9taW5hdGlvbikudmFsdWUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaXNOZWdhdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlLmlzTmVnYXRpdmUoKTtcclxuICB9XHJcblxyXG4gIGlzUG9zaXRpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCkgPT09IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgYmFzZSAxNiBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE51bWVyaWMgdGhhdCBpc1xyXG4gICAqIDB4IHByZWZpeGVkLiBUaGlzIG9wZXJhdGlvbiBieXBhc3NlcyB0aGUgY3VycmVudGx5IHNldCBiYXNlIG9mIHRoZVxyXG4gICAqIE51bWVyaWMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyAweCBwcmVmaXhlZCBoZXhzdHJpbmcuXHJcbiAgICovXHJcbiAgdG9QcmVmaXhlZEhleFN0cmluZygpIHtcclxuICAgIHJldHVybiBhZGRIZXhQcmVmaXgodGhpcy52YWx1ZS50b1N0cmluZygxNikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1lcmljLCB1c2luZyB0aGUgY3VycmVudCB2YWx1ZSBvZlxyXG4gICAqIHRoaXMuYmFzZSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIGJlIGEgZGVjaW1hbCBvciBoZXhhZGVjaW1hbCBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1lcmljXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyh0aGlzLmJhc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGZpeGVkLXBvaW50IGRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOdW1lcmljXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGVjaW1hbHMgLSB0aGUgYW1vdW50IG9mIGRlY2ltYWwgcHJlY2lzaW9uIHRvIHVzZSB3aGVuIHJvdW5kaW5nXHJcbiAgICogQHJldHVybnMgQSBmaXhlZCBwb2ludCBkZWNpbWFsIHN0cmluZyByZXByZXNlbmF0aW9uIG9mIHRoZSBOdW1lcmljXHJcbiAgICovXHJcbiAgdG9GaXhlZChkZWNpbWFsczogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50b0ZpeGVkKGRlY2ltYWxzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoZSB2YWx1ZSB0byBhIEphdmFTY3JpcHQgTnVtYmVyLCB3aXRoIGFsbCBvZiB0aGUgaW5hY2N1cmFjeSB0aGF0XHJcbiAgICogY291bGQgY29tZSB3aXRoIHRoYXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBKUyBOdW1iZXJcclxuICAgKi9cclxuICB0b051bWJlcigpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvTnVtYmVyKCk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBVdGlsaXR5IEZ1bmN0aW9ucyB0byBzdXBwb3J0IGJyb3dzZXIucnVudGltZSBKYXZhU2NyaXB0IEFQSVxyXG4gKi9cclxuXHJcbmltcG9ydCBicm93c2VyIGZyb20gJ3dlYmV4dGVuc2lvbi1wb2x5ZmlsbCc7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gRXJyb3IgaWYgZXh0ZW5zaW9uLnJ1bnRpbWUubGFzdEVycm9yIGlzIHByZXNlbnRcclxuICogdGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHRoZSBub24tc3RhbmRhcmQgZXJyb3Igb2JqZWN0IHRoYXQncyB1c2VkXHJcbiAqXHJcbiAqIEFjY29yZGluZyB0byB0aGUgZG9jcywgd2UgYXJlIGV4cGVjdGVkIHRvIGNoZWNrIGxhc3RFcnJvciBpbiBydW50aW1lIEFQSSBjYWxsYmFja3M6XHJcbiAqIFwiXHJcbiAqIElmIHlvdSBjYWxsIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IG1heSBzZXQgbGFzdEVycm9yLCB5b3UgYXJlIGV4cGVjdGVkIHRvXHJcbiAqIGNoZWNrIGZvciB0aGUgZXJyb3Igd2hlbiB5b3UgaGFuZGxlIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uLiBJZiBsYXN0RXJyb3IgaGFzIGJlZW5cclxuICogc2V0IGFuZCB5b3UgZG9uJ3QgY2hlY2sgaXQgd2l0aGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgdGhlbiBhbiBlcnJvciB3aWxsIGJlIHJhaXNlZC5cclxuICogXCJcclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9sYXN0RXJyb3J9XHJcbiAqIEByZXR1cm5zIHtFcnJvcnx1bmRlZmluZWR9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tGb3JMYXN0RXJyb3IoKSB7XHJcbiAgY29uc3QgeyBsYXN0RXJyb3IgfSA9IGJyb3dzZXIucnVudGltZTtcclxuICBpZiAoIWxhc3RFcnJvcikge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLy8gaWYgaXQgcXVhY2tzIGxpa2UgYW4gRXJyb3IsIGl0cyBhbiBFcnJvclxyXG4gIGlmIChsYXN0RXJyb3Iuc3RhY2sgJiYgbGFzdEVycm9yLm1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBsYXN0RXJyb3I7XHJcbiAgfVxyXG4gIC8vIHJlcGFpciBpbmNvbXBsZXRlIGVycm9yIG9iamVjdCAoZWcgY2hyb21pdW0gdjc3KVxyXG4gIHJldHVybiBuZXcgRXJyb3IobGFzdEVycm9yLm1lc3NhZ2UpO1xyXG59XHJcblxyXG4vKiogQHJldHVybnMge0Vycm9yfHVuZGVmaW5lZH0gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yTGFzdEVycm9yQW5kTG9nKCkge1xyXG4gIGNvbnN0IGVycm9yID0gY2hlY2tGb3JMYXN0RXJyb3IoKTtcclxuXHJcbiAgaWYgKGVycm9yKSB7XHJcbiAgICBsb2cuZXJyb3IoZXJyb3IpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVycm9yO1xyXG59XHJcblxyXG4vKiogQHJldHVybnMge0Vycm9yfHVuZGVmaW5lZH0gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yTGFzdEVycm9yQW5kV2FybigpIHtcclxuICBjb25zdCBlcnJvciA9IGNoZWNrRm9yTGFzdEVycm9yKCk7XHJcblxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBlcnJvcjtcclxufVxyXG4iLCJ0eXBlIGNvbnRyYWN0ID0ge1xyXG4gIGNvbnRyYWN0Q29kZTogc3RyaW5nIHwgbnVsbDtcclxuICBpc0NvbnRyYWN0QWRkcmVzczogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWFkQWRkcmVzc0FzQ29udHJhY3QgPSBhc3luYyAoXHJcbiAgZXRoUXVlcnk6IHtcclxuICAgIGdldENvZGU6IChhZGRyZXNzOiBzdHJpbmcpID0+IHN0cmluZztcclxuICB9LFxyXG4gIGFkZHJlc3M6IHN0cmluZyxcclxuKTogUHJvbWlzZTxjb250cmFjdD4gPT4ge1xyXG4gIGxldCBjb250cmFjdENvZGU7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnRyYWN0Q29kZSA9IGF3YWl0IGV0aFF1ZXJ5LmdldENvZGUoYWRkcmVzcyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29udHJhY3RDb2RlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlzQ29udHJhY3RBZGRyZXNzID0gY29udHJhY3RDb2RlXHJcbiAgICA/IGNvbnRyYWN0Q29kZSAhPT0gJzB4JyAmJiBjb250cmFjdENvZGUgIT09ICcweDAnXHJcbiAgICA6IGZhbHNlO1xyXG4gIHJldHVybiB7IGNvbnRyYWN0Q29kZSwgaXNDb250cmFjdEFkZHJlc3MgfTtcclxufTtcclxuIiwiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuXHJcbmltcG9ydCB7IGFkZEhleFByZWZpeCwgQk4gfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xyXG5pbXBvcnQgeyBFdGhlckRlbm9taW5hdGlvbiB9IGZyb20gJy4uL2NvbnN0YW50cy9jb21tb24nO1xyXG5pbXBvcnQgeyBOdW1lcmljLCBOdW1lcmljVmFsdWUgfSBmcm9tICcuL051bWVyaWMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY0dXRUlUb0hleFdFSShkZWNHV0VJOiBudW1iZXIpIHtcclxuICByZXR1cm4gbmV3IE51bWVyaWMoZGVjR1dFSSwgMTAsIEV0aGVyRGVub21pbmF0aW9uLkdXRUkpXHJcbiAgICAudG9CYXNlKDE2KVxyXG4gICAgLnRvRGVub21pbmF0aW9uKEV0aGVyRGVub21pbmF0aW9uLldFSSlcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3RIZXhlcyhhSGV4V0VJOiBzdHJpbmcsIGJIZXhXRUk6IHN0cmluZykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhhSGV4V0VJLCAxNilcclxuICAgIC5taW51cyhuZXcgTnVtZXJpYyhiSGV4V0VJLCAxNikpXHJcbiAgICAucm91bmQoNiwgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTilcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkSGV4ZXMoYUhleFdFSTogc3RyaW5nLCBiSGV4V0VJOiBzdHJpbmcpIHtcclxuICByZXR1cm4gbmV3IE51bWVyaWMoYUhleFdFSSwgMTYpXHJcbiAgICAuYWRkKG5ldyBOdW1lcmljKGJIZXhXRUksIDE2KSlcclxuICAgIC5yb3VuZCg2LCBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOKVxyXG4gICAgLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNXRUlUb0RlY0VUSChkZWNXRUk6IHN0cmluZykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhkZWNXRUksIDEwLCBFdGhlckRlbm9taW5hdGlvbi5XRUkpXHJcbiAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxyXG4gICAgLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoZXhXRUlUb0RlY0VUSChoZXhXRUk6IHN0cmluZykge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhoZXhXRUksIDE2LCBFdGhlckRlbm9taW5hdGlvbi5XRUkpXHJcbiAgICAudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uRVRIKVxyXG4gICAgLnRvQmFzZSgxMClcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVjRXRoVG9Db252ZXJ0ZWRDdXJyZW5jeShcclxuICBldGhUb3RhbDogTnVtZXJpY1ZhbHVlLFxyXG4gIGNvbnZlcnRlZEN1cnJlbmN5Pzogc3RyaW5nLFxyXG4gIGNvbnZlcnNpb25SYXRlPzogbnVtYmVyLFxyXG4pIHtcclxuICBsZXQgbnVtZXJpYyA9IG5ldyBOdW1lcmljKGV0aFRvdGFsLCAxMCwgRXRoZXJEZW5vbWluYXRpb24uRVRIKTtcclxuXHJcbiAgaWYgKGNvbnZlcnRlZEN1cnJlbmN5ICE9PSBFdGhlckRlbm9taW5hdGlvbi5FVEgpIHtcclxuICAgIG51bWVyaWMgPSBudW1lcmljLmFwcGx5Q29udmVyc2lvblJhdGUoY29udmVyc2lvblJhdGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bWVyaWMucm91bmQoMik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWlIZXhGcm9tRGVjaW1hbFZhbHVlKHtcclxuICB2YWx1ZSxcclxuICBjb252ZXJzaW9uUmF0ZSA9IDEsXHJcbiAgZnJvbURlbm9taW5hdGlvbixcclxuICBmcm9tQ3VycmVuY3ksXHJcbiAgaW52ZXJ0Q29udmVyc2lvblJhdGUgPSBmYWxzZSxcclxufToge1xyXG4gIHZhbHVlOiBOdW1lcmljVmFsdWU7XHJcbiAgY29udmVyc2lvblJhdGU/OiBudW1iZXI7XHJcbiAgZnJvbURlbm9taW5hdGlvbj86IEV0aGVyRGVub21pbmF0aW9uO1xyXG4gIGZyb21DdXJyZW5jeT86IHN0cmluZztcclxuICBpbnZlcnRDb252ZXJzaW9uUmF0ZT86IGJvb2xlYW47XHJcbn0pIHtcclxuICBsZXQgbnVtZXJpYyA9IG5ldyBOdW1lcmljKHZhbHVlLCAxMCwgZnJvbURlbm9taW5hdGlvbik7XHJcbiAgaWYgKGZyb21DdXJyZW5jeSAhPT0gRXRoZXJEZW5vbWluYXRpb24uRVRIKSB7XHJcbiAgICBudW1lcmljID0gbnVtZXJpYy5hcHBseUNvbnZlcnNpb25SYXRlKGNvbnZlcnNpb25SYXRlLCBpbnZlcnRDb252ZXJzaW9uUmF0ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBudW1lcmljLnRvQmFzZSgxNikudG9EZW5vbWluYXRpb24oRXRoZXJEZW5vbWluYXRpb24uV0VJKS50b1N0cmluZygpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBCTiBvYmplY3QgdG8gYSBoZXggc3RyaW5nIHdpdGggYSAnMHgnIHByZWZpeFxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXRCbiAtIFRoZSBCTiB0byBjb252ZXJ0IHRvIGEgaGV4IHN0cmluZ1xyXG4gKiBAcmV0dXJucyBBICcweCcgcHJlZml4ZWQgaGV4IHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJuVG9IZXgoaW5wdXRCbjogQk4pIHtcclxuICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0Qm4udG9TdHJpbmcoMTYpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEV0aENvbnZlcnNpb25Gcm9tV2VpSGV4KHtcclxuICB2YWx1ZSxcclxuICBmcm9tQ3VycmVuY3kgPSBFdGhlckRlbm9taW5hdGlvbi5FVEgsXHJcbiAgY29udmVyc2lvblJhdGUsXHJcbiAgbnVtYmVyT2ZEZWNpbWFscyA9IDYsXHJcbn06IHtcclxuICB2YWx1ZTogTnVtZXJpY1ZhbHVlO1xyXG4gIGNvbnZlcnNpb25SYXRlPzogbnVtYmVyO1xyXG4gIGZyb21DdXJyZW5jeT86IEV0aGVyRGVub21pbmF0aW9uIHwgc3RyaW5nO1xyXG4gIG51bWJlck9mRGVjaW1hbHM/OiBudW1iZXI7XHJcbn0pIHtcclxuICBjb25zdCBkZW5vbWluYXRpb25zID0gW1xyXG4gICAgRXRoZXJEZW5vbWluYXRpb24uRVRILFxyXG4gICAgRXRoZXJEZW5vbWluYXRpb24uR1dFSSxcclxuICAgIEV0aGVyRGVub21pbmF0aW9uLldFSSxcclxuICBdO1xyXG5cclxuICBsZXQgbm9uWmVyb0Rlbm9taW5hdGlvbjtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZW5vbWluYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGdldFZhbHVlRnJvbVdlaUhleCh7XHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBjb252ZXJzaW9uUmF0ZSxcclxuICAgICAgZnJvbUN1cnJlbmN5LFxyXG4gICAgICB0b0N1cnJlbmN5OiBmcm9tQ3VycmVuY3ksXHJcbiAgICAgIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgICAgIHRvRGVub21pbmF0aW9uOiBkZW5vbWluYXRpb25zW2ldLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGNvbnZlcnRlZFZhbHVlICE9PSAnMCcgfHwgaSA9PT0gZGVub21pbmF0aW9ucy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIG5vblplcm9EZW5vbWluYXRpb24gPSBgJHtjb252ZXJ0ZWRWYWx1ZX0gJHtkZW5vbWluYXRpb25zW2ldfWA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5vblplcm9EZW5vbWluYXRpb247XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21XZWlIZXgoe1xyXG4gIHZhbHVlLFxyXG4gIGZyb21DdXJyZW5jeSA9IEV0aGVyRGVub21pbmF0aW9uLkVUSCxcclxuICB0b0N1cnJlbmN5LFxyXG4gIGNvbnZlcnNpb25SYXRlLFxyXG4gIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgdG9EZW5vbWluYXRpb24gPSBFdGhlckRlbm9taW5hdGlvbi5FVEgsXHJcbn06IHtcclxuICB2YWx1ZTogTnVtZXJpY1ZhbHVlO1xyXG4gIGZyb21DdXJyZW5jeT86IEV0aGVyRGVub21pbmF0aW9uIHwgc3RyaW5nO1xyXG4gIHRvQ3VycmVuY3k/OiBFdGhlckRlbm9taW5hdGlvbiB8IHN0cmluZztcclxuICBjb252ZXJzaW9uUmF0ZT86IG51bWJlcjtcclxuICBudW1iZXJPZkRlY2ltYWxzPzogbnVtYmVyO1xyXG4gIHRvRGVub21pbmF0aW9uPzogRXRoZXJEZW5vbWluYXRpb247XHJcbn0pIHtcclxuICBsZXQgbnVtZXJpYyA9IG5ldyBOdW1lcmljKHZhbHVlLCAxNiwgRXRoZXJEZW5vbWluYXRpb24uV0VJKTtcclxuICBpZiAoZnJvbUN1cnJlbmN5ICE9PSB0b0N1cnJlbmN5KSB7XHJcbiAgICBudW1lcmljID0gbnVtZXJpYy5hcHBseUNvbnZlcnNpb25SYXRlKGNvbnZlcnNpb25SYXRlKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bWVyaWNcclxuICAgIC50b0Jhc2UoMTApXHJcbiAgICAudG9EZW5vbWluYXRpb24odG9EZW5vbWluYXRpb24pXHJcbiAgICAucm91bmQobnVtYmVyT2ZEZWNpbWFscywgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTilcclxuICAgIC50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VtSGV4ZXMoZmlyc3Q6IHN0cmluZywgLi4uYXJnczogc3RyaW5nW10pIHtcclxuICBjb25zdCBmaXJzdFZhbHVlID0gbmV3IE51bWVyaWMoZmlyc3QsIDE2KTtcclxuICBjb25zdCB0b3RhbCA9IGFyZ3MucmVkdWNlKFxyXG4gICAgKGFjYywgaGV4QW1vdW50KSA9PiBhY2MuYWRkKG5ldyBOdW1lcmljKGhleEFtb3VudCwgMTYpKSxcclxuICAgIGZpcnN0VmFsdWUsXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHRvdGFsLnRvUHJlZml4ZWRIZXhTdHJpbmcoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhleFdFSVRvRGVjR1dFSSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIHwgQmlnTnVtYmVyIHwgQk4pIHtcclxuICByZXR1cm4gbmV3IE51bWVyaWModmFsdWUsIDE2LCBFdGhlckRlbm9taW5hdGlvbi5XRUkpXHJcbiAgICAudG9CYXNlKDEwKVxyXG4gICAgLnRvRGVub21pbmF0aW9uKEV0aGVyRGVub21pbmF0aW9uLkdXRUkpXHJcbiAgICAudG9TdHJpbmcoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY2ltYWxUb0hleChkZWNpbWFsOiBudW1iZXIgfCBzdHJpbmcgfCBCaWdOdW1iZXIgfCBCTikge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhkZWNpbWFsLCAxMCkudG9CYXNlKDE2KS50b1N0cmluZygpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9EZWNpbWFsKGhleFZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBCaWdOdW1iZXIgfCBCTikge1xyXG4gIHJldHVybiBuZXcgTnVtZXJpYyhoZXhWYWx1ZSwgMTYpLnRvQmFzZSgxMCkudG9TdHJpbmcoKTtcclxufVxyXG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYW4gSFRUUCByZXF1ZXN0IGJ1dCB0aW1pbmcgb3V0XHJcbiAqIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYSBkZXNpcmVkIGFtb3VudCBvZiB0aW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGltZW91dCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWwgdGhlIHJlcXVlc3QgdGltZXNcclxuICogb3V0LlxyXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlc1xyXG4gKiB0byB0aGUgSFRUUCByZXNwb25zZSBvYmplY3Qgb3IgaXMgcmVqZWN0ZWQgaWYgYSBuZXR3b3JrIGVycm9yIGlzIGVuY291bnRlcmVkXHJcbiAqIG9yIHRoZSByZXF1ZXN0IHRpbWVzIG91dC5cclxuICovXHJcbmNvbnN0IGdldEZldGNoV2l0aFRpbWVvdXQgPSBtZW1vaXplKCh0aW1lb3V0ID0gU0VDT05EICogMzApID0+IHtcclxuICBpZiAoIU51bWJlci5pc0ludGVnZXIodGltZW91dCkgfHwgdGltZW91dCA8IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHBvc2l0aXZlIGludGVnZXIgdGltZW91dC4nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhUaW1lb3V0KFxyXG4gICAgdXJsOiBSZXF1ZXN0SW5mbyxcclxuICAgIG9wdHM/OiBSZXF1ZXN0SW5pdCxcclxuICApOiBQcm9taXNlPFJlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgd2luZG93LkFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgY29uc3QgeyBzaWduYWwgfSA9IGFib3J0Q29udHJvbGxlcjtcclxuICAgIGNvbnN0IGYgPSB3aW5kb3cuZmV0Y2godXJsLCB7XHJcbiAgICAgIC4uLm9wdHMsXHJcbiAgICAgIHNpZ25hbCxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGF3YWl0IGY7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0RmV0Y2hXaXRoVGltZW91dDtcclxuIiwiaW1wb3J0IHtcclxuICBpc0hleFN0cmluZyxcclxuICBpc1ZhbGlkQWRkcmVzcyxcclxuICBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzLFxyXG4gIGFkZEhleFByZWZpeCxcclxuICB0b0NoZWNrc3VtQWRkcmVzcyxcclxuICB6ZXJvQWRkcmVzcyxcclxuICBpc0hleFByZWZpeGVkLFxyXG59IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XHJcblxyXG5leHBvcnQgY29uc3QgQlVSTl9BRERSRVNTID0gemVyb0FkZHJlc3MoKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0J1cm5BZGRyZXNzKGFkZHJlc3M6IHN0cmluZykge1xyXG4gIHJldHVybiBhZGRyZXNzID09PSBCVVJOX0FERFJFU1M7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5SGV4U3RyaW5nKHZhbHVlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICByZXR1cm4gW1xyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgbnVsbCxcclxuICAgICcweCcsXHJcbiAgICAnMHgwJyxcclxuICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxyXG4gIF0uaW5jbHVkZXModmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGlucHV0IGlzIGEgaGV4IGFkZHJlc3MuIFRoaXMgdXRpbGl0eSBtZXRob2QgaXMgYSB0aGluXHJcbiAqIHdyYXBwZXIgYXJvdW5kIGV0aGVyZXVtanMtdXRpbC5pc1ZhbGlkQWRkcmVzcywgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaXRcclxuICogZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBwcm92aWRlZCB2YWx1ZXMgdGhhdCBhcmUgbm90IGhleCBzdHJpbmdzLiBJblxyXG4gKiBhZGRpdGlvbiwgYW5kIGJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRydWUgZm9yIGhleCBzdHJpbmdzIHRoYXRcclxuICogbWVldCB0aGUgbGVuZ3RoIHJlcXVpcmVtZW50IG9mIGEgaGV4IGFkZHJlc3MsIGJ1dCBhcmUgbm90IHByZWZpeGVkIHdpdGggYDB4YFxyXG4gKiBGaW5hbGx5LCBpZiB0aGUgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gZmxhZyBpcyB0cnVlIGFuZCBhIG1peGVkIGNhc2Ugc3RyaW5nIGlzXHJcbiAqIHByb3ZpZGVkIHRoaXMgbWV0aG9kIHdpbGwgdmFsaWRhdGUgaXQgaGFzIHRoZSBwcm9wZXIgY2hlY2tzdW0gZm9ybWF0dGluZy5cclxuICpcclxuICogQHBhcmFtIHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0XHJcbiAqIEBwYXJhbSBbb3B0aW9uc10gLSBvcHRpb25zIGJhZ1xyXG4gKiBAcGFyYW0gW29wdGlvbnMuYWxsb3dOb25QcmVmaXhlZF0gLSBJZiB0cnVlIHdpbGwgZmlyc3QgZW5zdXJlICcweCdcclxuICogaXMgcHJlcGVuZGVkIHRvIHRoZSBzdHJpbmdcclxuICogQHBhcmFtIFtvcHRpb25zLm1peGVkQ2FzZVVzZUNoZWNrc3VtXSAtIElmIHRydWUgd2lsbCB0cmVhdCBtaXhlZFxyXG4gKiBjYXNlIGFkZHJlc3NlcyBhcyBjaGVja3N1bSBhZGRyZXNzZXMgYW5kIHZhbGlkYXRlIHRoYXQgcHJvcGVyIGNoZWNrc3VtXHJcbiAqIGZvcm1hdCBpcyB1c2VkXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleEFkZHJlc3MoXHJcbiAgcG9zc2libGVBZGRyZXNzOiBzdHJpbmcsXHJcbiAgeyBhbGxvd05vblByZWZpeGVkID0gdHJ1ZSwgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gPSBmYWxzZSB9ID0ge30sXHJcbikge1xyXG4gIGNvbnN0IGFkZHJlc3NUb0NoZWNrID0gYWxsb3dOb25QcmVmaXhlZFxyXG4gICAgPyBhZGRIZXhQcmVmaXgocG9zc2libGVBZGRyZXNzKVxyXG4gICAgOiBwb3NzaWJsZUFkZHJlc3M7XHJcbiAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzVG9DaGVjaykpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChtaXhlZENhc2VVc2VDaGVja3N1bSkge1xyXG4gICAgY29uc3QgcHJlZml4UmVtb3ZlZCA9IGFkZHJlc3NUb0NoZWNrLnNsaWNlKDIpO1xyXG4gICAgY29uc3QgbG93ZXIgPSBwcmVmaXhSZW1vdmVkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCB1cHBlciA9IHByZWZpeFJlbW92ZWQudG9VcHBlckNhc2UoKTtcclxuICAgIGNvbnN0IGFsbE9uZUNhc2UgPSBwcmVmaXhSZW1vdmVkID09PSBsb3dlciB8fCBwcmVmaXhSZW1vdmVkID09PSB1cHBlcjtcclxuICAgIGlmICghYWxsT25lQ2FzZSkge1xyXG4gICAgICByZXR1cm4gaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzVG9DaGVjayk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzc1RvQ2hlY2spO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKSB7XHJcbiAgaWYgKCFhZGRyZXNzKSB7XHJcbiAgICAvLyBvdXIgaW50ZXJuYWwgY2hlY2tzdW1BZGRyZXNzIGZ1bmN0aW9uIHRoYXQgdGhpcyBtZXRob2QgcmVwbGFjZXMgd291bGRcclxuICAgIC8vIHJldHVybiBhbiBlbXB0eSBzdHJpbmcgZm9yIG51bGxpc2ggaW5wdXQuIElmIGFueSBkaXJlY3QgdXNhZ2VzIG9mXHJcbiAgICAvLyBldGhlcmV1bWpzLXV0aWwudG9DaGVja3N1bUFkZHJlc3Mgd2VyZSBjYWxsZWQgd2l0aCBudWxsaXNoIGlucHV0IGl0XHJcbiAgICAvLyB3b3VsZCBoYXZlIHJlc3VsdGVkIGluIGFuIGVycm9yIG9uIHZlcnNpb24gNS4xLlxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBjb25zdCBoZXhQcmVmaXhlZCA9IGFkZEhleFByZWZpeChhZGRyZXNzKTtcclxuICBpZiAoIWlzSGV4U3RyaW5nKGhleFByZWZpeGVkKSkge1xyXG4gICAgLy8gVmVyc2lvbiA1LjEgb2YgZXRoZXJldW1qcy11dGlscyB3b3VsZCBoYXZlIHJldHVybmVkICcweFknIGZvciBpbnB1dCAneSdcclxuICAgIC8vIGJ1dCB3ZSBzaG91bGRuJ3Qgd2FzdGUgZWZmb3J0IHRyeWluZyB0byBjaGFuZ2UgY2FzZSBvbiBhIGNsZWFybHkgaW52YWxpZFxyXG4gICAgLy8gc3RyaW5nLiBJbnN0ZWFkIGp1c3QgcmV0dXJuIHRoZSBoZXggcHJlZml4ZWQgb3JpZ2luYWwgc3RyaW5nIHdoaWNoIG1vc3RcclxuICAgIC8vIGNsb3NlbHkgbWltaWNzIHRoZSBvcmlnaW5hbCBiZWhhdmlvci5cclxuICAgIHJldHVybiBoZXhQcmVmaXhlZDtcclxuICB9XHJcbiAgcmV0dXJuIHRvQ2hlY2tzdW1BZGRyZXNzKGhleFByZWZpeGVkKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cjogc3RyaW5nKSB7XHJcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xyXG59XHJcbiIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgeyBKc29uIH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcclxuaW1wb3J0IGdldEZldGNoV2l0aFRpbWVvdXQgZnJvbSAnLi9mZXRjaC13aXRoLXRpbWVvdXQnO1xyXG5cclxuY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQoKTtcclxuXHJcbi8vIEZyb20gYXBwL19sb2NhbGVzIGZvbGRlcnMgdGhlcmUgaXMgYSBtZXNzYWdlcy5qc29uIGZpbGUgc3VjaCBhcyBhcHAvX2xvY2FsZXMvZW4sIGNvbWVzIHdpdGgga2V5IGFuZCB0cmFuc2xhdGVkIHJlc3VsdHNcclxuLy8gYW5kIHdlIHVzZSBhcyB0KCdyZWplY3QnKSB0byBnZXQgdGhlIHRyYW5zbGF0ZWQgbWVzc2FnZSBpbiB0aGUgY29kZWJhc2VcclxuLy8gYW5kIGluIGkxOG4gbGliLCB0aGUgdHJhbnNsYXRlZCBtZXNzYWdlIGlzIGFuIG9iamVjdCAoSTE4Tk1lc3NhZ2UpIHdpdGggbWVzc2FnZSAmIGRlc2NyaXB0aW9uIC1cclxuLy8gbWVzc2FnZSBpcyB0aGUgc3RyaW5nIHRoYXQgd2lsbCByZXBsYWNlIHRoZSB0cmFuc2xhdGlvbktleSwgYW5kIHRoYXQgbWVzc2FnZSBtYXkgY29udGFpbiByZXBsYWNlbWVudCB2YXJpYWJsZXMgc3VjaCBhcyAkMSwgJDIsIGV0Yy5cclxuLy8gRGVzY3JpcHRpb24gaXMga2V5IGRlc2NyaWJpbmcgdGhlIHVzYWdlIG9mIHRoZSBtZXNzYWdlLlxyXG5leHBvcnQgaW50ZXJmYWNlIEkxOE5NZXNzYWdlIHtcclxuICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIFRoZSBvdmVyYWxsIHRyYW5zbGF0aW9uIGZpbGUgaXMgbWFkZSBvZiBzYW1lIGVudHJpZXNcclxuLy8gdHJhbnNsYXRpb25LZXkgKHN0cmluZykgYW5kIHRoZSBJMThOTWVzc2FnZSBhcyB0aGUgdmFsdWUuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSTE4Tk1lc3NhZ2VEaWN0IHtcclxuICBbdHJhbnNsYXRpb25LZXk6IHN0cmluZ106IEkxOE5NZXNzYWdlO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBJMThOU3Vic3RpdHV0aW9uID0gc3RyaW5nIHwgKCgpID0+IGFueSkgfCBvYmplY3Q7XHJcblxyXG4vLyBBIHBhcmFtZXRlcml6ZWQgdHlwZSAob3IgZ2VuZXJpYyB0eXBlKSBvZiBtYXBzIHRoYXQgdXNlIHRoZSBzYW1lIHN0cnVjdHVyZSAodHJhbnNsYXRpb25LZXkpIGtleVxyXG5pbnRlcmZhY2UgSTE4Tk1lc3NhZ2VEaWN0TWFwPFI+IHtcclxuICBbdHJhbnNsYXRpb25LZXk6IHN0cmluZ106IFI7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBGQUxMQkFDS19MT0NBTEUgPSAnZW4nO1xyXG5cclxuY29uc3Qgd2FybmVkOiB7IFtsb2NhbGVDb2RlOiBzdHJpbmddOiBJMThOTWVzc2FnZURpY3RNYXA8Ym9vbGVhbj4gfSA9IHt9O1xyXG5cclxuY29uc3QgbWlzc2luZ01lc3NhZ2VFcnJvcnM6IEkxOE5NZXNzYWdlRGljdE1hcDxFcnJvcj4gPSB7fTtcclxuXHJcbmNvbnN0IG1pc3NpbmdTdWJzdGl0dXRpb25FcnJvcnM6IHtcclxuICBbbG9jYWxlQ29kZTogc3RyaW5nXTogSTE4Tk1lc3NhZ2VEaWN0TWFwPGJvb2xlYW4+O1xyXG59ID0ge307XHJcblxyXG5jb25zdCByZWxhdGl2ZVRpbWVGb3JtYXRMb2NhbGVEYXRhID0gbmV3IFNldCgpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBsb2NhbGl6ZWQgbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGtleVxyXG4gKlxyXG4gKiBAcGFyYW0gbG9jYWxlQ29kZSAtIFRoZSBjb2RlIGZvciB0aGUgY3VycmVudCBsb2NhbGVcclxuICogQHBhcmFtIGxvY2FsZU1lc3NhZ2VzIC0gVGhlIG1hcCBvZiBtZXNzYWdlcyBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgbWVzc2FnZSBrZXlcclxuICogQHBhcmFtIHN1YnN0aXR1dGlvbnMgLSBBIGxpc3Qgb2YgbWVzc2FnZSBzdWJzdGl0dXRpb24gcmVwbGFjZW1lbnRzIGNhbiByZXBsYWNlICRuIGluIGdpdmVuIG1lc3NhZ2VcclxuICogQHBhcmFtIG9uRXJyb3IgLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBwcm92aWRlIGFkZGl0aW9uYWwgcHJvY2Vzc2luZyBvbiBhbnkgZXJyb3JzXHJcbiAqIEBwYXJhbSBqb2luIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gam9pbiB0aGUgc3Vic3RpdHV0ZWQgcGFydHMgdXNpbmcgY3VzdG9tIGxvZ2ljXHJcbiAqIEByZXR1cm5zIFRoZSBsb2NhbGl6ZWQgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldE1lc3NhZ2UgPSA8VD4oXHJcbiAgbG9jYWxlQ29kZTogc3RyaW5nLFxyXG4gIGxvY2FsZU1lc3NhZ2VzOiBJMThOTWVzc2FnZURpY3QsXHJcbiAga2V5OiBzdHJpbmcsXHJcbiAgc3Vic3RpdHV0aW9ucz86IEkxOE5TdWJzdGl0dXRpb25bXSxcclxuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZCxcclxuICBqb2luPzogKHN1YnN0aXR1dGVkUGFydHM6IEkxOE5TdWJzdGl0dXRpb25bXSkgPT4gVCxcclxuKTogVCB8IHN0cmluZyB8IG51bGwgPT4ge1xyXG4gIGlmICghbG9jYWxlTWVzc2FnZXMpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbWVzc2FnZSA9IGxvY2FsZU1lc3NhZ2VzW2tleV07XHJcblxyXG4gIGlmICghbWVzc2FnZSkge1xyXG4gICAgbWlzc2luZ0tleUVycm9yKGtleSwgbG9jYWxlQ29kZSwgb25FcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRleHQgPSBtZXNzYWdlLm1lc3NhZ2U7XHJcblxyXG4gIGNvbnN0IHBhcnRzID0gaGFzU3Vic3RpdHV0aW9ucyhzdWJzdGl0dXRpb25zKVxyXG4gICAgPyBhcHBseVN1YnN0aXR1dGlvbnMoXHJcbiAgICAgICAgdGV4dCxcclxuICAgICAgICBzdWJzdGl0dXRpb25zIGFzIEkxOE5TdWJzdGl0dXRpb25bXSxcclxuICAgICAgICBrZXksXHJcbiAgICAgICAgbG9jYWxlQ29kZSxcclxuICAgICAgICBvbkVycm9yLFxyXG4gICAgICApXHJcbiAgICA6IFt0ZXh0XTtcclxuXHJcbiAgcmV0dXJuIGpvaW4gPyBqb2luKHBhcnRzKSA6IHBhcnRzLmpvaW4oJycpO1xyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTG9jYWxlKFxyXG4gIGxvY2FsZUNvZGU6IHN0cmluZyxcclxuKTogUHJvbWlzZTxJMThOTWVzc2FnZURpY3Q+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KFxyXG4gICAgICBgLi9fbG9jYWxlcy8ke2xvY2FsZUNvZGV9L21lc3NhZ2VzLmpzb25gLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZy5lcnJvcihgZmFpbGVkIHRvIGZldGNoICR7bG9jYWxlQ29kZX0gbG9jYWxlIGJlY2F1c2Ugb2YgJHtlcnJvcn1gKTtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUmVsYXRpdmVUaW1lRm9ybWF0TG9jYWxlRGF0YShcclxuICBsb2NhbGVDb2RlOiBzdHJpbmcsXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IGxhbmd1YWdlVGFnID0gbG9jYWxlQ29kZS5zcGxpdCgnXycpWzBdO1xyXG4gIGlmIChcclxuICAgIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0ICYmXHJcbiAgICB0eXBlb2YgKEludGwuUmVsYXRpdmVUaW1lRm9ybWF0IGFzIGFueSkuX19hZGRMb2NhbGVEYXRhID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAhcmVsYXRpdmVUaW1lRm9ybWF0TG9jYWxlRGF0YS5oYXMobGFuZ3VhZ2VUYWcpXHJcbiAgKSB7XHJcbiAgICBjb25zdCBsb2NhbGVEYXRhID0gYXdhaXQgZmV0Y2hSZWxhdGl2ZVRpbWVGb3JtYXREYXRhKGxhbmd1YWdlVGFnKTtcclxuICAgIChJbnRsLlJlbGF0aXZlVGltZUZvcm1hdCBhcyBhbnkpLl9fYWRkTG9jYWxlRGF0YShsb2NhbGVEYXRhKTtcclxuICAgIHJlbGF0aXZlVGltZUZvcm1hdExvY2FsZURhdGEuYWRkKGxhbmd1YWdlVGFnKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhY2hlcygpIHtcclxuICBPYmplY3Qua2V5cyh3YXJuZWQpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgZGVsZXRlIHdhcm5lZFtrZXldO1xyXG4gIH0pO1xyXG5cclxuICBPYmplY3Qua2V5cyhtaXNzaW5nTWVzc2FnZUVycm9ycykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICBkZWxldGUgbWlzc2luZ01lc3NhZ2VFcnJvcnNba2V5XTtcclxuICB9KTtcclxuXHJcbiAgT2JqZWN0LmtleXMobWlzc2luZ1N1YnN0aXR1dGlvbkVycm9ycykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICBkZWxldGUgbWlzc2luZ1N1YnN0aXR1dGlvbkVycm9yc1trZXldO1xyXG4gIH0pO1xyXG5cclxuICByZWxhdGl2ZVRpbWVGb3JtYXRMb2NhbGVEYXRhLmNsZWFyKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5U3Vic3RpdHV0aW9ucyhcclxuICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgc3Vic3RpdHV0aW9uczogSTE4TlN1YnN0aXR1dGlvbltdLFxyXG4gIGtleTogc3RyaW5nLFxyXG4gIGxvY2FsZUNvZGU6IHN0cmluZyxcclxuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZCxcclxuKTogSTE4TlN1YnN0aXR1dGlvbltdIHtcclxuICBjb25zdCBwYXJ0cyA9IG1lc3NhZ2Uuc3BsaXQoLyhcXCRcXGQpL2d1KTtcclxuXHJcbiAgcmV0dXJuIHBhcnRzLm1hcCgocGFydDogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCBzdWJNYXRjaCA9IHBhcnQubWF0Y2goL1xcJChcXGQpL3UpO1xyXG5cclxuICAgIGlmICghc3ViTWF0Y2gpIHtcclxuICAgICAgcmV0dXJuIHBhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3Vic3RpdHV0ZUluZGV4ID0gTnVtYmVyKHN1Yk1hdGNoWzFdKSAtIDE7XHJcbiAgICBjb25zdCBzdWJzdGl0dXRpb24gPSBzdWJzdGl0dXRpb25zW3N1YnN0aXR1dGVJbmRleF07XHJcblxyXG4gICAgaWYgKHN1YnN0aXR1dGlvbiA9PT0gbnVsbCB8fCBzdWJzdGl0dXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3Ioa2V5LCBsb2NhbGVDb2RlLCBvbkVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3Vic3RpdHV0aW9ucz8uW3N1YnN0aXR1dGVJbmRleF07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1pc3NpbmdLZXlFcnJvcihcclxuICBrZXk6IHN0cmluZyxcclxuICBsb2NhbGVDb2RlOiBzdHJpbmcsXHJcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQsXHJcbikge1xyXG4gIGlmIChsb2NhbGVDb2RlID09PSBGQUxMQkFDS19MT0NBTEUgJiYgIW1pc3NpbmdNZXNzYWdlRXJyb3JzW2tleV0pIHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxyXG4gICAgICBgVW5hYmxlIHRvIGZpbmQgdmFsdWUgb2Yga2V5IFwiJHtrZXl9XCIgZm9yIGxvY2FsZSBcIiR7bG9jYWxlQ29kZX1cImAsXHJcbiAgICApO1xyXG5cclxuICAgIG1pc3NpbmdNZXNzYWdlRXJyb3JzW2tleV0gPSBlcnJvcjtcclxuXHJcbiAgICBvbkVycm9yPy4oZXJyb3IpO1xyXG4gICAgbG9nLmVycm9yKGVycm9yKTtcclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuSU5fVEVTVCkge1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChsb2NhbGVDb2RlID09PSBGQUxMQkFDS19MT0NBTEUgfHwgd2FybmVkW2xvY2FsZUNvZGVdPy5ba2V5XSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgd2FybmVkW2xvY2FsZUNvZGVdID0gd2FybmVkW2xvY2FsZUNvZGVdID8/IHt9O1xyXG4gIHdhcm5lZFtsb2NhbGVDb2RlXVtrZXldID0gdHJ1ZTtcclxuXHJcbiAgbG9nLndhcm4oXHJcbiAgICBgVHJhbnNsYXRvciAtIFVuYWJsZSB0byBmaW5kIHZhbHVlIG9mIGtleSBcIiR7a2V5fVwiIGZvciBsb2NhbGUgXCIke2xvY2FsZUNvZGV9XCJgLFxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1pc3NpbmdTdWJzdGl0dXRpb25FcnJvcihcclxuICBrZXk6IHN0cmluZyxcclxuICBsb2NhbGVDb2RlOiBzdHJpbmcsXHJcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQsXHJcbikge1xyXG4gIGlmIChtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3JzW2xvY2FsZUNvZGVdPy5ba2V5XSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbWlzc2luZ1N1YnN0aXR1dGlvbkVycm9yc1tsb2NhbGVDb2RlXSA9XHJcbiAgICBtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3JzW2xvY2FsZUNvZGVdID8/IHt9O1xyXG5cclxuICBtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3JzW2xvY2FsZUNvZGVdW2tleV0gPSB0cnVlO1xyXG5cclxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcclxuICAgIGBJbnN1ZmZpY2llbnQgbnVtYmVyIG9mIHN1YnN0aXR1dGlvbnMgZm9yIGtleSBcIiR7a2V5fVwiIHdpdGggbG9jYWxlIFwiJHtsb2NhbGVDb2RlfVwiYCxcclxuICApO1xyXG5cclxuICBsb2cuZXJyb3IoZXJyb3IpO1xyXG5cclxuICBvbkVycm9yPy4oZXJyb3IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNTdWJzdGl0dXRpb25zKHN1YnN0aXR1dGlvbnM/OiBJMThOU3Vic3RpdHV0aW9uW10pIHtcclxuICByZXR1cm4gKHN1YnN0aXR1dGlvbnM/Lmxlbmd0aCA/PyAwKSA+IDA7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVsYXRpdmVUaW1lRm9ybWF0RGF0YShsYW5ndWFnZVRhZzogc3RyaW5nKTogUHJvbWlzZTxKc29uPiB7XHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KFxyXG4gICAgYC4vaW50bC8ke2xhbmd1YWdlVGFnfS9yZWxhdGl2ZS10aW1lLWZvcm1hdC1kYXRhLmpzb25gLFxyXG4gICk7XHJcbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxufVxyXG4iLCJpbXBvcnQgYnJvd3NlciBmcm9tICd3ZWJleHRlbnNpb24tcG9seWZpbGwnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzTWFuaWZlc3RWMyA9XHJcbiAgYnJvd3Nlci5ydW50aW1lLmdldE1hbmlmZXN0KCkubWFuaWZlc3RfdmVyc2lvbiA9PT0gMztcclxuIiwiaW1wb3J0IHsgQ0hBSU5fSURTLCBNQVhfU0FGRV9DSEFJTl9JRCB9IGZyb20gJy4uL2NvbnN0YW50cy9uZXR3b3JrJztcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbnVtYmVyIHByaW1pdGl2ZSBjaGFpbiBJRCBpcyBzYWZlLlxyXG4gKiBCZWNhdXNlIHNvbWUgY3J5cHRvZ3JhcGhpYyBsaWJyYXJpZXMgd2UgdXNlIGV4cGVjdCB0aGUgY2hhaW4gSUQgdG8gYmUgYVxyXG4gKiBudW1iZXIgcHJpbWl0aXZlLCBpdCBtdXN0IG5vdCBleGNlZWQgYSBjZXJ0YWluIHNpemUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGNoYWluIElEIHRvIGNoZWNrIGZvciBzYWZldHkuXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNoYWluIElEIGlzIHNhZmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZlQ2hhaW5JZChjaGFpbklkOiB1bmtub3duKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIGlzU2FmZUludGVnZXIoY2hhaW5JZCkgJiYgY2hhaW5JZCA+IDAgJiYgY2hhaW5JZCA8PSBNQVhfU0FGRV9DSEFJTl9JRDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIDB4LXByZWZpeGVkLCBub24temVybywgbm9uLXplcm8tcGFkZGVkLFxyXG4gKiBoZXhhZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBjb3JyZWN0bHkgZm9ybWF0dGVkIGhleCBzdHJpbmcsXHJcbiAqIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nKHZhbHVlOiB1bmtub3duKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIC9eMHhbMS05YS1mXStbMC05YS1mXSokL2l1LnRlc3QodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdG9rZW4gZGV0ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIGNlcnRhaW4gbmV0d29ya3NcclxuICpcclxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbklEIG9mIG5ldHdvcmtcclxuICogQHJldHVybnMgV2hldGhlciB0aGUgY3VycmVudCBuZXR3b3JrIHN1cHBvcnRzIHRva2VuIGRldGVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5EZXRlY3Rpb25FbmFibGVkRm9yTmV0d29yayhjaGFpbklkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcclxuICBzd2l0Y2ggKGNoYWluSWQpIHtcclxuICAgIGNhc2UgQ0hBSU5fSURTLk1BSU5ORVQ6XHJcbiAgICBjYXNlIENIQUlOX0lEUy5CU0M6XHJcbiAgICBjYXNlIENIQUlOX0lEUy5QT0xZR09OOlxyXG4gICAgY2FzZSBDSEFJTl9JRFMuQVZBTEFOQ0hFOlxyXG4gICAgY2FzZSBDSEFJTl9JRFMuQVVST1JBOlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaWtlIHtAbGluayBOdW1iZXIuaXNTYWZlSW50ZWdlcn0sIGJ1dCB0eXBlcyB0aGUgaW5wdXQgYXMgYSBgbnVtYmVyYCBpZiBpdCBpc1xyXG4gKiBpbmRlZWQgYSBzYWZlIGludGVnZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzYWZlIGludGVnZXIsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xyXG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRTaG93TGluZWFNYWlubmV0KCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IERhdGUuVVRDKDIwMjMsIDYsIDExLCAxOCk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIFJldHVybiBhIFwibWFza2VkXCIgY29weSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGluY2x1ZGVzIG9ubHkgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBpbiB0aGUgbWFzay4gVGhlXHJcbiAqIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbWlycm9ycyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBvYmplY3QsIGV4Y2VwdFxyXG4gKiB0aGUgb25seSB2YWx1ZXMgYXJlIGB0cnVlYCBvciBhIHN1Yi1tYXNrLiBgdHJ1ZWAgaW1wbGllcyB0aGUgcHJvcGVydHlcclxuICogc2hvdWxkIGJlIGluY2x1ZGVkLCBhbmQgYSBzdWItbWFzayBpbXBsaWVzIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgZnVydGhlclxyXG4gKiBtYXNrZWQgYWNjb3JkaW5nIHRvIHRoYXQgc3ViLW1hc2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1hc2tcclxuICogQHBhcmFtIHtPYmplY3Q8b2JqZWN0IHwgYm9vbGVhbj59IG1hc2sgLSBUaGUgbWFzayB0byBhcHBseSB0byB0aGUgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFza09iamVjdChvYmplY3QsIG1hc2spIHtcclxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5yZWR1Y2UoKHN0YXRlLCBrZXkpID0+IHtcclxuICAgIGlmIChtYXNrW2tleV0gPT09IHRydWUpIHtcclxuICAgICAgc3RhdGVba2V5XSA9IG9iamVjdFtrZXldO1xyXG4gICAgfSBlbHNlIGlmIChtYXNrW2tleV0pIHtcclxuICAgICAgc3RhdGVba2V5XSA9IG1hc2tPYmplY3Qob2JqZWN0W2tleV0sIG1hc2tba2V5XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfSwge30pO1xyXG59XHJcbiIsImNvbnN0IE1BWCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG5cclxubGV0IGlkQ291bnRlciA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1BWCk7XHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVJhbmRvbUlkKCkge1xyXG4gIGlkQ291bnRlciAlPSBNQVg7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBsdXNwbHVzXHJcbiAgcmV0dXJuIGlkQ291bnRlcisrO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDb21wYXJlIDIgZ2l2ZW4gc3RyaW5ncyBhbmQgcmV0dXJuIGJvb2xlYW5cclxuICogZWc6IFwiZm9vXCIgYW5kIFwiRk9PXCIgPT4gdHJ1ZVxyXG4gKiBlZzogXCJmb29cIiBhbmQgXCJiYXJcIiA9PiBmYWxzZVxyXG4gKiBlZzogXCJmb29cIiBhbmQgMTIzID0+IGZhbHNlXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZTEgLSBmaXJzdCBzdHJpbmcgdG8gY29tcGFyZVxyXG4gKiBAcGFyYW0gdmFsdWUyIC0gZmlyc3Qgc3RyaW5nIHRvIGNvbXBhcmVcclxuICogQHJldHVybnMgdHJ1ZSBpZiAyIHN0cmluZ3MgYXJlIGlkZW50aWNhbCB3aGVuIHRoZXkgYXJlIGxvd2VyY2FzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUoXHJcbiAgdmFsdWUxOiBzdHJpbmcsXHJcbiAgdmFsdWUyOiBzdHJpbmcsXHJcbik6IGJvb2xlYW4ge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUxICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUyICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWUxLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlMi50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogVGFrZXMgYSBudW1iZXIgd2l0aCBtYXggbGVuZ3RoIHVudGlsIHRoZSByZXN1bHRpbmcgc3RyaW5nIHJlYWNoZXMgdGhlIGdpdmVuIGxlbmd0aFxyXG4gKlxyXG4gKiBAcGFyYW0gbnVtXHJcbiAqIEBwYXJhbSBtYXhMZW5ndGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmVwZW5kWmVybyhudW06IG51bWJlciwgbWF4TGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIHJldHVybiBudW0udG9TdHJpbmcoKS5wYWRTdGFydChtYXhMZW5ndGgsICcwJyk7XHJcbn1cclxuIiwiaW1wb3J0IHsgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUCB9IGZyb20gJy4uL2NvbnN0YW50cy9zd2Fwcyc7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGFkZHJlc3MgaXMgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGFkZHJlc3MgZm9yXHJcbiAqIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIG9mIHRoZSBwcm92aWRlZCBjaGFpbi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUgdG8gdGhlIGRlZmF1bHQgdG9rZW4gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBoZXggZW5jb2RlZCBjaGFpbiBJRCBvZiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYWRkcmVzcyBpcyB0aGUgcHJvdmlkZWQgY2hhaW4ncyBkZWZhdWx0IHRva2VuIGFkZHJlc3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N3YXBzRGVmYXVsdFRva2VuQWRkcmVzcyhhZGRyZXNzLCBjaGFpbklkKSB7XHJcbiAgaWYgKCFhZGRyZXNzIHx8ICFjaGFpbklkKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYWRkcmVzcyA9PT0gU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUFtjaGFpbklkXT8uYWRkcmVzcztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzeW1ib2wgaXMgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIHN5bWJvbCBmb3JcclxuICogdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gb2YgdGhlIHByb3ZpZGVkIGNoYWluLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIC0gVGhlIHN0cmluZyB0byBjb21wYXJlIHRvIHRoZSBkZWZhdWx0IHRva2VuIHN5bWJvbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBoZXggZW5jb2RlZCBjaGFpbiBJRCBvZiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3ltYmwgaXMgdGhlIHByb3ZpZGVkIGNoYWluJ3MgZGVmYXVsdCB0b2tlbiBzeW1ib2xcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N3YXBzRGVmYXVsdFRva2VuU3ltYm9sKHN5bWJvbCwgY2hhaW5JZCkge1xyXG4gIGlmICghc3ltYm9sIHx8ICFjaGFpbklkKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3ltYm9sID09PSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5zeW1ib2w7XHJcbn1cclxuIiwiaW1wb3J0IHsgaXNIZXhTdHJpbmcgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xyXG5pbXBvcnQgeyBJbnRlcmZhY2UgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9hYmknO1xyXG5pbXBvcnQgeyBhYmlFUkM3MjEsIGFiaUVSQzIwLCBhYmlFUkMxMTU1IH0gZnJvbSAnQG1ldGFtYXNrL21ldGFtYXNrLWV0aC1hYmlzJztcclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCB7XHJcbiAgQXNzZXRUeXBlLFxyXG4gIFRva2VuU3RhbmRhcmQsXHJcbiAgVHJhbnNhY3Rpb25UeXBlLFxyXG59IGZyb20gJy4uL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcbmltcG9ydCB7IHJlYWRBZGRyZXNzQXNDb250cmFjdCB9IGZyb20gJy4vY29udHJhY3QtdXRpbHMnO1xyXG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi9zdHJpbmctdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsgJ3RyYW5zZmVyJyB8ICdhcHByb3ZlJyB8ICdzZXRhcHByb3ZhbGZvcmFsbCcgfCAndHJhbnNmZXJmcm9tJyB8ICdjb250cmFjdEludGVyYWN0aW9uJ3wgJ3NpbXBsZVNlbmQnIH0gSW5mZXJyYWJsZVRyYW5zYWN0aW9uVHlwZXNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gSW5mZXJUcmFuc2FjdGlvblR5cGVSZXN1bHRcclxuICogQHByb3BlcnR5IHtJbmZlcnJhYmxlVHJhbnNhY3Rpb25UeXBlc30gdHlwZSAtIFRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnZXRDb2RlUmVzcG9uc2UgLSBUaGUgY29udHJhY3QgY29kZSwgaW4gaGV4IGZvcm1hdCBpZlxyXG4gKiAgaXQgZXhpc3RzLiAnMHgwJyBvciAnMHgnIGFyZSBhbHNvIGluZGljYXRvcnMgb2Ygbm9uLWV4aXN0ZW50IGNvbnRyYWN0XHJcbiAqICBjb2RlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIEV0aGVyc0NvbnRyYWN0Q2FsbFxyXG4gKiBAdHlwZSBvYmplY3RcclxuICogQHByb3BlcnR5IHthbnlbXX0gYXJncyAtIFRoZSBhcmdzL3BhcmFtcyB0byB0aGUgZnVuY3Rpb24gY2FsbC5cclxuICogQW4gYXJyYXktbGlrZSBvYmplY3Qgd2l0aCBudW1lcmljYWwgYW5kIHN0cmluZyBpbmRpY2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ25hdHVyZSAtIFRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaWdoYXNoIC0gVGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXNoLlxyXG4gKiBAcHJvcGVydHkge0V0aGVyc0JpZ051bWJlcn0gdmFsdWUgLSBUaGUgRVRIIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsbC5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbkZyYWdtZW50fSBmdW5jdGlvbkZyYWdtZW50IC0gVGhlIEV0aGVycyBmdW5jdGlvbiBmcmFnbWVudFxyXG4gKiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuY29uc3QgZXJjMjBJbnRlcmZhY2UgPSBuZXcgSW50ZXJmYWNlKGFiaUVSQzIwKTtcclxuY29uc3QgZXJjNzIxSW50ZXJmYWNlID0gbmV3IEludGVyZmFjZShhYmlFUkM3MjEpO1xyXG5jb25zdCBlcmMxMTU1SW50ZXJmYWNlID0gbmV3IEludGVyZmFjZShhYmlFUkMxMTU1KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrKHRyYW5zYWN0aW9uLCBjaGFpbklkLCBuZXR3b3JrSWQpIHtcclxuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmNoYWluSWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uY2hhaW5JZCA9PT0gY2hhaW5JZDtcclxuICB9XHJcbiAgcmV0dXJuIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID09PSBuZXR3b3JrSWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIGZpZWxkcyBhcmUgc3VwcGxpZWRcclxuICogYW5kIHZhbGlkIGlucHV0cy4gVGhpcyB3aWxsIHJldHVybiBmYWxzZSBmb3Igbm9uIGhleCBzdHJpbmcgaW5wdXRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbnN0YW50cy90cmFuc2FjdGlvblwiKS5UcmFuc2FjdGlvbk1ldGF9IHRyYW5zYWN0aW9uIC1cclxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0cmFuc2FjdGlvbiB1c2VzIHZhbGlkIEVJUDE1NTkgZmllbGRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNFSVAxNTU5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICByZXR1cm4gKFxyXG4gICAgaXNIZXhTdHJpbmcodHJhbnNhY3Rpb24/LnR4UGFyYW1zPy5tYXhGZWVQZXJHYXMpICYmXHJcbiAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbj8udHhQYXJhbXM/Lm1heFByaW9yaXR5RmVlUGVyR2FzKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgaWYgdGhlIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgZmllbGRzIGFyZSBub3RcclxuICogc3VwcGxpZWQgYW5kIHRoYXQgdGhlIGdhc1ByaWNlIGZpZWxkIGlzIHZhbGlkIGlmIGl0IGlzIHByb3ZpZGVkLiBUaGlzIHdpbGxcclxuICogcmV0dXJuIGZhbHNlIGlmIGdhc1ByaWNlIGlzIGEgbm9uIGhleCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxyXG4gKiAgdGhlIHRyYW5zYWN0aW9uIHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRyYW5zYWN0aW9uIHVzZXMgdmFsaWQgTGVnYWN5IGZpZWxkcyBPUiBsYWNrc1xyXG4gKiAgRUlQMTU1OSBmaWVsZHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xlZ2FjeVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIHR5cGVvZiB0cmFuc2FjdGlvbi50eFBhcmFtcy5tYXhGZWVQZXJHYXMgPT09ICd1bmRlZmluZWQnICYmXHJcbiAgICB0eXBlb2YgdHJhbnNhY3Rpb24udHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAodHlwZW9mIHRyYW5zYWN0aW9uLnR4UGFyYW1zLmdhc1ByaWNlID09PSAndW5kZWZpbmVkJyB8fFxyXG4gICAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbi50eFBhcmFtcy5nYXNQcmljZSkpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBpZiBhIHRyYW5zYWN0aW9ucyBnYXMgZmVlcyBpbiB0eFBhcmFtcyBtYXRjaCB0aG9zZSBpbiBpdHMgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgcHJvcGVydHlcclxuICpcclxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb25zdGFudHMvdHJhbnNhY3Rpb25cIikuVHJhbnNhY3Rpb25NZXRhfSB0cmFuc2FjdGlvbiAtXHJcbiAqICB0aGUgdHJhbnNhY3Rpb24gdG8gY2hlY2tcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYm90aCB0aGUgdHhQYXJhbXMgYW5kIGRhcHBTdWdnZXN0ZWRHYXNGZWVzIGFyZSBvYmplY3RzIHdpdGggdHJ1dGh5IGdhcyBmZWUgcHJvcGVydGllcyxcclxuICogICBhbmQgdGhvc2UgcHJvcGVydGllcyBhcmUgc3RyaWN0bHkgZXF1YWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0eFBhcmFtc0FyZURhcHBTdWdnZXN0ZWQodHJhbnNhY3Rpb24pIHtcclxuICBjb25zdCB7IGdhc1ByaWNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzIH0gPVxyXG4gICAgdHJhbnNhY3Rpb24/LnR4UGFyYW1zIHx8IHt9O1xyXG4gIHJldHVybiAoXHJcbiAgICAoZ2FzUHJpY2UgJiYgZ2FzUHJpY2UgPT09IHRyYW5zYWN0aW9uPy5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8uZ2FzUHJpY2UpIHx8XHJcbiAgICAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcclxuICAgICAgbWF4RmVlUGVyR2FzICYmXHJcbiAgICAgIHRyYW5zYWN0aW9uPy5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8ubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09XHJcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcclxuICAgICAgdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5tYXhGZWVQZXJHYXMgPT09IG1heEZlZVBlckdhcylcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZGVjb2RlIHRyYW5zYWN0aW9uIGRhdGEgdXNpbmcgQUJJcyBmb3IgdGhyZWUgZGlmZmVyZW50IHRva2VuIHN0YW5kYXJkczogRVJDMjAsIEVSQzcyMSwgRVJDMTE1NS5cclxuICogVGhlIGRhdGEgd2lsbCBkZWNvZGUgY29ycmVjdGx5IGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbnRlcmFjdGlvbiB3aXRoIGEgY29udHJhY3QgdGhhdCBtYXRjaGVzIG9uZSBvZiB0aGVzZVxyXG4gKiBjb250cmFjdCBzdGFuZGFyZHNcclxuICpcclxuICogQHBhcmFtIGRhdGEgLSBlbmNvZGVkIHRyYW5zYWN0aW9uIGRhdGFcclxuICogQHJldHVybnMge0V0aGVyc0NvbnRyYWN0Q2FsbCB8IHVuZGVmaW5lZH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEoZGF0YSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZXJjMjBJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICAvLyBpZ25vcmUgYW5kIG5leHQgdHJ5IHRvIHBhcnNlIHdpdGggZXJjNzIxIEFCSVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBlcmM3MjFJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICAvLyBpZ25vcmUgYW5kIG5leHQgdHJ5IHRvIHBhcnNlIHdpdGggZXJjMTE1NSBBQklcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZXJjMTE1NUludGVyZmFjZS5wYXJzZVRyYW5zYWN0aW9uKHsgZGF0YSB9KTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIGlnbm9yZSBhbmQgcmV0dXJuIHVuZGVmaW5lZFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgdGhlIGNvbnRyYWN0Q29kZSBvZiB0aGUgdHJhbnNhY3Rpb24gYnkgYW5hbHl6aW5nIHRoZSB0eFBhcmFtcy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHR4UGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcclxuICogQHJldHVybnMge0luZmVyVHJhbnNhY3Rpb25UeXBlUmVzdWx0fVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uQ29udHJhY3RDb2RlKHR4UGFyYW1zLCBxdWVyeSkge1xyXG4gIGNvbnN0IHsgdG8gfSA9IHR4UGFyYW1zO1xyXG4gIGNvbnN0IHsgY29udHJhY3RDb2RlIH0gPSBhd2FpdCByZWFkQWRkcmVzc0FzQ29udHJhY3QocXVlcnksIHRvKTtcclxuICByZXR1cm4gY29udHJhY3RDb2RlO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0aGUgdHJhbnNhY3Rpb24gYnkgYW5hbHl6aW5nIHRoZSB0eFBhcmFtcy5cclxuICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gb25lIG9mIHRoZSB0eXBlcyBkZWZpbmVkIGluIHNoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb25zXHJcbiAqIEl0IHdpbGwgbmV2ZXIgcmV0dXJuIFRSQU5TQUNUSU9OX1RZUEVfQ0FOQ0VMIG9yIFRSQU5TQUNUSU9OX1RZUEVfUkVUUlkgYXMgdGhlc2VcclxuICogcmVwcmVzZW50IHNwZWNpZmljIGV2ZW50cyB0aGF0IHdlIGNvbnRyb2wgZnJvbSB0aGUgZXh0ZW5zaW9uIGFuZCBhcmUgYWRkZWQgbWFudWFsbHlcclxuICogYXQgdHJhbnNhY3Rpb24gY3JlYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eFBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge0V0aFF1ZXJ5fSBxdWVyeSAtIEV0aFF1ZXJ5IGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHtJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdH1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVUcmFuc2FjdGlvblR5cGUodHhQYXJhbXMsIHF1ZXJ5KSB7XHJcbiAgY29uc3QgeyBkYXRhLCB0byB9ID0gdHhQYXJhbXM7XHJcbiAgbGV0IG5hbWU7XHJcbiAgdHJ5IHtcclxuICAgICh7IG5hbWUgfSA9IGRhdGEgJiYgcGFyc2VTdGFuZGFyZFRva2VuVHJhbnNhY3Rpb25EYXRhKGRhdGEpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nLmRlYnVnKCdGYWlsZWQgdG8gcGFyc2UgdHJhbnNhY3Rpb24gZGF0YS4nLCBlcnJvciwgZGF0YSk7XHJcbiAgfVxyXG5cclxuICBsZXQgcmVzdWx0O1xyXG4gIGxldCBjb250cmFjdENvZGU7XHJcblxyXG4gIGlmIChkYXRhICYmICF0bykge1xyXG4gICAgcmVzdWx0ID0gVHJhbnNhY3Rpb25UeXBlLmRlcGxveUNvbnRyYWN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB7IGNvbnRyYWN0Q29kZTogcmVzdWx0Q29kZSwgaXNDb250cmFjdEFkZHJlc3MgfSA9XHJcbiAgICAgIGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChxdWVyeSwgdG8pO1xyXG5cclxuICAgIGNvbnRyYWN0Q29kZSA9IHJlc3VsdENvZGU7XHJcblxyXG4gICAgaWYgKGlzQ29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgIGNvbnN0IGhhc1ZhbHVlID0gdHhQYXJhbXMudmFsdWUgJiYgTnVtYmVyKHR4UGFyYW1zLnZhbHVlKSAhPT0gMDtcclxuXHJcbiAgICAgIGNvbnN0IHRva2VuTWV0aG9kTmFtZSA9IFtcclxuICAgICAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RBcHByb3ZlLFxyXG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFNldEFwcHJvdmFsRm9yQWxsLFxyXG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFRyYW5zZmVyLFxyXG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFRyYW5zZmVyRnJvbSxcclxuICAgICAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RTYWZlVHJhbnNmZXJGcm9tLFxyXG4gICAgICBdLmZpbmQoKG1ldGhvZE5hbWUpID0+IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUobWV0aG9kTmFtZSwgbmFtZSkpO1xyXG5cclxuICAgICAgcmVzdWx0ID1cclxuICAgICAgICBkYXRhICYmIHRva2VuTWV0aG9kTmFtZSAmJiAhaGFzVmFsdWVcclxuICAgICAgICAgID8gdG9rZW5NZXRob2ROYW1lXHJcbiAgICAgICAgICA6IFRyYW5zYWN0aW9uVHlwZS5jb250cmFjdEludGVyYWN0aW9uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0ID0gVHJhbnNhY3Rpb25UeXBlLnNpbXBsZVNlbmQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyB0eXBlOiByZXN1bHQsIGdldENvZGVSZXNwb25zZTogY29udHJhY3RDb2RlIH07XHJcbn1cclxuXHJcbmNvbnN0IElORkVSUkFCTEVfVFJBTlNBQ1RJT05fVFlQRVMgPSBbXHJcbiAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kQXBwcm92ZSxcclxuICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RTZXRBcHByb3ZhbEZvckFsbCxcclxuICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RUcmFuc2ZlcixcclxuICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RUcmFuc2ZlckZyb20sXHJcbiAgVHJhbnNhY3Rpb25UeXBlLmNvbnRyYWN0SW50ZXJhY3Rpb24sXHJcbiAgVHJhbnNhY3Rpb25UeXBlLnNpbXBsZVNlbmQsXHJcbl07XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSB0cmFuc2FjdGlvbiBtZXRhIG9iamVjdCwgZGV0ZXJtaW5lIHRoZSBhc3NldCB0eXBlIHRoYXQgdGhlXHJcbiAqIHRyYW5zYWN0aW9uIGlzIGRlYWxpbmcgd2l0aCwgYXMgd2VsbCBhcyB0aGUgc3RhbmRhcmQgZm9yIHRoZSB0b2tlbiBpZiBpdFxyXG4gKiBpcyBhIHRva2VuIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuVHJhbnNhY3Rpb25NZXRhfSB0eE1ldGEgLVxyXG4gKiAgdHJhbnNhY3Rpb24gbWV0YSBvYmplY3RcclxuICogQHBhcmFtIHtFdGhRdWVyeX0gcXVlcnkgLSBFdGhRdWVyeSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyAtIGZ1bmN0aW9uIHRvIGdldCB0b2tlblxyXG4gKiAgc3RhbmRhcmRzIGFuZCBkZXRhaWxzLlxyXG4gKiBAcmV0dXJucyB7eyBhc3NldFR5cGU6IHN0cmluZywgdG9rZW5TdGFuZGFyZDogc3RyaW5nfX1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVUcmFuc2FjdGlvbkFzc2V0VHlwZShcclxuICB0eE1ldGEsXHJcbiAgcXVlcnksXHJcbiAgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMsXHJcbikge1xyXG4gIC8vIElmIHRoZSB0cmFuc2FjdGlvbiB0eXBlIGlzIGFscmVhZHkgb25lIG9mIHRoZSBpbmZlcnJhYmxlIHR5cGVzLCB0aGVuIHdlIGRvXHJcbiAgLy8gbm90IG5lZWQgdG8gcmUtZXN0YWJsaXNoIHRoZSB0eXBlLlxyXG4gIGxldCBpbmZlcnJhYmxlVHlwZSA9IHR4TWV0YS50eXBlO1xyXG4gIGlmIChJTkZFUlJBQkxFX1RSQU5TQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR4TWV0YS50eXBlKSA9PT0gZmFsc2UpIHtcclxuICAgIC8vIEJlY2F1c2Ugd2Ugd2lsbCBkZWFsIHdpdGggYWxsIHR5cGVzIG9mIHRyYW5zYWN0aW9ucyAoaW5jbHVkaW5nIHN3YXBzKVxyXG4gICAgLy8gd2Ugd2FudCB0byBnZXQgYW4gaW5mZXJyYWJsZSB0eXBlIG9mIHRyYW5zYWN0aW9uIHRoYXQgaXNuJ3Qgc3BlY2lhbCBjYXNlZFxyXG4gICAgLy8gdGhhdCB3YXkgd2UgY2FuIG5hcnJvdyB0aGUgbnVtYmVyIG9mIGxvZ2ljIGdhdGVzIHJlcXVpcmVkLlxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGV0ZXJtaW5lVHJhbnNhY3Rpb25UeXBlKHR4TWV0YS50eFBhcmFtcywgcXVlcnkpO1xyXG4gICAgaW5mZXJyYWJsZVR5cGUgPSByZXN1bHQudHlwZTtcclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSBpbmZlcnJlZCB0eXBlIG9mIHRoZSB0cmFuc2FjdGlvbiBpcyBvbmUgb2YgdGhvc2UgdGhhdCBhcmUgcGFydCBvZlxyXG4gIC8vIHRoZSB0b2tlbiBjb250cmFjdCBzdGFuZGFyZHMsIHdlIGNhbiB1c2UgdGhlIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzXHJcbiAgLy8gbWV0aG9kIHRvIGdldCB0aGUgYXNzZXQgdHlwZS5cclxuICBjb25zdCBpc1Rva2VuTWV0aG9kID0gW1xyXG4gICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kQXBwcm92ZSxcclxuICAgIFRyYW5zYWN0aW9uVHlwZS50b2tlbk1ldGhvZFNldEFwcHJvdmFsRm9yQWxsLFxyXG4gICAgVHJhbnNhY3Rpb25UeXBlLnRva2VuTWV0aG9kVHJhbnNmZXIsXHJcbiAgICBUcmFuc2FjdGlvblR5cGUudG9rZW5NZXRob2RUcmFuc2ZlckZyb20sXHJcbiAgXS5maW5kKChtZXRob2ROYW1lKSA9PiBtZXRob2ROYW1lID09PSBpbmZlcnJhYmxlVHlwZSk7XHJcblxyXG4gIGlmIChcclxuICAgIGlzVG9rZW5NZXRob2QgfHxcclxuICAgIC8vIFdlIGNhbiBhbHNvIGNoZWNrIGFueSBjb250cmFjdCBpbnRlcmFjdGlvbiB0eXBlIHRvIHNlZSBpZiB0aGUgdG8gYWRkcmVzc1xyXG4gICAgLy8gaXMgYSB0b2tlbiBjb250cmFjdC4gSWYgaXQgaXNuJ3QsIHRoZW4gdGhlIG1ldGhvZCB3aWxsIHRocm93IGFuZCB3ZSBjYW5cclxuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgb3RoZXIgY2hlY2tzLlxyXG4gICAgaW5mZXJyYWJsZVR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5jb250cmFjdEludGVyYWN0aW9uXHJcbiAgKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIGEgYmFsYW5jZSBjaGVjaywgc28gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG9cclxuICAgICAgLy8gZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMgaXMgb21pdHRlZC5cclxuICAgICAgY29uc3QgZGV0YWlscyA9IGF3YWl0IGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKHR4TWV0YS50eFBhcmFtcy50byk7XHJcbiAgICAgIGlmIChkZXRhaWxzLnN0YW5kYXJkKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGFzc2V0VHlwZTpcclxuICAgICAgICAgICAgZGV0YWlscy5zdGFuZGFyZCA9PT0gVG9rZW5TdGFuZGFyZC5FUkMyMFxyXG4gICAgICAgICAgICAgID8gQXNzZXRUeXBlLnRva2VuXHJcbiAgICAgICAgICAgICAgOiBBc3NldFR5cGUuTkZULFxyXG4gICAgICAgICAgdG9rZW5TdGFuZGFyZDogZGV0YWlscy5zdGFuZGFyZCxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gbm9vcCwgV2UgZXhwZWN0IGVycm9ycyBoZXJlIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHJlcG9ydCB0aGVtIG9yIGRvXHJcbiAgICAgIC8vIGFueXRoaW5nIGluIHJlc3BvbnNlLlxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGlzIGludGVyYWN0aW5nIHdpdGggYSBjb250cmFjdCBidXQgaXNuJ3QgYSB0b2tlbiBtZXRob2RcclxuICAvLyB3ZSB1c2UgdGhlICdVTktOT1dOJyB2YWx1ZSB0byBzaG93IHRoYXQgaXQgaXNuJ3QgYSB0cmFuc2FjdGlvbiBzZW5kaW5nIGFueVxyXG4gIC8vIHBhcnRpY3VsYXIgYXNzZXQuXHJcbiAgaWYgKGluZmVycmFibGVUeXBlID09PSBUcmFuc2FjdGlvblR5cGUuY29udHJhY3RJbnRlcmFjdGlvbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYXNzZXRUeXBlOiBBc3NldFR5cGUudW5rbm93bixcclxuICAgICAgdG9rZW5TdGFuZGFyZDogVG9rZW5TdGFuZGFyZC5ub25lLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHsgYXNzZXRUeXBlOiBBc3NldFR5cGUubmF0aXZlLCB0b2tlblN0YW5kYXJkOiBUb2tlblN0YW5kYXJkLm5vbmUgfTtcclxufVxyXG4iLCIvLyBNZXNzYWdlcyBhbmQgZGVzY3JpcHRpb25zIGZvciB0aGVzZSBsb2NhbGUga2V5cyBhcmUgaW4gYXBwL19sb2NhbGVzL2VuL21lc3NhZ2VzLmpzb25cclxuZXhwb3J0IGNvbnN0IFVJX05PVElGSUNBVElPTlMgPSB7XHJcbiAgMToge1xyXG4gICAgaWQ6IDEsXHJcbiAgICBkYXRlOiAnMjAyMS0wMy0xNycsXHJcbiAgICBpbWFnZToge1xyXG4gICAgICBzcmM6ICdpbWFnZXMvbW9iaWxlLWxpbmstcXIuc3ZnJyxcclxuICAgICAgaGVpZ2h0OiAnMjMwcHgnLFxyXG4gICAgICB3aWR0aDogJzIzMHB4JyxcclxuICAgICAgcGxhY2VJbWFnZUJlbG93RGVzY3JpcHRpb246IHRydWUsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgMzoge1xyXG4gICAgaWQ6IDMsXHJcbiAgICBkYXRlOiAnMjAyMS0wMy0wOCcsXHJcbiAgfSxcclxuICA0OiB7XHJcbiAgICBpZDogNCxcclxuICAgIGRhdGU6ICcyMDIxLTA1LTExJyxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy9zb3VyY2UtbG9nb3MtYnNjLnN2ZycsXHJcbiAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgNToge1xyXG4gICAgaWQ6IDUsXHJcbiAgICBkYXRlOiAnMjAyMS0wNi0wOScsXHJcbiAgfSxcclxuICA2OiB7XHJcbiAgICBpZDogNixcclxuICAgIGRhdGU6ICcyMDIxLTA1LTI2JyxcclxuICB9LFxyXG4gIDc6IHtcclxuICAgIGlkOiA3LFxyXG4gICAgZGF0ZTogJzIwMjEtMDktMTcnLFxyXG4gIH0sXHJcbiAgODoge1xyXG4gICAgaWQ6IDgsXHJcbiAgICBkYXRlOiAnMjAyMS0xMS0wMScsXHJcbiAgfSxcclxuICA5OiB7XHJcbiAgICBpZDogOSxcclxuICAgIGRhdGU6ICcyMDIxLTEyLTA3JyxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy90eGluc2lnaHRzLnBuZycsXHJcbiAgICAgIHdpZHRoOiAnODAlJyxcclxuICAgIH0sXHJcbiAgfSxcclxuICAxMDoge1xyXG4gICAgaWQ6IDEwLFxyXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxyXG4gICAgaW1hZ2U6IHtcclxuICAgICAgc3JjOiAnaW1hZ2VzL3Rva2VuLWRldGVjdGlvbi5zdmcnLFxyXG4gICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIDExOiB7XHJcbiAgICBpZDogMTEsXHJcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXHJcbiAgfSxcclxuICAxMjoge1xyXG4gICAgaWQ6IDEyLFxyXG4gICAgZGF0ZTogJzIwMjItMDUtMTgnLFxyXG4gICAgaW1hZ2U6IHtcclxuICAgICAgc3JjOiAnaW1hZ2VzL2Rhcmttb2RlLWJhbm5lci5wbmcnLFxyXG4gICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIDEzOiB7XHJcbiAgICBpZDogMTMsXHJcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXHJcbiAgfSxcclxuICAxNDoge1xyXG4gICAgaWQ6IDE0LFxyXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxyXG4gIH0sXHJcbiAgMTU6IHtcclxuICAgIGlkOiAxNSxcclxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcclxuICB9LFxyXG4gIDE2OiB7XHJcbiAgICBpZDogMTYsXHJcbiAgICBkYXRlOiBudWxsLFxyXG4gIH0sXHJcbiAgMTc6IHtcclxuICAgIGlkOiAxNyxcclxuICAgIGRhdGU6IG51bGwsXHJcbiAgfSxcclxuICAxODoge1xyXG4gICAgaWQ6IDE4LFxyXG4gICAgZGF0ZTogbnVsbCxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy9vcGVuLXNlYS1zZWN1cml0eS1wcm92aWRlci5zdmcnLFxyXG4gICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIDE5OiB7XHJcbiAgICBpZDogMTksXHJcbiAgICBkYXRlOiBudWxsLFxyXG4gICAgaW1hZ2U6IHtcclxuICAgICAgc3JjOiAnaW1hZ2VzL25mdHMuc3ZnJyxcclxuICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgIH0sXHJcbiAgfSxcclxuICAyMDoge1xyXG4gICAgaWQ6IDIwLFxyXG4gICAgZGF0ZTogbnVsbCxcclxuICB9LFxyXG4gIDIxOiB7XHJcbiAgICBpZDogMjEsXHJcbiAgICBkYXRlOiBudWxsLFxyXG4gICAgaW1hZ2U6IHtcclxuICAgICAgc3JjOiAnaW1hZ2VzL3N3YXBzLXJlZGVzaWduLnN2ZycsXHJcbiAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICB9LFxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VHJhbnNsYXRlZFVJTm90aWZpY2F0aW9ucyA9ICh0LCBsb2NhbGUpID0+IHtcclxuICBjb25zdCBmb3JtYXR0ZWRMb2NhbGUgPSBsb2NhbGUucmVwbGFjZSgnXycsICctJyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIDE6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxXSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxVGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxRGVzY3JpcHRpb24nKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxXS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICAzOiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbM10sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zM1RpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zM0Rlc2NyaXB0aW9uJyksXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMzQWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzNdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDQ6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s0XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM0VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnM0RGVzY3JpcHRpb24nKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczRBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbNF0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgNToge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzVdLFxyXG4gICAgICB0aXRsZTogdCgnc2VjcmV0UmVjb3ZlcnlQaHJhc2UnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnM1RGVzY3JpcHRpb24nKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczNBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbNV0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgNjoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzZdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczZUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogW1xyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM2RGVzY3JpcHRpb25PbmUnKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zNkRlc2NyaXB0aW9uVHdvJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczZEZXNjcmlwdGlvblRocmVlJyksXHJcbiAgICAgIF0sXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbNl0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgNzoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzddLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczdUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogW1xyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM3RGVzY3JpcHRpb25PbmUnKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zN0Rlc2NyaXB0aW9uVHdvJyksXHJcbiAgICAgIF0sXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbN10uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgODoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzhdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczhUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogW1xyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM4RGVzY3JpcHRpb25PbmUnKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zOERlc2NyaXB0aW9uVHdvJyksXHJcbiAgICAgIF0sXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbOF0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnM4QWN0aW9uVGV4dCcpLFxyXG4gICAgfSxcclxuICAgIDk6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s5XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM5VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zOURlc2NyaXB0aW9uT25lJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczlEZXNjcmlwdGlvblR3bycpLFxyXG4gICAgICBdLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzldLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDEwOiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTBdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczEwVGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zMTBEZXNjcmlwdGlvbk9uZScpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxMERlc2NyaXB0aW9uVHdvJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczEwRGVzY3JpcHRpb25UaHJlZScpLFxyXG4gICAgICBdLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTBBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTBdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDExOiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTFdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczExVGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxMURlc2NyaXB0aW9uJyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTFdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDEyOiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTJdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczEyVGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxMkRlc2NyaXB0aW9uJyksXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxMkFjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxMl0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgMTM6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxM10sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTNUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczEzRGVzY3JpcHRpb24nKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczEzQWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzEzXS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICAxNDoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzE0XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxNFRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTREZXNjcmlwdGlvbicpLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTRBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IFVJX05PVElGSUNBVElPTlNbMTRdLmRhdGVcclxuICAgICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzE0XS5kYXRlKSxcclxuICAgICAgICAgIClcclxuICAgICAgICA6ICcnLFxyXG4gICAgfSxcclxuICAgIDE1OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTVdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczE1VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxNURlc2NyaXB0aW9uJyksXHJcbiAgICAgIGRhdGU6IFVJX05PVElGSUNBVElPTlNbMTVdLmRhdGVcclxuICAgICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzE1XS5kYXRlKSxcclxuICAgICAgICAgIClcclxuICAgICAgICA6ICcnLFxyXG4gICAgfSxcclxuICAgIDE4OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMThdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczE4VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zMThEZXNjcmlwdGlvbk9uZScpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxOERlc2NyaXB0aW9uVHdvJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczE4RGVzY3JpcHRpb25UaHJlZScpLFxyXG4gICAgICBdLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMThBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IFVJX05PVElGSUNBVElPTlNbMThdLmRhdGVcclxuICAgICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzE4XS5kYXRlKSxcclxuICAgICAgICAgIClcclxuICAgICAgICA6ICcnLFxyXG4gICAgfSxcclxuXHJcbiAgICAxOToge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzE5XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxOVRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBbXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczE5RGVzY3JpcHRpb25PbmUnKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zMTlEZXNjcmlwdGlvblR3bycpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxOURlc2NyaXB0aW9uVGhyZWUnKSxcclxuICAgICAgXSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczE5QWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzE5XS5kYXRlXHJcbiAgICAgICAgPyBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxOV0uZGF0ZSksXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiAnJyxcclxuICAgIH0sXHJcbiAgICAyMDoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzIwXSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMyMFRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBbdCgnbm90aWZpY2F0aW9uczIwRGVzY3JpcHRpb24nKV0sXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMyMEFjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogVUlfTk9USUZJQ0FUSU9OU1syMF0uZGF0ZVxyXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMjBdLmRhdGUpLFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogJycsXHJcbiAgICB9LFxyXG4gICAgMjE6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1syMV0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMjFUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczIxRGVzY3JpcHRpb24nKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczIxQWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzIxXS5kYXRlXHJcbiAgICAgICAgPyBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1syMV0uZGF0ZSksXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiAnJyxcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuIiwiZXhwb3J0IGNvbnN0IFBSSU1BUlkgPSAnUFJJTUFSWSc7XHJcbmV4cG9ydCBjb25zdCBTRUNPTkRBUlkgPSAnU0VDT05EQVJZJztcclxuXHJcbmNvbnN0IF9jb250cmFjdEFkZHJlc3NMaW5rID1cclxuICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMjAwMjgwOTItV2hhdC1pcy10aGUta25vd24tY29udHJhY3QtYWRkcmVzcy13YXJuaW5nLSc7XHJcblxyXG5cblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcclxuZXhwb3J0IGNvbnN0IFNVUFBPUlRfUkVRVUVTVF9MSU5LID0gcHJvY2Vzcy5lbnYuU1VQUE9SVF9SRVFVRVNUX0xJTks7XHJcbmV4cG9ydCBjb25zdCBDT05UUkFDVF9BRERSRVNTX0xJTksgPSBfY29udHJhY3RBZGRyZXNzTGluaztcclxuZXhwb3J0IGNvbnN0IFBBU1NXT1JEX01JTl9MRU5HVEggPSA4O1xyXG5leHBvcnQgY29uc3QgT1VUREFURURfQlJPV1NFUl9WRVJTSU9OUyA9IHtcclxuICAvLyBDaHJvbWUgYW5kIEVkZ2Ugc2hvdWxkIG1hdGNoIHRoZSBsYXRlc3QgQ2hyb21lIHZlcnNpb24gcmVsZWFzZWQgfjIgeWVhcnMgYWdvXHJcbiAgY2hyb21lOiAnPDkwJyxcclxuICBlZGdlOiAnPDkwJyxcclxuICAvLyBGaXJlZm94IHNob3VsZCBtYXRjaCB0aGUgbW9zdCByZWNlbnQgZW5kLW9mLWxpZmUgZXh0ZW5kZWQgc3VwcG9ydCByZWxlYXNlXHJcbiAgZmlyZWZveDogJzw5MScsXHJcbiAgLy8gT3BlcmEgc2hvdWxkIGJlIHNldCB0byB0aGUgZXF1aXZhbGVudCBvZiB0aGUgQ2hyb21lIHZlcnNpb24gc2V0XHJcbiAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hpc3Rvcnlfb2ZfdGhlX09wZXJhX3dlYl9icm93c2VyXHJcbiAgb3BlcmE6ICc8NzYnLFxyXG59O1xyXG4iLCJcblxuXHJcbmNvbnN0IGFzc2V0TGlzdCA9IHtcclxuICBtYWluOiB7XHJcbiAgICAvLyBXaWxsIHVzZSBkZWZhdWx0IHByb3ZpZGVkIGJ5IHRoZSBAbWV0YW1hc2svbG9nbyBsaWJyYXJ5XHJcbiAgICBmb3hNZXNoSnNvbjogdW5kZWZpbmVkLFxyXG4gIH0sXHJcblxuXG5cbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNCZXRhKCkge1xyXG4gIHJldHVybiBwcm9jZXNzLmVudi5NRVRBTUFTS19CVUlMRF9UWVBFID09PSAnYmV0YSc7XHJcbn1cclxuXHJcbi8vIFJldHVybnMgYSBzcGVjaWZpYyB2ZXJzaW9uIG9mIGFuIGFzc2V0IGJhc2VkIG9uXHJcbi8vIHRoZSBjdXJyZW50IG1ldGFtYXNrIHZlcnNpb24gKGkuZS4gbWFpbiwgYmV0YSwgZXRjLilcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1aWxkU3BlY2lmaWNBc3NldChhc3NldE5hbWUpIHtcclxuICBjb25zdCBidWlsZFR5cGUgPSBwcm9jZXNzLmVudi5NRVRBTUFTS19CVUlMRF9UWVBFO1xyXG4gIGlmIChcclxuICAgICFhc3NldExpc3RbYnVpbGRUeXBlXSB8fFxyXG4gICAgIU9iamVjdC5rZXlzKGFzc2V0TGlzdFtidWlsZFR5cGVdKS5pbmNsdWRlcyhhc3NldE5hbWUpXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICBgQ2Fubm90IGZpbmQgYXNzZXQgXCIke2Fzc2V0TmFtZX1cIiBmb3IgYnVpbGQgXCIke2J1aWxkVHlwZX1cIiwgcmV0dXJuaW5nIG1haW4gYnVpbGQgYXNzZXQuYCxcclxuICAgICk7XHJcbiAgICByZXR1cm4gYXNzZXRMaXN0Lm1haW5bYXNzZXROYW1lXTtcclxuICB9XHJcbiAgcmV0dXJuIGFzc2V0TGlzdFtidWlsZFR5cGVdW2Fzc2V0TmFtZV07XHJcbn1cclxuIiwiaW1wb3J0IHsgb21pdCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IEJOIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHsgQ29tbW9uLCBIYXJkZm9yayB9IGZyb20gJ0BldGhlcmV1bWpzL2NvbW1vbic7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9IGZyb20gJ0BldGhlcmV1bWpzL3R4JztcclxuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xyXG5cclxuZnVuY3Rpb24gYnVpbGRUeFBhcmFtcyh0eE1ldGEpIHtcclxuICByZXR1cm4ge1xyXG4gICAgLi4ub21pdCh0eE1ldGEudHhQYXJhbXMsICdnYXMnKSxcclxuICAgIGdhc0xpbWl0OiB0eE1ldGEudHhQYXJhbXMuZ2FzLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKSB7XHJcbiAgLy8gVGhpcyBwcm9kdWNlcyBhIHRyYW5zYWN0aW9uIHdob3NlIGluZm9ybWF0aW9uIGRvZXMgbm90IGNvbXBsZXRlbHkgbWF0Y2ggYW5cclxuICAvLyBPcHRpbWlzbSB0cmFuc2FjdGlvbiDigJQgZm9yIGluc3RhbmNlLCBERUZBVUxUX0NIQUlOIGlzIHN0aWxsICdtYWlubmV0JyBhbmRcclxuICAvLyBnZW5lc2lzIHBvaW50cyB0byB0aGUgbWFpbm5ldCBnZW5lc2lzLCBub3QgdGhlIE9wdGltaXNtIGdlbmVzaXMg4oCUIGJ1dFxyXG4gIC8vIGNvbnNpZGVyaW5nIHRoYXQgYWxsIHdlIHdhbnQgdG8gZG8gaXMgc2VyaWFsaXplIGEgdHJhbnNhY3Rpb24sIHRoaXMgd29ya3NcclxuICAvLyBmaW5lIGZvciBvdXIgdXNlIGNhc2UuXHJcbiAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xyXG4gICAgY2hhaW5JZDogbmV3IEJOKHN0cmlwSGV4UHJlZml4KHR4TWV0YS5jaGFpbklkKSwgMTYpLFxyXG4gICAgbmV0d29ya0lkOiBuZXcgQk4odHhNZXRhLm1ldGFtYXNrTmV0d29ya0lkLCAxMCksXHJcbiAgICAvLyBPcHRpbWlzbSBvbmx5IHN1cHBvcnRzIHR5cGUtMCB0cmFuc2FjdGlvbnM7IGl0IGRvZXMgbm90IHN1cHBvcnQgYW55IG9mXHJcbiAgICAvLyB0aGUgbmV3ZXIgRUlQcyBzaW5jZSBFSVAtMTU1LiBTb3VyY2U6XHJcbiAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtLW9wdGltaXNtL29wdGltaXNtL2Jsb2IvZGV2ZWxvcC9zcGVjcy9sMmdldGgvdHJhbnNhY3Rpb24tdHlwZXMubWQ+XHJcbiAgICBkZWZhdWx0SGFyZGZvcms6IEhhcmRmb3JrLlNwdXJpb3VzRHJhZ29uLFxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uKHR4TWV0YSkge1xyXG4gIGNvbnN0IHR4UGFyYW1zID0gYnVpbGRUeFBhcmFtcyh0eE1ldGEpO1xyXG4gIGNvbnN0IGNvbW1vbiA9IGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKTtcclxuICByZXR1cm4gVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhQYXJhbXMsIHsgY29tbW9uIH0pO1xyXG59XHJcbiIsImltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJztcclxuaW1wb3J0IHsgV2ViM1Byb3ZpZGVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJztcclxuaW1wb3J0IHsgaGV4VG9EZWNpbWFsIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XHJcbmltcG9ydCBidWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uIGZyb20gJy4vYnVpbGRVbnNlcmlhbGl6ZWRUcmFuc2FjdGlvbic7XHJcblxyXG4vLyBTbmlwcGV0IG9mIHRoZSBBQkkgdGhhdCB3ZSBuZWVkXHJcbi8vIFNob3VsZCB3ZSBuZWVkIG1vcmUgb2YgaXQgYXQgc29tZSBwb2ludCwgdGhlIGZ1bGwgQUJJIGNhbiBiZSBmb3VuZCBoZXJlOlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0tb3B0aW1pc20vb3B0aW1pc20vYmxvYi9kZXZlbG9wL2dhcy1vcmFjbGUvYWJpcy9PVk1fR2FzUHJpY2VPcmFjbGUuanNvblxyXG5jb25zdCBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FCSSA9IFtcclxuICB7XHJcbiAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogJ2J5dGVzJywgbmFtZTogJ19kYXRhJywgdHlwZTogJ2J5dGVzJyB9XSxcclxuICAgIG5hbWU6ICdnZXRMMUZlZScsXHJcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JywgbmFtZTogJycsIHR5cGU6ICd1aW50MjU2JyB9XSxcclxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxyXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcclxuICB9LFxyXG5dO1xyXG5cclxuLy8gQmxvY2tFeHBsb3JlciBsaW5rOiBodHRwczovL29wdGltaXN0aWMuZXRoZXJzY2FuLmlvL2FkZHJlc3MvMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmI2NvZGVcclxuY29uc3QgT1BUSU1JU01fR0FTX1BSSUNFX09SQUNMRV9BRERSRVNTID1cclxuICAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRXN0aW1hdGVkTDFGZWUoXHJcbiAgY2hhaW5JZCxcclxuICB0eE1ldGEsXHJcbiAgZXRoZXJzUHJvdmlkZXIsXHJcbikge1xyXG4gIGNvbnN0IGNoYWluSWRBc0RlY2ltYWxOdW1iZXIgPSBOdW1iZXIoaGV4VG9EZWNpbWFsKGNoYWluSWQpKTtcclxuICBjb25zdCBwcm92aWRlciA9IGdsb2JhbC5ldGhlcmV1bVByb3ZpZGVyXHJcbiAgICA/IG5ldyBXZWIzUHJvdmlkZXIoZ2xvYmFsLmV0aGVyZXVtUHJvdmlkZXIsIGNoYWluSWRBc0RlY2ltYWxOdW1iZXIpXHJcbiAgICA6IGV0aGVyc1Byb3ZpZGVyO1xyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuSU5fVEVTVCkge1xyXG4gICAgcHJvdmlkZXIuZGV0ZWN0TmV0d29yayA9IGFzeW5jICgpID0+ICh7XHJcbiAgICAgIG5hbWU6ICdvcHRpbWlzbScsXHJcbiAgICAgIGNoYWluSWQ6IGNoYWluSWRBc0RlY2ltYWxOdW1iZXIsXHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXHJcbiAgICBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FERFJFU1MsXHJcbiAgICBPUFRJTUlTTV9HQVNfUFJJQ0VfT1JBQ0xFX0FCSSxcclxuICAgIHByb3ZpZGVyLFxyXG4gICk7XHJcbiAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID1cclxuICAgIGJ1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24odHhNZXRhKS5zZXJpYWxpemUoKTtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5nZXRMMUZlZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xyXG4gIHJldHVybiByZXN1bHQ/LnRvSGV4U3RyaW5nKCk7XHJcbn1cclxuIiwiaW1wb3J0IHB1bnljb2RlIGZyb20gJ3B1bnljb2RlL3B1bnljb2RlJztcclxuaW1wb3J0IGFiaSBmcm9tICdodW1hbi1zdGFuZGFyZC10b2tlbi1hYmknO1xyXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCAqIGFzIGV0aFV0aWwgZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XHJcbmltcG9ydCB7IGdldEZvcm1hdHRlZElwZnNVcmwgfSBmcm9tICdAbWV0YW1hc2svYXNzZXRzLWNvbnRyb2xsZXJzJztcclxuaW1wb3J0IHNsaXA0NCBmcm9tICdAbWV0YW1hc2svc2xpcDQ0JztcclxuaW1wb3J0ICogYXMgbG9kYXNoIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBib3dzZXIgZnJvbSAnYm93c2VyJztcclxuXG5pbXBvcnQgeyBDSEFJTl9JRFMsIE5FVFdPUktfVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5pbXBvcnQge1xyXG4gIHRvQ2hlY2tzdW1IZXhBZGRyZXNzLFxyXG4gIHN0cmlwSGV4UHJlZml4LFxyXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XHJcbmltcG9ydCB7XHJcbiAgVFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlMsXHJcbiAgVFJVTkNBVEVEX05BTUVfQ0hBUl9MSU1JVCxcclxuICBUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlMsXHJcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9sYWJlbHMnO1xyXG5pbXBvcnQgeyBOdW1lcmljIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvTnVtZXJpYyc7XHJcbmltcG9ydCB7IE9VVERBVEVEX0JST1dTRVJfVkVSU0lPTlMgfSBmcm9tICcuLi9jb25zdGFudHMvY29tbW9uJztcclxuXG5cclxuLy8gZm9ybWF0RGF0YSA6OiAoIGRhdGU6IDxVbml4IFRpbWVzdGFtcD4gKSAtPiBTdHJpbmdcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0ID0gXCJNL2QveSAnYXQnIFRcIikge1xyXG4gIGlmICghZGF0ZSkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICByZXR1cm4gRGF0ZVRpbWUuZnJvbU1pbGxpcyhkYXRlKS50b0Zvcm1hdChmb3JtYXQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVdpdGhZZWFyQ29udGV4dChcclxuICBkYXRlLFxyXG4gIGZvcm1hdFRoaXNZZWFyID0gJ01NTSBkJyxcclxuICBmYWxsYmFjayA9ICdNTU0gZCwgeScsXHJcbikge1xyXG4gIGlmICghZGF0ZSkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBjb25zdCBkYXRlVGltZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSk7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZVRpbWUubG9jYWwoKTtcclxuICByZXR1cm4gZGF0ZVRpbWUudG9Gb3JtYXQoXHJcbiAgICBub3cueWVhciA9PT0gZGF0ZVRpbWUueWVhciA/IGZvcm1hdFRoaXNZZWFyIDogZmFsbGJhY2ssXHJcbiAgKTtcclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvdmlkZWQgY2hhaW5JZCBpcyBhIGRlZmF1bHQgTWV0YU1hc2sgY2hhaW5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBjaGFpbklkIHRvIGNoZWNrXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZhdWx0TWV0YU1hc2tDaGFpbihjaGFpbklkKSB7XHJcbiAgaWYgKFxyXG4gICAgIWNoYWluSWQgfHxcclxuICAgIGNoYWluSWQgPT09IENIQUlOX0lEUy5NQUlOTkVUIHx8XHJcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuTElORUFfTUFJTk5FVCB8fFxyXG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLkdPRVJMSSB8fFxyXG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLlNFUE9MSUEgfHxcclxuICAgIGNoYWluSWQgPT09IENIQUlOX0lEUy5MSU5FQV9HT0VSTEkgfHxcclxuICAgIGNoYWluSWQgPT09IENIQUlOX0lEUy5MT0NBTEhPU1RcclxuICApIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzRm9yKG9iaikge1xyXG4gIGlmICghb2JqKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRyZXNzU3VtbWFyeShcclxuICBhZGRyZXNzLFxyXG4gIGZpcnN0U2VnTGVuZ3RoID0gMTAsXHJcbiAgbGFzdFNlZ0xlbmd0aCA9IDQsXHJcbiAgaW5jbHVkZUhleCA9IHRydWUsXHJcbikge1xyXG4gIGlmICghYWRkcmVzcykge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBsZXQgY2hlY2tlZCA9IHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xyXG4gIGlmICghaW5jbHVkZUhleCkge1xyXG4gICAgY2hlY2tlZCA9IHN0cmlwSGV4UHJlZml4KGNoZWNrZWQpO1xyXG4gIH1cclxuICByZXR1cm4gY2hlY2tlZFxyXG4gICAgPyBgJHtjaGVja2VkLnNsaWNlKDAsIGZpcnN0U2VnTGVuZ3RoKX0uLi4ke2NoZWNrZWQuc2xpY2UoXHJcbiAgICAgICAgY2hlY2tlZC5sZW5ndGggLSBsYXN0U2VnTGVuZ3RoLFxyXG4gICAgICApfWBcclxuICAgIDogJy4uLic7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRG9tYWluTmFtZShhZGRyZXNzKSB7XHJcbiAgY29uc3QgbWF0Y2ggPSBwdW55Y29kZVxyXG4gICAgLnRvQVNDSUkoYWRkcmVzcylcclxuICAgIC50b0xvd2VyQ2FzZSgpXHJcbiAgICAvLyBDaGVja3MgdGhhdCB0aGUgZG9tYWluIGNvbnNpc3RzIG9mIGF0IGxlYXN0IG9uZSB2YWxpZCBkb21haW4gcGllY2VzIHNlcGFyYXRlZCBieSBwZXJpb2RzLCBmb2xsb3dlZCBieSBhIHRsZFxyXG4gICAgLy8gRWFjaCBwaWVjZSBvZiBkb21haW4gbmFtZSBoYXMgb25seSB0aGUgY2hhcmFjdGVycyBhLXosIDAtOSwgYW5kIGEgaHlwaGVuIChidXQgbm90IGF0IHRoZSBzdGFydCBvciBlbmQgb2YgY2h1bmspXHJcbiAgICAvLyBBIGNodW5rIGhhcyBtaW5pbXVtIGxlbmd0aCBvZiAxLCBidXQgbWluaW11bSB0bGQgaXMgc2V0IHRvIDIgZm9yIG5vdyAobm8gMS1jaGFyYWN0ZXIgdGxkcyBleGlzdCB5ZXQpXHJcbiAgICAubWF0Y2goXHJcbiAgICAgIC9eKD86W2EtejAtOV0oPzpbLWEtejAtOV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV1bLWEtejAtOV0qW2EtejAtOV0kL3UsXHJcbiAgICApO1xyXG4gIHJldHVybiBtYXRjaCAhPT0gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3JpZ2luQ29udHJhY3RBZGRyZXNzKHRvLCBzZW5kVG9rZW5BZGRyZXNzKSB7XHJcbiAgaWYgKCF0byB8fCAhc2VuZFRva2VuQWRkcmVzcykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdG8udG9Mb3dlckNhc2UoKSA9PT0gc2VuZFRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG4vLyBUYWtlcyB3ZWkgSGV4LCByZXR1cm5zIHdlaSBCTiwgZXZlbiBpZiBpbnB1dCBpcyBudWxsXHJcbmV4cG9ydCBmdW5jdGlvbiBudW1lcmljQmFsYW5jZShiYWxhbmNlKSB7XHJcbiAgaWYgKCFiYWxhbmNlKSB7XHJcbiAgICByZXR1cm4gbmV3IGV0aFV0aWwuQk4oMCwgMTYpO1xyXG4gIH1cclxuICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGJhbGFuY2UpO1xyXG4gIHJldHVybiBuZXcgZXRoVXRpbC5CTihzdHJpcHBlZCwgMTYpO1xyXG59XHJcblxyXG4vLyBUYWtlcyAgaGV4LCByZXR1cm5zIFtiZWZvcmVEZWNpbWFsLCBhZnRlckRlY2ltYWxdXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJhbGFuY2UoYmFsYW5jZSkge1xyXG4gIGxldCBhZnRlckRlY2ltYWw7XHJcbiAgY29uc3Qgd2VpID0gbnVtZXJpY0JhbGFuY2UoYmFsYW5jZSk7XHJcbiAgY29uc3Qgd2VpU3RyaW5nID0gd2VpLnRvU3RyaW5nKCk7XHJcbiAgY29uc3QgdHJhaWxpbmdaZXJvcyA9IC8wKyQvdTtcclxuXHJcbiAgY29uc3QgYmVmb3JlRGVjaW1hbCA9XHJcbiAgICB3ZWlTdHJpbmcubGVuZ3RoID4gMTggPyB3ZWlTdHJpbmcuc2xpY2UoMCwgd2VpU3RyaW5nLmxlbmd0aCAtIDE4KSA6ICcwJztcclxuICBhZnRlckRlY2ltYWwgPSBgMDAwMDAwMDAwMDAwMDAwMDAwJHt3ZWl9YFxyXG4gICAgLnNsaWNlKC0xOClcclxuICAgIC5yZXBsYWNlKHRyYWlsaW5nWmVyb3MsICcnKTtcclxuICBpZiAoYWZ0ZXJEZWNpbWFsID09PSAnJykge1xyXG4gICAgYWZ0ZXJEZWNpbWFsID0gJzAnO1xyXG4gIH1cclxuICByZXR1cm4gW2JlZm9yZURlY2ltYWwsIGFmdGVyRGVjaW1hbF07XHJcbn1cclxuXHJcbi8vIFRha2VzIHdlaSBoZXgsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhyZWUgcHJvcGVydGllcy5cclxuLy8gSXRzIFwiZm9ybWF0dGVkXCIgcHJvcGVydHkgaXMgd2hhdCB3ZSBnZW5lcmFsbHkgdXNlIHRvIHJlbmRlciB2YWx1ZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCYWxhbmNlKFxyXG4gIGJhbGFuY2UsXHJcbiAgZGVjaW1hbHNUb0tlZXAsXHJcbiAgbmVlZHNQYXJzZSA9IHRydWUsXHJcbiAgdGlja2VyID0gJ0VUSCcsXHJcbikge1xyXG4gIGNvbnN0IHBhcnNlZCA9IG5lZWRzUGFyc2UgPyBwYXJzZUJhbGFuY2UoYmFsYW5jZSkgOiBiYWxhbmNlLnNwbGl0KCcuJyk7XHJcbiAgY29uc3QgYmVmb3JlRGVjaW1hbCA9IHBhcnNlZFswXTtcclxuICBsZXQgYWZ0ZXJEZWNpbWFsID0gcGFyc2VkWzFdO1xyXG4gIGxldCBmb3JtYXR0ZWQgPSAnTm9uZSc7XHJcbiAgaWYgKGRlY2ltYWxzVG9LZWVwID09PSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChiZWZvcmVEZWNpbWFsID09PSAnMCcpIHtcclxuICAgICAgaWYgKGFmdGVyRGVjaW1hbCAhPT0gJzAnKSB7XHJcbiAgICAgICAgY29uc3Qgc2lnRmlncyA9IGFmdGVyRGVjaW1hbC5tYXRjaCgvXjAqKC57Mn0pL3UpOyAvLyBkZWZhdWx0OiBncmFicyAyIG1vc3Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgaWYgKHNpZ0ZpZ3MpIHtcclxuICAgICAgICAgIGFmdGVyRGVjaW1hbCA9IHNpZ0ZpZ3NbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdHRlZCA9IGAwLiR7YWZ0ZXJEZWNpbWFsfSAke3RpY2tlcn1gO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3JtYXR0ZWQgPSBgJHtiZWZvcmVEZWNpbWFsfS4ke2FmdGVyRGVjaW1hbC5zbGljZSgwLCAzKX0gJHt0aWNrZXJ9YDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgYWZ0ZXJEZWNpbWFsICs9IEFycmF5KGRlY2ltYWxzVG9LZWVwKS5qb2luKCcwJyk7XHJcbiAgICBmb3JtYXR0ZWQgPSBgJHtiZWZvcmVEZWNpbWFsfS4ke2FmdGVyRGVjaW1hbC5zbGljZShcclxuICAgICAgMCxcclxuICAgICAgZGVjaW1hbHNUb0tlZXAsXHJcbiAgICApfSAke3RpY2tlcn1gO1xyXG4gIH1cclxuICByZXR1cm4gZm9ybWF0dGVkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udHJhY3RBdEFkZHJlc3ModG9rZW5BZGRyZXNzKSB7XHJcbiAgcmV0dXJuIGdsb2JhbC5ldGguY29udHJhY3QoYWJpKS5hdCh0b2tlbkFkZHJlc3MpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tRmlsZU5hbWUoKSB7XHJcbiAgbGV0IGZpbGVOYW1lID0gJyc7XHJcbiAgY29uc3QgY2hhckJhbmsgPSBbXHJcbiAgICAuLi4nYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknLFxyXG4gIF07XHJcbiAgY29uc3QgZmlsZU5hbWVMZW5ndGggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA3ICsgNik7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZU5hbWVMZW5ndGg7IGkrKykge1xyXG4gICAgZmlsZU5hbWUgKz0gY2hhckJhbmtbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhckJhbmsubGVuZ3RoKV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmlsZU5hbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaG9ydGVucyBhbiBFdGhlcmV1bSBhZGRyZXNzIGZvciBkaXNwbGF5LCBwcmVzZXJ2aW5nIHRoZSBiZWdpbm5pbmcgYW5kIGVuZC5cclxuICogUmV0dXJucyB0aGUgZ2l2ZW4gYWRkcmVzcyBpZiBpdCBpcyBubyBsb25nZXIgdGhhbiAxMCBjaGFyYWN0ZXJzLlxyXG4gKiBTaG9ydGVuZWQgYWRkcmVzc2VzIGFyZSAxMyBjaGFyYWN0ZXJzIGxvbmcuXHJcbiAqXHJcbiAqIEV4YW1wbGUgb3V0cHV0OiAweGFiY2QuLi4xMjM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gc2hvcnRlbi5cclxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHNob3J0ZW5lZCBhZGRyZXNzLCBvciB0aGUgb3JpZ2luYWwgaWYgaXQgd2FzIG5vIGxvbmdlclxyXG4gKiB0aGFuIDEwIGNoYXJhY3RlcnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvcnRlbkFkZHJlc3MoYWRkcmVzcyA9ICcnKSB7XHJcbiAgaWYgKGFkZHJlc3MubGVuZ3RoIDwgVFJVTkNBVEVEX05BTUVfQ0hBUl9MSU1JVCkge1xyXG4gICAgcmV0dXJuIGFkZHJlc3M7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYCR7YWRkcmVzcy5zbGljZSgwLCBUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSUyl9Li4uJHthZGRyZXNzLnNsaWNlKFxyXG4gICAgLVRSVU5DQVRFRF9BRERSRVNTX0VORF9DSEFSUyxcclxuICApfWA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50QnlBZGRyZXNzKGFjY291bnRzID0gW10sIHRhcmdldEFkZHJlc3MpIHtcclxuICByZXR1cm4gYWNjb3VudHMuZmluZCgoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MgPT09IHRhcmdldEFkZHJlc3MpO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaXBzIHRoZSBmb2xsb3dpbmcgc2NoZW1lcyBmcm9tIFVSTCBzdHJpbmdzOlxyXG4gKiAtIGh0dHBcclxuICogLSBodHRwc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwU2NoZW1lcyh1cmxTdHJpbmcpIHtcclxuICByZXR1cm4gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwcz86XFwvXFwvL3UsICcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0cmlwcyB0aGUgZm9sbG93aW5nIHNjaGVtZXMgZnJvbSBVUkwgc3RyaW5nczpcclxuICogLSBodHRwc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwc1NjaGVtZSh1cmxTdHJpbmcpIHtcclxuICByZXR1cm4gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwczpcXC9cXC8vdSwgJycpO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaXBzIGBodHRwc2Agc2NoZW1lcyBmcm9tIFVSTCBzdHJpbmdzLCBpZiB0aGUgVVJMIGRvZXMgbm90IGhhdmUgYSBwb3J0LlxyXG4gKiBUaGlzIGlzIHVzZWZ1bFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwc1NjaGVtZVdpdGhvdXRQb3J0KHVybFN0cmluZykge1xyXG4gIGlmIChnZXRVUkwodXJsU3RyaW5nKS5wb3J0KSB7XHJcbiAgICByZXR1cm4gdXJsU3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmlwSHR0cHNTY2hlbWUodXJsU3RyaW5nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGEgVVJMLWxpa2UgdmFsdWUgKG9iamVjdCBvciBzdHJpbmcpIGlzIGFuIGV4dGVuc2lvbiBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgVVJMIHwgb2JqZWN0fSB1cmxMaWtlIC0gVGhlIFVSTC1saWtlIHZhbHVlIHRvIHRlc3QuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBVUkwtbGlrZSB2YWx1ZSBpcyBhbiBleHRlbnNpb24gVVJMLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZW5zaW9uVXJsKHVybExpa2UpIHtcclxuICBjb25zdCBFWFRfUFJPVE9DT0xTID0gWydjaHJvbWUtZXh0ZW5zaW9uOicsICdtb3otZXh0ZW5zaW9uOiddO1xyXG5cclxuICBpZiAodHlwZW9mIHVybExpa2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIEVYVF9QUk9UT0NPTFMpIHtcclxuICAgICAgaWYgKHVybExpa2Uuc3RhcnRzV2l0aChwcm90b2NvbCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHVybExpa2U/LnByb3RvY29sKSB7XHJcbiAgICByZXR1cm4gRVhUX1BST1RPQ09MUy5pbmNsdWRlcyh1cmxMaWtlLnByb3RvY29sKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYW4gYWRkcmVzcyBpcyBpbiBhIHBhc3NlZCBsaXN0IG9mIG9iamVjdHMgd2l0aCBhZGRyZXNzIHByb3BlcnRpZXMuIFRoZSBjaGVjayBpcyBwZXJmb3JtZWQgb24gdGhlXHJcbiAqIGxvd2VyY2FzZWQgdmVyc2lvbiBvZiB0aGUgYWRkcmVzc2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyB0byBjaGVja1xyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gVGhlIGFycmF5IG9mIG9iamVjdHMgdG8gY2hlY2tcclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhZGRyZXNzIGlzIGluIHRoZSBsaXN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFeGlzdGluZ0FkZHJlc3NlcyhhZGRyZXNzLCBsaXN0ID0gW10pIHtcclxuICBpZiAoIWFkZHJlc3MpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1hdGNoZXNBZGRyZXNzID0gKG9iaikgPT4ge1xyXG4gICAgcmV0dXJuIG9iai5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbGlzdC5zb21lKG1hdGNoZXNBZGRyZXNzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJuR3JlYXRlclRoYW4oYSwgYikge1xyXG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5ndChiLCAxMCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBibkxlc3NUaGFuKGEsIGIpIHtcclxuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEJpZ051bWJlcihhLCAxMCkubHQoYiwgMTApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYm5HcmVhdGVyVGhhbkVxdWFsVG8oYSwgYikge1xyXG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5ndGUoYiwgMTApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYm5MZXNzVGhhbkVxdWFsVG8oYSwgYikge1xyXG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5sdGUoYiwgMTApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKHVybCkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldElzQnJvd3NlckRlcHJlY2F0ZWQoXHJcbiAgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLFxyXG4pIHtcclxuICByZXR1cm4gYnJvd3Nlci5zYXRpc2ZpZXMoT1VUREFURURfQlJPV1NFUl9WRVJTSU9OUykgPz8gZmFsc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkxIb3N0KHVybCkge1xyXG4gIHJldHVybiBnZXRVUkwodXJsKT8uaG9zdCB8fCAnJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3ROYW1lKHVybCkge1xyXG4gIHJldHVybiBnZXRVUkwodXJsKT8uaG9zdG5hbWUgfHwgJyc7XHJcbn1cclxuXHJcbi8vIE9uY2Ugd2UgcmVhY2ggdGhpcyB0aHJlc2hvbGQsIHdlIHN3aXRjaCB0byBoaWdoZXIgdW5pdFxyXG5jb25zdCBNSU5VVEVfQ1VUT0ZGID0gOTAgKiA2MDtcclxuY29uc3QgU0VDT05EX0NVVE9GRiA9IDkwO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRvSHVtYW5SZWFkYWJsZVRpbWUgPSAodCwgbWlsbGlzZWNvbmRzKSA9PiB7XHJcbiAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkIHx8IG1pbGxpc2Vjb25kcyA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5jZWlsKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xyXG4gIGlmIChzZWNvbmRzIDw9IFNFQ09ORF9DVVRPRkYpIHtcclxuICAgIHJldHVybiB0KCdnYXNUaW1pbmdTZWNvbmRzU2hvcnQnLCBbc2Vjb25kc10pO1xyXG4gIH1cclxuICBpZiAoc2Vjb25kcyA8PSBNSU5VVEVfQ1VUT0ZGKSB7XHJcbiAgICByZXR1cm4gdCgnZ2FzVGltaW5nTWludXRlc1Nob3J0JywgW01hdGguY2VpbChzZWNvbmRzIC8gNjApXSk7XHJcbiAgfVxyXG4gIHJldHVybiB0KCdnYXNUaW1pbmdIb3Vyc1Nob3J0JywgW01hdGguY2VpbChzZWNvbmRzIC8gMzYwMCldKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNsaXBib2FyZCgpIHtcclxuICB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoJycpO1xyXG59XHJcblxyXG5jb25zdCBzb2xpZGl0eVR5cGVzID0gKCkgPT4ge1xyXG4gIGNvbnN0IHR5cGVzID0gW1xyXG4gICAgJ2Jvb2wnLFxyXG4gICAgJ2FkZHJlc3MnLFxyXG4gICAgJ3N0cmluZycsXHJcbiAgICAnYnl0ZXMnLFxyXG4gICAgJ2ludCcsXHJcbiAgICAndWludCcsXHJcbiAgICAnZml4ZWQnLFxyXG4gICAgJ3VmaXhlZCcsXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgaW50cyA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxyXG4gICAgKF8sIGluZGV4KSA9PiBgaW50JHsoaW5kZXggKyAxKSAqIDh9YCxcclxuICApO1xyXG4gIGNvbnN0IHVpbnRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoMzIpKS5tYXAoXHJcbiAgICAoXywgaW5kZXgpID0+IGB1aW50JHsoaW5kZXggKyAxKSAqIDh9YCxcclxuICApO1xyXG4gIGNvbnN0IGJ5dGVzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoMzIpKS5tYXAoXHJcbiAgICAoXywgaW5kZXgpID0+IGBieXRlcyR7aW5kZXggKyAxfWAsXHJcbiAgKTtcclxuXHJcbiAgLyoqXHJcbiAgICogZml4ZWQgYW5kIHVmaXhlZFxyXG4gICAqIFRoaXMgdmFsdWUgdHlwZSBhbHNvIGNhbiBiZSBkZWNsYXJlZCBrZXl3b3JkcyBzdWNoIGFzIHVmaXhlZE14TiBhbmQgZml4ZWRNeE4uXHJcbiAgICogVGhlIE0gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGJpdHMgdGhhdCB0aGUgdHlwZSB0YWtlcyxcclxuICAgKiB3aXRoIE4gcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdGhhdCBhcmUgYXZhaWxhYmxlLlxyXG4gICAqICBNIGhhcyB0byBiZSBkaXZpc2libGUgYnkgOCwgYW5kIGEgbnVtYmVyIGZyb20gOCB0byAyNTYuXHJcbiAgICogTiBoYXMgdG8gYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDgwLCBhbHNvIGJlaW5nIGluY2x1c2l2ZS5cclxuICAgKi9cclxuICBjb25zdCBmaXhlZE0gPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcclxuICAgIChfLCBpbmRleCkgPT4gYGZpeGVkJHsoaW5kZXggKyAxKSAqIDh9YCxcclxuICApO1xyXG4gIGNvbnN0IHVmaXhlZE0gPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcclxuICAgIChfLCBpbmRleCkgPT4gYHVmaXhlZCR7KGluZGV4ICsgMSkgKiA4fWAsXHJcbiAgKTtcclxuICBjb25zdCBmaXhlZCA9IEFycmF5LmZyb20obmV3IEFycmF5KDgwKSkubWFwKChfLCBpbmRleCkgPT5cclxuICAgIGZpeGVkTS5tYXAoKGFGaXhlZE0pID0+IGAke2FGaXhlZE19eCR7aW5kZXggKyAxfWApLFxyXG4gICk7XHJcbiAgY29uc3QgdWZpeGVkID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoODApKS5tYXAoKF8sIGluZGV4KSA9PlxyXG4gICAgdWZpeGVkTS5tYXAoKGF1Rml4ZWRNKSA9PiBgJHthdUZpeGVkTX14JHtpbmRleCArIDF9YCksXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIFtcclxuICAgIC4uLnR5cGVzLFxyXG4gICAgLi4uaW50cyxcclxuICAgIC4uLnVpbnRzLFxyXG4gICAgLi4uYnl0ZXMsXHJcbiAgICAuLi5maXhlZC5mbGF0KCksXHJcbiAgICAuLi51Zml4ZWQuZmxhdCgpLFxyXG4gIF07XHJcbn07XHJcblxyXG5jb25zdCBTT0xJRElUWV9UWVBFUyA9IHNvbGlkaXR5VHlwZXMoKTtcclxuXHJcbmNvbnN0IHN0cmlwQXJyYXlUeXBlID0gKHBvdGVudGlhbEFycmF5VHlwZSkgPT5cclxuICBwb3RlbnRpYWxBcnJheVR5cGUucmVwbGFjZSgvXFxbW1swLTldKlxcXSovZ3UsICcnKTtcclxuXHJcbmNvbnN0IHN0cmlwT25lTGF5ZXJvZk5lc3RpbmcgPSAocG90ZW50aWFsQXJyYXlUeXBlKSA9PlxyXG4gIHBvdGVudGlhbEFycmF5VHlwZS5yZXBsYWNlKC9cXFtbWzAtOV0qXFxdL3UsICcnKTtcclxuXHJcbmNvbnN0IGlzQXJyYXlUeXBlID0gKHBvdGVudGlhbEFycmF5VHlwZSkgPT5cclxuICBwb3RlbnRpYWxBcnJheVR5cGUubWF0Y2goL1xcW1tbMC05XSpcXF0qL3UpICE9PSBudWxsO1xyXG5cclxuY29uc3QgaXNTb2xpZGl0eVR5cGUgPSAodHlwZSkgPT4gU09MSURJVFlfVFlQRVMuaW5jbHVkZXModHlwZSk7XHJcblxyXG5leHBvcnQgY29uc3Qgc2FuaXRpemVNZXNzYWdlID0gKG1zZywgcHJpbWFyeVR5cGUsIHR5cGVzKSA9PiB7XHJcbiAgaWYgKCF0eXBlcykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR5cGVzIGRlZmluaXRpb25gKTtcclxuICB9XHJcblxyXG4gIC8vIFByaW1hcnkgdHlwZSBjYW4gYmUgYW4gYXJyYXkuXHJcbiAgY29uc3QgaXNBcnJheSA9IHByaW1hcnlUeXBlICYmIGlzQXJyYXlUeXBlKHByaW1hcnlUeXBlKTtcclxuICBpZiAoaXNBcnJheSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdmFsdWU6IG1zZy5tYXAoKHZhbHVlKSA9PlxyXG4gICAgICAgIHNhbml0aXplTWVzc2FnZSh2YWx1ZSwgc3RyaXBPbmVMYXllcm9mTmVzdGluZyhwcmltYXJ5VHlwZSksIHR5cGVzKSxcclxuICAgICAgKSxcclxuICAgICAgdHlwZTogcHJpbWFyeVR5cGUsXHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAoaXNTb2xpZGl0eVR5cGUocHJpbWFyeVR5cGUpKSB7XHJcbiAgICByZXR1cm4geyB2YWx1ZTogbXNnLCB0eXBlOiBwcmltYXJ5VHlwZSB9O1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgbm90LCBhc3N1bWUgdG8gYmUgc3RydWN0XHJcbiAgY29uc3QgYmFzZVR5cGUgPSBpc0FycmF5ID8gc3RyaXBBcnJheVR5cGUocHJpbWFyeVR5cGUpIDogcHJpbWFyeVR5cGU7XHJcblxyXG4gIGNvbnN0IGJhc2VUeXBlRGVmaW5pdGlvbnMgPSB0eXBlc1tiYXNlVHlwZV07XHJcbiAgaWYgKCFiYXNlVHlwZURlZmluaXRpb25zKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJpbWFyeSB0eXBlIGRlZmluaXRpb25gKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhbml0aXplZFN0cnVjdCA9IHt9O1xyXG4gIGNvbnN0IG1zZ0tleXMgPSBPYmplY3Qua2V5cyhtc2cpO1xyXG4gIG1zZ0tleXMuZm9yRWFjaCgobXNnS2V5KSA9PiB7XHJcbiAgICBjb25zdCBkZWZpbmVkVHlwZSA9IE9iamVjdC52YWx1ZXMoYmFzZVR5cGVEZWZpbml0aW9ucykuZmluZChcclxuICAgICAgKGJhc2VUeXBlRGVmaW5pdGlvbikgPT4gYmFzZVR5cGVEZWZpbml0aW9uLm5hbWUgPT09IG1zZ0tleSxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCFkZWZpbmVkVHlwZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2FuaXRpemVkU3RydWN0W21zZ0tleV0gPSBzYW5pdGl6ZU1lc3NhZ2UoXHJcbiAgICAgIG1zZ1ttc2dLZXldLFxyXG4gICAgICBkZWZpbmVkVHlwZS50eXBlLFxyXG4gICAgICB0eXBlcyxcclxuICAgICk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHsgdmFsdWU6IHNhbml0aXplZFN0cnVjdCwgdHlwZTogcHJpbWFyeVR5cGUgfTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NldEltYWdlVVJMKGltYWdlLCBpcGZzR2F0ZXdheSkge1xyXG4gIGlmICghaW1hZ2UgfHwgdHlwZW9mIGltYWdlICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlwZnNHYXRld2F5ICYmIGltYWdlLnN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSkge1xyXG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZElwZnNVcmwoaXBmc0dhdGV3YXksIGltYWdlLCB0cnVlKTtcclxuICB9XHJcbiAgcmV0dXJuIGltYWdlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUb0RlY2ltYWxQbGFjZXNSZW1vdmluZ0V4dHJhWmVyb2VzKFxyXG4gIG51bWJlcmlzaCxcclxuICBudW1iZXJPZkRlY2ltYWxQbGFjZXMsXHJcbikge1xyXG4gIGlmIChudW1iZXJpc2ggPT09IHVuZGVmaW5lZCB8fCBudW1iZXJpc2ggPT09IG51bGwpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBOdW1lcmljKFxyXG4gICAgbmV3IE51bWVyaWMobnVtYmVyaXNoLCAxMCkudG9GaXhlZChudW1iZXJPZkRlY2ltYWxQbGFjZXMpLFxyXG4gICAgMTAsXHJcbiAgKS50b051bWJlcigpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgU0xJUC00NCBwcm90b2NvbCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWRcclxuICogYGNvaW5fdHlwZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBjb2luVHlwZSAtIFRoZSBTTElQLTQ0IGBjb2luX3R5cGVgIHZhbHVlIHdob3NlIG5hbWVcclxuICogdG8gcmV0cmlldmUuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRoZSBuYW1lIG9mIHRoZSBwcm90b2NvbCBpZiBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb2luVHlwZVRvUHJvdG9jb2xOYW1lKGNvaW5UeXBlKSB7XHJcbiAgaWYgKFN0cmluZyhjb2luVHlwZSkgPT09ICcxJykge1xyXG4gICAgcmV0dXJuICdUZXN0IE5ldHdvcmtzJztcclxuICB9XHJcbiAgcmV0dXJuIHNsaXA0NFtjb2luVHlwZV0/Lm5hbWUgfHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdHMgXCJudWxsaXNobmVzc1wiLiBVc2VkIHRvIGd1YXJkIGEgc2VjdGlvbiBvZiBhIGNvbXBvbmVudCBmcm9tIGJlaW5nXHJcbiAqIHJlbmRlcmVkIGJhc2VkIG9uIGEgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIEEgdmFsdWUgKGxpdGVyYWxseSBhbnl0aGluZykuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbGlzaCh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5cblxyXG4vKipcclxuICogVGhlIG1ldGhvZCBlc2NhcGUgUlRMIGNoYXJhY3RlciBpbiBzdHJpbmdcclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7KHN0cmluZ3wqKX0gZXNjYXBlZCBzdHJpbmcgb3Igb3JpZ2luYWwgcGFyYW0gdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBzYW5pdGl6ZVN0cmluZyA9ICh2YWx1ZSkgPT4ge1xyXG4gIGlmICghdmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgaWYgKCFsb2Rhc2guaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGNvbnN0IHJlZ2V4ID0gL1xcdTIwMkUvZ2l1O1xyXG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlZ2V4LCAnXFxcXHUyMDJFJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgY2hlY2tzIGN1cnJlbnQgcHJvdmlkZXIgdHlwZSBhbmQgcmV0dXJucyBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcHJvdmlkZXJcclxuICogQHBhcmFtIHsqfSB0XHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5ldHdvcmtOYW1lRnJvbVByb3ZpZGVyVHlwZSA9IChwcm92aWRlck5hbWUpID0+IHtcclxuICBpZiAocHJvdmlkZXJOYW1lID09PSBORVRXT1JLX1RZUEVTLlJQQykge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuICByZXR1cm4gcHJvdmlkZXJOYW1lO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4ga2V5cmluZyB0eXBlIGlzIGFibGUgdG8gZXhwb3J0IGFuIGFjY291bnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBrZXlyaW5nVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBrZXlyaW5nLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGZhbHNlYCBpZiB0aGUga2V5cmluZyB0eXBlIGluY2x1ZGVzICdIYXJkd2FyZScgb3IgJ1NuYXAnLCBgdHJ1ZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzQWJsZVRvRXhwb3J0QWNjb3VudCA9IChrZXlyaW5nVHlwZSA9ICcnKSA9PiB7XHJcbiAgcmV0dXJuICFrZXlyaW5nVHlwZS5pbmNsdWRlcygnSGFyZHdhcmUnKSAmJiAha2V5cmluZ1R5cGUuaW5jbHVkZXMoJ1NuYXAnKTtcclxufTtcclxuIl0sInByZUV4aXN0aW5nQ29tbWVudCI6Ii8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXAifQ==
