LavaPack.loadBundle([
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uniqueArray.js", {"./_internals/ArrayArbitrary":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\ArrayArbitrary.js","./_internals/helpers/CustomEqualSet":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\CustomEqualSet.js","./_internals/helpers/MaxLengthFromMinLength":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\MaxLengthFromMinLength.js","./_internals/helpers/SameValueSet":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SameValueSet.js","./_internals/helpers/SameValueZeroSet":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\SameValueZeroSet.js","./_internals/helpers/StrictlyEqualSet":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\StrictlyEqualSet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CuniqueArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uniqueArray = void 0;
const ArrayArbitrary_1 = require("./_internals/ArrayArbitrary");
const MaxLengthFromMinLength_1 = require("./_internals/helpers/MaxLengthFromMinLength");
const CustomEqualSet_1 = require("./_internals/helpers/CustomEqualSet");
const StrictlyEqualSet_1 = require("./_internals/helpers/StrictlyEqualSet");
const SameValueSet_1 = require("./_internals/helpers/SameValueSet");
const SameValueZeroSet_1 = require("./_internals/helpers/SameValueZeroSet");
function buildUniqueArraySetBuilder(constraints) {
    if (typeof constraints.comparator === 'function') {
        if (constraints.selector === undefined) {
            const comparator = constraints.comparator;
            const isEqualForBuilder = (nextA, nextB) => comparator(nextA.value_, nextB.value_);
            return () => new CustomEqualSet_1.CustomEqualSet(isEqualForBuilder);
        }
        const comparator = constraints.comparator;
        const selector = constraints.selector;
        const refinedSelector = (next) => selector(next.value_);
        const isEqualForBuilder = (nextA, nextB) => comparator(refinedSelector(nextA), refinedSelector(nextB));
        return () => new CustomEqualSet_1.CustomEqualSet(isEqualForBuilder);
    }
    const selector = constraints.selector || ((v) => v);
    const refinedSelector = (next) => selector(next.value_);
    switch (constraints.comparator) {
        case 'IsStrictlyEqual':
            return () => new StrictlyEqualSet_1.StrictlyEqualSet(refinedSelector);
        case 'SameValueZero':
            return () => new SameValueZeroSet_1.SameValueZeroSet(refinedSelector);
        case 'SameValue':
        case undefined:
            return () => new SameValueSet_1.SameValueSet(refinedSelector);
    }
}
function uniqueArray(arb, constraints = {}) {
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.MaxLengthUpperBound;
    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(constraints.size, minLength, maxLength, constraints.maxLength !== undefined);
    const depthIdentifier = constraints.depthIdentifier;
    const setBuilder = buildUniqueArraySetBuilder(constraints);
    const arrayArb = new ArrayArbitrary_1.ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, []);
    if (minLength === 0)
        return arrayArb;
    return arrayArb.filter((tab) => tab.length >= minLength);
}
exports.uniqueArray = uniqueArray;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uniqueArray.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uuid.js", {"./_internals/builders/PaddedNumberArbitraryBuilder":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\PaddedNumberArbitraryBuilder.js","./_internals/mappers/PaddedEightsToUuid":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\PaddedEightsToUuid.js","./tuple":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5Cuuid.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uuid = void 0;
const tuple_1 = require("./tuple");
const PaddedNumberArbitraryBuilder_1 = require("./_internals/builders/PaddedNumberArbitraryBuilder");
const PaddedEightsToUuid_1 = require("./_internals/mappers/PaddedEightsToUuid");
function uuid() {
    const padded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const secondPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x10000000, 0x5fffffff);
    const thirdPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, tuple_1.tuple)(padded, secondPadded, thirdPadded, padded).map(PaddedEightsToUuid_1.paddedEightsToUuidMapper, PaddedEightsToUuid_1.paddedEightsToUuidUnmapper);
}
exports.uuid = uuid;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uuid.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uuidV.js", {"./_internals/builders/PaddedNumberArbitraryBuilder":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\PaddedNumberArbitraryBuilder.js","./_internals/mappers/PaddedEightsToUuid":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\PaddedEightsToUuid.js","./tuple":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CuuidV.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uuidV = void 0;
const tuple_1 = require("./tuple");
const PaddedNumberArbitraryBuilder_1 = require("./_internals/builders/PaddedNumberArbitraryBuilder");
const PaddedEightsToUuid_1 = require("./_internals/mappers/PaddedEightsToUuid");
function uuidV(versionNumber) {
    const padded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const offsetSecond = versionNumber * 0x10000000;
    const secondPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(offsetSecond, offsetSecond + 0x0fffffff);
    const thirdPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, tuple_1.tuple)(padded, secondPadded, thirdPadded, padded).map(PaddedEightsToUuid_1.paddedEightsToUuidMapper, PaddedEightsToUuid_1.paddedEightsToUuidUnmapper);
}
exports.uuidV = uuidV;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\uuidV.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js", {"./_internals/builders/CharacterRangeArbitraryBuilder":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\CharacterRangeArbitraryBuilder.js","./constant":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\constant.js","./domain":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\domain.js","./ipV4":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\ipV4.js","./ipV4Extended":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\ipV4Extended.js","./ipV6":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\ipV6.js","./nat":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\nat.js","./oneof":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js","./option":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\option.js","./stringOf":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\stringOf.js","./tuple":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebAuthority.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webAuthority = void 0;
const CharacterRangeArbitraryBuilder_1 = require("./_internals/builders/CharacterRangeArbitraryBuilder");
const constant_1 = require("./constant");
const domain_1 = require("./domain");
const ipV4_1 = require("./ipV4");
const ipV4Extended_1 = require("./ipV4Extended");
const ipV6_1 = require("./ipV6");
const nat_1 = require("./nat");
const oneof_1 = require("./oneof");
const option_1 = require("./option");
const stringOf_1 = require("./stringOf");
const tuple_1 = require("./tuple");
function hostUserInfo(size) {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':'];
    return (0, stringOf_1.stringOf)((0, CharacterRangeArbitraryBuilder_1.buildAlphaNumericPercentArbitrary)(others), { size });
}
function userHostPortMapper([u, h, p]) {
    return (u === null ? '' : `${u}@`) + h + (p === null ? '' : `:${p}`);
}
function userHostPortUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported');
    }
    const atPosition = value.indexOf('@');
    const user = atPosition !== -1 ? value.substring(0, atPosition) : null;
    const portRegex = /:(\d+)$/;
    const m = portRegex.exec(value);
    const port = m !== null ? Number(m[1]) : null;
    const host = m !== null ? value.substring(atPosition + 1, value.length - m[1].length - 1) : value.substring(atPosition + 1);
    return [user, host, port];
}
function bracketedMapper(s) {
    return `[${s}]`;
}
function bracketedUnmapper(value) {
    if (typeof value !== 'string' || value[0] !== '[' || value[value.length - 1] !== ']') {
        throw new Error('Unsupported');
    }
    return value.substring(1, value.length - 1);
}
function webAuthority(constraints) {
    const c = constraints || {};
    const size = c.size;
    const hostnameArbs = [(0, domain_1.domain)({ size })]
        .concat(c.withIPv4 === true ? [(0, ipV4_1.ipV4)()] : [])
        .concat(c.withIPv6 === true ? [(0, ipV6_1.ipV6)().map(bracketedMapper, bracketedUnmapper)] : [])
        .concat(c.withIPv4Extended === true ? [(0, ipV4Extended_1.ipV4Extended)()] : []);
    return (0, tuple_1.tuple)(c.withUserInfo === true ? (0, option_1.option)(hostUserInfo(size)) : (0, constant_1.constant)(null), (0, oneof_1.oneof)(...hostnameArbs), c.withPort === true ? (0, option_1.option)((0, nat_1.nat)(65535)) : (0, constant_1.constant)(null)).map(userHostPortMapper, userHostPortUnmapper);
}
exports.webAuthority = webAuthority;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webFragments.js", {"./_internals/builders/UriQueryOrFragmentArbitraryBuilder":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\UriQueryOrFragmentArbitraryBuilder.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebFragments.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webFragments = void 0;
const UriQueryOrFragmentArbitraryBuilder_1 = require("./_internals/builders/UriQueryOrFragmentArbitraryBuilder");
function webFragments(constraints = {}) {
    return (0, UriQueryOrFragmentArbitraryBuilder_1.buildUriQueryOrFragmentArbitrary)(constraints.size);
}
exports.webFragments = webFragments;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webFragments.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js", {"./_internals/builders/UriQueryOrFragmentArbitraryBuilder":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\UriQueryOrFragmentArbitraryBuilder.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebQueryParameters.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webQueryParameters = void 0;
const UriQueryOrFragmentArbitraryBuilder_1 = require("./_internals/builders/UriQueryOrFragmentArbitraryBuilder");
function webQueryParameters(constraints = {}) {
    return (0, UriQueryOrFragmentArbitraryBuilder_1.buildUriQueryOrFragmentArbitrary)(constraints.size);
}
exports.webQueryParameters = webQueryParameters;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webSegment.js", {"./_internals/builders/CharacterRangeArbitraryBuilder":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\CharacterRangeArbitraryBuilder.js","./stringOf":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\stringOf.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebSegment.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webSegment = void 0;
const CharacterRangeArbitraryBuilder_1 = require("./_internals/builders/CharacterRangeArbitraryBuilder");
const stringOf_1 = require("./stringOf");
function webSegment(constraints = {}) {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@'];
    return (0, stringOf_1.stringOf)((0, CharacterRangeArbitraryBuilder_1.buildAlphaNumericPercentArbitrary)(others), { size: constraints.size });
}
exports.webSegment = webSegment;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webSegment.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webUrl.js", {"./_internals/builders/UriPathArbitraryBuilder":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\builders\\UriPathArbitraryBuilder.js","./_internals/helpers/MaxLengthFromMinLength":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\MaxLengthFromMinLength.js","./_internals/mappers/PartsToUrl":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\mappers\\PartsToUrl.js","./constant":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\constant.js","./constantFrom":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\constantFrom.js","./option":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\option.js","./tuple":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","./webAuthority":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js","./webFragments":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webFragments.js","./webQueryParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Carbitrary%5CwebUrl.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webUrl = void 0;
const constantFrom_1 = require("./constantFrom");
const constant_1 = require("./constant");
const option_1 = require("./option");
const tuple_1 = require("./tuple");
const webQueryParameters_1 = require("./webQueryParameters");
const webFragments_1 = require("./webFragments");
const webAuthority_1 = require("./webAuthority");
const PartsToUrl_1 = require("./_internals/mappers/PartsToUrl");
const MaxLengthFromMinLength_1 = require("./_internals/helpers/MaxLengthFromMinLength");
const UriPathArbitraryBuilder_1 = require("./_internals/builders/UriPathArbitraryBuilder");
function webUrl(constraints) {
    const c = constraints || {};
    const resolvedSize = (0, MaxLengthFromMinLength_1.resolveSize)(c.size);
    const resolvedAuthoritySettingsSize = c.authoritySettings !== undefined && c.authoritySettings.size !== undefined
        ? (0, MaxLengthFromMinLength_1.relativeSizeToSize)(c.authoritySettings.size, resolvedSize)
        : resolvedSize;
    const resolvedAuthoritySettings = Object.assign(Object.assign({}, c.authoritySettings), { size: resolvedAuthoritySettingsSize });
    const validSchemes = c.validSchemes || ['http', 'https'];
    const schemeArb = (0, constantFrom_1.constantFrom)(...validSchemes);
    const authorityArb = (0, webAuthority_1.webAuthority)(resolvedAuthoritySettings);
    const pathArb = (0, UriPathArbitraryBuilder_1.buildUriPathArbitrary)(resolvedSize);
    return (0, tuple_1.tuple)(schemeArb, authorityArb, pathArb, c.withQueryParameters === true ? (0, option_1.option)((0, webQueryParameters_1.webQueryParameters)({ size: resolvedSize })) : (0, constant_1.constant)(null), c.withFragments === true ? (0, option_1.option)((0, webFragments_1.webFragments)({ size: resolvedSize })) : (0, constant_1.constant)(null)).map(PartsToUrl_1.partsToUrlMapper, PartsToUrl_1.partsToUrlUnmapper);
}
exports.webUrl = webUrl;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\arbitrary\\webUrl.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js", {"../../../stream/Stream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js","../../symbols":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\symbols.js","./Value":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Carbitrary%5Cdefinition%5CArbitrary.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertIsArbitrary = exports.isArbitrary = exports.Arbitrary = void 0;
const Stream_1 = require("../../../stream/Stream");
const symbols_1 = require("../../symbols");
const Value_1 = require("./Value");
class Arbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper, unmapper) {
        return new MapArbitrary(this, mapper, unmapper);
    }
    chain(chainer) {
        return new ChainArbitrary(this, chainer);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
exports.Arbitrary = Arbitrary;
class ChainArbitrary extends Arbitrary {
    constructor(arb, chainer) {
        super();
        this.arb = arb;
        this.chainer = chainer;
    }
    generate(mrng, biasFactor) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng, biasFactor);
        return this.valueChainer(src, mrng, clonedMrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return (!context.stoppedForOriginal
                ? this.arb
                    .shrink(context.originalValue, context.originalContext)
                    .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))
                : Stream_1.Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
                const newContext = Object.assign(Object.assign({}, context), { chainedContext: dst.context, stoppedForOriginal: true });
                return new Value_1.Value(dst.value_, newContext);
            }));
        }
        return Stream_1.Stream.nil();
    }
    valueChainer(v, generateMrng, clonedMrng, biasFactor) {
        const chainedArbitrary = this.chainer(v.value_);
        const dst = chainedArbitrary.generate(generateMrng, biasFactor);
        const context = {
            originalBias: biasFactor,
            originalValue: v.value_,
            originalContext: v.context,
            stoppedForOriginal: false,
            chainedArbitrary,
            chainedContext: dst.context,
            clonedMrng,
        };
        return new Value_1.Value(dst.value_, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalBias' in context &&
            'originalValue' in context &&
            'originalContext' in context &&
            'stoppedForOriginal' in context &&
            'chainedArbitrary' in context &&
            'chainedContext' in context &&
            'clonedMrng' in context);
    }
}
class MapArbitrary extends Arbitrary {
    constructor(arb, mapper, unmapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
        this.unmapper = unmapper;
        this.bindValueMapper = this.valueMapper.bind(this);
    }
    generate(mrng, biasFactor) {
        const g = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(g);
    }
    canShrinkWithoutContext(value) {
        if (this.unmapper !== undefined) {
            try {
                const unmapped = this.unmapper(value);
                return this.arb.canShrinkWithoutContext(unmapped);
            }
            catch (_err) {
                return false;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
        }
        if (this.unmapper !== undefined) {
            const unmapped = this.unmapper(value);
            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
        }
        return Stream_1.Stream.nil();
    }
    mapperWithCloneIfNeeded(v) {
        const sourceValue = v.value;
        const mappedValue = this.mapper(sourceValue);
        if (v.hasToBeCloned &&
            ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&
            Object.isExtensible(mappedValue) &&
            !(0, symbols_1.hasCloneMethod)(mappedValue)) {
            Object.defineProperty(mappedValue, symbols_1.cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
        }
        return [mappedValue, sourceValue];
    }
    valueMapper(v) {
        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
        const context = { originalValue: sourceValue, originalContext: v.context };
        return new Value_1.Value(mappedValue, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalValue' in context &&
            'originalContext' in context);
    }
}
class FilterArbitrary extends Arbitrary {
    constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
        this.bindRefinementOnValue = this.refinementOnValue.bind(this);
    }
    generate(mrng, biasFactor) {
        while (true) {
            const g = this.arb.generate(mrng, biasFactor);
            if (this.refinementOnValue(g)) {
                return g;
            }
        }
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
    }
    refinementOnValue(v) {
        return this.refinement(v.value);
    }
}
class NoShrinkArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        return this.arb.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
    noShrink() {
        return this;
    }
}
class NoBiasArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, _biasFactor) {
        return this.arb.generate(mrng, undefined);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context);
    }
    noBias() {
        return this;
    }
}
function isArbitrary(instance) {
    return (typeof instance === 'object' &&
        instance !== null &&
        'generate' in instance &&
        'shrink' in instance &&
        'canShrinkWithoutContext' in instance);
}
exports.isArbitrary = isArbitrary;
function assertIsArbitrary(instance) {
    if (!isArbitrary(instance)) {
        throw new Error('Unexpected value received: not an instance of Arbitrary');
    }
}
exports.assertIsArbitrary = assertIsArbitrary;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js", {"../../symbols":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\symbols.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Carbitrary%5Cdefinition%5CValue.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Value = void 0;
const symbols_1 = require("../../symbols");
class Value {
    constructor(value_, context, customGetValue = undefined) {
        this.value_ = value_;
        this.context = context;
        this.hasToBeCloned = customGetValue !== undefined || (0, symbols_1.hasCloneMethod)(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });
        }
        else {
            this.value = value_;
        }
    }
    getValue() {
        if (this.hasToBeCloned) {
            if (!this.readOnce) {
                this.readOnce = true;
                return this.value_;
            }
            return this.value_[symbols_1.cloneMethod]();
        }
        return this.value_;
    }
}
exports.Value = Value;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\model\\ModelRunner.js", {"./commands/ScheduledCommand":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\model\\commands\\ScheduledCommand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5CModelRunner.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scheduledModelRun = exports.asyncModelRun = exports.modelRun = void 0;
const ScheduledCommand_1 = require("./commands/ScheduledCommand");
const genericModelRun = (s, cmds, initialValue, runCmd, then) => {
    return s.then((o) => {
        const { model, real } = o;
        let state = initialValue;
        for (const c of cmds) {
            state = then(state, () => {
                return runCmd(c, model, real);
            });
        }
        return state;
    });
};
const internalModelRun = (s, cmds) => {
    const then = (_p, c) => c();
    const setupProducer = {
        then: (fun) => {
            fun(s());
            return undefined;
        },
    };
    const runSync = (cmd, m, r) => {
        if (cmd.check(m))
            cmd.run(m, r);
        return undefined;
    };
    return genericModelRun(setupProducer, cmds, undefined, runSync, then);
};
const isAsyncSetup = (s) => {
    return typeof s.then === 'function';
};
const internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {
    const then = (p, c) => p.then(c);
    const setupProducer = {
        then: (fun) => {
            const out = s();
            if (isAsyncSetup(out))
                return out.then(fun);
            else
                return fun(out);
        },
    };
    const runAsync = async (cmd, m, r) => {
        if (await cmd.check(m))
            await cmd.run(m, r);
    };
    return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
    internalModelRun(s, cmds);
}
exports.modelRun = modelRun;
async function asyncModelRun(s, cmds) {
    await internalAsyncModelRun(s, cmds);
}
exports.asyncModelRun = asyncModelRun;
async function scheduledModelRun(scheduler, s, cmds) {
    const scheduledCommands = (0, ScheduledCommand_1.scheduleCommands)(scheduler, cmds);
    const out = internalAsyncModelRun(s, scheduledCommands, scheduler.schedule(Promise.resolve(), 'startModel'));
    await scheduler.waitAll();
    await out;
}
exports.scheduledModelRun = scheduledModelRun;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\ModelRunner.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\model\\ReplayPath.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5CReplayPath.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplayPath = void 0;
class ReplayPath {
    static parse(replayPathStr) {
        const [serializedCount, serializedChanges] = replayPathStr.split(':');
        const counts = this.parseCounts(serializedCount);
        const changes = this.parseChanges(serializedChanges);
        return this.parseOccurences(counts, changes);
    }
    static stringify(replayPath) {
        const occurences = this.countOccurences(replayPath);
        const serializedCount = this.stringifyCounts(occurences);
        const serializedChanges = this.stringifyChanges(occurences);
        return `${serializedCount}:${serializedChanges}`;
    }
    static intToB64(n) {
        if (n < 26)
            return String.fromCharCode(n + 65);
        if (n < 52)
            return String.fromCharCode(n + 97 - 26);
        if (n < 62)
            return String.fromCharCode(n + 48 - 52);
        return String.fromCharCode(n === 62 ? 43 : 47);
    }
    static b64ToInt(c) {
        if (c >= 'a')
            return c.charCodeAt(0) - 97 + 26;
        if (c >= 'A')
            return c.charCodeAt(0) - 65;
        if (c >= '0')
            return c.charCodeAt(0) - 48 + 52;
        return c === '+' ? 62 : 63;
    }
    static countOccurences(replayPath) {
        return replayPath.reduce((counts, cur) => {
            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)
                counts.push({ value: cur, count: 1 });
            else
                counts[counts.length - 1].count += 1;
            return counts;
        }, []);
    }
    static parseOccurences(counts, changes) {
        const replayPath = [];
        for (let idx = 0; idx !== counts.length; ++idx) {
            const count = counts[idx];
            const value = changes[idx];
            for (let num = 0; num !== count; ++num)
                replayPath.push(value);
        }
        return replayPath;
    }
    static stringifyChanges(occurences) {
        let serializedChanges = '';
        for (let idx = 0; idx < occurences.length; idx += 6) {
            const changesInt = occurences
                .slice(idx, idx + 6)
                .reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);
            serializedChanges += this.intToB64(changesInt);
        }
        return serializedChanges;
    }
    static parseChanges(serializedChanges) {
        const changesInt = serializedChanges.split('').map((c) => this.b64ToInt(c));
        const changes = [];
        for (let idx = 0; idx !== changesInt.length; ++idx) {
            let current = changesInt[idx];
            for (let n = 0; n !== 6; ++n, current >>= 1) {
                changes.push(current % 2 === 1);
            }
        }
        return changes;
    }
    static stringifyCounts(occurences) {
        return occurences.map(({ count }) => this.intToB64(count - 1)).join('');
    }
    static parseCounts(serializedCount) {
        return serializedCount.split('').map((c) => this.b64ToInt(c) + 1);
    }
}
exports.ReplayPath = ReplayPath;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\ReplayPath.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\model\\commands\\CommandWrapper.js", {"../../../utils/stringify":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\utils\\stringify.js","../../symbols":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\symbols.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5Ccommands%5CCommandWrapper.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandWrapper = void 0;
const stringify_1 = require("../../../utils/stringify");
const symbols_1 = require("../../symbols");
class CommandWrapper {
    constructor(cmd) {
        this.cmd = cmd;
        this.hasRan = false;
        if ((0, stringify_1.hasToStringMethod)(cmd)) {
            const method = cmd[stringify_1.toStringMethod];
            this[stringify_1.toStringMethod] = function toStringMethod() {
                return method.call(cmd);
            };
        }
        if ((0, stringify_1.hasAsyncToStringMethod)(cmd)) {
            const method = cmd[stringify_1.asyncToStringMethod];
            this[stringify_1.asyncToStringMethod] = function asyncToStringMethod() {
                return method.call(cmd);
            };
        }
    }
    check(m) {
        return this.cmd.check(m);
    }
    run(m, r) {
        this.hasRan = true;
        return this.cmd.run(m, r);
    }
    clone() {
        if ((0, symbols_1.hasCloneMethod)(this.cmd))
            return new CommandWrapper(this.cmd[symbols_1.cloneMethod]());
        return new CommandWrapper(this.cmd);
    }
    toString() {
        return this.cmd.toString();
    }
}
exports.CommandWrapper = CommandWrapper;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\commands\\CommandWrapper.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\model\\commands\\CommandsIterable.js", {"../../symbols":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\symbols.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5Ccommands%5CCommandsIterable.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsIterable = void 0;
const symbols_1 = require("../../symbols");
class CommandsIterable {
    constructor(commands, metadataForReplay) {
        this.commands = commands;
        this.metadataForReplay = metadataForReplay;
    }
    [Symbol.iterator]() {
        return this.commands[Symbol.iterator]();
    }
    [symbols_1.cloneMethod]() {
        return new CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
    }
    toString() {
        const serializedCommands = this.commands
            .filter((c) => c.hasRan)
            .map((c) => c.toString())
            .join(',');
        const metadata = this.metadataForReplay();
        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
    }
}
exports.CommandsIterable = CommandsIterable;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\commands\\CommandsIterable.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\model\\commands\\ScheduledCommand.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cmodel%5Ccommands%5CScheduledCommand.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scheduleCommands = exports.ScheduledCommand = void 0;
class ScheduledCommand {
    constructor(s, cmd) {
        this.s = s;
        this.cmd = cmd;
    }
    async check(m) {
        let error = null;
        let checkPassed = false;
        const status = await this.s.scheduleSequence([
            {
                label: `check@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        checkPassed = await Promise.resolve(this.cmd.check(m));
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
        return checkPassed;
    }
    async run(m, r) {
        let error = null;
        const status = await this.s.scheduleSequence([
            {
                label: `run@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        await this.cmd.run(m, r);
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
    }
}
exports.ScheduledCommand = ScheduledCommand;
const scheduleCommands = function* (s, cmds) {
    for (const cmd of cmds) {
        yield new ScheduledCommand(s, cmd);
    }
};
exports.scheduleCommands = scheduleCommands;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\model\\commands\\ScheduledCommand.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\Pre.js", {"./PreconditionFailure":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cprecondition%5CPre.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pre = void 0;
const PreconditionFailure_1 = require("./PreconditionFailure");
function pre(expectTruthy) {
    if (!expectTruthy) {
        throw new PreconditionFailure_1.PreconditionFailure();
    }
}
exports.pre = pre;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\precondition\\Pre.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cprecondition%5CPreconditionFailure.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreconditionFailure = void 0;
class PreconditionFailure extends Error {
    constructor(interruptExecution = false) {
        super();
        this.interruptExecution = interruptExecution;
        this.footprint = PreconditionFailure.SharedFootPrint;
    }
    static isFailure(err) {
        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
    }
}
exports.PreconditionFailure = PreconditionFailure;
PreconditionFailure.SharedFootPrint = Symbol('fast-check/PreconditionFailure');

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.generic.js", {"../../arbitrary/_internals/helpers/NoUndefinedAsContext":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\NoUndefinedAsContext.js","../../stream/Stream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js","../precondition/PreconditionFailure":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","../runner/configuration/GlobalParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./IRawProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CAsyncProperty.generic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncProperty = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
const IRawProperty_1 = require("./IRawProperty");
const GlobalParameters_1 = require("../runner/configuration/GlobalParameters");
const Stream_1 = require("../../stream/Stream");
const NoUndefinedAsContext_1 = require("../../arbitrary/_internals/helpers/NoUndefinedAsContext");
class AsyncProperty {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined && beforeEach !== undefined) {
            throw Error('Global "asyncBeforeEach" and "beforeEach" parameters can\'t be set at the same time when running async properties');
        }
        if (asyncAfterEach !== undefined && afterEach !== undefined) {
            throw Error('Global "asyncAfterEach" and "afterEach" parameters can\'t be set at the same time when running async properties');
        }
        this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;
        this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, IRawProperty_1.runIdToFrequency)(runId) : undefined);
        return (0, NoUndefinedAsContext_1.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {
            return Stream_1.Stream.nil();
        }
        const safeContext = value.context !== NoUndefinedAsContext_1.UndefinedContextPlaceholder ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map(NoUndefinedAsContext_1.noUndefinedAsContext);
    }
    async run(v) {
        await this.beforeEachHook();
        try {
            const output = await this.predicate(v);
            return output == null || output === true
                ? null
                : { error: undefined, errorMessage: 'Property failed by returning false' };
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack) {
                return { error: err, errorMessage: `${err}\n\nStack trace: ${err.stack}` };
            }
            return { error: err, errorMessage: String(err) };
        }
        finally {
            await this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.AsyncProperty = AsyncProperty;
AsyncProperty.dummyHook = () => { };

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.generic.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.js", {"../../arbitrary/_internals/AlwaysShrinkableArbitrary":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\AlwaysShrinkableArbitrary.js","../../arbitrary/tuple":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","../arbitrary/definition/Arbitrary":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js","./AsyncProperty.generic":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.generic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CAsyncProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncProperty = void 0;
const Arbitrary_1 = require("../arbitrary/definition/Arbitrary");
const tuple_1 = require("../../arbitrary/tuple");
const AsyncProperty_generic_1 = require("./AsyncProperty.generic");
const AlwaysShrinkableArbitrary_1 = require("../../arbitrary/_internals/AlwaysShrinkableArbitrary");
function asyncProperty(...args) {
    if (args.length < 2) {
        throw new Error('asyncProperty expects at least two parameters');
    }
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    arbs.forEach(Arbitrary_1.assertIsArbitrary);
    const mappedArbs = arbs.map((arb) => new AlwaysShrinkableArbitrary_1.AlwaysShrinkableArbitrary(arb));
    return new AsyncProperty_generic_1.AsyncProperty((0, tuple_1.tuple)(...mappedArbs), (t) => p(...t));
}
exports.asyncProperty = asyncProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CIRawProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runIdToFrequency = void 0;
const runIdToFrequency = (runId) => 2 + Math.floor(Math.log(runId + 1) / Math.log(10));
exports.runIdToFrequency = runIdToFrequency;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\IgnoreEqualValuesProperty.js", {"../../utils/stringify":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\utils\\stringify.js","../precondition/PreconditionFailure":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CIgnoreEqualValuesProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoreEqualValuesProperty = void 0;
const stringify_1 = require("../../utils/stringify");
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
function fromSyncCached(cachedValue) {
    return cachedValue === null ? new PreconditionFailure_1.PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
    if (data[1])
        return data[0].then(fromSyncCached);
    return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
    return fromCached(cachedValue, isAsync);
}
class IgnoreEqualValuesProperty {
    constructor(property, skipRuns) {
        this.property = property;
        this.skipRuns = skipRuns;
        this.coveredCases = new Map();
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        const stringifiedValue = (0, stringify_1.stringify)(v);
        if (this.coveredCases.has(stringifiedValue)) {
            const lastOutput = this.coveredCases.get(stringifiedValue);
            if (!this.skipRuns) {
                return lastOutput;
            }
            return fromCachedUnsafe(lastOutput, this.property.isAsync());
        }
        const out = this.property.run(v);
        this.coveredCases.set(stringifiedValue, out);
        return out;
    }
}
exports.IgnoreEqualValuesProperty = IgnoreEqualValuesProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\IgnoreEqualValuesProperty.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\Property.generic.js", {"../../arbitrary/_internals/helpers/NoUndefinedAsContext":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\NoUndefinedAsContext.js","../../stream/Stream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js","../precondition/PreconditionFailure":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","../runner/configuration/GlobalParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./IRawProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\IRawProperty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CProperty.generic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Property = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
const IRawProperty_1 = require("./IRawProperty");
const GlobalParameters_1 = require("../runner/configuration/GlobalParameters");
const Stream_1 = require("../../stream/Stream");
const NoUndefinedAsContext_1 = require("../../arbitrary/_internals/helpers/NoUndefinedAsContext");
class Property {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach, } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined) {
            throw Error('"asyncBeforeEach" can\'t be set when running synchronous properties');
        }
        if (asyncAfterEach !== undefined) {
            throw Error('"asyncAfterEach" can\'t be set when running synchronous properties');
        }
        this.beforeEachHook = beforeEach;
        this.afterEachHook = afterEach;
    }
    isAsync() {
        return false;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, IRawProperty_1.runIdToFrequency)(runId) : undefined);
        return (0, NoUndefinedAsContext_1.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {
            return Stream_1.Stream.nil();
        }
        const safeContext = value.context !== NoUndefinedAsContext_1.UndefinedContextPlaceholder ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map(NoUndefinedAsContext_1.noUndefinedAsContext);
    }
    run(v) {
        this.beforeEachHook();
        try {
            const output = this.predicate(v);
            return output == null || output === true
                ? null
                : { error: undefined, errorMessage: 'Property failed by returning false' };
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack) {
                return { error: err, errorMessage: `${err}\n\nStack trace: ${err.stack}` };
            }
            return { error: err, errorMessage: String(err) };
        }
        finally {
            this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.Property = Property;
Property.dummyHook = () => { };

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\Property.generic.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\Property.js", {"../../arbitrary/_internals/AlwaysShrinkableArbitrary":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\AlwaysShrinkableArbitrary.js","../../arbitrary/tuple":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","../arbitrary/definition/Arbitrary":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js","./Property.generic":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\Property.generic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.property = void 0;
const Arbitrary_1 = require("../arbitrary/definition/Arbitrary");
const tuple_1 = require("../../arbitrary/tuple");
const Property_generic_1 = require("./Property.generic");
const AlwaysShrinkableArbitrary_1 = require("../../arbitrary/_internals/AlwaysShrinkableArbitrary");
function property(...args) {
    if (args.length < 2) {
        throw new Error('property expects at least two parameters');
    }
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    arbs.forEach(Arbitrary_1.assertIsArbitrary);
    const mappedArbs = arbs.map((arb) => new AlwaysShrinkableArbitrary_1.AlwaysShrinkableArbitrary(arb));
    return new Property_generic_1.Property((0, tuple_1.tuple)(...mappedArbs), (t) => p(...t));
}
exports.property = property;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\Property.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\SkipAfterProperty.js", {"../precondition/PreconditionFailure":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CSkipAfterProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkipAfterProperty = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
class SkipAfterProperty {
    constructor(property, getTime, timeLimit, interruptExecution) {
        this.property = property;
        this.getTime = getTime;
        this.interruptExecution = interruptExecution;
        this.skipAfterTime = this.getTime() + timeLimit;
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        if (this.getTime() >= this.skipAfterTime) {
            const preconditionFailure = new PreconditionFailure_1.PreconditionFailure(this.interruptExecution);
            if (this.isAsync()) {
                return Promise.resolve(preconditionFailure);
            }
            else {
                return preconditionFailure;
            }
        }
        return this.property.run(v);
    }
}
exports.SkipAfterProperty = SkipAfterProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\SkipAfterProperty.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\TimeoutProperty.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CTimeoutProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeoutProperty = void 0;
const timeoutAfter = (timeMs) => {
    let timeoutHandle = null;
    const promise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => {
            resolve({ error: undefined, errorMessage: `Property timeout: exceeded limit of ${timeMs} milliseconds` });
        }, timeMs);
    });
    return {
        clear: () => clearTimeout(timeoutHandle),
        promise,
    };
};
class TimeoutProperty {
    constructor(property, timeMs) {
        this.property = property;
        this.timeMs = timeMs;
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    async run(v) {
        const t = timeoutAfter(this.timeMs);
        const propRun = Promise.race([this.property.run(v), t.promise]);
        propRun.then(t.clear, t.clear);
        return propRun;
    }
}
exports.TimeoutProperty = TimeoutProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\TimeoutProperty.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Cproperty%5CUnbiasedProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnbiasedProperty = void 0;
class UnbiasedProperty {
    constructor(property) {
        this.property = property;
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, _runId) {
        return this.property.generate(mrng, undefined);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        return this.property.run(v);
    }
}
exports.UnbiasedProperty = UnbiasedProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\DecorateProperty.js", {"../property/IgnoreEqualValuesProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\IgnoreEqualValuesProperty.js","../property/SkipAfterProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\SkipAfterProperty.js","../property/TimeoutProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\TimeoutProperty.js","../property/UnbiasedProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CDecorateProperty.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateProperty = void 0;
const SkipAfterProperty_1 = require("../property/SkipAfterProperty");
const TimeoutProperty_1 = require("../property/TimeoutProperty");
const UnbiasedProperty_1 = require("../property/UnbiasedProperty");
const IgnoreEqualValuesProperty_1 = require("../property/IgnoreEqualValuesProperty");
function decorateProperty(rawProperty, qParams) {
    let prop = rawProperty;
    if (rawProperty.isAsync() && qParams.timeout != null) {
        prop = new TimeoutProperty_1.TimeoutProperty(prop, qParams.timeout);
    }
    if (qParams.unbiased) {
        prop = new UnbiasedProperty_1.UnbiasedProperty(prop);
    }
    if (qParams.skipAllAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.skipAllAfterTimeLimit, false);
    }
    if (qParams.interruptAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.interruptAfterTimeLimit, true);
    }
    if (qParams.skipEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, true);
    }
    if (qParams.ignoreEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, false);
    }
    return prop;
}
exports.decorateProperty = decorateProperty;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\DecorateProperty.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\Runner.js", {"../../stream/Stream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js","./DecorateProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\DecorateProperty.js","./RunnerIterator":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\RunnerIterator.js","./SourceValuesIterator":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\SourceValuesIterator.js","./Tosser":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\Tosser.js","./configuration/GlobalParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./configuration/QualifiedParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js","./utils/PathWalker":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js","./utils/RunDetailsFormatter":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CRunner.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = exports.check = void 0;
const Stream_1 = require("../../stream/Stream");
const GlobalParameters_1 = require("./configuration/GlobalParameters");
const QualifiedParameters_1 = require("./configuration/QualifiedParameters");
const DecorateProperty_1 = require("./DecorateProperty");
const RunnerIterator_1 = require("./RunnerIterator");
const SourceValuesIterator_1 = require("./SourceValuesIterator");
const Tosser_1 = require("./Tosser");
const PathWalker_1 = require("./utils/PathWalker");
const RunDetailsFormatter_1 = require("./utils/RunDetailsFormatter");
function runIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
async function asyncRunIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = await property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
function runnerPathWalker(valueProducers, shrink, path) {
    const pathPoints = path.split(':');
    const pathStream = (0, Stream_1.stream)(valueProducers)
        .drop(pathPoints.length > 0 ? +pathPoints[0] : 0)
        .map((producer) => producer());
    const adaptedPath = ['0', ...pathPoints.slice(1)].join(':');
    return (0, Stream_1.stream)((0, PathWalker_1.pathWalk)(adaptedPath, pathStream, shrink)).map((v) => () => v);
}
function buildInitialValues(valueProducers, shrink, qParams) {
    if (qParams.path.length === 0) {
        return (0, Stream_1.stream)(valueProducers);
    }
    return runnerPathWalker(valueProducers, shrink, qParams.path);
}
function check(rawProperty, params) {
    if (rawProperty == null || rawProperty.generate == null)
        throw new Error('Invalid property encountered, please use a valid property');
    if (rawProperty.run == null)
        throw new Error('Invalid property encountered, please use a valid property not an arbitrary');
    const qParams = QualifiedParameters_1.QualifiedParameters.read(Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params));
    if (qParams.reporter !== null && qParams.asyncReporter !== null)
        throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');
    if (qParams.asyncReporter !== null && !rawProperty.isAsync())
        throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');
    const property = (0, DecorateProperty_1.decorateProperty)(rawProperty, qParams);
    const generator = (0, Tosser_1.toss)(property, qParams.seed, qParams.randomType, qParams.examples);
    const maxInitialIterations = qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;
    const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
    const shrink = property.shrink.bind(property);
    const initialValues = buildInitialValues(generator, shrink, qParams);
    const sourceValues = new SourceValuesIterator_1.SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
    const finalShrink = !qParams.endOnFailure ? shrink : Stream_1.Stream.nil;
    return property.isAsync()
        ? asyncRunIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams))
        : runIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
exports.check = check;
function assert(property, params) {
    const out = check(property, params);
    if (property.isAsync())
        return out.then(RunDetailsFormatter_1.asyncReportRunDetails);
    else
        (0, RunDetailsFormatter_1.reportRunDetails)(out);
}
exports.assert = assert;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\Runner.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\RunnerIterator.js", {"../precondition/PreconditionFailure":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","./reporter/RunExecution":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\RunExecution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CRunnerIterator.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunnerIterator = void 0;
const PreconditionFailure_1 = require("../precondition/PreconditionFailure");
const RunExecution_1 = require("./reporter/RunExecution");
class RunnerIterator {
    constructor(sourceValues, shrink, verbose, interruptedAsFailure) {
        this.sourceValues = sourceValues;
        this.shrink = shrink;
        this.runExecution = new RunExecution_1.RunExecution(verbose, interruptedAsFailure);
        this.currentIdx = -1;
        this.nextValues = sourceValues;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const nextValue = this.nextValues.next();
        if (nextValue.done || this.runExecution.interrupted) {
            return { done: true, value: undefined };
        }
        this.currentValue = nextValue.value;
        ++this.currentIdx;
        return { done: false, value: nextValue.value.value_ };
    }
    handleResult(result) {
        if (result != null && typeof result === 'object' && !PreconditionFailure_1.PreconditionFailure.isFailure(result)) {
            this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
            this.currentIdx = -1;
            this.nextValues = this.shrink(this.currentValue);
        }
        else if (result != null) {
            if (!result.interruptExecution) {
                this.runExecution.skip(this.currentValue.value_);
                this.sourceValues.skippedOne();
            }
            else {
                this.runExecution.interrupt();
            }
        }
        else {
            this.runExecution.success(this.currentValue.value_);
        }
    }
}
exports.RunnerIterator = RunnerIterator;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\RunnerIterator.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\Sampler.js", {"../../stream/Stream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js","../property/Property.generic":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\Property.generic.js","../property/UnbiasedProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\UnbiasedProperty.js","./Tosser":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\Tosser.js","./configuration/GlobalParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./configuration/QualifiedParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js","./utils/PathWalker":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CSampler.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.statistics = exports.sample = void 0;
const Stream_1 = require("../../stream/Stream");
const Property_generic_1 = require("../property/Property.generic");
const UnbiasedProperty_1 = require("../property/UnbiasedProperty");
const GlobalParameters_1 = require("./configuration/GlobalParameters");
const QualifiedParameters_1 = require("./configuration/QualifiedParameters");
const Tosser_1 = require("./Tosser");
const PathWalker_1 = require("./utils/PathWalker");
function toProperty(generator, qParams) {
    const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync')
        ? new Property_generic_1.Property(generator, () => true)
        : generator;
    return qParams.unbiased === true ? new UnbiasedProperty_1.UnbiasedProperty(prop) : prop;
}
function streamSample(generator, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), { numRuns: params }) : Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const nextProperty = toProperty(generator, qParams);
    const shrink = nextProperty.shrink.bind(nextProperty);
    const tossedValues = (0, Stream_1.stream)((0, Tosser_1.toss)(nextProperty, qParams.seed, qParams.randomType, qParams.examples));
    if (qParams.path.length === 0) {
        return tossedValues.take(qParams.numRuns).map((s) => s().value_);
    }
    return (0, Stream_1.stream)((0, PathWalker_1.pathWalk)(qParams.path, tossedValues.map((s) => s()), shrink))
        .take(qParams.numRuns)
        .map((s) => s.value_);
}
function sample(generator, params) {
    return [...streamSample(generator, params)];
}
exports.sample = sample;
function round2(n) {
    return (Math.round(n * 100) / 100).toFixed(2);
}
function statistics(generator, classify, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), { numRuns: params }) : Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const recorded = {};
    for (const g of streamSample(generator, params)) {
        const out = classify(g);
        const categories = Array.isArray(out) ? out : [out];
        for (const c of categories) {
            recorded[c] = (recorded[c] || 0) + 1;
        }
    }
    const data = Object.entries(recorded)
        .sort((a, b) => b[1] - a[1])
        .map((i) => [i[0], `${round2((i[1] * 100.0) / qParams.numRuns)}%`]);
    const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);
    const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);
    for (const item of data) {
        qParams.logger(`${item[0].padEnd(longestName, '.')}..${item[1].padStart(longestPercent, '.')}`);
    }
}
exports.statistics = statistics;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\Sampler.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\SourceValuesIterator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CSourceValuesIterator.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceValuesIterator = void 0;
class SourceValuesIterator {
    constructor(initialValues, maxInitialIterations, remainingSkips) {
        this.initialValues = initialValues;
        this.maxInitialIterations = maxInitialIterations;
        this.remainingSkips = remainingSkips;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
            const n = this.initialValues.next();
            if (!n.done)
                return { value: n.value(), done: false };
        }
        return { value: undefined, done: true };
    }
    skippedOne() {
        --this.remainingSkips;
        ++this.maxInitialIterations;
    }
}
exports.SourceValuesIterator = SourceValuesIterator;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\SourceValuesIterator.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\Tosser.js", {"../../random/generator/Random":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\random\\generator\\Random.js","../arbitrary/definition/Value":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js","pure-rand":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5CTosser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toss = void 0;
const pure_rand_1 = require("pure-rand");
const Random_1 = require("../../random/generator/Random");
const Value_1 = require("../arbitrary/definition/Value");
function lazyGenerate(generator, rng, idx) {
    return () => generator.generate(new Random_1.Random(rng), idx);
}
function* toss(generator, seed, random, examples) {
    yield* examples.map((e) => () => new Value_1.Value(e, undefined));
    let idx = 0;
    let rng = random(seed);
    for (;;) {
        rng = rng.jump ? rng.jump() : (0, pure_rand_1.skipN)(rng, 42);
        yield lazyGenerate(generator, rng, idx++);
    }
}
exports.toss = toss;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\Tosser.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cconfiguration%5CGlobalParameters.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = void 0;
let globalParameters = {};
function configureGlobal(parameters) {
    globalParameters = parameters;
}
exports.configureGlobal = configureGlobal;
function readConfigureGlobal() {
    return globalParameters;
}
exports.readConfigureGlobal = readConfigureGlobal;
function resetConfigureGlobal() {
    globalParameters = {};
}
exports.resetConfigureGlobal = resetConfigureGlobal;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js", {"./VerbosityLevel":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","pure-rand":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cconfiguration%5CQualifiedParameters.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QualifiedParameters = void 0;
const pure_rand_1 = require("pure-rand");
const VerbosityLevel_1 = require("./VerbosityLevel");
class QualifiedParameters {
    constructor(op) {
        const p = op || {};
        this.seed = QualifiedParameters.readSeed(p);
        this.randomType = QualifiedParameters.readRandomType(p);
        this.numRuns = QualifiedParameters.readNumRuns(p);
        this.verbose = QualifiedParameters.readVerbose(p);
        this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);
        this.timeout = QualifiedParameters.readOrDefault(p, 'timeout', null);
        this.skipAllAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null);
        this.interruptAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null);
        this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');
        this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');
        this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');
        this.logger = QualifiedParameters.readOrDefault(p, 'logger', (v) => {
            console.log(v);
        });
        this.path = QualifiedParameters.readOrDefault(p, 'path', '');
        this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');
        this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);
        this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');
        this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);
        this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);
    }
    toParameters() {
        const orUndefined = (value) => (value !== null ? value : undefined);
        return {
            seed: this.seed,
            randomType: this.randomType,
            numRuns: this.numRuns,
            maxSkipsPerRun: this.maxSkipsPerRun,
            timeout: orUndefined(this.timeout),
            skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),
            interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),
            markInterruptAsFailure: this.markInterruptAsFailure,
            skipEqualValues: this.skipEqualValues,
            ignoreEqualValues: this.ignoreEqualValues,
            path: this.path,
            logger: this.logger,
            unbiased: this.unbiased,
            verbose: this.verbose,
            examples: this.examples,
            endOnFailure: this.endOnFailure,
            reporter: orUndefined(this.reporter),
            asyncReporter: orUndefined(this.asyncReporter),
        };
    }
    static read(op) {
        return new QualifiedParameters(op);
    }
}
exports.QualifiedParameters = QualifiedParameters;
QualifiedParameters.readSeed = (p) => {
    if (p.seed == null)
        return Date.now() ^ (Math.random() * 0x100000000);
    const seed32 = p.seed | 0;
    if (p.seed === seed32)
        return seed32;
    const gap = p.seed - seed32;
    return seed32 ^ (gap * 0x100000000);
};
QualifiedParameters.readRandomType = (p) => {
    if (p.randomType == null)
        return pure_rand_1.default.xorshift128plus;
    if (typeof p.randomType === 'string') {
        switch (p.randomType) {
            case 'mersenne':
                return pure_rand_1.default.mersenne;
            case 'congruential':
                return pure_rand_1.default.congruential;
            case 'congruential32':
                return pure_rand_1.default.congruential32;
            case 'xorshift128plus':
                return pure_rand_1.default.xorshift128plus;
            case 'xoroshiro128plus':
                return pure_rand_1.default.xoroshiro128plus;
            default:
                throw new Error(`Invalid random specified: '${p.randomType}'`);
        }
    }
    return p.randomType;
};
QualifiedParameters.readNumRuns = (p) => {
    const defaultValue = 100;
    if (p.numRuns != null)
        return p.numRuns;
    if (p.num_runs != null)
        return p.num_runs;
    return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
    if (p.verbose == null)
        return VerbosityLevel_1.VerbosityLevel.None;
    if (typeof p.verbose === 'boolean') {
        return p.verbose === true ? VerbosityLevel_1.VerbosityLevel.Verbose : VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose <= VerbosityLevel_1.VerbosityLevel.None) {
        return VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        return VerbosityLevel_1.VerbosityLevel.VeryVerbose;
    }
    return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
    const value = p[key];
    return value != null ? value : defaultValue;
};

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\configuration\\QualifiedParameters.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cconfiguration%5CVerbosityLevel.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerbosityLevel = void 0;
var VerbosityLevel;
(function (VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["None"] = 0] = "None";
    VerbosityLevel[VerbosityLevel["Verbose"] = 1] = "Verbose";
    VerbosityLevel[VerbosityLevel["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel = exports.VerbosityLevel || (exports.VerbosityLevel = {}));

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Creporter%5CExecutionStatus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionStatus = void 0;
var ExecutionStatus;
(function (ExecutionStatus) {
    ExecutionStatus[ExecutionStatus["Success"] = 0] = "Success";
    ExecutionStatus[ExecutionStatus["Skipped"] = -1] = "Skipped";
    ExecutionStatus[ExecutionStatus["Failure"] = 1] = "Failure";
})(ExecutionStatus = exports.ExecutionStatus || (exports.ExecutionStatus = {}));

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\RunExecution.js", {"../configuration/VerbosityLevel":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","./ExecutionStatus":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Creporter%5CRunExecution.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunExecution = void 0;
const VerbosityLevel_1 = require("../configuration/VerbosityLevel");
const ExecutionStatus_1 = require("./ExecutionStatus");
class RunExecution {
    constructor(verbosity, interruptedAsFailure) {
        this.verbosity = verbosity;
        this.interruptedAsFailure = interruptedAsFailure;
        this.isSuccess = () => this.pathToFailure == null;
        this.firstFailure = () => (this.pathToFailure ? +this.pathToFailure.split(':')[0] : -1);
        this.numShrinks = () => (this.pathToFailure ? this.pathToFailure.split(':').length - 1 : 0);
        this.rootExecutionTrees = [];
        this.currentLevelExecutionTrees = this.rootExecutionTrees;
        this.failure = null;
        this.numSkips = 0;
        this.numSuccesses = 0;
        this.interrupted = false;
    }
    appendExecutionTree(status, value) {
        const currentTree = { status, value, children: [] };
        this.currentLevelExecutionTrees.push(currentTree);
        return currentTree;
    }
    fail(value, id, failure) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.Verbose) {
            const currentTree = this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Failure, value);
            this.currentLevelExecutionTrees = currentTree.children;
        }
        if (this.pathToFailure == null)
            this.pathToFailure = `${id}`;
        else
            this.pathToFailure += `:${id}`;
        this.value = value;
        this.failure = failure;
    }
    skip(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Skipped, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSkips;
        }
    }
    success(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Success, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSuccesses;
        }
    }
    interrupt() {
        this.interrupted = true;
    }
    extractFailures() {
        if (this.isSuccess()) {
            return [];
        }
        const failures = [];
        let cursor = this.rootExecutionTrees;
        while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus_1.ExecutionStatus.Failure) {
            const failureTree = cursor[cursor.length - 1];
            failures.push(failureTree.value);
            cursor = failureTree.children;
        }
        return failures;
    }
    toRunDetails(seed, basePath, maxSkips, qParams) {
        if (!this.isSuccess()) {
            return {
                failed: true,
                interrupted: this.interrupted,
                numRuns: this.firstFailure() + 1 - this.numSkips,
                numSkips: this.numSkips,
                numShrinks: this.numShrinks(),
                seed,
                counterexample: this.value,
                counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
                error: this.failure.errorMessage,
                errorInstance: this.failure.error,
                failures: this.extractFailures(),
                executionSummary: this.rootExecutionTrees,
                verbose: this.verbosity,
                runConfiguration: qParams.toParameters(),
            };
        }
        const failed = this.numSkips > maxSkips || (this.interrupted && this.interruptedAsFailure);
        return {
            failed,
            interrupted: this.interrupted,
            numRuns: this.numSuccesses,
            numSkips: this.numSkips,
            numShrinks: 0,
            seed,
            counterexample: null,
            counterexamplePath: null,
            error: null,
            errorInstance: null,
            failures: [],
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters(),
        };
    }
}
exports.RunExecution = RunExecution;
RunExecution.mergePaths = (offsetPath, path) => {
    if (offsetPath.length === 0)
        return path;
    const offsetItems = offsetPath.split(':');
    const remainingItems = path.split(':');
    const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
    return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(':');
};

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\reporter\\RunExecution.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js", {"../../../stream/Stream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cutils%5CPathWalker.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pathWalk = void 0;
const Stream_1 = require("../../../stream/Stream");
function pathWalk(path, initialValues, shrink) {
    let values = (0, Stream_1.stream)(initialValues);
    const segments = path.split(':').map((text) => +text);
    if (segments.length === 0)
        return values;
    if (!segments.every((v) => !Number.isNaN(v))) {
        throw new Error(`Unable to replay, got invalid path=${path}`);
    }
    values = values.drop(segments[0]);
    for (const s of segments.slice(1)) {
        const valueToShrink = values.getNthOrLast(0);
        if (valueToShrink == null) {
            throw new Error(`Unable to replay, got wrong path=${path}`);
        }
        values = shrink(valueToShrink).drop(s);
    }
    return values;
}
exports.pathWalk = pathWalk;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\utils\\PathWalker.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js", {"../../../utils/stringify":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\utils\\stringify.js","../configuration/VerbosityLevel":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","../reporter/ExecutionStatus":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Crunner%5Cutils%5CRunDetailsFormatter.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncReportRunDetails = exports.reportRunDetails = void 0;
const stringify_1 = require("../../../utils/stringify");
const VerbosityLevel_1 = require("../configuration/VerbosityLevel");
const ExecutionStatus_1 = require("../reporter/ExecutionStatus");
function formatHints(hints) {
    if (hints.length === 1) {
        return `Hint: ${hints[0]}`;
    }
    return hints.map((h, idx) => `Hint (${idx + 1}): ${h}`).join('\n');
}
function formatFailures(failures, stringifyOne) {
    return `Encountered failures were:\n- ${failures.map(stringifyOne).join('\n- ')}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
    const summaryLines = [];
    const remainingTreesAndDepth = [];
    for (const tree of executionTrees.slice().reverse()) {
        remainingTreesAndDepth.push({ depth: 1, tree });
    }
    while (remainingTreesAndDepth.length !== 0) {
        const currentTreeAndDepth = remainingTreesAndDepth.pop();
        const currentTree = currentTreeAndDepth.tree;
        const currentDepth = currentTreeAndDepth.depth;
        const statusIcon = currentTree.status === ExecutionStatus_1.ExecutionStatus.Success
            ? '\x1b[32m\u221A\x1b[0m'
            : currentTree.status === ExecutionStatus_1.ExecutionStatus.Failure
                ? '\x1b[31m\xD7\x1b[0m'
                : '\x1b[33m!\x1b[0m';
        const leftPadding = Array(currentDepth).join('. ');
        summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
        for (const tree of currentTree.children.slice().reverse()) {
            remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });
        }
    }
    return `Execution summary:\n${summaryLines.join('\n')}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
    const message = `Failed to run property, too many pre-condition failures encountered\n{ seed: ${out.seed} }\n\nRan ${out.numRuns} time(s)\nSkipped ${out.numSkips} time(s)`;
    let details = null;
    const hints = [
        'Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries',
        'Increase failure tolerance by setting maxSkipsPerRun to an higher value',
    ];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function preFormatFailure(out, stringifyOne) {
    const message = `Property failed after ${out.numRuns} tests\n{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }\nCounterexample: ${stringifyOne(out.counterexample)}\nShrunk ${out.numShrinks} time(s)\nGot error: ${out.error}`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else if (out.verbose === VerbosityLevel_1.VerbosityLevel.Verbose) {
        details = formatFailures(out.failures, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');
    }
    return { message, details, hints };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
    const message = `Property interrupted after ${out.numRuns} tests\n{ seed: ${out.seed} }`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function defaultReportMessageInternal(out, stringifyOne) {
    if (!out.failed)
        return;
    const { message, details, hints } = out.counterexamplePath === null
        ? out.interrupted
            ? preFormatEarlyInterrupted(out, stringifyOne)
            : preFormatTooManySkipped(out, stringifyOne)
        : preFormatFailure(out, stringifyOne);
    let errorMessage = message;
    if (details != null)
        errorMessage += `\n\n${details}`;
    if (hints.length > 0)
        errorMessage += `\n\n${formatHints(hints)}`;
    return errorMessage;
}
function defaultReportMessage(out) {
    return defaultReportMessageInternal(out, stringify_1.stringify);
}
exports.defaultReportMessage = defaultReportMessage;
async function asyncDefaultReportMessage(out) {
    const pendingStringifieds = [];
    function stringifyOne(value) {
        const stringified = (0, stringify_1.possiblyAsyncStringify)(value);
        if (typeof stringified === 'string') {
            return stringified;
        }
        pendingStringifieds.push(Promise.all([value, stringified]));
        return '\u2026';
    }
    const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
    if (pendingStringifieds.length === 0) {
        return firstTryMessage;
    }
    const registeredValues = new Map(await Promise.all(pendingStringifieds));
    function stringifySecond(value) {
        const asyncStringifiedIfRegistered = registeredValues.get(value);
        if (asyncStringifiedIfRegistered !== undefined) {
            return asyncStringifiedIfRegistered;
        }
        return (0, stringify_1.stringify)(value);
    }
    return defaultReportMessageInternal(out, stringifySecond);
}
exports.asyncDefaultReportMessage = asyncDefaultReportMessage;
function throwIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(defaultReportMessage(out));
}
async function asyncThrowIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(await asyncDefaultReportMessage(out));
}
function reportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return throwIfFailed(out);
}
exports.reportRunDetails = reportRunDetails;
async function asyncReportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return asyncThrowIfFailed(out);
}
exports.asyncReportRunDetails = asyncReportRunDetails;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\symbols.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Ccheck%5Csymbols.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneIfNeeded = exports.hasCloneMethod = exports.cloneMethod = void 0;
exports.cloneMethod = Symbol('fast-check/cloneMethod');
function hasCloneMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.cloneMethod in instance &&
        typeof instance[exports.cloneMethod] === 'function');
}
exports.hasCloneMethod = hasCloneMethod;
function cloneIfNeeded(instance) {
    return hasCloneMethod(instance) ? instance[exports.cloneMethod]() : instance;
}
exports.cloneIfNeeded = cloneIfNeeded;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\check\\symbols.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\fast-check-default.js", {"./arbitrary/_internals/helpers/DepthContext":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\_internals\\helpers\\DepthContext.js","./arbitrary/anything":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\anything.js","./arbitrary/array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\array.js","./arbitrary/ascii":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\ascii.js","./arbitrary/asciiString":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\asciiString.js","./arbitrary/base64":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\base64.js","./arbitrary/base64String":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\base64String.js","./arbitrary/bigInt":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\bigInt.js","./arbitrary/bigInt64Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\bigInt64Array.js","./arbitrary/bigIntN":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\bigIntN.js","./arbitrary/bigUint":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\bigUint.js","./arbitrary/bigUint64Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\bigUint64Array.js","./arbitrary/bigUintN":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\bigUintN.js","./arbitrary/boolean":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\boolean.js","./arbitrary/char":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\char.js","./arbitrary/char16bits":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\char16bits.js","./arbitrary/clone":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\clone.js","./arbitrary/commands":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\commands.js","./arbitrary/compareBooleanFunc":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\compareBooleanFunc.js","./arbitrary/compareFunc":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\compareFunc.js","./arbitrary/constant":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\constant.js","./arbitrary/constantFrom":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\constantFrom.js","./arbitrary/context":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\context.js","./arbitrary/date":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\date.js","./arbitrary/dictionary":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\dictionary.js","./arbitrary/domain":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\domain.js","./arbitrary/double":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\double.js","./arbitrary/emailAddress":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\emailAddress.js","./arbitrary/falsy":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\falsy.js","./arbitrary/float":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\float.js","./arbitrary/float32Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\float32Array.js","./arbitrary/float64Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\float64Array.js","./arbitrary/fullUnicode":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\fullUnicode.js","./arbitrary/fullUnicodeString":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\fullUnicodeString.js","./arbitrary/func":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\func.js","./arbitrary/hexa":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\hexa.js","./arbitrary/hexaString":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\hexaString.js","./arbitrary/infiniteStream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\infiniteStream.js","./arbitrary/int16Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\int16Array.js","./arbitrary/int32Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\int32Array.js","./arbitrary/int8Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\int8Array.js","./arbitrary/integer":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\integer.js","./arbitrary/ipV4":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\ipV4.js","./arbitrary/ipV4Extended":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\ipV4Extended.js","./arbitrary/ipV6":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\ipV6.js","./arbitrary/json":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\json.js","./arbitrary/jsonValue":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\jsonValue.js","./arbitrary/letrec":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\letrec.js","./arbitrary/lorem":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\lorem.js","./arbitrary/mapToConstant":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\mapToConstant.js","./arbitrary/maxSafeInteger":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\maxSafeInteger.js","./arbitrary/maxSafeNat":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\maxSafeNat.js","./arbitrary/memo":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\memo.js","./arbitrary/mixedCase":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\mixedCase.js","./arbitrary/nat":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\nat.js","./arbitrary/object":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\object.js","./arbitrary/oneof":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\oneof.js","./arbitrary/option":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\option.js","./arbitrary/record":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\record.js","./arbitrary/scheduler":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\scheduler.js","./arbitrary/shuffledSubarray":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\shuffledSubarray.js","./arbitrary/sparseArray":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\sparseArray.js","./arbitrary/string":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\string.js","./arbitrary/string16bits":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\string16bits.js","./arbitrary/stringOf":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\stringOf.js","./arbitrary/subarray":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\subarray.js","./arbitrary/tuple":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\tuple.js","./arbitrary/uint16Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uint16Array.js","./arbitrary/uint32Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uint32Array.js","./arbitrary/uint8Array":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uint8Array.js","./arbitrary/uint8ClampedArray":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uint8ClampedArray.js","./arbitrary/unicode":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\unicode.js","./arbitrary/unicodeJson":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\unicodeJson.js","./arbitrary/unicodeJsonValue":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\unicodeJsonValue.js","./arbitrary/unicodeString":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\unicodeString.js","./arbitrary/uniqueArray":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uniqueArray.js","./arbitrary/uuid":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uuid.js","./arbitrary/uuidV":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\uuidV.js","./arbitrary/webAuthority":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webAuthority.js","./arbitrary/webFragments":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webFragments.js","./arbitrary/webQueryParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webQueryParameters.js","./arbitrary/webSegment":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webSegment.js","./arbitrary/webUrl":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\arbitrary\\webUrl.js","./check/arbitrary/definition/Arbitrary":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Arbitrary.js","./check/arbitrary/definition/Value":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\arbitrary\\definition\\Value.js","./check/model/ModelRunner":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\model\\ModelRunner.js","./check/precondition/Pre":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\Pre.js","./check/precondition/PreconditionFailure":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\precondition\\PreconditionFailure.js","./check/property/AsyncProperty":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\AsyncProperty.js","./check/property/Property":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\property\\Property.js","./check/runner/Runner":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\Runner.js","./check/runner/Sampler":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\Sampler.js","./check/runner/configuration/GlobalParameters":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\GlobalParameters.js","./check/runner/configuration/VerbosityLevel":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\configuration\\VerbosityLevel.js","./check/runner/reporter/ExecutionStatus":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\reporter\\ExecutionStatus.js","./check/runner/utils/RunDetailsFormatter":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\runner\\utils\\RunDetailsFormatter.js","./check/symbols":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\check\\symbols.js","./random/generator/Random":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\random\\generator\\Random.js","./stream/Stream":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js","./utils/hash":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\utils\\hash.js","./utils/stringify":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\utils\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Cfast-check-default.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sparseArray = exports.array = exports.subarray = exports.shuffledSubarray = exports.clone = exports.oneof = exports.option = exports.mapToConstant = exports.constantFrom = exports.constant = exports.lorem = exports.base64String = exports.hexaString = exports.fullUnicodeString = exports.unicodeString = exports.stringOf = exports.string16bits = exports.asciiString = exports.string = exports.mixedCase = exports.base64 = exports.hexa = exports.fullUnicode = exports.unicode = exports.char16bits = exports.ascii = exports.char = exports.bigUint = exports.bigInt = exports.bigUintN = exports.bigIntN = exports.maxSafeNat = exports.maxSafeInteger = exports.nat = exports.integer = exports.double = exports.float = exports.falsy = exports.boolean = exports.asyncProperty = exports.property = exports.PreconditionFailure = exports.pre = exports.assert = exports.check = exports.statistics = exports.sample = exports.__commitHash = exports.__version = exports.__type = void 0;
exports.cloneMethod = exports.Value = exports.Arbitrary = exports.schedulerFor = exports.scheduler = exports.commands = exports.scheduledModelRun = exports.modelRun = exports.asyncModelRun = exports.bigUint64Array = exports.bigInt64Array = exports.float64Array = exports.float32Array = exports.uint32Array = exports.int32Array = exports.uint16Array = exports.int16Array = exports.uint8ClampedArray = exports.uint8Array = exports.int8Array = exports.uuidV = exports.uuid = exports.emailAddress = exports.webUrl = exports.webQueryParameters = exports.webFragments = exports.webSegment = exports.webAuthority = exports.domain = exports.ipV6 = exports.ipV4Extended = exports.ipV4 = exports.date = exports.context = exports.func = exports.compareFunc = exports.compareBooleanFunc = exports.memo = exports.letrec = exports.unicodeJsonValue = exports.unicodeJson = exports.jsonValue = exports.json = exports.object = exports.anything = exports.dictionary = exports.record = exports.tuple = exports.uniqueArray = exports.infiniteStream = void 0;
exports.createDepthIdentifier = exports.stream = exports.Stream = exports.Random = exports.ExecutionStatus = exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = exports.VerbosityLevel = exports.hash = exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncStringify = exports.stringify = exports.getDepthContextFor = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = exports.hasCloneMethod = exports.cloneIfNeeded = void 0;
const Pre_1 = require("./check/precondition/Pre");
Object.defineProperty(exports, "pre", { enumerable: true, get: function () { return Pre_1.pre; } });
const AsyncProperty_1 = require("./check/property/AsyncProperty");
Object.defineProperty(exports, "asyncProperty", { enumerable: true, get: function () { return AsyncProperty_1.asyncProperty; } });
const Property_1 = require("./check/property/Property");
Object.defineProperty(exports, "property", { enumerable: true, get: function () { return Property_1.property; } });
const Runner_1 = require("./check/runner/Runner");
Object.defineProperty(exports, "assert", { enumerable: true, get: function () { return Runner_1.assert; } });
Object.defineProperty(exports, "check", { enumerable: true, get: function () { return Runner_1.check; } });
const Sampler_1 = require("./check/runner/Sampler");
Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return Sampler_1.sample; } });
Object.defineProperty(exports, "statistics", { enumerable: true, get: function () { return Sampler_1.statistics; } });
const array_1 = require("./arbitrary/array");
Object.defineProperty(exports, "array", { enumerable: true, get: function () { return array_1.array; } });
const bigInt_1 = require("./arbitrary/bigInt");
Object.defineProperty(exports, "bigInt", { enumerable: true, get: function () { return bigInt_1.bigInt; } });
const bigIntN_1 = require("./arbitrary/bigIntN");
Object.defineProperty(exports, "bigIntN", { enumerable: true, get: function () { return bigIntN_1.bigIntN; } });
const bigUint_1 = require("./arbitrary/bigUint");
Object.defineProperty(exports, "bigUint", { enumerable: true, get: function () { return bigUint_1.bigUint; } });
const bigUintN_1 = require("./arbitrary/bigUintN");
Object.defineProperty(exports, "bigUintN", { enumerable: true, get: function () { return bigUintN_1.bigUintN; } });
const boolean_1 = require("./arbitrary/boolean");
Object.defineProperty(exports, "boolean", { enumerable: true, get: function () { return boolean_1.boolean; } });
const falsy_1 = require("./arbitrary/falsy");
Object.defineProperty(exports, "falsy", { enumerable: true, get: function () { return falsy_1.falsy; } });
const ascii_1 = require("./arbitrary/ascii");
Object.defineProperty(exports, "ascii", { enumerable: true, get: function () { return ascii_1.ascii; } });
const base64_1 = require("./arbitrary/base64");
Object.defineProperty(exports, "base64", { enumerable: true, get: function () { return base64_1.base64; } });
const char_1 = require("./arbitrary/char");
Object.defineProperty(exports, "char", { enumerable: true, get: function () { return char_1.char; } });
const char16bits_1 = require("./arbitrary/char16bits");
Object.defineProperty(exports, "char16bits", { enumerable: true, get: function () { return char16bits_1.char16bits; } });
const fullUnicode_1 = require("./arbitrary/fullUnicode");
Object.defineProperty(exports, "fullUnicode", { enumerable: true, get: function () { return fullUnicode_1.fullUnicode; } });
const hexa_1 = require("./arbitrary/hexa");
Object.defineProperty(exports, "hexa", { enumerable: true, get: function () { return hexa_1.hexa; } });
const unicode_1 = require("./arbitrary/unicode");
Object.defineProperty(exports, "unicode", { enumerable: true, get: function () { return unicode_1.unicode; } });
const constant_1 = require("./arbitrary/constant");
Object.defineProperty(exports, "constant", { enumerable: true, get: function () { return constant_1.constant; } });
const constantFrom_1 = require("./arbitrary/constantFrom");
Object.defineProperty(exports, "constantFrom", { enumerable: true, get: function () { return constantFrom_1.constantFrom; } });
const context_1 = require("./arbitrary/context");
Object.defineProperty(exports, "context", { enumerable: true, get: function () { return context_1.context; } });
const date_1 = require("./arbitrary/date");
Object.defineProperty(exports, "date", { enumerable: true, get: function () { return date_1.date; } });
const clone_1 = require("./arbitrary/clone");
Object.defineProperty(exports, "clone", { enumerable: true, get: function () { return clone_1.clone; } });
const dictionary_1 = require("./arbitrary/dictionary");
Object.defineProperty(exports, "dictionary", { enumerable: true, get: function () { return dictionary_1.dictionary; } });
const emailAddress_1 = require("./arbitrary/emailAddress");
Object.defineProperty(exports, "emailAddress", { enumerable: true, get: function () { return emailAddress_1.emailAddress; } });
const double_1 = require("./arbitrary/double");
Object.defineProperty(exports, "double", { enumerable: true, get: function () { return double_1.double; } });
const float_1 = require("./arbitrary/float");
Object.defineProperty(exports, "float", { enumerable: true, get: function () { return float_1.float; } });
const compareBooleanFunc_1 = require("./arbitrary/compareBooleanFunc");
Object.defineProperty(exports, "compareBooleanFunc", { enumerable: true, get: function () { return compareBooleanFunc_1.compareBooleanFunc; } });
const compareFunc_1 = require("./arbitrary/compareFunc");
Object.defineProperty(exports, "compareFunc", { enumerable: true, get: function () { return compareFunc_1.compareFunc; } });
const func_1 = require("./arbitrary/func");
Object.defineProperty(exports, "func", { enumerable: true, get: function () { return func_1.func; } });
const domain_1 = require("./arbitrary/domain");
Object.defineProperty(exports, "domain", { enumerable: true, get: function () { return domain_1.domain; } });
const integer_1 = require("./arbitrary/integer");
Object.defineProperty(exports, "integer", { enumerable: true, get: function () { return integer_1.integer; } });
const maxSafeInteger_1 = require("./arbitrary/maxSafeInteger");
Object.defineProperty(exports, "maxSafeInteger", { enumerable: true, get: function () { return maxSafeInteger_1.maxSafeInteger; } });
const maxSafeNat_1 = require("./arbitrary/maxSafeNat");
Object.defineProperty(exports, "maxSafeNat", { enumerable: true, get: function () { return maxSafeNat_1.maxSafeNat; } });
const nat_1 = require("./arbitrary/nat");
Object.defineProperty(exports, "nat", { enumerable: true, get: function () { return nat_1.nat; } });
const ipV4_1 = require("./arbitrary/ipV4");
Object.defineProperty(exports, "ipV4", { enumerable: true, get: function () { return ipV4_1.ipV4; } });
const ipV4Extended_1 = require("./arbitrary/ipV4Extended");
Object.defineProperty(exports, "ipV4Extended", { enumerable: true, get: function () { return ipV4Extended_1.ipV4Extended; } });
const ipV6_1 = require("./arbitrary/ipV6");
Object.defineProperty(exports, "ipV6", { enumerable: true, get: function () { return ipV6_1.ipV6; } });
const letrec_1 = require("./arbitrary/letrec");
Object.defineProperty(exports, "letrec", { enumerable: true, get: function () { return letrec_1.letrec; } });
const lorem_1 = require("./arbitrary/lorem");
Object.defineProperty(exports, "lorem", { enumerable: true, get: function () { return lorem_1.lorem; } });
const mapToConstant_1 = require("./arbitrary/mapToConstant");
Object.defineProperty(exports, "mapToConstant", { enumerable: true, get: function () { return mapToConstant_1.mapToConstant; } });
const memo_1 = require("./arbitrary/memo");
Object.defineProperty(exports, "memo", { enumerable: true, get: function () { return memo_1.memo; } });
const mixedCase_1 = require("./arbitrary/mixedCase");
Object.defineProperty(exports, "mixedCase", { enumerable: true, get: function () { return mixedCase_1.mixedCase; } });
const object_1 = require("./arbitrary/object");
Object.defineProperty(exports, "object", { enumerable: true, get: function () { return object_1.object; } });
const json_1 = require("./arbitrary/json");
Object.defineProperty(exports, "json", { enumerable: true, get: function () { return json_1.json; } });
const anything_1 = require("./arbitrary/anything");
Object.defineProperty(exports, "anything", { enumerable: true, get: function () { return anything_1.anything; } });
const unicodeJsonValue_1 = require("./arbitrary/unicodeJsonValue");
Object.defineProperty(exports, "unicodeJsonValue", { enumerable: true, get: function () { return unicodeJsonValue_1.unicodeJsonValue; } });
const jsonValue_1 = require("./arbitrary/jsonValue");
Object.defineProperty(exports, "jsonValue", { enumerable: true, get: function () { return jsonValue_1.jsonValue; } });
const unicodeJson_1 = require("./arbitrary/unicodeJson");
Object.defineProperty(exports, "unicodeJson", { enumerable: true, get: function () { return unicodeJson_1.unicodeJson; } });
const oneof_1 = require("./arbitrary/oneof");
Object.defineProperty(exports, "oneof", { enumerable: true, get: function () { return oneof_1.oneof; } });
const option_1 = require("./arbitrary/option");
Object.defineProperty(exports, "option", { enumerable: true, get: function () { return option_1.option; } });
const record_1 = require("./arbitrary/record");
Object.defineProperty(exports, "record", { enumerable: true, get: function () { return record_1.record; } });
const uniqueArray_1 = require("./arbitrary/uniqueArray");
Object.defineProperty(exports, "uniqueArray", { enumerable: true, get: function () { return uniqueArray_1.uniqueArray; } });
const infiniteStream_1 = require("./arbitrary/infiniteStream");
Object.defineProperty(exports, "infiniteStream", { enumerable: true, get: function () { return infiniteStream_1.infiniteStream; } });
const asciiString_1 = require("./arbitrary/asciiString");
Object.defineProperty(exports, "asciiString", { enumerable: true, get: function () { return asciiString_1.asciiString; } });
const base64String_1 = require("./arbitrary/base64String");
Object.defineProperty(exports, "base64String", { enumerable: true, get: function () { return base64String_1.base64String; } });
const fullUnicodeString_1 = require("./arbitrary/fullUnicodeString");
Object.defineProperty(exports, "fullUnicodeString", { enumerable: true, get: function () { return fullUnicodeString_1.fullUnicodeString; } });
const hexaString_1 = require("./arbitrary/hexaString");
Object.defineProperty(exports, "hexaString", { enumerable: true, get: function () { return hexaString_1.hexaString; } });
const string_1 = require("./arbitrary/string");
Object.defineProperty(exports, "string", { enumerable: true, get: function () { return string_1.string; } });
const string16bits_1 = require("./arbitrary/string16bits");
Object.defineProperty(exports, "string16bits", { enumerable: true, get: function () { return string16bits_1.string16bits; } });
const stringOf_1 = require("./arbitrary/stringOf");
Object.defineProperty(exports, "stringOf", { enumerable: true, get: function () { return stringOf_1.stringOf; } });
const unicodeString_1 = require("./arbitrary/unicodeString");
Object.defineProperty(exports, "unicodeString", { enumerable: true, get: function () { return unicodeString_1.unicodeString; } });
const subarray_1 = require("./arbitrary/subarray");
Object.defineProperty(exports, "subarray", { enumerable: true, get: function () { return subarray_1.subarray; } });
const shuffledSubarray_1 = require("./arbitrary/shuffledSubarray");
Object.defineProperty(exports, "shuffledSubarray", { enumerable: true, get: function () { return shuffledSubarray_1.shuffledSubarray; } });
const tuple_1 = require("./arbitrary/tuple");
Object.defineProperty(exports, "tuple", { enumerable: true, get: function () { return tuple_1.tuple; } });
const uuid_1 = require("./arbitrary/uuid");
Object.defineProperty(exports, "uuid", { enumerable: true, get: function () { return uuid_1.uuid; } });
const uuidV_1 = require("./arbitrary/uuidV");
Object.defineProperty(exports, "uuidV", { enumerable: true, get: function () { return uuidV_1.uuidV; } });
const webAuthority_1 = require("./arbitrary/webAuthority");
Object.defineProperty(exports, "webAuthority", { enumerable: true, get: function () { return webAuthority_1.webAuthority; } });
const webFragments_1 = require("./arbitrary/webFragments");
Object.defineProperty(exports, "webFragments", { enumerable: true, get: function () { return webFragments_1.webFragments; } });
const webQueryParameters_1 = require("./arbitrary/webQueryParameters");
Object.defineProperty(exports, "webQueryParameters", { enumerable: true, get: function () { return webQueryParameters_1.webQueryParameters; } });
const webSegment_1 = require("./arbitrary/webSegment");
Object.defineProperty(exports, "webSegment", { enumerable: true, get: function () { return webSegment_1.webSegment; } });
const webUrl_1 = require("./arbitrary/webUrl");
Object.defineProperty(exports, "webUrl", { enumerable: true, get: function () { return webUrl_1.webUrl; } });
const commands_1 = require("./arbitrary/commands");
Object.defineProperty(exports, "commands", { enumerable: true, get: function () { return commands_1.commands; } });
const ModelRunner_1 = require("./check/model/ModelRunner");
Object.defineProperty(exports, "asyncModelRun", { enumerable: true, get: function () { return ModelRunner_1.asyncModelRun; } });
Object.defineProperty(exports, "modelRun", { enumerable: true, get: function () { return ModelRunner_1.modelRun; } });
Object.defineProperty(exports, "scheduledModelRun", { enumerable: true, get: function () { return ModelRunner_1.scheduledModelRun; } });
const Random_1 = require("./random/generator/Random");
Object.defineProperty(exports, "Random", { enumerable: true, get: function () { return Random_1.Random; } });
const GlobalParameters_1 = require("./check/runner/configuration/GlobalParameters");
Object.defineProperty(exports, "configureGlobal", { enumerable: true, get: function () { return GlobalParameters_1.configureGlobal; } });
Object.defineProperty(exports, "readConfigureGlobal", { enumerable: true, get: function () { return GlobalParameters_1.readConfigureGlobal; } });
Object.defineProperty(exports, "resetConfigureGlobal", { enumerable: true, get: function () { return GlobalParameters_1.resetConfigureGlobal; } });
const VerbosityLevel_1 = require("./check/runner/configuration/VerbosityLevel");
Object.defineProperty(exports, "VerbosityLevel", { enumerable: true, get: function () { return VerbosityLevel_1.VerbosityLevel; } });
const ExecutionStatus_1 = require("./check/runner/reporter/ExecutionStatus");
Object.defineProperty(exports, "ExecutionStatus", { enumerable: true, get: function () { return ExecutionStatus_1.ExecutionStatus; } });
const symbols_1 = require("./check/symbols");
Object.defineProperty(exports, "cloneMethod", { enumerable: true, get: function () { return symbols_1.cloneMethod; } });
Object.defineProperty(exports, "cloneIfNeeded", { enumerable: true, get: function () { return symbols_1.cloneIfNeeded; } });
Object.defineProperty(exports, "hasCloneMethod", { enumerable: true, get: function () { return symbols_1.hasCloneMethod; } });
const Stream_1 = require("./stream/Stream");
Object.defineProperty(exports, "Stream", { enumerable: true, get: function () { return Stream_1.Stream; } });
Object.defineProperty(exports, "stream", { enumerable: true, get: function () { return Stream_1.stream; } });
const hash_1 = require("./utils/hash");
Object.defineProperty(exports, "hash", { enumerable: true, get: function () { return hash_1.hash; } });
const stringify_1 = require("./utils/stringify");
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return stringify_1.stringify; } });
Object.defineProperty(exports, "asyncStringify", { enumerable: true, get: function () { return stringify_1.asyncStringify; } });
Object.defineProperty(exports, "toStringMethod", { enumerable: true, get: function () { return stringify_1.toStringMethod; } });
Object.defineProperty(exports, "hasToStringMethod", { enumerable: true, get: function () { return stringify_1.hasToStringMethod; } });
Object.defineProperty(exports, "asyncToStringMethod", { enumerable: true, get: function () { return stringify_1.asyncToStringMethod; } });
Object.defineProperty(exports, "hasAsyncToStringMethod", { enumerable: true, get: function () { return stringify_1.hasAsyncToStringMethod; } });
const scheduler_1 = require("./arbitrary/scheduler");
Object.defineProperty(exports, "scheduler", { enumerable: true, get: function () { return scheduler_1.scheduler; } });
Object.defineProperty(exports, "schedulerFor", { enumerable: true, get: function () { return scheduler_1.schedulerFor; } });
const RunDetailsFormatter_1 = require("./check/runner/utils/RunDetailsFormatter");
Object.defineProperty(exports, "defaultReportMessage", { enumerable: true, get: function () { return RunDetailsFormatter_1.defaultReportMessage; } });
Object.defineProperty(exports, "asyncDefaultReportMessage", { enumerable: true, get: function () { return RunDetailsFormatter_1.asyncDefaultReportMessage; } });
const PreconditionFailure_1 = require("./check/precondition/PreconditionFailure");
Object.defineProperty(exports, "PreconditionFailure", { enumerable: true, get: function () { return PreconditionFailure_1.PreconditionFailure; } });
const int8Array_1 = require("./arbitrary/int8Array");
Object.defineProperty(exports, "int8Array", { enumerable: true, get: function () { return int8Array_1.int8Array; } });
const int16Array_1 = require("./arbitrary/int16Array");
Object.defineProperty(exports, "int16Array", { enumerable: true, get: function () { return int16Array_1.int16Array; } });
const int32Array_1 = require("./arbitrary/int32Array");
Object.defineProperty(exports, "int32Array", { enumerable: true, get: function () { return int32Array_1.int32Array; } });
const uint8Array_1 = require("./arbitrary/uint8Array");
Object.defineProperty(exports, "uint8Array", { enumerable: true, get: function () { return uint8Array_1.uint8Array; } });
const uint8ClampedArray_1 = require("./arbitrary/uint8ClampedArray");
Object.defineProperty(exports, "uint8ClampedArray", { enumerable: true, get: function () { return uint8ClampedArray_1.uint8ClampedArray; } });
const uint16Array_1 = require("./arbitrary/uint16Array");
Object.defineProperty(exports, "uint16Array", { enumerable: true, get: function () { return uint16Array_1.uint16Array; } });
const uint32Array_1 = require("./arbitrary/uint32Array");
Object.defineProperty(exports, "uint32Array", { enumerable: true, get: function () { return uint32Array_1.uint32Array; } });
const float32Array_1 = require("./arbitrary/float32Array");
Object.defineProperty(exports, "float32Array", { enumerable: true, get: function () { return float32Array_1.float32Array; } });
const float64Array_1 = require("./arbitrary/float64Array");
Object.defineProperty(exports, "float64Array", { enumerable: true, get: function () { return float64Array_1.float64Array; } });
const sparseArray_1 = require("./arbitrary/sparseArray");
Object.defineProperty(exports, "sparseArray", { enumerable: true, get: function () { return sparseArray_1.sparseArray; } });
const Arbitrary_1 = require("./check/arbitrary/definition/Arbitrary");
Object.defineProperty(exports, "Arbitrary", { enumerable: true, get: function () { return Arbitrary_1.Arbitrary; } });
const Value_1 = require("./check/arbitrary/definition/Value");
Object.defineProperty(exports, "Value", { enumerable: true, get: function () { return Value_1.Value; } });
const DepthContext_1 = require("./arbitrary/_internals/helpers/DepthContext");
Object.defineProperty(exports, "createDepthIdentifier", { enumerable: true, get: function () { return DepthContext_1.createDepthIdentifier; } });
Object.defineProperty(exports, "getDepthContextFor", { enumerable: true, get: function () { return DepthContext_1.getDepthContextFor; } });
const bigInt64Array_1 = require("./arbitrary/bigInt64Array");
Object.defineProperty(exports, "bigInt64Array", { enumerable: true, get: function () { return bigInt64Array_1.bigInt64Array; } });
const bigUint64Array_1 = require("./arbitrary/bigUint64Array");
Object.defineProperty(exports, "bigUint64Array", { enumerable: true, get: function () { return bigUint64Array_1.bigUint64Array; } });
const __type = 'commonjs';
exports.__type = __type;
const __version = '3.1.1';
exports.__version = __version;
const __commitHash = '35ac775d3a2353a9458b1426c2ac97397b99cdbd';
exports.__commitHash = __commitHash;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\fast-check-default.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\fast-check.js", {"./fast-check-default":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\fast-check-default.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Cfast-check.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
const fc = require("./fast-check-default");
exports.default = fc;
__exportStar(require("./fast-check-default"), exports);

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\fast-check.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\random\\generator\\Random.js", {"pure-rand":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Crandom%5Cgenerator%5CRandom.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Random = void 0;
const pure_rand_1 = require("pure-rand");
class Random {
    constructor(sourceRng) {
        this.internalRng = sourceRng.clone();
    }
    clone() {
        return new Random(this.internalRng);
    }
    next(bits) {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(0, (1 << bits) - 1, this.internalRng);
    }
    nextBoolean() {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(0, 1, this.internalRng) == 1;
    }
    nextInt(min, max) {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);
    }
    nextBigInt(min, max) {
        return (0, pure_rand_1.unsafeUniformBigIntDistribution)(min, max, this.internalRng);
    }
    nextArrayInt(min, max) {
        return (0, pure_rand_1.unsafeUniformArrayIntDistribution)(min, max, this.internalRng);
    }
    nextDouble() {
        const a = this.next(26);
        const b = this.next(27);
        return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
    }
}
exports.Random = Random;
Random.MIN_INT = 0x80000000 | 0;
Random.MAX_INT = 0x7fffffff | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\random\\generator\\Random.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\LazyIterableIterator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Cstream%5CLazyIterableIterator.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeLazy = void 0;
class LazyIterableIterator {
    constructor(producer) {
        this.producer = producer;
    }
    [Symbol.iterator]() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it;
    }
    next() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it.next();
    }
}
function makeLazy(producer) {
    return new LazyIterableIterator(producer);
}
exports.makeLazy = makeLazy;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\stream\\LazyIterableIterator.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\Stream.js", {"./StreamHelpers":"F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\StreamHelpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Cstream%5CStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stream = exports.Stream = void 0;
const StreamHelpers_1 = require("./StreamHelpers");
class Stream {
    constructor(g) {
        this.g = g;
    }
    static nil() {
        return new Stream((0, StreamHelpers_1.nilHelper)());
    }
    static of(...elements) {
        return new Stream(elements[Symbol.iterator]());
    }
    next() {
        return this.g.next();
    }
    [Symbol.iterator]() {
        return this.g;
    }
    map(f) {
        return new Stream((0, StreamHelpers_1.mapHelper)(this.g, f));
    }
    flatMap(f) {
        return new Stream((0, StreamHelpers_1.flatMapHelper)(this.g, f));
    }
    dropWhile(f) {
        let foundEligible = false;
        function* helper(v) {
            if (foundEligible || !f(v)) {
                foundEligible = true;
                yield v;
            }
        }
        return this.flatMap(helper);
    }
    drop(n) {
        let idx = 0;
        function helper() {
            return idx++ < n;
        }
        return this.dropWhile(helper);
    }
    takeWhile(f) {
        return new Stream((0, StreamHelpers_1.takeWhileHelper)(this.g, f));
    }
    take(n) {
        return new Stream((0, StreamHelpers_1.takeNHelper)(this.g, n));
    }
    filter(f) {
        return new Stream((0, StreamHelpers_1.filterHelper)(this.g, f));
    }
    every(f) {
        for (const v of this.g) {
            if (!f(v)) {
                return false;
            }
        }
        return true;
    }
    has(f) {
        for (const v of this.g) {
            if (f(v)) {
                return [true, v];
            }
        }
        return [false, null];
    }
    join(...others) {
        return new Stream((0, StreamHelpers_1.joinHelper)(this.g, others));
    }
    getNthOrLast(nth) {
        let remaining = nth;
        let last = null;
        for (const v of this.g) {
            if (remaining-- === 0)
                return v;
            last = v;
        }
        return last;
    }
}
exports.Stream = Stream;
function stream(g) {
    return new Stream(g);
}
exports.stream = stream;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\stream\\Stream.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\stream\\StreamHelpers.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Cstream%5CStreamHelpers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinHelper = exports.takeWhileHelper = exports.takeNHelper = exports.filterHelper = exports.flatMapHelper = exports.mapHelper = exports.nilHelper = void 0;
class Nil {
    [Symbol.iterator]() {
        return this;
    }
    next(value) {
        return { value, done: true };
    }
}
Nil.nil = new Nil();
function nilHelper() {
    return Nil.nil;
}
exports.nilHelper = nilHelper;
function* mapHelper(g, f) {
    for (const v of g) {
        yield f(v);
    }
}
exports.mapHelper = mapHelper;
function* flatMapHelper(g, f) {
    for (const v of g) {
        yield* f(v);
    }
}
exports.flatMapHelper = flatMapHelper;
function* filterHelper(g, f) {
    for (const v of g) {
        if (f(v)) {
            yield v;
        }
    }
}
exports.filterHelper = filterHelper;
function* takeNHelper(g, n) {
    for (let i = 0; i < n; ++i) {
        const cur = g.next();
        if (cur.done) {
            break;
        }
        yield cur.value;
    }
}
exports.takeNHelper = takeNHelper;
function* takeWhileHelper(g, f) {
    let cur = g.next();
    while (!cur.done && f(cur.value)) {
        yield cur.value;
        cur = g.next();
    }
}
exports.takeWhileHelper = takeWhileHelper;
function* joinHelper(g, others) {
    for (let cur = g.next(); !cur.done; cur = g.next()) {
        yield cur.value;
    }
    for (const s of others) {
        for (let cur = s.next(); !cur.done; cur = s.next()) {
            yield cur.value;
        }
    }
}
exports.joinHelper = joinHelper;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\stream\\StreamHelpers.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\utils\\hash.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Cutils%5Chash.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hash = void 0;
const crc32Table = [
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832,
    0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a,
    0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,
    0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4,
    0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074,
    0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525,
    0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76,
    0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6,
    0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,
    0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,
    0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330,
    0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
];
function hash(repr) {
    let crc = 0xffffffff;
    for (let idx = 0; idx < repr.length; ++idx) {
        const c = repr.charCodeAt(idx);
        if (c < 0x80) {
            crc = crc32Table[(crc & 0xff) ^ c] ^ (crc >> 8);
        }
        else if (c < 0x800) {
            crc = crc32Table[(crc & 0xff) ^ (192 | ((c >> 6) & 31))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
        else if (c >= 0xd800 && c < 0xe000) {
            const cNext = repr.charCodeAt(++idx);
            if (c >= 0xdc00 || cNext < 0xdc00 || cNext > 0xdfff || Number.isNaN(cNext)) {
                idx -= 1;
                crc = crc32Table[(crc & 0xff) ^ 0xef] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbf] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbd] ^ (crc >> 8);
            }
            else {
                const c1 = (c & 1023) + 64;
                const c2 = cNext & 1023;
                crc = crc32Table[(crc & 0xff) ^ (240 | ((c1 >> 8) & 7))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c1 >> 2) & 63))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c2 >> 6) & 15) | ((c1 & 3) << 4))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | (c2 & 63))] ^ (crc >> 8);
            }
        }
        else {
            crc = crc32Table[(crc & 0xff) ^ (224 | ((c >> 12) & 15))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | ((c >> 6) & 63))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
    }
    return (crc | 0) + 0x80000000;
}
exports.hash = hash;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\utils\\hash.js",}],
["F:\\metamask-extension\\node_modules\\fast-check\\lib\\utils\\stringify.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfast-check%5Clib%5Cutils%5Cstringify.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncStringify = exports.possiblyAsyncStringify = exports.stringify = exports.stringifyInternal = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = void 0;
exports.toStringMethod = Symbol('fast-check/toStringMethod');
function hasToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.toStringMethod in instance &&
        typeof instance[exports.toStringMethod] === 'function');
}
exports.hasToStringMethod = hasToStringMethod;
exports.asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');
function hasAsyncToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.asyncToStringMethod in instance &&
        typeof instance[exports.asyncToStringMethod] === 'function');
}
exports.hasAsyncToStringMethod = hasAsyncToStringMethod;
const findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
    if (s.description !== undefined)
        return s.description;
    const m = findSymbolNameRegex.exec(String(s));
    return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
    switch (numValue) {
        case 0:
            return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';
        case Number.NEGATIVE_INFINITY:
            return 'Number.NEGATIVE_INFINITY';
        case Number.POSITIVE_INFINITY:
            return 'Number.POSITIVE_INFINITY';
        default:
            return numValue === numValue ? String(numValue) : 'Number.NaN';
    }
}
function isSparseArray(arr) {
    let previousNumberedIndex = -1;
    for (const index in arr) {
        const numberedIndex = Number(index);
        if (numberedIndex !== previousNumberedIndex + 1)
            return true;
        previousNumberedIndex = numberedIndex;
    }
    return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value, previousValues, getAsyncContent) {
    const currentValues = previousValues.concat([value]);
    if (typeof value === 'object') {
        if (previousValues.indexOf(value) !== -1) {
            return '[cyclic]';
        }
    }
    if (hasAsyncToStringMethod(value)) {
        const content = getAsyncContent(value);
        if (content.state === 'fulfilled') {
            return content.value;
        }
    }
    if (hasToStringMethod(value)) {
        try {
            return value[exports.toStringMethod]();
        }
        catch (err) {
        }
    }
    switch (Object.prototype.toString.call(value)) {
        case '[object Array]': {
            const arr = value;
            if (arr.length >= 50 && isSparseArray(arr)) {
                const assignments = [];
                for (const index in arr) {
                    if (!Number.isNaN(Number(index)))
                        assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
                }
                return assignments.length !== 0
                    ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})`
                    : `Array(${arr.length})`;
            }
            const stringifiedArray = arr.map((v) => stringifyInternal(v, currentValues, getAsyncContent)).join(',');
            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
        }
        case '[object BigInt]':
            return `${value}n`;
        case '[object Boolean]':
            return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;
        case '[object Date]': {
            const d = value;
            return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;
        }
        case '[object Map]':
            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object Null]':
            return `null`;
        case '[object Number]':
            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;
        case '[object Object]': {
            try {
                const toStringAccessor = value.toString;
                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {
                    return value.toString();
                }
            }
            catch (err) {
                return '[object Object]';
            }
            const mapper = (k) => `${k === '__proto__'
                ? '["__proto__"]'
                : typeof k === 'symbol'
                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`
                    : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;
            const stringifiedProperties = [
                ...Object.keys(value).map(mapper),
                ...Object.getOwnPropertySymbols(value)
                    .filter((s) => {
                    const descriptor = Object.getOwnPropertyDescriptor(value, s);
                    return descriptor && descriptor.enumerable;
                })
                    .map(mapper),
            ];
            const rawRepr = '{' + stringifiedProperties.join(',') + '}';
            if (Object.getPrototypeOf(value) === null) {
                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;
            }
            return rawRepr;
        }
        case '[object Set]':
            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object String]':
            return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;
        case '[object Symbol]': {
            const s = value;
            if (Symbol.keyFor(s) !== undefined) {
                return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;
            }
            const desc = getSymbolDescription(s);
            if (desc === null) {
                return 'Symbol()';
            }
            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];
            return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;
        }
        case '[object Promise]': {
            const promiseContent = getAsyncContent(value);
            switch (promiseContent.state) {
                case 'fulfilled':
                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'rejected':
                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'pending':
                    return `new Promise(() => {/*pending*/})`;
                case 'unknown':
                default:
                    return `new Promise(() => {/*unknown*/})`;
            }
        }
        case '[object Error]':
            if (value instanceof Error) {
                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;
            }
            break;
        case '[object Undefined]':
            return `undefined`;
        case '[object Int8Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Int16Array]':
        case '[object Uint16Array]':
        case '[object Int32Array]':
        case '[object Uint32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object BigInt64Array]':
        case '[object BigUint64Array]': {
            if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {
                return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;
            }
            const valuePrototype = Object.getPrototypeOf(value);
            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
            if (typeof className === 'string') {
                const typedArray = value;
                const valuesFromTypedArr = typedArray.values();
                return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;
            }
            break;
        }
    }
    try {
        return value.toString();
    }
    catch (_a) {
        return Object.prototype.toString.call(value);
    }
}
exports.stringifyInternal = stringifyInternal;
function stringify(value) {
    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));
}
exports.stringify = stringify;
function possiblyAsyncStringify(value) {
    const stillPendingMarker = Symbol();
    const pendingPromisesForCache = [];
    const cache = new Map();
    function createDelay0() {
        let handleId = null;
        const cancel = () => {
            if (handleId !== null) {
                clearTimeout(handleId);
            }
        };
        const delay = new Promise((resolve) => {
            handleId = setTimeout(() => {
                handleId = null;
                resolve(stillPendingMarker);
            }, 0);
        });
        return { delay, cancel };
    }
    const unknownState = { state: 'unknown', value: undefined };
    const getAsyncContent = function getAsyncContent(data) {
        const cacheKey = data;
        if (cache.has(cacheKey)) {
            return cache.get(cacheKey);
        }
        const delay0 = createDelay0();
        const p = exports.asyncToStringMethod in data
            ? Promise.resolve().then(() => data[exports.asyncToStringMethod]())
            : data;
        p.catch(() => { });
        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
            if (successValue === stillPendingMarker)
                cache.set(cacheKey, { state: 'pending', value: undefined });
            else
                cache.set(cacheKey, { state: 'fulfilled', value: successValue });
            delay0.cancel();
        }, (errorValue) => {
            cache.set(cacheKey, { state: 'rejected', value: errorValue });
            delay0.cancel();
        }));
        cache.set(cacheKey, unknownState);
        return unknownState;
    };
    function loop() {
        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);
        if (pendingPromisesForCache.length === 0) {
            return stringifiedValue;
        }
        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);
    }
    return loop();
}
exports.possiblyAsyncStringify = possiblyAsyncStringify;
async function asyncStringify(value) {
    return Promise.resolve(possiblyAsyncStringify(value));
}
exports.asyncStringify = asyncStringify;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check",file:"node_modules\\fast-check\\lib\\utils\\stringify.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cconstants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FOCUS_NO_AUTOFOCUS = exports.FOCUS_AUTO = exports.FOCUS_ALLOW = exports.FOCUS_DISABLED = exports.FOCUS_GROUP = void 0;
/**
 * defines a focus group
 */
exports.FOCUS_GROUP = 'data-focus-lock';
/**
 * disables element discovery inside a group marked by key
 */
exports.FOCUS_DISABLED = 'data-focus-lock-disabled';
/**
 * allows uncontrolled focus within the marked area, effectively disabling focus lock for it's content
 */
exports.FOCUS_ALLOW = 'data-no-focus-lock';
/**
 * instructs autofocus engine to pick default autofocus inside a given node
 * can be set on the element or container
 */
exports.FOCUS_AUTO = 'data-autofocus-inside';
/**
 * instructs autofocus to ignore elements within a given node
 * can be set on the element or container
 */
exports.FOCUS_NO_AUTOFOCUS = 'data-no-autofocus';

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\constants.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusInside.js", {"./utils/DOMutils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/all-affected":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./utils/getActiveElement":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CfocusInside.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusInside = void 0;
var DOMutils_1 = require("./utils/DOMutils");
var all_affected_1 = require("./utils/all-affected");
var array_1 = require("./utils/array");
var getActiveElement_1 = require("./utils/getActiveElement");
var focusInFrame = function (frame, activeElement) { return frame === activeElement; };
var focusInsideIframe = function (topNode, activeElement) {
    return Boolean((0, array_1.toArray)(topNode.querySelectorAll('iframe')).some(function (node) { return focusInFrame(node, activeElement); }));
};
/**
 * @returns {Boolean} true, if the current focus is inside given node or nodes
 */
var focusInside = function (topNode, activeElement) {
    // const activeElement = document && getActiveElement();
    if (activeElement === void 0) { activeElement = (0, getActiveElement_1.getActiveElement)((0, array_1.getFirst)(topNode).ownerDocument); }
    if (!activeElement || (activeElement.dataset && activeElement.dataset.focusGuard)) {
        return false;
    }
    return (0, all_affected_1.getAllAffectedNodes)(topNode).some(function (node) {
        return (0, DOMutils_1.contains)(node, activeElement) || focusInsideIframe(node, activeElement);
    });
};
exports.focusInside = focusInside;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusInside.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusIsHidden.js", {"./constants":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\constants.js","./utils/DOMutils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./utils/getActiveElement":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CfocusIsHidden.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusIsHidden = void 0;
var constants_1 = require("./constants");
var DOMutils_1 = require("./utils/DOMutils");
var array_1 = require("./utils/array");
var getActiveElement_1 = require("./utils/getActiveElement");
/**
 * focus is hidden FROM the focus-lock
 * ie contained inside a node focus-lock shall ignore
 * @returns {boolean} focus is currently is in "allow" area
 */
var focusIsHidden = function (inDocument) {
    if (inDocument === void 0) { inDocument = document; }
    var activeElement = (0, getActiveElement_1.getActiveElement)(inDocument);
    if (!activeElement) {
        return false;
    }
    // this does not support setting FOCUS_ALLOW within shadow dom
    return (0, array_1.toArray)(inDocument.querySelectorAll("[".concat(constants_1.FOCUS_ALLOW, "]"))).some(function (node) { return (0, DOMutils_1.contains)(node, activeElement); });
};
exports.focusIsHidden = focusIsHidden;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusIsHidden.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusMerge.js", {"./solver":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\solver.js","./utils/DOMutils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/all-affected":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./utils/auto-focus":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\auto-focus.js","./utils/getActiveElement":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js","./utils/is":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js","./utils/parenting":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CfocusMerge.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocusMerge = void 0;
var solver_1 = require("./solver");
var DOMutils_1 = require("./utils/DOMutils");
var all_affected_1 = require("./utils/all-affected");
var array_1 = require("./utils/array");
var auto_focus_1 = require("./utils/auto-focus");
var getActiveElement_1 = require("./utils/getActiveElement");
var is_1 = require("./utils/is");
var parenting_1 = require("./utils/parenting");
var reorderNodes = function (srcNodes, dstNodes) {
    var remap = new Map();
    // no Set(dstNodes) for IE11 :(
    dstNodes.forEach(function (entity) { return remap.set(entity.node, entity); });
    // remap to dstNodes
    return srcNodes.map(function (node) { return remap.get(node); }).filter(is_1.isDefined);
};
/**
 * given top node(s) and the last active element return the element to be focused next
 * @param topNode
 * @param lastNode
 */
var getFocusMerge = function (topNode, lastNode) {
    var activeElement = (0, getActiveElement_1.getActiveElement)((0, array_1.asArray)(topNode).length > 0 ? document : (0, array_1.getFirst)(topNode).ownerDocument);
    var entries = (0, all_affected_1.getAllAffectedNodes)(topNode).filter(is_1.isNotAGuard);
    var commonParent = (0, parenting_1.getTopCommonParent)(activeElement || topNode, topNode, entries);
    var visibilityCache = new Map();
    var anyFocusable = (0, DOMutils_1.getAllTabbableNodes)(entries, visibilityCache);
    var innerElements = (0, DOMutils_1.getTabbableNodes)(entries, visibilityCache).filter(function (_a) {
        var node = _a.node;
        return (0, is_1.isNotAGuard)(node);
    });
    if (!innerElements[0]) {
        innerElements = anyFocusable;
        if (!innerElements[0]) {
            return undefined;
        }
    }
    var outerNodes = (0, DOMutils_1.getAllTabbableNodes)([commonParent], visibilityCache).map(function (_a) {
        var node = _a.node;
        return node;
    });
    var orderedInnerElements = reorderNodes(outerNodes, innerElements);
    var innerNodes = orderedInnerElements.map(function (_a) {
        var node = _a.node;
        return node;
    });
    var newId = (0, solver_1.newFocus)(innerNodes, outerNodes, activeElement, lastNode);
    if (newId === solver_1.NEW_FOCUS) {
        var focusNode = (0, auto_focus_1.pickAutofocus)(anyFocusable, innerNodes, (0, parenting_1.allParentAutofocusables)(entries, visibilityCache));
        if (focusNode) {
            return { node: focusNode };
        }
        else {
            console.warn('focus-lock: cannot find any node to move focus into');
            return undefined;
        }
    }
    if (newId === undefined) {
        return newId;
    }
    return orderedInnerElements[newId];
};
exports.getFocusMerge = getFocusMerge;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusMerge.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusables.js", {"./utils/DOMutils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./utils/all-affected":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/is":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js","./utils/parenting":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cfocusables.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocusableIn = exports.getFocusabledIn = void 0;
var DOMutils_1 = require("./utils/DOMutils");
var all_affected_1 = require("./utils/all-affected");
var is_1 = require("./utils/is");
var parenting_1 = require("./utils/parenting");
/**
 * return list of focusable elements inside a given top node
 * @deprecated use {@link getFocusableIn}. Yep, there is typo in the function name
 */
var getFocusabledIn = function (topNode) {
    var entries = (0, all_affected_1.getAllAffectedNodes)(topNode).filter(is_1.isNotAGuard);
    var commonParent = (0, parenting_1.getTopCommonParent)(topNode, topNode, entries);
    var visibilityCache = new Map();
    var outerNodes = (0, DOMutils_1.getTabbableNodes)([commonParent], visibilityCache, true);
    var innerElements = (0, DOMutils_1.getTabbableNodes)(entries, visibilityCache)
        .filter(function (_a) {
        var node = _a.node;
        return (0, is_1.isNotAGuard)(node);
    })
        .map(function (_a) {
        var node = _a.node;
        return node;
    });
    return outerNodes.map(function (_a) {
        var node = _a.node, index = _a.index;
        return ({
            node: node,
            index: index,
            lockItem: innerElements.indexOf(node) >= 0,
            guard: (0, is_1.isGuard)(node),
        });
    });
};
exports.getFocusabledIn = getFocusabledIn;
/**
 * return list of focusable elements inside a given top node
 */
exports.getFocusableIn = exports.getFocusabledIn;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\focusables.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\index.js", {"./constants":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\constants.js","./focusInside":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusInside.js","./focusIsHidden":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusIsHidden.js","./focusMerge":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusMerge.js","./focusables":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusables.js","./setFocus":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\setFocus.js","./sibling":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\sibling.js","./tabHook":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\tabHook.js","./utils/all-affected":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js","./utils/getActiveElement":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js","tslib":"F:\\metamask-extension\\node_modules\\tslib\\tslib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveElement = exports.focusPrevElement = exports.focusNextElement = exports.getAllAffectedNodes = exports.constants = exports.getFocusabledIn = exports.getFocusableIn = exports.focusMerge = exports.focusIsHidden = exports.focusInside = exports.tabHook = void 0;
var tslib_1 = require("tslib");
var constants = (0, tslib_1.__importStar)(require("./constants"));
exports.constants = constants;
var focusInside_1 = require("./focusInside");
Object.defineProperty(exports, "focusInside", { enumerable: true, get: function () { return focusInside_1.focusInside; } });
var focusIsHidden_1 = require("./focusIsHidden");
Object.defineProperty(exports, "focusIsHidden", { enumerable: true, get: function () { return focusIsHidden_1.focusIsHidden; } });
var focusMerge_1 = require("./focusMerge");
Object.defineProperty(exports, "focusMerge", { enumerable: true, get: function () { return focusMerge_1.getFocusMerge; } });
var focusables_1 = require("./focusables");
Object.defineProperty(exports, "getFocusabledIn", { enumerable: true, get: function () { return focusables_1.getFocusabledIn; } });
Object.defineProperty(exports, "getFocusableIn", { enumerable: true, get: function () { return focusables_1.getFocusableIn; } });
var setFocus_1 = require("./setFocus");
var sibling_1 = require("./sibling");
Object.defineProperty(exports, "focusNextElement", { enumerable: true, get: function () { return sibling_1.focusNextElement; } });
Object.defineProperty(exports, "focusPrevElement", { enumerable: true, get: function () { return sibling_1.focusPrevElement; } });
var tabHook_1 = (0, tslib_1.__importDefault)(require("./tabHook"));
exports.tabHook = tabHook_1.default;
var all_affected_1 = require("./utils/all-affected");
Object.defineProperty(exports, "getAllAffectedNodes", { enumerable: true, get: function () { return all_affected_1.getAllAffectedNodes; } });
var getActiveElement_1 = require("./utils/getActiveElement");
Object.defineProperty(exports, "getActiveElement", { enumerable: true, get: function () { return getActiveElement_1.getActiveElement; } });
exports.default = setFocus_1.setFocus;
//

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\index.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\setFocus.js", {"./focusMerge":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\focusMerge.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CsetFocus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setFocus = exports.focusOn = void 0;
var focusMerge_1 = require("./focusMerge");
var focusOn = function (target, focusOptions) {
    if ('focus' in target) {
        target.focus(focusOptions);
    }
    if ('contentWindow' in target && target.contentWindow) {
        target.contentWindow.focus();
    }
};
exports.focusOn = focusOn;
var guardCount = 0;
var lockDisabled = false;
/**
 * Sets focus at a given node. The last focused element will help to determine which element(first or last) should be focused.
 * HTML markers (see {@link __import__('./constants').FOCUS_AUTO} constants) can control autofocus
 * @param topNode
 * @param lastNode
 * @param options
 */
var setFocus = function (topNode, lastNode, options) {
    if (options === void 0) { options = {}; }
    var focusable = (0, focusMerge_1.getFocusMerge)(topNode, lastNode);
    if (lockDisabled) {
        return;
    }
    if (focusable) {
        if (guardCount > 2) {
            // tslint:disable-next-line:no-console
            console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' +
                'See https://github.com/theKashey/focus-lock/#focus-fighting');
            lockDisabled = true;
            setTimeout(function () {
                lockDisabled = false;
            }, 1);
            return;
        }
        guardCount++;
        (0, exports.focusOn)(focusable.node, options.focusOptions);
        guardCount--;
    }
};
exports.setFocus = setFocus;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\setFocus.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\sibling.js", {"./setFocus":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\setFocus.js","./utils/DOMutils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Csibling.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusPrevElement = exports.focusNextElement = void 0;
var setFocus_1 = require("./setFocus");
var DOMutils_1 = require("./utils/DOMutils");
var getRelativeFocusable = function (element, scope) {
    if (!element || !scope || !(0, DOMutils_1.contains)(scope, element)) {
        return {};
    }
    var focusables = (0, DOMutils_1.getTabbableNodes)([scope], new Map());
    var current = focusables.findIndex(function (_a) {
        var node = _a.node;
        return node === element;
    });
    if (current === -1) {
        return {};
    }
    return {
        prev: focusables[current - 1],
        next: focusables[current + 1],
        first: focusables[0],
        last: focusables[focusables.length - 1],
    };
};
var defaultOptions = function (options) {
    return Object.assign({
        scope: document.body,
        cycle: true,
    }, options);
};
/**
 * focuses next element in the tab-order
 * @param baseElement - common parent to scope active element search or tab cycle order
 * @param {FocusNextOptions} [options] - focus options
 */
var focusNextElement = function (baseElement, options) {
    if (options === void 0) { options = {}; }
    var _a = defaultOptions(options), scope = _a.scope, cycle = _a.cycle;
    var _b = getRelativeFocusable(baseElement, scope), next = _b.next, first = _b.first;
    var newTarget = next || (cycle && first);
    if (newTarget) {
        (0, setFocus_1.focusOn)(newTarget.node, options.focusOptions);
    }
};
exports.focusNextElement = focusNextElement;
/**
 * focuses prev element in the tab order
 * @param baseElement - common parent to scope active element search or tab cycle order
 * @param {FocusNextOptions} [options] - focus options
 */
var focusPrevElement = function (baseElement, options) {
    if (options === void 0) { options = {}; }
    var _a = defaultOptions(options), scope = _a.scope, cycle = _a.cycle;
    var _b = getRelativeFocusable(baseElement, scope), prev = _b.prev, last = _b.last;
    var newTarget = prev || (cycle && last);
    if (newTarget) {
        (0, setFocus_1.focusOn)(newTarget.node, options.focusOptions);
    }
};
exports.focusPrevElement = focusPrevElement;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\sibling.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\solver.js", {"./utils/correctFocus":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js","./utils/firstFocus":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js","./utils/is":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Csolver.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newFocus = exports.NEW_FOCUS = void 0;
var correctFocus_1 = require("./utils/correctFocus");
var firstFocus_1 = require("./utils/firstFocus");
var is_1 = require("./utils/is");
exports.NEW_FOCUS = 'NEW_FOCUS';
/**
 * Main solver for the "find next focus" question
 * @param innerNodes
 * @param outerNodes
 * @param activeElement
 * @param lastNode
 * @returns {number|string|undefined|*}
 */
var newFocus = function (innerNodes, outerNodes, activeElement, lastNode) {
    var cnt = innerNodes.length;
    var firstFocus = innerNodes[0];
    var lastFocus = innerNodes[cnt - 1];
    var isOnGuard = (0, is_1.isGuard)(activeElement);
    // focus is inside
    if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
        return undefined;
    }
    var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;
    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
    var indexDiff = activeIndex - lastIndex;
    var firstNodeIndex = outerNodes.indexOf(firstFocus);
    var lastNodeIndex = outerNodes.indexOf(lastFocus);
    var correctedNodes = (0, correctFocus_1.correctNodes)(outerNodes);
    var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;
    var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
    var returnFirstNode = (0, firstFocus_1.pickFocusable)(innerNodes, 0);
    var returnLastNode = (0, firstFocus_1.pickFocusable)(innerNodes, cnt - 1);
    // new focus
    if (activeIndex === -1 || lastNodeInside === -1) {
        return exports.NEW_FOCUS;
    }
    // old focus
    if (!indexDiff && lastNodeInside >= 0) {
        return lastNodeInside;
    }
    // first element
    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
        return returnLastNode;
    }
    // last element
    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
        return returnFirstNode;
    }
    // jump out, but not on the guard
    if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
        return lastNodeInside;
    }
    // focus above lock
    if (activeIndex <= firstNodeIndex) {
        return returnLastNode;
    }
    // focus below lock
    if (activeIndex > lastNodeIndex) {
        return returnFirstNode;
    }
    // index is inside tab order, but outside Lock
    if (indexDiff) {
        if (Math.abs(indexDiff) > 1) {
            return lastNodeInside;
        }
        return (cnt + lastNodeInside + indexDiff) % cnt;
    }
    // do nothing
    return undefined;
};
exports.newFocus = newFocus;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\solver.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\tabHook.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5CtabHook.js
      return function (require, module, exports) {
"use strict";
/* eslint-disable */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @deprecated does nothing
 */
exports.default = {
    attach: function () { },
    detach: function () { },
};

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\tabHook.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js", {"./array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./is":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js","./tabOrder":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\tabOrder.js","./tabUtils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\tabUtils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CDOMutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contains = exports.parentAutofocusables = exports.getAllTabbableNodes = exports.getTabbableNodes = exports.filterAutoFocusable = exports.filterFocusable = void 0;
var array_1 = require("./array");
var is_1 = require("./is");
var tabOrder_1 = require("./tabOrder");
var tabUtils_1 = require("./tabUtils");
/**
 * given list of focusable elements keeps the ones user can interact with
 * @param nodes
 * @param visibilityCache
 */
var filterFocusable = function (nodes, visibilityCache) {
    return (0, array_1.toArray)(nodes)
        .filter(function (node) { return (0, is_1.isVisibleCached)(visibilityCache, node); })
        .filter(function (node) { return (0, is_1.notHiddenInput)(node); });
};
exports.filterFocusable = filterFocusable;
var filterAutoFocusable = function (nodes, cache) {
    if (cache === void 0) { cache = new Map(); }
    return (0, array_1.toArray)(nodes).filter(function (node) { return (0, is_1.isAutoFocusAllowedCached)(cache, node); });
};
exports.filterAutoFocusable = filterAutoFocusable;
/**
 * only tabbable ones
 * (but with guards which would be ignored)
 */
var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {
    return (0, tabOrder_1.orderByTabIndex)((0, exports.filterFocusable)((0, tabUtils_1.getFocusables)(topNodes, withGuards), visibilityCache), true, withGuards);
};
exports.getTabbableNodes = getTabbableNodes;
/**
 * actually anything "focusable", not only tabbable
 * (without guards, as long as they are not expected to be focused)
 */
var getAllTabbableNodes = function (topNodes, visibilityCache) {
    return (0, tabOrder_1.orderByTabIndex)((0, exports.filterFocusable)((0, tabUtils_1.getFocusables)(topNodes), visibilityCache), false);
};
exports.getAllTabbableNodes = getAllTabbableNodes;
/**
 * return list of nodes which are expected to be auto-focused
 * @param topNode
 * @param visibilityCache
 */
var parentAutofocusables = function (topNode, visibilityCache) {
    return (0, exports.filterFocusable)((0, tabUtils_1.getParentAutofocusables)(topNode), visibilityCache);
};
exports.parentAutofocusables = parentAutofocusables;
/*
 * Determines if element is contained in scope, including nested shadow DOMs
 */
var contains = function (scope, element) {
    if (scope.shadowRoot) {
        return (0, exports.contains)(scope.shadowRoot, element);
    }
    else {
        if (Object.getPrototypeOf(scope).contains !== undefined &&
            Object.getPrototypeOf(scope).contains.call(scope, element)) {
            return true;
        }
        return (0, array_1.toArray)(scope.children).some(function (child) {
            var _a;
            if (child instanceof HTMLIFrameElement) {
                var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;
                if (iframeBody) {
                    return (0, exports.contains)(iframeBody, element);
                }
                return false;
            }
            return (0, exports.contains)(child, element);
        });
    }
};
exports.contains = contains;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js", {"../constants":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\constants.js","./array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Call-affected.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllAffectedNodes = void 0;
var constants_1 = require("../constants");
var array_1 = require("./array");
/**
 * in case of multiple nodes nested inside each other
 * keeps only top ones
 * this is O(nlogn)
 * @param nodes
 * @returns {*}
 */
var filterNested = function (nodes) {
    var contained = new Set();
    var l = nodes.length;
    for (var i = 0; i < l; i += 1) {
        for (var j = i + 1; j < l; j += 1) {
            var position = nodes[i].compareDocumentPosition(nodes[j]);
            /* eslint-disable no-bitwise */
            if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
                contained.add(j);
            }
            if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
                contained.add(i);
            }
            /* eslint-enable */
        }
    }
    return nodes.filter(function (_, index) { return !contained.has(index); });
};
/**
 * finds top most parent for a node
 * @param node
 * @returns {*}
 */
var getTopParent = function (node) {
    return node.parentNode ? getTopParent(node.parentNode) : node;
};
/**
 * returns all "focus containers" inside a given node
 * @param node
 * @returns {T}
 */
var getAllAffectedNodes = function (node) {
    var nodes = (0, array_1.asArray)(node);
    return nodes.filter(Boolean).reduce(function (acc, currentNode) {
        var group = currentNode.getAttribute(constants_1.FOCUS_GROUP);
        acc.push.apply(acc, (group
            ? filterNested((0, array_1.toArray)(getTopParent(currentNode).querySelectorAll("[".concat(constants_1.FOCUS_GROUP, "=\"").concat(group, "\"]:not([").concat(constants_1.FOCUS_DISABLED, "=\"disabled\"])"))))
            : [currentNode]));
        return acc;
    }, []);
};
exports.getAllAffectedNodes = getAllAffectedNodes;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\all-affected.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Carray.js
      return function (require, module, exports) {
"use strict";
/*
IE11 support
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFirst = exports.asArray = exports.toArray = void 0;
var toArray = function (a) {
    var ret = Array(a.length);
    for (var i = 0; i < a.length; ++i) {
        ret[i] = a[i];
    }
    return ret;
};
exports.toArray = toArray;
var asArray = function (a) { return (Array.isArray(a) ? a : [a]); };
exports.asArray = asArray;
var getFirst = function (a) { return (Array.isArray(a) ? a[0] : a); };
exports.getFirst = getFirst;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\array.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\auto-focus.js", {"./DOMutils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./firstFocus":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js","./is":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Cauto-focus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickAutofocus = void 0;
var DOMutils_1 = require("./DOMutils");
var firstFocus_1 = require("./firstFocus");
var is_1 = require("./is");
var findAutoFocused = function (autoFocusables) {
    return function (node) {
        var _a;
        var autofocus = (_a = (0, is_1.getDataset)(node)) === null || _a === void 0 ? void 0 : _a.autofocus;
        return (
        // @ts-expect-error
        node.autofocus ||
            //
            (autofocus !== undefined && autofocus !== 'false') ||
            //
            autoFocusables.indexOf(node) >= 0);
    };
};
var pickAutofocus = function (nodesIndexes, orderedNodes, groups) {
    var nodes = nodesIndexes.map(function (_a) {
        var node = _a.node;
        return node;
    });
    var autoFocusable = (0, DOMutils_1.filterAutoFocusable)(nodes.filter(findAutoFocused(groups)));
    if (autoFocusable && autoFocusable.length) {
        return (0, firstFocus_1.pickFirstFocus)(autoFocusable);
    }
    return (0, firstFocus_1.pickFirstFocus)((0, DOMutils_1.filterAutoFocusable)(orderedNodes));
};
exports.pickAutofocus = pickAutofocus;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\auto-focus.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js", {"./is":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CcorrectFocus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.correctNodes = exports.correctNode = void 0;
var is_1 = require("./is");
var findSelectedRadio = function (node, nodes) {
    return nodes
        .filter(is_1.isRadioElement)
        .filter(function (el) { return el.name === node.name; })
        .filter(function (el) { return el.checked; })[0] || node;
};
var correctNode = function (node, nodes) {
    if ((0, is_1.isRadioElement)(node) && node.name) {
        return findSelectedRadio(node, nodes);
    }
    return node;
};
exports.correctNode = correctNode;
/**
 * giving a set of radio inputs keeps only selected (tabbable) ones
 * @param nodes
 */
var correctNodes = function (nodes) {
    // IE11 has no Set(array) constructor
    var resultSet = new Set();
    nodes.forEach(function (node) { return resultSet.add((0, exports.correctNode)(node, nodes)); });
    // using filter to support IE11
    return nodes.filter(function (node) { return resultSet.has(node); });
};
exports.correctNodes = correctNodes;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js", {"./correctFocus":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\correctFocus.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CfirstFocus.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickFocusable = exports.pickFirstFocus = void 0;
var correctFocus_1 = require("./correctFocus");
var pickFirstFocus = function (nodes) {
    if (nodes[0] && nodes.length > 1) {
        return (0, correctFocus_1.correctNode)(nodes[0], nodes);
    }
    return nodes[0];
};
exports.pickFirstFocus = pickFirstFocus;
var pickFocusable = function (nodes, index) {
    if (nodes.length > 1) {
        return nodes.indexOf((0, correctFocus_1.correctNode)(nodes[index], nodes));
    }
    return index;
};
exports.pickFocusable = pickFocusable;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\firstFocus.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js", {"./safe":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\safe.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CgetActiveElement.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveElement = void 0;
/**
 * returns active element from document or from nested shadowdoms
 */
var safe_1 = require("./safe");
var getActiveElement = function (inDocument) {
    if (inDocument === void 0) { inDocument = document; }
    if (!inDocument || !inDocument.activeElement) {
        return undefined;
    }
    var activeElement = inDocument.activeElement;
    return (activeElement.shadowRoot
        ? (0, exports.getActiveElement)(activeElement.shadowRoot)
        : activeElement instanceof HTMLIFrameElement && (0, safe_1.safeProbe)(function () { return activeElement.contentWindow.document; })
            ? (0, exports.getActiveElement)(activeElement.contentWindow.document)
            : activeElement);
};
exports.getActiveElement = getActiveElement;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\getActiveElement.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\is.js", {"../constants":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\constants.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Cis.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDefined = exports.isNotAGuard = exports.isGuard = exports.isAutoFocusAllowed = exports.notHiddenInput = exports.isRadioElement = exports.isHTMLInputElement = exports.isHTMLButtonElement = exports.getDataset = exports.isAutoFocusAllowedCached = exports.isVisibleCached = void 0;
var constants_1 = require("../constants");
var isElementHidden = function (node) {
    // we can measure only "elements"
    // consider others as "visible"
    if (node.nodeType !== Node.ELEMENT_NODE) {
        return false;
    }
    var computedStyle = window.getComputedStyle(node, null);
    if (!computedStyle || !computedStyle.getPropertyValue) {
        return false;
    }
    return (computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden');
};
var getParentNode = function (node) {
    // DOCUMENT_FRAGMENT_NODE can also point on ShadowRoot. In this case .host will point on the next node
    return node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE
        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.parentNode.host
        : node.parentNode;
};
var isTopNode = function (node) {
    // @ts-ignore
    return node === document || (node && node.nodeType === Node.DOCUMENT_NODE);
};
var isVisibleUncached = function (node, checkParent) {
    return !node || isTopNode(node) || (!isElementHidden(node) && checkParent(getParentNode(node)));
};
var isVisibleCached = function (visibilityCache, node) {
    var cached = visibilityCache.get(node);
    if (cached !== undefined) {
        return cached;
    }
    var result = isVisibleUncached(node, exports.isVisibleCached.bind(undefined, visibilityCache));
    visibilityCache.set(node, result);
    return result;
};
exports.isVisibleCached = isVisibleCached;
var isAutoFocusAllowedUncached = function (node, checkParent) {
    return node && !isTopNode(node) ? ((0, exports.isAutoFocusAllowed)(node) ? checkParent(getParentNode(node)) : false) : true;
};
var isAutoFocusAllowedCached = function (cache, node) {
    var cached = cache.get(node);
    if (cached !== undefined) {
        return cached;
    }
    var result = isAutoFocusAllowedUncached(node, exports.isAutoFocusAllowedCached.bind(undefined, cache));
    cache.set(node, result);
    return result;
};
exports.isAutoFocusAllowedCached = isAutoFocusAllowedCached;
var getDataset = function (node) {
    // @ts-ignore
    return node.dataset;
};
exports.getDataset = getDataset;
var isHTMLButtonElement = function (node) { return node.tagName === 'BUTTON'; };
exports.isHTMLButtonElement = isHTMLButtonElement;
var isHTMLInputElement = function (node) { return node.tagName === 'INPUT'; };
exports.isHTMLInputElement = isHTMLInputElement;
var isRadioElement = function (node) {
    return (0, exports.isHTMLInputElement)(node) && node.type === 'radio';
};
exports.isRadioElement = isRadioElement;
var notHiddenInput = function (node) {
    return !(((0, exports.isHTMLInputElement)(node) || (0, exports.isHTMLButtonElement)(node)) && (node.type === 'hidden' || node.disabled));
};
exports.notHiddenInput = notHiddenInput;
var isAutoFocusAllowed = function (node) {
    var attribute = node.getAttribute(constants_1.FOCUS_NO_AUTOFOCUS);
    return ![true, 'true', ''].includes(attribute);
};
exports.isAutoFocusAllowed = isAutoFocusAllowed;
var isGuard = function (node) { var _a; return Boolean(node && ((_a = (0, exports.getDataset)(node)) === null || _a === void 0 ? void 0 : _a.focusGuard)); };
exports.isGuard = isGuard;
var isNotAGuard = function (node) { return !(0, exports.isGuard)(node); };
exports.isNotAGuard = isNotAGuard;
var isDefined = function (x) { return Boolean(x); };
exports.isDefined = isDefined;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\is.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js", {"./DOMutils":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\DOMutils.js","./array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Cparenting.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.allParentAutofocusables = exports.getTopCommonParent = exports.getCommonParent = void 0;
var DOMutils_1 = require("./DOMutils");
var DOMutils_2 = require("./DOMutils");
var array_1 = require("./array");
var getParents = function (node, parents) {
    if (parents === void 0) { parents = []; }
    parents.push(node);
    if (node.parentNode) {
        getParents(node.parentNode.host || node.parentNode, parents);
    }
    return parents;
};
/**
 * finds a parent for both nodeA and nodeB
 * @param nodeA
 * @param nodeB
 * @returns {boolean|*}
 */
var getCommonParent = function (nodeA, nodeB) {
    var parentsA = getParents(nodeA);
    var parentsB = getParents(nodeB);
    // tslint:disable-next-line:prefer-for-of
    for (var i = 0; i < parentsA.length; i += 1) {
        var currentParent = parentsA[i];
        if (parentsB.indexOf(currentParent) >= 0) {
            return currentParent;
        }
    }
    return false;
};
exports.getCommonParent = getCommonParent;
var getTopCommonParent = function (baseActiveElement, leftEntry, rightEntries) {
    var activeElements = (0, array_1.asArray)(baseActiveElement);
    var leftEntries = (0, array_1.asArray)(leftEntry);
    var activeElement = activeElements[0];
    var topCommon = false;
    leftEntries.filter(Boolean).forEach(function (entry) {
        topCommon = (0, exports.getCommonParent)(topCommon || entry, entry) || topCommon;
        rightEntries.filter(Boolean).forEach(function (subEntry) {
            var common = (0, exports.getCommonParent)(activeElement, subEntry);
            if (common) {
                if (!topCommon || (0, DOMutils_2.contains)(common, topCommon)) {
                    topCommon = common;
                }
                else {
                    topCommon = (0, exports.getCommonParent)(common, topCommon);
                }
            }
        });
    });
    // TODO: add assert here?
    return topCommon;
};
exports.getTopCommonParent = getTopCommonParent;
/**
 * return list of nodes which are expected to be autofocused inside a given top nodes
 * @param entries
 * @param visibilityCache
 */
var allParentAutofocusables = function (entries, visibilityCache) {
    return entries.reduce(function (acc, node) { return acc.concat((0, DOMutils_1.parentAutofocusables)(node, visibilityCache)); }, []);
};
exports.allParentAutofocusables = allParentAutofocusables;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\parenting.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\safe.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Csafe.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeProbe = void 0;
var safeProbe = function (cb) {
    try {
        return cb();
    }
    catch (e) {
        return undefined;
    }
};
exports.safeProbe = safeProbe;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\safe.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\tabOrder.js", {"./array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CtabOrder.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderByTabIndex = exports.tabSort = void 0;
var array_1 = require("./array");
var tabSort = function (a, b) {
    var tabDiff = a.tabIndex - b.tabIndex;
    var indexDiff = a.index - b.index;
    if (tabDiff) {
        if (!a.tabIndex) {
            return 1;
        }
        if (!b.tabIndex) {
            return -1;
        }
    }
    return tabDiff || indexDiff;
};
exports.tabSort = tabSort;
var orderByTabIndex = function (nodes, filterNegative, keepGuards) {
    return (0, array_1.toArray)(nodes)
        .map(function (node, index) { return ({
        node: node,
        index: index,
        tabIndex: keepGuards && node.tabIndex === -1 ? ((node.dataset || {}).focusGuard ? 0 : -1) : node.tabIndex,
    }); })
        .filter(function (data) { return !filterNegative || data.tabIndex >= 0; })
        .sort(exports.tabSort);
};
exports.orderByTabIndex = orderByTabIndex;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\tabOrder.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\tabUtils.js", {"../constants":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\constants.js","./array":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\array.js","./tabbables":"F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\tabbables.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5CtabUtils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParentAutofocusables = exports.getFocusables = void 0;
var constants_1 = require("../constants");
var array_1 = require("./array");
var tabbables_1 = require("./tabbables");
var queryTabbables = tabbables_1.tabbables.join(',');
var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
var getFocusablesWithShadowDom = function (parent, withGuards) {
    return (0, array_1.toArray)((parent.shadowRoot || parent).children).reduce(function (acc, child) {
        return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
    }, []);
};
var getFocusablesWithIFrame = function (parent, withGuards) {
    var _a;
    // contentDocument of iframe will be null if current origin cannot access it
    if (parent instanceof HTMLIFrameElement && ((_a = parent.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
        return (0, exports.getFocusables)([parent.contentDocument.body], withGuards);
    }
    return [parent];
};
var getFocusables = function (parents, withGuards) {
    return parents.reduce(function (acc, parent) {
        var _a;
        var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);
        var focusableWithIframes = (_a = []).concat.apply(_a, focusableWithShadowDom.map(function (node) { return getFocusablesWithIFrame(node, withGuards); }));
        return acc.concat(
        // add all tabbables inside and within shadow DOMs in DOM order
        focusableWithIframes, 
        // add if node is tabbable itself
        parent.parentNode
            ? (0, array_1.toArray)(parent.parentNode.querySelectorAll(queryTabbables)).filter(function (node) { return node === parent; })
            : []);
    }, []);
};
exports.getFocusables = getFocusables;
/**
 * return a list of focusable nodes within an area marked as "auto-focusable"
 * @param parent
 */
var getParentAutofocusables = function (parent) {
    var parentFocus = parent.querySelectorAll("[".concat(constants_1.FOCUS_AUTO, "]"));
    return (0, array_1.toArray)(parentFocus)
        .map(function (node) { return (0, exports.getFocusables)([node]); })
        .reduce(function (acc, nodes) { return acc.concat(nodes); }, []);
};
exports.getParentAutofocusables = getParentAutofocusables;

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\tabUtils.js",}],
["F:\\metamask-extension\\node_modules\\focus-lock\\dist\\es5\\utils\\tabbables.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfocus-lock%5Cdist%5Ces5%5Cutils%5Ctabbables.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tabbables = void 0;
/**
 * list of the object to be considered as focusable
 */
exports.tabbables = [
    'button:enabled',
    'select:enabled',
    'textarea:enabled',
    'input:enabled',
    // elements with explicit roles will also use explicit tabindex
    // '[role="button"]',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[tabindex]',
    '[contenteditable]',
    '[autofocus]',
];

      };
    };
  }
  }
}, {package:"react-focus-lock>focus-lock",file:"node_modules\\focus-lock\\dist\\es5\\utils\\tabbables.js",}],
["F:\\metamask-extension\\node_modules\\foreach\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cforeach%5Cindex.js
      return function (require, module, exports) {

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>json-pointer>foreach",file:"node_modules\\foreach\\index.js",}],
["F:\\metamask-extension\\node_modules\\function-bind\\implementation.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfunction-bind%5Cimplementation.js
      return function (require, module, exports) {
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

      };
    };
  }
  }
}, {package:"browserify>has>function-bind",file:"node_modules\\function-bind\\implementation.js",}],
["F:\\metamask-extension\\node_modules\\function-bind\\index.js", {"./implementation":"F:\\metamask-extension\\node_modules\\function-bind\\implementation.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfunction-bind%5Cindex.js
      return function (require, module, exports) {
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

      };
    };
  }
  }
}, {package:"browserify>has>function-bind",file:"node_modules\\function-bind\\index.js",}],
["F:\\metamask-extension\\node_modules\\functions-have-names\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfunctions-have-names%5Cindex.js
      return function (require, module, exports) {
'use strict';

var functionsHaveNames = function functionsHaveNames() {
	return typeof function f() {}.name === 'string';
};

var gOPD = Object.getOwnPropertyDescriptor;
if (gOPD) {
	try {
		gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		gOPD = null;
	}
}

functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
	if (!functionsHaveNames() || !gOPD) {
		return false;
	}
	var desc = gOPD(function () {}, 'name');
	return !!desc && !!desc.configurable;
};

var $bind = Function.prototype.bind;

functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
	return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
};

module.exports = functionsHaveNames;

      };
    };
  }
  }
}, {package:"string.prototype.matchall>regexp.prototype.flags>functions-have-names",file:"node_modules\\functions-have-names\\index.js",}],
["F:\\metamask-extension\\node_modules\\fuse.js\\dist\\fuse.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cfuse.js%5Cdist%5Cfuse.js
      return function (require, module, exports) {
/*!
 * Fuse.js v3.6.1 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("Fuse",[],t):"object"==typeof exports?exports.Fuse=t():e.Fuse=t()}(this,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){function n(e){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var i=r(1),a=r(7),s=a.get,c=(a.deepValue,a.isArray),h=function(){function e(t,r){var n=r.location,o=void 0===n?0:n,i=r.distance,a=void 0===i?100:i,c=r.threshold,h=void 0===c?.6:c,l=r.maxPatternLength,u=void 0===l?32:l,f=r.caseSensitive,v=void 0!==f&&f,p=r.tokenSeparator,d=void 0===p?/ +/g:p,g=r.findAllMatches,y=void 0!==g&&g,m=r.minMatchCharLength,k=void 0===m?1:m,b=r.id,S=void 0===b?null:b,x=r.keys,M=void 0===x?[]:x,_=r.shouldSort,w=void 0===_||_,L=r.getFn,A=void 0===L?s:L,O=r.sortFn,C=void 0===O?function(e,t){return e.score-t.score}:O,j=r.tokenize,P=void 0!==j&&j,I=r.matchAllTokens,F=void 0!==I&&I,T=r.includeMatches,N=void 0!==T&&T,z=r.includeScore,E=void 0!==z&&z,W=r.verbose,K=void 0!==W&&W;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:a,threshold:h,maxPatternLength:u,isCaseSensitive:v,tokenSeparator:d,findAllMatches:y,minMatchCharLength:k,id:S,keys:M,includeMatches:N,includeScore:E,shouldSort:w,getFn:A,sortFn:C,verbose:K,tokenize:P,matchAllTokens:F},this.setCollection(t),this._processKeys(M)}var t,r,a;return t=e,(r=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"_processKeys",value:function(e){if(this._keyWeights={},this._keyNames=[],e.length&&"string"==typeof e[0])for(var t=0,r=e.length;t<r;t+=1){var n=e[t];this._keyWeights[n]=1,this._keyNames.push(n)}else{for(var o=null,i=null,a=0,s=0,c=e.length;s<c;s+=1){var h=e[s];if(!h.hasOwnProperty("name"))throw new Error('Missing "name" property in key object');var l=h.name;if(this._keyNames.push(l),!h.hasOwnProperty("weight"))throw new Error('Missing "weight" property in key object');var u=h.weight;if(u<0||u>1)throw new Error('"weight" property in key must bein the range of [0, 1)');i=null==i?u:Math.max(i,u),o=null==o?u:Math.min(o,u),this._keyWeights[l]=u,a+=u}if(a>1)throw new Error("Total of weights cannot exceed 1")}}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var r=this._prepareSearchers(e),n=r.tokenSearchers,o=r.fullSearcher,i=this._search(n,o);return this._computeScore(i),this.options.shouldSort&&this._sort(i),t.limit&&"number"==typeof t.limit&&(i=i.slice(0,t.limit)),this._format(i)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize)for(var r=e.split(this.options.tokenSeparator),n=0,o=r.length;n<o;n+=1)t.push(new i(r[n],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,r=this.list,n={},o=[];if("string"==typeof r[0]){for(var i=0,a=r.length;i<a;i+=1)this._analyze({key:"",value:r[i],record:i,index:i},{resultMap:n,results:o,tokenSearchers:e,fullSearcher:t});return o}for(var s=0,c=r.length;s<c;s+=1)for(var h=r[s],l=0,u=this._keyNames.length;l<u;l+=1){var f=this._keyNames[l];this._analyze({key:f,value:this.options.getFn(h,f),record:h,index:s},{resultMap:n,results:o,tokenSearchers:e,fullSearcher:t})}return o}},{key:"_analyze",value:function(e,t){var r=this,n=e.key,o=e.arrayIndex,i=void 0===o?-1:o,a=e.value,s=e.record,h=e.index,l=t.tokenSearchers,u=void 0===l?[]:l,f=t.fullSearcher,v=t.resultMap,p=void 0===v?{}:v,d=t.results,g=void 0===d?[]:d;!function e(t,o,i,a){if(null!=o)if("string"==typeof o){var s=!1,h=-1,l=0;r._log("\nKey: ".concat(""===n?"--":n));var v=f.search(o);if(r._log('Full text: "'.concat(o,'", score: ').concat(v.score)),r.options.tokenize){for(var d=o.split(r.options.tokenSeparator),y=d.length,m=[],k=0,b=u.length;k<b;k+=1){var S=u[k];r._log('\nPattern: "'.concat(S.pattern,'"'));for(var x=!1,M=0;M<y;M+=1){var _=d[M],w=S.search(_),L={};w.isMatch?(L[_]=w.score,s=!0,x=!0,m.push(w.score)):(L[_]=1,r.options.matchAllTokens||m.push(1)),r._log('Token: "'.concat(_,'", score: ').concat(L[_]))}x&&(l+=1)}h=m[0];for(var A=m.length,O=1;O<A;O+=1)h+=m[O];h/=A,r._log("Token score average:",h)}var C=v.score;h>-1&&(C=(C+h)/2),r._log("Score average:",C);var j=!r.options.tokenize||!r.options.matchAllTokens||l>=u.length;if(r._log("\nCheck Matches: ".concat(j)),(s||v.isMatch)&&j){var P={key:n,arrayIndex:t,value:o,score:C};r.options.includeMatches&&(P.matchedIndices=v.matchedIndices);var I=p[a];I?I.output.push(P):(p[a]={item:i,output:[P]},g.push(p[a]))}}else if(c(o))for(var F=0,T=o.length;F<T;F+=1)e(F,o[F],i,a)}(i,a,s,h)}},{key:"_computeScore",value:function(e){this._log("\n\nComputing score:\n");for(var t=this._keyWeights,r=!!Object.keys(t).length,n=0,o=e.length;n<o;n+=1){for(var i=e[n],a=i.output,s=a.length,c=1,h=0;h<s;h+=1){var l=a[h],u=l.key,f=r?t[u]:1,v=0===l.score&&t&&t[u]>0?Number.EPSILON:l.score;c*=Math.pow(v,f)}i.score=c,this._log(i)}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn)}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var r=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===n(t)&&null!==t){if(-1!==r.indexOf(t))return;r.push(t)}return t},2)),r=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var r=e.output;t.matches=[];for(var n=0,o=r.length;n<o;n+=1){var i=r[n];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,r),a&&o(t,a),e}();e.exports=h},function(e,t,r){function n(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=r(2),i=r(3),a=r(6),s=function(){function e(t,r){var n=r.location,o=void 0===n?0:n,i=r.distance,s=void 0===i?100:i,c=r.threshold,h=void 0===c?.6:c,l=r.maxPatternLength,u=void 0===l?32:l,f=r.isCaseSensitive,v=void 0!==f&&f,p=r.tokenSeparator,d=void 0===p?/ +/g:p,g=r.findAllMatches,y=void 0!==g&&g,m=r.minMatchCharLength,k=void 0===m?1:m,b=r.includeMatches,S=void 0!==b&&b;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:v,tokenSeparator:d,findAllMatches:y,includeMatches:S,minMatchCharLength:k},this.pattern=v?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,r,s;return t=e,(r=[{key:"search",value:function(e){var t=this.options,r=t.isCaseSensitive,n=t.includeMatches;if(r||(e=e.toLowerCase()),this.pattern===e){var a={isMatch:!0,score:0};return n&&(a.matchedIndices=[[0,e.length-1]]),a}var s=this.options,c=s.maxPatternLength,h=s.tokenSeparator;if(this.pattern.length>c)return o(e,this.pattern,h);var l=this.options,u=l.location,f=l.distance,v=l.threshold,p=l.findAllMatches,d=l.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:u,distance:f,threshold:v,findAllMatches:p,minMatchCharLength:d,includeMatches:n})}}])&&n(t.prototype,r),s&&n(t,s),e}();e.exports=s},function(e,t){var r=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(r,"\\$&").replace(n,"|")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,r){var n=r(4),o=r(5);e.exports=function(e,t,r,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,v=void 0!==f&&f,p=i.minMatchCharLength,d=void 0===p?1:p,g=i.includeMatches,y=void 0!==g&&g,m=s,k=e.length,b=u,S=e.indexOf(t,m),x=t.length,M=[],_=0;_<k;_+=1)M[_]=0;if(-1!==S){var w=n(t,{errors:0,currentLocation:S,expectedLocation:m,distance:h});if(b=Math.min(w,b),-1!==(S=e.lastIndexOf(t,m+x))){var L=n(t,{errors:0,currentLocation:S,expectedLocation:m,distance:h});b=Math.min(L,b)}}S=-1;for(var A=[],O=1,C=x+k,j=1<<(x<=31?x-1:30),P=0;P<x;P+=1){for(var I=0,F=C;I<F;){n(t,{errors:P,currentLocation:m+F,expectedLocation:m,distance:h})<=b?I=F:C=F,F=Math.floor((C-I)/2+I)}C=F;var T=Math.max(1,m-F+1),N=v?k:Math.min(m+F,k)+x,z=Array(N+2);z[N+1]=(1<<P)-1;for(var E=N;E>=T;E-=1){var W=E-1,K=r[e.charAt(W)];if(K&&(M[W]=1),z[E]=(z[E+1]<<1|1)&K,0!==P&&(z[E]|=(A[E+1]|A[E])<<1|1|A[E+1]),z[E]&j&&(O=n(t,{errors:P,currentLocation:W,expectedLocation:m,distance:h}))<=b){if(b=O,(S=W)<=m)break;T=Math.max(1,2*m-S)}}if(n(t,{errors:P+1,currentLocation:m,expectedLocation:m,distance:h})>b)break;A=z}var $={isMatch:S>=0,score:0===O?.001:O};return y&&($.matchedIndices=o(M,d)),$}},function(e,t){e.exports=function(e,t){var r=t.errors,n=void 0===r?0:r,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=n/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,r=[],n=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===n?n=i:s||-1===n||((o=i-1)-n+1>=t&&r.push([n,o]),n=-1)}return e[i-1]&&i-n>=t&&r.push([n,i-1]),r}},function(e,t){e.exports=function(e){for(var t={},r=e.length,n=0;n<r;n+=1)t[e.charAt(n)]=0;for(var o=0;o<r;o+=1)t[e.charAt(o)]|=1<<r-o-1;return t}},function(e,t){var r=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)},n=function(e){return null==e?"":function(e){if("string"==typeof e)return e;var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)},o=function(e){return"string"==typeof e},i=function(e){return"number"==typeof e};e.exports={get:function(e,t){var a=[];return function e(t,s){if(s){var c=s.indexOf("."),h=s,l=null;-1!==c&&(h=s.slice(0,c),l=s.slice(c+1));var u=t[h];if(null!=u)if(l||!o(u)&&!i(u))if(r(u))for(var f=0,v=u.length;f<v;f+=1)e(u[f],l);else l&&e(u,l);else a.push(n(u))}else a.push(t)}(e,t),a},isArray:r,isString:o,isNum:i,toString:n}}])});
      };
    };
  }
  }
}, {package:"fuse.js",file:"node_modules\\fuse.js\\dist\\fuse.js",}],
["F:\\metamask-extension\\node_modules\\get-intrinsic\\index.js", {"function-bind":"F:\\metamask-extension\\node_modules\\function-bind\\index.js","has":"F:\\metamask-extension\\node_modules\\has\\src\\index.js","has-proto":"F:\\metamask-extension\\node_modules\\has-proto\\index.js","has-symbols":"F:\\metamask-extension\\node_modules\\has-symbols\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cget-intrinsic%5Cindex.js
      return function (require, module, exports) {
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();
var hasProto = require('has-proto')();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>get-intrinsic",file:"node_modules\\get-intrinsic\\index.js",}],
["F:\\metamask-extension\\node_modules\\get-params\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cget-params%5Cindex.js
      return function (require, module, exports) {
/* global window */
var GetParams = function (func) {
	'use strict';

	if (typeof func !== 'function') {
		return [];
	}

	var patternComments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	var patternArguments = /([^\s,]+)/g;

	var funcString = func
		.toString()
		.replace(patternComments, '');

	var result = funcString
		.slice(
			funcString.indexOf('(') + 1,
			funcString.indexOf(')')
		)
		.match(patternArguments);

	if (result === null) {
		return [];
	}

	return result;
};

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	module.exports = GetParams;
}

if (typeof window !== 'undefined') {
	window.GetParams = GetParams;
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>redux-devtools-core>get-params",file:"node_modules\\get-params\\index.js",}],
["F:\\metamask-extension\\node_modules\\gl-mat4\\identity.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgl-mat4%5Cidentity.js
      return function (require, module, exports) {
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\identity.js",}],
["F:\\metamask-extension\\node_modules\\gl-mat4\\invert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgl-mat4%5Cinvert.js
      return function (require, module, exports) {
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\invert.js",}],
["F:\\metamask-extension\\node_modules\\gl-mat4\\lookAt.js", {"./identity":"F:\\metamask-extension\\node_modules\\gl-mat4\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgl-mat4%5ClookAt.js
      return function (require, module, exports) {
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\lookAt.js",}],
["F:\\metamask-extension\\node_modules\\gl-mat4\\multiply.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgl-mat4%5Cmultiply.js
      return function (require, module, exports) {
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\multiply.js",}],
["F:\\metamask-extension\\node_modules\\gl-mat4\\perspective.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgl-mat4%5Cperspective.js
      return function (require, module, exports) {
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\perspective.js",}],
["F:\\metamask-extension\\node_modules\\gl-mat4\\rotate.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgl-mat4%5Crotate.js
      return function (require, module, exports) {
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-mat4",file:"node_modules\\gl-mat4\\rotate.js",}],
["F:\\metamask-extension\\node_modules\\gl-vec3\\transformMat4.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgl-vec3%5CtransformMat4.js
      return function (require, module, exports) {
module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}
      };
    };
  }
  }
}, {package:"@metamask/logo>gl-vec3",file:"node_modules\\gl-vec3\\transformMat4.js",}],
["F:\\metamask-extension\\node_modules\\gud\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgud%5Cindex.js
      return function (require, module, exports) {
// @flow
'use strict';

var key = '__global_unique_id__';

module.exports = function() {
  return global[key] = (global[key] || 0) + 1;
};

      };
    };
  }
  }
}, {package:"react-router-dom>react-router>mini-create-react-context>gud",file:"node_modules\\gud\\index.js",}],
["F:\\metamask-extension\\node_modules\\has-property-descriptors\\index.js", {"get-intrinsic":"F:\\metamask-extension\\node_modules\\get-intrinsic\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Chas-property-descriptors%5Cindex.js
      return function (require, module, exports) {
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

      };
    };
  }
  }
}, {package:"globalthis>define-properties>has-property-descriptors",file:"node_modules\\has-property-descriptors\\index.js",}],
["F:\\metamask-extension\\node_modules\\has-proto\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Chas-proto%5Cindex.js
      return function (require, module, exports) {
'use strict';

var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>es-abstract>has-proto",file:"node_modules\\has-proto\\index.js",}],
["F:\\metamask-extension\\node_modules\\has-symbols\\index.js", {"./shams":"F:\\metamask-extension\\node_modules\\has-symbols\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Chas-symbols%5Cindex.js
      return function (require, module, exports) {
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>has-symbols",file:"node_modules\\has-symbols\\index.js",}],
["F:\\metamask-extension\\node_modules\\has-symbols\\shams.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Chas-symbols%5Cshams.js
      return function (require, module, exports) {
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>has-symbols",file:"node_modules\\has-symbols\\shams.js",}],
["F:\\metamask-extension\\node_modules\\has-tostringtag\\shams.js", {"has-symbols/shams":"F:\\metamask-extension\\node_modules\\has-symbols\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Chas-tostringtag%5Cshams.js
      return function (require, module, exports) {
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

      };
    };
  }
  }
}, {package:"koa>is-generator-function>has-tostringtag",file:"node_modules\\has-tostringtag\\shams.js",}],
["F:\\metamask-extension\\node_modules\\has\\src\\index.js", {"function-bind":"F:\\metamask-extension\\node_modules\\function-bind\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Chas%5Csrc%5Cindex.js
      return function (require, module, exports) {
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

      };
    };
  }
  }
}, {package:"browserify>has",file:"node_modules\\has\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\header-case\\header-case.js", {"no-case":"F:\\metamask-extension\\node_modules\\no-case\\no-case.js","upper-case":"F:\\metamask-extension\\node_modules\\upper-case\\upper-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cheader-case%5Cheader-case.js
      return function (require, module, exports) {
var noCase = require('no-case')
var upperCase = require('upper-case')

/**
 * Header case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-').replace(/^.|-./g, function (m) {
    return upperCase(m, locale)
  })
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>header-case",file:"node_modules\\header-case\\header-case.js",}],
["F:\\metamask-extension\\node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js", {"react-is":"F:\\metamask-extension\\node_modules\\react-is\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Choist-non-react-statics%5Cdist%5Choist-non-react-statics.cjs.js
      return function (require, module, exports) {
'use strict';

var reactIs = require('react-is');

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

      };
    };
  }
  }
}, {package:"react-redux>hoist-non-react-statics",file:"node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js",}],
["F:\\metamask-extension\\node_modules\\hyphenate-style-name\\index.cjs.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Chyphenate-style-name%5Cindex.cjs.js
      return function (require, module, exports) {
'use strict';

/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

module.exports = hyphenateStyleName;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-camel-case>hyphenate-style-name",file:"node_modules\\hyphenate-style-name\\index.cjs.js",}],
["F:\\metamask-extension\\node_modules\\is-arguments\\index.js", {"call-bind/callBound":"F:\\metamask-extension\\node_modules\\call-bind\\callBound.js","has-tostringtag/shams":"F:\\metamask-extension\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-arguments%5Cindex.js
      return function (require, module, exports) {
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

      };
    };
  }
  }
}, {package:"@metamask/eth-token-tracker>deep-equal>is-arguments",file:"node_modules\\is-arguments\\index.js",}],
["F:\\metamask-extension\\node_modules\\is-date-object\\index.js", {"has-tostringtag/shams":"F:\\metamask-extension\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-date-object%5Cindex.js
      return function (require, module, exports) {
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = require('has-tostringtag/shams')();

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-token-tracker>deep-equal>is-date-object",file:"node_modules\\is-date-object\\index.js",}],
["F:\\metamask-extension\\node_modules\\is-dom\\index.js", {"is-object":"F:\\metamask-extension\\node_modules\\is-object\\index.js","is-window":"F:\\metamask-extension\\node_modules\\is-window\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-dom%5Cindex.js
      return function (require, module, exports) {
var isObject = require('is-object')
var isWindow = require('is-window')

function isNode (val) {
  if (!isObject(val) || !isWindow(window) || typeof window.Node !== 'function') {
    return false
  }

  return typeof val.nodeType === 'number' &&
    typeof val.nodeName === 'string'
}

module.exports = isNode

      };
    };
  }
  }
}, {package:"react-inspector>is-dom",file:"node_modules\\is-dom\\index.js",}],
["F:\\metamask-extension\\node_modules\\is-in-browser\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-in-browser%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = exports.isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

exports.default = isBrowser;
      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss>is-in-browser",file:"node_modules\\is-in-browser\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\is-lower-case\\is-lower-case.js", {"lower-case":"F:\\metamask-extension\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-lower-case%5Cis-lower-case.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

/**
 * Check if a string is lower case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return lowerCase(string, locale) === string
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>is-lower-case",file:"node_modules\\is-lower-case\\is-lower-case.js",}],
["F:\\metamask-extension\\node_modules\\is-object\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-object%5Cindex.js
      return function (require, module, exports) {
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

      };
    };
  }
  }
}, {package:"proxyquire>fill-keys>is-object",file:"node_modules\\is-object\\index.js",}],
["F:\\metamask-extension\\node_modules\\is-regex\\index.js", {"call-bind/callBound":"F:\\metamask-extension\\node_modules\\call-bind\\callBound.js","has-tostringtag/shams":"F:\\metamask-extension\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-regex%5Cindex.js
      return function (require, module, exports) {
'use strict';

var callBound = require('call-bind/callBound');
var hasToStringTag = require('has-tostringtag/shams')();
var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	has = callBound('Object.prototype.hasOwnProperty');
	$exec = callBound('RegExp.prototype.exec');
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			$exec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};

      };
    };
  }
  }
}, {package:"string.prototype.matchall>es-abstract>is-regex",file:"node_modules\\is-regex\\index.js",}],
["F:\\metamask-extension\\node_modules\\is-upper-case\\is-upper-case.js", {"upper-case":"F:\\metamask-extension\\node_modules\\upper-case\\upper-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-upper-case%5Cis-upper-case.js
      return function (require, module, exports) {
var upperCase = require('upper-case')

/**
 * Check if a string is upper case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return upperCase(string, locale) === string
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>is-upper-case",file:"node_modules\\is-upper-case\\is-upper-case.js",}],
["F:\\metamask-extension\\node_modules\\is-window\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-window%5Cindex.js
      return function (require, module, exports) {
'use strict';

module.exports = function (obj) {

  if (obj == null) {
    return false;
  }

  var o = Object(obj);

  return o === o.window;
};

      };
    };
  }
  }
}, {package:"@lavamoat/snow>is-cross-origin>is-window",file:"node_modules\\is-window\\index.js",}],
["F:\\metamask-extension\\node_modules\\jsan\\index.js", {"./lib":"F:\\metamask-extension\\node_modules\\jsan\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsan%5Cindex.js
      return function (require, module, exports) {
module.exports = require('./lib');

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\index.js",}],
["F:\\metamask-extension\\node_modules\\jsan\\lib\\cycle.js", {"./path-getter":"F:\\metamask-extension\\node_modules\\jsan\\lib\\path-getter.js","./utils":"F:\\metamask-extension\\node_modules\\jsan\\lib\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsan%5Clib%5Ccycle.js
      return function (require, module, exports) {
var pathGetter = require('./path-getter');
var utils = require('./utils');

var WMap = typeof WeakMap !== 'undefined'?
  WeakMap:
  function() {
    var keys = [];
    var values = [];
    return {
      set: function(key, value) {
        keys.push(key);
        values.push(value);
      },
      get: function(key) {
        for (var i = 0; i < keys.length; i++) {
          if (keys[i] === key) {
            return values[i];
          }
        }
      }
    }
  };

// Based on https://github.com/douglascrockford/JSON-js/blob/master/cycle.js

exports.decycle = function decycle(object, options, replacer, map) {
  'use strict';

  map = map || new WMap();

  var noCircularOption = !Object.prototype.hasOwnProperty.call(options, 'circular');
  var withRefs = options.refs !== false;

  return (function derez(_value, path, key) {

    // The derez recurses through the object, producing the deep copy.

    var i,        // The loop counter
      name,       // Property name
      nu;         // The new object or array

    // typeof null === 'object', so go on if this value is really an object but not
    // one of the weird builtin objects.

    var value = typeof replacer === 'function' ? replacer(key || '', _value) : _value;

    if (options.date && value instanceof Date) {
      return {$jsan: 'd' + value.getTime()};
    }
    if (options.regex && value instanceof RegExp) {
      return {$jsan: 'r' + utils.getRegexFlags(value) + ',' + value.source};
    }
    if (options['function'] && typeof value === 'function') {
      return {$jsan: 'f' + utils.stringifyFunction(value, options['function'])}
    }
    if (options['nan'] && typeof value === 'number' && isNaN(value)) {
      return {$jsan: 'n'}
    }
    if (options['infinity']) {
      if (Number.POSITIVE_INFINITY === value) return {$jsan: 'i'}
      if (Number.NEGATIVE_INFINITY === value) return {$jsan: 'y'}
    }
    if (options['undefined'] && value === undefined) {
      return {$jsan: 'u'}
    }
    if (options['error'] && value instanceof Error) {
      return {$jsan: 'e' + value.message}
    }
    if (options['symbol'] && typeof value === 'symbol') {
      var symbolKey = Symbol.keyFor(value)
      if (symbolKey !== undefined) {
        return {$jsan: 'g' + symbolKey}
      }

      // 'Symbol(foo)'.slice(7, -1) === 'foo'
      return {$jsan: 's' + value.toString().slice(7, -1)}
    }

    if (options['map'] && typeof Map === 'function' && value instanceof Map && typeof Array.from === 'function') {
      return {$jsan: 'm' + JSON.stringify(decycle(Array.from(value), options, replacer, map))}
    }

    if (options['set'] && typeof Set === 'function' && value instanceof Set && typeof Array.from === 'function') {
      return {$jsan: 'l' + JSON.stringify(decycle(Array.from(value), options, replacer, map))}
    }

    if (value && typeof value.toJSON === 'function') {
      try {
        value = value.toJSON(key);
      } catch (error) {
        var keyString = (key || '$');
        return "toJSON failed for '" + (map.get(value) || keyString) + "'";
      }
    }

    if (typeof value === 'object' && value !== null &&
      !(value instanceof Boolean) &&
      !(value instanceof Date)    &&
      !(value instanceof Number)  &&
      !(value instanceof RegExp)  &&
      !(value instanceof String)  &&
      !(typeof value === 'symbol')  &&
      !(value instanceof Error)) {

        // If the value is an object or array, look to see if we have already
        // encountered it. If so, return a $ref/path object.

      if (typeof value === 'object') {
        var foundPath = map.get(value);
        if (foundPath) {
          if (noCircularOption && withRefs) {
            return {$jsan: foundPath};
          }
          
          // This is only a true circular reference if the parent path is inside of foundPath
          // drop the last component of the current path and check if it starts with foundPath
          var parentPath = path.split('.').slice(0, -1).join('.');
          if (parentPath.indexOf(foundPath) === 0) {
            if (!noCircularOption) {
              return typeof options.circular === 'function'?
              options.circular(value, path, foundPath):
              options.circular;
            }
            return {$jsan: foundPath};
          }
          if (withRefs) return {$jsan: foundPath};
        }
        map.set(value, path);
      }


      // If it is an array, replicate the array.

      if (Object.prototype.toString.apply(value) === '[object Array]') {
          nu = [];
          for (i = 0; i < value.length; i += 1) {
              nu[i] = derez(value[i], path + '[' + i + ']', i);
          }
      } else {

        // If it is an object, replicate the object.

        nu = {};
        for (name in value) {
          if (Object.prototype.hasOwnProperty.call(value, name)) {
            var nextPath = /^\w+$/.test(name) ?
              '.' + name :
              '[' + JSON.stringify(name) + ']';
            nu[name] = name === '$jsan' ? [derez(value[name], path + nextPath)] : derez(value[name], path + nextPath, name);
          }
        }
      }
      return nu;
    }
    return value;
  }(object, '$'));
};


exports.retrocycle = function retrocycle($) {
  'use strict';


  return (function rez(value) {

    // The rez function walks recursively through the object looking for $jsan
    // properties. When it finds one that has a value that is a path, then it
    // replaces the $jsan object with a reference to the value that is found by
    // the path.

    var i, item, name, path;

    if (value && typeof value === 'object') {
      if (Object.prototype.toString.apply(value) === '[object Array]') {
        for (i = 0; i < value.length; i += 1) {
          item = value[i];
          if (item && typeof item === 'object') {
            if (item.$jsan) {
              value[i] = utils.restore(item.$jsan, $);
            } else {
              rez(item);
            }
          }
        }
      } else {
        for (name in value) {
          // base case passed raw object
          if(typeof value[name] === 'string' && name === '$jsan'){
            return utils.restore(value.$jsan, $);
            break;
          }
          else {
            if (name === '$jsan') {
              value[name] = value[name][0];
            }
            if (typeof value[name] === 'object') {
              item = value[name];
              if (item && typeof item === 'object') {
                if (item.$jsan) {
                  value[name] = utils.restore(item.$jsan, $);
                } else {
                  rez(item);
                }
              }
            }
          }
        }
      }
    }
    return value;
  }($));
};

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\cycle.js",}],
["F:\\metamask-extension\\node_modules\\jsan\\lib\\index.js", {"./cycle":"F:\\metamask-extension\\node_modules\\jsan\\lib\\cycle.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsan%5Clib%5Cindex.js
      return function (require, module, exports) {
var cycle = require('./cycle');

exports.stringify = function stringify(value, replacer, space, _options) {

  if (arguments.length < 4) {
    try {
      if (arguments.length === 1) {
        return JSON.stringify(value);
      } else {
        return JSON.stringify.apply(JSON, arguments);
      }
    } catch (e) {}
  }

  var options = _options || false;
  if (typeof options === 'boolean') {
    options = {
      'date': options,
      'function': options,
      'regex': options,
      'undefined': options,
      'error': options,
      'symbol': options,
      'map': options,
      'set': options,
      'nan': options,
      'infinity': options
    }
  }

  var decycled = cycle.decycle(value, options, replacer);
  if (arguments.length === 1) {
    return JSON.stringify(decycled);
  } else {
    // decycle already handles when replacer is a function.
    return JSON.stringify(decycled, Array.isArray(replacer) ? replacer : null, space);
  }
}

exports.parse = function parse(text, reviver) {
  var needsRetrocycle = /"\$jsan"/.test(text);
  var parsed;
  if (arguments.length === 1) {
    parsed = JSON.parse(text);
  } else {
    parsed = JSON.parse(text, reviver);
  }
  if (needsRetrocycle) {
    parsed = cycle.retrocycle(parsed);
  }
  return parsed;
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\jsan\\lib\\path-getter.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsan%5Clib%5Cpath-getter.js
      return function (require, module, exports) {
module.exports = pathGetter;

function pathGetter(obj, path) {
  if (path !== '$') {
    var paths = getPaths(path);
    for (var i = 0; i < paths.length; i++) {
      path = paths[i].toString().replace(/\\"/g, '"');
      if (typeof obj[path] === 'undefined' && i !== paths.length - 1) continue;
      obj = obj[path];
    }
  }
  return obj;
}

function getPaths(pathString) {
  var regex = /(?:\.(\w+))|(?:\[(\d+)\])|(?:\["((?:[^\\"]|\\.)*)"\])/g;
  var matches = [];
  var match;
  while (match = regex.exec(pathString)) {
    matches.push( match[1] || match[2] || match[3] );
  }
  return matches;
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\path-getter.js",}],
["F:\\metamask-extension\\node_modules\\jsan\\lib\\utils.js", {"./":"F:\\metamask-extension\\node_modules\\jsan\\lib\\index.js","./path-getter":"F:\\metamask-extension\\node_modules\\jsan\\lib\\path-getter.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsan%5Clib%5Cutils.js
      return function (require, module, exports) {
var pathGetter = require('./path-getter');
var jsan = require('./');

exports.getRegexFlags = function getRegexFlags(regex) {
  var flags = '';
  if (regex.ignoreCase) flags += 'i';
  if (regex.global) flags += 'g';
  if (regex.multiline) flags += 'm';
  return flags;
};

exports.stringifyFunction = function stringifyFunction(fn, customToString) {
  if (typeof customToString === 'function') {
    return customToString(fn);
  }
  var str = fn.toString();
  var match = str.match(/^[^{]*{|^[^=]*=>/);
  var start = match ? match[0] : '<function> ';
  var end = str[str.length - 1] === '}' ? '}' : '';
  return start.replace(/\r\n|\n/g, ' ').replace(/\s+/g, ' ') + ' /* ... */ ' + end;
};

exports.restore = function restore(obj, root) {
  var type = obj[0];
  var rest = obj.slice(1);
  switch(type) {
    case '$':
      return pathGetter(root, obj);
    case 'r':
      var comma = rest.indexOf(',');
      var flags = rest.slice(0, comma);
      var source = rest.slice(comma + 1);
      return RegExp(source, flags);
    case 'd':
      return new Date(+rest);
    case 'f':
      var fn = function() { throw new Error("can't run jsan parsed function") };
      fn.toString = function() { return rest; };
      return fn;
    case 'u':
      return undefined;
    case 'e':
      var error = new Error(rest);
      error.stack = 'Stack is unavailable for jsan parsed errors';
      return error;
    case 's':
      return Symbol(rest);
    case 'g':
      return Symbol.for(rest);
    case 'm':
      return new Map(jsan.parse(rest));
    case 'l':
      return new Set(jsan.parse(rest));
    case 'n':
      return NaN;
    case 'i':
      return Infinity;
    case 'y':
      return -Infinity;
    default:
      console.warn('unknown type', obj);
      return obj;
  }
}

      };
    };
  }
  }
}, {package:"remote-redux-devtools>jsan",file:"node_modules\\jsan\\lib\\utils.js",}],
["F:\\metamask-extension\\node_modules\\json-pointer\\index.js", {"foreach":"F:\\metamask-extension\\node_modules\\foreach\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjson-pointer%5Cindex.js
      return function (require, module, exports) {
'use strict';

var each = require('foreach');
module.exports = api;


/**
 * Convenience wrapper around the api.
 * Calls `.get` when called with an `object` and a `pointer`.
 * Calls `.set` when also called with `value`.
 * If only supplied `object`, returns a partially applied function, mapped to the object.
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 * @returns {*}
 */

function api (obj, pointer, value) {
    // .set()
    if (arguments.length === 3) {
        return api.set(obj, pointer, value);
    }
    // .get()
    if (arguments.length === 2) {
        return api.get(obj, pointer);
    }
    // Return a partially applied function on `obj`.
    var wrapped = api.bind(api, obj);

    // Support for oo style
    for (var name in api) {
        if (api.hasOwnProperty(name)) {
            wrapped[name] = api[name].bind(wrapped, obj);
        }
    }
    return wrapped;
}


/**
 * Lookup a json pointer in an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @returns {*}
 */
api.get = function get (obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);

    for (var i = 0; i < refTokens.length; ++i) {
        var tok = refTokens[i];
        if (!(typeof obj == 'object' && tok in obj)) {
            throw new Error('Invalid reference token: ' + tok);
        }
        obj = obj[tok];
    }
    return obj;
};

/**
 * Sets a value on an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 */
api.set = function set (obj, pointer, value) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),
      nextTok = refTokens[0];

    if (refTokens.length === 0) {
      throw Error('Can not set the root object');
    }

    for (var i = 0; i < refTokens.length - 1; ++i) {
        var tok = refTokens[i];
        if (typeof tok !== 'string' && typeof tok !== 'number') {
          tok = String(tok)
        }
        if (tok === "__proto__" || tok === "constructor" || tok === "prototype") {
            continue
        }
        if (tok === '-' && Array.isArray(obj)) {
          tok = obj.length;
        }
        nextTok = refTokens[i + 1];

        if (!(tok in obj)) {
            if (nextTok.match(/^(\d+|-)$/)) {
                obj[tok] = [];
            } else {
                obj[tok] = {};
            }
        }
        obj = obj[tok];
    }
    if (nextTok === '-' && Array.isArray(obj)) {
      nextTok = obj.length;
    }
    obj[nextTok] = value;
    return this;
};

/**
 * Removes an attribute
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 */
api.remove = function (obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
    var finalToken = refTokens[refTokens.length -1];
    if (finalToken === undefined) {
        throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
    }

    var parent = api.get(obj, refTokens.slice(0, -1));
    if (Array.isArray(parent)) {
      var index = +finalToken;
      if (finalToken === '' && isNaN(index)) {
        throw new Error('Invalid array index: "' + finalToken + '"');
      }

      Array.prototype.splice.call(parent, index, 1);
    } else {
      delete parent[finalToken];
    }
};

/**
 * Returns a (pointer -> value) dictionary for an object
 *
 * @param obj
 * @param {function} descend
 * @returns {}
 */
api.dict = function dict (obj, descend) {
    var results = {};
    api.walk(obj, function (value, pointer) {
        results[pointer] = value;
    }, descend);
    return results;
};

/**
 * Iterates over an object
 * Iterator: function (value, pointer) {}
 *
 * @param obj
 * @param {function} iterator
 * @param {function} descend
 */
api.walk = function walk (obj, iterator, descend) {
    var refTokens = [];

    descend = descend || function (value) {
        var type = Object.prototype.toString.call(value);
        return type === '[object Object]' || type === '[object Array]';
    };

    (function next (cur) {
        each(cur, function (value, key) {
            refTokens.push(String(key));
            if (descend(value)) {
                next(value);
            } else {
                iterator(value, api.compile(refTokens));
            }
            refTokens.pop();
        });
    }(obj));
};

/**
 * Tests if an object has a value for a json pointer
 *
 * @param obj
 * @param pointer
 * @returns {boolean}
 */
api.has = function has (obj, pointer) {
    try {
        api.get(obj, pointer);
    } catch (e) {
        return false;
    }
    return true;
};

/**
 * Escapes a reference token
 *
 * @param str
 * @returns {string}
 */
api.escape = function escape (str) {
    return str.toString().replace(/~/g, '~0').replace(/\//g, '~1');
};

/**
 * Unescapes a reference token
 *
 * @param str
 * @returns {string}
 */
api.unescape = function unescape (str) {
    return str.replace(/~1/g, '/').replace(/~0/g, '~');
};

/**
 * Converts a json pointer into a array of reference tokens
 *
 * @param pointer
 * @returns {Array}
 */
api.parse = function parse (pointer) {
    if (pointer === '') { return []; }
    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }
    return pointer.substring(1).split(/\//).map(api.unescape);
};

/**
 * Builds a json pointer from a array of reference tokens
 *
 * @param refTokens
 * @returns {string}
 */
api.compile = function compile (refTokens) {
    if (refTokens.length === 0) { return ''; }
    return '/' + refTokens.map(api.escape).join('/');
};

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>json-pointer",file:"node_modules\\json-pointer\\index.js",}],
["F:\\metamask-extension\\node_modules\\jss-plugin-camel-case\\dist\\jss-plugin-camel-case.cjs.js", {"hyphenate-style-name":"F:\\metamask-extension\\node_modules\\hyphenate-style-name\\index.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss-plugin-camel-case%5Cdist%5Cjss-plugin-camel-case.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var hyphenate = _interopDefault(require('hyphenate-style-name'));

/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : hyphenate(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = hyphenate(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = camelCase;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-camel-case",file:"node_modules\\jss-plugin-camel-case\\dist\\jss-plugin-camel-case.cjs.js",}],
["F:\\metamask-extension\\node_modules\\jss-plugin-default-unit\\dist\\jss-plugin-default-unit.cjs.js", {"jss":"F:\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss-plugin-default-unit%5Cdist%5Cjss-plugin-default-unit.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jss = require('jss');

var px = jss.hasCSSTOMSupport && CSS ? CSS.px : 'px';
var ms = jss.hasCSSTOMSupport && CSS ? CSS.ms : 'ms';
var percent = jss.hasCSSTOMSupport && CSS ? CSS.percent : '%';
/**
 * Generated jss-plugin-default-unit CSS property units
 *
 * @type object
 */

var defaultUnits = {
  // Animation properties
  'animation-delay': ms,
  'animation-duration': ms,
  // Background properties
  'background-position': px,
  'background-position-x': px,
  'background-position-y': px,
  'background-size': px,
  // Border Properties
  border: px,
  'border-bottom': px,
  'border-bottom-left-radius': px,
  'border-bottom-right-radius': px,
  'border-bottom-width': px,
  'border-left': px,
  'border-left-width': px,
  'border-radius': px,
  'border-right': px,
  'border-right-width': px,
  'border-top': px,
  'border-top-left-radius': px,
  'border-top-right-radius': px,
  'border-top-width': px,
  'border-width': px,
  // Margin properties
  margin: px,
  'margin-bottom': px,
  'margin-left': px,
  'margin-right': px,
  'margin-top': px,
  // Padding properties
  padding: px,
  'padding-bottom': px,
  'padding-left': px,
  'padding-right': px,
  'padding-top': px,
  // Mask properties
  'mask-position-x': px,
  'mask-position-y': px,
  'mask-size': px,
  // Width and height properties
  height: px,
  width: px,
  'min-height': px,
  'max-height': px,
  'min-width': px,
  'max-width': px,
  // Position properties
  bottom: px,
  left: px,
  top: px,
  right: px,
  // Shadow properties
  'box-shadow': px,
  'text-shadow': px,
  // Column properties
  'column-gap': px,
  'column-rule': px,
  'column-rule-width': px,
  'column-width': px,
  // Font and text properties
  'font-size': px,
  'font-size-delta': px,
  'letter-spacing': px,
  'text-indent': px,
  'text-stroke': px,
  'text-stroke-width': px,
  'word-spacing': px,
  // Motion properties
  motion: px,
  'motion-offset': px,
  // Outline properties
  outline: px,
  'outline-offset': px,
  'outline-width': px,
  // Perspective properties
  perspective: px,
  'perspective-origin-x': percent,
  'perspective-origin-y': percent,
  // Transform properties
  'transform-origin': percent,
  'transform-origin-x': percent,
  'transform-origin-y': percent,
  'transform-origin-z': percent,
  // Transition properties
  'transition-delay': ms,
  'transition-duration': ms,
  // Alignment properties
  'vertical-align': px,
  'flex-basis': px,
  // Some random properties
  'shape-margin': px,
  size: px,
  // Grid properties
  grid: px,
  'grid-gap': px,
  'grid-row-gap': px,
  'grid-column-gap': px,
  'grid-template-rows': px,
  'grid-template-columns': px,
  'grid-auto-rows': px,
  'grid-auto-columns': px,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  'box-shadow-x': px,
  'box-shadow-y': px,
  'box-shadow-blur': px,
  'box-shadow-spread': px,
  'font-line-height': px,
  'text-shadow-x': px,
  'text-shadow-y': px,
  'text-shadow-blur': px
};

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;

  var replace = function replace(str) {
    return str[1].toUpperCase();
  };

  var newObj = {};

  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp, replace)] = obj[_key];
  }

  return newObj;
}

var units = addCamelCasedVersion(defaultUnits);
/**
 * Recursive deep style passing function
 */

function iterate(prop, value, options) {
  if (!value) return value;

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = iterate(prop, value[i], options);
    }
  } else if (typeof value === 'object') {
    if (prop === 'fallbacks') {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
      }
    }
  } else if (typeof value === 'number') {
    var unit = options[prop] || units[prop];

    if (unit) {
      return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
    }

    return value.toString();
  }

  return value;
}
/**
 * Add unit to numeric values.
 */


function defaultUnit(options) {
  if (options === void 0) {
    options = {};
  }

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = defaultUnit;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-default-unit",file:"node_modules\\jss-plugin-default-unit\\dist\\jss-plugin-default-unit.cjs.js",}],
["F:\\metamask-extension\\node_modules\\jss-plugin-global\\dist\\jss-plugin-global.cjs.js", {"@babel/runtime/helpers/extends":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\extends.js","jss":"F:\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss-plugin-global%5Cdist%5Cjss-plugin-global.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var jss = require('jss');

var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss.RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString() {
    return this.rules.toString();
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    options.sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    options.sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule) {
    if (rule.type !== 'style') return;
    handleNestedGlobalContainerRule(rule);
    handlePrefixedGlobalRule(rule);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

exports.default = jssGlobal;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-global",file:"node_modules\\jss-plugin-global\\dist\\jss-plugin-global.cjs.js",}],
["F:\\metamask-extension\\node_modules\\jss-plugin-nested\\dist\\jss-plugin-nested.cjs.js", {"@babel/runtime/helpers/extends":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\extends.js","tiny-warning":"F:\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss-plugin-nested%5Cdist%5Cjss-plugin-nested.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var warning = _interopDefault(require('tiny-warning'));

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        rule = rule;
        return rule.selector;
      }

      "development" !== "production" ? warning(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") : void 0;
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return _extends({}, prevOptions, {
      index: prevOptions.index + 1
    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        container.addRule(selector, style[prop], _extends({}, options, {
          selector: selector
        }));
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options) // Flow expects more options but they aren't required
        // And flow doesn't know this will always be a StyleRule which has the addRule method
        // $FlowFixMe
        .addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

exports.default = jssNested;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-nested",file:"node_modules\\jss-plugin-nested\\dist\\jss-plugin-nested.cjs.js",}],
["F:\\metamask-extension\\node_modules\\jss-plugin-props-sort\\dist\\jss-plugin-props-sort.cjs.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss-plugin-props-sort%5Cdist%5Cjss-plugin-props-sort.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Sort props by length.
 */
function jssPropsSort() {
  var sort = function sort(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }

    return prop0.length - prop1.length;
  };

  return {
    onProcessStyle: function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);

      for (var i = 0; i < props.length; i++) {
        newStyle[props[i]] = style[props[i]];
      }

      return newStyle;
    }
  };
}

exports.default = jssPropsSort;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-props-sort",file:"node_modules\\jss-plugin-props-sort\\dist\\jss-plugin-props-sort.cjs.js",}],
["F:\\metamask-extension\\node_modules\\jss-plugin-rule-value-function\\dist\\jss-plugin-rule-value-function.cjs.js", {"jss":"F:\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js","tiny-warning":"F:\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss-plugin-rule-value-function%5Cdist%5Cjss-plugin-rule-value-function.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var warning = _interopDefault(require('tiny-warning'));
var jss = require('jss');

var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;
function functionPlugin() {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (typeof decl !== 'function') return null;
      var rule = jss.createRule(name, {}, options);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle(style, rule) {
      // We need to extract function values from the declaration, so that we can keep core unaware of them.
      // We need to do that only once.
      // We don't need to extract functions on each style update, since this can happen only once.
      // We don't support function values inside of function rules.
      if (fnValuesNs in rule || fnRuleNs in rule) return style;
      var fnValues = {};

      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== 'function') continue;
        delete style[prop];
        fnValues[prop] = value;
      } // $FlowFixMe


      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data, rule, sheet, options) {
      var styleRule = rule;
      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
      // will be returned from that function.

      if (fnRule) {
        // Empty object will remove all currently defined props
        // in case function rule returns a falsy value.
        styleRule.style = fnRule(data) || {};

        if ("development" === 'development') {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === 'function') {
              "development" !== "production" ? warning(false, '[JSS] Function values inside function rules are not supported.') : void 0;
              break;
            }
          }
        }
      }

      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data), options);
        }
      }
    }
  };
}

exports.default = functionPlugin;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-rule-value-function",file:"node_modules\\jss-plugin-rule-value-function\\dist\\jss-plugin-rule-value-function.cjs.js",}],
["F:\\metamask-extension\\node_modules\\jss-plugin-vendor-prefixer\\dist\\jss-plugin-vendor-prefixer.cjs.js", {"css-vendor":"F:\\metamask-extension\\node_modules\\css-vendor\\dist\\css-vendor.cjs.js","jss":"F:\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss-plugin-vendor-prefixer%5Cdist%5Cjss-plugin-vendor-prefixer.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vendor = require('css-vendor');
var jss = require('jss');

/**
 * Add vendor prefix to a property name when needed.
 *
 * @api public
 */

function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      var atRule = rule;
      atRule.at = vendor.supportedKeyframes(atRule.at);
    }
  }

  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];

      if (prop === 'fallbacks' && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }

      var changeProp = false;
      var supportedProp = vendor.supportedProperty(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;
      var changeValue = false;
      var supportedValue = vendor.supportedValue(supportedProp, jss.toCssValue(value));
      if (supportedValue && supportedValue !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue || value;
      }
    }

    return style;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    return prefixStyle(style);
  }

  function onChangeValue(value, prop) {
    return vendor.supportedValue(prop, jss.toCssValue(value)) || value;
  }

  return {
    onProcessRule: onProcessRule,
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = jssVendorPrefixer;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-vendor-prefixer",file:"node_modules\\jss-plugin-vendor-prefixer\\dist\\jss-plugin-vendor-prefixer.cjs.js",}],
["F:\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js", {"@babel/runtime/helpers/assertThisInitialized":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\assertThisInitialized.js","@babel/runtime/helpers/createClass":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/extends":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\extends.js","@babel/runtime/helpers/inheritsLoose":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","@babel/runtime/helpers/objectWithoutPropertiesLoose":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\objectWithoutPropertiesLoose.js","is-in-browser":"F:\\metamask-extension\\node_modules\\is-in-browser\\dist\\index.js","tiny-warning":"F:\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjss%5Cdist%5Cjss.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var isInBrowser = _interopDefault(require('is-in-browser'));
var warning = _interopDefault(require('tiny-warning'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));

var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
    "development" !== "production" ? warning(false, "[JSS] Unknown rule " + name) : void 0;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


function toCssValue(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }

  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;
  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += '\n';
            result += "" + indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += '\n';
          result += "" + indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += '\n';
      result += "" + indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
      "development" !== "production" ? warning(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : void 0;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  _createClass(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name, style, options) {
    if (name[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(name, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.at = void 0;
    this.key = void 0;
    this.query = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown';
    this.options = options;
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {\n" + children + "\n}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
      "development" !== "production" ? warning(false, "[JSS] Bad keyframes name " + key) : void 0;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

      "development" !== "production" ? warning(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") : void 0;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var plugin = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += '\n';
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = _extends({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Get a rule.
   */
  ;

  _proto.get = function get(name) {
    return this.map[name];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe

      data = arguments.length <= 1 ? undefined : arguments[1]; // $FlowFixMe

      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe

      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.map[name], data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var styleRule = rule;
    var style = styleRule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== styleRule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(styleRule.style, styleRule, sheet); // Update and add props.

      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += '\n';
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name.
   */
  ;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);
    if (!rule) return false;
    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      // $FlowFixMe
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
          "development" !== "production" ? warning(false, "[JSS] Unknown hook \"" + name + "\".") : void 0;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += '\n';
      css += sheet.toString(options);
    }

    return css;
  };

  _createClass(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var globalThis = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis[ns] == null) globalThis[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis[ns]++;

var maxRules = 1e10;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */
var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;
  return function (rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
      "development" !== "production" ? warning(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : void 0;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };
};

/**
 * Cache the value from the first time a function is called.
 */
var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
}
/**
 * Set a style property.
 */


function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
}
/**
 * Remove a style property.
 */


function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
    "development" !== "production" ? warning(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") : void 0;
  }
}
/**
 * Set the selector.
 */


function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
}
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


    "development" !== "production" ? warning(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") : void 0;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else "development" !== "production" ? warning(false, '[JSS] Insertion point is not in the DOM.') : void 0;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    index = maxIndex;
  }

  try {
    if ('insertRule' in container) {
      var c = container;
      c.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        var _c = container;

        _c.appendRule(rule);
      }
  } catch (err) {
    "development" !== "production" ? warning(false, "[JSS] " + err.message) : void 0;
    return false;
  }

  return container.cssRules[index];
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element);
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        // We need to render the container without children first.
        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), index);

        if (latestNativeParent === false) {
          return false;
        }
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    } // IE keeps the CSSStyleSheet after style node has been reattached,
    // so we need to check if the `renderable` reference the right style sheet and not
    // rerender those rules.


    if (rule.renderable && rule.renderable.parentStyleSheet === this.element.sheet) {
      return rule.renderable;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;

    var nativeRule = _insertRule(nativeParent, ruleStr, index);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    rule.renderable = nativeRule;
    return nativeRule;
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    var cssRules = this.element.sheet.cssRules;

    for (var index = 0; index < cssRules.length; index++) {
      if (cssRule === cssRules[index]) return index;
    }

    return -1;
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   *
   * Only used for some old browsers because they can't set a selector.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.3.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: isInBrowser ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = _extends({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, _extends({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = _extends({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    warning(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      warning(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  _createClass(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */

/**
 * Export a constant indicating if this browser has CSSTOM support.
 * https://developers.google.com/web/updates/2018/03/cssom
 */
var hasCSSTOMSupport = typeof CSS !== 'undefined' && CSS && 'number' in CSS;
/**
 * Creates a new instance of Jss.
 */

var create = function create(options) {
  return new Jss(options);
};
/**
 * A global Jss instance.
 */

var index = create();

exports.RuleList = RuleList;
exports.SheetsManager = SheetsManager;
exports.SheetsRegistry = SheetsRegistry;
exports.create = create;
exports.createGenerateId = createGenerateId;
exports.createRule = createRule;
exports.default = index;
exports.getDynamicStyles = getDynamicStyles;
exports.hasCSSTOMSupport = hasCSSTOMSupport;
exports.sheets = sheets;
exports.toCssValue = toCssValue;

      };
    };
  }
  }
}, {package:"@material-ui/core>@material-ui/styles>jss",file:"node_modules\\jss\\dist\\jss.cjs.js",}],
["F:\\metamask-extension\\node_modules\\linked-list\\_source\\linked-list.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clinked-list%5C_source%5Clinked-list.js
      return function (require, module, exports) {
'use strict';

/**
 * Constants.
 */

var errorMessage;

errorMessage = 'An argument without append, prepend, ' +
    'or detach methods was given to `List';

/**
 * Creates a new List: A linked list is a bit like an Array, but
 * knows nothing about how many items are in it, and knows only about its
 * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,
 * &c.) knows which item comes before or after it (its more like the
 * implementation of the DOM in JavaScript).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of List.
 */

function List(/*items...*/) {
    if (arguments.length) {
        return List.from(arguments);
    }
}

var ListPrototype;

ListPrototype = List.prototype;

/**
 * Creates a new list from the arguments (each a list item) passed in.
 * @name List.of
 * @param {...ListItem} [items] - Zero or more items to attach.
 * @returns {list} - A new instance of List.
 */

List.of = function (/*items...*/) {
    return List.from.call(this, arguments);
};

/**
 * Creates a new list from the given array-like object (each a list item)
 * passed in.
 * @name List.from
 * @param {ListItem[]} [items] - The items to append.
 * @returns {list} - A new instance of List.
 */
List.from = function (items) {
    var list = new this(), length, iterator, item;

    if (items && (length = items.length)) {
        iterator = -1;

        while (++iterator < length) {
            item = items[iterator];

            if (item !== null && item !== undefined) {
                list.append(item);
            }
        }
    }

    return list;
};

/**
 * List#head
 * Default to `null`.
 */
ListPrototype.head = null;

/**
 * List#tail
 * Default to `null`.
 */
ListPrototype.tail = null;

/**
 * Returns the list's items as an array. This does *not* detach the items.
 * @name List#toArray
 * @returns {ListItem[]} - An array of (still attached) ListItems.
 */
ListPrototype.toArray = function () {
    var item = this.head,
        result = [];

    while (item) {
        result.push(item);
        item = item.next;
    }

    return result;
};

/**
 * Prepends the given item to the list: Item will be the new first item
 * (`head`).
 * @name List#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */
ListPrototype.prepend = function (item) {
    if (!item) {
        return false;
    }

    if (!item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + '#prepend`.');
    }

    var self, head;

    // Cache self.
    self = this;

    // If self has a first item, defer prepend to the first items prepend
    // method, and return the result.
    head = self.head;

    if (head) {
        return head.prepend(item);
    }

    // ...otherwise, there is no `head` (or `tail`) item yet.

    // Detach the prependee.
    item.detach();

    // Set the prependees parent list to reference self.
    item.list = self;

    // Set self's first item to the prependee, and return the item.
    self.head = item;

    return item;
};

/**
 * Appends the given item to the list: Item will be the new last item (`tail`)
 * if the list had a first item, and its first item (`head`) otherwise.
 * @name List#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */

ListPrototype.append = function (item) {
    if (!item) {
        return false;
    }

    if (!item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + '#append`.');
    }

    var self, head, tail;

    // Cache self.
    self = this;

    // If self has a last item, defer appending to the last items append
    // method, and return the result.
    tail = self.tail;

    if (tail) {
        return tail.append(item);
    }

    // If self has a first item, defer appending to the first items append
    // method, and return the result.
    head = self.head;

    if (head) {
        return head.append(item);
    }

    // ...otherwise, there is no `tail` or `head` item yet.

    // Detach the appendee.
    item.detach();

    // Set the appendees parent list to reference self.
    item.list = self;

    // Set self's first item to the appendee, and return the item.
    self.head = item;

    return item;
};

/**
 * Creates a new ListItem: A linked list item is a bit like DOM node:
 * It knows only about its "parent" (`list`), the item before it (`prev`),
 * and the item after it (`next`).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of ListItem.
 */

function ListItem() {}

List.Item = ListItem;

var ListItemPrototype = ListItem.prototype;

ListItemPrototype.next = null;

ListItemPrototype.prev = null;

ListItemPrototype.list = null;

/**
 * Detaches the item operated on from its parent list.
 * @name ListItem#detach
 * @returns {ListItem} - The item operated on.
 */
ListItemPrototype.detach = function () {
    // Cache self, the parent list, and the previous and next items.
    var self = this,
        list = self.list,
        prev = self.prev,
        next = self.next;

    // If the item is already detached, return self.
    if (!list) {
        return self;
    }

    // If self is the last item in the parent list, link the lists last item
    // to the previous item.
    if (list.tail === self) {
        list.tail = prev;
    }

    // If self is the first item in the parent list, link the lists first item
    // to the next item.
    if (list.head === self) {
        list.head = next;
    }

    // If both the last and first items in the parent list are the same,
    // remove the link to the last item.
    if (list.tail === list.head) {
        list.tail = null;
    }

    // If a previous item exists, link its next item to selfs next item.
    if (prev) {
        prev.next = next;
    }

    // If a next item exists, link its previous item to selfs previous item.
    if (next) {
        next.prev = prev;
    }

    // Remove links from self to both the next and previous items, and to the
    // parent list.
    self.prev = self.next = self.list = null;

    // Return self.
    return self;
};

/**
 * Prepends the given item *before* the item operated on.
 * @name ListItem#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */
ListItemPrototype.prepend = function (item) {
    if (!item || !item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + 'Item#prepend`.');
    }

    // Cache self, the parent list, and the previous item.
    var self = this,
        list = self.list,
        prev = self.prev;

    // If self is detached, return false.
    if (!list) {
        return false;
    }

    // Detach the prependee.
    item.detach();

    // If self has a previous item...
    if (prev) {
        // ...link the prependees previous item, to selfs previous item.
        item.prev = prev;

        // ...link the previous items next item, to self.
        prev.next = item;
    }

    // Set the prependees next item to self.
    item.next = self;

    // Set the prependees parent list to selfs parent list.
    item.list = list;

    // Set the previous item of self to the prependee.
    self.prev = item;

    // If self is the first item in the parent list, link the lists first item
    // to the prependee.
    if (self === list.head) {
        list.head = item;
    }

    // If the the parent list has no last item, link the lists last item to
    // self.
    if (!list.tail) {
        list.tail = self;
    }

    // Return the prependee.
    return item;
};

/**
 * Appends the given item *after* the item operated on.
 * @name ListItem#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */
ListItemPrototype.append = function (item) {
    // If item is falsey, return false.
    if (!item || !item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + 'Item#append`.');
    }

    // Cache self, the parent list, and the next item.
    var self = this,
        list = self.list,
        next = self.next;

    // If self is detached, return false.
    if (!list) {
        return false;
    }

    // Detach the appendee.
    item.detach();

    // If self has a next item...
    if (next) {
        // ...link the appendees next item, to selfs next item.
        item.next = next;

        // ...link the next items previous item, to the appendee.
        next.prev = item;
    }

    // Set the appendees previous item to self.
    item.prev = self;

    // Set the appendees parent list to selfs parent list.
    item.list = list;

    // Set the next item of self to the appendee.
    self.next = item;

    // If the the parent list has no last item or if self is the parent lists
    // last item, link the lists last item to the appendee.
    if (self === list.tail || !list.tail) {
        list.tail = item;
    }

    // Return the appendee.
    return item;
};

/**
 * Expose `List`.
 */

module.exports = List;

      };
    };
  }
  }
}, {package:"remote-redux-devtools>socketcluster-client>linked-list",file:"node_modules\\linked-list\\_source\\linked-list.js",}],
["F:\\metamask-extension\\node_modules\\linked-list\\index.js", {"./_source/linked-list.js":"F:\\metamask-extension\\node_modules\\linked-list\\_source\\linked-list.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clinked-list%5Cindex.js
      return function (require, module, exports) {
'use strict';

module.exports = require('./_source/linked-list.js');

      };
    };
  }
  }
}, {package:"remote-redux-devtools>socketcluster-client>linked-list",file:"node_modules\\linked-list\\index.js",}],
["F:\\metamask-extension\\node_modules\\locale-currency\\index.js", {"./map":"F:\\metamask-extension\\node_modules\\locale-currency\\map.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clocale-currency%5Cindex.js
      return function (require, module, exports) {
var map = require("./map");

var getCountryCode = function(localeString) {
    var components = localeString.split("_");
    if (components.length == 2) {
        return components.pop();
    }
    components = localeString.split("-");
    if (components.length == 2) {
        return components.pop();
    }
    return localeString;
}

exports.getCurrency = function(locale) {
    var countryCode = getCountryCode(locale).toUpperCase();
    if (countryCode in map) {
        return map[countryCode];
    }
    return null;
}

exports.getLocales = function(currencyCode) {
    currencyCode = currencyCode.toUpperCase();
    var locales = [];
    for (countryCode in map) {
        if (map[countryCode] === currencyCode) {
            locales.push(countryCode);
        }
    }
    return locales;
}
      };
    };
  }
  }
}, {package:"currency-formatter>locale-currency",file:"node_modules\\locale-currency\\index.js",}],
["F:\\metamask-extension\\node_modules\\locale-currency\\map.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clocale-currency%5Cmap.js
      return function (require, module, exports) {
// Generated using ShowCurrencies.java
var map = {
AD: 'EUR',
AE: 'AED',
AF: 'AFN',
AG: 'XCD',
AI: 'XCD',
AL: 'ALL',
AM: 'AMD',
AN: 'ANG',
AO: 'AOA',
AR: 'ARS',
AS: 'USD',
AT: 'EUR',
AU: 'AUD',
AW: 'AWG',
AX: 'EUR',
AZ: 'AZN',
BA: 'BAM',
BB: 'BBD',
BD: 'BDT',
BE: 'EUR',
BF: 'XOF',
BG: 'BGN',
BH: 'BHD',
BI: 'BIF',
BJ: 'XOF',
BL: 'EUR',
BM: 'BMD',
BN: 'BND',
BO: 'BOB',
BQ: 'USD',
BR: 'BRL',
BS: 'BSD',
BT: 'BTN',
BV: 'NOK',
BW: 'BWP',
BY: 'BYR',
BZ: 'BZD',
CA: 'CAD',
CC: 'AUD',
CD: 'CDF',
CF: 'XAF',
CG: 'XAF',
CH: 'CHF',
CI: 'XOF',
CK: 'NZD',
CL: 'CLP',
CM: 'XAF',
CN: 'CNY',
CO: 'COP',
CR: 'CRC',
CU: 'CUP',
CV: 'CVE',
CW: 'ANG',
CX: 'AUD',
CY: 'EUR',
CZ: 'CZK',
DE: 'EUR',
DJ: 'DJF',
DK: 'DKK',
DM: 'XCD',
DO: 'DOP',
DZ: 'DZD',
EC: 'USD',
EE: 'EUR',
EG: 'EGP',
EH: 'MAD',
ER: 'ERN',
ES: 'EUR',
ET: 'ETB',
FI: 'EUR',
FJ: 'FJD',
FK: 'FKP',
FM: 'USD',
FO: 'DKK',
FR: 'EUR',
GA: 'XAF',
GB: 'GBP',
GD: 'XCD',
GE: 'GEL',
GF: 'EUR',
GG: 'GBP',
GH: 'GHS',
GI: 'GIP',
GL: 'DKK',
GM: 'GMD',
GN: 'GNF',
GP: 'EUR',
GQ: 'XAF',
GR: 'EUR',
GS: 'GBP',
GT: 'GTQ',
GU: 'USD',
GW: 'XOF',
GY: 'GYD',
HK: 'HKD',
HM: 'AUD',
HN: 'HNL',
HR: 'HRK',
HT: 'HTG',
HU: 'HUF',
ID: 'IDR',
IE: 'EUR',
IL: 'ILS',
IM: 'GBP',
IN: 'INR',
IO: 'USD',
IQ: 'IQD',
IR: 'IRR',
IS: 'ISK',
IT: 'EUR',
JE: 'GBP',
JM: 'JMD',
JO: 'JOD',
JP: 'JPY',
KE: 'KES',
KG: 'KGS',
KH: 'KHR',
KI: 'AUD',
KM: 'KMF',
KN: 'XCD',
KP: 'KPW',
KR: 'KRW',
KW: 'KWD',
KY: 'KYD',
KZ: 'KZT',
LA: 'LAK',
LB: 'LBP',
LC: 'XCD',
LI: 'CHF',
LK: 'LKR',
LR: 'LRD',
LS: 'LSL',
LT: 'LTL',
LU: 'EUR',
LV: 'LVL',
LY: 'LYD',
MA: 'MAD',
MC: 'EUR',
MD: 'MDL',
ME: 'EUR',
MF: 'EUR',
MG: 'MGA',
MH: 'USD',
MK: 'MKD',
ML: 'XOF',
MM: 'MMK',
MN: 'MNT',
MO: 'MOP',
MP: 'USD',
MQ: 'EUR',
MR: 'MRO',
MS: 'XCD',
MT: 'EUR',
MU: 'MUR',
MV: 'MVR',
MW: 'MWK',
MX: 'MXN',
MY: 'MYR',
MZ: 'MZN',
NA: 'NAD',
NC: 'XPF',
NE: 'XOF',
NF: 'AUD',
NG: 'NGN',
NI: 'NIO',
NL: 'EUR',
NO: 'NOK',
NP: 'NPR',
NR: 'AUD',
NU: 'NZD',
NZ: 'NZD',
OM: 'OMR',
PA: 'PAB',
PE: 'PEN',
PF: 'XPF',
PG: 'PGK',
PH: 'PHP',
PK: 'PKR',
PL: 'PLN',
PM: 'EUR',
PN: 'NZD',
PR: 'USD',
PS: 'ILS',
PT: 'EUR',
PW: 'USD',
PY: 'PYG',
QA: 'QAR',
RE: 'EUR',
RO: 'RON',
RS: 'RSD',
RU: 'RUB',
RW: 'RWF',
SA: 'SAR',
SB: 'SBD',
SC: 'SCR',
SD: 'SDG',
SE: 'SEK',
SG: 'SGD',
SH: 'SHP',
SI: 'EUR',
SJ: 'NOK',
SK: 'EUR',
SL: 'SLL',
SM: 'EUR',
SN: 'XOF',
SO: 'SOS',
SR: 'SRD',
ST: 'STD',
SV: 'SVC',
SX: 'ANG',
SY: 'SYP',
SZ: 'SZL',
TC: 'USD',
TD: 'XAF',
TF: 'EUR',
TG: 'XOF',
TH: 'THB',
TJ: 'TJS',
TK: 'NZD',
TL: 'USD',
TM: 'TMT',
TN: 'TND',
TO: 'TOP',
TR: 'TRY',
TT: 'TTD',
TV: 'AUD',
TW: 'TWD',
TZ: 'TZS',
UA: 'UAH',
UG: 'UGX',
UM: 'USD',
US: 'USD',
UY: 'UYU',
UZ: 'UZS',
VA: 'EUR',
VC: 'XCD',
VE: 'VEF',
VG: 'USD',
VI: 'USD',
VN: 'VND',
VU: 'VUV',
WF: 'XPF',
WS: 'WST',
YE: 'YER',
YT: 'EUR',
ZA: 'ZAR',
ZM: 'ZMK',
ZW: 'ZWL'
};

module.exports = map;
      };
    };
  }
  }
}, {package:"currency-formatter>locale-currency",file:"node_modules\\locale-currency\\map.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_apply.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_apply.js
      return function (require, module, exports) {
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_apply.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_arrayAggregator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_arrayAggregator.js
      return function (require, module, exports) {
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

module.exports = arrayAggregator;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_arrayAggregator.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_arrayIncludes.js", {"./_baseIndexOf":"F:\\metamask-extension\\node_modules\\lodash\\_baseIndexOf.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_arrayIncludes.js
      return function (require, module, exports) {
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_arrayIncludes.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_arrayIncludesWith.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_arrayIncludesWith.js
      return function (require, module, exports) {
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_arrayIncludesWith.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseAggregator.js", {"./_baseEach":"F:\\metamask-extension\\node_modules\\lodash\\_baseEach.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseAggregator.js
      return function (require, module, exports) {
var baseEach = require('./_baseEach');

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

module.exports = baseAggregator;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseAggregator.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseDifference.js", {"./_SetCache":"F:\\metamask-extension\\node_modules\\lodash\\_SetCache.js","./_arrayIncludes":"F:\\metamask-extension\\node_modules\\lodash\\_arrayIncludes.js","./_arrayIncludesWith":"F:\\metamask-extension\\node_modules\\lodash\\_arrayIncludesWith.js","./_arrayMap":"F:\\metamask-extension\\node_modules\\lodash\\_arrayMap.js","./_baseUnary":"F:\\metamask-extension\\node_modules\\lodash\\_baseUnary.js","./_cacheHas":"F:\\metamask-extension\\node_modules\\lodash\\_cacheHas.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseDifference.js
      return function (require, module, exports) {
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseDifference.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseEach.js", {"./_baseForOwn":"F:\\metamask-extension\\node_modules\\lodash\\_baseForOwn.js","./_createBaseEach":"F:\\metamask-extension\\node_modules\\lodash\\_createBaseEach.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseEach.js
      return function (require, module, exports) {
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseEach.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseFindIndex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseFindIndex.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseFindIndex.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseFlatten.js", {"./_arrayPush":"F:\\metamask-extension\\node_modules\\lodash\\_arrayPush.js","./_isFlattenable":"F:\\metamask-extension\\node_modules\\lodash\\_isFlattenable.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseFlatten.js
      return function (require, module, exports) {
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseFlatten.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseIndexOf.js", {"./_baseFindIndex":"F:\\metamask-extension\\node_modules\\lodash\\_baseFindIndex.js","./_baseIsNaN":"F:\\metamask-extension\\node_modules\\lodash\\_baseIsNaN.js","./_strictIndexOf":"F:\\metamask-extension\\node_modules\\lodash\\_strictIndexOf.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseIndexOf.js
      return function (require, module, exports) {
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseIndexOf.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseIsNaN.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseIsNaN.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseIsNaN.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseRest.js", {"./_overRest":"F:\\metamask-extension\\node_modules\\lodash\\_overRest.js","./_setToString":"F:\\metamask-extension\\node_modules\\lodash\\_setToString.js","./identity":"F:\\metamask-extension\\node_modules\\lodash\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseRest.js
      return function (require, module, exports) {
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseRest.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseSetToString.js", {"./_defineProperty":"F:\\metamask-extension\\node_modules\\lodash\\_defineProperty.js","./constant":"F:\\metamask-extension\\node_modules\\lodash\\constant.js","./identity":"F:\\metamask-extension\\node_modules\\lodash\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseSetToString.js
      return function (require, module, exports) {
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseSetToString.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseSum.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseSum.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

module.exports = baseSum;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseSum.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseUniq.js", {"./_SetCache":"F:\\metamask-extension\\node_modules\\lodash\\_SetCache.js","./_arrayIncludes":"F:\\metamask-extension\\node_modules\\lodash\\_arrayIncludes.js","./_arrayIncludesWith":"F:\\metamask-extension\\node_modules\\lodash\\_arrayIncludesWith.js","./_cacheHas":"F:\\metamask-extension\\node_modules\\lodash\\_cacheHas.js","./_createSet":"F:\\metamask-extension\\node_modules\\lodash\\_createSet.js","./_setToArray":"F:\\metamask-extension\\node_modules\\lodash\\_setToArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseUniq.js
      return function (require, module, exports) {
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseUniq.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_createAggregator.js", {"./_arrayAggregator":"F:\\metamask-extension\\node_modules\\lodash\\_arrayAggregator.js","./_baseAggregator":"F:\\metamask-extension\\node_modules\\lodash\\_baseAggregator.js","./_baseIteratee":"F:\\metamask-extension\\node_modules\\lodash\\_baseIteratee.js","./isArray":"F:\\metamask-extension\\node_modules\\lodash\\isArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_createAggregator.js
      return function (require, module, exports) {
var arrayAggregator = require('./_arrayAggregator'),
    baseAggregator = require('./_baseAggregator'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray');

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

module.exports = createAggregator;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_createAggregator.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_createBaseEach.js", {"./isArrayLike":"F:\\metamask-extension\\node_modules\\lodash\\isArrayLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_createBaseEach.js
      return function (require, module, exports) {
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_createBaseEach.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_createSet.js", {"./_Set":"F:\\metamask-extension\\node_modules\\lodash\\_Set.js","./_setToArray":"F:\\metamask-extension\\node_modules\\lodash\\_setToArray.js","./noop":"F:\\metamask-extension\\node_modules\\lodash\\noop.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_createSet.js
      return function (require, module, exports) {
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_createSet.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_isFlattenable.js", {"./_Symbol":"F:\\metamask-extension\\node_modules\\lodash\\_Symbol.js","./isArguments":"F:\\metamask-extension\\node_modules\\lodash\\isArguments.js","./isArray":"F:\\metamask-extension\\node_modules\\lodash\\isArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_isFlattenable.js
      return function (require, module, exports) {
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_isFlattenable.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_overRest.js", {"./_apply":"F:\\metamask-extension\\node_modules\\lodash\\_apply.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_overRest.js
      return function (require, module, exports) {
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_overRest.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_setToString.js", {"./_baseSetToString":"F:\\metamask-extension\\node_modules\\lodash\\_baseSetToString.js","./_shortOut":"F:\\metamask-extension\\node_modules\\lodash\\_shortOut.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_setToString.js
      return function (require, module, exports) {
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_setToString.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_shortOut.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_shortOut.js
      return function (require, module, exports) {
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_shortOut.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_strictIndexOf.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_strictIndexOf.js
      return function (require, module, exports) {
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_strictIndexOf.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\constant.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5Cconstant.js
      return function (require, module, exports) {
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\constant.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\difference.js", {"./_baseDifference":"F:\\metamask-extension\\node_modules\\lodash\\_baseDifference.js","./_baseFlatten":"F:\\metamask-extension\\node_modules\\lodash\\_baseFlatten.js","./_baseRest":"F:\\metamask-extension\\node_modules\\lodash\\_baseRest.js","./isArrayLikeObject":"F:\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5Cdifference.js
      return function (require, module, exports) {
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\difference.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\escapeRegExp.js", {"./toString":"F:\\metamask-extension\\node_modules\\lodash\\toString.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CescapeRegExp.js
      return function (require, module, exports) {
var toString = require('./toString');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
}

module.exports = escapeRegExp;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\escapeRegExp.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js", {"./isArrayLike":"F:\\metamask-extension\\node_modules\\lodash\\isArrayLike.js","./isObjectLike":"F:\\metamask-extension\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisArrayLikeObject.js
      return function (require, module, exports) {
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isArrayLikeObject.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isBoolean.js", {"./_baseGetTag":"F:\\metamask-extension\\node_modules\\lodash\\_baseGetTag.js","./isObjectLike":"F:\\metamask-extension\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisBoolean.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && baseGetTag(value) == boolTag);
}

module.exports = isBoolean;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isBoolean.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isEqual.js", {"./_baseIsEqual":"F:\\metamask-extension\\node_modules\\lodash\\_baseIsEqual.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisEqual.js
      return function (require, module, exports) {
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isEqual.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isNumber.js", {"./_baseGetTag":"F:\\metamask-extension\\node_modules\\lodash\\_baseGetTag.js","./isObjectLike":"F:\\metamask-extension\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisNumber.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isNumber.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isPlainObject.js", {"./_baseGetTag":"F:\\metamask-extension\\node_modules\\lodash\\_baseGetTag.js","./_getPrototype":"F:\\metamask-extension\\node_modules\\lodash\\_getPrototype.js","./isObjectLike":"F:\\metamask-extension\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisPlainObject.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isPlainObject.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isString.js", {"./_baseGetTag":"F:\\metamask-extension\\node_modules\\lodash\\_baseGetTag.js","./isArray":"F:\\metamask-extension\\node_modules\\lodash\\isArray.js","./isObjectLike":"F:\\metamask-extension\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisString.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isString.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\noop.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5Cnoop.js
      return function (require, module, exports) {
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\noop.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\partition.js", {"./_createAggregator":"F:\\metamask-extension\\node_modules\\lodash\\_createAggregator.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5Cpartition.js
      return function (require, module, exports) {
var createAggregator = require('./_createAggregator');

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements `predicate` returns truthy for, the second of which
 * contains elements `predicate` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ];
 *
 * _.partition(users, function(o) { return o.active; });
 * // => objects for [['fred'], ['barney', 'pebbles']]
 *
 * // The `_.matches` iteratee shorthand.
 * _.partition(users, { 'age': 1, 'active': false });
 * // => objects for [['pebbles'], ['barney', 'fred']]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.partition(users, ['active', false]);
 * // => objects for [['barney', 'pebbles'], ['fred']]
 *
 * // The `_.property` iteratee shorthand.
 * _.partition(users, 'active');
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
var partition = createAggregator(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() { return [[], []]; });

module.exports = partition;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\partition.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\sum.js", {"./_baseSum":"F:\\metamask-extension\\node_modules\\lodash\\_baseSum.js","./identity":"F:\\metamask-extension\\node_modules\\lodash\\identity.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5Csum.js
      return function (require, module, exports) {
var baseSum = require('./_baseSum'),
    identity = require('./identity');

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum(array) {
  return (array && array.length)
    ? baseSum(array, identity)
    : 0;
}

module.exports = sum;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\sum.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\union.js", {"./_baseFlatten":"F:\\metamask-extension\\node_modules\\lodash\\_baseFlatten.js","./_baseRest":"F:\\metamask-extension\\node_modules\\lodash\\_baseRest.js","./_baseUniq":"F:\\metamask-extension\\node_modules\\lodash\\_baseUniq.js","./isArrayLikeObject":"F:\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5Cunion.js
      return function (require, module, exports) {
var baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    baseUniq = require('./_baseUniq'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\union.js",}],
["F:\\metamask-extension\\node_modules\\lower-case-first\\lower-case-first.js", {"lower-case":"F:\\metamask-extension\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clower-case-first%5Clower-case-first.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

/**
 * Lower case the first character of a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  if (str == null) {
    return ''
  }

  str = String(str)

  return lowerCase(str.charAt(0), locale) + str.substr(1)
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>lower-case-first",file:"node_modules\\lower-case-first\\lower-case-first.js",}],
["F:\\metamask-extension\\node_modules\\lower-case\\lower-case.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clower-case%5Clower-case.js
      return function (require, module, exports) {
/**
 * Special language-specific overrides.
 *
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 *
 * @type {Object}
 */
var LANGUAGES = {
  tr: {
    regexp: /\u0130|\u0049|\u0049\u0307/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  az: {
    regexp: /[\u0130]/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  lt: {
    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
    map: {
      '\u0049': '\u0069\u0307',
      '\u004A': '\u006A\u0307',
      '\u012E': '\u012F\u0307',
      '\u00CC': '\u0069\u0307\u0300',
      '\u00CD': '\u0069\u0307\u0301',
      '\u0128': '\u0069\u0307\u0303'
    }
  }
}

/**
 * Lowercase a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  var lang = LANGUAGES[locale]

  str = str == null ? '' : String(str)

  if (lang) {
    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
  }

  return str.toLowerCase()
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>lower-case",file:"node_modules\\lower-case\\lower-case.js",}],
["F:\\metamask-extension\\node_modules\\mersenne-twister\\src\\mersenne-twister.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmersenne-twister%5Csrc%5Cmersenne-twister.js
      return function (require, module, exports) {
/*
  https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
  so it's better encapsulated. Now you can have multiple random number generators
  and they won't stomp all over eachother's state.

  If you want to use this as a substitute for Math.random(), use the random()
  method like so:

  var m = new MersenneTwister();
  var randomNumber = m.random();

  You can also call the other genrand_{foo}() methods on the instance.

  If you want to use a specific seed in order to get a repeatable random
  sequence, pass an integer into the constructor:

  var m = new MersenneTwister(123);

  and that will always produce the same random sequence.

  Sean McCullough (banksean@gmail.com)
*/

/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_seed(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

var MersenneTwister = function(seed) {
	if (seed == undefined) {
		seed = new Date().getTime();
	}

	/* Period parameters */
	this.N = 624;
	this.M = 397;
	this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	this.mt = new Array(this.N); /* the array for the state vector */
	this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	if (seed.constructor == Array) {
		this.init_by_array(seed, seed.length);
	}
	else {
		this.init_seed(seed);
	}
}

/* initializes mt[N] with a seed */
/* origin name init_genrand */
MersenneTwister.prototype.init_seed = function(s) {
	this.mt[0] = s >>> 0;
	for (this.mti=1; this.mti<this.N; this.mti++) {
		var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		+ this.mti;
		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		/* In the previous versions, MSBs of the seed affect   */
		/* only MSBs of the array mt[].                        */
		/* 2002/01/09 modified by Makoto Matsumoto             */
		this.mt[this.mti] >>>= 0;
		/* for >32 bit machines */
	}
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
	var i, j, k;
	this.init_seed(19650218);
	i=1; j=0;
	k = (this.N>key_length ? this.N : key_length);
	for (; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		+ init_key[j] + j; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++; j++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		if (j>=key_length) j=0;
	}
	for (k=this.N-1; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		- i; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	}

	this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
/* origin name genrand_int32 */
MersenneTwister.prototype.random_int = function() {
	var y;
	var mag01 = new Array(0x0, this.MATRIX_A);
	/* mag01[x] = x * MATRIX_A  for x=0,1 */

	if (this.mti >= this.N) { /* generate N words at one time */
		var kk;

		if (this.mti == this.N+1)  /* if init_seed() has not been called, */
			this.init_seed(5489);  /* a default initial seed is used */

		for (kk=0;kk<this.N-this.M;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		for (;kk<this.N-1;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		this.mti = 0;
	}

	y = this.mt[this.mti++];

	/* Tempering */
	y ^= (y >>> 11);
	y ^= (y << 7) & 0x9d2c5680;
	y ^= (y << 15) & 0xefc60000;
	y ^= (y >>> 18);

	return y >>> 0;
}

/* generates a random number on [0,0x7fffffff]-interval */
/* origin name genrand_int31 */
MersenneTwister.prototype.random_int31 = function() {
	return (this.random_int()>>>1);
}

/* generates a random number on [0,1]-real-interval */
/* origin name genrand_real1 */
MersenneTwister.prototype.random_incl = function() {
	return this.random_int()*(1.0/4294967295.0);
	/* divided by 2^32-1 */
}

/* generates a random number on [0,1)-real-interval */
MersenneTwister.prototype.random = function() {
	return this.random_int()*(1.0/4294967296.0);
	/* divided by 2^32 */
}

/* generates a random number on (0,1)-real-interval */
/* origin name genrand_real3 */
MersenneTwister.prototype.random_excl = function() {
	return (this.random_int() + 0.5)*(1.0/4294967296.0);
	/* divided by 2^32 */
}

/* generates a random number on [0,1) with 53-bit resolution*/
/* origin name genrand_res53 */
MersenneTwister.prototype.random_long = function() {
	var a=this.random_int()>>>5, b=this.random_int()>>>6;
	return(a*67108864.0+b)*(1.0/9007199254740992.0);
}

/* These real versions are due to Isaku Wada, 2002/01/09 added */

module.exports = MersenneTwister;

      };
    };
  }
  }
}, {package:"@metamask/jazzicon>mersenne-twister",file:"node_modules\\mersenne-twister\\src\\mersenne-twister.js",}],
["F:\\metamask-extension\\node_modules\\mini-create-react-context\\dist\\cjs\\index.js", {"@babel/runtime/helpers/inheritsLoose":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","gud":"F:\\metamask-extension\\node_modules\\gud\\index.js","prop-types":"F:\\metamask-extension\\node_modules\\prop-types\\index.js","react":"F:\\metamask-extension\\node_modules\\react\\index.js","tiny-warning":"F:\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmini-create-react-context%5Cdist%5Ccjs%5Cindex.js
      return function (require, module, exports) {
'use strict';function _interopDefault(e){return(e&&(typeof e==='object')&&'default'in e)?e['default']:e}var React=require('react'),React__default=_interopDefault(React),_inheritsLoose=_interopDefault(require('@babel/runtime/helpers/inheritsLoose')),PropTypes=_interopDefault(require('prop-types')),gud=_interopDefault(require('gud')),warning=_interopDefault(require('tiny-warning'));var MAX_SIGNED_31_BIT_INT = 1073741823;

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + gud() + '__';

  var Provider =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if ("development" !== 'production') {
            warning((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(React.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);

  var Consumer =
  /*#__PURE__*/
  function (_Component2) {
    _inheritsLoose(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(React.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}var index = React__default.createContext || createReactContext;module.exports=index;
      };
    };
  }
  }
}, {package:"react-router-dom>react-router>mini-create-react-context",file:"node_modules\\mini-create-react-context\\dist\\cjs\\index.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
'use strict'

class Base {
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.alphabet = alphabet
    if (implementation && alphabet) {
      this.engine = implementation(alphabet)
    }
  }

  encode (stringOrBuffer) {
    return this.engine.encode(stringOrBuffer)
  }

  decode (stringOrBuffer) {
    return this.engine.decode(stringOrBuffer)
  }

  isImplemented () {
    return this.engine
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base16.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase16.js
      return function (require, module, exports) {
'use strict'
const { Buffer } = require('buffer')

module.exports = function base16 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return Buffer.from(input).toString('hex')
      }
      return input.toString('hex')
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base16 character')
        }
      }
      return Buffer.from(input, 'hex')
    }
  }
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base16.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base32.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase32.js
      return function (require, module, exports) {
'use strict'

function decode (input, alphabet) {
  input = input.replace(new RegExp('=', 'g'), '')
  const length = input.length

  let bits = 0
  let value = 0

  let index = 0
  const output = new Uint8Array((length * 5 / 8) | 0)

  for (let i = 0; i < length; i++) {
    value = (value << 5) | alphabet.indexOf(input[i])
    bits += 5

    if (bits >= 8) {
      output[index++] = (value >>> (bits - 8)) & 255
      bits -= 8
    }
  }

  return output.buffer
}

function encode (buffer, alphabet) {
  const length = buffer.byteLength
  const view = new Uint8Array(buffer)
  const padding = alphabet.indexOf('=') === alphabet.length - 1

  if (padding) {
    alphabet = alphabet.substring(0, alphabet.length - 1)
  }

  let bits = 0
  let value = 0
  let output = ''

  for (let i = 0; i < length; i++) {
    value = (value << 8) | view[i]
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}

module.exports = function base32 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return encode(Uint8Array.from(input), alphabet)
      }

      return encode(input, alphabet)
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base32 character')
        }
      }

      return decode(input, alphabet)
    }
  }
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base32.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base64.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase64.js
      return function (require, module, exports) {
'use strict'
const { Buffer } = require('buffer')

module.exports = function base64 (alphabet) {
  // The alphabet is only used to know:
  //   1. If padding is enabled (must contain '=')
  //   2. If the output must be url-safe (must contain '-' and '_')
  //   3. If the input of the output function is valid
  // The alphabets from RFC 4648 are always used.
  const padding = alphabet.indexOf('=') > -1
  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1

  return {
    encode (input) {
      let output = ''

      if (typeof input === 'string') {
        output = Buffer.from(input).toString('base64')
      } else {
        output = input.toString('base64')
      }

      if (url) {
        output = output.replace(/\+/g, '-').replace(/\//g, '_')
      }

      const pad = output.indexOf('=')
      if (pad > 0 && !padding) {
        output = output.substring(0, pad)
      }

      return output
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base64 character')
        }
      }

      return Buffer.from(input, 'base64')
    }
  }
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\base64.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js", {"./base.js":"F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js","./base16":"F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base16.js","./base32":"F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base32.js","./base64":"F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base64.js","base-x":"F:\\metamask-extension\\node_modules\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

const Base = require('./base.js')
const baseX = require('base-x')
const base16 = require('./base16')
const base32 = require('./base32')
const base64 = require('./base64')

// name, code, implementation, alphabet
const constants = [
  ['base1', '1', '', '1'],
  ['base2', '0', baseX, '01'],
  ['base8', '7', baseX, '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', base16, '0123456789abcdef'],
  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],
  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names: names,
  codes: codes
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js", {"./constants":"F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.names = Object.freeze(Object.keys(constants.names))
exports.codes = Object.freeze(Object.keys(constants.codes))

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be prefixed with multibase.
 * @memberof Multibase
 * @returns {Buffer}
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const base = getBase(nameOrCode)
  const codeBuf = Buffer.from(base.code)

  const name = base.name
  validEncode(name, buf)
  return Buffer.concat([codeBuf, buf])
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be encoded.
 * @returns {Buffer}
 * @memberof Multibase
 */
function encode (nameOrCode, buf) {
  const base = getBase(nameOrCode)
  const name = base.name

  return multibase(name, Buffer.from(base.encode(buf)))
}

/**
 * Takes a buffer or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Buffer|string} bufOrString
 * @returns {Buffer}
 * @memberof Multibase
 *
 */
function decode (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  const code = bufOrString.substring(0, 1)
  bufOrString = bufOrString.substring(1, bufOrString.length)

  if (typeof bufOrString === 'string') {
    bufOrString = Buffer.from(bufOrString)
  }

  const base = getBase(code)
  return Buffer.from(base.decode(bufOrString.toString()))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Buffer|string} bufOrString
 * @returns {boolean}
 * @memberof Multibase
 */
function isEncoded (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
    return false
  }

  const code = bufOrString.substring(0, 1)
  try {
    const base = getBase(code)
    return base.name
  } catch (err) {
    return false
  }
}

/**
 * @param {string} name
 * @param {Buffer} buf
 * @private
 * @returns {undefined}
 */
function validEncode (name, buf) {
  const base = getBase(name)
  base.decode(buf.toString())
}

function getBase (nameOrCode) {
  let base

  if (constants.names[nameOrCode]) {
    base = constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    base = constants.codes[nameOrCode]
  } else {
    throw new Error('Unsupported encoding')
  }

  if (!base.isImplemented()) {
    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
  }

  return base
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes>multibase",file:"node_modules\\multihashes\\node_modules\\multibase\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\src\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Csrc%5Cconstants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
/* eslint key-spacing: off */
'use strict'

exports.names = Object.freeze({
  'identity':   0x0,
  'sha1':       0x11,
  'sha2-256':   0x12,
  'sha2-512':   0x13,
  'dbl-sha2-256': 0x56,
  'sha3-224':   0x17,
  'sha3-256':   0x16,
  'sha3-384':   0x15,
  'sha3-512':   0x14,
  'shake-128':  0x18,
  'shake-256':  0x19,
  'keccak-224': 0x1A,
  'keccak-256': 0x1B,
  'keccak-384': 0x1C,
  'keccak-512': 0x1D,
  'murmur3-128': 0x22,
  'murmur3-32':  0x23,
  'md4':         0xd4,
  'md5':         0xd5,
  'blake2b-8':   0xb201,
  'blake2b-16':  0xb202,
  'blake2b-24':  0xb203,
  'blake2b-32':  0xb204,
  'blake2b-40':  0xb205,
  'blake2b-48':  0xb206,
  'blake2b-56':  0xb207,
  'blake2b-64':  0xb208,
  'blake2b-72':  0xb209,
  'blake2b-80':  0xb20a,
  'blake2b-88':  0xb20b,
  'blake2b-96':  0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8':   0xb241,
  'blake2s-16':  0xb242,
  'blake2s-24':  0xb243,
  'blake2s-32':  0xb244,
  'blake2s-40':  0xb245,
  'blake2s-48':  0xb246,
  'blake2s-56':  0xb247,
  'blake2s-64':  0xb248,
  'blake2s-72':  0xb249,
  'blake2s-80':  0xb24a,
  'blake2s-88':  0xb24b,
  'blake2s-96':  0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'Skein256-8': 0xb301,
  'Skein256-16': 0xb302,
  'Skein256-24': 0xb303,
  'Skein256-32': 0xb304,
  'Skein256-40': 0xb305,
  'Skein256-48': 0xb306,
  'Skein256-56': 0xb307,
  'Skein256-64': 0xb308,
  'Skein256-72': 0xb309,
  'Skein256-80': 0xb30a,
  'Skein256-88': 0xb30b,
  'Skein256-96': 0xb30c,
  'Skein256-104': 0xb30d,
  'Skein256-112': 0xb30e,
  'Skein256-120': 0xb30f,
  'Skein256-128': 0xb310,
  'Skein256-136': 0xb311,
  'Skein256-144': 0xb312,
  'Skein256-152': 0xb313,
  'Skein256-160': 0xb314,
  'Skein256-168': 0xb315,
  'Skein256-176': 0xb316,
  'Skein256-184': 0xb317,
  'Skein256-192': 0xb318,
  'Skein256-200': 0xb319,
  'Skein256-208': 0xb31a,
  'Skein256-216': 0xb31b,
  'Skein256-224': 0xb31c,
  'Skein256-232': 0xb31d,
  'Skein256-240': 0xb31e,
  'Skein256-248': 0xb31f,
  'Skein256-256': 0xb320,
  'Skein512-8': 0xb321,
  'Skein512-16': 0xb322,
  'Skein512-24': 0xb323,
  'Skein512-32': 0xb324,
  'Skein512-40': 0xb325,
  'Skein512-48': 0xb326,
  'Skein512-56': 0xb327,
  'Skein512-64': 0xb328,
  'Skein512-72': 0xb329,
  'Skein512-80': 0xb32a,
  'Skein512-88': 0xb32b,
  'Skein512-96': 0xb32c,
  'Skein512-104': 0xb32d,
  'Skein512-112': 0xb32e,
  'Skein512-120': 0xb32f,
  'Skein512-128': 0xb330,
  'Skein512-136': 0xb331,
  'Skein512-144': 0xb332,
  'Skein512-152': 0xb333,
  'Skein512-160': 0xb334,
  'Skein512-168': 0xb335,
  'Skein512-176': 0xb336,
  'Skein512-184': 0xb337,
  'Skein512-192': 0xb338,
  'Skein512-200': 0xb339,
  'Skein512-208': 0xb33a,
  'Skein512-216': 0xb33b,
  'Skein512-224': 0xb33c,
  'Skein512-232': 0xb33d,
  'Skein512-240': 0xb33e,
  'Skein512-248': 0xb33f,
  'Skein512-256': 0xb340,
  'Skein512-264': 0xb341,
  'Skein512-272': 0xb342,
  'Skein512-280': 0xb343,
  'Skein512-288': 0xb344,
  'Skein512-296': 0xb345,
  'Skein512-304': 0xb346,
  'Skein512-312': 0xb347,
  'Skein512-320': 0xb348,
  'Skein512-328': 0xb349,
  'Skein512-336': 0xb34a,
  'Skein512-344': 0xb34b,
  'Skein512-352': 0xb34c,
  'Skein512-360': 0xb34d,
  'Skein512-368': 0xb34e,
  'Skein512-376': 0xb34f,
  'Skein512-384': 0xb350,
  'Skein512-392': 0xb351,
  'Skein512-400': 0xb352,
  'Skein512-408': 0xb353,
  'Skein512-416': 0xb354,
  'Skein512-424': 0xb355,
  'Skein512-432': 0xb356,
  'Skein512-440': 0xb357,
  'Skein512-448': 0xb358,
  'Skein512-456': 0xb359,
  'Skein512-464': 0xb35a,
  'Skein512-472': 0xb35b,
  'Skein512-480': 0xb35c,
  'Skein512-488': 0xb35d,
  'Skein512-496': 0xb35e,
  'Skein512-504': 0xb35f,
  'Skein512-512': 0xb360,
  'Skein1024-8': 0xb361,
  'Skein1024-16': 0xb362,
  'Skein1024-24': 0xb363,
  'Skein1024-32': 0xb364,
  'Skein1024-40': 0xb365,
  'Skein1024-48': 0xb366,
  'Skein1024-56': 0xb367,
  'Skein1024-64': 0xb368,
  'Skein1024-72': 0xb369,
  'Skein1024-80': 0xb36a,
  'Skein1024-88': 0xb36b,
  'Skein1024-96': 0xb36c,
  'Skein1024-104': 0xb36d,
  'Skein1024-112': 0xb36e,
  'Skein1024-120': 0xb36f,
  'Skein1024-128': 0xb370,
  'Skein1024-136': 0xb371,
  'Skein1024-144': 0xb372,
  'Skein1024-152': 0xb373,
  'Skein1024-160': 0xb374,
  'Skein1024-168': 0xb375,
  'Skein1024-176': 0xb376,
  'Skein1024-184': 0xb377,
  'Skein1024-192': 0xb378,
  'Skein1024-200': 0xb379,
  'Skein1024-208': 0xb37a,
  'Skein1024-216': 0xb37b,
  'Skein1024-224': 0xb37c,
  'Skein1024-232': 0xb37d,
  'Skein1024-240': 0xb37e,
  'Skein1024-248': 0xb37f,
  'Skein1024-256': 0xb380,
  'Skein1024-264': 0xb381,
  'Skein1024-272': 0xb382,
  'Skein1024-280': 0xb383,
  'Skein1024-288': 0xb384,
  'Skein1024-296': 0xb385,
  'Skein1024-304': 0xb386,
  'Skein1024-312': 0xb387,
  'Skein1024-320': 0xb388,
  'Skein1024-328': 0xb389,
  'Skein1024-336': 0xb38a,
  'Skein1024-344': 0xb38b,
  'Skein1024-352': 0xb38c,
  'Skein1024-360': 0xb38d,
  'Skein1024-368': 0xb38e,
  'Skein1024-376': 0xb38f,
  'Skein1024-384': 0xb390,
  'Skein1024-392': 0xb391,
  'Skein1024-400': 0xb392,
  'Skein1024-408': 0xb393,
  'Skein1024-416': 0xb394,
  'Skein1024-424': 0xb395,
  'Skein1024-432': 0xb396,
  'Skein1024-440': 0xb397,
  'Skein1024-448': 0xb398,
  'Skein1024-456': 0xb399,
  'Skein1024-464': 0xb39a,
  'Skein1024-472': 0xb39b,
  'Skein1024-480': 0xb39c,
  'Skein1024-488': 0xb39d,
  'Skein1024-496': 0xb39e,
  'Skein1024-504': 0xb39f,
  'Skein1024-512': 0xb3a0,
  'Skein1024-520': 0xb3a1,
  'Skein1024-528': 0xb3a2,
  'Skein1024-536': 0xb3a3,
  'Skein1024-544': 0xb3a4,
  'Skein1024-552': 0xb3a5,
  'Skein1024-560': 0xb3a6,
  'Skein1024-568': 0xb3a7,
  'Skein1024-576': 0xb3a8,
  'Skein1024-584': 0xb3a9,
  'Skein1024-592': 0xb3aa,
  'Skein1024-600': 0xb3ab,
  'Skein1024-608': 0xb3ac,
  'Skein1024-616': 0xb3ad,
  'Skein1024-624': 0xb3ae,
  'Skein1024-632': 0xb3af,
  'Skein1024-640': 0xb3b0,
  'Skein1024-648': 0xb3b1,
  'Skein1024-656': 0xb3b2,
  'Skein1024-664': 0xb3b3,
  'Skein1024-672': 0xb3b4,
  'Skein1024-680': 0xb3b5,
  'Skein1024-688': 0xb3b6,
  'Skein1024-696': 0xb3b7,
  'Skein1024-704': 0xb3b8,
  'Skein1024-712': 0xb3b9,
  'Skein1024-720': 0xb3ba,
  'Skein1024-728': 0xb3bb,
  'Skein1024-736': 0xb3bc,
  'Skein1024-744': 0xb3bd,
  'Skein1024-752': 0xb3be,
  'Skein1024-760': 0xb3bf,
  'Skein1024-768': 0xb3c0,
  'Skein1024-776': 0xb3c1,
  'Skein1024-784': 0xb3c2,
  'Skein1024-792': 0xb3c3,
  'Skein1024-800': 0xb3c4,
  'Skein1024-808': 0xb3c5,
  'Skein1024-816': 0xb3c6,
  'Skein1024-824': 0xb3c7,
  'Skein1024-832': 0xb3c8,
  'Skein1024-840': 0xb3c9,
  'Skein1024-848': 0xb3ca,
  'Skein1024-856': 0xb3cb,
  'Skein1024-864': 0xb3cc,
  'Skein1024-872': 0xb3cd,
  'Skein1024-880': 0xb3ce,
  'Skein1024-888': 0xb3cf,
  'Skein1024-896': 0xb3d0,
  'Skein1024-904': 0xb3d1,
  'Skein1024-912': 0xb3d2,
  'Skein1024-920': 0xb3d3,
  'Skein1024-928': 0xb3d4,
  'Skein1024-936': 0xb3d5,
  'Skein1024-944': 0xb3d6,
  'Skein1024-952': 0xb3d7,
  'Skein1024-960': 0xb3d8,
  'Skein1024-968': 0xb3d9,
  'Skein1024-976': 0xb3da,
  'Skein1024-984': 0xb3db,
  'Skein1024-992': 0xb3dc,
  'Skein1024-1000': 0xb3dd,
  'Skein1024-1008': 0xb3de,
  'Skein1024-1016': 0xb3df,
  'Skein1024-1024': 0xb3e0
})

exports.codes = Object.freeze({
  0x0: 'identity',

  // sha family
  0x11: 'sha1',
  0x12: 'sha2-256',
  0x13: 'sha2-512',
  0x56: 'dbl-sha2-256',
  0x17: 'sha3-224',
  0x16: 'sha3-256',
  0x15: 'sha3-384',
  0x14: 'sha3-512',
  0x18: 'shake-128',
  0x19: 'shake-256',
  0x1A: 'keccak-224',
  0x1B: 'keccak-256',
  0x1C: 'keccak-384',
  0x1D: 'keccak-512',

  0x22: 'murmur3-128',
  0x23: 'murmur3-32',

  0xd4: 'md4',
  0xd5: 'md5',

  // blake2
  0xb201: 'blake2b-8',
  0xb202: 'blake2b-16',
  0xb203: 'blake2b-24',
  0xb204: 'blake2b-32',
  0xb205: 'blake2b-40',
  0xb206: 'blake2b-48',
  0xb207: 'blake2b-56',
  0xb208: 'blake2b-64',
  0xb209: 'blake2b-72',
  0xb20a: 'blake2b-80',
  0xb20b: 'blake2b-88',
  0xb20c: 'blake2b-96',
  0xb20d: 'blake2b-104',
  0xb20e: 'blake2b-112',
  0xb20f: 'blake2b-120',
  0xb210: 'blake2b-128',
  0xb211: 'blake2b-136',
  0xb212: 'blake2b-144',
  0xb213: 'blake2b-152',
  0xb214: 'blake2b-160',
  0xb215: 'blake2b-168',
  0xb216: 'blake2b-176',
  0xb217: 'blake2b-184',
  0xb218: 'blake2b-192',
  0xb219: 'blake2b-200',
  0xb21a: 'blake2b-208',
  0xb21b: 'blake2b-216',
  0xb21c: 'blake2b-224',
  0xb21d: 'blake2b-232',
  0xb21e: 'blake2b-240',
  0xb21f: 'blake2b-248',
  0xb220: 'blake2b-256',
  0xb221: 'blake2b-264',
  0xb222: 'blake2b-272',
  0xb223: 'blake2b-280',
  0xb224: 'blake2b-288',
  0xb225: 'blake2b-296',
  0xb226: 'blake2b-304',
  0xb227: 'blake2b-312',
  0xb228: 'blake2b-320',
  0xb229: 'blake2b-328',
  0xb22a: 'blake2b-336',
  0xb22b: 'blake2b-344',
  0xb22c: 'blake2b-352',
  0xb22d: 'blake2b-360',
  0xb22e: 'blake2b-368',
  0xb22f: 'blake2b-376',
  0xb230: 'blake2b-384',
  0xb231: 'blake2b-392',
  0xb232: 'blake2b-400',
  0xb233: 'blake2b-408',
  0xb234: 'blake2b-416',
  0xb235: 'blake2b-424',
  0xb236: 'blake2b-432',
  0xb237: 'blake2b-440',
  0xb238: 'blake2b-448',
  0xb239: 'blake2b-456',
  0xb23a: 'blake2b-464',
  0xb23b: 'blake2b-472',
  0xb23c: 'blake2b-480',
  0xb23d: 'blake2b-488',
  0xb23e: 'blake2b-496',
  0xb23f: 'blake2b-504',
  0xb240: 'blake2b-512',
  0xb241: 'blake2s-8',
  0xb242: 'blake2s-16',
  0xb243: 'blake2s-24',
  0xb244: 'blake2s-32',
  0xb245: 'blake2s-40',
  0xb246: 'blake2s-48',
  0xb247: 'blake2s-56',
  0xb248: 'blake2s-64',
  0xb249: 'blake2s-72',
  0xb24a: 'blake2s-80',
  0xb24b: 'blake2s-88',
  0xb24c: 'blake2s-96',
  0xb24d: 'blake2s-104',
  0xb24e: 'blake2s-112',
  0xb24f: 'blake2s-120',
  0xb250: 'blake2s-128',
  0xb251: 'blake2s-136',
  0xb252: 'blake2s-144',
  0xb253: 'blake2s-152',
  0xb254: 'blake2s-160',
  0xb255: 'blake2s-168',
  0xb256: 'blake2s-176',
  0xb257: 'blake2s-184',
  0xb258: 'blake2s-192',
  0xb259: 'blake2s-200',
  0xb25a: 'blake2s-208',
  0xb25b: 'blake2s-216',
  0xb25c: 'blake2s-224',
  0xb25d: 'blake2s-232',
  0xb25e: 'blake2s-240',
  0xb25f: 'blake2s-248',
  0xb260: 'blake2s-256',

  // skein
  0xb301: 'Skein256-8',
  0xb302: 'Skein256-16',
  0xb303: 'Skein256-24',
  0xb304: 'Skein256-32',
  0xb305: 'Skein256-40',
  0xb306: 'Skein256-48',
  0xb307: 'Skein256-56',
  0xb308: 'Skein256-64',
  0xb309: 'Skein256-72',
  0xb30a: 'Skein256-80',
  0xb30b: 'Skein256-88',
  0xb30c: 'Skein256-96',
  0xb30d: 'Skein256-104',
  0xb30e: 'Skein256-112',
  0xb30f: 'Skein256-120',
  0xb310: 'Skein256-128',
  0xb311: 'Skein256-136',
  0xb312: 'Skein256-144',
  0xb313: 'Skein256-152',
  0xb314: 'Skein256-160',
  0xb315: 'Skein256-168',
  0xb316: 'Skein256-176',
  0xb317: 'Skein256-184',
  0xb318: 'Skein256-192',
  0xb319: 'Skein256-200',
  0xb31a: 'Skein256-208',
  0xb31b: 'Skein256-216',
  0xb31c: 'Skein256-224',
  0xb31d: 'Skein256-232',
  0xb31e: 'Skein256-240',
  0xb31f: 'Skein256-248',
  0xb320: 'Skein256-256',
  0xb321: 'Skein512-8',
  0xb322: 'Skein512-16',
  0xb323: 'Skein512-24',
  0xb324: 'Skein512-32',
  0xb325: 'Skein512-40',
  0xb326: 'Skein512-48',
  0xb327: 'Skein512-56',
  0xb328: 'Skein512-64',
  0xb329: 'Skein512-72',
  0xb32a: 'Skein512-80',
  0xb32b: 'Skein512-88',
  0xb32c: 'Skein512-96',
  0xb32d: 'Skein512-104',
  0xb32e: 'Skein512-112',
  0xb32f: 'Skein512-120',
  0xb330: 'Skein512-128',
  0xb331: 'Skein512-136',
  0xb332: 'Skein512-144',
  0xb333: 'Skein512-152',
  0xb334: 'Skein512-160',
  0xb335: 'Skein512-168',
  0xb336: 'Skein512-176',
  0xb337: 'Skein512-184',
  0xb338: 'Skein512-192',
  0xb339: 'Skein512-200',
  0xb33a: 'Skein512-208',
  0xb33b: 'Skein512-216',
  0xb33c: 'Skein512-224',
  0xb33d: 'Skein512-232',
  0xb33e: 'Skein512-240',
  0xb33f: 'Skein512-248',
  0xb340: 'Skein512-256',
  0xb341: 'Skein512-264',
  0xb342: 'Skein512-272',
  0xb343: 'Skein512-280',
  0xb344: 'Skein512-288',
  0xb345: 'Skein512-296',
  0xb346: 'Skein512-304',
  0xb347: 'Skein512-312',
  0xb348: 'Skein512-320',
  0xb349: 'Skein512-328',
  0xb34a: 'Skein512-336',
  0xb34b: 'Skein512-344',
  0xb34c: 'Skein512-352',
  0xb34d: 'Skein512-360',
  0xb34e: 'Skein512-368',
  0xb34f: 'Skein512-376',
  0xb350: 'Skein512-384',
  0xb351: 'Skein512-392',
  0xb352: 'Skein512-400',
  0xb353: 'Skein512-408',
  0xb354: 'Skein512-416',
  0xb355: 'Skein512-424',
  0xb356: 'Skein512-432',
  0xb357: 'Skein512-440',
  0xb358: 'Skein512-448',
  0xb359: 'Skein512-456',
  0xb35a: 'Skein512-464',
  0xb35b: 'Skein512-472',
  0xb35c: 'Skein512-480',
  0xb35d: 'Skein512-488',
  0xb35e: 'Skein512-496',
  0xb35f: 'Skein512-504',
  0xb360: 'Skein512-512',
  0xb361: 'Skein1024-8',
  0xb362: 'Skein1024-16',
  0xb363: 'Skein1024-24',
  0xb364: 'Skein1024-32',
  0xb365: 'Skein1024-40',
  0xb366: 'Skein1024-48',
  0xb367: 'Skein1024-56',
  0xb368: 'Skein1024-64',
  0xb369: 'Skein1024-72',
  0xb36a: 'Skein1024-80',
  0xb36b: 'Skein1024-88',
  0xb36c: 'Skein1024-96',
  0xb36d: 'Skein1024-104',
  0xb36e: 'Skein1024-112',
  0xb36f: 'Skein1024-120',
  0xb370: 'Skein1024-128',
  0xb371: 'Skein1024-136',
  0xb372: 'Skein1024-144',
  0xb373: 'Skein1024-152',
  0xb374: 'Skein1024-160',
  0xb375: 'Skein1024-168',
  0xb376: 'Skein1024-176',
  0xb377: 'Skein1024-184',
  0xb378: 'Skein1024-192',
  0xb379: 'Skein1024-200',
  0xb37a: 'Skein1024-208',
  0xb37b: 'Skein1024-216',
  0xb37c: 'Skein1024-224',
  0xb37d: 'Skein1024-232',
  0xb37e: 'Skein1024-240',
  0xb37f: 'Skein1024-248',
  0xb380: 'Skein1024-256',
  0xb381: 'Skein1024-264',
  0xb382: 'Skein1024-272',
  0xb383: 'Skein1024-280',
  0xb384: 'Skein1024-288',
  0xb385: 'Skein1024-296',
  0xb386: 'Skein1024-304',
  0xb387: 'Skein1024-312',
  0xb388: 'Skein1024-320',
  0xb389: 'Skein1024-328',
  0xb38a: 'Skein1024-336',
  0xb38b: 'Skein1024-344',
  0xb38c: 'Skein1024-352',
  0xb38d: 'Skein1024-360',
  0xb38e: 'Skein1024-368',
  0xb38f: 'Skein1024-376',
  0xb390: 'Skein1024-384',
  0xb391: 'Skein1024-392',
  0xb392: 'Skein1024-400',
  0xb393: 'Skein1024-408',
  0xb394: 'Skein1024-416',
  0xb395: 'Skein1024-424',
  0xb396: 'Skein1024-432',
  0xb397: 'Skein1024-440',
  0xb398: 'Skein1024-448',
  0xb399: 'Skein1024-456',
  0xb39a: 'Skein1024-464',
  0xb39b: 'Skein1024-472',
  0xb39c: 'Skein1024-480',
  0xb39d: 'Skein1024-488',
  0xb39e: 'Skein1024-496',
  0xb39f: 'Skein1024-504',
  0xb3a0: 'Skein1024-512',
  0xb3a1: 'Skein1024-520',
  0xb3a2: 'Skein1024-528',
  0xb3a3: 'Skein1024-536',
  0xb3a4: 'Skein1024-544',
  0xb3a5: 'Skein1024-552',
  0xb3a6: 'Skein1024-560',
  0xb3a7: 'Skein1024-568',
  0xb3a8: 'Skein1024-576',
  0xb3a9: 'Skein1024-584',
  0xb3aa: 'Skein1024-592',
  0xb3ab: 'Skein1024-600',
  0xb3ac: 'Skein1024-608',
  0xb3ad: 'Skein1024-616',
  0xb3ae: 'Skein1024-624',
  0xb3af: 'Skein1024-632',
  0xb3b0: 'Skein1024-640',
  0xb3b1: 'Skein1024-648',
  0xb3b2: 'Skein1024-656',
  0xb3b3: 'Skein1024-664',
  0xb3b4: 'Skein1024-672',
  0xb3b5: 'Skein1024-680',
  0xb3b6: 'Skein1024-688',
  0xb3b7: 'Skein1024-696',
  0xb3b8: 'Skein1024-704',
  0xb3b9: 'Skein1024-712',
  0xb3ba: 'Skein1024-720',
  0xb3bb: 'Skein1024-728',
  0xb3bc: 'Skein1024-736',
  0xb3bd: 'Skein1024-744',
  0xb3be: 'Skein1024-752',
  0xb3bf: 'Skein1024-760',
  0xb3c0: 'Skein1024-768',
  0xb3c1: 'Skein1024-776',
  0xb3c2: 'Skein1024-784',
  0xb3c3: 'Skein1024-792',
  0xb3c4: 'Skein1024-800',
  0xb3c5: 'Skein1024-808',
  0xb3c6: 'Skein1024-816',
  0xb3c7: 'Skein1024-824',
  0xb3c8: 'Skein1024-832',
  0xb3c9: 'Skein1024-840',
  0xb3ca: 'Skein1024-848',
  0xb3cb: 'Skein1024-856',
  0xb3cc: 'Skein1024-864',
  0xb3cd: 'Skein1024-872',
  0xb3ce: 'Skein1024-880',
  0xb3cf: 'Skein1024-888',
  0xb3d0: 'Skein1024-896',
  0xb3d1: 'Skein1024-904',
  0xb3d2: 'Skein1024-912',
  0xb3d3: 'Skein1024-920',
  0xb3d4: 'Skein1024-928',
  0xb3d5: 'Skein1024-936',
  0xb3d6: 'Skein1024-944',
  0xb3d7: 'Skein1024-952',
  0xb3d8: 'Skein1024-960',
  0xb3d9: 'Skein1024-968',
  0xb3da: 'Skein1024-976',
  0xb3db: 'Skein1024-984',
  0xb3dc: 'Skein1024-992',
  0xb3dd: 'Skein1024-1000',
  0xb3de: 'Skein1024-1008',
  0xb3df: 'Skein1024-1016',
  0xb3e0: 'Skein1024-1024'
})

exports.defaultLengths = Object.freeze({
  0x11: 20,
  0x12: 32,
  0x13: 64,
  0x56: 32,
  0x17: 28,
  0x16: 32,
  0x15: 48,
  0x14: 64,
  0x18: 32,
  0x19: 64,
  0x1A: 28,
  0x1B: 32,
  0x1C: 48,
  0x1D: 64,
  0x22: 32,

  0xb201: 0x01,
  0xb202: 0x02,
  0xb203: 0x03,
  0xb204: 0x04,
  0xb205: 0x05,
  0xb206: 0x06,
  0xb207: 0x07,
  0xb208: 0x08,
  0xb209: 0x09,
  0xb20a: 0x0a,
  0xb20b: 0x0b,
  0xb20c: 0x0c,
  0xb20d: 0x0d,
  0xb20e: 0x0e,
  0xb20f: 0x0f,
  0xb210: 0x10,
  0xb211: 0x11,
  0xb212: 0x12,
  0xb213: 0x13,
  0xb214: 0x14,
  0xb215: 0x15,
  0xb216: 0x16,
  0xb217: 0x17,
  0xb218: 0x18,
  0xb219: 0x19,
  0xb21a: 0x1a,
  0xb21b: 0x1b,
  0xb21c: 0x1c,
  0xb21d: 0x1d,
  0xb21e: 0x1e,
  0xb21f: 0x1f,
  0xb220: 0x20,
  0xb221: 0x21,
  0xb222: 0x22,
  0xb223: 0x23,
  0xb224: 0x24,
  0xb225: 0x25,
  0xb226: 0x26,
  0xb227: 0x27,
  0xb228: 0x28,
  0xb229: 0x29,
  0xb22a: 0x2a,
  0xb22b: 0x2b,
  0xb22c: 0x2c,
  0xb22d: 0x2d,
  0xb22e: 0x2e,
  0xb22f: 0x2f,
  0xb230: 0x30,
  0xb231: 0x31,
  0xb232: 0x32,
  0xb233: 0x33,
  0xb234: 0x34,
  0xb235: 0x35,
  0xb236: 0x36,
  0xb237: 0x37,
  0xb238: 0x38,
  0xb239: 0x39,
  0xb23a: 0x3a,
  0xb23b: 0x3b,
  0xb23c: 0x3c,
  0xb23d: 0x3d,
  0xb23e: 0x3e,
  0xb23f: 0x3f,
  0xb240: 0x40,
  0xb241: 0x01,
  0xb242: 0x02,
  0xb243: 0x03,
  0xb244: 0x04,
  0xb245: 0x05,
  0xb246: 0x06,
  0xb247: 0x07,
  0xb248: 0x08,
  0xb249: 0x09,
  0xb24a: 0x0a,
  0xb24b: 0x0b,
  0xb24c: 0x0c,
  0xb24d: 0x0d,
  0xb24e: 0x0e,
  0xb24f: 0x0f,
  0xb250: 0x10,
  0xb251: 0x11,
  0xb252: 0x12,
  0xb253: 0x13,
  0xb254: 0x14,
  0xb255: 0x15,
  0xb256: 0x16,
  0xb257: 0x17,
  0xb258: 0x18,
  0xb259: 0x19,
  0xb25a: 0x1a,
  0xb25b: 0x1b,
  0xb25c: 0x1c,
  0xb25d: 0x1d,
  0xb25e: 0x1e,
  0xb25f: 0x1f,
  0xb260: 0x20,
  0xb301: 0x01,
  0xb302: 0x02,
  0xb303: 0x03,
  0xb304: 0x04,
  0xb305: 0x05,
  0xb306: 0x06,
  0xb307: 0x07,
  0xb308: 0x08,
  0xb309: 0x09,
  0xb30a: 0x0a,
  0xb30b: 0x0b,
  0xb30c: 0x0c,
  0xb30d: 0x0d,
  0xb30e: 0x0e,
  0xb30f: 0x0f,
  0xb310: 0x10,
  0xb311: 0x11,
  0xb312: 0x12,
  0xb313: 0x13,
  0xb314: 0x14,
  0xb315: 0x15,
  0xb316: 0x16,
  0xb317: 0x17,
  0xb318: 0x18,
  0xb319: 0x19,
  0xb31a: 0x1a,
  0xb31b: 0x1b,
  0xb31c: 0x1c,
  0xb31d: 0x1d,
  0xb31e: 0x1e,
  0xb31f: 0x1f,
  0xb320: 0x20,
  0xb321: 0x01,
  0xb322: 0x02,
  0xb323: 0x03,
  0xb324: 0x04,
  0xb325: 0x05,
  0xb326: 0x06,
  0xb327: 0x07,
  0xb328: 0x08,
  0xb329: 0x09,
  0xb32a: 0x0a,
  0xb32b: 0x0b,
  0xb32c: 0x0c,
  0xb32d: 0x0d,
  0xb32e: 0x0e,
  0xb32f: 0x0f,
  0xb330: 0x10,
  0xb331: 0x11,
  0xb332: 0x12,
  0xb333: 0x13,
  0xb334: 0x14,
  0xb335: 0x15,
  0xb336: 0x16,
  0xb337: 0x17,
  0xb338: 0x18,
  0xb339: 0x19,
  0xb33a: 0x1a,
  0xb33b: 0x1b,
  0xb33c: 0x1c,
  0xb33d: 0x1d,
  0xb33e: 0x1e,
  0xb33f: 0x1f,
  0xb340: 0x20,
  0xb341: 0x21,
  0xb342: 0x22,
  0xb343: 0x23,
  0xb344: 0x24,
  0xb345: 0x25,
  0xb346: 0x26,
  0xb347: 0x27,
  0xb348: 0x28,
  0xb349: 0x29,
  0xb34a: 0x2a,
  0xb34b: 0x2b,
  0xb34c: 0x2c,
  0xb34d: 0x2d,
  0xb34e: 0x2e,
  0xb34f: 0x2f,
  0xb350: 0x30,
  0xb351: 0x31,
  0xb352: 0x32,
  0xb353: 0x33,
  0xb354: 0x34,
  0xb355: 0x35,
  0xb356: 0x36,
  0xb357: 0x37,
  0xb358: 0x38,
  0xb359: 0x39,
  0xb35a: 0x3a,
  0xb35b: 0x3b,
  0xb35c: 0x3c,
  0xb35d: 0x3d,
  0xb35e: 0x3e,
  0xb35f: 0x3f,
  0xb360: 0x40,
  0xb361: 0x01,
  0xb362: 0x02,
  0xb363: 0x03,
  0xb364: 0x04,
  0xb365: 0x05,
  0xb366: 0x06,
  0xb367: 0x07,
  0xb368: 0x08,
  0xb369: 0x09,
  0xb36a: 0x0a,
  0xb36b: 0x0b,
  0xb36c: 0x0c,
  0xb36d: 0x0d,
  0xb36e: 0x0e,
  0xb36f: 0x0f,
  0xb370: 0x10,
  0xb371: 0x11,
  0xb372: 0x12,
  0xb373: 0x13,
  0xb374: 0x14,
  0xb375: 0x15,
  0xb376: 0x16,
  0xb377: 0x17,
  0xb378: 0x18,
  0xb379: 0x19,
  0xb37a: 0x1a,
  0xb37b: 0x1b,
  0xb37c: 0x1c,
  0xb37d: 0x1d,
  0xb37e: 0x1e,
  0xb37f: 0x1f,
  0xb380: 0x20,
  0xb381: 0x21,
  0xb382: 0x22,
  0xb383: 0x23,
  0xb384: 0x24,
  0xb385: 0x25,
  0xb386: 0x26,
  0xb387: 0x27,
  0xb388: 0x28,
  0xb389: 0x29,
  0xb38a: 0x2a,
  0xb38b: 0x2b,
  0xb38c: 0x2c,
  0xb38d: 0x2d,
  0xb38e: 0x2e,
  0xb38f: 0x2f,
  0xb390: 0x30,
  0xb391: 0x31,
  0xb392: 0x32,
  0xb393: 0x33,
  0xb394: 0x34,
  0xb395: 0x35,
  0xb396: 0x36,
  0xb397: 0x37,
  0xb398: 0x38,
  0xb399: 0x39,
  0xb39a: 0x3a,
  0xb39b: 0x3b,
  0xb39c: 0x3c,
  0xb39d: 0x3d,
  0xb39e: 0x3e,
  0xb39f: 0x3f,
  0xb3a0: 0x40,
  0xb3a1: 0x41,
  0xb3a2: 0x42,
  0xb3a3: 0x43,
  0xb3a4: 0x44,
  0xb3a5: 0x45,
  0xb3a6: 0x46,
  0xb3a7: 0x47,
  0xb3a8: 0x48,
  0xb3a9: 0x49,
  0xb3aa: 0x4a,
  0xb3ab: 0x4b,
  0xb3ac: 0x4c,
  0xb3ad: 0x4d,
  0xb3ae: 0x4e,
  0xb3af: 0x4f,
  0xb3b0: 0x50,
  0xb3b1: 0x51,
  0xb3b2: 0x52,
  0xb3b3: 0x53,
  0xb3b4: 0x54,
  0xb3b5: 0x55,
  0xb3b6: 0x56,
  0xb3b7: 0x57,
  0xb3b8: 0x58,
  0xb3b9: 0x59,
  0xb3ba: 0x5a,
  0xb3bb: 0x5b,
  0xb3bc: 0x5c,
  0xb3bd: 0x5d,
  0xb3be: 0x5e,
  0xb3bf: 0x5f,
  0xb3c0: 0x60,
  0xb3c1: 0x61,
  0xb3c2: 0x62,
  0xb3c3: 0x63,
  0xb3c4: 0x64,
  0xb3c5: 0x65,
  0xb3c6: 0x66,
  0xb3c7: 0x67,
  0xb3c8: 0x68,
  0xb3c9: 0x69,
  0xb3ca: 0x6a,
  0xb3cb: 0x6b,
  0xb3cc: 0x6c,
  0xb3cd: 0x6d,
  0xb3ce: 0x6e,
  0xb3cf: 0x6f,
  0xb3d0: 0x70,
  0xb3d1: 0x71,
  0xb3d2: 0x72,
  0xb3d3: 0x73,
  0xb3d4: 0x74,
  0xb3d5: 0x75,
  0xb3d6: 0x76,
  0xb3d7: 0x77,
  0xb3d8: 0x78,
  0xb3d9: 0x79,
  0xb3da: 0x7a,
  0xb3db: 0x7b,
  0xb3dc: 0x7c,
  0xb3dd: 0x7d,
  0xb3de: 0x7e,
  0xb3df: 0x7f,
  0xb3e0: 0x80
})

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes",file:"node_modules\\multihashes\\src\\constants.js",}],
["F:\\metamask-extension\\node_modules\\multihashes\\src\\index.js", {"./constants":"F:\\metamask-extension\\node_modules\\multihashes\\src\\constants.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","multibase":"F:\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js","varint":"F:\\metamask-extension\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultihashes%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const cs = require('./constants')

exports.names = cs.names
exports.codes = cs.codes
exports.defaultLengths = cs.defaultLengths

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return hash.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return multibase.encode('base58btc', hash).toString().slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Buffer} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  let encoded = hash
  if (Buffer.isBuffer(hash)) {
    encoded = hash.toString()
  }

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Buffer} buf
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (buf) {
  if (!(Buffer.isBuffer(buf))) {
    throw new Error('multihash must be a Buffer')
  }

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code: code,
    name: cs.codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Buffer} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(Buffer.isBuffer(digest))) {
    throw new Error('digest should be a Buffer')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  return Buffer.concat([
    Buffer.from(varint.encode(hashfn)),
    Buffer.from(varint.encode(length)),
    digest
  ])
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (cs.names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = cs.names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (cs.codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return multihash.slice(0, 2)
}

      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/encoder>@ensdomains/ensjs>content-hash>multihashes",file:"node_modules\\multihashes\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\nanoid\\non-secure\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cnanoid%5Cnon-secure%5Cindex.js
      return function (require, module, exports) {
// This alphabet uses a-z A-Z 0-9 _- symbols.
// Symbols are generated for smaller size.
// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA
var url = '-_'
// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).
var i = 36
while (i--) {
  // 36 is radix. Number.prototype.toString(36) returns number
  // in Base36 representation. Base36 is like hex, but it uses 0–9 and a-z.
  url += i.toString(36)
}
// Loop from 36 to 10 (from Z to A in Base36).
i = 36
while (i-- - 10) {
  url += i.toString(36).toUpperCase()
}

/**
 * Generate URL-friendly unique ID. This method use non-secure predictable
 * random generator with bigger collision probability.
 *
 * @param {number} [size=21] The number of symbols in ID.
 *
 * @return {string} Random string.
 *
 * @example
 * const nanoid = require('nanoid/non-secure')
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 *
 * @name nonSecure
 * @function
 */
module.exports = function (size) {
  var id = ''
  i = size || 21
  // Compact alternative for `for (var i = 0; i < size; i++)`
  while (i--) {
    // `| 0` is compact and faster alternative for `Math.floor()`
    id += url[Math.random() * 64 | 0]
  }
  return id
}

      };
    };
  }
  }
}, {package:"nanoid",file:"node_modules\\nanoid\\non-secure\\index.js",}],
["F:\\metamask-extension\\node_modules\\no-case\\no-case.js", {"./vendor/camel-case-regexp":"F:\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-regexp.js","./vendor/camel-case-upper-regexp":"F:\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-upper-regexp.js","./vendor/non-word-regexp":"F:\\metamask-extension\\node_modules\\no-case\\vendor\\non-word-regexp.js","lower-case":"F:\\metamask-extension\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cno-case%5Cno-case.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

var NON_WORD_REGEXP = require('./vendor/non-word-regexp')
var CAMEL_CASE_REGEXP = require('./vendor/camel-case-regexp')
var CAMEL_CASE_UPPER_REGEXP = require('./vendor/camel-case-upper-regexp')

/**
 * Sentence case a string.
 *
 * @param  {string} str
 * @param  {string} locale
 * @param  {string} replacement
 * @return {string}
 */
module.exports = function (str, locale, replacement) {
  if (str == null) {
    return ''
  }

  replacement = typeof replacement !== 'string' ? ' ' : replacement

  function replace (match, index, value) {
    if (index === 0 || index === (value.length - match.length)) {
      return ''
    }

    return replacement
  }

  str = String(str)
    // Support camel case ("camelCase" -> "camel Case").
    .replace(CAMEL_CASE_REGEXP, '$1 $2')
    // Support odd camel case ("CAMELCase" -> "CAMEL Case").
    .replace(CAMEL_CASE_UPPER_REGEXP, '$1 $2')
    // Remove all non-word characters and replace with a single space.
    .replace(NON_WORD_REGEXP, replace)

  // Lower case the entire string.
  return lowerCase(str, locale)
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\no-case.js",}],
["F:\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-regexp.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cno-case%5Cvendor%5Ccamel-case-regexp.js
      return function (require, module, exports) {
module.exports = /([a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])/g

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\vendor\\camel-case-regexp.js",}],
["F:\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-upper-regexp.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cno-case%5Cvendor%5Ccamel-case-upper-regexp.js
      return function (require, module, exports) {
module.exports = /([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A][a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])/g

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\vendor\\camel-case-upper-regexp.js",}],
["F:\\metamask-extension\\node_modules\\no-case\\vendor\\non-word-regexp.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cno-case%5Cvendor%5Cnon-word-regexp.js
      return function (require, module, exports) {
module.exports = /[^A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",file:"node_modules\\no-case\\vendor\\non-word-regexp.js",}],
["F:\\metamask-extension\\node_modules\\node-interval-tree\\lib\\index.js", {"shallowequal":"F:\\metamask-extension\\node_modules\\shallowequal\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cnode-interval-tree%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = require("shallowequal");
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>node-interval-tree",file:"node_modules\\node-interval-tree\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\nofilter\\lib\\index.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","stream":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js","util":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cnofilter%5Clib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const stream = require('stream')
const util = require('util')

/**
 * NoFilter stream.  Can be used to sink or source data to and from
 * other node streams.  Implemented as the "identity" Transform stream
 * (hence the name), but allows for inspecting data that is in-flight.
 *
 * Allows passing in source data (input, inputEncoding) at creation
 * time.  Source data can also be passed in the options object.
 *
 * @example <caption>source</caption>
 * const n = new NoFilter('Zm9v', 'base64');
 * n.pipe(process.stdout);
 *
 * @example <caption>sink</caption>
 * const n = new Nofilter();
 * // NOTE: 'finish' fires when the input is done writing
 * n.on('finish', function() { console.log(n.toString('base64')); });
 * process.stdin.pipe(n);
 */
class NoFilter extends stream.Transform {
  /**
   * Create an instance of NoFilter.
   *
   * @param {string|Buffer} [input] - Source data
   * @param {string} [inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {Object} [options={}] - Other options
   * @param {string|Buffer} [options.input=null] - Input source data
   * @param {string} [options.inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes
   *   to store in the internal buffer before ceasing to read from the
   *   underlying resource. Default=16kb, or 16 for objectMode streams
   * @param {string} [options.encoding=null] - If specified, then buffers will
   *   be decoded to strings using the specified encoding
   * @param {boolean} [options.objectMode=false] - Whether this stream should
   *   behave as a stream of objects. Meaning that stream.read(n) returns a
   *   single value instead of a Buffer of size n
   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode
   *   strings into Buffers before passing them to _write()
   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'
   *   events, setting this stream's objectMode based on the objectMode of the
   *   input stream
   * @param {boolean} [options.readError=false] - If true, when a read()
   *   underflows, throw an error.
   */
  constructor(input, inputEncoding, options) {
    if (options == null) {
      options = {}
    }
    let inp
    let inpE
    switch (typeof(input)) {
      case 'object':
        if (Buffer.isBuffer(input)) {
          inp = input
          if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
            options = inputEncoding
          }
        } else {
          options = input
        }
        break
      case 'string':
        inp = input
        if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
          options = inputEncoding
        } else {
          inpE = inputEncoding
        }
        break
    }

    if ((options == null)) {
      options = {}
    }
    if (inp == null) {
      inp = options.input
    }
    if (inpE == null) {
      inpE = options.inputEncoding
    }
    delete options.input
    delete options.inputEncoding
    const watchPipe = options.watchPipe != null ? options.watchPipe : true
    delete options.watchPipe
    const readError = !! options.readError
    delete options.readError
    super(options)

    this.readError = readError

    if (watchPipe) {
      this.on('pipe', readable => {
        const om = readable._readableState.objectMode
        if ((this.length > 0) && (om !== this._readableState.objectMode)) {
          throw new Error(
            'Do not switch objectMode in the middle of the stream')
        }

        this._readableState.objectMode = om
        return this._writableState.objectMode = om
      })
    }

    if (inp != null) {
      this.end(inp, inpE)
    }
  }

  /**
   * Is the given object a {NoFilter}?
   *
   * @param {Object} obj The object to test.
   * @returns {boolean} true if obj is a NoFilter
   */
  static isNoFilter(obj) {
    return obj instanceof this
  }

  /**
   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
   *
   * @param {NoFilter} nf1 - The first object to compare
   * @param {NoFilter} nf2 - The second object to compare
   * @returns {number} -1, 0, 1 for less, equal, greater
   *
   * @example
   * const arr = [new NoFilter('1234'), new NoFilter('0123')];
   * arr.sort(NoFilter.compare);
   */
  static compare(nf1, nf2) {
    if (!(nf1 instanceof this)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (nf1 === nf2) {
      return 0
    } else {
      return nf1.compare(nf2)
    }
  }

  /**
   * Returns a buffer which is the result of concatenating all the
   * NoFilters in the list together. If the list has no items, or if
   * the totalLength is 0, then it returns a zero-length buffer.
   *
   * If length is not provided, it is read from the buffers in the
   * list. However, this adds an additional loop to the function, so
   * it is faster to provide the length explicitly if you already know it.
   *
   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
   *   mode, or all not in object mode.
   * @param {number} [length=null] Number of bytes or objects to read
   * @returns {Buffer|Array} The concatenated values as an array if in object
   *   mode, otherwise a Buffer
   */
  static concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('list argument must be an Array of NoFilters')
    }
    if ((list.length === 0) || (length === 0)) {
      return Buffer.alloc(0)
    }
    if ((length == null)) {
      length = list.reduce((tot, nf) => {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError('list argument must be an Array of NoFilters')
        }
        return tot + nf.length
      }, 0)
    }
    let allBufs = true
    let allObjs = true
    const bufs = list.map(nf => {
      if (!(nf instanceof NoFilter)) {
        throw new TypeError('list argument must be an Array of NoFilters')
      }
      const buf = nf.slice()
      if (Buffer.isBuffer(buf)) {
        allObjs = false
      } else {
        allBufs = false
      }
      return buf
    })
    if (allBufs) {
      return Buffer.concat(bufs, length)
    }
    if (allObjs) {
      return [].concat(...bufs).slice(0, length)
    }
    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays
    // counting objects?  I can't imagine why that would be useful.
    throw new Error('Concatenating mixed object and byte streams not supported')
  }

  /**
   * @private
   */
  _transform(chunk, encoding, callback) {
    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, encoding)
    }
    this.push(chunk)
    callback()
  }

  /**
   * @private
   */
  _bufArray() {
    let bufs = this._readableState.buffer
    // HACK: replace with something else one day.  This is what I get for
    // relying on internals.
    if (!Array.isArray(bufs)) {
      let b = bufs.head
      bufs = []
      while (b != null) {
        bufs.push(b.data)
        b = b.next
      }
    }
    return bufs
  }

  /**
   * Pulls some data out of the internal buffer and returns it.
   * If there is no data available, then it will return null.
   *
   * If you pass in a size argument, then it will return that many bytes. If
   * size bytes are not available, then it will return null, unless we've
   * ended, in which case it will return the data remaining in the buffer.
   *
   * If you do not specify a size argument, then it will return all the data in
   * the internal buffer.
   *
   * @param {number} [size=null] - Number of bytes to read.
   * @returns {string|Buffer|null} If no data or not enough data, null.  If
   *   decoding output a string, otherwise a Buffer
   * @throws Error - if readError is true and there was underflow
   * @fires NoFilter#read
   */
  read(size) {
    const buf = super.read(size)
    if (buf != null) {
      /*
       * Read event. Fired whenever anything is read from the stream.
       *
       * @event NoFilter#read
       * @type {Buffer|string|Object}
       *
       */
      this.emit('read', buf)
      if (this.readError && (buf.length < size)) {
        throw new Error(`Read ${buf.length}, wanted ${size}`)
      }
    } else if (this.readError) {
      throw new Error(`No data available, wanted ${size}`)
    }
    return buf
  }

  /**
   * Return a promise fulfilled with the full contents, after the 'finish'
   * event fires.  Errors on the stream cause the promise to be rejected.
   *
   * @param {function} [cb=null] - finished/error callback used in *addition*
   *   to the promise
   * @returns {Promise<Buffer|String>} fulfilled when complete
   */
  promise(cb) {
    let done = false
    return new Promise((resolve, reject) => {
      this.on('finish', () => {
        const data = this.read()
        if ((cb != null) && !done) {
          done = true
          cb(null, data)
        }
        resolve(data)
      })
      this.on('error', (er) => {
        if ((cb != null) && !done) {
          done = true
          cb(er)
        }
        reject(er)
      })
    })
  }

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other NoFilter in sort order.
   *
   * @param {NoFilter} other - The other object to compare
   * @returns {Number} -1, 0, 1 for less, equal, greater
   */
  compare(other) {
    if (!(other instanceof NoFilter)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (this === other) {
      return 0
    } else {
      const buf1 = this.slice()
      const buf2 = other.slice()
      // these will both be buffers because of the check above.
      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
        return buf1.compare(buf2)
      }
      throw new Error('Cannot compare streams in object mode')
    }
  }

  /**
   * Do these NoFilter's contain the same bytes?  Doesn't work if either is
   * in object mode.
   *
   * @param {NoFilter} other
   * @returns {boolean} Equal?
   */
  equals(other) {
    return this.compare(other) === 0
  }

  /**
   * Read bytes or objects without consuming them.  Useful for diagnostics.
   * Note: as a side-effect, concatenates multiple writes together into what
   * looks like a single write, so that this concat doesn't have to happen
   * multiple times when you're futzing with the same NoFilter.
   *
   * @param {Number} [start=0] - beginning offset
   * @param {Number} [end=length] - ending offset
   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,
   *   concatenated array of contents.
   */
  slice(start, end) {
    if (this._readableState.objectMode) {
      return this._bufArray().slice(start, end)
    }
    const bufs = this._bufArray()
    switch (bufs.length) {
      case 0: return Buffer.alloc(0)
      case 1: return bufs[0].slice(start, end)
      default:
        const b = Buffer.concat(bufs)
        // TODO: store the concatented bufs back
        // @_readableState.buffer = [b]
        return b.slice(start, end)
    }
  }

  /**
    * Get a byte by offset.  I didn't want to get into metaprogramming
    * to give you the `NoFilter[0]` syntax.
    *
    * @param {Number} index - The byte to retrieve
    * @returns {Number} 0-255
    */
  get(index) {
    return this.slice()[index]
  }

  /**
   * Return an object compatible with Buffer's toJSON implementation, so
   * that round-tripping will produce a Buffer.
   *
   * @returns {Object}
   *
   * @example output for 'foo'
   *   { type: 'Buffer', data: [ 102, 111, 111 ] }
   */
  toJSON() {
    const b = this.slice()
    if (Buffer.isBuffer(b)) {
      return b.toJSON()
    } else {
      return b
    }
  }

  /**
   * Decodes and returns a string from buffer data encoded using the specified
   * character set encoding. If encoding is undefined or null, then encoding
   * defaults to 'utf8'. The start and end parameters default to 0 and
   * NoFilter.length when undefined.
   *
   * @param {String} [encoding='utf8'] - Which to use for decoding?
   * @param {Number} [start=0] - Start offset
   * @param {Number} [end=length] - End offset
   * @returns {String}
   */
  toString(encoding, start, end) {
    const buf = this.slice(start, end)
    if (!Buffer.isBuffer(buf)) {
      return JSON.stringify(buf)
    }
    if ((!encoding || (encoding === 'utf8')) && util.TextDecoder) {
      const td = new util.TextDecoder('utf8', {
        fatal: true,
        ignoreBOM: true
      })
      return td.decode(buf)
    }
    return buf.toString(encoding, start, end)
  }

  /**
   * @private
   * @deprecated
   */
  inspect(depth, options) {
    return this[util.inspect.custom](depth, options)
  }

  /**
   * @private
   */
  [util.inspect.custom](depth, options) {
    const bufs = this._bufArray()
    const hex = bufs.map((b) => {
      if (Buffer.isBuffer(b)) {
        if ((options != null ? options.stylize : undefined)) {
          return options.stylize(b.toString('hex'), 'string')
        } else {
          return b.toString('hex')
        }
      } else {
        return util.inspect(b, options)
      }
    }).join(', ')
    return `${this.constructor.name} [${hex}]`
  }

  /**
   * Current readable length, in bytes.
   *
   * @member {number}
   * @readonly
   */
  get length() {
    return this._readableState.length
  }

  /**
   * Write a JavaScript BigInt to the stream.  Negative numbers will be
   * written as their 2's complement version.
   *
   * @param {bigint} val - The value to write
   * @returns {boolean} true on success
   */
  writeBigInt(val) {
    let str = val.toString(16)
    if (val < 0) {
      // two's complement
      // Note: str always starts with '-' here.
      const sz = BigInt(Math.floor(str.length / 2))
      const mask = BigInt(1) << (sz * BigInt(8))
      val = mask + val
      str = val.toString(16)
    }
    if (str.length % 2) {
      str = '0' + str
    }
    return this.push(Buffer.from(str, 'hex'))
  }

  /**
   * Read a variable-sized JavaScript unsigned BigInt from the stream.
   *
   * @param {number}  [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readUBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return BigInt('0x' + b.toString('hex'))
  }

  /**
   * Read a variable-sized JavaScript signed BigInt from the stream in 2's
   * complement format.
   *
   * @param {number} [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    let ret = BigInt('0x' + b.toString('hex'))
    // negative?
    if (b[0] & 0x80) {
      // two's complement
      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))
      ret = ret - mask
    }
    return ret
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _read_gen(meth, len) {
  return function(val) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b[meth].call(b, 0, true)
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _write_gen(meth, len) {
  return function(val) {
    const b = Buffer.alloc(len)
    b[meth].call(b, val, 0, true)
    return this.push(b)
  }
}

Object.assign(NoFilter.prototype, {
  /**
   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
   *
   * @function writeUInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value - 0-255
   * @returns {boolean} true on success
   */
  writeUInt8: _write_gen('writeUInt8', 1),

  /**
   * Write a little-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16LE: _write_gen('writeUInt16LE', 2),

  /**
   * Write a big-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16BE: _write_gen('writeUInt16BE', 2),

  /**
   * Write a little-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32LE: _write_gen('writeUInt32LE', 4),

  /**
   * Write a big-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32BE: _write_gen('writeUInt32BE', 4),

  /**
   * Write a signed 8-bit integer to the stream.  Adds 1 byte.
   *
   * @function writeInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt8: _write_gen('writeInt8', 1),

  /**
   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16LE: _write_gen('writeInt16LE', 2),

  /**
   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16BE: _write_gen('writeInt16BE', 2),

  /**
   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32LE: _write_gen('writeInt32LE', 4),

  /**
   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32BE: _write_gen('writeInt32BE', 4),

  /**
   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatLE: _write_gen('writeFloatLE', 4),

  /**
   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatBE: _write_gen('writeFloatBE', 4),

  /**
   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleLE: _write_gen('writeDoubleLE', 8),

  /**
   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleBE: _write_gen('writeDoubleBE', 8),

  /**
   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @function readUInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt8: _read_gen('readUInt8', 1),

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16LE: _read_gen('readUInt16LE', 2),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16BE: _read_gen('readUInt16BE', 2),

  /**
   * Read a little-endian unsigned 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32LE: _read_gen('readUInt32LE', 4),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32BE: _read_gen('readUInt32BE', 4),

  /**
   * Read a signed 8-bit integer from the stream.
   * Consumes 1 byte.
   *
   * @function readInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt8: _read_gen('readInt8', 1),

  /**
   * Read a signed 16-bit little-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16LE: _read_gen('readInt16LE', 2),

  /**
   * Read a signed 16-bit big-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16BE: _read_gen('readInt16BE', 2),

  /**
   * Read a signed 32-bit little-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32LE: _read_gen('readInt32LE', 4),

  /**
   * Read a signed 32-bit big-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32BE: _read_gen('readInt32BE', 4),

  /**
   * Read a 32-bit little-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatLE: _read_gen('readFloatLE', 4),

  /**
   * Read a 32-bit big-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatBE: _read_gen('readFloatBE', 4),

  /**
   * Read a 64-bit little-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleLE: _read_gen('readDoubleLE', 8),

  /**
   * Read a 64-bit big-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleBE: _read_gen('readDoubleBE', 8)
})

module.exports = NoFilter

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@truffle/codec>cbor>nofilter",file:"node_modules\\nofilter\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\object-is\\implementation.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobject-is%5Cimplementation.js
      return function (require, module, exports) {
'use strict';

var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};


      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\implementation.js",}],
["F:\\metamask-extension\\node_modules\\object-is\\index.js", {"./implementation":"F:\\metamask-extension\\node_modules\\object-is\\implementation.js","./polyfill":"F:\\metamask-extension\\node_modules\\object-is\\polyfill.js","./shim":"F:\\metamask-extension\\node_modules\\object-is\\shim.js","call-bind":"F:\\metamask-extension\\node_modules\\call-bind\\index.js","define-properties":"F:\\metamask-extension\\node_modules\\define-properties\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobject-is%5Cindex.js
      return function (require, module, exports) {
'use strict';

var define = require('define-properties');
var callBind = require('call-bind');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;

      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\index.js",}],
["F:\\metamask-extension\\node_modules\\object-is\\polyfill.js", {"./implementation":"F:\\metamask-extension\\node_modules\\object-is\\implementation.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobject-is%5Cpolyfill.js
      return function (require, module, exports) {
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};

      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\polyfill.js",}],
["F:\\metamask-extension\\node_modules\\object-is\\shim.js", {"./polyfill":"F:\\metamask-extension\\node_modules\\object-is\\polyfill.js","define-properties":"F:\\metamask-extension\\node_modules\\define-properties\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobject-is%5Cshim.js
      return function (require, module, exports) {
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};

      };
    };
  }
  }
}, {package:"@ngraveio/bc-ur>assert>object-is",file:"node_modules\\object-is\\shim.js",}],
["F:\\metamask-extension\\node_modules\\object-keys\\implementation.js", {"./isArguments":"F:\\metamask-extension\\node_modules\\object-keys\\isArguments.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobject-keys%5Cimplementation.js
      return function (require, module, exports) {
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

      };
    };
  }
  }
}, {package:"globalthis>define-properties>object-keys",file:"node_modules\\object-keys\\implementation.js",}],
["F:\\metamask-extension\\node_modules\\object-keys\\index.js", {"./implementation":"F:\\metamask-extension\\node_modules\\object-keys\\implementation.js","./isArguments":"F:\\metamask-extension\\node_modules\\object-keys\\isArguments.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobject-keys%5Cindex.js
      return function (require, module, exports) {
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

      };
    };
  }
  }
}, {package:"globalthis>define-properties>object-keys",file:"node_modules\\object-keys\\index.js",}],
["F:\\metamask-extension\\node_modules\\object-keys\\isArguments.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobject-keys%5CisArguments.js
      return function (require, module, exports) {
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

      };
    };
  }
  }
}, {package:"globalthis>define-properties>object-keys",file:"node_modules\\object-keys\\isArguments.js",}],
["F:\\metamask-extension\\node_modules\\os-browserify\\browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cos-browserify%5Cbrowser.js
      return function (require, module, exports) {
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

      };
    };
  }
  }
}, {package:"browserify>os-browserify",file:"node_modules\\os-browserify\\browser.js",}],
["F:\\metamask-extension\\node_modules\\param-case\\param-case.js", {"no-case":"F:\\metamask-extension\\node_modules\\no-case\\no-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cparam-case%5Cparam-case.js
      return function (require, module, exports) {
var noCase = require('no-case')

/**
 * Param case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-')
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>param-case",file:"node_modules\\param-case\\param-case.js",}],
["F:\\metamask-extension\\node_modules\\pascal-case\\pascal-case.js", {"camel-case":"F:\\metamask-extension\\node_modules\\camel-case\\camel-case.js","upper-case-first":"F:\\metamask-extension\\node_modules\\upper-case-first\\upper-case-first.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpascal-case%5Cpascal-case.js
      return function (require, module, exports) {
var camelCase = require('camel-case')
var upperCaseFirst = require('upper-case-first')

/**
 * Pascal case a string.
 *
 * @param  {string}  value
 * @param  {string}  [locale]
 * @param  {boolean} [mergeNumbers]
 * @return {string}
 */
module.exports = function (value, locale, mergeNumbers) {
  return upperCaseFirst(camelCase(value, locale, mergeNumbers), locale)
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>pascal-case",file:"node_modules\\pascal-case\\pascal-case.js",}],
["F:\\metamask-extension\\node_modules\\path-case\\path-case.js", {"no-case":"F:\\metamask-extension\\node_modules\\no-case\\no-case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpath-case%5Cpath-case.js
      return function (require, module, exports) {
var noCase = require('no-case')

/**
 * Path case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '/')
}

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>path-case",file:"node_modules\\path-case\\path-case.js",}],
["F:\\metamask-extension\\node_modules\\path-to-regexp\\index.js", {"isarray":"F:\\metamask-extension\\node_modules\\path-to-regexp\\node_modules\\isarray\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpath-to-regexp%5Cindex.js
      return function (require, module, exports) {
var isarray = require('isarray')

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

      };
    };
  }
  }
}, {package:"sinon>nise>path-to-regexp",file:"node_modules\\path-to-regexp\\index.js",}],
["F:\\metamask-extension\\node_modules\\path-to-regexp\\node_modules\\isarray\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpath-to-regexp%5Cnode_modules%5Cisarray%5Cindex.js
      return function (require, module, exports) {
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

      };
    };
  }
  }
}, {package:"sinon>nise>path-to-regexp>isarray",file:"node_modules\\path-to-regexp\\node_modules\\isarray\\index.js",}],
["F:\\metamask-extension\\node_modules\\popper.js\\dist\\umd\\popper.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpopper.js%5Cdist%5Cumd%5Cpopper.js
      return function (require, module, exports) {
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.15.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Popper = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

return Popper;

})));
//# sourceMappingURL=popper.js.map

      };
    };
  }
  }
}, {package:"react-tippy>popper.js",file:"node_modules\\popper.js\\dist\\umd\\popper.js",}],
["F:\\metamask-extension\\node_modules\\prop-types\\checkPropTypes.js", {"./lib/ReactPropTypesSecret":"F:\\metamask-extension\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js","./lib/has":"F:\\metamask-extension\\node_modules\\prop-types\\lib\\has.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprop-types%5CcheckPropTypes.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var printWarning = function() {};

if ("development" !== 'production') {
  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
  var loggedTypeFailures = {};
  var has = require('./lib/has');

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) { /**/ }
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if ("development" !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if ("development" !== 'production') {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\checkPropTypes.js",}],
["F:\\metamask-extension\\node_modules\\prop-types\\factoryWithThrowingShims.js", {"./lib/ReactPropTypesSecret":"F:\\metamask-extension\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprop-types%5CfactoryWithThrowingShims.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\factoryWithThrowingShims.js",}],
["F:\\metamask-extension\\node_modules\\prop-types\\factoryWithTypeCheckers.js", {"./checkPropTypes":"F:\\metamask-extension\\node_modules\\prop-types\\checkPropTypes.js","./lib/ReactPropTypesSecret":"F:\\metamask-extension\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js","./lib/has":"F:\\metamask-extension\\node_modules\\prop-types\\lib\\has.js","object-assign":"F:\\metamask-extension\\node_modules\\object-assign\\index.js","react-is":"F:\\metamask-extension\\node_modules\\react-is\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprop-types%5CfactoryWithTypeCheckers.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactIs = require('react-is');
var assign = require('object-assign');

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var has = require('./lib/has');
var checkPropTypes = require('./checkPropTypes');

var printWarning = function() {};

if ("development" !== 'production') {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if ("development" !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if ("development" !== 'production') {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      "development" !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\factoryWithTypeCheckers.js",}],
["F:\\metamask-extension\\node_modules\\prop-types\\index.js", {"./factoryWithThrowingShims":"F:\\metamask-extension\\node_modules\\prop-types\\factoryWithThrowingShims.js","./factoryWithTypeCheckers":"F:\\metamask-extension\\node_modules\\prop-types\\factoryWithTypeCheckers.js","react-is":"F:\\metamask-extension\\node_modules\\react-is\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprop-types%5Cindex.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if ("development" !== 'production') {
  var ReactIs = require('react-is');

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\index.js",}],
["F:\\metamask-extension\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprop-types%5Clib%5CReactPropTypesSecret.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\lib\\ReactPropTypesSecret.js",}],
["F:\\metamask-extension\\node_modules\\prop-types\\lib\\has.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprop-types%5Clib%5Chas.js
      return function (require, module, exports) {
module.exports = Function.call.bind(Object.prototype.hasOwnProperty);

      };
    };
  }
  }
}, {package:"prop-types",file:"node_modules\\prop-types\\lib\\has.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js", {"./UnsafeUniformArrayIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUniformArrayIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformArrayIntDistribution = void 0;
var UnsafeUniformArrayIntDistribution_1 = require("./UnsafeUniformArrayIntDistribution");
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformArrayIntDistribution = uniformArrayIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js", {"./UnsafeUniformBigIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUniformBigIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformBigIntDistribution = void 0;
var UnsafeUniformBigIntDistribution_1 = require("./UnsafeUniformBigIntDistribution");
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformBigIntDistribution = uniformBigIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js", {"./UnsafeUniformIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUniformIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformIntDistribution = void 0;
var UnsafeUniformIntDistribution_1 = require("./UnsafeUniformIntDistribution");
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformIntDistribution = uniformIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js", {"./internals/ArrayInt":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js","./internals/UnsafeUniformArrayIntDistributionInternal":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUnsafeUniformArrayIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformArrayIntDistribution = void 0;
var ArrayInt_1 = require("./internals/ArrayInt");
var UnsafeUniformArrayIntDistributionInternal_1 = require("./internals/UnsafeUniformArrayIntDistributionInternal");
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = (0, ArrayInt_1.trimArrayIntInplace)((0, ArrayInt_1.addOneToPositiveArrayInt)((0, ArrayInt_1.substractArrayIntToNew)(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = (0, UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal)(emptyArrayIntData, rangeSize.data, rng);
    return (0, ArrayInt_1.trimArrayIntInplace)((0, ArrayInt_1.addArrayIntToNew)({ sign: 1, data: g }, from));
}
exports.unsafeUniformArrayIntDistribution = unsafeUniformArrayIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUnsafeUniformBigIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformBigIntDistribution = void 0;
var SBigInt = typeof BigInt !== 'undefined' ? BigInt : undefined;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + SBigInt(1);
    var MinRng = SBigInt(rng.min());
    var NumValues = SBigInt(rng.max() - rng.min() + 1);
    var FinalNumValues = NumValues;
    var NumIterations = SBigInt(1);
    while (FinalNumValues < diff) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);
    while (true) {
        var value = SBigInt(0);
        for (var num = SBigInt(0); num !== NumIterations; ++num) {
            var out = rng.unsafeNext();
            value = NumValues * value + (SBigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}
exports.unsafeUniformBigIntDistribution = unsafeUniformBigIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js", {"./internals/ArrayInt":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js","./internals/UnsafeUniformArrayIntDistributionInternal":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js","./internals/UnsafeUniformIntDistributionInternal":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5CUnsafeUniformIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistribution = void 0;
var UnsafeUniformIntDistributionInternal_1 = require("./internals/UnsafeUniformIntDistributionInternal");
var ArrayInt_1 = require("./internals/ArrayInt");
var UnsafeUniformArrayIntDistributionInternal_1 = require("./internals/UnsafeUniformArrayIntDistributionInternal");
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger
        ? (0, ArrayInt_1.fromNumberToArrayInt64)(sharedC, rangeSize)
        : (0, ArrayInt_1.substractArrayInt64)(sharedC, (0, ArrayInt_1.fromNumberToArrayInt64)(sharedA, to), (0, ArrayInt_1.fromNumberToArrayInt64)(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    }
    else {
        rangeSizeArrayIntValue.data[1] += 1;
    }
    (0, UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal)(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = (0, UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal)(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}
exports.unsafeUniformIntDistribution = unsafeUniformIntDistribution;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5Cinternals%5CArrayInt.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.substractArrayInt64 = exports.fromNumberToArrayInt64 = exports.trimArrayIntInplace = exports.substractArrayIntToNew = exports.addOneToPositiveArrayInt = exports.addArrayIntToNew = void 0;
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) {
        data.push(reminder);
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.addArrayIntToNew = addArrayIntToNew;
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for (var index = data.length - 1; index >= 0; --index) {
        if (data[index] === 0xffffffff) {
            data[index] = 0;
        }
        else {
            data[index] += 1;
            return arrayInt;
        }
    }
    data.unshift(1);
    return arrayInt;
}
exports.addOneToPositiveArrayInt = addOneToPositiveArrayInt;
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for (var index = 0; index < maxLength; ++index) {
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB)
            return true;
        if (vA > vB)
            return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.substractArrayIntToNew = substractArrayIntToNew;
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) { }
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [0];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
exports.trimArrayIntInplace = trimArrayIntInplace;
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    }
    else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
exports.fromNumberToArrayInt64 = fromNumberToArrayInt64;
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}
exports.substractArrayInt64 = substractArrayInt64;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js", {"./UnsafeUniformIntDistributionInternal":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5Cinternals%5CUnsafeUniformArrayIntDistributionInternal.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformArrayIntDistributionInternal = void 0;
var UnsafeUniformIntDistributionInternal_1 = require("./UnsafeUniformIntDistributionInternal");
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while (true) {
        for (var index = 0; index !== rangeLength; ++index) {
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = (0, UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal)(indexRangeSize, rng);
            out[index] = g;
        }
        for (var index = 0; index !== rangeLength; ++index) {
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) {
                return out;
            }
            else if (current > currentInRange) {
                break;
            }
        }
    }
}
exports.unsafeUniformArrayIntDistributionInternal = unsafeUniformArrayIntDistributionInternal;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cdistribution%5Cinternals%5CUnsafeUniformIntDistributionInternal.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistributionInternal = void 0;
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MinRng = rng.min();
    var NumValues = rng.max() - rng.min() + 1;
    if (rangeSize <= NumValues) {
        var nrng_1 = rng;
        var MaxAllowed = NumValues - (NumValues % rangeSize);
        while (true) {
            var out = nrng_1.unsafeNext();
            var deltaV = out - MinRng;
            if (deltaV < MaxAllowed) {
                return deltaV % rangeSize;
            }
        }
    }
    var FinalNumValues = NumValues * NumValues;
    var NumIterations = 2;
    while (FinalNumValues < rangeSize) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = rangeSize * Math.floor((1 * FinalNumValues) / rangeSize);
    var nrng = rng;
    while (true) {
        var value = 0;
        for (var num = 0; num !== NumIterations; ++num) {
            var out = nrng.unsafeNext();
            value = NumValues * value + (out - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value - rangeSize * Math.floor((1 * value) / rangeSize);
            return inDiff;
        }
    }
}
exports.unsafeUniformIntDistributionInternal = unsafeUniformIntDistributionInternal;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CLinearCongruential.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.congruential32 = exports.congruential = void 0;
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function (seed) {
    return (seed * MULTIPLIER + INCREMENT) & MASK;
};
var computeValueFromNextSeed = function (nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential = (function () {
    function LinearCongruential(seed) {
        this.seed = seed;
    }
    LinearCongruential.prototype.min = function () {
        return LinearCongruential.min;
    };
    LinearCongruential.prototype.max = function () {
        return LinearCongruential.max;
    };
    LinearCongruential.prototype.clone = function () {
        return new LinearCongruential(this.seed);
    };
    LinearCongruential.prototype.next = function () {
        var nextRng = new LinearCongruential(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential.prototype.unsafeNext = function () {
        this.seed = computeNextSeed(this.seed);
        return computeValueFromNextSeed(this.seed);
    };
    LinearCongruential.min = 0;
    LinearCongruential.max = Math.pow(2, 15) - 1;
    return LinearCongruential;
}());
var LinearCongruential32 = (function () {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.min = function () {
        return LinearCongruential32.min;
    };
    LinearCongruential32.prototype.max = function () {
        return LinearCongruential32.max;
    };
    LinearCongruential32.prototype.clone = function () {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function () {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential32.prototype.unsafeNext = function () {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + ((v2 + (v1 << 15)) << 15);
        return ((vnext + 0x80000000) | 0) + 0x80000000;
    };
    LinearCongruential32.min = 0;
    LinearCongruential32.max = 0xffffffff;
    return LinearCongruential32;
}());
var congruential = function (seed) {
    return new LinearCongruential(seed);
};
exports.congruential = congruential;
var congruential32 = function (seed) {
    return new LinearCongruential32(seed);
};
exports.congruential32 = congruential32;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CMersenneTwister.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
var MersenneTwister = (function () {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function (prev) {
        var mt = prev.slice();
        for (var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx) {
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ (y_1 >>> 1) ^ (-(y_1 & 1) & MersenneTwister.A);
        }
        for (var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx) {
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ (y_2 >>> 1) ^ (-(y_2 & 1) & MersenneTwister.A);
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ (y >>> 1) ^ (-(y & 1) & MersenneTwister.A);
        return mt;
    };
    MersenneTwister.seeded = function (seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for (var idx = 1; idx !== MersenneTwister.N; ++idx) {
            var xored = out[idx - 1] ^ (out[idx - 1] >>> 30);
            out[idx] = (Math.imul(MersenneTwister.F, xored) + idx) | 0;
        }
        return out;
    };
    MersenneTwister.from = function (seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.min = function () {
        return MersenneTwister.min;
    };
    MersenneTwister.prototype.max = function () {
        return MersenneTwister.max;
    };
    MersenneTwister.prototype.clone = function () {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function () {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    MersenneTwister.prototype.unsafeNext = function () {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= (y << MersenneTwister.S) & MersenneTwister.B;
        y ^= (y << MersenneTwister.T) & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y >>> 0;
    };
    MersenneTwister.min = 0;
    MersenneTwister.max = 0xffffffff;
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}());
function default_1(seed) {
    return MersenneTwister.from(seed);
}
exports["default"] = default_1;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CRandomGenerator.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.skipN = exports.unsafeSkipN = exports.generateN = exports.unsafeGenerateN = void 0;
function unsafeGenerateN(rng, num) {
    var out = [];
    for (var idx = 0; idx != num; ++idx) {
        out.push(rng.unsafeNext());
    }
    return out;
}
exports.unsafeGenerateN = unsafeGenerateN;
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [out, nextRng];
}
exports.generateN = generateN;
function unsafeSkipN(rng, num) {
    for (var idx = 0; idx != num; ++idx) {
        rng.unsafeNext();
    }
}
exports.unsafeSkipN = unsafeSkipN;
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}
exports.skipN = skipN;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XorShift.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CXorShift.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.xorshift128plus = void 0;
var XorShift128Plus = (function () {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XorShift128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XorShift128Plus.prototype.clone = function () {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XorShift128Plus.prototype.unsafeNext = function () {
        var a0 = this.s00 ^ (this.s00 << 23);
        var a1 = this.s01 ^ ((this.s01 << 23) | (this.s00 >>> 9));
        var b0 = a0 ^ this.s10 ^ ((a0 >>> 18) | (a1 << 14)) ^ ((this.s10 >>> 5) | (this.s11 << 27));
        var b1 = a1 ^ this.s11 ^ (a1 >>> 18) ^ (this.s11 >>> 5);
        var out = (this.s00 + this.s10) | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0x635d2dff, 0x8a5cd789, 0x5c472f96, 0x121fd215];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XorShift128Plus;
}());
var xorshift128plus = function (seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
};
exports.xorshift128plus = xorshift128plus;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\XorShift.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XoroShiro.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cgenerator%5CXoroShiro.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.xoroshiro128plus = void 0;
var XoroShiro128Plus = (function () {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XoroShiro128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XoroShiro128Plus.prototype.clone = function () {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XoroShiro128Plus.prototype.unsafeNext = function () {
        var out = (this.s00 + this.s10) | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);
        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));
        this.s10 = (a1 << 5) ^ (a0 >>> 27);
        this.s11 = (a0 << 5) ^ (a1 >>> 27);
        return out;
    };
    XoroShiro128Plus.prototype.jump = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XoroShiro128Plus;
}());
var xoroshiro128plus = function (seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
};
exports.xoroshiro128plus = xoroshiro128plus;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\generator\\XoroShiro.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand-default.js", {"./distribution/UniformArrayIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js","./distribution/UniformBigIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js","./distribution/UniformIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js","./distribution/UnsafeUniformArrayIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js","./distribution/UnsafeUniformBigIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js","./distribution/UnsafeUniformIntDistribution":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js","./generator/LinearCongruential":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js","./generator/MersenneTwister":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js","./generator/RandomGenerator":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js","./generator/XorShift":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XorShift.js","./generator/XoroShiro":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XoroShiro.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cpure-rand-default.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistribution = exports.unsafeUniformBigIntDistribution = exports.unsafeUniformArrayIntDistribution = exports.uniformIntDistribution = exports.uniformBigIntDistribution = exports.uniformArrayIntDistribution = exports.xoroshiro128plus = exports.xorshift128plus = exports.mersenne = exports.congruential32 = exports.congruential = exports.unsafeSkipN = exports.unsafeGenerateN = exports.skipN = exports.generateN = exports.__commitHash = exports.__version = exports.__type = void 0;
var RandomGenerator_1 = require("./generator/RandomGenerator");
exports.generateN = RandomGenerator_1.generateN;
exports.skipN = RandomGenerator_1.skipN;
exports.unsafeGenerateN = RandomGenerator_1.unsafeGenerateN;
exports.unsafeSkipN = RandomGenerator_1.unsafeSkipN;
var LinearCongruential_1 = require("./generator/LinearCongruential");
exports.congruential = LinearCongruential_1.congruential;
exports.congruential32 = LinearCongruential_1.congruential32;
var MersenneTwister_1 = require("./generator/MersenneTwister");
exports.mersenne = MersenneTwister_1["default"];
var XorShift_1 = require("./generator/XorShift");
exports.xorshift128plus = XorShift_1.xorshift128plus;
var XoroShiro_1 = require("./generator/XoroShiro");
exports.xoroshiro128plus = XoroShiro_1.xoroshiro128plus;
var UniformArrayIntDistribution_1 = require("./distribution/UniformArrayIntDistribution");
exports.uniformArrayIntDistribution = UniformArrayIntDistribution_1.uniformArrayIntDistribution;
var UniformBigIntDistribution_1 = require("./distribution/UniformBigIntDistribution");
exports.uniformBigIntDistribution = UniformBigIntDistribution_1.uniformBigIntDistribution;
var UniformIntDistribution_1 = require("./distribution/UniformIntDistribution");
exports.uniformIntDistribution = UniformIntDistribution_1.uniformIntDistribution;
var UnsafeUniformArrayIntDistribution_1 = require("./distribution/UnsafeUniformArrayIntDistribution");
exports.unsafeUniformArrayIntDistribution = UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution;
var UnsafeUniformBigIntDistribution_1 = require("./distribution/UnsafeUniformBigIntDistribution");
exports.unsafeUniformBigIntDistribution = UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution;
var UnsafeUniformIntDistribution_1 = require("./distribution/UnsafeUniformIntDistribution");
exports.unsafeUniformIntDistribution = UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution;
var __type = 'commonjs';
exports.__type = __type;
var __version = '5.0.5';
exports.__version = __version;
var __commitHash = '8b812d9651b4a18e9115aa13d84fe1b5eb9b068d';
exports.__commitHash = __commitHash;

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\pure-rand-default.js",}],
["F:\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand.js", {"./pure-rand-default":"F:\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand-default.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpure-rand%5Clib%5Cpure-rand.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
exports.__esModule = true;
var prand = require("./pure-rand-default");
exports["default"] = prand;
__exportStar(require("./pure-rand-default"), exports);

      };
    };
  }
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",file:"node_modules\\pure-rand\\lib\\pure-rand.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\8BitByte.js", {"./mode":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\mode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5C8BitByte.js
      return function (require, module, exports) {
var mode = require('./mode');

function QR8bitByte(data) {
	this.mode = mode.MODE_8BIT_BYTE;
	this.data = data;
}

QR8bitByte.prototype = {

	getLength : function(buffer) {
		return this.data.length;
	},
	
	write : function(buffer) {
		for (var i = 0; i < this.data.length; i++) {
			// not JIS ...
			buffer.put(this.data.charCodeAt(i), 8);
		}
	}
};

module.exports = QR8bitByte;


      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\8BitByte.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\BitBuffer.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5CBitBuffer.js
      return function (require, module, exports) {
function QRBitBuffer() {
	this.buffer = new Array();
	this.length = 0;
}

QRBitBuffer.prototype = {

	get : function(index) {
		var bufIndex = Math.floor(index / 8);
		return ( (this.buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
	},
	
	put : function(num, length) {
		for (var i = 0; i < length; i++) {
			this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
		}
	},
	
	getLengthInBits : function() {
		return this.length;
	},
	
	putBit : function(bit) {
	
		var bufIndex = Math.floor(this.length / 8);
		if (this.buffer.length <= bufIndex) {
			this.buffer.push(0);
		}
	
		if (bit) {
			this.buffer[bufIndex] |= (0x80 >>> (this.length % 8) );
		}
	
		this.length++;
	}
};

module.exports = QRBitBuffer;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\BitBuffer.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5CErrorCorrectLevel.js
      return function (require, module, exports) {
module.exports = {
	L : 1,
	M : 0,
	Q : 3,
	H : 2
};


      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\ErrorCorrectLevel.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\Polynomial.js", {"./math":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\math.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5CPolynomial.js
      return function (require, module, exports) {
var math = require('./math');

function QRPolynomial(num, shift) {

	if (num.length == undefined) {
		throw new Error(num.length + "/" + shift);
	}

	var offset = 0;

	while (offset < num.length && num[offset] == 0) {
		offset++;
	}

	this.num = new Array(num.length - offset + shift);
	for (var i = 0; i < num.length - offset; i++) {
		this.num[i] = num[i + offset];
	}
}

QRPolynomial.prototype = {

	get : function(index) {
		return this.num[index];
	},
	
	getLength : function() {
		return this.num.length;
	},
	
	multiply : function(e) {
	
		var num = new Array(this.getLength() + e.getLength() - 1);
	
		for (var i = 0; i < this.getLength(); i++) {
			for (var j = 0; j < e.getLength(); j++) {
				num[i + j] ^= math.gexp(math.glog(this.get(i) ) + math.glog(e.get(j) ) );
			}
		}
	
		return new QRPolynomial(num, 0);
	},
	
	mod : function(e) {
	
		if (this.getLength() - e.getLength() < 0) {
			return this;
		}
	
		var ratio = math.glog(this.get(0) ) - math.glog(e.get(0) );
	
		var num = new Array(this.getLength() );
		
		for (var i = 0; i < this.getLength(); i++) {
			num[i] = this.get(i);
		}
		
		for (var i = 0; i < e.getLength(); i++) {
			num[i] ^= math.gexp(math.glog(e.get(i) ) + ratio);
		}
	
		// recursive call
		return new QRPolynomial(num, 0).mod(e);
	}
};

module.exports = QRPolynomial;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\Polynomial.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\QRCode.js", {"./8BitByte":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\8BitByte.js","./BitBuffer":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\BitBuffer.js","./Polynomial":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\Polynomial.js","./RSBlock":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\RSBlock.js","./util":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5CQRCode.js
      return function (require, module, exports) {
var BitByte = require('./8BitByte');
var RSBlock = require('./RSBlock');
var BitBuffer = require('./BitBuffer');
var util = require('./util');
var Polynomial = require('./Polynomial');

function QRCode(typeNumber, errorCorrectLevel) {
	this.typeNumber = typeNumber;
	this.errorCorrectLevel = errorCorrectLevel;
	this.modules = null;
	this.moduleCount = 0;
	this.dataCache = null;
	this.dataList = [];
}

// for client side minification
var proto = QRCode.prototype;

proto.addData = function(data) {
	var newData = new BitByte(data);
	this.dataList.push(newData);
	this.dataCache = null;
};

proto.isDark = function(row, col) {
	if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
		throw new Error(row + "," + col);
	}
	return this.modules[row][col];
};

proto.getModuleCount = function() {
	return this.moduleCount;
};

proto.make = function() {
	// Calculate automatically typeNumber if provided is < 1
	if (this.typeNumber < 1 ){
		var typeNumber = 1;
		for (typeNumber = 1; typeNumber < 40; typeNumber++) {
			var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);

			var buffer = new BitBuffer();
			var totalDataCount = 0;
			for (var i = 0; i < rsBlocks.length; i++) {
				totalDataCount += rsBlocks[i].dataCount;
			}

			for (var i = 0; i < this.dataList.length; i++) {
				var data = this.dataList[i];
				buffer.put(data.mode, 4);
				buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber) );
				data.write(buffer);
			}
			if (buffer.getLengthInBits() <= totalDataCount * 8)
				break;
		}
		this.typeNumber = typeNumber;
	}
	this.makeImpl(false, this.getBestMaskPattern() );
};

proto.makeImpl = function(test, maskPattern) {
	
	this.moduleCount = this.typeNumber * 4 + 17;
	this.modules = new Array(this.moduleCount);
	
	for (var row = 0; row < this.moduleCount; row++) {
		
		this.modules[row] = new Array(this.moduleCount);
		
		for (var col = 0; col < this.moduleCount; col++) {
			this.modules[row][col] = null;//(col + row) % 3;
		}
	}

	this.setupPositionProbePattern(0, 0);
	this.setupPositionProbePattern(this.moduleCount - 7, 0);
	this.setupPositionProbePattern(0, this.moduleCount - 7);
	this.setupPositionAdjustPattern();
	this.setupTimingPattern();
	this.setupTypeInfo(test, maskPattern);
	
	if (this.typeNumber >= 7) {
		this.setupTypeNumber(test);
	}

	if (this.dataCache == null) {
		this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
	}

	this.mapData(this.dataCache, maskPattern);
};

proto.setupPositionProbePattern = function(row, col)  {
	
	for (var r = -1; r <= 7; r++) {
		
		if (row + r <= -1 || this.moduleCount <= row + r) continue;
		
		for (var c = -1; c <= 7; c++) {
			
			if (col + c <= -1 || this.moduleCount <= col + c) continue;
			
			if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
					|| (0 <= c && c <= 6 && (r == 0 || r == 6) )
					|| (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
				this.modules[row + r][col + c] = true;
			} else {
				this.modules[row + r][col + c] = false;
			}
		}		
	}		
};

proto.getBestMaskPattern = function() {

	var minLostPoint = 0;
	var pattern = 0;

	for (var i = 0; i < 8; i++) {
		
		this.makeImpl(true, i);

		var lostPoint = util.getLostPoint(this);

		if (i == 0 || minLostPoint >  lostPoint) {
			minLostPoint = lostPoint;
			pattern = i;
		}
	}

	return pattern;
};

proto.createMovieClip = function(target_mc, instance_name, depth) {

	var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
	var cs = 1;

	this.make();

	for (var row = 0; row < this.modules.length; row++) {
		
		var y = row * cs;
		
		for (var col = 0; col < this.modules[row].length; col++) {

			var x = col * cs;
			var dark = this.modules[row][col];
		
			if (dark) {
				qr_mc.beginFill(0, 100);
				qr_mc.moveTo(x, y);
				qr_mc.lineTo(x + cs, y);
				qr_mc.lineTo(x + cs, y + cs);
				qr_mc.lineTo(x, y + cs);
				qr_mc.endFill();
			}
		}
	}
	
	return qr_mc;
};

proto.setupTimingPattern = function() {
	
	for (var r = 8; r < this.moduleCount - 8; r++) {
		if (this.modules[r][6] != null) {
			continue;
		}
		this.modules[r][6] = (r % 2 == 0);
	}

	for (var c = 8; c < this.moduleCount - 8; c++) {
		if (this.modules[6][c] != null) {
			continue;
		}
		this.modules[6][c] = (c % 2 == 0);
	}
};

proto.setupPositionAdjustPattern = function() {

	var pos = util.getPatternPosition(this.typeNumber);
	
	for (var i = 0; i < pos.length; i++) {
	
		for (var j = 0; j < pos.length; j++) {
		
			var row = pos[i];
			var col = pos[j];
			
			if (this.modules[row][col] != null) {
				continue;
			}
			
			for (var r = -2; r <= 2; r++) {
			
				for (var c = -2; c <= 2; c++) {
				
					if (r == -2 || r == 2 || c == -2 || c == 2
							|| (r == 0 && c == 0) ) {
						this.modules[row + r][col + c] = true;
					} else {
						this.modules[row + r][col + c] = false;
					}
				}
			}
		}
	}
};

proto.setupTypeNumber = function(test) {

	var bits = util.getBCHTypeNumber(this.typeNumber);

	for (var i = 0; i < 18; i++) {
		var mod = (!test && ( (bits >> i) & 1) == 1);
		this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
	}

	for (var i = 0; i < 18; i++) {
		var mod = (!test && ( (bits >> i) & 1) == 1);
		this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
	}
};

proto.setupTypeInfo = function(test, maskPattern) {

	var data = (this.errorCorrectLevel << 3) | maskPattern;
	var bits = util.getBCHTypeInfo(data);

	// vertical		
	for (var i = 0; i < 15; i++) {

		var mod = (!test && ( (bits >> i) & 1) == 1);

		if (i < 6) {
			this.modules[i][8] = mod;
		} else if (i < 8) {
			this.modules[i + 1][8] = mod;
		} else {
			this.modules[this.moduleCount - 15 + i][8] = mod;
		}
	}

	// horizontal
	for (var i = 0; i < 15; i++) {

		var mod = (!test && ( (bits >> i) & 1) == 1);
		
		if (i < 8) {
			this.modules[8][this.moduleCount - i - 1] = mod;
		} else if (i < 9) {
			this.modules[8][15 - i - 1 + 1] = mod;
		} else {
			this.modules[8][15 - i - 1] = mod;
		}
	}

	// fixed module
	this.modules[this.moduleCount - 8][8] = (!test);
};

proto.mapData = function(data, maskPattern) {
	
	var inc = -1;
	var row = this.moduleCount - 1;
	var bitIndex = 7;
	var byteIndex = 0;
	
	for (var col = this.moduleCount - 1; col > 0; col -= 2) {

		if (col == 6) col--;

		while (true) {

			for (var c = 0; c < 2; c++) {
				
				if (this.modules[row][col - c] == null) {
					
					var dark = false;

					if (byteIndex < data.length) {
						dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
					}

					var mask = util.getMask(maskPattern, row, col - c);

					if (mask) {
						dark = !dark;
					}
					
					this.modules[row][col - c] = dark;
					bitIndex--;

					if (bitIndex == -1) {
						byteIndex++;
						bitIndex = 7;
					}
				}
			}
							
			row += inc;

			if (row < 0 || this.moduleCount <= row) {
				row -= inc;
				inc = -inc;
				break;
			}
		}
	}
};

QRCode.PAD0 = 0xEC;
QRCode.PAD1 = 0x11;

QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
	
	var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
	
	var buffer = new BitBuffer();
	
	for (var i = 0; i < dataList.length; i++) {
		var data = dataList[i];
		buffer.put(data.mode, 4);
		buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber) );
		data.write(buffer);
	}

	// calc num max data.
	var totalDataCount = 0;
	for (var i = 0; i < rsBlocks.length; i++) {
		totalDataCount += rsBlocks[i].dataCount;
	}

	if (buffer.getLengthInBits() > totalDataCount * 8) {
		throw new Error("code length overflow. ("
			+ buffer.getLengthInBits()
			+ ">"
			+  totalDataCount * 8
			+ ")");
	}

	// end code
	if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
		buffer.put(0, 4);
	}

	// padding
	while (buffer.getLengthInBits() % 8 != 0) {
		buffer.putBit(false);
	}

	// padding
	while (true) {
		
		if (buffer.getLengthInBits() >= totalDataCount * 8) {
			break;
		}
		buffer.put(QRCode.PAD0, 8);
		
		if (buffer.getLengthInBits() >= totalDataCount * 8) {
			break;
		}
		buffer.put(QRCode.PAD1, 8);
	}

	return QRCode.createBytes(buffer, rsBlocks);
};

QRCode.createBytes = function(buffer, rsBlocks) {

	var offset = 0;
	
	var maxDcCount = 0;
	var maxEcCount = 0;
	
	var dcdata = new Array(rsBlocks.length);
	var ecdata = new Array(rsBlocks.length);
	
	for (var r = 0; r < rsBlocks.length; r++) {

		var dcCount = rsBlocks[r].dataCount;
		var ecCount = rsBlocks[r].totalCount - dcCount;

		maxDcCount = Math.max(maxDcCount, dcCount);
		maxEcCount = Math.max(maxEcCount, ecCount);
		
		dcdata[r] = new Array(dcCount);
		
		for (var i = 0; i < dcdata[r].length; i++) {
			dcdata[r][i] = 0xff & buffer.buffer[i + offset];
		}
		offset += dcCount;
		
		var rsPoly = util.getErrorCorrectPolynomial(ecCount);
		var rawPoly = new Polynomial(dcdata[r], rsPoly.getLength() - 1);

		var modPoly = rawPoly.mod(rsPoly);
		ecdata[r] = new Array(rsPoly.getLength() - 1);
		for (var i = 0; i < ecdata[r].length; i++) {
            var modIndex = i + modPoly.getLength() - ecdata[r].length;
			ecdata[r][i] = (modIndex >= 0)? modPoly.get(modIndex) : 0;
		}

	}
	
	var totalCodeCount = 0;
	for (var i = 0; i < rsBlocks.length; i++) {
		totalCodeCount += rsBlocks[i].totalCount;
	}

	var data = new Array(totalCodeCount);
	var index = 0;

	for (var i = 0; i < maxDcCount; i++) {
		for (var r = 0; r < rsBlocks.length; r++) {
			if (i < dcdata[r].length) {
				data[index++] = dcdata[r][i];
			}
		}
	}

	for (var i = 0; i < maxEcCount; i++) {
		for (var r = 0; r < rsBlocks.length; r++) {
			if (i < ecdata[r].length) {
				data[index++] = ecdata[r][i];
			}
		}
	}

	return data;
};

module.exports = QRCode;


      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\QRCode.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\RSBlock.js", {"./ErrorCorrectLevel":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5CRSBlock.js
      return function (require, module, exports) {
// ErrorCorrectLevel
var ECL = require('./ErrorCorrectLevel');

function QRRSBlock(totalCount, dataCount) {
	this.totalCount = totalCount;
	this.dataCount  = dataCount;
}

QRRSBlock.RS_BLOCK_TABLE = [

	// L
	// M
	// Q
	// H

	// 1
	[1, 26, 19],
	[1, 26, 16],
	[1, 26, 13],
	[1, 26, 9],
	
	// 2
	[1, 44, 34],
	[1, 44, 28],
	[1, 44, 22],
	[1, 44, 16],

	// 3
	[1, 70, 55],
	[1, 70, 44],
	[2, 35, 17],
	[2, 35, 13],

	// 4		
	[1, 100, 80],
	[2, 50, 32],
	[2, 50, 24],
	[4, 25, 9],
	
	// 5
	[1, 134, 108],
	[2, 67, 43],
	[2, 33, 15, 2, 34, 16],
	[2, 33, 11, 2, 34, 12],
	
	// 6
	[2, 86, 68],
	[4, 43, 27],
	[4, 43, 19],
	[4, 43, 15],
	
	// 7		
	[2, 98, 78],
	[4, 49, 31],
	[2, 32, 14, 4, 33, 15],
	[4, 39, 13, 1, 40, 14],
	
	// 8
	[2, 121, 97],
	[2, 60, 38, 2, 61, 39],
	[4, 40, 18, 2, 41, 19],
	[4, 40, 14, 2, 41, 15],
	
	// 9
	[2, 146, 116],
	[3, 58, 36, 2, 59, 37],
	[4, 36, 16, 4, 37, 17],
	[4, 36, 12, 4, 37, 13],
	
	// 10		
	[2, 86, 68, 2, 87, 69],
	[4, 69, 43, 1, 70, 44],
	[6, 43, 19, 2, 44, 20],
	[6, 43, 15, 2, 44, 16],

	// 11
	[4, 101, 81],
	[1, 80, 50, 4, 81, 51],
	[4, 50, 22, 4, 51, 23],
	[3, 36, 12, 8, 37, 13],

	// 12
	[2, 116, 92, 2, 117, 93],
	[6, 58, 36, 2, 59, 37],
	[4, 46, 20, 6, 47, 21],
	[7, 42, 14, 4, 43, 15],

	// 13
	[4, 133, 107],
	[8, 59, 37, 1, 60, 38],
	[8, 44, 20, 4, 45, 21],
	[12, 33, 11, 4, 34, 12],

	// 14
	[3, 145, 115, 1, 146, 116],
	[4, 64, 40, 5, 65, 41],
	[11, 36, 16, 5, 37, 17],
	[11, 36, 12, 5, 37, 13],

	// 15
	[5, 109, 87, 1, 110, 88],
	[5, 65, 41, 5, 66, 42],
	[5, 54, 24, 7, 55, 25],
	[11, 36, 12],

	// 16
	[5, 122, 98, 1, 123, 99],
	[7, 73, 45, 3, 74, 46],
	[15, 43, 19, 2, 44, 20],
	[3, 45, 15, 13, 46, 16],

	// 17
	[1, 135, 107, 5, 136, 108],
	[10, 74, 46, 1, 75, 47],
	[1, 50, 22, 15, 51, 23],
	[2, 42, 14, 17, 43, 15],

	// 18
	[5, 150, 120, 1, 151, 121],
	[9, 69, 43, 4, 70, 44],
	[17, 50, 22, 1, 51, 23],
	[2, 42, 14, 19, 43, 15],

	// 19
	[3, 141, 113, 4, 142, 114],
	[3, 70, 44, 11, 71, 45],
	[17, 47, 21, 4, 48, 22],
	[9, 39, 13, 16, 40, 14],

	// 20
	[3, 135, 107, 5, 136, 108],
	[3, 67, 41, 13, 68, 42],
	[15, 54, 24, 5, 55, 25],
	[15, 43, 15, 10, 44, 16],

	// 21
	[4, 144, 116, 4, 145, 117],
	[17, 68, 42],
	[17, 50, 22, 6, 51, 23],
	[19, 46, 16, 6, 47, 17],

	// 22
	[2, 139, 111, 7, 140, 112],
	[17, 74, 46],
	[7, 54, 24, 16, 55, 25],
	[34, 37, 13],

	// 23
	[4, 151, 121, 5, 152, 122],
	[4, 75, 47, 14, 76, 48],
	[11, 54, 24, 14, 55, 25],
	[16, 45, 15, 14, 46, 16],

	// 24
	[6, 147, 117, 4, 148, 118],
	[6, 73, 45, 14, 74, 46],
	[11, 54, 24, 16, 55, 25],
	[30, 46, 16, 2, 47, 17],

	// 25
	[8, 132, 106, 4, 133, 107],
	[8, 75, 47, 13, 76, 48],
	[7, 54, 24, 22, 55, 25],
	[22, 45, 15, 13, 46, 16],

	// 26
	[10, 142, 114, 2, 143, 115],
	[19, 74, 46, 4, 75, 47],
	[28, 50, 22, 6, 51, 23],
	[33, 46, 16, 4, 47, 17],

	// 27
	[8, 152, 122, 4, 153, 123],
	[22, 73, 45, 3, 74, 46],
	[8, 53, 23, 26, 54, 24],
	[12, 45, 15, 28, 46, 16],

	// 28
	[3, 147, 117, 10, 148, 118],
	[3, 73, 45, 23, 74, 46],
	[4, 54, 24, 31, 55, 25],
	[11, 45, 15, 31, 46, 16],

	// 29
	[7, 146, 116, 7, 147, 117],
	[21, 73, 45, 7, 74, 46],
	[1, 53, 23, 37, 54, 24],
	[19, 45, 15, 26, 46, 16],

	// 30
	[5, 145, 115, 10, 146, 116],
	[19, 75, 47, 10, 76, 48],
	[15, 54, 24, 25, 55, 25],
	[23, 45, 15, 25, 46, 16],

	// 31
	[13, 145, 115, 3, 146, 116],
	[2, 74, 46, 29, 75, 47],
	[42, 54, 24, 1, 55, 25],
	[23, 45, 15, 28, 46, 16],

	// 32
	[17, 145, 115],
	[10, 74, 46, 23, 75, 47],
	[10, 54, 24, 35, 55, 25],
	[19, 45, 15, 35, 46, 16],

	// 33
	[17, 145, 115, 1, 146, 116],
	[14, 74, 46, 21, 75, 47],
	[29, 54, 24, 19, 55, 25],
	[11, 45, 15, 46, 46, 16],

	// 34
	[13, 145, 115, 6, 146, 116],
	[14, 74, 46, 23, 75, 47],
	[44, 54, 24, 7, 55, 25],
	[59, 46, 16, 1, 47, 17],

	// 35
	[12, 151, 121, 7, 152, 122],
	[12, 75, 47, 26, 76, 48],
	[39, 54, 24, 14, 55, 25],
	[22, 45, 15, 41, 46, 16],

	// 36
	[6, 151, 121, 14, 152, 122],
	[6, 75, 47, 34, 76, 48],
	[46, 54, 24, 10, 55, 25],
	[2, 45, 15, 64, 46, 16],

	// 37
	[17, 152, 122, 4, 153, 123],
	[29, 74, 46, 14, 75, 47],
	[49, 54, 24, 10, 55, 25],
	[24, 45, 15, 46, 46, 16],

	// 38
	[4, 152, 122, 18, 153, 123],
	[13, 74, 46, 32, 75, 47],
	[48, 54, 24, 14, 55, 25],
	[42, 45, 15, 32, 46, 16],

	// 39
	[20, 147, 117, 4, 148, 118],
	[40, 75, 47, 7, 76, 48],
	[43, 54, 24, 22, 55, 25],
	[10, 45, 15, 67, 46, 16],

	// 40
	[19, 148, 118, 6, 149, 119],
	[18, 75, 47, 31, 76, 48],
	[34, 54, 24, 34, 55, 25],
	[20, 45, 15, 61, 46, 16]
];

QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
	
	var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
	
	if (rsBlock == undefined) {
		throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
	}

	var length = rsBlock.length / 3;
	
	var list = new Array();
	
	for (var i = 0; i < length; i++) {

		var count = rsBlock[i * 3 + 0];
		var totalCount = rsBlock[i * 3 + 1];
		var dataCount  = rsBlock[i * 3 + 2];

		for (var j = 0; j < count; j++) {
			list.push(new QRRSBlock(totalCount, dataCount) );	
		}
	}
	
	return list;
}

QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {

	switch(errorCorrectLevel) {
	case ECL.L :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
	case ECL.M :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
	case ECL.Q :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
	case ECL.H :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
	default :
		return undefined;
	}
}

module.exports = QRRSBlock;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\RSBlock.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\math.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5Cmath.js
      return function (require, module, exports) {
var QRMath = {

	glog : function(n) {
	
		if (n < 1) {
			throw new Error("glog(" + n + ")");
		}
		
		return QRMath.LOG_TABLE[n];
	},
	
	gexp : function(n) {
	
		while (n < 0) {
			n += 255;
		}
	
		while (n >= 256) {
			n -= 255;
		}
	
		return QRMath.EXP_TABLE[n];
	},
	
	EXP_TABLE : new Array(256),
	
	LOG_TABLE : new Array(256)

};
	
for (var i = 0; i < 8; i++) {
	QRMath.EXP_TABLE[i] = 1 << i;
}
for (var i = 8; i < 256; i++) {
	QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4]
		^ QRMath.EXP_TABLE[i - 5]
		^ QRMath.EXP_TABLE[i - 6]
		^ QRMath.EXP_TABLE[i - 8];
}
for (var i = 0; i < 255; i++) {
	QRMath.LOG_TABLE[QRMath.EXP_TABLE[i] ] = i;
}

module.exports = QRMath;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\math.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\mode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5Cmode.js
      return function (require, module, exports) {
module.exports = {
	MODE_NUMBER :		1 << 0,
	MODE_ALPHA_NUM : 	1 << 1,
	MODE_8BIT_BYTE : 	1 << 2,
	MODE_KANJI :		1 << 3
};

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\mode.js",}],
["F:\\metamask-extension\\node_modules\\qr.js\\lib\\util.js", {"./Polynomial":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\Polynomial.js","./math":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\math.js","./mode":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\mode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqr.js%5Clib%5Cutil.js
      return function (require, module, exports) {
var Mode = require('./mode');
var Polynomial = require('./Polynomial');
var math = require('./math');

var QRMaskPattern = {
	PATTERN000 : 0,
	PATTERN001 : 1,
	PATTERN010 : 2,
	PATTERN011 : 3,
	PATTERN100 : 4,
	PATTERN101 : 5,
	PATTERN110 : 6,
	PATTERN111 : 7
};

var QRUtil = {

    PATTERN_POSITION_TABLE : [
	    [],
	    [6, 18],
	    [6, 22],
	    [6, 26],
	    [6, 30],
	    [6, 34],
	    [6, 22, 38],
	    [6, 24, 42],
	    [6, 26, 46],
	    [6, 28, 50],
	    [6, 30, 54],		
	    [6, 32, 58],
	    [6, 34, 62],
	    [6, 26, 46, 66],
	    [6, 26, 48, 70],
	    [6, 26, 50, 74],
	    [6, 30, 54, 78],
	    [6, 30, 56, 82],
	    [6, 30, 58, 86],
	    [6, 34, 62, 90],
	    [6, 28, 50, 72, 94],
	    [6, 26, 50, 74, 98],
	    [6, 30, 54, 78, 102],
	    [6, 28, 54, 80, 106],
	    [6, 32, 58, 84, 110],
	    [6, 30, 58, 86, 114],
	    [6, 34, 62, 90, 118],
	    [6, 26, 50, 74, 98, 122],
	    [6, 30, 54, 78, 102, 126],
	    [6, 26, 52, 78, 104, 130],
	    [6, 30, 56, 82, 108, 134],
	    [6, 34, 60, 86, 112, 138],
	    [6, 30, 58, 86, 114, 142],
	    [6, 34, 62, 90, 118, 146],
	    [6, 30, 54, 78, 102, 126, 150],
	    [6, 24, 50, 76, 102, 128, 154],
	    [6, 28, 54, 80, 106, 132, 158],
	    [6, 32, 58, 84, 110, 136, 162],
	    [6, 26, 54, 82, 110, 138, 166],
	    [6, 30, 58, 86, 114, 142, 170]
    ],

    G15 : (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
    G18 : (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
    G15_MASK : (1 << 14) | (1 << 12) | (1 << 10)	| (1 << 4) | (1 << 1),

    getBCHTypeInfo : function(data) {
	    var d = data << 10;
	    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
		    d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) ) ); 	
	    }
	    return ( (data << 10) | d) ^ QRUtil.G15_MASK;
    },

    getBCHTypeNumber : function(data) {
	    var d = data << 12;
	    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
		    d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) ) ); 	
	    }
	    return (data << 12) | d;
    },

    getBCHDigit : function(data) {

	    var digit = 0;

	    while (data != 0) {
		    digit++;
		    data >>>= 1;
	    }

	    return digit;
    },

    getPatternPosition : function(typeNumber) {
	    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },

    getMask : function(maskPattern, i, j) {
	    
	    switch (maskPattern) {
		    
	    case QRMaskPattern.PATTERN000 : return (i + j) % 2 == 0;
	    case QRMaskPattern.PATTERN001 : return i % 2 == 0;
	    case QRMaskPattern.PATTERN010 : return j % 3 == 0;
	    case QRMaskPattern.PATTERN011 : return (i + j) % 3 == 0;
	    case QRMaskPattern.PATTERN100 : return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0;
	    case QRMaskPattern.PATTERN101 : return (i * j) % 2 + (i * j) % 3 == 0;
	    case QRMaskPattern.PATTERN110 : return ( (i * j) % 2 + (i * j) % 3) % 2 == 0;
	    case QRMaskPattern.PATTERN111 : return ( (i * j) % 3 + (i + j) % 2) % 2 == 0;

	    default :
		    throw new Error("bad maskPattern:" + maskPattern);
	    }
    },

    getErrorCorrectPolynomial : function(errorCorrectLength) {

	    var a = new Polynomial([1], 0);

	    for (var i = 0; i < errorCorrectLength; i++) {
		    a = a.multiply(new Polynomial([1, math.gexp(i)], 0) );
	    }

	    return a;
    },

    getLengthInBits : function(mode, type) {

	    if (1 <= type && type < 10) {

		    // 1 - 9

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 10;
		    case Mode.MODE_ALPHA_NUM 	: return 9;
		    case Mode.MODE_8BIT_BYTE	: return 8;
		    case Mode.MODE_KANJI  	: return 8;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else if (type < 27) {

		    // 10 - 26

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 12;
		    case Mode.MODE_ALPHA_NUM 	: return 11;
		    case Mode.MODE_8BIT_BYTE	: return 16;
		    case Mode.MODE_KANJI  	: return 10;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else if (type < 41) {

		    // 27 - 40

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 14;
		    case Mode.MODE_ALPHA_NUM	: return 13;
		    case Mode.MODE_8BIT_BYTE	: return 16;
		    case Mode.MODE_KANJI  	: return 12;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else {
		    throw new Error("type:" + type);
	    }
    },

    getLostPoint : function(qrCode) {
	    
	    var moduleCount = qrCode.getModuleCount();
	    
	    var lostPoint = 0;
	    
	    // LEVEL1
	    
	    for (var row = 0; row < moduleCount; row++) {

		    for (var col = 0; col < moduleCount; col++) {

			    var sameCount = 0;
			    var dark = qrCode.isDark(row, col);

				for (var r = -1; r <= 1; r++) {

				    if (row + r < 0 || moduleCount <= row + r) {
					    continue;
				    }

				    for (var c = -1; c <= 1; c++) {

					    if (col + c < 0 || moduleCount <= col + c) {
						    continue;
					    }

					    if (r == 0 && c == 0) {
						    continue;
					    }

					    if (dark == qrCode.isDark(row + r, col + c) ) {
						    sameCount++;
					    }
				    }
			    }

			    if (sameCount > 5) {
				    lostPoint += (3 + sameCount - 5);
			    }
		    }
	    }

	    // LEVEL2

	    for (var row = 0; row < moduleCount - 1; row++) {
		    for (var col = 0; col < moduleCount - 1; col++) {
			    var count = 0;
			    if (qrCode.isDark(row,     col    ) ) count++;
			    if (qrCode.isDark(row + 1, col    ) ) count++;
			    if (qrCode.isDark(row,     col + 1) ) count++;
			    if (qrCode.isDark(row + 1, col + 1) ) count++;
			    if (count == 0 || count == 4) {
				    lostPoint += 3;
			    }
		    }
	    }

	    // LEVEL3

	    for (var row = 0; row < moduleCount; row++) {
		    for (var col = 0; col < moduleCount - 6; col++) {
			    if (qrCode.isDark(row, col)
					    && !qrCode.isDark(row, col + 1)
					    &&  qrCode.isDark(row, col + 2)
					    &&  qrCode.isDark(row, col + 3)
					    &&  qrCode.isDark(row, col + 4)
					    && !qrCode.isDark(row, col + 5)
					    &&  qrCode.isDark(row, col + 6) ) {
				    lostPoint += 40;
			    }
		    }
	    }

	    for (var col = 0; col < moduleCount; col++) {
		    for (var row = 0; row < moduleCount - 6; row++) {
			    if (qrCode.isDark(row, col)
					    && !qrCode.isDark(row + 1, col)
					    &&  qrCode.isDark(row + 2, col)
					    &&  qrCode.isDark(row + 3, col)
					    &&  qrCode.isDark(row + 4, col)
					    && !qrCode.isDark(row + 5, col)
					    &&  qrCode.isDark(row + 6, col) ) {
				    lostPoint += 40;
			    }
		    }
	    }

	    // LEVEL4
	    
	    var darkCount = 0;

	    for (var col = 0; col < moduleCount; col++) {
		    for (var row = 0; row < moduleCount; row++) {
			    if (qrCode.isDark(row, col) ) {
				    darkCount++;
			    }
		    }
	    }
	    
	    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
	    lostPoint += ratio * 10;

	    return lostPoint;		
    }
};

module.exports = QRUtil;

      };
    };
  }
  }
}, {package:"qrcode.react>qr.js",file:"node_modules\\qr.js\\lib\\util.js",}],
["F:\\metamask-extension\\node_modules\\qrcode-generator\\qrcode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqrcode-generator%5Cqrcode.js
      return function (require, module, exports) {
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//  http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//  http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

  //---------------------------------------------------------------------
  // qrcode
  //---------------------------------------------------------------------

  /**
   * qrcode
   * @param typeNumber 1 to 40
   * @param errorCorrectionLevel 'L','M','Q','H'
   */
  var qrcode = function(typeNumber, errorCorrectionLevel) {

    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {

      _moduleCount = _typeNumber * 4 + 17;
      _modules = function(moduleCount) {
        var modules = new Array(moduleCount);
        for (var row = 0; row < moduleCount; row += 1) {
          modules[row] = new Array(moduleCount);
          for (var col = 0; col < moduleCount; col += 1) {
            modules[row][col] = null;
          }
        }
        return modules;
      }(_moduleCount);

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      }

      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {

      for (var r = -1; r <= 7; r += 1) {

        if (row + r <= -1 || _moduleCount <= row + r) continue;

        for (var c = -1; c <= 7; c += 1) {

          if (col + c <= -1 || _moduleCount <= col + c) continue;

          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
              || (0 <= c && c <= 6 && (r == 0 || r == 6) )
              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {

      var minLostPoint = 0;
      var pattern = 0;

      for (var i = 0; i < 8; i += 1) {

        makeImpl(true, i);

        var lostPoint = QRUtil.getLostPoint(_this);

        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }

      return pattern;
    };

    var setupTimingPattern = function() {

      for (var r = 8; r < _moduleCount - 8; r += 1) {
        if (_modules[r][6] != null) {
          continue;
        }
        _modules[r][6] = (r % 2 == 0);
      }

      for (var c = 8; c < _moduleCount - 8; c += 1) {
        if (_modules[6][c] != null) {
          continue;
        }
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {

      var pos = QRUtil.getPatternPosition(_typeNumber);

      for (var i = 0; i < pos.length; i += 1) {

        for (var j = 0; j < pos.length; j += 1) {

          var row = pos[i];
          var col = pos[j];

          if (_modules[row][col] != null) {
            continue;
          }

          for (var r = -2; r <= 2; r += 1) {

            for (var c = -2; c <= 2; c += 1) {

              if (r == -2 || r == 2 || c == -2 || c == 2
                  || (r == 0 && c == 0) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {

      var bits = QRUtil.getBCHTypeNumber(_typeNumber);

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {

      var data = (_errorCorrectionLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);

      // vertical
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 6) {
          _modules[i][8] = mod;
        } else if (i < 8) {
          _modules[i + 1][8] = mod;
        } else {
          _modules[_moduleCount - 15 + i][8] = mod;
        }
      }

      // horizontal
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 8) {
          _modules[8][_moduleCount - i - 1] = mod;
        } else if (i < 9) {
          _modules[8][15 - i - 1 + 1] = mod;
        } else {
          _modules[8][15 - i - 1] = mod;
        }
      }

      // fixed module
      _modules[_moduleCount - 8][8] = (!test);
    };

    var mapData = function(data, maskPattern) {

      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      var maskFunc = QRUtil.getMaskFunction(maskPattern);

      for (var col = _moduleCount - 1; col > 0; col -= 2) {

        if (col == 6) col -= 1;

        while (true) {

          for (var c = 0; c < 2; c += 1) {

            if (_modules[row][col - c] == null) {

              var dark = false;

              if (byteIndex < data.length) {
                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
              }

              var mask = maskFunc(row, col - c);

              if (mask) {
                dark = !dark;
              }

              _modules[row][col - c] = dark;
              bitIndex -= 1;

              if (bitIndex == -1) {
                byteIndex += 1;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };

    var createBytes = function(buffer, rsBlocks) {

      var offset = 0;

      var maxDcCount = 0;
      var maxEcCount = 0;

      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);

      for (var r = 0; r < rsBlocks.length; r += 1) {

        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;

        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);

        dcdata[r] = new Array(dcCount);

        for (var i = 0; i < dcdata[r].length; i += 1) {
          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
        }
        offset += dcCount;

        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i += 1) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
        }
      }

      var totalCodeCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalCodeCount += rsBlocks[i].totalCount;
      }

      var data = new Array(totalCodeCount);
      var index = 0;

      for (var i = 0; i < maxDcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < dcdata[r].length) {
            data[index] = dcdata[r][i];
            index += 1;
          }
        }
      }

      for (var i = 0; i < maxEcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < ecdata[r].length) {
            data[index] = ecdata[r][i];
            index += 1;
          }
        }
      }

      return data;
    };

    var createData = function(typeNumber, errorCorrectionLevel, dataList) {

      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

      var buffer = qrBitBuffer();

      for (var i = 0; i < dataList.length; i += 1) {
        var data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
        data.write(buffer);
      }

      // calc num max data.
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalDataCount += rsBlocks[i].dataCount;
      }

      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw 'code length overflow. ('
          + buffer.getLengthInBits()
          + '>'
          + totalDataCount * 8
          + ')';
      }

      // end code
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }

      // padding
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }

      // padding
      while (true) {

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD0, 8);

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD1, 8);
      }

      return createBytes(buffer, rsBlocks);
    };

    _this.addData = function(data, mode) {

      mode = mode || 'Byte';

      var newData = null;

      switch(mode) {
      case 'Numeric' :
        newData = qrNumber(data);
        break;
      case 'Alphanumeric' :
        newData = qrAlphaNum(data);
        break;
      case 'Byte' :
        newData = qr8BitByte(data);
        break;
      case 'Kanji' :
        newData = qrKanji(data);
        break;
      default :
        throw 'mode:' + mode;
      }

      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) {
      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
        throw row + ',' + col;
      }
      return _modules[row][col];
    };

    _this.getModuleCount = function() {
      return _moduleCount;
    };

    _this.make = function() {
      if (_typeNumber < 1) {
        var typeNumber = 1;

        for (; typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
          var buffer = qrBitBuffer();

          for (var i = 0; i < _dataList.length; i++) {
            var data = _dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() <= totalDataCount * 8) {
            break;
          }
        }

        _typeNumber = typeNumber;
      }

      makeImpl(false, getBestMaskPattern() );
    };

    _this.createTableTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var qrHtml = '';

      qrHtml += '<table style="';
      qrHtml += ' border-width: 0px; border-style: none;';
      qrHtml += ' border-collapse: collapse;';
      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
      qrHtml += '">';
      qrHtml += '<tbody>';

      for (var r = 0; r < _this.getModuleCount(); r += 1) {

        qrHtml += '<tr>';

        for (var c = 0; c < _this.getModuleCount(); c += 1) {
          qrHtml += '<td style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: 0px;';
          qrHtml += ' width: ' + cellSize + 'px;';
          qrHtml += ' height: ' + cellSize + 'px;';
          qrHtml += ' background-color: ';
          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
          qrHtml += ';';
          qrHtml += '"/>';
        }

        qrHtml += '</tr>';
      }

      qrHtml += '</tbody>';
      qrHtml += '</table>';

      return qrHtml;
    };

    _this.createSvgTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;
      var size = _this.getModuleCount() * cellSize + margin * 2;
      var c, mc, r, mr, qrSvg='', rect;

      rect = 'l' + cellSize + ',0 0,' + cellSize +
        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

      qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
      qrSvg += ' width="' + size + 'px"';
      qrSvg += ' height="' + size + 'px"';
      qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
      qrSvg += ' preserveAspectRatio="xMinYMin meet">';
      qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
      qrSvg += '<path d="';

      for (r = 0; r < _this.getModuleCount(); r += 1) {
        mr = r * cellSize + margin;
        for (c = 0; c < _this.getModuleCount(); c += 1) {
          if (_this.isDark(r, c) ) {
            mc = c*cellSize+margin;
            qrSvg += 'M' + mc + ',' + mr + rect;
          }
        }
      }

      qrSvg += '" stroke="transparent" fill="black"/>';
      qrSvg += '</svg>';

      return qrSvg;
    };

    _this.createDataURL = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      return createDataURL(size, size, function(x, y) {
        if (min <= x && x < max && min <= y && y < max) {
          var c = Math.floor( (x - min) / cellSize);
          var r = Math.floor( (y - min) / cellSize);
          return _this.isDark(r, c)? 0 : 1;
        } else {
          return 1;
        }
      } );
    };

    _this.createImgTag = function(cellSize, margin, alt) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;

      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += _this.createDataURL(cellSize, margin);
      img += '"';
      img += '\u0020width="';
      img += size;
      img += '"';
      img += '\u0020height="';
      img += size;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += alt;
        img += '"';
      }
      img += '/>';

      return img;
    };

    var _createHalfASCII = function(margin) {
      var cellSize = 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r1, r2, p;

      var blocks = {
        '██': '█',
        '█ ': '▀',
        ' █': '▄',
        '  ': ' '
      };

      var ascii = '';
      for (y = 0; y < size; y += 2) {
        r1 = Math.floor((y - min) / cellSize);
        r2 = Math.floor((y + 1 - min) / cellSize);
        for (x = 0; x < size; x += 1) {
          p = '█';

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
            p = ' ';
          }

          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
            p += ' ';
          }
          else {
            p += '█';
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          ascii += blocks[p];
        }

        ascii += '\n';
      }

      if (size % 2) {
        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('▀');
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.createASCII = function(cellSize, margin) {
      cellSize = cellSize || 1;

      if (cellSize < 2) {
        return _createHalfASCII(margin);
      }

      cellSize -= 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r, p;

      var white = Array(cellSize+1).join('██');
      var black = Array(cellSize+1).join('  ');

      var ascii = '';
      var line = '';
      for (y = 0; y < size; y += 1) {
        r = Math.floor( (y - min) / cellSize);
        line = '';
        for (x = 0; x < size; x += 1) {
          p = 1;

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
            p = 0;
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          line += p ? white : black;
        }

        for (r = 0; r < cellSize; r += 1) {
          ascii += line + '\n';
        }
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.renderTo2dContext = function(context, cellSize) {
      cellSize = cellSize || 2;
      var length = _this.getModuleCount();
      for (var row = 0; row < length; row++) {
        for (var col = 0; col < length; col++) {
          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
        }
      }
    }

    return _this;
  };

  //---------------------------------------------------------------------
  // qrcode.stringToBytes
  //---------------------------------------------------------------------

  qrcode.stringToBytesFuncs = {
    'default' : function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        bytes.push(c & 0xff);
      }
      return bytes;
    }
  };

  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

  //---------------------------------------------------------------------
  // qrcode.createStringToBytes
  //---------------------------------------------------------------------

  /**
   * @param unicodeData base64 string of byte array.
   * [16bit Unicode],[16bit Bytes], ...
   * @param numChars
   */
  qrcode.createStringToBytes = function(unicodeData, numChars) {

    // create conversion map.

    var unicodeMap = function() {

      var bin = base64DecodeInputStream(unicodeData);
      var read = function() {
        var b = bin.read();
        if (b == -1) throw 'eof';
        return b;
      };

      var count = 0;
      var unicodeMap = {};
      while (true) {
        var b0 = bin.read();
        if (b0 == -1) break;
        var b1 = read();
        var b2 = read();
        var b3 = read();
        var k = String.fromCharCode( (b0 << 8) | b1);
        var v = (b2 << 8) | b3;
        unicodeMap[k] = v;
        count += 1;
      }
      if (count != numChars) {
        throw count + ' != ' + numChars;
      }

      return unicodeMap;
    }();

    var unknownChar = '?'.charCodeAt(0);

    return function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        if (c < 128) {
          bytes.push(c);
        } else {
          var b = unicodeMap[s.charAt(i)];
          if (typeof b == 'number') {
            if ( (b & 0xff) == b) {
              // 1byte
              bytes.push(b);
            } else {
              // 2bytes
              bytes.push(b >>> 8);
              bytes.push(b & 0xff);
            }
          } else {
            bytes.push(unknownChar);
          }
        }
      }
      return bytes;
    };
  };

  //---------------------------------------------------------------------
  // QRMode
  //---------------------------------------------------------------------

  var QRMode = {
    MODE_NUMBER :    1 << 0,
    MODE_ALPHA_NUM : 1 << 1,
    MODE_8BIT_BYTE : 1 << 2,
    MODE_KANJI :     1 << 3
  };

  //---------------------------------------------------------------------
  // QRErrorCorrectionLevel
  //---------------------------------------------------------------------

  var QRErrorCorrectionLevel = {
    L : 1,
    M : 0,
    Q : 3,
    H : 2
  };

  //---------------------------------------------------------------------
  // QRMaskPattern
  //---------------------------------------------------------------------

  var QRMaskPattern = {
    PATTERN000 : 0,
    PATTERN001 : 1,
    PATTERN010 : 2,
    PATTERN011 : 3,
    PATTERN100 : 4,
    PATTERN101 : 5,
    PATTERN110 : 6,
    PATTERN111 : 7
  };

  //---------------------------------------------------------------------
  // QRUtil
  //---------------------------------------------------------------------

  var QRUtil = function() {

    var PATTERN_POSITION_TABLE = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ];
    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

    var _this = {};

    var getBCHDigit = function(data) {
      var digit = 0;
      while (data != 0) {
        digit += 1;
        data >>>= 1;
      }
      return digit;
    };

    _this.getBCHTypeInfo = function(data) {
      var d = data << 10;
      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
      }
      return ( (data << 10) | d) ^ G15_MASK;
    };

    _this.getBCHTypeNumber = function(data) {
      var d = data << 12;
      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
      }
      return (data << 12) | d;
    };

    _this.getPatternPosition = function(typeNumber) {
      return PATTERN_POSITION_TABLE[typeNumber - 1];
    };

    _this.getMaskFunction = function(maskPattern) {

      switch (maskPattern) {

      case QRMaskPattern.PATTERN000 :
        return function(i, j) { return (i + j) % 2 == 0; };
      case QRMaskPattern.PATTERN001 :
        return function(i, j) { return i % 2 == 0; };
      case QRMaskPattern.PATTERN010 :
        return function(i, j) { return j % 3 == 0; };
      case QRMaskPattern.PATTERN011 :
        return function(i, j) { return (i + j) % 3 == 0; };
      case QRMaskPattern.PATTERN100 :
        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
      case QRMaskPattern.PATTERN101 :
        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
      case QRMaskPattern.PATTERN110 :
        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
      case QRMaskPattern.PATTERN111 :
        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

      default :
        throw 'bad maskPattern:' + maskPattern;
      }
    };

    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
      var a = qrPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i += 1) {
        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
      }
      return a;
    };

    _this.getLengthInBits = function(mode, type) {

      if (1 <= type && type < 10) {

        // 1 - 9

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 10;
        case QRMode.MODE_ALPHA_NUM : return 9;
        case QRMode.MODE_8BIT_BYTE : return 8;
        case QRMode.MODE_KANJI     : return 8;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 27) {

        // 10 - 26

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 12;
        case QRMode.MODE_ALPHA_NUM : return 11;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 10;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 41) {

        // 27 - 40

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 14;
        case QRMode.MODE_ALPHA_NUM : return 13;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 12;
        default :
          throw 'mode:' + mode;
        }

      } else {
        throw 'type:' + type;
      }
    };

    _this.getLostPoint = function(qrcode) {

      var moduleCount = qrcode.getModuleCount();

      var lostPoint = 0;

      // LEVEL1

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount; col += 1) {

          var sameCount = 0;
          var dark = qrcode.isDark(row, col);

          for (var r = -1; r <= 1; r += 1) {

            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c += 1) {

              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrcode.isDark(row + r, col + c) ) {
                sameCount += 1;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += (3 + sameCount - 5);
          }
        }
      };

      // LEVEL2

      for (var row = 0; row < moduleCount - 1; row += 1) {
        for (var col = 0; col < moduleCount - 1; col += 1) {
          var count = 0;
          if (qrcode.isDark(row, col) ) count += 1;
          if (qrcode.isDark(row + 1, col) ) count += 1;
          if (qrcode.isDark(row, col + 1) ) count += 1;
          if (qrcode.isDark(row + 1, col + 1) ) count += 1;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }

      // LEVEL3

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount - 6; col += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row, col + 1)
              &&  qrcode.isDark(row, col + 2)
              &&  qrcode.isDark(row, col + 3)
              &&  qrcode.isDark(row, col + 4)
              && !qrcode.isDark(row, col + 5)
              &&  qrcode.isDark(row, col + 6) ) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount - 6; row += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row + 1, col)
              &&  qrcode.isDark(row + 2, col)
              &&  qrcode.isDark(row + 3, col)
              &&  qrcode.isDark(row + 4, col)
              && !qrcode.isDark(row + 5, col)
              &&  qrcode.isDark(row + 6, col) ) {
            lostPoint += 40;
          }
        }
      }

      // LEVEL4

      var darkCount = 0;

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount; row += 1) {
          if (qrcode.isDark(row, col) ) {
            darkCount += 1;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;

      return lostPoint;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // QRMath
  //---------------------------------------------------------------------

  var QRMath = function() {

    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);

    // initialize tables
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4]
        ^ EXP_TABLE[i - 5]
        ^ EXP_TABLE[i - 6]
        ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i] ] = i;
    }

    var _this = {};

    _this.glog = function(n) {

      if (n < 1) {
        throw 'glog(' + n + ')';
      }

      return LOG_TABLE[n];
    };

    _this.gexp = function(n) {

      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return EXP_TABLE[n];
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrPolynomial
  //---------------------------------------------------------------------

  function qrPolynomial(num, shift) {

    if (typeof num.length == 'undefined') {
      throw num.length + '/' + shift;
    }

    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();

    var _this = {};

    _this.getAt = function(index) {
      return _num[index];
    };

    _this.getLength = function() {
      return _num.length;
    };

    _this.multiply = function(e) {

      var num = new Array(_this.getLength() + e.getLength() - 1);

      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
        }
      }

      return qrPolynomial(num, 0);
    };

    _this.mod = function(e) {

      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }

      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

      var num = new Array(_this.getLength() );
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }

      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
      }

      // recursive call
      return qrPolynomial(num, 0).mod(e);
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // QRRSBlock
  //---------------------------------------------------------------------

  var QRRSBlock = function() {

    var RS_BLOCK_TABLE = [

      // L
      // M
      // Q
      // H

      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],

      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],

      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],

      // 4
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],

      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],

      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],

      // 7
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],

      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],

      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],

      // 10
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],

      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],

      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];

    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };

    var _this = {};

    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

      switch(errorCorrectionLevel) {
      case QRErrorCorrectionLevel.L :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectionLevel.M :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectionLevel.Q :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectionLevel.H :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default :
        return undefined;
      }
    };

    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

      if (typeof rsBlock == 'undefined') {
        throw 'bad rs block @ typeNumber:' + typeNumber +
            '/errorCorrectionLevel:' + errorCorrectionLevel;
      }

      var length = rsBlock.length / 3;

      var list = [];

      for (var i = 0; i < length; i += 1) {

        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];

        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount) );
        }
      }

      return list;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrBitBuffer
  //---------------------------------------------------------------------

  var qrBitBuffer = function() {

    var _buffer = [];
    var _length = 0;

    var _this = {};

    _this.getBuffer = function() {
      return _buffer;
    };

    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
    };

    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
      }
    };

    _this.getLengthInBits = function() {
      return _length;
    };

    _this.putBit = function(bit) {

      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }

      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
      }

      _length += 1;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrNumber
  //---------------------------------------------------------------------

  var qrNumber = function(data) {

    var _mode = QRMode.MODE_NUMBER;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var data = _data;

      var i = 0;

      while (i + 2 < data.length) {
        buffer.put(strToNum(data.substring(i, i + 3) ), 10);
        i += 3;
      }

      if (i < data.length) {
        if (data.length - i == 1) {
          buffer.put(strToNum(data.substring(i, i + 1) ), 4);
        } else if (data.length - i == 2) {
          buffer.put(strToNum(data.substring(i, i + 2) ), 7);
        }
      }
    };

    var strToNum = function(s) {
      var num = 0;
      for (var i = 0; i < s.length; i += 1) {
        num = num * 10 + chatToNum(s.charAt(i) );
      }
      return num;
    };

    var chatToNum = function(c) {
      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      throw 'illegal char :' + c;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrAlphaNum
  //---------------------------------------------------------------------

  var qrAlphaNum = function(data) {

    var _mode = QRMode.MODE_ALPHA_NUM;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var s = _data;

      var i = 0;

      while (i + 1 < s.length) {
        buffer.put(
          getCode(s.charAt(i) ) * 45 +
          getCode(s.charAt(i + 1) ), 11);
        i += 2;
      }

      if (i < s.length) {
        buffer.put(getCode(s.charAt(i) ), 6);
      }
    };

    var getCode = function(c) {

      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      } else if ('A' <= c && c <= 'Z') {
        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      } else {
        switch (c) {
        case ' ' : return 36;
        case '$' : return 37;
        case '%' : return 38;
        case '*' : return 39;
        case '+' : return 40;
        case '-' : return 41;
        case '.' : return 42;
        case '/' : return 43;
        case ':' : return 44;
        default :
          throw 'illegal char :' + c;
        }
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qr8BitByte
  //---------------------------------------------------------------------

  var qr8BitByte = function(data) {

    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = qrcode.stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _bytes.length;
    };

    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrKanji
  //---------------------------------------------------------------------

  var qrKanji = function(data) {

    var _mode = QRMode.MODE_KANJI;
    var _data = data;

    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
    if (!stringToBytes) {
      throw 'sjis not supported.';
    }
    !function(c, code) {
      // self test for sjis support.
      var test = stringToBytes(c);
      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
        throw 'sjis not supported.';
      }
    }('\u53cb', 0x9746);

    var _bytes = stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return ~~(_bytes.length / 2);
    };

    _this.write = function(buffer) {

      var data = _bytes;

      var i = 0;

      while (i + 1 < data.length) {

        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

        if (0x8140 <= c && c <= 0x9FFC) {
          c -= 0x8140;
        } else if (0xE040 <= c && c <= 0xEBBF) {
          c -= 0xC140;
        } else {
          throw 'illegal char at ' + (i + 1) + '/' + c;
        }

        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

        buffer.put(c, 13);

        i += 2;
      }

      if (i < data.length) {
        throw 'illegal char at ' + (i + 1);
      }
    };

    return _this;
  };

  //=====================================================================
  // GIF Support etc.
  //

  //---------------------------------------------------------------------
  // byteArrayOutputStream
  //---------------------------------------------------------------------

  var byteArrayOutputStream = function() {

    var _bytes = [];

    var _this = {};

    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };

    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };

    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };

    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i) );
      }
    };

    _this.toByteArray = function() {
      return _bytes;
    };

    _this.toString = function() {
      var s = '';
      s += '[';
      for (var i = 0; i < _bytes.length; i += 1) {
        if (i > 0) {
          s += ',';
        }
        s += _bytes[i];
      }
      s += ']';
      return s;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64EncodeOutputStream
  //---------------------------------------------------------------------

  var base64EncodeOutputStream = function() {

    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';

    var _this = {};

    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f) );
    };

    var encode = function(n) {
      if (n < 0) {
        // error.
      } else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw 'n:' + n;
    };

    _this.writeByte = function(n) {

      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;

      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6) );
        _buflen -= 6;
      }
    };

    _this.flush = function() {

      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen) );
        _buffer = 0;
        _buflen = 0;
      }

      if (_length % 3 != 0) {
        // padding
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };

    _this.toString = function() {
      return _base64;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64DecodeInputStream
  //---------------------------------------------------------------------

  var base64DecodeInputStream = function(str) {

    var _str = str;
    var _pos = 0;
    var _buffer = 0;
    var _buflen = 0;

    var _this = {};

    _this.read = function() {

      while (_buflen < 8) {

        if (_pos >= _str.length) {
          if (_buflen == 0) {
            return -1;
          }
          throw 'unexpected end of file./' + _buflen;
        }

        var c = _str.charAt(_pos);
        _pos += 1;

        if (c == '=') {
          _buflen = 0;
          return -1;
        } else if (c.match(/^\s$/) ) {
          // ignore if whitespace.
          continue;
        }

        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
        _buflen += 6;
      }

      var n = (_buffer >>> (_buflen - 8) ) & 0xff;
      _buflen -= 8;
      return n;
    };

    var decode = function(c) {
      if (0x41 <= c && c <= 0x5a) {
        return c - 0x41;
      } else if (0x61 <= c && c <= 0x7a) {
        return c - 0x61 + 26;
      } else if (0x30 <= c && c <= 0x39) {
        return c - 0x30 + 52;
      } else if (c == 0x2b) {
        return 62;
      } else if (c == 0x2f) {
        return 63;
      } else {
        throw 'c:' + c;
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // gifImage (B/W)
  //---------------------------------------------------------------------

  var gifImage = function(width, height) {

    var _width = width;
    var _height = height;
    var _data = new Array(width * height);

    var _this = {};

    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };

    _this.write = function(out) {

      //---------------------------------
      // GIF Signature

      out.writeString('GIF87a');

      //---------------------------------
      // Screen Descriptor

      out.writeShort(_width);
      out.writeShort(_height);

      out.writeByte(0x80); // 2bit
      out.writeByte(0);
      out.writeByte(0);

      //---------------------------------
      // Global Color Map

      // black
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);

      // white
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);

      //---------------------------------
      // Image Descriptor

      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);

      //---------------------------------
      // Local Color Map

      //---------------------------------
      // Raster Data

      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);

      out.writeByte(lzwMinCodeSize);

      var offset = 0;

      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }

      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);

      //---------------------------------
      // GIF Terminator
      out.writeString(';');
    };

    var bitOutputStream = function(out) {

      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;

      var _this = {};

      _this.write = function(data, length) {

        if ( (data >>> length) != 0) {
          throw 'length over';
        }

        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }

        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };

      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };

      return _this;
    };

    var getLZWRaster = function(lzwMinCodeSize) {

      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;

      // Setup LZWTable
      var table = lzwTable();

      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i) );
      }
      table.add(String.fromCharCode(clearCode) );
      table.add(String.fromCharCode(endCode) );

      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);

      // clear code
      bitOut.write(clearCode, bitLength);

      var dataIndex = 0;

      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;

      while (dataIndex < _data.length) {

        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;

        if (table.contains(s + c) ) {

          s = s + c;

        } else {

          bitOut.write(table.indexOf(s), bitLength);

          if (table.size() < 0xfff) {

            if (table.size() == (1 << bitLength) ) {
              bitLength += 1;
            }

            table.add(s + c);
          }

          s = c;
        }
      }

      bitOut.write(table.indexOf(s), bitLength);

      // end code
      bitOut.write(endCode, bitLength);

      bitOut.flush();

      return byteOut.toByteArray();
    };

    var lzwTable = function() {

      var _map = {};
      var _size = 0;

      var _this = {};

      _this.add = function(key) {
        if (_this.contains(key) ) {
          throw 'dup key:' + key;
        }
        _map[key] = _size;
        _size += 1;
      };

      _this.size = function() {
        return _size;
      };

      _this.indexOf = function(key) {
        return _map[key];
      };

      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };

      return _this;
    };

    return _this;
  };

  var createDataURL = function(width, height, getPixel) {
    var gif = gifImage(width, height);
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        gif.setPixel(x, y, getPixel(x, y) );
      }
    }

    var b = byteArrayOutputStream();
    gif.write(b);

    var base64 = base64EncodeOutputStream();
    var bytes = b.toByteArray();
    for (var i = 0; i < bytes.length; i += 1) {
      base64.writeByte(bytes[i]);
    }
    base64.flush();

    return 'data:image/gif;base64,' + base64;
  };

  //---------------------------------------------------------------------
  // returns qrcode function.

  return qrcode;
}();

// multibyte support
!function() {

  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6),
              0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff));
          utf8.push(0xf0 | (charcode >>18),
              0x80 | ((charcode>>12) & 0x3f),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
      }
      return utf8;
    }
    return toUTF8Array(s);
  };

}();

(function (factory) {
  if (typeof define === 'function' && define.amd) {
      define([], factory);
  } else if (typeof exports === 'object') {
      module.exports = factory();
  }
}(function () {
    return qrcode;
}));

      };
    };
  }
  }
}, {package:"qrcode-generator",file:"node_modules\\qrcode-generator\\qrcode.js",}],
["F:\\metamask-extension\\node_modules\\qrcode.react\\lib\\index.js", {"prop-types":"F:\\metamask-extension\\node_modules\\prop-types\\index.js","qr.js/lib/ErrorCorrectLevel":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js","qr.js/lib/QRCode":"F:\\metamask-extension\\node_modules\\qr.js\\lib\\QRCode.js","react":"F:\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cqrcode.react%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var React = require('react');

var PropTypes = require('prop-types'); // qr.js doesn't handle error level of zero (M) so we need to do it right,
// thus the deep require.


var QRCodeImpl = require('qr.js/lib/QRCode');

var ErrorCorrectLevel = require('qr.js/lib/ErrorCorrectLevel'); // TODO: pull this off of the QRCode class type so it matches.


// Convert from UTF-16, forcing the use of byte-mode encoding in our QR Code.
// This allows us to encode Hanji, Kanji, emoji, etc. Ideally we'd do more
// detection and not resort to byte-mode if possible, but we're trading off
// a smaller library for a smaller amount of data we can potentially encode.
// Based on http://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/
function convertStr(str) {
  var out = '';

  for (var i = 0; i < str.length; i++) {
    var charcode = str.charCodeAt(i);

    if (charcode < 0x0080) {
      out += String.fromCharCode(charcode);
    } else if (charcode < 0x0800) {
      out += String.fromCharCode(0xc0 | charcode >> 6);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    } else if (charcode < 0xd800 || charcode >= 0xe000) {
      out += String.fromCharCode(0xe0 | charcode >> 12);
      out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    } else {
      // This is a surrogate pair, so we'll reconsitute the pieces and work
      // from that
      i++;
      charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
      out += String.fromCharCode(0xf0 | charcode >> 18);
      out += String.fromCharCode(0x80 | charcode >> 12 & 0x3f);
      out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    }
  }

  return out;
}

var DEFAULT_PROPS = {
  size: 128,
  level: 'L',
  bgColor: '#FFFFFF',
  fgColor: '#000000',
  includeMargin: false
};
var PROP_TYPES = "development" !== 'production' ? {
  value: PropTypes.string.isRequired,
  size: PropTypes.number,
  level: PropTypes.oneOf(['L', 'M', 'Q', 'H']),
  bgColor: PropTypes.string,
  fgColor: PropTypes.string,
  includeMargin: PropTypes.bool,
  imageSettings: PropTypes.shape({
    src: PropTypes.string.isRequired,
    height: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired,
    excavate: PropTypes.bool,
    x: PropTypes.number,
    y: PropTypes.number
  })
} : {};
var MARGIN_SIZE = 4; // This is *very* rough estimate of max amount of QRCode allowed to be covered.
// It is "wrong" in a lot of ways (area is a terrible way to estimate, it
// really should be number of modules covered), but if for some reason we don't
// get an explicit height or width, I'd rather default to something than throw.

var DEFAULT_IMG_SCALE = 0.1;

function generatePath(modules) {
  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var ops = [];
  modules.forEach(function (row, y) {
    var start = null;
    row.forEach(function (cell, x) {
      if (!cell && start !== null) {
        // M0 0h7v1H0z injects the space with the move and drops the comma,
        // saving a char per operation
        ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
        start = null;
        return;
      } // end of row, clean up or skip


      if (x === row.length - 1) {
        if (!cell) {
          // We would have closed the op above already so this can only mean
          // 2+ light modules in a row.
          return;
        }

        if (start === null) {
          // Just a single dark module.
          ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
        } else {
          // Otherwise finish the current line.
          ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
        }

        return;
      }

      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join('');
} // We could just do this in generatePath, except that we want to support
// non-Path2D canvas, so we need to keep it an explicit step.


function excavateModules(modules, excavation) {
  return modules.slice().map(function (row, y) {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }

    return row.map(function (cell, x) {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }

      return false;
    });
  });
}

function getImageSettings(props, cells) {
  var imageSettings = props.imageSettings,
      size = props.size,
      includeMargin = props.includeMargin;

  if (imageSettings == null) {
    return null;
  }

  var margin = includeMargin ? MARGIN_SIZE : 0;
  var numCells = cells.length + margin * 2;
  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  var scale = numCells / size;
  var w = (imageSettings.width || defaultSize) * scale;
  var h = (imageSettings.height || defaultSize) * scale;
  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  var excavation = null;

  if (imageSettings.excavate) {
    var floorX = Math.floor(x);
    var floorY = Math.floor(y);
    var ceilW = Math.ceil(w + x - floorX);
    var ceilH = Math.ceil(h + y - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }

  return {
    x: x,
    y: y,
    h: h,
    w: w,
    excavation: excavation
  };
} // For canvas we're going to switch our drawing mode based on whether or not
// the environment supports Path2D. We only need the constructor to be
// supported, but Edge doesn't actually support the path (string) type
// argument. Luckily it also doesn't support the addPath() method. We can
// treat that as the same thing.


var SUPPORTS_PATH2D = function () {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }

  return true;
}();

var QRCodeCanvas =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(QRCodeCanvas, _React$PureComponent);

  function QRCodeCanvas() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, QRCodeCanvas);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(QRCodeCanvas)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "_canvas", void 0);

    _defineProperty(_assertThisInitialized(_this), "_image", void 0);

    _defineProperty(_assertThisInitialized(_this), "state", {
      imgLoaded: false
    });

    _defineProperty(_assertThisInitialized(_this), "handleImageLoad", function () {
      _this.setState({
        imgLoaded: true
      });
    });

    return _this;
  }

  _createClass(QRCodeCanvas, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._image && this._image.complete) {
        this.handleImageLoad();
      }

      this.update();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this$props$imageSett, _nextProps$imageSetti;

      var currentSrc = (_this$props$imageSett = this.props.imageSettings) === null || _this$props$imageSett === void 0 ? void 0 : _this$props$imageSett.src;
      var nextSrc = (_nextProps$imageSetti = nextProps.imageSettings) === null || _nextProps$imageSetti === void 0 ? void 0 : _nextProps$imageSetti.src;

      if (currentSrc !== nextSrc) {
        this.setState({
          imgLoaded: false
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var _this$props = this.props,
          value = _this$props.value,
          size = _this$props.size,
          level = _this$props.level,
          bgColor = _this$props.bgColor,
          fgColor = _this$props.fgColor,
          includeMargin = _this$props.includeMargin,
          imageSettings = _this$props.imageSettings; // We'll use type===-1 to force QRCode to automatically pick the best type

      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();

      if (this._canvas != null) {
        var canvas = this._canvas;
        var ctx = canvas.getContext('2d');

        if (!ctx) {
          return;
        }

        var cells = qrcode.modules;

        if (cells === null) {
          return;
        }

        var margin = includeMargin ? MARGIN_SIZE : 0;
        var numCells = cells.length + margin * 2;
        var calculatedImageSettings = getImageSettings(this.props, cells);

        if (imageSettings != null && calculatedImageSettings != null) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }
        } // We're going to scale this so that the number of drawable units
        // matches the number of cells. This avoids rounding issues, but does
        // result in some potentially unwanted single pixel issues between
        // blocks, only in environments that don't support Path2D.


        var pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        var scale = size / numCells * pixelRatio;
        ctx.scale(scale, scale); // Draw solid background, only paint dark modules.

        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;

        if (SUPPORTS_PATH2D) {
          // $FlowFixMe: Path2D c'tor doesn't support args yet.
          ctx.fill(new Path2D(generatePath(cells, margin)));
        } else {
          cells.forEach(function (row, rdx) {
            row.forEach(function (cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }

        if (this.state.imgLoaded && this._image && calculatedImageSettings != null) {
          ctx.drawImage(this._image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          value = _this$props2.value,
          size = _this$props2.size,
          level = _this$props2.level,
          bgColor = _this$props2.bgColor,
          fgColor = _this$props2.fgColor,
          style = _this$props2.style,
          includeMargin = _this$props2.includeMargin,
          imageSettings = _this$props2.imageSettings,
          otherProps = _objectWithoutProperties(_this$props2, ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"]);

      var canvasStyle = _objectSpread({
        height: size,
        width: size
      }, style);

      var img = null;
      var imgSrc = imageSettings && imageSettings.src;

      if (imageSettings != null && imgSrc != null) {
        img = React.createElement("img", {
          src: imgSrc,
          style: {
            display: 'none'
          },
          onLoad: this.handleImageLoad,
          ref: function ref(_ref) {
            return _this2._image = _ref;
          }
        });
      }

      return React.createElement(React.Fragment, null, React.createElement("canvas", _extends({
        style: canvasStyle,
        height: size,
        width: size,
        ref: function ref(_ref2) {
          return _this2._canvas = _ref2;
        }
      }, otherProps)), img);
    }
  }]);

  return QRCodeCanvas;
}(React.PureComponent);

_defineProperty(QRCodeCanvas, "defaultProps", DEFAULT_PROPS);

if ("development" !== 'production') {
  QRCodeCanvas.propTypes = PROP_TYPES;
}

var QRCodeSVG =
/*#__PURE__*/
function (_React$PureComponent2) {
  _inherits(QRCodeSVG, _React$PureComponent2);

  function QRCodeSVG() {
    _classCallCheck(this, QRCodeSVG);

    return _possibleConstructorReturn(this, _getPrototypeOf(QRCodeSVG).apply(this, arguments));
  }

  _createClass(QRCodeSVG, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          value = _this$props3.value,
          size = _this$props3.size,
          level = _this$props3.level,
          bgColor = _this$props3.bgColor,
          fgColor = _this$props3.fgColor,
          includeMargin = _this$props3.includeMargin,
          imageSettings = _this$props3.imageSettings,
          otherProps = _objectWithoutProperties(_this$props3, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]); // We'll use type===-1 to force QRCode to automatically pick the best type


      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();
      var cells = qrcode.modules;

      if (cells === null) {
        return null;
      }

      var margin = includeMargin ? MARGIN_SIZE : 0;
      var numCells = cells.length + margin * 2;
      var calculatedImageSettings = getImageSettings(this.props, cells);
      var image = null;

      if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }

        image = React.createElement("image", {
          xlinkHref: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none"
        });
      } // Drawing strategy: instead of a rect per module, we're going to create a
      // single path for the dark modules and layer that on top of a light rect,
      // for a total of 2 DOM nodes. We pay a bit more in string concat but that's
      // way faster than DOM ops.
      // For level 1, 441 nodes -> 2
      // For level 40, 31329 -> 2


      var fgPath = generatePath(cells, margin);
      return React.createElement("svg", _extends({
        shapeRendering: "crispEdges",
        height: size,
        width: size,
        viewBox: "0 0 ".concat(numCells, " ").concat(numCells)
      }, otherProps), React.createElement("path", {
        fill: bgColor,
        d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")
      }), React.createElement("path", {
        fill: fgColor,
        d: fgPath
      }), image);
    }
  }]);

  return QRCodeSVG;
}(React.PureComponent);

_defineProperty(QRCodeSVG, "defaultProps", DEFAULT_PROPS);

if ("development" !== 'production') {
  QRCodeSVG.propTypes = PROP_TYPES;
}

var QRCode = function QRCode(props) {
  var renderAs = props.renderAs,
      otherProps = _objectWithoutProperties(props, ["renderAs"]);

  var Component = renderAs === 'svg' ? QRCodeSVG : QRCodeCanvas;
  return React.createElement(Component, otherProps);
};

QRCode.defaultProps = _objectSpread({
  renderAs: 'canvas'
}, DEFAULT_PROPS);
module.exports = QRCode;
      };
    };
  }
  }
}, {package:"qrcode.react",file:"node_modules\\qrcode.react\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\react-clientside-effect\\lib\\index.js", {"@babel/runtime/helpers/defineProperty":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/inheritsLoose":"F:\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","react":"F:\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Creact-clientside-effect%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var React = require('react');
var React__default = _interopDefault(React);

function withSideEffect(reducePropsToState, handleStateChangeOnClient) {
  if ("development" !== "production") {
    if (typeof reducePropsToState !== 'function') {
      throw new Error('Expected reducePropsToState to be a function.');
    }

    if (typeof handleStateChangeOnClient !== 'function') {
      throw new Error('Expected handleStateChangeOnClient to be a function.');
    }
  }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }

  return function wrap(WrappedComponent) {
    if ("development" !== "production") {
      if (typeof WrappedComponent !== 'function') {
        throw new Error('Expected WrappedComponent to be a React component.');
      }
    }

    var mountedInstances = [];
    var state;

    function emitChange() {
      state = reducePropsToState(mountedInstances.map(function (instance) {
        return instance.props;
      }));
      handleStateChangeOnClient(state);
    }

    var SideEffect = /*#__PURE__*/function (_PureComponent) {
      _inheritsLoose(SideEffect, _PureComponent);

      function SideEffect() {
        return _PureComponent.apply(this, arguments) || this;
      }

      // Try to use displayName of wrapped component
      SideEffect.peek = function peek() {
        return state;
      };

      var _proto = SideEffect.prototype;

      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        var index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      };

      _proto.render = function render() {
        return /*#__PURE__*/React__default.createElement(WrappedComponent, this.props);
      };

      return SideEffect;
    }(React.PureComponent);

    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");

    return SideEffect;
  };
}

module.exports = withSideEffect;

      };
    };
  }
  }
}, {package:"react-focus-lock>react-clientside-effect",file:"node_modules\\react-clientside-effect\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\react-devtools-core\\backend.js", {"./dist/backend":"F:\\metamask-extension\\node_modules\\react-devtools-core\\dist\\backend.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Creact-devtools-core%5Cbackend.js
      return function (require, module, exports) {
module.exports = require('./dist/backend');

      };
    };
  }
  }
}, {package:"react-devtools>react-devtools-core",file:"node_modules\\react-devtools-core\\backend.js",}],
["F:\\metamask-extension\\node_modules\\react-devtools-core\\dist\\backend.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Creact-devtools-core%5Cdist%5Cbackend.js
      return function (require, module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReactDevToolsBackend"] = factory();
	else
		root["ReactDevToolsBackend"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 28);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export alphaSortKeys */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getAllEnumerableKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getWrappedDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getUID; });
/* unused harmony export utfDecodeString */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return utfEncodeString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return printOperationsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getDefaultComponentFilters; });
/* unused harmony export getSavedComponentFilters */
/* unused harmony export setSavedComponentFilters */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return castBool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return castBrowserTheme; });
/* unused harmony export getAppendComponentStack */
/* unused harmony export getBreakOnConsoleErrors */
/* unused harmony export getHideConsoleLogsInStrictMode */
/* unused harmony export getShowInlineWarningsAndErrors */
/* unused harmony export getDefaultOpenInEditorURL */
/* unused harmony export getOpenInEditorURL */
/* unused harmony export separateDisplayNameAndHOCs */
/* unused harmony export shallowDiffers */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return deletePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return renamePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return setInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getDisplayNameForReactElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return formatDataForPreview; });
/* unused harmony export isPlainObject */
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5);
/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









// $FlowFixMe[method-unbinding]
var hasOwnProperty = Object.prototype.hasOwnProperty;
var cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.
// Try to reuse the already encoded strings.

var encodedStringCache = new lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a({
  max: 1000
});
function alphaSortKeys(a, b) {
  if (a.toString() > b.toString()) {
    return 1;
  } else if (b.toString() > a.toString()) {
    return -1;
  } else {
    return 0;
  }
}
function getAllEnumerableKeys(obj) {
  var keys = new Set();
  var current = obj;

  var _loop = function _loop() {
    var currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));
    var descriptors = Object.getOwnPropertyDescriptors(current);
    currentKeys.forEach(function (key) {
      // $FlowFixMe[incompatible-type]: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor
      if (descriptors[key].enumerable) {
        keys.add(key);
      }
    });
    current = Object.getPrototypeOf(current);
  };

  while (current != null) {
    _loop();
  }

  return keys;
} // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37

function getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {
  var displayName = outerType.displayName;
  return displayName || "".concat(wrapperName, "(").concat(getDisplayName(innerType, fallbackName), ")");
}
function getDisplayName(type) {
  var fallbackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Anonymous';
  var nameFromCache = cachedDisplayNames.get(type);

  if (nameFromCache != null) {
    return nameFromCache;
  }

  var displayName = fallbackName; // The displayName property is not guaranteed to be a string.
  // It's only safe to use for our purposes if it's a string.
  // github.com/facebook/react-devtools/issues/803

  if (typeof type.displayName === 'string') {
    displayName = type.displayName;
  } else if (typeof type.name === 'string' && type.name !== '') {
    displayName = type.name;
  }

  cachedDisplayNames.set(type, displayName);
  return displayName;
}
var uidCounter = 0;
function getUID() {
  return ++uidCounter;
}
function utfDecodeString(array) {
  // Avoid spreading the array (e.g. String.fromCodePoint(...array))
  // Functions arguments are first placed on the stack before the function is called
  // which throws a RangeError for large arrays.
  // See github.com/facebook/react/issues/22293
  var string = '';

  for (var i = 0; i < array.length; i++) {
    var char = array[i];
    string += String.fromCodePoint(char);
  }

  return string;
}

function surrogatePairToCodePoint(charCode1, charCode2) {
  return ((charCode1 & 0x3ff) << 10) + (charCode2 & 0x3ff) + 0x10000;
} // Credit for this encoding approach goes to Tim Down:
// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript


function utfEncodeString(string) {
  var cached = encodedStringCache.get(string);

  if (cached !== undefined) {
    return cached;
  }

  var encoded = [];
  var i = 0;
  var charCode;

  while (i < string.length) {
    charCode = string.charCodeAt(i); // Handle multibyte unicode characters (like emoji).

    if ((charCode & 0xf800) === 0xd800) {
      encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));
    } else {
      encoded.push(charCode);
    }

    ++i;
  }

  encodedStringCache.set(string, encoded);
  return encoded;
}
function printOperationsArray(operations) {
  // The first two values are always rendererID and rootID
  var rendererID = operations[0];
  var rootID = operations[1];
  var logs = ["operations for renderer:".concat(rendererID, " and root:").concat(rootID)];
  var i = 2; // Reassemble the string table.

  var stringTable = [null // ID = 0 corresponds to the null string.
  ];
  var stringTableSize = operations[i++];
  var stringTableEnd = i + stringTableSize;

  while (i < stringTableEnd) {
    var nextLength = operations[i++];
    var nextString = utfDecodeString(operations.slice(i, i + nextLength));
    stringTable.push(nextString);
    i += nextLength;
  }

  while (i < operations.length) {
    var operation = operations[i];

    switch (operation) {
      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_ADD */ "l"]:
        {
          var _id = operations[i + 1];
          var type = operations[i + 2];
          i += 3;

          if (type === _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeRoot */ "m"]) {
            logs.push("Add new root node ".concat(_id));
            i++; // isStrictModeCompliant

            i++; // supportsProfiling

            i++; // supportsStrictMode

            i++; // hasOwnerMetadata
          } else {
            var parentID = operations[i];
            i++;
            i++; // ownerID

            var displayNameStringID = operations[i];
            var displayName = stringTable[displayNameStringID];
            i++;
            i++; // key

            logs.push("Add node ".concat(_id, " (").concat(displayName || 'null', ") as child of ").concat(parentID));
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REMOVE */ "m"]:
        {
          var removeLength = operations[i + 1];
          i += 2;

          for (var removeIndex = 0; removeIndex < removeLength; removeIndex++) {
            var _id2 = operations[i];
            i += 1;
            logs.push("Remove node ".concat(_id2));
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REMOVE_ROOT */ "n"]:
        {
          i += 1;
          logs.push("Remove root ".concat(rootID));
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_SET_SUBTREE_MODE */ "p"]:
        {
          var _id3 = operations[i + 1];
          var mode = operations[i + 1];
          i += 3;
          logs.push("Mode ".concat(mode, " set for subtree with root ").concat(_id3));
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REORDER_CHILDREN */ "o"]:
        {
          var _id4 = operations[i + 1];
          var numChildren = operations[i + 2];
          i += 3;
          var children = operations.slice(i, i + numChildren);
          i += numChildren;
          logs.push("Re-order node ".concat(_id4, " children ").concat(children.join(',')));
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */ "r"]:
        // Base duration updates are only sent while profiling is in progress.
        // We can ignore them at this point.
        // The profiler UI uses them lazily in order to generate the tree.
        i += 3;
        break;

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS */ "q"]:
        var id = operations[i + 1];
        var numErrors = operations[i + 2];
        var numWarnings = operations[i + 3];
        i += 4;
        logs.push("Node ".concat(id, " has ").concat(numErrors, " errors and ").concat(numWarnings, " warnings"));
        break;

      default:
        throw Error("Unsupported Bridge operation \"".concat(operation, "\""));
    }
  }

  console.log(logs.join('\n  '));
}
function getDefaultComponentFilters() {
  return [{
    type: _types__WEBPACK_IMPORTED_MODULE_4__[/* ComponentFilterElementType */ "b"],
    value: _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeHostComponent */ "i"],
    isEnabled: true
  }];
}
function getSavedComponentFilters() {
  try {
    var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY */ "a"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return getDefaultComponentFilters();
}
function setSavedComponentFilters(componentFilters) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY */ "a"], JSON.stringify(componentFilters));
}

function parseBool(s) {
  if (s === 'true') {
    return true;
  }

  if (s === 'false') {
    return false;
  }
}

function castBool(v) {
  if (v === true || v === false) {
    return v;
  }
}
function castBrowserTheme(v) {
  if (v === 'light' || v === 'dark' || v === 'auto') {
    return v;
  }
}
function getAppendComponentStack() {
  var _parseBool;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY */ "d"]);
  return (_parseBool = parseBool(raw)) !== null && _parseBool !== void 0 ? _parseBool : true;
}
function getBreakOnConsoleErrors() {
  var _parseBool2;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */ "e"]);
  return (_parseBool2 = parseBool(raw)) !== null && _parseBool2 !== void 0 ? _parseBool2 : false;
}
function getHideConsoleLogsInStrictMode() {
  var _parseBool3;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE */ "b"]);
  return (_parseBool3 = parseBool(raw)) !== null && _parseBool3 !== void 0 ? _parseBool3 : false;
}
function getShowInlineWarningsAndErrors() {
  var _parseBool4;

  var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY */ "f"]);
  return (_parseBool4 = parseBool(raw)) !== null && _parseBool4 !== void 0 ? _parseBool4 : true;
}
function getDefaultOpenInEditorURL() {
  return typeof "" === 'string' ? "" : '';
}
function getOpenInEditorURL() {
  try {
    var raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_OPEN_IN_EDITOR_URL */ "c"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return getDefaultOpenInEditorURL();
}
function separateDisplayNameAndHOCs(displayName, type) {
  if (displayName === null) {
    return [null, null];
  }

  var hocDisplayNames = null;

  switch (type) {
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeClass */ "e"]:
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeForwardRef */ "g"]:
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeFunction */ "h"]:
    case _types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeMemo */ "j"]:
      if (displayName.indexOf('(') >= 0) {
        var matches = displayName.match(/[^()]+/g);

        if (matches != null) {
          displayName = matches.pop();
          hocDisplayNames = matches;
        }
      }

      break;

    default:
      break;
  }

  return [displayName, hocDisplayNames];
} // Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349

function shallowDiffers(prev, next) {
  for (var attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (var _attribute in next) {
    if (prev[_attribute] !== next[_attribute]) {
      return true;
    }
  }

  return false;
}
function getInObject(object, path) {
  return path.reduce(function (reduced, attr) {
    if (reduced) {
      if (hasOwnProperty.call(reduced, attr)) {
        return reduced[attr];
      }

      if (typeof reduced[Symbol.iterator] === 'function') {
        // Convert iterable to array and return array[index]
        //
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        return Array.from(reduced)[attr];
      }
    }

    return null;
  }, object);
}
function deletePathInObject(object, path) {
  var length = path.length;
  var last = path[length - 1];

  if (object != null) {
    var parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(parent)) {
        parent.splice(last, 1);
      } else {
        delete parent[last];
      }
    }
  }
}
function renamePathInObject(object, oldPath, newPath) {
  var length = oldPath.length;

  if (object != null) {
    var parent = getInObject(object, oldPath.slice(0, length - 1));

    if (parent) {
      var lastOld = oldPath[length - 1];
      var lastNew = newPath[length - 1];
      parent[lastNew] = parent[lastOld];

      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(parent)) {
        parent.splice(lastOld, 1);
      } else {
        delete parent[lastOld];
      }
    }
  }
}
function setInObject(object, path, value) {
  var length = path.length;
  var last = path[length - 1];

  if (object != null) {
    var parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      parent[last] = value;
    }
  }
}

/**
 * Get a enhanced/artificial type string based on the object instance
 */
function getDataType(data) {
  if (data === null) {
    return 'null';
  } else if (data === undefined) {
    return 'undefined';
  }

  if (Object(react_is__WEBPACK_IMPORTED_MODULE_1__["isElement"])(data)) {
    return 'react_element';
  }

  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {
    return 'html_element';
  }

  var type = _typeof(data);

  switch (type) {
    case 'bigint':
      return 'bigint';

    case 'boolean':
      return 'boolean';

    case 'function':
      return 'function';

    case 'number':
      if (Number.isNaN(data)) {
        return 'nan';
      } else if (!Number.isFinite(data)) {
        return 'infinity';
      } else {
        return 'number';
      }

    case 'object':
      if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(data)) {
        return 'array';
      } else if (ArrayBuffer.isView(data)) {
        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';
      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {
        // HACK This ArrayBuffer check is gross; is there a better way?
        // We could try to create a new DataView with the value.
        // If it doesn't error, we know it's an ArrayBuffer,
        // but this seems kind of awkward and expensive.
        return 'array_buffer';
      } else if (typeof data[Symbol.iterator] === 'function') {
        var iterator = data[Symbol.iterator]();

        if (!iterator) {// Proxies might break assumptoins about iterators.
          // See github.com/facebook/react/issues/21654
        } else {
          return iterator === data ? 'opaque_iterator' : 'iterator';
        }
      } else if (data.constructor && data.constructor.name === 'RegExp') {
        return 'regexp';
      } else {
        // $FlowFixMe[method-unbinding]
        var toStringValue = Object.prototype.toString.call(data);

        if (toStringValue === '[object Date]') {
          return 'date';
        } else if (toStringValue === '[object HTMLAllCollection]') {
          return 'html_all_collection';
        }
      }

      if (!isPlainObject(data)) {
        return 'class_instance';
      }

      return 'object';

    case 'string':
      return 'string';

    case 'symbol':
      return 'symbol';

    case 'undefined':
      if ( // $FlowFixMe[method-unbinding]
      Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {
        return 'html_all_collection';
      }

      return 'undefined';

    default:
      return 'unknown';
  }
}
function getDisplayNameForReactElement(element) {
  var elementType = Object(react_is__WEBPACK_IMPORTED_MODULE_1__["typeOf"])(element);

  switch (elementType) {
    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextConsumer"]:
      return 'ContextConsumer';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextProvider"]:
      return 'ContextProvider';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ForwardRef"]:
      return 'ForwardRef';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Fragment"]:
      return 'Fragment';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Lazy"]:
      return 'Lazy';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Memo"]:
      return 'Memo';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Portal"]:
      return 'Portal';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Profiler"]:
      return 'Profiler';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["StrictMode"]:
      return 'StrictMode';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Suspense"]:
      return 'Suspense';

    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__[/* REACT_SUSPENSE_LIST_TYPE */ "a"]:
      return 'SuspenseList';

    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__[/* REACT_TRACING_MARKER_TYPE */ "b"]:
      return 'TracingMarker';

    default:
      var type = element.type;

      if (typeof type === 'string') {
        return type;
      } else if (typeof type === 'function') {
        return getDisplayName(type, 'Anonymous');
      } else if (type != null) {
        return 'NotImplementedInDevtools';
      } else {
        return 'Element';
      }

  }
}
var MAX_PREVIEW_STRING_LENGTH = 50;

function truncateForDisplay(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;

  if (string.length > length) {
    return string.slice(0, length) + '…';
  } else {
    return string;
  }
} // Attempts to mimic Chrome's inline preview for values.
// For example, the following value...
//   {
//      foo: 123,
//      bar: "abc",
//      baz: [true, false],
//      qux: { ab: 1, cd: 2 }
//   };
//
// Would show a preview of...
//   {foo: 123, bar: "abc", baz: Array(2), qux: {…}}
//
// And the following value...
//   [
//     123,
//     "abc",
//     [true, false],
//     { foo: 123, bar: "abc" }
//   ];
//
// Would show a preview of...
//   [123, "abc", Array(2), {…}]


function formatDataForPreview(data, showFormattedValue) {
  if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].type)) {
    return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].preview_short];
  }

  var type = getDataType(data);

  switch (type) {
    case 'html_element':
      return "<".concat(truncateForDisplay(data.tagName.toLowerCase()), " />");

    case 'function':
      return truncateForDisplay("\u0192 ".concat(typeof data.name === 'function' ? '' : data.name, "() {}"));

    case 'string':
      return "\"".concat(data, "\"");

    case 'bigint':
      return truncateForDisplay(data.toString() + 'n');

    case 'regexp':
      return truncateForDisplay(data.toString());

    case 'symbol':
      return truncateForDisplay(data.toString());

    case 'react_element':
      return "<".concat(truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown'), " />");

    case 'array_buffer':
      return "ArrayBuffer(".concat(data.byteLength, ")");

    case 'data_view':
      return "DataView(".concat(data.buffer.byteLength, ")");

    case 'array':
      if (showFormattedValue) {
        var formatted = '';

        for (var i = 0; i < data.length; i++) {
          if (i > 0) {
            formatted += ', ';
          }

          formatted += formatDataForPreview(data[i], false);

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "[".concat(truncateForDisplay(formatted), "]");
      } else {
        var length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "b"].size] : data.length;
        return "Array(".concat(length, ")");
      }

    case 'typed_array':
      var shortName = "".concat(data.constructor.name, "(").concat(data.length, ")");

      if (showFormattedValue) {
        var _formatted = '';

        for (var _i = 0; _i < data.length; _i++) {
          if (_i > 0) {
            _formatted += ', ';
          }

          _formatted += data[_i];

          if (_formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "".concat(shortName, " [").concat(truncateForDisplay(_formatted), "]");
      } else {
        return shortName;
      }

    case 'iterator':
      var name = data.constructor.name;

      if (showFormattedValue) {
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        var array = Array.from(data);
        var _formatted2 = '';

        for (var _i2 = 0; _i2 < array.length; _i2++) {
          var entryOrEntries = array[_i2];

          if (_i2 > 0) {
            _formatted2 += ', ';
          } // TRICKY
          // Browsers display Maps and Sets differently.
          // To mimic their behavior, detect if we've been given an entries tuple.
          //   Map(2) {"abc" => 123, "def" => 123}
          //   Set(2) {"abc", 123}


          if (Object(_isArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(entryOrEntries)) {
            var key = formatDataForPreview(entryOrEntries[0], true);
            var value = formatDataForPreview(entryOrEntries[1], false);
            _formatted2 += "".concat(key, " => ").concat(value);
          } else {
            _formatted2 += formatDataForPreview(entryOrEntries, false);
          }

          if (_formatted2.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "".concat(name, "(").concat(data.size, ") {").concat(truncateForDisplay(_formatted2), "}");
      } else {
        return "".concat(name, "(").concat(data.size, ")");
      }

    case 'opaque_iterator':
      {
        return data[Symbol.toStringTag];
      }

    case 'date':
      return data.toString();

    case 'class_instance':
      return data.constructor.name;

    case 'object':
      if (showFormattedValue) {
        var keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);
        var _formatted3 = '';

        for (var _i3 = 0; _i3 < keys.length; _i3++) {
          var _key = keys[_i3];

          if (_i3 > 0) {
            _formatted3 += ', ';
          }

          _formatted3 += "".concat(_key.toString(), ": ").concat(formatDataForPreview(data[_key], false));

          if (_formatted3.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "{".concat(truncateForDisplay(_formatted3), "}");
      } else {
        return '{…}';
      }

    case 'boolean':
    case 'number':
    case 'infinity':
    case 'nan':
    case 'null':
    case 'undefined':
      return data;

    default:
      try {
        return truncateForDisplay(String(data));
      } catch (error) {
        return 'unserializable';
      }

  }
} // Basically checking that the object only has Object in its prototype chain

var isPlainObject = function isPlainObject(object) {
  var objectPrototype = Object.getPrototypeOf(object);
  if (!objectPrototype) return true;
  var objectParentPrototype = Object.getPrototypeOf(objectPrototype);
  return !objectParentPrototype;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(19)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ElementTypeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ElementTypeContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ElementTypeFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return ElementTypeForwardRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return ElementTypeHostComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return ElementTypeMemo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return ElementTypeOtherOrUnknown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return ElementTypeProfiler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return ElementTypeRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return ElementTypeSuspense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return ElementTypeSuspenseList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return ElementTypeTracingMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ComponentFilterElementType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ComponentFilterDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ComponentFilterLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ComponentFilterHOC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return StrictMode; });
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * WARNING:
 * This file contains types that are designed for React DevTools UI and how it interacts with the backend.
 * They might be used in different versions of DevTools backends.
 * Be mindful of backwards compatibility when making changes.
 */
// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new element types are added, use new numbers rather than re-ordering existing ones.
//
// Changing these types is also a backwards breaking change for the standalone shell,
// since the frontend and backend must share the same values-
// and the backend is embedded in certain environments (like React Native).
var ElementTypeClass = 1;
var ElementTypeContext = 2;
var ElementTypeFunction = 5;
var ElementTypeForwardRef = 6;
var ElementTypeHostComponent = 7;
var ElementTypeMemo = 8;
var ElementTypeOtherOrUnknown = 9;
var ElementTypeProfiler = 10;
var ElementTypeRoot = 11;
var ElementTypeSuspense = 12;
var ElementTypeSuspenseList = 13;
var ElementTypeTracingMarker = 14; // Different types of elements displayed in the Elements tree.
// These types may be used to visually distinguish types,
// or to enable/disable certain functionality.

// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new filter types are added, use new numbers rather than re-ordering existing ones.
var ComponentFilterElementType = 1;
var ComponentFilterDisplayName = 2;
var ComponentFilterLocation = 3;
var ComponentFilterHOC = 4;
var StrictMode = 1;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CHROME_WEBSTORE_EXTENSION_ID */
/* unused harmony export INTERNAL_EXTENSION_ID */
/* unused harmony export LOCAL_EXTENSION_ID */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __DEBUG__; });
/* unused harmony export __PERFORMANCE_PROFILE__ */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return TREE_OPERATION_ADD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return TREE_OPERATION_REMOVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return TREE_OPERATION_REORDER_CHILDREN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return TREE_OPERATION_UPDATE_TREE_BASE_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return TREE_OPERATION_REMOVE_ROOT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return TREE_OPERATION_SET_SUBTREE_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return PROFILING_FLAG_BASIC_SUPPORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return PROFILING_FLAG_TIMELINE_SUPPORT; });
/* unused harmony export LOCAL_STORAGE_DEFAULT_TAB_KEY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SESSION_STORAGE_LAST_SELECTION_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return LOCAL_STORAGE_OPEN_IN_EDITOR_URL; });
/* unused harmony export LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return SESSION_STORAGE_RELOAD_AND_PROFILE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS; });
/* unused harmony export LOCAL_STORAGE_BROWSER_THEME */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY; });
/* unused harmony export LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE; });
/* unused harmony export PROFILER_EXPORT_VERSION */
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var CHROME_WEBSTORE_EXTENSION_ID = 'fmkadmapgofadopljbjfkapdkoienihi';
var INTERNAL_EXTENSION_ID = 'dnjnjgbfilfphmojnmhliehogmojhclc';
var LOCAL_EXTENSION_ID = 'ikiahnapldjmdmpkmfhjdjilojjhgcbf'; // Flip this flag to true to enable verbose console debug logging.

var __DEBUG__ = false; // Flip this flag to true to enable performance.mark() and performance.measure() timings.

var __PERFORMANCE_PROFILE__ = false;
var TREE_OPERATION_ADD = 1;
var TREE_OPERATION_REMOVE = 2;
var TREE_OPERATION_REORDER_CHILDREN = 3;
var TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;
var TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;
var TREE_OPERATION_REMOVE_ROOT = 6;
var TREE_OPERATION_SET_SUBTREE_MODE = 7;
var PROFILING_FLAG_BASIC_SUPPORT = 1;
var PROFILING_FLAG_TIMELINE_SUPPORT = 2;
var LOCAL_STORAGE_DEFAULT_TAB_KEY = 'React::DevTools::defaultTab';
var LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';
var SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';
var LOCAL_STORAGE_OPEN_IN_EDITOR_URL = 'React::DevTools::openInEditorUrl';
var LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';
var SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';
var SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';
var LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';
var LOCAL_STORAGE_BROWSER_THEME = 'React::DevTools::theme';
var LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY = 'React::DevTools::appendComponentStack';
var LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = 'React::DevTools::showInlineWarningsAndErrors';
var LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';
var LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE = 'React::DevTools::hideConsoleLogsInStrictMode';
var PROFILER_EXPORT_VERSION = 5;

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CONCURRENT_MODE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CONCURRENT_MODE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return CONTEXT_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return CONTEXT_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return SERVER_CONTEXT_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return DEPRECATED_ASYNC_MODE_SYMBOL_STRING; });
/* unused harmony export ELEMENT_NUMBER */
/* unused harmony export ELEMENT_SYMBOL_STRING */
/* unused harmony export DEBUG_TRACING_MODE_NUMBER */
/* unused harmony export DEBUG_TRACING_MODE_SYMBOL_STRING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return FORWARD_REF_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return FORWARD_REF_SYMBOL_STRING; });
/* unused harmony export FRAGMENT_NUMBER */
/* unused harmony export FRAGMENT_SYMBOL_STRING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return LAZY_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return LAZY_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return MEMO_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return MEMO_SYMBOL_STRING; });
/* unused harmony export PORTAL_NUMBER */
/* unused harmony export PORTAL_SYMBOL_STRING */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return PROFILER_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return PROFILER_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return PROVIDER_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return PROVIDER_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return SCOPE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return SCOPE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return STRICT_MODE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return STRICT_MODE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return SUSPENSE_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return SUSPENSE_SYMBOL_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return SUSPENSE_LIST_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return SUSPENSE_LIST_SYMBOL_STRING; });
/* unused harmony export SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING */
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.
// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:
// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)
// 2. DevTools must support both Symbol and numeric forms of each symbol;
//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.
var CONCURRENT_MODE_NUMBER = 0xeacf;
var CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';
var CONTEXT_NUMBER = 0xeace;
var CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';
var SERVER_CONTEXT_SYMBOL_STRING = 'Symbol(react.server_context)';
var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';
var ELEMENT_NUMBER = 0xeac7;
var ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';
var DEBUG_TRACING_MODE_NUMBER = 0xeae1;
var DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';
var FORWARD_REF_NUMBER = 0xead0;
var FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';
var FRAGMENT_NUMBER = 0xeacb;
var FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';
var LAZY_NUMBER = 0xead4;
var LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';
var MEMO_NUMBER = 0xead3;
var MEMO_SYMBOL_STRING = 'Symbol(react.memo)';
var PORTAL_NUMBER = 0xeaca;
var PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';
var PROFILER_NUMBER = 0xead2;
var PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';
var PROVIDER_NUMBER = 0xeacd;
var PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';
var SCOPE_NUMBER = 0xead7;
var SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';
var STRICT_MODE_NUMBER = 0xeacc;
var STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';
var SUSPENSE_NUMBER = 0xead1;
var SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';
var SUSPENSE_LIST_NUMBER = 0xead8;
var SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';
var SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = 'Symbol(react.server_context.defaultValue)';

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ hasAssignedBackend; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ cleanForBridge; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ copyWithDelete; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ copyWithRename; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ copyWithSet; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ getEffectDurations; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ serializeToString; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ formatWithStyles; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ format; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ isSynchronousXHRSupported; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ gt; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ gte; });

// CONCATENATED MODULE: /Users/hoxy/repos/react/node_modules/compare-versions/lib/esm/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.
 * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.
 * @param v1 - First version to compare
 * @param v2 - Second version to compare
 * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).
 */
var compareVersions = function compareVersions(v1, v2) {
  // validate input and split into segments
  var n1 = validateAndParse(v1);
  var n2 = validateAndParse(v2); // pop off the patch

  var p1 = n1.pop();
  var p2 = n2.pop(); // validate numbers

  var r = compareSegments(n1, n2);
  if (r !== 0) return r; // validate pre-release

  if (p1 && p2) {
    return compareSegments(p1.split('.'), p2.split('.'));
  } else if (p1 || p2) {
    return p1 ? -1 : 1;
  }

  return 0;
};
/**
 * Validate [semver](https://semver.org/) version strings.
 *
 * @param version Version number to validate
 * @returns `true` if the version number is a valid semver version number, `false` otherwise.
 *
 * @example
 * ```
 * validate('1.0.0-rc.1'); // return true
 * validate('1.0-rc.1'); // return false
 * validate('foo'); // return false
 * ```
 */

var validate = function validate(version) {
  return typeof version === 'string' && /^[v\d]/.test(version) && semver.test(version);
};
/**
 * Compare [semver](https://semver.org/) version strings using the specified operator.
 *
 * @param v1 First version to compare
 * @param v2 Second version to compare
 * @param operator Allowed arithmetic operator to use
 * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.
 *
 * @example
 * ```
 * compare('10.1.8', '10.0.4', '>'); // return true
 * compare('10.0.1', '10.0.1', '='); // return true
 * compare('10.1.1', '10.2.2', '<'); // return true
 * compare('10.1.1', '10.2.2', '<='); // return true
 * compare('10.1.1', '10.2.2', '>='); // return false
 * ```
 */

var compare = function compare(v1, v2, operator) {
  // validate input operator
  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1
  // a simple map can be used to replace switch

  var res = compareVersions(v1, v2);
  return operatorResMap[operator].includes(res);
};
/**
 * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.
 *
 * @param version Version number to match
 * @param range Range pattern for version
 * @returns `true` if the version number is within the range, `false` otherwise.
 *
 * @example
 * ```
 * satisfies('1.1.0', '^1.0.0'); // return true
 * satisfies('1.1.0', '~1.0.0'); // return false
 * ```
 */

var satisfies = function satisfies(version, range) {
  // if no range operator then "="
  var m = range.match(/^([<>=~^]+)/);
  var op = m ? m[1] : '='; // if gt/lt/eq then operator compare

  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either "~" or "^" is assumed

  var _validateAndParse = validateAndParse(version),
      _validateAndParse2 = _slicedToArray(_validateAndParse, 5),
      v1 = _validateAndParse2[0],
      v2 = _validateAndParse2[1],
      v3 = _validateAndParse2[2],
      vp = _validateAndParse2[4];

  var _validateAndParse3 = validateAndParse(range),
      _validateAndParse4 = _slicedToArray(_validateAndParse3, 5),
      r1 = _validateAndParse4[0],
      r2 = _validateAndParse4[1],
      r3 = _validateAndParse4[2],
      rp = _validateAndParse4[4];

  var v = [v1, v2, v3];
  var r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x']; // validate pre-release

  if (rp) {
    if (!vp) return false;
    if (compareSegments(v, r) !== 0) return false;
    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;
  } // first non-zero number


  var nonZero = r.findIndex(function (v) {
    return v !== '0';
  }) + 1; // pointer to where segments can be >=

  var i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1; // before pointer must be equal

  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false; // after pointer must be >=

  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;
  return true;
};
var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;

var validateAndParse = function validateAndParse(version) {
  if (typeof version !== 'string') {
    throw new TypeError('Invalid argument expected string');
  }

  var match = version.match(semver);

  if (!match) {
    throw new Error("Invalid argument not valid semver ('".concat(version, "' received)"));
  }

  match.shift();
  return match;
};

var isWildcard = function isWildcard(s) {
  return s === '*' || s === 'x' || s === 'X';
};

var tryParse = function tryParse(v) {
  var n = parseInt(v, 10);
  return isNaN(n) ? v : n;
};

var forceType = function forceType(a, b) {
  return _typeof(a) !== _typeof(b) ? [String(a), String(b)] : [a, b];
};

var compareStrings = function compareStrings(a, b) {
  if (isWildcard(a) || isWildcard(b)) return 0;

  var _forceType = forceType(tryParse(a), tryParse(b)),
      _forceType2 = _slicedToArray(_forceType, 2),
      ap = _forceType2[0],
      bp = _forceType2[1];

  if (ap > bp) return 1;
  if (ap < bp) return -1;
  return 0;
};

var compareSegments = function compareSegments(a, b) {
  for (var i = 0; i < Math.max(a.length, b.length); i++) {
    var r = compareStrings(a[i] || '0', b[i] || '0');
    if (r !== 0) return r;
  }

  return 0;
};

var operatorResMap = {
  '>': [1],
  '>=': [0, 1],
  '=': [0],
  '<=': [-1, 0],
  '<': [-1]
};
var allowedOperators = Object.keys(operatorResMap);

var assertValidOperator = function assertValidOperator(op) {
  if (typeof op !== 'string') {
    throw new TypeError("Invalid operator type, expected string but got ".concat(_typeof(op)));
  }

  if (allowedOperators.indexOf(op) === -1) {
    throw new Error("Invalid operator, expected one of ".concat(allowedOperators.join('|')));
  }
};
// EXTERNAL MODULE: ../react-devtools-shared/src/hydration.js
var hydration = __webpack_require__(10);

// EXTERNAL MODULE: ../shared/isArray.js
var isArray = __webpack_require__(9);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/utils.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || utils_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return utils_arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return utils_arrayLikeToArray(arr); }

function utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// TODO: update this to the first React version that has a corresponding DevTools backend
var FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = '999.9.9';
function hasAssignedBackend(version) {
  if (version == null || version === '') {
    return false;
  }

  return gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);
}
function cleanForBridge(data, isPathAllowed) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (data !== null) {
    var cleanedPaths = [];
    var unserializablePaths = [];
    var cleanedData = Object(hydration["a" /* dehydrate */])(data, cleanedPaths, unserializablePaths, path, isPathAllowed);
    return {
      data: cleanedData,
      cleaned: cleanedPaths,
      unserializable: unserializablePaths
    };
  } else {
    return null;
  }
}
function copyWithDelete(obj, path) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var key = path[index];
  var updated = Object(isArray["a" /* default */])(obj) ? obj.slice() : _objectSpread({}, obj);

  if (index + 1 === path.length) {
    if (Object(isArray["a" /* default */])(updated)) {
      updated.splice(key, 1);
    } else {
      delete updated[key];
    }
  } else {
    // $FlowFixMe[incompatible-use] number or string is fine here
    updated[key] = copyWithDelete(obj[key], path, index + 1);
  }

  return updated;
} // This function expects paths to be the same except for the final value.
// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']

function copyWithRename(obj, oldPath, newPath) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var oldKey = oldPath[index];
  var updated = Object(isArray["a" /* default */])(obj) ? obj.slice() : _objectSpread({}, obj);

  if (index + 1 === oldPath.length) {
    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here

    updated[newKey] = updated[oldKey];

    if (Object(isArray["a" /* default */])(updated)) {
      updated.splice(oldKey, 1);
    } else {
      delete updated[oldKey];
    }
  } else {
    // $FlowFixMe[incompatible-use] number or string is fine here
    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);
  }

  return updated;
}
function copyWithSet(obj, path, value) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (index >= path.length) {
    return value;
  }

  var key = path[index];
  var updated = Object(isArray["a" /* default */])(obj) ? obj.slice() : _objectSpread({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here

  updated[key] = copyWithSet(obj[key], path, value, index + 1);
  return updated;
}
function getEffectDurations(root) {
  // Profiling durations are only available for certain builds.
  // If available, they'll be stored on the HostRoot.
  var effectDuration = null;
  var passiveEffectDuration = null;
  var hostRoot = root.current;

  if (hostRoot != null) {
    var stateNode = hostRoot.stateNode;

    if (stateNode != null) {
      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;
      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;
    }
  }

  return {
    effectDuration: effectDuration,
    passiveEffectDuration: passiveEffectDuration
  };
}
function serializeToString(data) {
  if (data === undefined) {
    return 'undefined';
  }

  var cache = new Set(); // Use a custom replacer function to protect against circular references.

  return JSON.stringify(data, function (key, value) {
    if (utils_typeof(value) === 'object' && value !== null) {
      if (cache.has(value)) {
        return;
      }

      cache.add(value);
    }

    if (typeof value === 'bigint') {
      return value.toString() + 'n';
    }

    return value;
  }, 2);
} // Formats an array of args with a style for console methods, using
// the following algorithm:
//     1. The first param is a string that contains %c
//          - Bail out and return the args without modifying the styles.
//            We don't want to affect styles that the developer deliberately set.
//     2. The first param is a string that doesn't contain %c but contains
//        string formatting
//          - [`%c${args[0]}`, style, ...args.slice(1)]
//          - Note: we assume that the string formatting that the developer uses
//            is correct.
//     3. The first param is a string that doesn't contain string formatting
//        OR is not a string
//          - Create a formatting string where:
//                 boolean, string, symbol -> %s
//                 number -> %f OR %i depending on if it's an int or float
//                 default -> %o

function formatWithStyles(inputArgs, style) {
  if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c
  typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {
    return inputArgs;
  } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)


  var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;

  if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {
    return ["%c".concat(inputArgs[0]), style].concat(_toConsumableArray(inputArgs.slice(1)));
  } else {
    var firstArg = inputArgs.reduce(function (formatStr, elem, i) {
      if (i > 0) {
        formatStr += ' ';
      }

      switch (utils_typeof(elem)) {
        case 'string':
        case 'boolean':
        case 'symbol':
          return formatStr += '%s';

        case 'number':
          var formatting = Number.isInteger(elem) ? '%i' : '%f';
          return formatStr += formatting;

        default:
          return formatStr += '%o';
      }
    }, '%c');
    return [firstArg, style].concat(_toConsumableArray(inputArgs));
  }
} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1
// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions
// Implements s, d, i and f placeholders
// NOTE: KEEP IN SYNC with src/hook.js

function format(maybeMessage) {
  for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    inputArgs[_key - 1] = arguments[_key];
  }

  var args = inputArgs.slice();
  var formatted = String(maybeMessage); // If the first argument is a string, check for substitutions.

  if (typeof maybeMessage === 'string') {
    if (args.length) {
      var REGEXP = /(%?)(%([jds]))/g;
      formatted = formatted.replace(REGEXP, function (match, escaped, ptn, flag) {
        var arg = args.shift();

        switch (flag) {
          case 's':
            arg += '';
            break;

          case 'd':
          case 'i':
            arg = parseInt(arg, 10).toString();
            break;

          case 'f':
            arg = parseFloat(arg).toString();
            break;
        }

        if (!escaped) {
          return arg;
        }

        args.unshift(arg);
        return match;
      });
    }
  } // Arguments that remain after formatting.


  if (args.length) {
    for (var i = 0; i < args.length; i++) {
      formatted += ' ' + String(args[i]);
    }
  } // Update escaped %% values.


  formatted = formatted.replace(/%{2,2}/g, '%');
  return String(formatted);
}
function isSynchronousXHRSupported() {
  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));
}
function gt() {
  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return compareVersions(a, b) === 1;
}
function gte() {
  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return compareVersions(a, b) > -1;
}

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return localStorageGetItem; });
/* unused harmony export localStorageRemoveItem */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return localStorageSetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sessionStorageGetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return sessionStorageRemoveItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return sessionStorageSetItem; });
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function localStorageGetItem(key) {
  try {
    return localStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function localStorageRemoveItem(key) {
  try {
    localStorage.removeItem(key);
  } catch (error) {}
}
function localStorageSetItem(key, value) {
  try {
    return localStorage.setItem(key, value);
  } catch (error) {}
}
function sessionStorageGetItem(key) {
  try {
    return sessionStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function sessionStorageRemoveItem(key) {
  try {
    sessionStorage.removeItem(key);
  } catch (error) {}
}
function sessionStorageSetItem(key, value) {
  try {
    return sessionStorage.setItem(key, value);
  } catch (error) {}
}

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isArray = Array.isArray;
/* harmony default export */ __webpack_exports__["a"] = (isArray);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(22);
} else {}

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export isStringComponentStack */
/* unused harmony export dangerous_setTargetConsoleForTesting */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return registerRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return patch; });
/* unused harmony export unpatch */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return patchForStrictMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return unpatchForStrictMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return patchConsoleUsingWindowValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return writeConsolePatchSettingsToWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return installConsoleFunctionsToWindow; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





var OVERRIDE_CONSOLE_METHODS = ['error', 'trace', 'warn'];
var DIMMED_NODE_CONSOLE_COLOR = '\x1b[2m%s\x1b[0m'; // React's custom built component stack strings match "\s{4}in"
// Chrome's prefix matches "\s{4}at"

var PREFIX_REGEX = /\s{4}(in|at)\s{1}/; // Firefox and Safari have no prefix ("")
// but we can fallback to looking for location info (e.g. "foo.js:12:345")

var ROW_COLUMN_NUMBER_REGEX = /:\d+:\d+(\n|$)/;
function isStringComponentStack(text) {
  return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);
}
var STYLE_DIRECTIVE_REGEX = /^%c/; // This function tells whether or not the arguments for a console
// method has been overridden by the patchForStrictMode function.
// If it has we'll need to do some special formatting of the arguments
// so the console color stays consistent

function isStrictModeOverride(args, method) {
  return args.length >= 2 && STYLE_DIRECTIVE_REGEX.test(args[0]) && args[1] === "color: ".concat(getConsoleColor(method) || '');
}

function getConsoleColor(method) {
  switch (method) {
    case 'warn':
      return consoleSettingsRef.browserTheme === 'light' ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";

    case 'error':
      return consoleSettingsRef.browserTheme === 'light' ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";

    case 'log':
    default:
      return consoleSettingsRef.browserTheme === 'light' ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)";
  }
}

var injectedRenderers = new Map();
var targetConsole = console;
var targetConsoleMethods = {};

for (var method in console) {
  targetConsoleMethods[method] = console[method];
}

var unpatchFn = null;
var isNode = false;

try {
  isNode = undefined === global;
} catch (error) {} // Enables e.g. Jest tests to inject a mock console object.


function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {
  targetConsole = targetConsoleForTesting;
  targetConsoleMethods = {};

  for (var _method in targetConsole) {
    targetConsoleMethods[_method] = console[_method];
  }
} // v16 renderers should use this method to inject internals necessary to generate a component stack.
// These internals will be used if the console is patched.
// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).

function registerRenderer(renderer, onErrorOrWarning) {
  var currentDispatcherRef = renderer.currentDispatcherRef,
      getCurrentFiber = renderer.getCurrentFiber,
      findFiberByHostInstance = renderer.findFiberByHostInstance,
      version = renderer.version; // Ignore React v15 and older because they don't expose a component stack anyway.

  if (typeof findFiberByHostInstance !== 'function') {
    return;
  } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.
  // getCurrentFiber gets injected for v16.9+.


  if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {
    var _getInternalReactCons = Object(_renderer__WEBPACK_IMPORTED_MODULE_1__[/* getInternalReactConstants */ "b"])(version),
        ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;

    injectedRenderers.set(renderer, {
      currentDispatcherRef: currentDispatcherRef,
      getCurrentFiber: getCurrentFiber,
      workTagMap: ReactTypeOfWork,
      onErrorOrWarning: onErrorOrWarning
    });
  }
}
var consoleSettingsRef = {
  appendComponentStack: false,
  breakOnConsoleErrors: false,
  showInlineWarningsAndErrors: false,
  hideConsoleLogsInStrictMode: false,
  browserTheme: 'dark'
}; // Patches console methods to append component stack for the current fiber.
// Call unpatch() to remove the injected behavior.

function patch(_ref) {
  var appendComponentStack = _ref.appendComponentStack,
      breakOnConsoleErrors = _ref.breakOnConsoleErrors,
      showInlineWarningsAndErrors = _ref.showInlineWarningsAndErrors,
      hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,
      browserTheme = _ref.browserTheme;
  // Settings may change after we've patched the console.
  // Using a shared ref allows the patch function to read the latest values.
  consoleSettingsRef.appendComponentStack = appendComponentStack;
  consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;
  consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;
  consoleSettingsRef.hideConsoleLogsInStrictMode = hideConsoleLogsInStrictMode;
  consoleSettingsRef.browserTheme = browserTheme;

  if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {
    if (unpatchFn !== null) {
      // Don't patch twice.
      return;
    }

    var originalConsoleMethods = {};

    unpatchFn = function unpatchFn() {
      for (var _method2 in originalConsoleMethods) {
        try {
          targetConsole[_method2] = originalConsoleMethods[_method2];
        } catch (error) {}
      }
    };

    OVERRIDE_CONSOLE_METHODS.forEach(function (method) {
      try {
        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]

        var overrideMethod = function overrideMethod() {
          var shouldAppendWarningStack = false;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (method !== 'log') {
            if (consoleSettingsRef.appendComponentStack) {
              var lastArg = args.length > 0 ? args[args.length - 1] : null;
              var alreadyHasComponentStack = typeof lastArg === 'string' && isStringComponentStack(lastArg); // If we are ever called with a string that already has a component stack,
              // e.g. a React error/warning, don't append a second stack.

              shouldAppendWarningStack = !alreadyHasComponentStack;
            }
          }

          var shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors && (method === 'error' || method === 'warn'); // Search for the first renderer that has a current Fiber.
          // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)
          // eslint-disable-next-line no-for-of-loops/no-for-of-loops

          var _iterator = _createForOfIteratorHelper(injectedRenderers.values()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _step.value,
                  currentDispatcherRef = _step$value.currentDispatcherRef,
                  getCurrentFiber = _step$value.getCurrentFiber,
                  onErrorOrWarning = _step$value.onErrorOrWarning,
                  workTagMap = _step$value.workTagMap;
              var current = getCurrentFiber();

              if (current != null) {
                try {
                  if (shouldShowInlineWarningsAndErrors) {
                    // patch() is called by two places: (1) the hook and (2) the renderer backend.
                    // The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.
                    if (typeof onErrorOrWarning === 'function') {
                      onErrorOrWarning(current, method, // Copy args before we mutate them (e.g. adding the component stack)
                      args.slice());
                    }
                  }

                  if (shouldAppendWarningStack) {
                    var componentStack = Object(_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__[/* getStackByFiberInDevAndProd */ "b"])(workTagMap, current, currentDispatcherRef);

                    if (componentStack !== '') {
                      if (isStrictModeOverride(args, method)) {
                        args[0] = "".concat(args[0], " %s");
                        args.push(componentStack);
                      } else {
                        args.push(componentStack);
                      }
                    }
                  }
                } catch (error) {
                  // Don't let a DevTools or React internal error interfere with logging.
                  setTimeout(function () {
                    throw error;
                  }, 0);
                } finally {
                  break;
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          if (consoleSettingsRef.breakOnConsoleErrors) {
            // --- Welcome to debugging with React DevTools ---
            // This debugger statement means that you've enabled the "break on warnings" feature.
            // Use the browser's Call Stack panel to step out of this override function-
            // to where the original warning or error was logged.
            // eslint-disable-next-line no-debugger
            debugger;
          }

          originalMethod.apply(void 0, args);
        };

        overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;
        originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod;
        targetConsole[method] = overrideMethod;
      } catch (error) {}
    });
  } else {
    unpatch();
  }
} // Removed component stack patch from console methods.

function unpatch() {
  if (unpatchFn !== null) {
    unpatchFn();
    unpatchFn = null;
  }
}
var unpatchForStrictModeFn = null; // NOTE: KEEP IN SYNC with src/hook.js:patchConsoleForInitialRenderInStrictMode

function patchForStrictMode() {
  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[/* consoleManagedByDevToolsDuringStrictMode */ "a"]) {
    var overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];

    if (unpatchForStrictModeFn !== null) {
      // Don't patch twice.
      return;
    }

    var originalConsoleMethods = {};

    unpatchForStrictModeFn = function unpatchForStrictModeFn() {
      for (var _method3 in originalConsoleMethods) {
        try {
          targetConsole[_method3] = originalConsoleMethods[_method3];
        } catch (error) {}
      }
    };

    overrideConsoleMethods.forEach(function (method) {
      try {
        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]

        var overrideMethod = function overrideMethod() {
          if (!consoleSettingsRef.hideConsoleLogsInStrictMode) {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            // Dim the text color of the double logs if we're not
            // hiding them.
            if (isNode) {
              originalMethod(DIMMED_NODE_CONSOLE_COLOR, _utils__WEBPACK_IMPORTED_MODULE_0__[/* format */ "e"].apply(void 0, args));
            } else {
              var color = getConsoleColor(method);

              if (color) {
                originalMethod.apply(void 0, _toConsumableArray(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatWithStyles */ "f"])(args, "color: ".concat(color))));
              } else {
                throw Error('Console color is not defined');
              }
            }
          }
        };

        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;
        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;
        targetConsole[method] = overrideMethod;
      } catch (error) {}
    });
  }
} // NOTE: KEEP IN SYNC with src/hook.js:unpatchConsoleForInitialRenderInStrictMode

function unpatchForStrictMode() {
  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[/* consoleManagedByDevToolsDuringStrictMode */ "a"]) {
    if (unpatchForStrictModeFn !== null) {
      unpatchForStrictModeFn();
      unpatchForStrictModeFn = null;
    }
  }
}
function patchConsoleUsingWindowValues() {
  var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;

  var appendComponentStack = (_castBool = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__)) !== null && _castBool !== void 0 ? _castBool : true;
  var breakOnConsoleErrors = (_castBool2 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__)) !== null && _castBool2 !== void 0 ? _castBool2 : false;
  var showInlineWarningsAndErrors = (_castBool3 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__)) !== null && _castBool3 !== void 0 ? _castBool3 : true;
  var hideConsoleLogsInStrictMode = (_castBool4 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ "a"])(window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__)) !== null && _castBool4 !== void 0 ? _castBool4 : false;
  var browserTheme = (_castBrowserTheme = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBrowserTheme */ "b"])(window.__REACT_DEVTOOLS_BROWSER_THEME__)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : 'dark';
  patch({
    appendComponentStack: appendComponentStack,
    breakOnConsoleErrors: breakOnConsoleErrors,
    showInlineWarningsAndErrors: showInlineWarningsAndErrors,
    hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,
    browserTheme: browserTheme
  });
} // After receiving cached console patch settings from React Native, we set them on window.
// When the console is initially patched (in renderer.js and hook.js), these values are read.
// The browser extension (etc.) sets these values on window, but through another method.

function writeConsolePatchSettingsToWindow(settings) {
  window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = settings.appendComponentStack;
  window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = settings.breakOnConsoleErrors;
  window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = settings.showInlineWarningsAndErrors;
  window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = settings.hideConsoleLogsInStrictMode;
  window.__REACT_DEVTOOLS_BROWSER_THEME__ = settings.browserTheme;
}
function installConsoleFunctionsToWindow() {
  window.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__ = {
    patchConsoleUsingWindowValues: patchConsoleUsingWindowValues,
    registerRendererWithConsole: registerRenderer
  };
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/* harmony default export */ __webpack_exports__["a"] = (isArray);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return meta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dehydrate; });
/* unused harmony export fillInPath */
/* unused harmony export hydrate */
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var meta = {
  inspectable: Symbol('inspectable'),
  inspected: Symbol('inspected'),
  name: Symbol('name'),
  preview_long: Symbol('preview_long'),
  preview_short: Symbol('preview_short'),
  readonly: Symbol('readonly'),
  size: Symbol('size'),
  type: Symbol('type'),
  unserializable: Symbol('unserializable')
};
// This threshold determines the depth at which the bridge "dehydrates" nested data.
// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,
// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).
//
// Reducing this threshold will improve the speed of initial component inspection,
// but may decrease the responsiveness of expanding objects/arrays to inspect further.
var LEVEL_THRESHOLD = 2;
/**
 * Generate the dehydrated metadata for complex object instances
 */

function createDehydrated(type, inspectable, data, cleaned, path) {
  cleaned.push(path);
  var dehydrated = {
    inspectable: inspectable,
    type: type,
    preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
    preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
  };

  if (type === 'array' || type === 'typed_array') {
    dehydrated.size = data.length;
  } else if (type === 'object') {
    dehydrated.size = Object.keys(data).length;
  }

  if (type === 'iterator' || type === 'typed_array') {
    dehydrated.readonly = true;
  }

  return dehydrated;
}
/**
 * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).
 * The paths of the stripped out objects are appended to the `cleaned` list.
 * On the other side of the barrier, the cleaned list is used to "re-hydrate" the cleaned representation into
 * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.
 *
 * Input: {"some": {"attr": fn()}, "other": AnInstance}
 * Output: {
 *   "some": {
 *     "attr": {"name": the fn.name, type: "function"}
 *   },
 *   "other": {
 *     "name": "AnInstance",
 *     "type": "object",
 *   },
 * }
 * and cleaned = [["some", "attr"], ["other"]]
 */


function dehydrate(data, cleaned, unserializable, path, isPathAllowed) {
  var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var type = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDataType */ "f"])(data);
  var isPathAllowedCheck;

  switch (type) {
    case 'html_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.tagName,
        type: type
      };

    case 'function':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,
        type: type
      };

    case 'string':
      isPathAllowedCheck = isPathAllowed(path);

      if (isPathAllowedCheck) {
        return data;
      } else {
        return data.length <= 500 ? data : data.slice(0, 500) + '...';
      }

    case 'bigint':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };

    case 'symbol':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };
    // React Elements aren't very inspector-friendly,
    // and often contain private fields or circular references.

    case 'react_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDisplayNameForReactElement */ "i"])(data) || 'Unknown',
        type: type
      };
    // ArrayBuffers error if you try to inspect them.

    case 'array_buffer':
    case 'data_view':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',
        size: data.byteLength,
        type: type
      };

    case 'array':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      }

      return data.map(function (item, i) {
        return dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
      });

    case 'html_all_collection':
    case 'typed_array':
    case 'iterator':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        var unserializableValue = {
          unserializable: true,
          type: type,
          readonly: true,
          size: type === 'typed_array' ? data.length : undefined,
          preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
          preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
        }; // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.

        Array.from(data).forEach(function (item, i) {
          return unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        unserializable.push(path);
        return unserializableValue;
      }

    case 'opaque_iterator':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data[Symbol.toStringTag],
        type: type
      };

    case 'date':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };

    case 'regexp':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.toString(),
        type: type
      };

    case 'object':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        var object = {};
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getAllEnumerableKeys */ "e"])(data).forEach(function (key) {
          var name = key.toString();
          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        return object;
      }

    case 'class_instance':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      }

      var value = {
        unserializable: true,
        type: type,
        readonly: true,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "d"])(data, true),
        name: data.constructor.name
      };
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getAllEnumerableKeys */ "e"])(data).forEach(function (key) {
        var keyAsString = key.toString();
        value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
      });
      unserializable.push(path);
      return value;

    case 'infinity':
    case 'nan':
    case 'undefined':
      // Some values are lossy when sent through a WebSocket.
      // We dehydrate+rehydrate them to preserve their type.
      cleaned.push(path);
      return {
        type: type
      };

    default:
      return data;
  }
}
function fillInPath(object, data, path, value) {
  var target = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path);

  if (target != null) {
    if (!target[meta.unserializable]) {
      delete target[meta.inspectable];
      delete target[meta.inspected];
      delete target[meta.name];
      delete target[meta.preview_long];
      delete target[meta.preview_short];
      delete target[meta.readonly];
      delete target[meta.size];
      delete target[meta.type];
    }
  }

  if (value !== null && data.unserializable.length > 0) {
    var unserializablePath = data.unserializable[0];
    var isMatch = unserializablePath.length === path.length;

    for (var i = 0; i < path.length; i++) {
      if (path[i] !== unserializablePath[i]) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      upgradeUnserializable(value, value);
    }
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* setInObject */ "o"])(object, path, value);
}
function hydrate(object, cleaned, unserializable) {
  cleaned.forEach(function (path) {
    var length = path.length;
    var last = path[length - 1];
    var parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    var value = parent[last];

    if (!value) {
      return;
    } else if (value.type === 'infinity') {
      parent[last] = Infinity;
    } else if (value.type === 'nan') {
      parent[last] = NaN;
    } else if (value.type === 'undefined') {
      parent[last] = undefined;
    } else {
      // Replace the string keys with Symbols so they're non-enumerable.
      var replaced = {};
      replaced[meta.inspectable] = !!value.inspectable;
      replaced[meta.inspected] = false;
      replaced[meta.name] = value.name;
      replaced[meta.preview_long] = value.preview_long;
      replaced[meta.preview_short] = value.preview_short;
      replaced[meta.size] = value.size;
      replaced[meta.readonly] = !!value.readonly;
      replaced[meta.type] = value.type;
      parent[last] = replaced;
    }
  });
  unserializable.forEach(function (path) {
    var length = path.length;
    var last = path[length - 1];
    var parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    var node = parent[last];

    var replacement = _objectSpread({}, node);

    upgradeUnserializable(replacement, node);
    parent[last] = replacement;
  });
  return object;
}

function upgradeUnserializable(destination, source) {
  var _Object$definePropert;

  Object.defineProperties(destination, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, meta.inspected, {
    configurable: true,
    enumerable: false,
    value: !!source.inspected
  }), _defineProperty(_Object$definePropert, meta.name, {
    configurable: true,
    enumerable: false,
    value: source.name
  }), _defineProperty(_Object$definePropert, meta.preview_long, {
    configurable: true,
    enumerable: false,
    value: source.preview_long
  }), _defineProperty(_Object$definePropert, meta.preview_short, {
    configurable: true,
    enumerable: false,
    value: source.preview_short
  }), _defineProperty(_Object$definePropert, meta.size, {
    configurable: true,
    enumerable: false,
    value: source.size
  }), _defineProperty(_Object$definePropert, meta.readonly, {
    configurable: true,
    enumerable: false,
    value: !!source.readonly
  }), _defineProperty(_Object$definePropert, meta.type, {
    configurable: true,
    enumerable: false,
    value: source.type
  }), _defineProperty(_Object$definePropert, meta.unserializable, {
    configurable: true,
    enumerable: false,
    value: !!source.unserializable
  }), _Object$definePropert));
  delete destination.inspected;
  delete destination.name;
  delete destination.preview_long;
  delete destination.preview_short;
  delete destination.size;
  delete destination.readonly;
  delete destination.type;
  delete destination.unserializable;
}

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return consoleManagedByDevToolsDuringStrictMode; });
/* unused harmony export enableLogger */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return enableStyleXFeatures; });
/* unused harmony export isInternalFacebookBuild */
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/************************************************************************
 * This file is forked between different DevTools implementations.
 * It should never be imported directly!
 * It should always be imported from "react-devtools-feature-flags".
 ************************************************************************/
var consoleManagedByDevToolsDuringStrictMode = false;
var enableLogger = false;
var enableStyleXFeatures = false;
var isInternalFacebookBuild = false;
/************************************************************************
 * Do not edit the code below.
 * It ensures this fork exports the same types as the default flags file.
 ************************************************************************/

// Flow magic to verify the exports of this file match the original version.
null;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function now() {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */


function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = _typeof(value);

  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && _typeof(value) == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = throttle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ getInternalReactConstants; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ attach; });

// EXTERNAL MODULE: ../react-devtools-shared/src/types.js
var types = __webpack_require__(1);

// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js
var utils = __webpack_require__(0);

// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js
var storage = __webpack_require__(5);

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/utils.js + 1 modules
var backend_utils = __webpack_require__(4);

// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js
var constants = __webpack_require__(2);

// EXTERNAL MODULE: /Users/hoxy/repos/react/build/oss-experimental/react-debug-tools/index.js
var react_debug_tools = __webpack_require__(18);

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/console.js
var backend_console = __webpack_require__(8);

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js
var ReactSymbols = __webpack_require__(3);

// EXTERNAL MODULE: ../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js
var DevToolsFeatureFlags_core_oss = __webpack_require__(11);

// CONCATENATED MODULE: ../shared/objectIs.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = // $FlowFixMe[method-unbinding]
typeof Object.is === 'function' ? Object.is : is;
/* harmony default export */ var shared_objectIs = (objectIs);
// CONCATENATED MODULE: ../shared/hasOwnProperty.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// $FlowFixMe[method-unbinding]
var hasOwnProperty_hasOwnProperty = Object.prototype.hasOwnProperty;
/* harmony default export */ var shared_hasOwnProperty = (hasOwnProperty_hasOwnProperty);
// EXTERNAL MODULE: ../react-devtools-shared/src/isArray.js
var isArray = __webpack_require__(6);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/StyleX/utils.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var cachedStyleNameToValueMap = new Map();
function getStyleXData(data) {
  var sources = new Set();
  var resolvedStyles = {};
  crawlData(data, sources, resolvedStyles);
  return {
    sources: Array.from(sources).sort(),
    resolvedStyles: resolvedStyles
  };
}
function crawlData(data, sources, resolvedStyles) {
  if (data == null) {
    return;
  }

  if (Object(isArray["a" /* default */])(data)) {
    data.forEach(function (entry) {
      if (entry == null) {
        return;
      }

      if (Object(isArray["a" /* default */])(entry)) {
        crawlData(entry, sources, resolvedStyles);
      } else {
        crawlObjectProperties(entry, sources, resolvedStyles);
      }
    });
  } else {
    crawlObjectProperties(data, sources, resolvedStyles);
  }

  resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());
}

function crawlObjectProperties(entry, sources, resolvedStyles) {
  var keys = Object.keys(entry);
  keys.forEach(function (key) {
    var value = entry[key];

    if (typeof value === 'string') {
      if (key === value) {
        // Special case; this key is the name of the style's source/file/module.
        sources.add(key);
      } else {
        var propertyValue = getPropertyValueForStyleName(value);

        if (propertyValue != null) {
          resolvedStyles[key] = propertyValue;
        }
      }
    } else {
      var nestedStyle = {};
      resolvedStyles[key] = nestedStyle;
      crawlData([value], sources, nestedStyle);
    }
  });
}

function getPropertyValueForStyleName(styleName) {
  if (cachedStyleNameToValueMap.has(styleName)) {
    return cachedStyleNameToValueMap.get(styleName);
  }

  for (var styleSheetIndex = 0; styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {
    var styleSheet = document.styleSheets[styleSheetIndex];
    var rules = null; // this might throw if CORS rules are enforced https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface

    try {
      rules = styleSheet.cssRules;
    } catch (_e) {
      continue;
    }

    for (var ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {
      if (!(rules[ruleIndex] instanceof CSSStyleRule)) {
        continue;
      }

      var rule = rules[ruleIndex];
      var cssText = rule.cssText,
          selectorText = rule.selectorText,
          style = rule.style;

      if (selectorText != null) {
        if (selectorText.startsWith(".".concat(styleName))) {
          var match = cssText.match(/{ *([a-z\-]+):/);

          if (match !== null) {
            var property = match[1];
            var value = style.getPropertyValue(property);
            cachedStyleNameToValueMap.set(styleName, value);
            return value;
          } else {
            return null;
          }
        }
      }
    }
  }

  return null;
}
// EXTERNAL MODULE: ../shared/isArray.js
var shared_isArray = __webpack_require__(9);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/constants.js
var CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md';
var UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back';
var REACT_DEVTOOLS_WORKPLACE_URL = 'https://fburl.com/react-devtools-workplace-group';
var THEME_STYLES = {
  light: {
    '--color-attribute-name': '#ef6632',
    '--color-attribute-name-not-editable': '#23272f',
    '--color-attribute-name-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-attribute-value': '#1a1aa6',
    '--color-attribute-value-inverted': '#ffffff',
    '--color-attribute-editable-value': '#1a1aa6',
    '--color-background': '#ffffff',
    '--color-background-hover': 'rgba(0, 136, 250, 0.1)',
    '--color-background-inactive': '#e5e5e5',
    '--color-background-invalid': '#fff0f0',
    '--color-background-selected': '#0088fa',
    '--color-button-background': '#ffffff',
    '--color-button-background-focus': '#ededed',
    '--color-button': '#5f6673',
    '--color-button-disabled': '#cfd1d5',
    '--color-button-active': '#0088fa',
    '--color-button-focus': '#23272f',
    '--color-button-hover': '#23272f',
    '--color-border': '#eeeeee',
    '--color-commit-did-not-render-fill': '#cfd1d5',
    '--color-commit-did-not-render-fill-text': '#000000',
    '--color-commit-did-not-render-pattern': '#cfd1d5',
    '--color-commit-did-not-render-pattern-text': '#333333',
    '--color-commit-gradient-0': '#37afa9',
    '--color-commit-gradient-1': '#63b19e',
    '--color-commit-gradient-2': '#80b393',
    '--color-commit-gradient-3': '#97b488',
    '--color-commit-gradient-4': '#abb67d',
    '--color-commit-gradient-5': '#beb771',
    '--color-commit-gradient-6': '#cfb965',
    '--color-commit-gradient-7': '#dfba57',
    '--color-commit-gradient-8': '#efbb49',
    '--color-commit-gradient-9': '#febc38',
    '--color-commit-gradient-text': '#000000',
    '--color-component-name': '#6a51b2',
    '--color-component-name-inverted': '#ffffff',
    '--color-component-badge-background': 'rgba(0, 0, 0, 0.1)',
    '--color-component-badge-background-inverted': 'rgba(255, 255, 255, 0.25)',
    '--color-component-badge-count': '#777d88',
    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-console-error-badge-text': '#ffffff',
    '--color-console-error-background': '#fff0f0',
    '--color-console-error-border': '#ffd6d6',
    '--color-console-error-icon': '#eb3941',
    '--color-console-error-text': '#fe2e31',
    '--color-console-warning-badge-text': '#000000',
    '--color-console-warning-background': '#fffbe5',
    '--color-console-warning-border': '#fff5c1',
    '--color-console-warning-icon': '#f4bd00',
    '--color-console-warning-text': '#64460c',
    '--color-context-background': 'rgba(0,0,0,.9)',
    '--color-context-background-hover': 'rgba(255, 255, 255, 0.1)',
    '--color-context-background-selected': '#178fb9',
    '--color-context-border': '#3d424a',
    '--color-context-text': '#ffffff',
    '--color-context-text-selected': '#ffffff',
    '--color-dim': '#777d88',
    '--color-dimmer': '#cfd1d5',
    '--color-dimmest': '#eff0f1',
    '--color-error-background': 'hsl(0, 100%, 97%)',
    '--color-error-border': 'hsl(0, 100%, 92%)',
    '--color-error-text': '#ff0000',
    '--color-expand-collapse-toggle': '#777d88',
    '--color-link': '#0000ff',
    '--color-modal-background': 'rgba(255, 255, 255, 0.75)',
    '--color-bridge-version-npm-background': '#eff0f1',
    '--color-bridge-version-npm-text': '#000000',
    '--color-bridge-version-number': '#0088fa',
    '--color-primitive-hook-badge-background': '#e5e5e5',
    '--color-primitive-hook-badge-text': '#5f6673',
    '--color-record-active': '#fc3a4b',
    '--color-record-hover': '#3578e5',
    '--color-record-inactive': '#0088fa',
    '--color-resize-bar': '#eeeeee',
    '--color-resize-bar-active': '#dcdcdc',
    '--color-resize-bar-border': '#d1d1d1',
    '--color-resize-bar-dot': '#333333',
    '--color-timeline-internal-module': '#d1d1d1',
    '--color-timeline-internal-module-hover': '#c9c9c9',
    '--color-timeline-internal-module-text': '#444',
    '--color-timeline-native-event': '#ccc',
    '--color-timeline-native-event-hover': '#aaa',
    '--color-timeline-network-primary': '#fcf3dc',
    '--color-timeline-network-primary-hover': '#f0e7d1',
    '--color-timeline-network-secondary': '#efc457',
    '--color-timeline-network-secondary-hover': '#e3ba52',
    '--color-timeline-priority-background': '#f6f6f6',
    '--color-timeline-priority-border': '#eeeeee',
    '--color-timeline-user-timing': '#c9cacd',
    '--color-timeline-user-timing-hover': '#93959a',
    '--color-timeline-react-idle': '#d3e5f6',
    '--color-timeline-react-idle-hover': '#c3d9ef',
    '--color-timeline-react-render': '#9fc3f3',
    '--color-timeline-react-render-hover': '#83afe9',
    '--color-timeline-react-render-text': '#11365e',
    '--color-timeline-react-commit': '#c88ff0',
    '--color-timeline-react-commit-hover': '#b281d6',
    '--color-timeline-react-commit-text': '#3e2c4a',
    '--color-timeline-react-layout-effects': '#b281d6',
    '--color-timeline-react-layout-effects-hover': '#9d71bd',
    '--color-timeline-react-layout-effects-text': '#3e2c4a',
    '--color-timeline-react-passive-effects': '#b281d6',
    '--color-timeline-react-passive-effects-hover': '#9d71bd',
    '--color-timeline-react-passive-effects-text': '#3e2c4a',
    '--color-timeline-react-schedule': '#9fc3f3',
    '--color-timeline-react-schedule-hover': '#2683E2',
    '--color-timeline-react-suspense-rejected': '#f1cc14',
    '--color-timeline-react-suspense-rejected-hover': '#ffdf37',
    '--color-timeline-react-suspense-resolved': '#a6e59f',
    '--color-timeline-react-suspense-resolved-hover': '#89d281',
    '--color-timeline-react-suspense-unresolved': '#c9cacd',
    '--color-timeline-react-suspense-unresolved-hover': '#93959a',
    '--color-timeline-thrown-error': '#ee1638',
    '--color-timeline-thrown-error-hover': '#da1030',
    '--color-timeline-text-color': '#000000',
    '--color-timeline-text-dim-color': '#ccc',
    '--color-timeline-react-work-border': '#eeeeee',
    '--color-search-match': 'yellow',
    '--color-search-match-current': '#f7923b',
    '--color-selected-tree-highlight-active': 'rgba(0, 136, 250, 0.1)',
    '--color-selected-tree-highlight-inactive': 'rgba(0, 0, 0, 0.05)',
    '--color-scroll-caret': 'rgba(150, 150, 150, 0.5)',
    '--color-tab-selected-border': '#0088fa',
    '--color-text': '#000000',
    '--color-text-invalid': '#ff0000',
    '--color-text-selected': '#ffffff',
    '--color-toggle-background-invalid': '#fc3a4b',
    '--color-toggle-background-on': '#0088fa',
    '--color-toggle-background-off': '#cfd1d5',
    '--color-toggle-text': '#ffffff',
    '--color-warning-background': '#fb3655',
    '--color-warning-background-hover': '#f82042',
    '--color-warning-text-color': '#ffffff',
    '--color-warning-text-color-inverted': '#fd4d69',
    // The styles below should be kept in sync with 'root.css'
    // They are repeated there because they're used by e.g. tooltips or context menus
    // which get rendered outside of the DOM subtree (where normal theme/styles are written).
    '--color-scroll-thumb': '#c2c2c2',
    '--color-scroll-track': '#fafafa',
    '--color-tooltip-background': 'rgba(0, 0, 0, 0.9)',
    '--color-tooltip-text': '#ffffff'
  },
  dark: {
    '--color-attribute-name': '#9d87d2',
    '--color-attribute-name-not-editable': '#ededed',
    '--color-attribute-name-inverted': '#282828',
    '--color-attribute-value': '#cedae0',
    '--color-attribute-value-inverted': '#ffffff',
    '--color-attribute-editable-value': 'yellow',
    '--color-background': '#282c34',
    '--color-background-hover': 'rgba(255, 255, 255, 0.1)',
    '--color-background-inactive': '#3d424a',
    '--color-background-invalid': '#5c0000',
    '--color-background-selected': '#178fb9',
    '--color-button-background': '#282c34',
    '--color-button-background-focus': '#3d424a',
    '--color-button': '#afb3b9',
    '--color-button-active': '#61dafb',
    '--color-button-disabled': '#4f5766',
    '--color-button-focus': '#a2e9fc',
    '--color-button-hover': '#ededed',
    '--color-border': '#3d424a',
    '--color-commit-did-not-render-fill': '#777d88',
    '--color-commit-did-not-render-fill-text': '#000000',
    '--color-commit-did-not-render-pattern': '#666c77',
    '--color-commit-did-not-render-pattern-text': '#ffffff',
    '--color-commit-gradient-0': '#37afa9',
    '--color-commit-gradient-1': '#63b19e',
    '--color-commit-gradient-2': '#80b393',
    '--color-commit-gradient-3': '#97b488',
    '--color-commit-gradient-4': '#abb67d',
    '--color-commit-gradient-5': '#beb771',
    '--color-commit-gradient-6': '#cfb965',
    '--color-commit-gradient-7': '#dfba57',
    '--color-commit-gradient-8': '#efbb49',
    '--color-commit-gradient-9': '#febc38',
    '--color-commit-gradient-text': '#000000',
    '--color-component-name': '#61dafb',
    '--color-component-name-inverted': '#282828',
    '--color-component-badge-background': 'rgba(255, 255, 255, 0.25)',
    '--color-component-badge-background-inverted': 'rgba(0, 0, 0, 0.25)',
    '--color-component-badge-count': '#8f949d',
    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-console-error-badge-text': '#000000',
    '--color-console-error-background': '#290000',
    '--color-console-error-border': '#5c0000',
    '--color-console-error-icon': '#eb3941',
    '--color-console-error-text': '#fc7f7f',
    '--color-console-warning-badge-text': '#000000',
    '--color-console-warning-background': '#332b00',
    '--color-console-warning-border': '#665500',
    '--color-console-warning-icon': '#f4bd00',
    '--color-console-warning-text': '#f5f2ed',
    '--color-context-background': 'rgba(255,255,255,.95)',
    '--color-context-background-hover': 'rgba(0, 136, 250, 0.1)',
    '--color-context-background-selected': '#0088fa',
    '--color-context-border': '#eeeeee',
    '--color-context-text': '#000000',
    '--color-context-text-selected': '#ffffff',
    '--color-dim': '#8f949d',
    '--color-dimmer': '#777d88',
    '--color-dimmest': '#4f5766',
    '--color-error-background': '#200',
    '--color-error-border': '#900',
    '--color-error-text': '#f55',
    '--color-expand-collapse-toggle': '#8f949d',
    '--color-link': '#61dafb',
    '--color-modal-background': 'rgba(0, 0, 0, 0.75)',
    '--color-bridge-version-npm-background': 'rgba(0, 0, 0, 0.25)',
    '--color-bridge-version-npm-text': '#ffffff',
    '--color-bridge-version-number': 'yellow',
    '--color-primitive-hook-badge-background': 'rgba(0, 0, 0, 0.25)',
    '--color-primitive-hook-badge-text': 'rgba(255, 255, 255, 0.7)',
    '--color-record-active': '#fc3a4b',
    '--color-record-hover': '#a2e9fc',
    '--color-record-inactive': '#61dafb',
    '--color-resize-bar': '#282c34',
    '--color-resize-bar-active': '#31363f',
    '--color-resize-bar-border': '#3d424a',
    '--color-resize-bar-dot': '#cfd1d5',
    '--color-timeline-internal-module': '#303542',
    '--color-timeline-internal-module-hover': '#363b4a',
    '--color-timeline-internal-module-text': '#7f8899',
    '--color-timeline-native-event': '#b2b2b2',
    '--color-timeline-native-event-hover': '#949494',
    '--color-timeline-network-primary': '#fcf3dc',
    '--color-timeline-network-primary-hover': '#e3dbc5',
    '--color-timeline-network-secondary': '#efc457',
    '--color-timeline-network-secondary-hover': '#d6af4d',
    '--color-timeline-priority-background': '#1d2129',
    '--color-timeline-priority-border': '#282c34',
    '--color-timeline-user-timing': '#c9cacd',
    '--color-timeline-user-timing-hover': '#93959a',
    '--color-timeline-react-idle': '#3d485b',
    '--color-timeline-react-idle-hover': '#465269',
    '--color-timeline-react-render': '#2683E2',
    '--color-timeline-react-render-hover': '#1a76d4',
    '--color-timeline-react-render-text': '#11365e',
    '--color-timeline-react-commit': '#731fad',
    '--color-timeline-react-commit-hover': '#611b94',
    '--color-timeline-react-commit-text': '#e5c1ff',
    '--color-timeline-react-layout-effects': '#611b94',
    '--color-timeline-react-layout-effects-hover': '#51167a',
    '--color-timeline-react-layout-effects-text': '#e5c1ff',
    '--color-timeline-react-passive-effects': '#611b94',
    '--color-timeline-react-passive-effects-hover': '#51167a',
    '--color-timeline-react-passive-effects-text': '#e5c1ff',
    '--color-timeline-react-schedule': '#2683E2',
    '--color-timeline-react-schedule-hover': '#1a76d4',
    '--color-timeline-react-suspense-rejected': '#f1cc14',
    '--color-timeline-react-suspense-rejected-hover': '#e4c00f',
    '--color-timeline-react-suspense-resolved': '#a6e59f',
    '--color-timeline-react-suspense-resolved-hover': '#89d281',
    '--color-timeline-react-suspense-unresolved': '#c9cacd',
    '--color-timeline-react-suspense-unresolved-hover': '#93959a',
    '--color-timeline-thrown-error': '#fb3655',
    '--color-timeline-thrown-error-hover': '#f82042',
    '--color-timeline-text-color': '#282c34',
    '--color-timeline-text-dim-color': '#555b66',
    '--color-timeline-react-work-border': '#3d424a',
    '--color-search-match': 'yellow',
    '--color-search-match-current': '#f7923b',
    '--color-selected-tree-highlight-active': 'rgba(23, 143, 185, 0.15)',
    '--color-selected-tree-highlight-inactive': 'rgba(255, 255, 255, 0.05)',
    '--color-scroll-caret': '#4f5766',
    '--color-shadow': 'rgba(0, 0, 0, 0.5)',
    '--color-tab-selected-border': '#178fb9',
    '--color-text': '#ffffff',
    '--color-text-invalid': '#ff8080',
    '--color-text-selected': '#ffffff',
    '--color-toggle-background-invalid': '#fc3a4b',
    '--color-toggle-background-on': '#178fb9',
    '--color-toggle-background-off': '#777d88',
    '--color-toggle-text': '#ffffff',
    '--color-warning-background': '#ee1638',
    '--color-warning-background-hover': '#da1030',
    '--color-warning-text-color': '#ffffff',
    '--color-warning-text-color-inverted': '#ee1638',
    // The styles below should be kept in sync with 'root.css'
    // They are repeated there because they're used by e.g. tooltips or context menus
    // which get rendered outside of the DOM subtree (where normal theme/styles are written).
    '--color-scroll-thumb': '#afb3b9',
    '--color-scroll-track': '#313640',
    '--color-tooltip-background': 'rgba(255, 255, 255, 0.95)',
    '--color-tooltip-text': '#000000'
  },
  compact: {
    '--font-size-monospace-small': '9px',
    '--font-size-monospace-normal': '11px',
    '--font-size-monospace-large': '15px',
    '--font-size-sans-small': '10px',
    '--font-size-sans-normal': '12px',
    '--font-size-sans-large': '14px',
    '--line-height-data': '18px'
  },
  comfortable: {
    '--font-size-monospace-small': '10px',
    '--font-size-monospace-normal': '13px',
    '--font-size-monospace-large': '17px',
    '--font-size-sans-small': '12px',
    '--font-size-sans-normal': '14px',
    '--font-size-sans-large': '16px',
    '--line-height-data': '22px'
  }
}; // HACK
//
// Sometimes the inline target is rendered before root styles are applied,
// which would result in e.g. NaN itemSize being passed to react-window list.

var COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable['--line-height-data'], 10);
var COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact['--line-height-data'], 10);

// CONCATENATED MODULE: ../react-devtools-timeline/src/constants.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var REACT_TOTAL_NUM_LANES = 31; // Increment this number any time a backwards breaking change is made to the profiler metadata.

var SCHEDULING_PROFILER_VERSION = 1;
var SNAPSHOT_MAX_HEIGHT = 60;
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js + 2 modules
var DevToolsFiberComponentStack = __webpack_require__(14);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/profilingHooks.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


 // Add padding to the start/stop time of the profile.
// This makes the UI nicer to use.

var TIME_OFFSET = 10;
var performanceTarget = null; // If performance exists and supports the subset of the User Timing API that we require.

var supportsUserTiming = typeof performance !== 'undefined' && // $FlowFixMe[method-unbinding]
typeof performance.mark === 'function' && // $FlowFixMe[method-unbinding]
typeof performance.clearMarks === 'function';
var supportsUserTimingV3 = false;

if (supportsUserTiming) {
  var CHECK_V3_MARK = '__v3';
  var markOptions = {};
  Object.defineProperty(markOptions, 'startTime', {
    get: function get() {
      supportsUserTimingV3 = true;
      return 0;
    },
    set: function set() {}
  });

  try {
    // $FlowFixMe[extra-arg]: Flow expects the User Timing level 2 API.
    performance.mark(CHECK_V3_MARK, markOptions);
  } catch (error) {// Ignore
  } finally {
    performance.clearMarks(CHECK_V3_MARK);
  }
}

if (supportsUserTimingV3) {
  performanceTarget = performance;
} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.


var getCurrentTime = // $FlowFixMe[method-unbinding]
(typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
}; // Mocking the Performance Object (and User Timing APIs) for testing is fragile.
// This API allows tests to directly override the User Timing APIs.

function setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {
  performanceTarget = performanceMock;
  supportsUserTiming = performanceMock !== null;
  supportsUserTimingV3 = performanceMock !== null;
}
function createProfilingHooks(_ref) {
  var getDisplayNameForFiber = _ref.getDisplayNameForFiber,
      getIsProfiling = _ref.getIsProfiling,
      getLaneLabelMap = _ref.getLaneLabelMap,
      workTagMap = _ref.workTagMap,
      currentDispatcherRef = _ref.currentDispatcherRef,
      reactVersion = _ref.reactVersion;
  var currentBatchUID = 0;
  var currentReactComponentMeasure = null;
  var currentReactMeasuresStack = [];
  var currentTimelineData = null;
  var currentFiberStacks = new Map();
  var isProfiling = false;
  var nextRenderShouldStartNewBatch = false;

  function getRelativeTime() {
    var currentTime = getCurrentTime();

    if (currentTimelineData) {
      if (currentTimelineData.startTime === 0) {
        currentTimelineData.startTime = currentTime - TIME_OFFSET;
      }

      return currentTime - currentTimelineData.startTime;
    }

    return 0;
  }

  function getInternalModuleRanges() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === 'function') {
      // Ask the DevTools hook for module ranges that may have been reported by the current renderer(s).
      // Don't do this eagerly like the laneToLabelMap,
      // because some modules might not yet have registered their boundaries when the renderer is injected.
      var ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges(); // This check would not be required,
      // except that it's possible for things to override __REACT_DEVTOOLS_GLOBAL_HOOK__.


      if (Object(shared_isArray["a" /* default */])(ranges)) {
        return ranges;
      }
    }

    return null;
  }

  function getTimelineData() {
    return currentTimelineData;
  }

  function laneToLanesArray(lanes) {
    var lanesArray = [];
    var lane = 1;

    for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {
      if (lane & lanes) {
        lanesArray.push(lane);
      }

      lane *= 2;
    }

    return lanesArray;
  }

  var laneToLabelMap = typeof getLaneLabelMap === 'function' ? getLaneLabelMap() : null;

  function markMetadata() {
    markAndClear("--react-version-".concat(reactVersion));
    markAndClear("--profiler-version-".concat(SCHEDULING_PROFILER_VERSION));
    var ranges = getInternalModuleRanges();

    if (ranges) {
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];

        if (Object(shared_isArray["a" /* default */])(range) && range.length === 2) {
          var _ranges$i = _slicedToArray(ranges[i], 2),
              startStackFrame = _ranges$i[0],
              stopStackFrame = _ranges$i[1];

          markAndClear("--react-internal-module-start-".concat(startStackFrame));
          markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
        }
      }
    }

    if (laneToLabelMap != null) {
      var labels = Array.from(laneToLabelMap.values()).join(',');
      markAndClear("--react-lane-labels-".concat(labels));
    }
  }

  function markAndClear(markName) {
    // This method won't be called unless these functions are defined, so we can skip the extra typeof check.
    performanceTarget.mark(markName);
    performanceTarget.clearMarks(markName);
  }

  function recordReactMeasureStarted(type, lanes) {
    // Decide what depth thi work should be rendered at, based on what's on the top of the stack.
    // It's okay to render over top of "idle" work but everything else should be on its own row.
    var depth = 0;

    if (currentReactMeasuresStack.length > 0) {
      var top = currentReactMeasuresStack[currentReactMeasuresStack.length - 1];
      depth = top.type === 'render-idle' ? top.depth : top.depth + 1;
    }

    var lanesArray = laneToLanesArray(lanes);
    var reactMeasure = {
      type: type,
      batchUID: currentBatchUID,
      depth: depth,
      lanes: lanesArray,
      timestamp: getRelativeTime(),
      duration: 0
    };
    currentReactMeasuresStack.push(reactMeasure);

    if (currentTimelineData) {
      var _currentTimelineData = currentTimelineData,
          batchUIDToMeasuresMap = _currentTimelineData.batchUIDToMeasuresMap,
          laneToReactMeasureMap = _currentTimelineData.laneToReactMeasureMap;
      var reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);

      if (reactMeasures != null) {
        reactMeasures.push(reactMeasure);
      } else {
        batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);
      }

      lanesArray.forEach(function (lane) {
        reactMeasures = laneToReactMeasureMap.get(lane);

        if (reactMeasures) {
          reactMeasures.push(reactMeasure);
        }
      });
    }
  }

  function recordReactMeasureCompleted(type) {
    var currentTime = getRelativeTime();

    if (currentReactMeasuresStack.length === 0) {
      console.error('Unexpected type "%s" completed at %sms while currentReactMeasuresStack is empty.', type, currentTime); // Ignore work "completion" user timing mark that doesn't complete anything

      return;
    }

    var top = currentReactMeasuresStack.pop();

    if (top.type !== type) {
      console.error('Unexpected type "%s" completed at %sms before "%s" completed.', type, currentTime, top.type);
    } // $FlowFixMe[cannot-write] This property should not be writable outside of this function.


    top.duration = currentTime - top.timestamp;

    if (currentTimelineData) {
      currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;
    }
  }

  function markCommitStarted(lanes) {
    if (isProfiling) {
      recordReactMeasureStarted('commit', lanes); // TODO (timeline) Re-think this approach to "batching"; I don't think it works for Suspense or pre-rendering.
      // This issue applies to the User Timing data also.

      nextRenderShouldStartNewBatch = true;
    }

    if (supportsUserTimingV3) {
      markAndClear("--commit-start-".concat(lanes)); // Some metadata only needs to be logged once per session,
      // but if profiling information is being recorded via the Performance tab,
      // DevTools has no way of knowing when the recording starts.
      // Because of that, we log thie type of data periodically (once per commit).

      markMetadata();
    }
  }

  function markCommitStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('commit');
      recordReactMeasureCompleted('render-idle');
    }

    if (supportsUserTimingV3) {
      markAndClear('--commit-stop');
    }
  }

  function markComponentRenderStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'render',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-render-start-".concat(componentName));
      }
    }
  }

  function markComponentRenderStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-render-stop');
    }
  }

  function markComponentLayoutEffectMountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'layout-effect-mount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-layout-effect-mount-start-".concat(componentName));
      }
    }
  }

  function markComponentLayoutEffectMountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-layout-effect-mount-stop');
    }
  }

  function markComponentLayoutEffectUnmountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'layout-effect-unmount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-layout-effect-unmount-start-".concat(componentName));
      }
    }
  }

  function markComponentLayoutEffectUnmountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-layout-effect-unmount-stop');
    }
  }

  function markComponentPassiveEffectMountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'passive-effect-mount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-passive-effect-mount-start-".concat(componentName));
      }
    }
  }

  function markComponentPassiveEffectMountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-passive-effect-mount-stop');
    }
  }

  function markComponentPassiveEffectUnmountStarted(fiber) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (isProfiling) {
          currentReactComponentMeasure = {
            componentName: componentName,
            duration: 0,
            timestamp: getRelativeTime(),
            type: 'passive-effect-unmount',
            warning: null
          };
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--component-passive-effect-unmount-start-".concat(componentName));
      }
    }
  }

  function markComponentPassiveEffectUnmountStopped() {
    if (isProfiling) {
      if (currentReactComponentMeasure) {
        if (currentTimelineData) {
          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
        } // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow
        getRelativeTime() - currentReactComponentMeasure.timestamp;
        currentReactComponentMeasure = null;
      }
    }

    if (supportsUserTimingV3) {
      markAndClear('--component-passive-effect-unmount-stop');
    }
  }

  function markComponentErrored(fiber, thrownValue, lanes) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';
      var phase = fiber.alternate === null ? 'mount' : 'update';
      var message = '';

      if (thrownValue !== null && _typeof(thrownValue) === 'object' && typeof thrownValue.message === 'string') {
        message = thrownValue.message;
      } else if (typeof thrownValue === 'string') {
        message = thrownValue;
      }

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (currentTimelineData) {
          currentTimelineData.thrownErrors.push({
            componentName: componentName,
            message: message,
            phase: phase,
            timestamp: getRelativeTime(),
            type: 'thrown-error'
          });
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--error-".concat(componentName, "-").concat(phase, "-").concat(message));
      }
    }
  }

  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // $FlowFixMe[incompatible-type]: Flow cannot handle polymorphic WeakMaps

  var wakeableIDs = new PossiblyWeakMap();
  var wakeableID = 0;

  function getWakeableID(wakeable) {
    if (!wakeableIDs.has(wakeable)) {
      wakeableIDs.set(wakeable, wakeableID++);
    }

    return wakeableIDs.get(wakeable);
  }

  function markComponentSuspended(fiber, wakeable, lanes) {
    if (isProfiling || supportsUserTimingV3) {
      var eventType = wakeableIDs.has(wakeable) ? 'resuspend' : 'suspend';
      var id = getWakeableID(wakeable);
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';
      var phase = fiber.alternate === null ? 'mount' : 'update'; // Following the non-standard fn.displayName convention,
      // frameworks like Relay may also annotate Promises with a displayName,
      // describing what operation/data the thrown Promise is related to.
      // When this is available we should pass it along to the Timeline.

      var displayName = wakeable.displayName || '';
      var suspenseEvent = null;

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        suspenseEvent = {
          componentName: componentName,
          depth: 0,
          duration: 0,
          id: "".concat(id),
          phase: phase,
          promiseName: displayName,
          resolution: 'unresolved',
          timestamp: getRelativeTime(),
          type: 'suspense',
          warning: null
        };

        if (currentTimelineData) {
          currentTimelineData.suspenseEvents.push(suspenseEvent);
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--suspense-".concat(eventType, "-").concat(id, "-").concat(componentName, "-").concat(phase, "-").concat(lanes, "-").concat(displayName));
      }

      wakeable.then(function () {
        if (suspenseEvent) {
          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
          suspenseEvent.resolution = 'resolved';
        }

        if (supportsUserTimingV3) {
          markAndClear("--suspense-resolved-".concat(id, "-").concat(componentName));
        }
      }, function () {
        if (suspenseEvent) {
          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
          suspenseEvent.resolution = 'rejected';
        }

        if (supportsUserTimingV3) {
          markAndClear("--suspense-rejected-".concat(id, "-").concat(componentName));
        }
      });
    }
  }

  function markLayoutEffectsStarted(lanes) {
    if (isProfiling) {
      recordReactMeasureStarted('layout-effects', lanes);
    }

    if (supportsUserTimingV3) {
      markAndClear("--layout-effects-start-".concat(lanes));
    }
  }

  function markLayoutEffectsStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('layout-effects');
    }

    if (supportsUserTimingV3) {
      markAndClear('--layout-effects-stop');
    }
  }

  function markPassiveEffectsStarted(lanes) {
    if (isProfiling) {
      recordReactMeasureStarted('passive-effects', lanes);
    }

    if (supportsUserTimingV3) {
      markAndClear("--passive-effects-start-".concat(lanes));
    }
  }

  function markPassiveEffectsStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('passive-effects');
    }

    if (supportsUserTimingV3) {
      markAndClear('--passive-effects-stop');
    }
  }

  function markRenderStarted(lanes) {
    if (isProfiling) {
      if (nextRenderShouldStartNewBatch) {
        nextRenderShouldStartNewBatch = false;
        currentBatchUID++;
      } // If this is a new batch of work, wrap an "idle" measure around it.
      // Log it before the "render" measure to preserve the stack ordering.


      if (currentReactMeasuresStack.length === 0 || currentReactMeasuresStack[currentReactMeasuresStack.length - 1].type !== 'render-idle') {
        recordReactMeasureStarted('render-idle', lanes);
      }

      recordReactMeasureStarted('render', lanes);
    }

    if (supportsUserTimingV3) {
      markAndClear("--render-start-".concat(lanes));
    }
  }

  function markRenderYielded() {
    if (isProfiling) {
      recordReactMeasureCompleted('render');
    }

    if (supportsUserTimingV3) {
      markAndClear('--render-yield');
    }
  }

  function markRenderStopped() {
    if (isProfiling) {
      recordReactMeasureCompleted('render');
    }

    if (supportsUserTimingV3) {
      markAndClear('--render-stop');
    }
  }

  function markRenderScheduled(lane) {
    if (isProfiling) {
      if (currentTimelineData) {
        currentTimelineData.schedulingEvents.push({
          lanes: laneToLanesArray(lane),
          timestamp: getRelativeTime(),
          type: 'schedule-render',
          warning: null
        });
      }
    }

    if (supportsUserTimingV3) {
      markAndClear("--schedule-render-".concat(lane));
    }
  }

  function markForceUpdateScheduled(fiber, lane) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (currentTimelineData) {
          currentTimelineData.schedulingEvents.push({
            componentName: componentName,
            lanes: laneToLanesArray(lane),
            timestamp: getRelativeTime(),
            type: 'schedule-force-update',
            warning: null
          });
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--schedule-forced-update-".concat(lane, "-").concat(componentName));
      }
    }
  }

  function getParentFibers(fiber) {
    var parents = [];
    var parent = fiber;

    while (parent !== null) {
      parents.push(parent);
      parent = parent.return;
    }

    return parents;
  }

  function markStateUpdateScheduled(fiber, lane) {
    if (isProfiling || supportsUserTimingV3) {
      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';

      if (isProfiling) {
        // TODO (timeline) Record and cache component stack
        if (currentTimelineData) {
          var event = {
            componentName: componentName,
            // Store the parent fibers so we can post process
            // them after we finish profiling
            lanes: laneToLanesArray(lane),
            timestamp: getRelativeTime(),
            type: 'schedule-state-update',
            warning: null
          };
          currentFiberStacks.set(event, getParentFibers(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow

          currentTimelineData.schedulingEvents.push(event);
        }
      }

      if (supportsUserTimingV3) {
        markAndClear("--schedule-state-update-".concat(lane, "-").concat(componentName));
      }
    }
  }

  function toggleProfilingStatus(value) {
    if (isProfiling !== value) {
      isProfiling = value;

      if (isProfiling) {
        var internalModuleSourceToRanges = new Map();

        if (supportsUserTimingV3) {
          var ranges = getInternalModuleRanges();

          if (ranges) {
            for (var i = 0; i < ranges.length; i++) {
              var range = ranges[i];

              if (Object(shared_isArray["a" /* default */])(range) && range.length === 2) {
                var _ranges$i2 = _slicedToArray(ranges[i], 2),
                    startStackFrame = _ranges$i2[0],
                    stopStackFrame = _ranges$i2[1];

                markAndClear("--react-internal-module-start-".concat(startStackFrame));
                markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
              }
            }
          }
        }

        var laneToReactMeasureMap = new Map();
        var lane = 1;

        for (var index = 0; index < REACT_TOTAL_NUM_LANES; index++) {
          laneToReactMeasureMap.set(lane, []);
          lane *= 2;
        }

        currentBatchUID = 0;
        currentReactComponentMeasure = null;
        currentReactMeasuresStack = [];
        currentFiberStacks = new Map();
        currentTimelineData = {
          // Session wide metadata; only collected once.
          internalModuleSourceToRanges: internalModuleSourceToRanges,
          laneToLabelMap: laneToLabelMap || new Map(),
          reactVersion: reactVersion,
          // Data logged by React during profiling session.
          componentMeasures: [],
          schedulingEvents: [],
          suspenseEvents: [],
          thrownErrors: [],
          // Data inferred based on what React logs.
          batchUIDToMeasuresMap: new Map(),
          duration: 0,
          laneToReactMeasureMap: laneToReactMeasureMap,
          startTime: 0,
          // Data only available in Chrome profiles.
          flamechart: [],
          nativeEvents: [],
          networkMeasures: [],
          otherUserTimingMarks: [],
          snapshots: [],
          snapshotHeight: 0
        };
        nextRenderShouldStartNewBatch = true;
      } else {
        // Postprocess Profile data
        if (currentTimelineData !== null) {
          currentTimelineData.schedulingEvents.forEach(function (event) {
            if (event.type === 'schedule-state-update') {
              // TODO(luna): We can optimize this by creating a map of
              // fiber to component stack instead of generating the stack
              // for every fiber every time
              var fiberStack = currentFiberStacks.get(event);

              if (fiberStack && currentDispatcherRef != null) {
                event.componentStack = fiberStack.reduce(function (trace, fiber) {
                  return trace + Object(DevToolsFiberComponentStack["a" /* describeFiber */])(workTagMap, fiber, currentDispatcherRef);
                }, '');
              }
            }
          });
        } // Clear the current fiber stacks so we don't hold onto the fibers
        // in memory after profiling finishes


        currentFiberStacks.clear();
      }
    }
  }

  return {
    getTimelineData: getTimelineData,
    profilingHooks: {
      markCommitStarted: markCommitStarted,
      markCommitStopped: markCommitStopped,
      markComponentRenderStarted: markComponentRenderStarted,
      markComponentRenderStopped: markComponentRenderStopped,
      markComponentPassiveEffectMountStarted: markComponentPassiveEffectMountStarted,
      markComponentPassiveEffectMountStopped: markComponentPassiveEffectMountStopped,
      markComponentPassiveEffectUnmountStarted: markComponentPassiveEffectUnmountStarted,
      markComponentPassiveEffectUnmountStopped: markComponentPassiveEffectUnmountStopped,
      markComponentLayoutEffectMountStarted: markComponentLayoutEffectMountStarted,
      markComponentLayoutEffectMountStopped: markComponentLayoutEffectMountStopped,
      markComponentLayoutEffectUnmountStarted: markComponentLayoutEffectUnmountStarted,
      markComponentLayoutEffectUnmountStopped: markComponentLayoutEffectUnmountStopped,
      markComponentErrored: markComponentErrored,
      markComponentSuspended: markComponentSuspended,
      markLayoutEffectsStarted: markLayoutEffectsStarted,
      markLayoutEffectsStopped: markLayoutEffectsStopped,
      markPassiveEffectsStarted: markPassiveEffectsStarted,
      markPassiveEffectsStopped: markPassiveEffectsStopped,
      markRenderStarted: markRenderStarted,
      markRenderYielded: markRenderYielded,
      markRenderStopped: markRenderStopped,
      markRenderScheduled: markRenderScheduled,
      markForceUpdateScheduled: markForceUpdateScheduled,
      markStateUpdateScheduled: markStateUpdateScheduled
    },
    toggleProfilingStatus: toggleProfilingStatus
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/renderer.js
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function renderer_slicedToArray(arr, i) { return renderer_arrayWithHoles(arr) || renderer_iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || renderer_nonIterableRest(); }

function renderer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function renderer_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function renderer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || renderer_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return renderer_arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = renderer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function renderer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return renderer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return renderer_arrayLikeToArray(o, minLen); }

function renderer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function renderer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return renderer_typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
















function getFiberFlags(fiber) {
  // The name of this field changed from "effectTag" to "flags"
  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;
} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.


var renderer_getCurrentTime = // $FlowFixMe[method-unbinding]
(typeof performance === "undefined" ? "undefined" : renderer_typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
function getInternalReactConstants(version) {
  // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // Technically these priority levels are invalid for versions before 16.9,
  // but 16.9 is the first version to report priority level to DevTools,
  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.
  var ReactPriorityLevels = {
    ImmediatePriority: 99,
    UserBlockingPriority: 98,
    NormalPriority: 97,
    LowPriority: 96,
    IdlePriority: 95,
    NoPriority: 90
  };

  if (Object(backend_utils["h" /* gt */])(version, '17.0.2')) {
    ReactPriorityLevels = {
      ImmediatePriority: 1,
      UserBlockingPriority: 2,
      NormalPriority: 3,
      LowPriority: 4,
      IdlePriority: 5,
      NoPriority: 0
    };
  }

  var StrictModeBits = 0;

  if (Object(backend_utils["i" /* gte */])(version, '18.0.0-alpha')) {
    // 18+
    StrictModeBits = 24;
  } else if (Object(backend_utils["i" /* gte */])(version, '16.9.0')) {
    // 16.9 - 17
    StrictModeBits = 1;
  } else if (Object(backend_utils["i" /* gte */])(version, '16.3.0')) {
    // 16.3 - 16.8
    StrictModeBits = 2;
  }

  var ReactTypeOfWork = null; // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // TODO Update the gt() check below to be gte() whichever the next version number is.
  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).

  if (Object(backend_utils["h" /* gt */])(version, '17.0.1')) {
    ReactTypeOfWork = {
      CacheComponent: 24,
      // Experimental
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: 26,
      // In reality, 18.2+. But doesn't hurt to include it here
      HostSingleton: 27,
      // Same as above
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 23,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 22,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      TracingMarkerComponent: 25,
      // Experimental - This is technically in 18 but we don't
      // want to fork again so we're adding it here instead
      YieldComponent: -1 // Removed

    };
  } else if (Object(backend_utils["i" /* gte */])(version, '17.0.0-alpha')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 24,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 23,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else if (Object(backend_utils["i" /* gte */])(version, '16.6.0-beta.0')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: -1,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 12,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else if (Object(backend_utils["i" /* gte */])(version, '16.4.3-alpha')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 2,
      ContextConsumer: 11,
      ContextProvider: 12,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 13,
      Fragment: 9,
      FunctionComponent: 0,
      HostComponent: 7,
      HostPortal: 6,
      HostRoot: 5,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 8,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 4,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 10,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 2,
      ContextConsumer: 12,
      ContextProvider: 13,
      CoroutineComponent: 7,
      CoroutineHandlerPhase: 8,
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 14,
      Fragment: 10,
      FunctionComponent: 1,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostHoistable: -1,
      // Doesn't exist yet
      HostSingleton: -1,
      // Doesn't exist yet
      HostText: 6,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 0,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 11,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      TracingMarkerComponent: -1,
      // Doesn't exist yet
      YieldComponent: 9
    };
  } // **********************************************************
  // End of copied code.
  // **********************************************************


  function getTypeSymbol(type) {
    var symbolOrNumber = renderer_typeof(type) === 'object' && type !== null ? type.$$typeof : type;
    return renderer_typeof(symbolOrNumber) === 'symbol' ? // $FlowFixMe[incompatible-return] `toString()` doesn't match the type signature?
    symbolOrNumber.toString() : symbolOrNumber;
  }

  var _ReactTypeOfWork = ReactTypeOfWork,
      CacheComponent = _ReactTypeOfWork.CacheComponent,
      ClassComponent = _ReactTypeOfWork.ClassComponent,
      IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,
      FunctionComponent = _ReactTypeOfWork.FunctionComponent,
      IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,
      ForwardRef = _ReactTypeOfWork.ForwardRef,
      HostRoot = _ReactTypeOfWork.HostRoot,
      HostHoistable = _ReactTypeOfWork.HostHoistable,
      HostSingleton = _ReactTypeOfWork.HostSingleton,
      HostComponent = _ReactTypeOfWork.HostComponent,
      HostPortal = _ReactTypeOfWork.HostPortal,
      HostText = _ReactTypeOfWork.HostText,
      Fragment = _ReactTypeOfWork.Fragment,
      LazyComponent = _ReactTypeOfWork.LazyComponent,
      LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent,
      MemoComponent = _ReactTypeOfWork.MemoComponent,
      OffscreenComponent = _ReactTypeOfWork.OffscreenComponent,
      Profiler = _ReactTypeOfWork.Profiler,
      ScopeComponent = _ReactTypeOfWork.ScopeComponent,
      SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,
      SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,
      SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent,
      TracingMarkerComponent = _ReactTypeOfWork.TracingMarkerComponent;

  function resolveFiberType(type) {
    var typeSymbol = getTypeSymbol(type);

    switch (typeSymbol) {
      case ReactSymbols["j" /* MEMO_NUMBER */]:
      case ReactSymbols["k" /* MEMO_SYMBOL_STRING */]:
        // recursively resolving memo type in case of memo(forwardRef(Component))
        return resolveFiberType(type.type);

      case ReactSymbols["f" /* FORWARD_REF_NUMBER */]:
      case ReactSymbols["g" /* FORWARD_REF_SYMBOL_STRING */]:
        return type.render;

      default:
        return type;
    }
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getDisplayNameForFiber(fiber) {
    var elementType = fiber.elementType,
        type = fiber.type,
        tag = fiber.tag;
    var resolvedType = type;

    if (renderer_typeof(type) === 'object' && type !== null) {
      resolvedType = resolveFiberType(type);
    }

    var resolvedContext = null;

    switch (tag) {
      case CacheComponent:
        return 'Cache';

      case ClassComponent:
      case IncompleteClassComponent:
        return Object(utils["h" /* getDisplayName */])(resolvedType);

      case FunctionComponent:
      case IndeterminateComponent:
        return Object(utils["h" /* getDisplayName */])(resolvedType);

      case ForwardRef:
        return Object(utils["l" /* getWrappedDisplayName */])(elementType, resolvedType, 'ForwardRef', 'Anonymous');

      case HostRoot:
        var fiberRoot = fiber.stateNode;

        if (fiberRoot != null && fiberRoot._debugRootType !== null) {
          return fiberRoot._debugRootType;
        }

        return null;

      case HostComponent:
      case HostSingleton:
      case HostHoistable:
        return type;

      case HostPortal:
      case HostText:
        return null;

      case Fragment:
        return 'Fragment';

      case LazyComponent:
        // This display name will not be user visible.
        // Once a Lazy component loads its inner component, React replaces the tag and type.
        // This display name will only show up in console logs when DevTools DEBUG mode is on.
        return 'Lazy';

      case MemoComponent:
      case SimpleMemoComponent:
        // Display name in React does not use `Memo` as a wrapper but fallback name.
        return Object(utils["l" /* getWrappedDisplayName */])(elementType, resolvedType, 'Memo', 'Anonymous');

      case SuspenseComponent:
        return 'Suspense';

      case LegacyHiddenComponent:
        return 'LegacyHidden';

      case OffscreenComponent:
        return 'Offscreen';

      case ScopeComponent:
        return 'Scope';

      case SuspenseListComponent:
        return 'SuspenseList';

      case Profiler:
        return 'Profiler';

      case TracingMarkerComponent:
        return 'TracingMarker';

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case ReactSymbols["a" /* CONCURRENT_MODE_NUMBER */]:
          case ReactSymbols["b" /* CONCURRENT_MODE_SYMBOL_STRING */]:
          case ReactSymbols["e" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:
            return null;

          case ReactSymbols["n" /* PROVIDER_NUMBER */]:
          case ReactSymbols["o" /* PROVIDER_SYMBOL_STRING */]:
            // 16.3.0 exposed the context object as "context"
            // PR #12501 changed it to "_context" for 16.3.1+
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type.context;
            return "".concat(resolvedContext.displayName || 'Context', ".Provider");

          case ReactSymbols["c" /* CONTEXT_NUMBER */]:
          case ReactSymbols["d" /* CONTEXT_SYMBOL_STRING */]:
          case ReactSymbols["r" /* SERVER_CONTEXT_SYMBOL_STRING */]:
            // 16.3-16.5 read from "type" because the Consumer is the actual context object.
            // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'
            // If you change the name, figure out a more resilient way to detect it.

            return "".concat(resolvedContext.displayName || 'Context', ".Consumer");

          case ReactSymbols["s" /* STRICT_MODE_NUMBER */]:
          case ReactSymbols["t" /* STRICT_MODE_SYMBOL_STRING */]:
            return null;

          case ReactSymbols["l" /* PROFILER_NUMBER */]:
          case ReactSymbols["m" /* PROFILER_SYMBOL_STRING */]:
            return "Profiler(".concat(fiber.memoizedProps.id, ")");

          case ReactSymbols["p" /* SCOPE_NUMBER */]:
          case ReactSymbols["q" /* SCOPE_SYMBOL_STRING */]:
            return 'Scope';

          default:
            // Unknown element type.
            // This may mean a new element type that has not yet been added to DevTools.
            return null;
        }

    }
  }

  return {
    getDisplayNameForFiber: getDisplayNameForFiber,
    getTypeSymbol: getTypeSymbol,
    ReactPriorityLevels: ReactPriorityLevels,
    ReactTypeOfWork: ReactTypeOfWork,
    StrictModeBits: StrictModeBits
  };
} // Map of one or more Fibers in a pair to their unique id number.
// We track both Fibers to support Fast Refresh,
// which may forcefully replace one of the pair as part of hot reloading.
// In that case it's still important to be able to locate the previous ID during subsequent renders.

var fiberToIDMap = new Map(); // Map of id to one (arbitrary) Fiber in a pair.
// This Map is used to e.g. get the display name for a Fiber or schedule an update,
// operations that should be the same whether the current and work-in-progress Fiber is used.

var idToArbitraryFiberMap = new Map();
function attach(hook, rendererID, renderer, global) {
  // Newer versions of the reconciler package also specific reconciler version.
  // If that version number is present, use it.
  // Third party renderer versions may not match the reconciler version,
  // and the latter is what's important in terms of tags and symbols.
  var version = renderer.reconcilerVersion || renderer.version;

  var _getInternalReactCons = getInternalReactConstants(version),
      getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,
      getTypeSymbol = _getInternalReactCons.getTypeSymbol,
      ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,
      ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,
      StrictModeBits = _getInternalReactCons.StrictModeBits;

  var CacheComponent = ReactTypeOfWork.CacheComponent,
      ClassComponent = ReactTypeOfWork.ClassComponent,
      ContextConsumer = ReactTypeOfWork.ContextConsumer,
      DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,
      ForwardRef = ReactTypeOfWork.ForwardRef,
      Fragment = ReactTypeOfWork.Fragment,
      FunctionComponent = ReactTypeOfWork.FunctionComponent,
      HostRoot = ReactTypeOfWork.HostRoot,
      HostHoistable = ReactTypeOfWork.HostHoistable,
      HostSingleton = ReactTypeOfWork.HostSingleton,
      HostPortal = ReactTypeOfWork.HostPortal,
      HostComponent = ReactTypeOfWork.HostComponent,
      HostText = ReactTypeOfWork.HostText,
      IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,
      IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,
      LegacyHiddenComponent = ReactTypeOfWork.LegacyHiddenComponent,
      MemoComponent = ReactTypeOfWork.MemoComponent,
      OffscreenComponent = ReactTypeOfWork.OffscreenComponent,
      SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,
      SuspenseComponent = ReactTypeOfWork.SuspenseComponent,
      SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent,
      TracingMarkerComponent = ReactTypeOfWork.TracingMarkerComponent;
  var ImmediatePriority = ReactPriorityLevels.ImmediatePriority,
      UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,
      NormalPriority = ReactPriorityLevels.NormalPriority,
      LowPriority = ReactPriorityLevels.LowPriority,
      IdlePriority = ReactPriorityLevels.IdlePriority,
      NoPriority = ReactPriorityLevels.NoPriority;
  var getLaneLabelMap = renderer.getLaneLabelMap,
      injectProfilingHooks = renderer.injectProfilingHooks,
      overrideHookState = renderer.overrideHookState,
      overrideHookStateDeletePath = renderer.overrideHookStateDeletePath,
      overrideHookStateRenamePath = renderer.overrideHookStateRenamePath,
      overrideProps = renderer.overrideProps,
      overridePropsDeletePath = renderer.overridePropsDeletePath,
      overridePropsRenamePath = renderer.overridePropsRenamePath,
      scheduleRefresh = renderer.scheduleRefresh,
      setErrorHandler = renderer.setErrorHandler,
      setSuspenseHandler = renderer.setSuspenseHandler,
      scheduleUpdate = renderer.scheduleUpdate;
  var supportsTogglingError = typeof setErrorHandler === 'function' && typeof scheduleUpdate === 'function';
  var supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function';

  if (typeof scheduleRefresh === 'function') {
    // When Fast Refresh updates a component, the frontend may need to purge cached information.
    // For example, ASTs cached for the component (for named hooks) may no longer be valid.
    // Send a signal to the frontend to purge this cached information.
    // The "fastRefreshScheduled" dispatched is global (not Fiber or even Renderer specific).
    // This is less effecient since it means the front-end will need to purge the entire cache,
    // but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.
    renderer.scheduleRefresh = function () {
      try {
        hook.emit('fastRefreshScheduled');
      } finally {
        return scheduleRefresh.apply(void 0, arguments);
      }
    };
  }

  var getTimelineData = null;
  var toggleProfilingStatus = null;

  if (typeof injectProfilingHooks === 'function') {
    var response = createProfilingHooks({
      getDisplayNameForFiber: getDisplayNameForFiber,
      getIsProfiling: function getIsProfiling() {
        return isProfiling;
      },
      getLaneLabelMap: getLaneLabelMap,
      currentDispatcherRef: renderer.currentDispatcherRef,
      workTagMap: ReactTypeOfWork,
      reactVersion: version
    }); // Pass the Profiling hooks to the reconciler for it to call during render.

    injectProfilingHooks(response.profilingHooks); // Hang onto this toggle so we can notify the external methods of profiling status changes.

    getTimelineData = response.getTimelineData;
    toggleProfilingStatus = response.toggleProfilingStatus;
  } // Tracks Fibers with recently changed number of error/warning messages.
  // These collections store the Fiber rather than the ID,
  // in order to avoid generating an ID for Fibers that never get mounted
  // (due to e.g. Suspense or error boundaries).
  // onErrorOrWarning() adds Fibers and recordPendingErrorsAndWarnings() later clears them.


  var fibersWithChangedErrorOrWarningCounts = new Set();
  var pendingFiberToErrorsMap = new Map();
  var pendingFiberToWarningsMap = new Map(); // Mapping of fiber IDs to error/warning messages and counts.

  var fiberIDToErrorsMap = new Map();
  var fiberIDToWarningsMap = new Map();

  function clearErrorsAndWarnings() {
    // eslint-disable-next-line no-for-of-loops/no-for-of-loops
    var _iterator = _createForOfIteratorHelper(fiberIDToErrorsMap.keys()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var id = _step.value;

        var _fiber = idToArbitraryFiberMap.get(id);

        if (_fiber != null) {
          fibersWithChangedErrorOrWarningCounts.add(_fiber);
          updateMostRecentlyInspectedElementIfNecessary(id);
        }
      } // eslint-disable-next-line no-for-of-loops/no-for-of-loops

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(fiberIDToWarningsMap.keys()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _id = _step2.value;

        var _fiber2 = idToArbitraryFiberMap.get(_id);

        if (_fiber2 != null) {
          fibersWithChangedErrorOrWarningCounts.add(_fiber2);
          updateMostRecentlyInspectedElementIfNecessary(_id);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    fiberIDToErrorsMap.clear();
    fiberIDToWarningsMap.clear();
    flushPendingEvents();
  }

  function clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
    var fiber = idToArbitraryFiberMap.get(fiberID);

    if (fiber != null) {
      // Throw out any pending changes.
      pendingFiberToErrorsMap.delete(fiber);

      if (fiberIDToMessageCountMap.has(fiberID)) {
        fiberIDToMessageCountMap.delete(fiberID); // If previous flushed counts have changed, schedule an update too.

        fibersWithChangedErrorOrWarningCounts.add(fiber);
        flushPendingEvents();
        updateMostRecentlyInspectedElementIfNecessary(fiberID);
      } else {
        fibersWithChangedErrorOrWarningCounts.delete(fiber);
      }
    }
  }

  function clearErrorsForFiberID(fiberID) {
    clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
  }

  function clearWarningsForFiberID(fiberID) {
    clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
  }

  function updateMostRecentlyInspectedElementIfNecessary(fiberID) {
    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {
      hasElementUpdatedSinceLastInspected = true;
    }
  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).


  function onErrorOrWarning(fiber, type, args) {
    if (type === 'error') {
      var maybeID = getFiberIDUnsafe(fiber); // if this is an error simulated by us to trigger error boundary, ignore

      if (maybeID != null && forceErrorForFiberIDs.get(maybeID) === true) {
        return;
      }
    }

    var message = backend_utils["e" /* format */].apply(void 0, _toConsumableArray(args));

    if (constants["s" /* __DEBUG__ */]) {
      debug('onErrorOrWarning', fiber, null, "".concat(type, ": \"").concat(message, "\""));
    } // Mark this Fiber as needed its warning/error count updated during the next flush.


    fibersWithChangedErrorOrWarningCounts.add(fiber); // Track the warning/error for later.

    var fiberMap = type === 'error' ? pendingFiberToErrorsMap : pendingFiberToWarningsMap;
    var messageMap = fiberMap.get(fiber);

    if (messageMap != null) {
      var count = messageMap.get(message) || 0;
      messageMap.set(message, count + 1);
    } else {
      fiberMap.set(fiber, new Map([[message, 1]]));
    } // Passive effects may trigger errors or warnings too;
    // In this case, we should wait until the rest of the passive effects have run,
    // but we shouldn't wait until the next commit because that might be a long time.
    // This would also cause "tearing" between an inspected Component and the tree view.
    // Then again we don't want to flush too soon because this could be an error during async rendering.
    // Use a debounce technique to ensure that we'll eventually flush.


    flushPendingErrorsAndWarningsAfterDelay();
  } // Patching the console enables DevTools to do a few useful things:
  // * Append component stacks to warnings and error messages
  // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)


  Object(backend_console["e" /* registerRenderer */])(renderer, onErrorOrWarning); // The renderer interface can't read these preferences directly,
  // because it is stored in localStorage within the context of the extension.
  // It relies on the extension to pass the preference through via the global.

  Object(backend_console["c" /* patchConsoleUsingWindowValues */])();

  var debug = function debug(name, fiber, parentFiber) {
    var extraString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    if (constants["s" /* __DEBUG__ */]) {
      var displayName = fiber.tag + ':' + (getDisplayNameForFiber(fiber) || 'null');
      var maybeID = getFiberIDUnsafe(fiber) || '<no id>';
      var parentDisplayName = parentFiber ? parentFiber.tag + ':' + (getDisplayNameForFiber(parentFiber) || 'null') : '';
      var maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || '<no-id>' : '';
      console.groupCollapsed("[renderer] %c".concat(name, " %c").concat(displayName, " (").concat(maybeID, ") %c").concat(parentFiber ? "".concat(parentDisplayName, " (").concat(maybeParentID, ")") : '', " %c").concat(extraString), 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;', 'color: black;');
      console.log(new Error().stack.split('\n').slice(1).join('\n'));
      console.groupEnd();
    }
  }; // Configurable Components tree filters.


  var hideElementsWithDisplayNames = new Set();
  var hideElementsWithPaths = new Set();
  var hideElementsWithTypes = new Set(); // Highlight updates

  var traceUpdatesEnabled = false;
  var traceUpdatesForNodes = new Set();

  function applyComponentFilters(componentFilters) {
    hideElementsWithTypes.clear();
    hideElementsWithDisplayNames.clear();
    hideElementsWithPaths.clear();
    componentFilters.forEach(function (componentFilter) {
      if (!componentFilter.isEnabled) {
        return;
      }

      switch (componentFilter.type) {
        case types["a" /* ComponentFilterDisplayName */]:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case types["b" /* ComponentFilterElementType */]:
          hideElementsWithTypes.add(componentFilter.value);
          break;

        case types["d" /* ComponentFilterLocation */]:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case types["c" /* ComponentFilterHOC */]:
          hideElementsWithDisplayNames.add(new RegExp('\\('));
          break;

        default:
          console.warn("Invalid component filter type \"".concat(componentFilter.type, "\""));
          break;
      }
    });
  } // The renderer interface can't read saved component filters directly,
  // because they are stored in localStorage within the context of the extension.
  // Instead it relies on the extension to pass filters through.


  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {
    applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);
  } else {
    // Unfortunately this feature is not expected to work for React Native for now.
    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,
    // so for now just skip this message...
    //console.warn('⚛️ DevTools: Could not locate saved component filters');
    // Fallback to assuming the default filters in this case.
    applyComponentFilters(Object(utils["g" /* getDefaultComponentFilters */])());
  } // If necessary, we can revisit optimizing this operation.
  // For example, we could add a new recursive unmount tree operation.
  // The unmount operations are already significantly smaller than mount operations though.
  // This is something to keep in mind for later.


  function updateComponentFilters(componentFilters) {
    if (isProfiling) {
      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.
      // If necessary, we could support this- but it doesn't seem like a necessary use case.
      throw Error('Cannot modify filter preferences while profiling');
    } // Recursively unmount all roots.


    hook.getFiberRoots(rendererID).forEach(function (root) {
      currentRootID = getOrGenerateFiberID(root.current); // The TREE_OPERATION_REMOVE_ROOT operation serves two purposes:
      // 1. It avoids sending unnecessary bridge traffic to clear a root.
      // 2. It preserves Fiber IDs when remounting (below) which in turn ID to error/warning mapping.

      pushOperation(constants["n" /* TREE_OPERATION_REMOVE_ROOT */]);
      flushPendingEvents(root);
      currentRootID = -1;
    });
    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.

    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.

    hook.getFiberRoots(rendererID).forEach(function (root) {
      currentRootID = getOrGenerateFiberID(root.current);
      setRootPseudoKey(currentRootID, root.current);
      mountFiberRecursively(root.current, null, false, false);
      flushPendingEvents(root);
      currentRootID = -1;
    }); // Also re-evaluate all error and warning counts given the new filters.

    reevaluateErrorsAndWarnings();
    flushPendingEvents();
  } // NOTICE Keep in sync with get*ForFiber methods


  function shouldFilterFiber(fiber) {
    var _debugSource = fiber._debugSource,
        tag = fiber.tag,
        type = fiber.type,
        key = fiber.key;

    switch (tag) {
      case DehydratedSuspenseComponent:
        // TODO: ideally we would show dehydrated Suspense immediately.
        // However, it has some special behavior (like disconnecting
        // an alternate and turning into real Suspense) which breaks DevTools.
        // For now, ignore it, and only show it once it gets hydrated.
        // https://github.com/bvaughn/react-devtools-experimental/issues/197
        return true;

      case HostPortal:
      case HostText:
      case LegacyHiddenComponent:
      case OffscreenComponent:
        return true;

      case HostRoot:
        // It is never valid to filter the root element.
        return false;

      case Fragment:
        return key === null;

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case ReactSymbols["a" /* CONCURRENT_MODE_NUMBER */]:
          case ReactSymbols["b" /* CONCURRENT_MODE_SYMBOL_STRING */]:
          case ReactSymbols["e" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:
          case ReactSymbols["s" /* STRICT_MODE_NUMBER */]:
          case ReactSymbols["t" /* STRICT_MODE_SYMBOL_STRING */]:
            return true;

          default:
            break;
        }

    }

    var elementType = getElementTypeForFiber(fiber);

    if (hideElementsWithTypes.has(elementType)) {
      return true;
    }

    if (hideElementsWithDisplayNames.size > 0) {
      var displayName = getDisplayNameForFiber(fiber);

      if (displayName != null) {
        // eslint-disable-next-line no-for-of-loops/no-for-of-loops
        var _iterator3 = _createForOfIteratorHelper(hideElementsWithDisplayNames),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var displayNameRegExp = _step3.value;

            if (displayNameRegExp.test(displayName)) {
              return true;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }

    if (_debugSource != null && hideElementsWithPaths.size > 0) {
      var fileName = _debugSource.fileName; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

      var _iterator4 = _createForOfIteratorHelper(hideElementsWithPaths),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var pathRegExp = _step4.value;

          if (pathRegExp.test(fileName)) {
            return true;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }

    return false;
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getElementTypeForFiber(fiber) {
    var type = fiber.type,
        tag = fiber.tag;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        return types["e" /* ElementTypeClass */];

      case FunctionComponent:
      case IndeterminateComponent:
        return types["h" /* ElementTypeFunction */];

      case ForwardRef:
        return types["g" /* ElementTypeForwardRef */];

      case HostRoot:
        return types["m" /* ElementTypeRoot */];

      case HostComponent:
      case HostHoistable:
      case HostSingleton:
        return types["i" /* ElementTypeHostComponent */];

      case HostPortal:
      case HostText:
      case Fragment:
        return types["k" /* ElementTypeOtherOrUnknown */];

      case MemoComponent:
      case SimpleMemoComponent:
        return types["j" /* ElementTypeMemo */];

      case SuspenseComponent:
        return types["n" /* ElementTypeSuspense */];

      case SuspenseListComponent:
        return types["o" /* ElementTypeSuspenseList */];

      case TracingMarkerComponent:
        return types["p" /* ElementTypeTracingMarker */];

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case ReactSymbols["a" /* CONCURRENT_MODE_NUMBER */]:
          case ReactSymbols["b" /* CONCURRENT_MODE_SYMBOL_STRING */]:
          case ReactSymbols["e" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:
            return types["k" /* ElementTypeOtherOrUnknown */];

          case ReactSymbols["n" /* PROVIDER_NUMBER */]:
          case ReactSymbols["o" /* PROVIDER_SYMBOL_STRING */]:
            return types["f" /* ElementTypeContext */];

          case ReactSymbols["c" /* CONTEXT_NUMBER */]:
          case ReactSymbols["d" /* CONTEXT_SYMBOL_STRING */]:
            return types["f" /* ElementTypeContext */];

          case ReactSymbols["s" /* STRICT_MODE_NUMBER */]:
          case ReactSymbols["t" /* STRICT_MODE_SYMBOL_STRING */]:
            return types["k" /* ElementTypeOtherOrUnknown */];

          case ReactSymbols["l" /* PROFILER_NUMBER */]:
          case ReactSymbols["m" /* PROFILER_SYMBOL_STRING */]:
            return types["l" /* ElementTypeProfiler */];

          default:
            return types["k" /* ElementTypeOtherOrUnknown */];
        }

    }
  } // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This is so that we can quickly capture a snapshot of those values if profiling starts.
  // If we didn't store these values, we'd have to crawl the tree when profiling started,
  // and use a slow path to find each of the current Fibers.


  var idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This map enables us to filter these times by root when sending them to the frontend.

  var idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.

  var currentRootID = -1; // Returns the unique ID for a Fiber or generates and caches a new one if the Fiber hasn't been seen before.
  // Once this method has been called for a Fiber, untrackFiberID() should always be called later to avoid leaking.

  function getOrGenerateFiberID(fiber) {
    var id = null;

    if (fiberToIDMap.has(fiber)) {
      id = fiberToIDMap.get(fiber);
    } else {
      var _alternate = fiber.alternate;

      if (_alternate !== null && fiberToIDMap.has(_alternate)) {
        id = fiberToIDMap.get(_alternate);
      }
    }

    var didGenerateID = false;

    if (id === null) {
      didGenerateID = true;
      id = Object(utils["k" /* getUID */])();
    } // This refinement is for Flow purposes only.


    var refinedID = id; // Make sure we're tracking this Fiber
    // e.g. if it just mounted or an error was logged during initial render.

    if (!fiberToIDMap.has(fiber)) {
      fiberToIDMap.set(fiber, refinedID);
      idToArbitraryFiberMap.set(refinedID, fiber);
    } // Also make sure we're tracking its alternate,
    // e.g. in case this is the first update after mount.


    var alternate = fiber.alternate;

    if (alternate !== null) {
      if (!fiberToIDMap.has(alternate)) {
        fiberToIDMap.set(alternate, refinedID);
      }
    }

    if (constants["s" /* __DEBUG__ */]) {
      if (didGenerateID) {
        debug('getOrGenerateFiberID()', fiber, fiber.return, 'Generated a new UID');
      }
    }

    return refinedID;
  } // Returns an ID if one has already been generated for the Fiber or throws.


  function getFiberIDThrows(fiber) {
    var maybeID = getFiberIDUnsafe(fiber);

    if (maybeID !== null) {
      return maybeID;
    }

    throw Error("Could not find ID for Fiber \"".concat(getDisplayNameForFiber(fiber) || '', "\""));
  } // Returns an ID if one has already been generated for the Fiber or null if one has not been generated.
  // Use this method while e.g. logging to avoid over-retaining Fibers.


  function getFiberIDUnsafe(fiber) {
    if (fiberToIDMap.has(fiber)) {
      return fiberToIDMap.get(fiber);
    } else {
      var alternate = fiber.alternate;

      if (alternate !== null && fiberToIDMap.has(alternate)) {
        return fiberToIDMap.get(alternate);
      }
    }

    return null;
  } // Removes a Fiber (and its alternate) from the Maps used to track their id.
  // This method should always be called when a Fiber is unmounting.


  function untrackFiberID(fiber) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('untrackFiberID()', fiber, fiber.return, 'schedule after delay');
    } // Untrack Fibers after a slight delay in order to support a Fast Refresh edge case:
    // 1. Component type is updated and Fast Refresh schedules an update+remount.
    // 2. flushPendingErrorsAndWarningsAfterDelay() runs, sees the old Fiber is no longer mounted
    //    (it's been disconnected by Fast Refresh), and calls untrackFiberID() to clear it from the Map.
    // 3. React flushes pending passive effects before it runs the next render,
    //    which logs an error or warning, which causes a new ID to be generated for this Fiber.
    // 4. DevTools now tries to unmount the old Component with the new ID.
    //
    // The underlying problem here is the premature clearing of the Fiber ID,
    // but DevTools has no way to detect that a given Fiber has been scheduled for Fast Refresh.
    // (The "_debugNeedsRemount" flag won't necessarily be set.)
    //
    // The best we can do is to delay untracking by a small amount,
    // and give React time to process the Fast Refresh delay.


    untrackFibersSet.add(fiber); // React may detach alternate pointers during unmount;
    // Since our untracking code is async, we should explicily track the pending alternate here as well.

    var alternate = fiber.alternate;

    if (alternate !== null) {
      untrackFibersSet.add(alternate);
    }

    if (untrackFibersTimeoutID === null) {
      untrackFibersTimeoutID = setTimeout(untrackFibers, 1000);
    }
  }

  var untrackFibersSet = new Set();
  var untrackFibersTimeoutID = null;

  function untrackFibers() {
    if (untrackFibersTimeoutID !== null) {
      clearTimeout(untrackFibersTimeoutID);
      untrackFibersTimeoutID = null;
    }

    untrackFibersSet.forEach(function (fiber) {
      var fiberID = getFiberIDUnsafe(fiber);

      if (fiberID !== null) {
        idToArbitraryFiberMap.delete(fiberID); // Also clear any errors/warnings associated with this fiber.

        clearErrorsForFiberID(fiberID);
        clearWarningsForFiberID(fiberID);
      }

      fiberToIDMap.delete(fiber);
      var alternate = fiber.alternate;

      if (alternate !== null) {
        fiberToIDMap.delete(alternate);
      }

      if (forceErrorForFiberIDs.has(fiberID)) {
        forceErrorForFiberIDs.delete(fiberID);

        if (forceErrorForFiberIDs.size === 0 && setErrorHandler != null) {
          setErrorHandler(shouldErrorFiberAlwaysNull);
        }
      }
    });
    untrackFibersSet.clear();
  }

  function getChangeDescription(prevFiber, nextFiber) {
    switch (getElementTypeForFiber(nextFiber)) {
      case types["e" /* ElementTypeClass */]:
      case types["h" /* ElementTypeFunction */]:
      case types["j" /* ElementTypeMemo */]:
      case types["g" /* ElementTypeForwardRef */]:
        if (prevFiber === null) {
          return {
            context: null,
            didHooksChange: false,
            isFirstMount: true,
            props: null,
            state: null
          };
        } else {
          var data = {
            context: getContextChangedKeys(nextFiber),
            didHooksChange: false,
            isFirstMount: false,
            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),
            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)
          }; // Only traverse the hooks list once, depending on what info we're returning.

          var indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);
          data.hooks = indices;
          data.didHooksChange = indices !== null && indices.length > 0;
          return data;
        }

      default:
        return null;
    }
  }

  function updateContextsForFiber(fiber) {
    switch (getElementTypeForFiber(fiber)) {
      case types["e" /* ElementTypeClass */]:
      case types["g" /* ElementTypeForwardRef */]:
      case types["h" /* ElementTypeFunction */]:
      case types["j" /* ElementTypeMemo */]:
        if (idToContextsMap !== null) {
          var id = getFiberIDThrows(fiber);
          var contexts = getContextsForFiber(fiber);

          if (contexts !== null) {
            // $FlowFixMe[incompatible-use] found when upgrading Flow
            idToContextsMap.set(id, contexts);
          }
        }

        break;

      default:
        break;
    }
  } // Differentiates between a null context value and no context.


  var NO_CONTEXT = {};

  function getContextsForFiber(fiber) {
    var legacyContext = NO_CONTEXT;
    var modernContext = NO_CONTEXT;

    switch (getElementTypeForFiber(fiber)) {
      case types["e" /* ElementTypeClass */]:
        var instance = fiber.stateNode;

        if (instance != null) {
          if (instance.constructor && instance.constructor.contextType != null) {
            modernContext = instance.context;
          } else {
            legacyContext = instance.context;

            if (legacyContext && Object.keys(legacyContext).length === 0) {
              legacyContext = NO_CONTEXT;
            }
          }
        }

        return [legacyContext, modernContext];

      case types["g" /* ElementTypeForwardRef */]:
      case types["h" /* ElementTypeFunction */]:
      case types["j" /* ElementTypeMemo */]:
        var dependencies = fiber.dependencies;

        if (dependencies && dependencies.firstContext) {
          modernContext = dependencies.firstContext;
        }

        return [legacyContext, modernContext];

      default:
        return null;
    }
  } // Record all contexts at the time profiling is started.
  // Fibers only store the current context value,
  // so we need to track them separately in order to determine changed keys.


  function crawlToInitializeContextsMap(fiber) {
    var id = getFiberIDUnsafe(fiber); // Not all Fibers in the subtree have mounted yet.
    // For example, Offscreen (hidden) or Suspense (suspended) subtrees won't yet be tracked.
    // We can safely skip these subtrees.

    if (id !== null) {
      updateContextsForFiber(fiber);
      var current = fiber.child;

      while (current !== null) {
        crawlToInitializeContextsMap(current);
        current = current.sibling;
      }
    }
  }

  function getContextChangedKeys(fiber) {
    if (idToContextsMap !== null) {
      var id = getFiberIDThrows(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow

      var prevContexts = idToContextsMap.has(id) ? // $FlowFixMe[incompatible-use] found when upgrading Flow
      idToContextsMap.get(id) : null;
      var nextContexts = getContextsForFiber(fiber);

      if (prevContexts == null || nextContexts == null) {
        return null;
      }

      var _prevContexts = renderer_slicedToArray(prevContexts, 2),
          prevLegacyContext = _prevContexts[0],
          prevModernContext = _prevContexts[1];

      var _nextContexts = renderer_slicedToArray(nextContexts, 2),
          nextLegacyContext = _nextContexts[0],
          nextModernContext = _nextContexts[1];

      switch (getElementTypeForFiber(fiber)) {
        case types["e" /* ElementTypeClass */]:
          if (prevContexts && nextContexts) {
            if (nextLegacyContext !== NO_CONTEXT) {
              return getChangedKeys(prevLegacyContext, nextLegacyContext);
            } else if (nextModernContext !== NO_CONTEXT) {
              return prevModernContext !== nextModernContext;
            }
          }

          break;

        case types["g" /* ElementTypeForwardRef */]:
        case types["h" /* ElementTypeFunction */]:
        case types["j" /* ElementTypeMemo */]:
          if (nextModernContext !== NO_CONTEXT) {
            var prevContext = prevModernContext;
            var nextContext = nextModernContext;

            while (prevContext && nextContext) {
              // Note this only works for versions of React that support this key (e.v. 18+)
              // For older versions, there's no good way to read the current context value after render has completed.
              // This is because React maintains a stack of context values during render,
              // but by the time DevTools is called, render has finished and the stack is empty.
              if (!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {
                return true;
              }

              prevContext = prevContext.next;
              nextContext = nextContext.next;
            }

            return false;
          }

          break;

        default:
          break;
      }
    }

    return null;
  }

  function isHookThatCanScheduleUpdate(hookObject) {
    var queue = hookObject.queue;

    if (!queue) {
      return false;
    }

    var boundHasOwnProperty = shared_hasOwnProperty.bind(queue); // Detect the shape of useState() or useReducer()
    // using the attributes that are unique to these hooks
    // but also stable (e.g. not tied to current Lanes implementation)

    var isStateOrReducer = boundHasOwnProperty('pending') && boundHasOwnProperty('dispatch') && typeof queue.dispatch === 'function'; // Detect useSyncExternalStore()

    var isSyncExternalStore = boundHasOwnProperty('value') && boundHasOwnProperty('getSnapshot') && typeof queue.getSnapshot === 'function'; // These are the only types of hooks that can schedule an update.

    return isStateOrReducer || isSyncExternalStore;
  }

  function didStatefulHookChange(prev, next) {
    var prevMemoizedState = prev.memoizedState;
    var nextMemoizedState = next.memoizedState;

    if (isHookThatCanScheduleUpdate(prev)) {
      return prevMemoizedState !== nextMemoizedState;
    }

    return false;
  }

  function getChangedHooksIndices(prev, next) {
    if (prev == null || next == null) {
      return null;
    }

    var indices = [];
    var index = 0;

    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      while (next !== null) {
        if (didStatefulHookChange(prev, next)) {
          indices.push(index);
        }

        next = next.next;
        prev = prev.next;
        index++;
      }
    }

    return indices;
  }

  function getChangedKeys(prev, next) {
    if (prev == null || next == null) {
      return null;
    } // We can't report anything meaningful for hooks changes.


    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      return null;
    }

    var keys = new Set([].concat(_toConsumableArray(Object.keys(prev)), _toConsumableArray(Object.keys(next))));
    var changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

    var _iterator5 = _createForOfIteratorHelper(keys),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var key = _step5.value;

        if (prev[key] !== next[key]) {
          changedKeys.push(key);
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    return changedKeys;
  } // eslint-disable-next-line no-unused-vars


  function didFiberRender(prevFiber, nextFiber) {
    switch (nextFiber.tag) {
      case ClassComponent:
      case FunctionComponent:
      case ContextConsumer:
      case MemoComponent:
      case SimpleMemoComponent:
      case ForwardRef:
        // For types that execute user code, we check PerformedWork effect.
        // We don't reflect bailouts (either referential or sCU) in DevTools.
        // TODO: This flag is a leaked implementation detail. Once we start
        // releasing DevTools in lockstep with React, we should import a
        // function from the reconciler instead.
        var PerformedWork = 1;
        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;
      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+
      // so it won't get highlighted with React 16.3.0 to 16.3.2.

      default:
        // For host components and other types, we compare inputs
        // to determine whether something is an update.
        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;
    }
  }

  var pendingOperations = [];
  var pendingRealUnmountedIDs = [];
  var pendingSimulatedUnmountedIDs = [];
  var pendingOperationsQueue = [];
  var pendingStringTable = new Map();
  var pendingStringTableLength = 0;
  var pendingUnmountedRootID = null;

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function shouldBailoutWithPendingOperations() {
    if (isProfiling) {
      if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {
        return false;
      }
    }

    return pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null;
  }

  function flushOrQueueOperations(operations) {
    if (shouldBailoutWithPendingOperations()) {
      return;
    }

    if (pendingOperationsQueue !== null) {
      pendingOperationsQueue.push(operations);
    } else {
      hook.emit('operations', operations);
    }
  }

  var flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;

  function clearPendingErrorsAndWarningsAfterDelay() {
    if (flushPendingErrorsAndWarningsAfterDelayTimeoutID !== null) {
      clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);
      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;
    }
  }

  function flushPendingErrorsAndWarningsAfterDelay() {
    clearPendingErrorsAndWarningsAfterDelay();
    flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(function () {
      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;

      if (pendingOperations.length > 0) {
        // On the off chance that something else has pushed pending operations,
        // we should bail on warnings; it's probably not safe to push midway.
        return;
      }

      recordPendingErrorsAndWarnings();

      if (shouldBailoutWithPendingOperations()) {
        // No warnings or errors to flush; we can bail out early here too.
        return;
      } // We can create a smaller operations array than flushPendingEvents()
      // because we only need to flush warning and error counts.
      // Only a few pieces of fixed information are required up front.


      var operations = new Array(3 + pendingOperations.length);
      operations[0] = rendererID;
      operations[1] = currentRootID;
      operations[2] = 0; // String table size

      for (var j = 0; j < pendingOperations.length; j++) {
        operations[3 + j] = pendingOperations[j];
      }

      flushOrQueueOperations(operations);
      pendingOperations.length = 0;
    }, 1000);
  }

  function reevaluateErrorsAndWarnings() {
    fibersWithChangedErrorOrWarningCounts.clear();
    fiberIDToErrorsMap.forEach(function (countMap, fiberID) {
      var fiber = idToArbitraryFiberMap.get(fiberID);

      if (fiber != null) {
        fibersWithChangedErrorOrWarningCounts.add(fiber);
      }
    });
    fiberIDToWarningsMap.forEach(function (countMap, fiberID) {
      var fiber = idToArbitraryFiberMap.get(fiberID);

      if (fiber != null) {
        fibersWithChangedErrorOrWarningCounts.add(fiber);
      }
    });
    recordPendingErrorsAndWarnings();
  }

  function mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
    var newCount = 0;
    var messageCountMap = fiberIDToMessageCountMap.get(fiberID);
    var pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);

    if (pendingMessageCountMap != null) {
      if (messageCountMap == null) {
        messageCountMap = pendingMessageCountMap;
        fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);
      } else {
        // This Flow refinement should not be necessary and yet...
        var refinedMessageCountMap = messageCountMap;
        pendingMessageCountMap.forEach(function (pendingCount, message) {
          var previousCount = refinedMessageCountMap.get(message) || 0;
          refinedMessageCountMap.set(message, previousCount + pendingCount);
        });
      }
    }

    if (!shouldFilterFiber(fiber)) {
      if (messageCountMap != null) {
        messageCountMap.forEach(function (count) {
          newCount += count;
        });
      }
    }

    pendingFiberToMessageCountMap.delete(fiber);
    return newCount;
  }

  function recordPendingErrorsAndWarnings() {
    clearPendingErrorsAndWarningsAfterDelay();
    fibersWithChangedErrorOrWarningCounts.forEach(function (fiber) {
      var fiberID = getFiberIDUnsafe(fiber);

      if (fiberID === null) {// Don't send updates for Fibers that didn't mount due to e.g. Suspense or an error boundary.
      } else {
        var errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
        var warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
        pushOperation(constants["q" /* TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS */]);
        pushOperation(fiberID);
        pushOperation(errorCount);
        pushOperation(warningCount);
      } // Always clean up so that we don't leak.


      pendingFiberToErrorsMap.delete(fiber);
      pendingFiberToWarningsMap.delete(fiber);
    });
    fibersWithChangedErrorOrWarningCounts.clear();
  }

  function flushPendingEvents(root) {
    // Add any pending errors and warnings to the operations array.
    // We do this just before flushing, so we can ignore errors for no-longer-mounted Fibers.
    recordPendingErrorsAndWarnings();

    if (shouldBailoutWithPendingOperations()) {
      // If we aren't profiling, we can just bail out here.
      // No use sending an empty update over the bridge.
      //
      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:
      // (1) an initial tree snapshot and
      // (2) the operations array for each commit
      // Because of this, it's important that the operations and metadata arrays align,
      // So it's important not to omit even empty operations while profiling is active.
      return;
    }

    var numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    var operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber props, states, and hooks to be inspected.

    var i = 0;
    operations[i++] = rendererID;
    operations[i++] = currentRootID; // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach(function (entry, stringKey) {
      var encodedString = entry.encodedString; // Don't use the string length.
      // It won't work for multibyte characters (like emoji).

      var length = encodedString.length;
      operations[i++] = length;

      for (var j = 0; j < length; j++) {
        operations[i + j] = encodedString[j];
      }

      i += length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = constants["m" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.
      // They were inserted parents-first by React, but we want children-first.
      // So we traverse our array backwards.

      for (var j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {
        operations[i++] = pendingRealUnmountedIDs[j];
      } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.
      // (We want children to go before parents.)
      // They go *after* the real unmounts because we know for sure they won't be
      // children of already pushed "real" IDs. If they were, we wouldn't be able
      // to discover them during the traversal, as they would have been deleted.


      for (var _j = 0; _j < pendingSimulatedUnmountedIDs.length; _j++) {
        operations[i + _j] = pendingSimulatedUnmountedIDs[_j];
      }

      i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.

      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (var _j2 = 0; _j2 < pendingOperations.length; _j2++) {
      operations[i + _j2] = pendingOperations[_j2];
    }

    i += pendingOperations.length; // Let the frontend know about tree operations.

    flushOrQueueOperations(operations); // Reset all of the pending state now that we've told the frontend about it.

    pendingOperations.length = 0;
    pendingRealUnmountedIDs.length = 0;
    pendingSimulatedUnmountedIDs.length = 0;
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function getStringID(string) {
    if (string === null) {
      return 0;
    }

    var existingEntry = pendingStringTable.get(string);

    if (existingEntry !== undefined) {
      return existingEntry.id;
    }

    var id = pendingStringTable.size + 1;
    var encodedString = Object(utils["p" /* utfEncodeString */])(string);
    pendingStringTable.set(string, {
      encodedString: encodedString,
      id: id
    }); // The string table total length needs to account both for the string length,
    // and for the array item that contains the length itself.
    //
    // Don't use string length for this table.
    // It won't work for multibyte characters (like emoji).

    pendingStringTableLength += encodedString.length + 1;
    return id;
  }

  function recordMount(fiber, parentFiber) {
    var isRoot = fiber.tag === HostRoot;
    var id = getOrGenerateFiberID(fiber);

    if (constants["s" /* __DEBUG__ */]) {
      debug('recordMount()', fiber, parentFiber);
    }

    var hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');
    var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration'); // Adding a new field here would require a bridge protocol version bump (a backwads breaking change).
    // Instead let's re-purpose a pre-existing field to carry more information.

    var profilingFlags = 0;

    if (isProfilingSupported) {
      profilingFlags = constants["g" /* PROFILING_FLAG_BASIC_SUPPORT */];

      if (typeof injectProfilingHooks === 'function') {
        profilingFlags |= constants["h" /* PROFILING_FLAG_TIMELINE_SUPPORT */];
      }
    }

    if (isRoot) {
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(types["m" /* ElementTypeRoot */]);
      pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);
      pushOperation(profilingFlags);
      pushOperation(StrictModeBits !== 0 ? 1 : 0);
      pushOperation(hasOwnerMetadata ? 1 : 0);

      if (isProfiling) {
        if (displayNamesByRootID !== null) {
          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));
        }
      }
    } else {
      var key = fiber.key;
      var displayName = getDisplayNameForFiber(fiber);
      var elementType = getElementTypeForFiber(fiber);
      var _debugOwner = fiber._debugOwner; // Ideally we should call getFiberIDThrows() for _debugOwner,
      // since owners are almost always higher in the tree (and so have already been processed),
      // but in some (rare) instances reported in open source, a descendant mounts before an owner.
      // Since this is a DEV only field it's probably okay to also just lazily generate and ID here if needed.
      // See https://github.com/facebook/react/issues/21445

      var ownerID = _debugOwner != null ? getOrGenerateFiberID(_debugOwner) : 0;
      var parentID = parentFiber ? getFiberIDThrows(parentFiber) : 0;
      var displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified
      // in such a way as to bypass the default stringification of the "key" property.

      var keyString = key === null ? null : String(key);
      var keyStringID = getStringID(keyString);
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(elementType);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID); // If this subtree has a new mode, let the frontend know.

      if ((fiber.mode & StrictModeBits) !== 0 && (parentFiber.mode & StrictModeBits) === 0) {
        pushOperation(constants["p" /* TREE_OPERATION_SET_SUBTREE_MODE */]);
        pushOperation(id);
        pushOperation(types["q" /* StrictMode */]);
      }
    }

    if (isProfilingSupported) {
      idToRootMap.set(id, currentRootID);
      recordProfilingDurations(fiber);
    }
  }

  function recordUnmount(fiber, isSimulated) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('recordUnmount()', fiber, null, isSimulated ? 'unmount is simulated' : '');
    }

    if (trackedPathMatchFiber !== null) {
      // We're in the process of trying to restore previous selection.
      // If this fiber matched but is being unmounted, there's no use trying.
      // Reset the state so we don't keep holding onto it.
      if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {
        setTrackedPath(null);
      }
    }

    var unsafeID = getFiberIDUnsafe(fiber);

    if (unsafeID === null) {
      // If we've never seen this Fiber, it might be inside of a legacy render Suspense fragment (so the store is not even aware of it).
      // In that case we can just ignore it or it will cause errors later on.
      // One example of this is a Lazy component that never resolves before being unmounted.
      //
      // This also might indicate a Fast Refresh force-remount scenario.
      //
      // TODO: This is fragile and can obscure actual bugs.
      return;
    } // Flow refinement.


    var id = unsafeID;
    var isRoot = fiber.tag === HostRoot;

    if (isRoot) {
      // Roots must be removed only after all children (pending and simulated) have been removed.
      // So we track it separately.
      pendingUnmountedRootID = id;
    } else if (!shouldFilterFiber(fiber)) {
      // To maintain child-first ordering,
      // we'll push it into one of these queues,
      // and later arrange them in the correct order.
      if (isSimulated) {
        pendingSimulatedUnmountedIDs.push(id);
      } else {
        pendingRealUnmountedIDs.push(id);
      }
    }

    if (!fiber._debugNeedsRemount) {
      untrackFiberID(fiber);
      var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');

      if (isProfilingSupported) {
        idToRootMap.delete(id);
        idToTreeBaseDurationMap.delete(id);
      }
    }
  }

  function mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {
    // Iterate over siblings rather than recursing.
    // This reduces the chance of stack overflow for wide trees (e.g. lists with many items).
    var fiber = firstChild;

    while (fiber !== null) {
      // Generate an ID even for filtered Fibers, in case it's needed later (e.g. for Profiling).
      getOrGenerateFiberID(fiber);

      if (constants["s" /* __DEBUG__ */]) {
        debug('mountFiberRecursively()', fiber, parentFiber);
      } // If we have the tree selection from previous reload, try to match this Fiber.
      // Also remember whether to do the same for siblings.


      var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);
      var shouldIncludeInTree = !shouldFilterFiber(fiber);

      if (shouldIncludeInTree) {
        recordMount(fiber, parentFiber);
      }

      if (traceUpdatesEnabled) {
        if (traceNearestHostComponentUpdate) {
          var elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.

          if (elementType === types["i" /* ElementTypeHostComponent */]) {
            traceUpdatesForNodes.add(fiber.stateNode);
            traceNearestHostComponentUpdate = false;
          }
        } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,
        // because we don't want to highlight every host node inside of a newly mounted subtree.

      }

      var isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;

      if (isSuspense) {
        var isTimedOut = fiber.memoizedState !== null;

        if (isTimedOut) {
          // Special case: if Suspense mounts in a timed-out state,
          // get the fallback child from the inner fragment and mount
          // it as if it was our own child. Updates handle this too.
          var primaryChildFragment = fiber.child;
          var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
          var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

          if (fallbackChild !== null) {
            mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
          }
        } else {
          var primaryChild = null;
          var areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;

          if (areSuspenseChildrenConditionallyWrapped) {
            primaryChild = fiber.child;
          } else if (fiber.child !== null) {
            primaryChild = fiber.child.child;
          }

          if (primaryChild !== null) {
            mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
          }
        }
      } else {
        if (fiber.child !== null) {
          mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
        }
      } // We're exiting this Fiber now, and entering its siblings.
      // If we have selection to restore, we might need to re-activate tracking.


      updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);
      fiber = traverseSiblings ? fiber.sibling : null;
    }
  } // We use this to simulate unmounting for Suspense trees
  // when we switch from primary to fallback.


  function unmountFiberChildrenRecursively(fiber) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('unmountFiberChildrenRecursively()', fiber);
    } // We might meet a nested Suspense on our way.


    var isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;
    var child = fiber.child;

    if (isTimedOutSuspense) {
      // If it's showing fallback tree, let's traverse it instead.
      var primaryChildFragment = fiber.child;
      var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.

      child = fallbackChildFragment ? fallbackChildFragment.child : null;
    }

    while (child !== null) {
      // Record simulated unmounts children-first.
      // We skip nodes without return because those are real unmounts.
      if (child.return !== null) {
        unmountFiberChildrenRecursively(child);
        recordUnmount(child, true);
      }

      child = child.sibling;
    }
  }

  function recordProfilingDurations(fiber) {
    var id = getFiberIDThrows(fiber);
    var actualDuration = fiber.actualDuration,
        treeBaseDuration = fiber.treeBaseDuration;
    idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);

    if (isProfiling) {
      var alternate = fiber.alternate; // It's important to update treeBaseDuration even if the current Fiber did not render,
      // because it's possible that one of its descendants did.

      if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {
        // Tree base duration updates are included in the operations typed array.
        // So we have to convert them from milliseconds to microseconds so we can send them as ints.
        var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);
        pushOperation(constants["r" /* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */]);
        pushOperation(id);
        pushOperation(convertedTreeBaseDuration);
      }

      if (alternate == null || didFiberRender(alternate, fiber)) {
        if (actualDuration != null) {
          // The actual duration reported by React includes time spent working on children.
          // This is useful information, but it's also useful to be able to exclude child durations.
          // The frontend can't compute this, since the immediate children may have been filtered out.
          // So we need to do this on the backend.
          // Note that this calculated self duration is not the same thing as the base duration.
          // The two are calculated differently (tree duration does not accumulate).
          var selfDuration = actualDuration;
          var child = fiber.child;

          while (child !== null) {
            selfDuration -= child.actualDuration || 0;
            child = child.sibling;
          } // If profiling is active, store durations for elements that were rendered during the commit.
          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.
          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)
          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we "bailed out".


          var metadata = currentCommitProfilingMetadata;
          metadata.durations.push(id, actualDuration, selfDuration);
          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);

          if (recordChangeDescriptions) {
            var changeDescription = getChangeDescription(alternate, fiber);

            if (changeDescription !== null) {
              if (metadata.changeDescriptions !== null) {
                metadata.changeDescriptions.set(id, changeDescription);
              }
            }

            updateContextsForFiber(fiber);
          }
        }
      }
    }
  }

  function recordResetChildren(fiber, childSet) {
    if (constants["s" /* __DEBUG__ */]) {
      debug('recordResetChildren()', childSet, fiber);
    } // The frontend only really cares about the displayName, key, and children.
    // The first two don't really change, so we are only concerned with the order of children here.
    // This is trickier than a simple comparison though, since certain types of fibers are filtered.


    var nextChildren = []; // This is a naive implementation that shallowly recourses children.
    // We might want to revisit this if it proves to be too inefficient.

    var child = childSet;

    while (child !== null) {
      findReorderedChildrenRecursively(child, nextChildren);
      child = child.sibling;
    }

    var numChildren = nextChildren.length;

    if (numChildren < 2) {
      // No need to reorder.
      return;
    }

    pushOperation(constants["o" /* TREE_OPERATION_REORDER_CHILDREN */]);
    pushOperation(getFiberIDThrows(fiber));
    pushOperation(numChildren);

    for (var i = 0; i < nextChildren.length; i++) {
      pushOperation(nextChildren[i]);
    }
  }

  function findReorderedChildrenRecursively(fiber, nextChildren) {
    if (!shouldFilterFiber(fiber)) {
      nextChildren.push(getFiberIDThrows(fiber));
    } else {
      var child = fiber.child;
      var isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;

      if (isTimedOutSuspense) {
        // Special case: if Suspense mounts in a timed-out state,
        // get the fallback child from the inner fragment,
        // and skip over the primary child.
        var primaryChildFragment = fiber.child;
        var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
        var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

        if (fallbackChild !== null) {
          child = fallbackChild;
        }
      }

      while (child !== null) {
        findReorderedChildrenRecursively(child, nextChildren);
        child = child.sibling;
      }
    }
  } // Returns whether closest unfiltered fiber parent needs to reset its child list.


  function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {
    var id = getOrGenerateFiberID(nextFiber);

    if (constants["s" /* __DEBUG__ */]) {
      debug('updateFiberRecursively()', nextFiber, parentFiber);
    }

    if (traceUpdatesEnabled) {
      var elementType = getElementTypeForFiber(nextFiber);

      if (traceNearestHostComponentUpdate) {
        // If an ancestor updated, we should mark the nearest host nodes for highlighting.
        if (elementType === types["i" /* ElementTypeHostComponent */]) {
          traceUpdatesForNodes.add(nextFiber.stateNode);
          traceNearestHostComponentUpdate = false;
        }
      } else {
        if (elementType === types["h" /* ElementTypeFunction */] || elementType === types["e" /* ElementTypeClass */] || elementType === types["f" /* ElementTypeContext */] || elementType === types["j" /* ElementTypeMemo */] || elementType === types["g" /* ElementTypeForwardRef */]) {
          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).
          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);
        }
      }
    }

    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && didFiberRender(prevFiber, nextFiber)) {
      // If this Fiber has updated, clear cached inspected data.
      // If it is inspected again, it may need to be re-run to obtain updated hooks values.
      hasElementUpdatedSinceLastInspected = true;
    }

    var shouldIncludeInTree = !shouldFilterFiber(nextFiber);
    var isSuspense = nextFiber.tag === SuspenseComponent;
    var shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.
    // Rather than unmount the timed out content (and possibly lose important state),
    // React re-parents this content within a hidden Fragment while the fallback is showing.
    // This behavior doesn't need to be observable in the DevTools though.
    // It might even result in a bad user experience for e.g. node selection in the Elements panel.
    // The easiest fix is to strip out the intermediate Fragment fibers,
    // so the Elements panel and Profiler don't need to special case them.
    // Suspense components only have a non-null memoizedState if they're timed-out.

    var prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;
    var nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()
    // inside ReactFiberBeginWork in the React source code.

    if (prevDidTimeout && nextDidTimeOut) {
      // Fallback -> Fallback:
      // 1. Reconcile fallback set.
      var nextFiberChild = nextFiber.child;
      var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate
      // because the set is special and alternate may not exist.

      var prevFiberChild = prevFiber.child;
      var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;

      if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {
        shouldResetChildren = true;
      }
    } else if (prevDidTimeout && !nextDidTimeOut) {
      // Fallback -> Primary:
      // 1. Unmount fallback set
      // Note: don't emulate fallback unmount because React actually did it.
      // 2. Mount primary set
      var nextPrimaryChildSet = nextFiber.child;

      if (nextPrimaryChildSet !== null) {
        mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
      }

      shouldResetChildren = true;
    } else if (!prevDidTimeout && nextDidTimeOut) {
      // Primary -> Fallback:
      // 1. Hide primary set
      // This is not a real unmount, so it won't get reported by React.
      // We need to manually walk the previous tree and record unmounts.
      unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set

      var _nextFiberChild = nextFiber.child;

      var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;

      if (_nextFallbackChildSet != null) {
        mountFiberRecursively(_nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
        shouldResetChildren = true;
      }
    } else {
      // Common case: Primary -> Primary.
      // This is the same code path as for non-Suspense fibers.
      if (nextFiber.child !== prevFiber.child) {
        // If the first child is different, we need to traverse them.
        // Each next child will be either a new child (mount) or an alternate (update).
        var nextChild = nextFiber.child;
        var prevChildAtSameIndex = prevFiber.child;

        while (nextChild) {
          // We already know children will be referentially different because
          // they are either new mounts or alternates of previous children.
          // Schedule updates and mounts depending on whether alternates exist.
          // We don't track deletions here because they are reported separately.
          if (nextChild.alternate) {
            var prevChild = nextChild.alternate;

            if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {
              // If a nested tree child order changed but it can't handle its own
              // child order invalidation (e.g. because it's filtered out like host nodes),
              // propagate the need to reset child order upwards to this Fiber.
              shouldResetChildren = true;
            } // However we also keep track if the order of the children matches
            // the previous order. They are always different referentially, but
            // if the instances line up conceptually we'll want to know that.


            if (prevChild !== prevChildAtSameIndex) {
              shouldResetChildren = true;
            }
          } else {
            mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);
            shouldResetChildren = true;
          } // Try the next child.


          nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can
          // keep comparing if they line up.

          if (!shouldResetChildren && prevChildAtSameIndex !== null) {
            prevChildAtSameIndex = prevChildAtSameIndex.sibling;
          }
        } // If we have no more children, but used to, they don't line up.


        if (prevChildAtSameIndex !== null) {
          shouldResetChildren = true;
        }
      } else {
        if (traceUpdatesEnabled) {
          // If we're tracing updates and we've bailed out before reaching a host node,
          // we should fall back to recursively marking the nearest host descendants for highlight.
          if (traceNearestHostComponentUpdate) {
            var hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));
            hostFibers.forEach(function (hostFiber) {
              traceUpdatesForNodes.add(hostFiber.stateNode);
            });
          }
        }
      }
    }

    if (shouldIncludeInTree) {
      var isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');

      if (isProfilingSupported) {
        recordProfilingDurations(nextFiber);
      }
    }

    if (shouldResetChildren) {
      // We need to crawl the subtree for closest non-filtered Fibers
      // so that we can display them in a flat children set.
      if (shouldIncludeInTree) {
        // Normally, search for children from the rendered child.
        var nextChildSet = nextFiber.child;

        if (nextDidTimeOut) {
          // Special case: timed-out Suspense renders the fallback set.
          var _nextFiberChild2 = nextFiber.child;
          nextChildSet = _nextFiberChild2 ? _nextFiberChild2.sibling : null;
        }

        if (nextChildSet != null) {
          recordResetChildren(nextFiber, nextChildSet);
        } // We've handled the child order change for this Fiber.
        // Since it's included, there's no need to invalidate parent child order.


        return false;
      } else {
        // Let the closest unfiltered parent Fiber reset its child order instead.
        return true;
      }
    } else {
      return false;
    }
  }

  function cleanup() {// We don't patch any methods so there is no cleanup.
  }

  function rootSupportsProfiling(root) {
    if (root.memoizedInteractions != null) {
      // v16 builds include this field for the scheduler/tracing API.
      return true;
    } else if (root.current != null && root.current.hasOwnProperty('treeBaseDuration')) {
      // The scheduler/tracing API was removed in v17 though
      // so we need to check a non-root Fiber.
      return true;
    } else {
      return false;
    }
  }

  function flushInitialOperations() {
    var localPendingOperationsQueue = pendingOperationsQueue;
    pendingOperationsQueue = null;

    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {
      // We may have already queued up some operations before the frontend connected
      // If so, let the frontend know about them.
      localPendingOperationsQueue.forEach(function (operations) {
        hook.emit('operations', operations);
      });
    } else {
      // Before the traversals, remember to start tracking
      // our path in case we have selection to restore.
      if (trackedPath !== null) {
        mightBeOnTrackedPath = true;
      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.


      hook.getFiberRoots(rendererID).forEach(function (root) {
        currentRootID = getOrGenerateFiberID(root.current);
        setRootPseudoKey(currentRootID, root.current); // Handle multi-renderer edge-case where only some v16 renderers support profiling.

        if (isProfiling && rootSupportsProfiling(root)) {
          // If profiling is active, store commit time and duration.
          // The frontend may request this information after profiling has stopped.
          currentCommitProfilingMetadata = {
            changeDescriptions: recordChangeDescriptions ? new Map() : null,
            durations: [],
            commitTime: renderer_getCurrentTime() - profilingStartTime,
            maxActualDuration: 0,
            priorityLevel: null,
            updaters: getUpdatersList(root),
            effectDuration: null,
            passiveEffectDuration: null
          };
        }

        mountFiberRecursively(root.current, null, false, false);
        flushPendingEvents(root);
        currentRootID = -1;
      });
    }
  }

  function getUpdatersList(root) {
    return root.memoizedUpdaters != null ? Array.from(root.memoizedUpdaters).filter(function (fiber) {
      return getFiberIDUnsafe(fiber) !== null;
    }).map(fiberToSerializedElement) : null;
  }

  function handleCommitFiberUnmount(fiber) {
    // If the untrackFiberSet already has the unmounted Fiber, this means we've already
    // recordedUnmount, so we don't need to do it again. If we don't do this, we might
    // end up double-deleting Fibers in some cases (like Legacy Suspense).
    if (!untrackFibersSet.has(fiber)) {
      // This is not recursive.
      // We can't traverse fibers after unmounting so instead
      // we rely on React telling us about each unmount.
      recordUnmount(fiber, false);
    }
  }

  function handlePostCommitFiberRoot(root) {
    if (isProfiling && rootSupportsProfiling(root)) {
      if (currentCommitProfilingMetadata !== null) {
        var _getEffectDurations = Object(backend_utils["g" /* getEffectDurations */])(root),
            effectDuration = _getEffectDurations.effectDuration,
            passiveEffectDuration = _getEffectDurations.passiveEffectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow


        currentCommitProfilingMetadata.effectDuration = effectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow

        currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;
      }
    }
  }

  function handleCommitFiberRoot(root, priorityLevel) {
    var current = root.current;
    var alternate = current.alternate; // Flush any pending Fibers that we are untracking before processing the new commit.
    // If we don't do this, we might end up double-deleting Fibers in some cases (like Legacy Suspense).

    untrackFibers();
    currentRootID = getOrGenerateFiberID(current); // Before the traversals, remember to start tracking
    // our path in case we have selection to restore.

    if (trackedPath !== null) {
      mightBeOnTrackedPath = true;
    }

    if (traceUpdatesEnabled) {
      traceUpdatesForNodes.clear();
    } // Handle multi-renderer edge-case where only some v16 renderers support profiling.


    var isProfilingSupported = rootSupportsProfiling(root);

    if (isProfiling && isProfilingSupported) {
      // If profiling is active, store commit time and duration.
      // The frontend may request this information after profiling has stopped.
      currentCommitProfilingMetadata = {
        changeDescriptions: recordChangeDescriptions ? new Map() : null,
        durations: [],
        commitTime: renderer_getCurrentTime() - profilingStartTime,
        maxActualDuration: 0,
        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),
        updaters: getUpdatersList(root),
        // Initialize to null; if new enough React version is running,
        // these values will be read during separate handlePostCommitFiberRoot() call.
        effectDuration: null,
        passiveEffectDuration: null
      };
    }

    if (alternate) {
      // TODO: relying on this seems a bit fishy.
      var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && // A dehydrated root is not considered mounted
      alternate.memoizedState.isDehydrated !== true;
      var isMounted = current.memoizedState != null && current.memoizedState.element != null && // A dehydrated root is not considered mounted
      current.memoizedState.isDehydrated !== true;

      if (!wasMounted && isMounted) {
        // Mount a new root.
        setRootPseudoKey(currentRootID, current);
        mountFiberRecursively(current, null, false, false);
      } else if (wasMounted && isMounted) {
        // Update an existing root.
        updateFiberRecursively(current, alternate, null, false);
      } else if (wasMounted && !isMounted) {
        // Unmount an existing root.
        removeRootPseudoKey(currentRootID);
        recordUnmount(current, false);
      }
    } else {
      // Mount a new root.
      setRootPseudoKey(currentRootID, current);
      mountFiberRecursively(current, null, false, false);
    }

    if (isProfiling && isProfilingSupported) {
      if (!shouldBailoutWithPendingOperations()) {
        var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);

        if (commitProfilingMetadata != null) {
          commitProfilingMetadata.push(currentCommitProfilingMetadata);
        } else {
          rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);
        }
      }
    } // We're done here.


    flushPendingEvents(root);

    if (traceUpdatesEnabled) {
      hook.emit('traceUpdates', traceUpdatesForNodes);
    }

    currentRootID = -1;
  }

  function findAllCurrentHostFibers(id) {
    var fibers = [];
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (!fiber) {
      return fibers;
    } // Next we'll drill down this component to find all HostComponent/Text.


    var node = fiber;

    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        fibers.push(node);
      } else if (node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return fibers;
      }

      while (!node.sibling) {
        if (!node.return || node.return === fiber) {
          return fibers;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    } // Flow needs the return here, but ESLint complains about it.
    // eslint-disable-next-line no-unreachable


    return fibers;
  }

  function findNativeNodesForFiberID(id) {
    try {
      var _fiber3 = findCurrentFiberUsingSlowPathById(id);

      if (_fiber3 === null) {
        return null;
      } // Special case for a timed-out Suspense.


      var isTimedOutSuspense = _fiber3.tag === SuspenseComponent && _fiber3.memoizedState !== null;

      if (isTimedOutSuspense) {
        // A timed-out Suspense's findDOMNode is useless.
        // Try our best to find the fallback directly.
        var maybeFallbackFiber = _fiber3.child && _fiber3.child.sibling;

        if (maybeFallbackFiber != null) {
          _fiber3 = maybeFallbackFiber;
        }
      }

      var hostFibers = findAllCurrentHostFibers(id);
      return hostFibers.map(function (hostFiber) {
        return hostFiber.stateNode;
      }).filter(Boolean);
    } catch (err) {
      // The fiber might have unmounted by now.
      return null;
    }
  }

  function getDisplayNameForFiberID(id) {
    var fiber = idToArbitraryFiberMap.get(id);
    return fiber != null ? getDisplayNameForFiber(fiber) : null;
  }

  function getFiberForNative(hostInstance) {
    return renderer.findFiberByHostInstance(hostInstance);
  }

  function getFiberIDForNative(hostInstance) {
    var findNearestUnfilteredAncestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var fiber = renderer.findFiberByHostInstance(hostInstance);

    if (fiber != null) {
      if (findNearestUnfilteredAncestor) {
        while (fiber !== null && shouldFilterFiber(fiber)) {
          fiber = fiber.return;
        }
      }

      return getFiberIDThrows(fiber);
    }

    return null;
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js


  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber) {
      throw new Error('Unable to find node on an unmounted component.');
    }
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js


  function getNearestMountedFiber(fiber) {
    var node = fiber;
    var nearestMounted = fiber;

    if (!fiber.alternate) {
      // If there is no alternate, this might be a new tree that isn't inserted
      // yet. If it is, then it will have a pending insertion effect on it.
      var nextNode = node;

      do {
        node = nextNode; // TODO: This function, and these flags, are a leaked implementation
        // detail. Once we start releasing DevTools in lockstep with React, we
        // should import a function from the reconciler instead.

        var Placement = 2;
        var Hydrating = 4096;

        if ((node.flags & (Placement | Hydrating)) !== 0) {
          // This is an insertion or in-progress hydration. The nearest possible
          // mounted fiber is the parent but we need to continue to figure out
          // if that one is still mounted.
          nearestMounted = node.return;
        } // $FlowFixMe[incompatible-type] we bail out when we get a null


        nextNode = node.return;
      } while (nextNode);
    } else {
      while (node.return) {
        node = node.return;
      }
    }

    if (node.tag === HostRoot) {
      // TODO: Check if this was a nested HostRoot when used with
      // renderContainerIntoSubtree.
      return nearestMounted;
    } // If we didn't hit the root, that means that we're in an disconnected tree
    // that has been unmounted.


    return null;
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js
  // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).
  // BEGIN copied code


  function findCurrentFiberUsingSlowPathById(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return null;
    }

    var alternate = fiber.alternate;

    if (!alternate) {
      // If there is no alternate, then we only need to check if it is mounted.
      var nearestMounted = getNearestMountedFiber(fiber);

      if (nearestMounted === null) {
        throw new Error('Unable to find node on an unmounted component.');
      }

      if (nearestMounted !== fiber) {
        return null;
      }

      return fiber;
    } // If we have two possible branches, we'll walk backwards up to the root
    // to see what path the root points to. On the way we may hit one of the
    // special cases and we'll deal with them.


    var a = fiber;
    var b = alternate;

    while (true) {
      var parentA = a.return;

      if (parentA === null) {
        // We're at the root.
        break;
      }

      var parentB = parentA.alternate;

      if (parentB === null) {
        // There is no alternate. This is an unusual case. Currently, it only
        // happens when a Suspense component is hidden. An extra fragment fiber
        // is inserted in between the Suspense fiber and its children. Skip
        // over this extra fragment fiber and proceed to the next parent.
        var nextParent = parentA.return;

        if (nextParent !== null) {
          a = b = nextParent;
          continue;
        } // If there's no parent, we're at the root.


        break;
      } // If both copies of the parent fiber point to the same child, we can
      // assume that the child is current. This happens when we bailout on low
      // priority: the bailed out fiber's child reuses the current child.


      if (parentA.child === parentB.child) {
        var child = parentA.child;

        while (child) {
          if (child === a) {
            // We've determined that A is the current branch.
            assertIsMounted(parentA);
            return fiber;
          }

          if (child === b) {
            // We've determined that B is the current branch.
            assertIsMounted(parentA);
            return alternate;
          }

          child = child.sibling;
        } // We should never have an alternate for any mounting node. So the only
        // way this could possibly happen is if this was unmounted, if at all.


        throw new Error('Unable to find node on an unmounted component.');
      }

      if (a.return !== b.return) {
        // The return pointer of A and the return pointer of B point to different
        // fibers. We assume that return pointers never criss-cross, so A must
        // belong to the child set of A.return, and B must belong to the child
        // set of B.return.
        a = parentA;
        b = parentB;
      } else {
        // The return pointers point to the same fiber. We'll have to use the
        // default, slow path: scan the child sets of each parent alternate to see
        // which child belongs to which set.
        //
        // Search parent A's child set
        var didFindChild = false;
        var _child = parentA.child;

        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }

          if (_child === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }

          _child = _child.sibling;
        }

        if (!didFindChild) {
          // Search parent B's child set
          _child = parentB.child;

          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }

            if (_child === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }

            _child = _child.sibling;
          }

          if (!didFindChild) {
            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
          }
        }
      }

      if (a.alternate !== b) {
        throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
      }
    } // If the root is not a host container, we're in a disconnected tree. I.e.
    // unmounted.


    if (a.tag !== HostRoot) {
      throw new Error('Unable to find node on an unmounted component.');
    }

    if (a.stateNode.current === a) {
      // We've determined that A is the current branch.
      return fiber;
    } // Otherwise B has to be current branch.


    return alternate;
  } // END copied code


  function prepareViewAttributeSource(id, path) {
    if (isMostRecentlyInspectedElement(id)) {
      window.$attribute = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var elementType = fiber.elementType,
        tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
      case FunctionComponent:
        global.$type = type;
        break;

      case ForwardRef:
        global.$type = type.render;
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$type = elementType != null && elementType.type != null ? elementType.type : type;
        break;

      default:
        global.$type = null;
        break;
    }
  }

  function fiberToSerializedElement(fiber) {
    return {
      displayName: getDisplayNameForFiber(fiber) || 'Anonymous',
      id: getFiberIDThrows(fiber),
      key: fiber.key,
      type: getElementTypeForFiber(fiber)
    };
  }

  function getOwnersList(id) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    var _debugOwner = fiber._debugOwner;
    var owners = [fiberToSerializedElement(fiber)];

    if (_debugOwner) {
      var owner = _debugOwner;

      while (owner !== null) {
        owners.unshift(fiberToSerializedElement(owner));
        owner = owner._debugOwner || null;
      }
    }

    return owners;
  } // Fast path props lookup for React Native style editor.
  // Could use inspectElementRaw() but that would require shallow rendering hooks components,
  // and could also mess with memoization.


  function getInstanceAndStyle(id) {
    var instance = null;
    var style = null;
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      instance = fiber.stateNode;

      if (fiber.memoizedProps !== null) {
        style = fiber.memoizedProps.style;
      }
    }

    return {
      instance: instance,
      style: style
    };
  }

  function isErrorBoundary(fiber) {
    var tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        var instance = fiber.stateNode;
        return typeof type.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function';

      default:
        return false;
    }
  }

  function getNearestErrorBoundaryID(fiber) {
    var parent = fiber.return;

    while (parent !== null) {
      if (isErrorBoundary(parent)) {
        return getFiberIDUnsafe(parent);
      }

      parent = parent.return;
    }

    return null;
  }

  function inspectElementRaw(id) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    var _debugOwner = fiber._debugOwner,
        _debugSource = fiber._debugSource,
        stateNode = fiber.stateNode,
        key = fiber.key,
        memoizedProps = fiber.memoizedProps,
        memoizedState = fiber.memoizedState,
        dependencies = fiber.dependencies,
        tag = fiber.tag,
        type = fiber.type;
    var elementType = getElementTypeForFiber(fiber);
    var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies); // TODO Show custom UI for Cache like we do for Suspense
    // For now, just hide state data entirely since it's not meant to be inspected.

    var showState = !usesHooks && tag !== CacheComponent;
    var typeSymbol = getTypeSymbol(type);
    var canViewSource = false;
    var context = null;

    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {
      canViewSource = true;

      if (stateNode && stateNode.context != null) {
        // Don't show an empty context object for class components that don't use the context API.
        var shouldHideContext = elementType === types["e" /* ElementTypeClass */] && !(type.contextTypes || type.contextType);

        if (!shouldHideContext) {
          context = stateNode.context;
        }
      }
    } else if (typeSymbol === ReactSymbols["c" /* CONTEXT_NUMBER */] || typeSymbol === ReactSymbols["d" /* CONTEXT_SYMBOL_STRING */]) {
      // 16.3-16.5 read from "type" because the Consumer is the actual context object.
      // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
      // NOTE Keep in sync with getDisplayNameForFiber()
      var consumerResolvedContext = type._context || type; // Global context value.

      context = consumerResolvedContext._currentValue || null; // Look for overridden value.

      var _current = fiber.return;

      while (_current !== null) {
        var currentType = _current.type;
        var currentTypeSymbol = getTypeSymbol(currentType);

        if (currentTypeSymbol === ReactSymbols["n" /* PROVIDER_NUMBER */] || currentTypeSymbol === ReactSymbols["o" /* PROVIDER_SYMBOL_STRING */]) {
          // 16.3.0 exposed the context object as "context"
          // PR #12501 changed it to "_context" for 16.3.1+
          // NOTE Keep in sync with getDisplayNameForFiber()
          var providerResolvedContext = currentType._context || currentType.context;

          if (providerResolvedContext === consumerResolvedContext) {
            context = _current.memoizedProps.value;
            break;
          }
        }

        _current = _current.return;
      }
    }

    var hasLegacyContext = false;

    if (context !== null) {
      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.
      // Otherwise simple values (e.g. strings, booleans) become harder to handle.

      context = {
        value: context
      };
    }

    var owners = null;

    if (_debugOwner) {
      owners = [];
      var owner = _debugOwner;

      while (owner !== null) {
        owners.push(fiberToSerializedElement(owner));
        owner = owner._debugOwner || null;
      }
    }

    var isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;
    var hooks = null;

    if (usesHooks) {
      var originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.

      for (var method in console) {
        try {
          originalConsoleMethods[method] = console[method]; // $FlowFixMe[prop-missing]

          console[method] = function () {};
        } catch (error) {}
      }

      try {
        hooks = Object(react_debug_tools["inspectHooksOfFiber"])(fiber, renderer.currentDispatcherRef, true // Include source location info for hooks
        );
      } finally {
        // Restore original console functionality.
        for (var _method in originalConsoleMethods) {
          try {
            // $FlowFixMe[prop-missing]
            console[_method] = originalConsoleMethods[_method];
          } catch (error) {}
        }
      }
    }

    var rootType = null;
    var current = fiber;

    while (current.return !== null) {
      current = current.return;
    }

    var fiberRoot = current.stateNode;

    if (fiberRoot != null && fiberRoot._debugRootType !== null) {
      rootType = fiberRoot._debugRootType;
    }

    var errors = fiberIDToErrorsMap.get(id) || new Map();
    var warnings = fiberIDToWarningsMap.get(id) || new Map();
    var isErrored = false;
    var targetErrorBoundaryID;

    if (isErrorBoundary(fiber)) {
      // if the current inspected element is an error boundary,
      // either that we want to use it to toggle off error state
      // or that we allow to force error state on it if it's within another
      // error boundary
      //
      // TODO: This flag is a leaked implementation detail. Once we start
      // releasing DevTools in lockstep with React, we should import a function
      // from the reconciler instead.
      var DidCapture = 128;
      isErrored = (fiber.flags & DidCapture) !== 0 || forceErrorForFiberIDs.get(id) === true;
      targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);
    } else {
      targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);
    }

    var plugins = {
      stylex: null
    };

    if (DevToolsFeatureFlags_core_oss["b" /* enableStyleXFeatures */]) {
      if (memoizedProps.hasOwnProperty('xstyle')) {
        plugins.stylex = getStyleXData(memoizedProps.xstyle);
      }
    }

    return {
      id: id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: typeof overrideHookState === 'function',
      canEditFunctionProps: typeof overrideProps === 'function',
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',
      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',
      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',
      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',
      canToggleError: supportsTogglingError && targetErrorBoundaryID != null,
      // Is this error boundary in error state.
      isErrored: isErrored,
      targetErrorBoundaryID: targetErrorBoundaryID,
      canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.
      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,
      // allow toggling it back to remove the fallback override.
      forceFallbackForSuspenseIDs.has(id)),
      // Can view component source location.
      canViewSource: canViewSource,
      // Does the component have legacy context attached to it.
      hasLegacyContext: hasLegacyContext,
      key: key != null ? key : null,
      displayName: getDisplayNameForFiber(fiber),
      type: elementType,
      // Inspectable properties.
      // TODO Review sanitization approach for the below inspectable values.
      context: context,
      hooks: hooks,
      props: memoizedProps,
      state: showState ? memoizedState : null,
      errors: Array.from(errors.entries()),
      warnings: Array.from(warnings.entries()),
      // List of owners
      owners: owners,
      // Location of component in source code.
      source: _debugSource || null,
      rootType: rootType,
      rendererPackageName: renderer.rendererPackageName,
      rendererVersion: renderer.version,
      plugins: plugins
    };
  }

  var mostRecentlyInspectedElement = null;
  var hasElementUpdatedSinceLastInspected = false;
  var currentlyInspectedPaths = {};

  function isMostRecentlyInspectedElement(id) {
    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;
  }

  function isMostRecentlyInspectedElementCurrent(id) {
    return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;
  } // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.


  function mergeInspectedPaths(path) {
    var current = currentlyInspectedPaths;
    path.forEach(function (key) {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key, secondaryCategory) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      switch (secondaryCategory) {
        case 'hooks':
          if (path.length === 1) {
            // Never dehydrate the "hooks" object at the top levels.
            return true;
          }

          if (path[path.length - 2] === 'hookSource' && path[path.length - 1] === 'fileName') {
            // It's important to preserve the full file name (URL) for hook sources
            // in case the user has enabled the named hooks feature.
            // Otherwise the frontend may end up with a partial URL which it can't load.
            return true;
          }

          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {
            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,
            // so it's easiest for now if we just don't break on this boundary.
            // We can always dehydrate a level deeper (in the value object).
            return true;
          }

          break;

        default:
          break;
      }

      var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (var i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  }

  function updateSelectedElement(inspectedElement) {
    var hooks = inspectedElement.hooks,
        id = inspectedElement.id,
        props = inspectedElement.props;
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var elementType = fiber.elementType,
        stateNode = fiber.stateNode,
        tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
        global.$r = stateNode;
        break;

      case FunctionComponent:
        global.$r = {
          hooks: hooks,
          props: props,
          type: type
        };
        break;

      case ForwardRef:
        global.$r = {
          hooks: hooks,
          props: props,
          type: type.render
        };
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$r = {
          hooks: hooks,
          props: props,
          type: elementType != null && elementType.type != null ? elementType.type : type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    if (isMostRecentlyInspectedElement(id)) {
      var value = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
      var key = "$reactTemp".concat(count);
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function getSerializedElementValueByPath(id, path) {
    if (isMostRecentlyInspectedElement(id)) {
      var valueToCopy = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
      return Object(backend_utils["l" /* serializeToString */])(valueToCopy);
    }
  }

  function inspectElement(requestID, id, path, forceFullData) {
    if (path !== null) {
      mergeInspectedPaths(path);
    }

    if (isMostRecentlyInspectedElement(id) && !forceFullData) {
      if (!hasElementUpdatedSinceLastInspected) {
        if (path !== null) {
          var secondaryCategory = null;

          if (path[0] === 'hooks') {
            secondaryCategory = 'hooks';
          } // If this element has not been updated since it was last inspected,
          // we can just return the subset of data in the newly-inspected path.


          return {
            id: id,
            responseID: requestID,
            type: 'hydrated-path',
            path: path,
            value: Object(backend_utils["a" /* cleanForBridge */])(Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)
          };
        } else {
          // If this element has not been updated since it was last inspected, we don't need to return it.
          // Instead we can just return the ID to indicate that it has not changed.
          return {
            id: id,
            responseID: requestID,
            type: 'no-change'
          };
        }
      }
    } else {
      currentlyInspectedPaths = {};
    }

    hasElementUpdatedSinceLastInspected = false;

    try {
      mostRecentlyInspectedElement = inspectElementRaw(id);
    } catch (error) {
      // the error name is synced with ReactDebugHooks
      if (error.name === 'ReactDebugToolsRenderError') {
        var message = 'Error rendering inspected element.';
        var stack; // Log error & cause for user to debug

        console.error(message + '\n\n', error);

        if (error.cause != null) {
          var _fiber4 = findCurrentFiberUsingSlowPathById(id);

          var componentName = _fiber4 != null ? getDisplayNameForFiber(_fiber4) : null;
          console.error('React DevTools encountered an error while trying to inspect hooks. ' + 'This is most likely caused by an error in current inspected component' + (componentName != null ? ": \"".concat(componentName, "\".") : '.') + '\nThe error thrown in the component is: \n\n', error.cause);

          if (error.cause instanceof Error) {
            message = error.cause.message || message;
            stack = error.cause.stack;
          }
        }

        return {
          type: 'error',
          errorType: 'user',
          id: id,
          responseID: requestID,
          message: message,
          stack: stack
        };
      } // the error name is synced with ReactDebugHooks


      if (error.name === 'ReactDebugToolsUnsupportedHookError') {
        return {
          type: 'error',
          errorType: 'unknown-hook',
          id: id,
          responseID: requestID,
          message: 'Unsupported hook in the react-debug-tools package: ' + error.message
        };
      } // Log Uncaught Error


      console.error('Error inspecting element.\n\n', error);
      return {
        type: 'error',
        errorType: 'uncaught',
        id: id,
        responseID: requestID,
        message: error.message,
        stack: error.stack
      };
    }

    if (mostRecentlyInspectedElement === null) {
      return {
        id: id,
        responseID: requestID,
        type: 'not-found'
      };
    } // Any time an inspected element has an update,
    // we should update the selected $r value as wel.
    // Do this before dehydration (cleanForBridge).


    updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.
    // This will enable us to send patches without re-inspecting if hydrated paths are requested.
    // (Reducing how often we shallow-render is a better DX for function components that use hooks.)

    var cleanedInspectedElement = _objectSpread({}, mostRecentlyInspectedElement); // $FlowFixMe[prop-missing] found when upgrading Flow


    cleanedInspectedElement.context = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.context, createIsPathAllowed('context', null)); // $FlowFixMe[prop-missing] found when upgrading Flow

    cleanedInspectedElement.hooks = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks')); // $FlowFixMe[prop-missing] found when upgrading Flow

    cleanedInspectedElement.props = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.props, createIsPathAllowed('props', null)); // $FlowFixMe[prop-missing] found when upgrading Flow

    cleanedInspectedElement.state = Object(backend_utils["a" /* cleanForBridge */])(cleanedInspectedElement.state, createIsPathAllowed('state', null));
    return {
      id: id,
      responseID: requestID,
      type: 'full-data',
      // $FlowFixMe[prop-missing] found when upgrading Flow
      value: cleanedInspectedElement
    };
  }

  function logElementToConsole(id) {
    var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);

    if (result === null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed("[Click to expand] %c<".concat(result.displayName || 'Component', " />"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.hooks !== null) {
      console.log('Hooks:', result.hooks);
    }

    var nativeNodes = findNativeNodesForFiberID(id);

    if (nativeNodes !== null) {
      console.log('Nodes:', nativeNodes);
    }

    if (result.source !== null) {
      console.log('Location:', result.source);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function deletePath(type, id, hookID, path) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {// Simple context value (noop)
              } else {
                Object(utils["c" /* deletePathInObject */])(instance.context, path);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateDeletePath === 'function') {
            overrideHookStateDeletePath(fiber, hookID, path);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsDeletePath === 'function') {
              overridePropsDeletePath(fiber, path);
            }
          } else {
            fiber.pendingProps = Object(backend_utils["b" /* copyWithDelete */])(instance.props, path);
            instance.forceUpdate();
          }

          break;

        case 'state':
          Object(utils["c" /* deletePathInObject */])(instance.state, path);
          instance.forceUpdate();
          break;
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          oldPath = oldPath.slice(1);
          newPath = newPath.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (oldPath.length === 0) {// Simple context value (noop)
              } else {
                Object(utils["n" /* renamePathInObject */])(instance.context, oldPath, newPath);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateRenamePath === 'function') {
            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsRenamePath === 'function') {
              overridePropsRenamePath(fiber, oldPath, newPath);
            }
          } else {
            fiber.pendingProps = Object(backend_utils["c" /* copyWithRename */])(instance.props, oldPath, newPath);
            instance.forceUpdate();
          }

          break;

        case 'state':
          Object(utils["n" /* renamePathInObject */])(instance.state, oldPath, newPath);
          instance.forceUpdate();
          break;
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {
                // Simple context value
                instance.context = value;
              } else {
                Object(utils["o" /* setInObject */])(instance.context, path, value);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookState === 'function') {
            overrideHookState(fiber, hookID, path, value);
          }

          break;

        case 'props':
          switch (fiber.tag) {
            case ClassComponent:
              fiber.pendingProps = Object(backend_utils["d" /* copyWithSet */])(instance.props, path, value);
              instance.forceUpdate();
              break;

            default:
              if (typeof overrideProps === 'function') {
                overrideProps(fiber, path, value);
              }

              break;
          }

          break;

        case 'state':
          switch (fiber.tag) {
            case ClassComponent:
              Object(utils["o" /* setInObject */])(instance.state, path, value);
              instance.forceUpdate();
              break;
          }

          break;
      }
    }
  }

  var currentCommitProfilingMetadata = null;
  var displayNamesByRootID = null;
  var idToContextsMap = null;
  var initialTreeBaseDurationsMap = null;
  var initialIDToRootMap = null;
  var isProfiling = false;
  var profilingStartTime = 0;
  var recordChangeDescriptions = false;
  var rootToCommitProfilingMetadataMap = null;

  function getProfilingData() {
    var dataForRoots = [];

    if (rootToCommitProfilingMetadataMap === null) {
      throw Error('getProfilingData() called before any profiling data was recorded');
    }

    rootToCommitProfilingMetadataMap.forEach(function (commitProfilingMetadata, rootID) {
      var commitData = [];
      var initialTreeBaseDurations = [];
      var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';

      if (initialTreeBaseDurationsMap != null) {
        initialTreeBaseDurationsMap.forEach(function (treeBaseDuration, id) {
          if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {
            // We don't need to convert milliseconds to microseconds in this case,
            // because the profiling summary is JSON serialized.
            initialTreeBaseDurations.push([id, treeBaseDuration]);
          }
        });
      }

      commitProfilingMetadata.forEach(function (commitProfilingData, commitIndex) {
        var changeDescriptions = commitProfilingData.changeDescriptions,
            durations = commitProfilingData.durations,
            effectDuration = commitProfilingData.effectDuration,
            maxActualDuration = commitProfilingData.maxActualDuration,
            passiveEffectDuration = commitProfilingData.passiveEffectDuration,
            priorityLevel = commitProfilingData.priorityLevel,
            commitTime = commitProfilingData.commitTime,
            updaters = commitProfilingData.updaters;
        var fiberActualDurations = [];
        var fiberSelfDurations = [];

        for (var i = 0; i < durations.length; i += 3) {
          var fiberID = durations[i];
          fiberActualDurations.push([fiberID, durations[i + 1]]);
          fiberSelfDurations.push([fiberID, durations[i + 2]]);
        }

        commitData.push({
          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,
          duration: maxActualDuration,
          effectDuration: effectDuration,
          fiberActualDurations: fiberActualDurations,
          fiberSelfDurations: fiberSelfDurations,
          passiveEffectDuration: passiveEffectDuration,
          priorityLevel: priorityLevel,
          timestamp: commitTime,
          updaters: updaters
        });
      });
      dataForRoots.push({
        commitData: commitData,
        displayName: displayName,
        initialTreeBaseDurations: initialTreeBaseDurations,
        rootID: rootID
      });
    });
    var timelineData = null;

    if (typeof getTimelineData === 'function') {
      var currentTimelineData = getTimelineData();

      if (currentTimelineData) {
        var batchUIDToMeasuresMap = currentTimelineData.batchUIDToMeasuresMap,
            internalModuleSourceToRanges = currentTimelineData.internalModuleSourceToRanges,
            laneToLabelMap = currentTimelineData.laneToLabelMap,
            laneToReactMeasureMap = currentTimelineData.laneToReactMeasureMap,
            rest = _objectWithoutProperties(currentTimelineData, ["batchUIDToMeasuresMap", "internalModuleSourceToRanges", "laneToLabelMap", "laneToReactMeasureMap"]);

        timelineData = _objectSpread(_objectSpread({}, rest), {}, {
          // Most of the data is safe to parse as-is,
          // but we need to convert the nested Arrays back to Maps.
          // Most of the data is safe to serialize as-is,
          // but we need to convert the Maps to nested Arrays.
          batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),
          internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),
          laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),
          laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())
        });
      }
    }

    return {
      dataForRoots: dataForRoots,
      rendererID: rendererID,
      timelineData: timelineData
    };
  }

  function startProfiling(shouldRecordChangeDescriptions) {
    if (isProfiling) {
      return;
    }

    recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.
    // It's important we snapshot both the durations and the id-to-root map,
    // since either of these may change during the profiling session
    // (e.g. when a fiber is re-rendered or when a fiber gets removed).

    displayNamesByRootID = new Map();
    initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);
    initialIDToRootMap = new Map(idToRootMap);
    idToContextsMap = new Map();
    hook.getFiberRoots(rendererID).forEach(function (root) {
      var rootID = getFiberIDThrows(root.current);
      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));

      if (shouldRecordChangeDescriptions) {
        // Record all contexts at the time profiling is started.
        // Fibers only store the current context value,
        // so we need to track them separately in order to determine changed keys.
        crawlToInitializeContextsMap(root.current);
      }
    });
    isProfiling = true;
    profilingStartTime = renderer_getCurrentTime();
    rootToCommitProfilingMetadataMap = new Map();

    if (toggleProfilingStatus !== null) {
      toggleProfilingStatus(true);
    }
  }

  function stopProfiling() {
    isProfiling = false;
    recordChangeDescriptions = false;

    if (toggleProfilingStatus !== null) {
      toggleProfilingStatus(false);
    }
  } // Automatically start profiling so that we don't miss timing info from initial "mount".


  if (Object(storage["c" /* sessionStorageGetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {
    startProfiling(Object(storage["c" /* sessionStorageGetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true');
  } // React will switch between these implementations depending on whether
  // we have any manually suspended/errored-out Fibers or not.


  function shouldErrorFiberAlwaysNull() {
    return null;
  } // Map of id and its force error status: true (error), false (toggled off),
  // null (do nothing)


  var forceErrorForFiberIDs = new Map();

  function shouldErrorFiberAccordingToMap(fiber) {
    if (typeof setErrorHandler !== 'function') {
      throw new Error('Expected overrideError() to not get called for earlier React versions.');
    }

    var id = getFiberIDUnsafe(fiber);

    if (id === null) {
      return null;
    }

    var status = null;

    if (forceErrorForFiberIDs.has(id)) {
      status = forceErrorForFiberIDs.get(id);

      if (status === false) {
        // TRICKY overrideError adds entries to this Map,
        // so ideally it would be the method that clears them too,
        // but that would break the functionality of the feature,
        // since DevTools needs to tell React to act differently than it normally would
        // (don't just re-render the failed boundary, but reset its errored state too).
        // So we can only clear it after telling React to reset the state.
        // Technically this is premature and we should schedule it for later,
        // since the render could always fail without committing the updated error boundary,
        // but since this is a DEV-only feature, the simplicity is worth the trade off.
        forceErrorForFiberIDs.delete(id);

        if (forceErrorForFiberIDs.size === 0) {
          // Last override is gone. Switch React back to fast path.
          setErrorHandler(shouldErrorFiberAlwaysNull);
        }
      }
    }

    return status;
  }

  function overrideError(id, forceError) {
    if (typeof setErrorHandler !== 'function' || typeof scheduleUpdate !== 'function') {
      throw new Error('Expected overrideError() to not get called for earlier React versions.');
    }

    forceErrorForFiberIDs.set(id, forceError);

    if (forceErrorForFiberIDs.size === 1) {
      // First override is added. Switch React to slower path.
      setErrorHandler(shouldErrorFiberAccordingToMap);
    }

    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber != null) {
      scheduleUpdate(fiber);
    }
  }

  function shouldSuspendFiberAlwaysFalse() {
    return false;
  }

  var forceFallbackForSuspenseIDs = new Set();

  function shouldSuspendFiberAccordingToSet(fiber) {
    var maybeID = getFiberIDUnsafe(fiber);
    return maybeID !== null && forceFallbackForSuspenseIDs.has(maybeID);
  }

  function overrideSuspense(id, forceFallback) {
    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {
      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');
    }

    if (forceFallback) {
      forceFallbackForSuspenseIDs.add(id);

      if (forceFallbackForSuspenseIDs.size === 1) {
        // First override is added. Switch React to slower path.
        setSuspenseHandler(shouldSuspendFiberAccordingToSet);
      }
    } else {
      forceFallbackForSuspenseIDs.delete(id);

      if (forceFallbackForSuspenseIDs.size === 0) {
        // Last override is gone. Switch React back to fast path.
        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
      }
    }

    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber != null) {
      scheduleUpdate(fiber);
    }
  } // Remember if we're trying to restore the selection after reload.
  // In that case, we'll do some extra checks for matching mounts.


  var trackedPath = null;
  var trackedPathMatchFiber = null;
  var trackedPathMatchDepth = -1;
  var mightBeOnTrackedPath = false;

  function setTrackedPath(path) {
    if (path === null) {
      trackedPathMatchFiber = null;
      trackedPathMatchDepth = -1;
      mightBeOnTrackedPath = false;
    }

    trackedPath = path;
  } // We call this before traversing a new mount.
  // It remembers whether this Fiber is the next best match for tracked path.
  // The return value signals whether we should keep matching siblings or not.


  function updateTrackedPathStateBeforeMount(fiber) {
    if (trackedPath === null || !mightBeOnTrackedPath) {
      // Fast path: there's nothing to track so do nothing and ignore siblings.
      return false;
    }

    var returnFiber = fiber.return;
    var returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.
    // Is this newly mounted Fiber a direct child of the current best match?
    // (This will also be true for new roots if we haven't matched anything yet.)

    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {
      // Is this the next Fiber we should select? Let's compare the frames.
      var actualFrame = getPathFrame(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow

      var expectedFrame = trackedPath[trackedPathMatchDepth + 1];

      if (expectedFrame === undefined) {
        throw new Error('Expected to see a frame at the next depth.');
      }

      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {
        // We have our next match.
        trackedPathMatchFiber = fiber;
        trackedPathMatchDepth++; // Are we out of frames to match?
        // $FlowFixMe[incompatible-use] found when upgrading Flow

        if (trackedPathMatchDepth === trackedPath.length - 1) {
          // There's nothing that can possibly match afterwards.
          // Don't check the children.
          mightBeOnTrackedPath = false;
        } else {
          // Check the children, as they might reveal the next match.
          mightBeOnTrackedPath = true;
        } // In either case, since we have a match, we don't need
        // to check the siblings. They'll never match.


        return false;
      }
    } // This Fiber's parent is on the path, but this Fiber itself isn't.
    // There's no need to check its children--they won't be on the path either.


    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.

    return true;
  }

  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {
    // updateTrackedPathStateBeforeMount() told us whether to match siblings.
    // Now that we're entering siblings, let's use that information.
    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;
  } // Roots don't have a real persistent identity.
  // A root's "pseudo key" is "childDisplayName:indexWithThatName".
  // For example, "App:0" or, in case of similar roots, "Story:0", "Story:1", etc.
  // We will use this to try to disambiguate roots when restoring selection between reloads.


  var rootPseudoKeys = new Map();
  var rootDisplayNameCounter = new Map();

  function setRootPseudoKey(id, fiber) {
    var name = getDisplayNameForRoot(fiber);
    var counter = rootDisplayNameCounter.get(name) || 0;
    rootDisplayNameCounter.set(name, counter + 1);
    var pseudoKey = "".concat(name, ":").concat(counter);
    rootPseudoKeys.set(id, pseudoKey);
  }

  function removeRootPseudoKey(id) {
    var pseudoKey = rootPseudoKeys.get(id);

    if (pseudoKey === undefined) {
      throw new Error('Expected root pseudo key to be known.');
    }

    var name = pseudoKey.slice(0, pseudoKey.lastIndexOf(':'));
    var counter = rootDisplayNameCounter.get(name);

    if (counter === undefined) {
      throw new Error('Expected counter to be known.');
    }

    if (counter > 1) {
      rootDisplayNameCounter.set(name, counter - 1);
    } else {
      rootDisplayNameCounter.delete(name);
    }

    rootPseudoKeys.delete(id);
  }

  function getDisplayNameForRoot(fiber) {
    var preferredDisplayName = null;
    var fallbackDisplayName = null;
    var child = fiber.child; // Go at most three levels deep into direct children
    // while searching for a child that has a displayName.

    for (var i = 0; i < 3; i++) {
      if (child === null) {
        break;
      }

      var displayName = getDisplayNameForFiber(child);

      if (displayName !== null) {
        // Prefer display names that we get from user-defined components.
        // We want to avoid using e.g. 'Suspense' unless we find nothing else.
        if (typeof child.type === 'function') {
          // There's a few user-defined tags, but we'll prefer the ones
          // that are usually explicitly named (function or class components).
          preferredDisplayName = displayName;
        } else if (fallbackDisplayName === null) {
          fallbackDisplayName = displayName;
        }
      }

      if (preferredDisplayName !== null) {
        break;
      }

      child = child.child;
    }

    return preferredDisplayName || fallbackDisplayName || 'Anonymous';
  }

  function getPathFrame(fiber) {
    var key = fiber.key;
    var displayName = getDisplayNameForFiber(fiber);
    var index = fiber.index;

    switch (fiber.tag) {
      case HostRoot:
        // Roots don't have a real displayName, index, or key.
        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).
        var id = getFiberIDThrows(fiber);
        var pseudoKey = rootPseudoKeys.get(id);

        if (pseudoKey === undefined) {
          throw new Error('Expected mounted root to have known pseudo key.');
        }

        displayName = pseudoKey;
        break;

      case HostComponent:
        displayName = fiber.type;
        break;

      default:
        break;
    }

    return {
      displayName: displayName,
      key: key,
      index: index
    };
  } // Produces a serializable representation that does a best effort
  // of identifying a particular Fiber between page reloads.
  // The return path will contain Fibers that are "invisible" to the store
  // because their keys and indexes are important to restoring the selection.


  function getPathForElement(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      return null;
    }

    var keyPath = [];

    while (fiber !== null) {
      // $FlowFixMe[incompatible-call] found when upgrading Flow
      keyPath.push(getPathFrame(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow

      fiber = fiber.return;
    }

    keyPath.reverse();
    return keyPath;
  }

  function getBestMatchForTrackedPath() {
    if (trackedPath === null) {
      // Nothing to match.
      return null;
    }

    if (trackedPathMatchFiber === null) {
      // We didn't find anything.
      return null;
    } // Find the closest Fiber store is aware of.


    var fiber = trackedPathMatchFiber;

    while (fiber !== null && shouldFilterFiber(fiber)) {
      fiber = fiber.return;
    }

    if (fiber === null) {
      return null;
    }

    return {
      id: getFiberIDThrows(fiber),
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1
    };
  }

  var formatPriorityLevel = function formatPriorityLevel(priorityLevel) {
    if (priorityLevel == null) {
      return 'Unknown';
    }

    switch (priorityLevel) {
      case ImmediatePriority:
        return 'Immediate';

      case UserBlockingPriority:
        return 'User-Blocking';

      case NormalPriority:
        return 'Normal';

      case LowPriority:
        return 'Low';

      case IdlePriority:
        return 'Idle';

      case NoPriority:
      default:
        return 'Unknown';
    }
  };

  function setTraceUpdatesEnabled(isEnabled) {
    traceUpdatesEnabled = isEnabled;
  }

  return {
    cleanup: cleanup,
    clearErrorsAndWarnings: clearErrorsAndWarnings,
    clearErrorsForFiberID: clearErrorsForFiberID,
    clearWarningsForFiberID: clearWarningsForFiberID,
    getSerializedElementValueByPath: getSerializedElementValueByPath,
    deletePath: deletePath,
    findNativeNodesForFiberID: findNativeNodesForFiberID,
    flushInitialOperations: flushInitialOperations,
    getBestMatchForTrackedPath: getBestMatchForTrackedPath,
    getDisplayNameForFiberID: getDisplayNameForFiberID,
    getFiberForNative: getFiberForNative,
    getFiberIDForNative: getFiberIDForNative,
    getInstanceAndStyle: getInstanceAndStyle,
    getOwnersList: getOwnersList,
    getPathForElement: getPathForElement,
    getProfilingData: getProfilingData,
    handleCommitFiberRoot: handleCommitFiberRoot,
    handleCommitFiberUnmount: handleCommitFiberUnmount,
    handlePostCommitFiberRoot: handlePostCommitFiberRoot,
    inspectElement: inspectElement,
    logElementToConsole: logElementToConsole,
    patchConsoleForStrictMode: backend_console["d" /* patchForStrictMode */],
    prepareViewAttributeSource: prepareViewAttributeSource,
    prepareViewElementSource: prepareViewElementSource,
    overrideError: overrideError,
    overrideSuspense: overrideSuspense,
    overrideValueAtPath: overrideValueAtPath,
    renamePath: renamePath,
    renderer: renderer,
    setTraceUpdatesEnabled: setTraceUpdatesEnabled,
    setTrackedPath: setTrackedPath,
    startProfiling: startProfiling,
    stopProfiling: stopProfiling,
    storeAsGlobal: storeAsGlobal,
    unpatchConsoleForStrictMode: backend_console["f" /* unpatchForStrictMode */],
    updateComponentFilters: updateComponentFilters
  };
}

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ describeFiber; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ getStackByFiberInDevAndProd; });

// EXTERNAL MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js
var ReactSymbols = __webpack_require__(3);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsConsolePatching.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of shared/ConsolePatchingDev.
// The shared console patching code is DEV-only.
// We can't use it since DevTools only ships production builds.
// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  if (disabledDepth === 0) {
    /* eslint-disable react-internal/no-production-logging */
    prevLog = console.log;
    prevInfo = console.info;
    prevWarn = console.warn;
    prevError = console.error;
    prevGroup = console.group;
    prevGroupCollapsed = console.groupCollapsed;
    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

    var props = {
      configurable: true,
      enumerable: true,
      value: disabledLog,
      writable: true
    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.

    Object.defineProperties(console, {
      info: props,
      log: props,
      warn: props,
      error: props,
      group: props,
      groupCollapsed: props,
      groupEnd: props
    });
    /* eslint-enable react-internal/no-production-logging */
  }

  disabledDepth++;
}
function reenableLogs() {
  disabledDepth--;

  if (disabledDepth === 0) {
    /* eslint-disable react-internal/no-production-logging */
    var props = {
      configurable: true,
      enumerable: true,
      writable: true
    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.

    Object.defineProperties(console, {
      log: _objectSpread(_objectSpread({}, props), {}, {
        value: prevLog
      }),
      info: _objectSpread(_objectSpread({}, props), {}, {
        value: prevInfo
      }),
      warn: _objectSpread(_objectSpread({}, props), {}, {
        value: prevWarn
      }),
      error: _objectSpread(_objectSpread({}, props), {}, {
        value: prevError
      }),
      group: _objectSpread(_objectSpread({}, props), {}, {
        value: prevGroup
      }),
      groupCollapsed: _objectSpread(_objectSpread({}, props), {}, {
        value: prevGroupCollapsed
      }),
      groupEnd: _objectSpread(_objectSpread({}, props), {}, {
        value: prevGroupEnd
      })
    });
    /* eslint-enable react-internal/no-production-logging */
  }

  if (disabledDepth < 0) {
    console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactComponentStackFrame.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).
 // The shared console patching code is DEV-only.
// We can't use it since DevTools only ships production builds.


var prefix;
function describeBuiltInComponentFrame(name, ownerFn) {
  if (prefix === undefined) {
    // Extract the VM specific prefix used by each line.
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || '';
    }
  } // We use the prefix to ensure our stacks line up with native stack frames.


  return '\n' + prefix + name;
}
var reentry = false;
var componentFrameCache;

if (false) { var PossiblyWeakMap; }

function describeNativeComponentFrame(fn, construct, currentDispatcherRef) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  if (false) { var frame; }

  var control;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.

  Error.prepareStackTrace = undefined;
  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.
  //
  // Note that unlike the code this was forked from (in ReactComponentStackFrame)
  // DevTools should override the dispatcher even when DevTools is compiled in production mode,
  // because the app itself may be in development mode and log errors/warnings.

  var previousDispatcher = currentDispatcherRef.current;
  currentDispatcherRef.current = null;
  disableLogs();

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function Fake() {
        throw Error();
      }; // $FlowFixMe[prop-missing]


      Object.defineProperty(Fake.prototype, 'props', {
        set: function set() {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        } // $FlowFixMe[prop-missing] found when upgrading Flow


        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                if (false) {} // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;
    Error.prepareStackTrace = previousPrepareStackTrace;
    currentDispatcherRef.current = previousDispatcher;
    reenableLogs();
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  if (false) {}

  return syntheticFrame;
}
function describeClassComponentFrame(ctor, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);
}
function describeFunctionComponentFrame(fn, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(fn, false, currentDispatcherRef);
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, ownerFn, currentDispatcherRef) {
  if (true) {
    return '';
  }

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type, ownerFn);
  }

  switch (type) {
    case ReactSymbols["w" /* SUSPENSE_NUMBER */]:
    case ReactSymbols["x" /* SUSPENSE_SYMBOL_STRING */]:
      return describeBuiltInComponentFrame('Suspense', ownerFn);

    case ReactSymbols["u" /* SUSPENSE_LIST_NUMBER */]:
    case ReactSymbols["v" /* SUSPENSE_LIST_SYMBOL_STRING */]:
      return describeBuiltInComponentFrame('SuspenseList', ownerFn);
  }

  if (_typeof(type) === 'object') {
    switch (type.$$typeof) {
      case ReactSymbols["f" /* FORWARD_REF_NUMBER */]:
      case ReactSymbols["g" /* FORWARD_REF_SYMBOL_STRING */]:
        return describeFunctionComponentFrame(type.render, ownerFn, currentDispatcherRef);

      case ReactSymbols["j" /* MEMO_NUMBER */]:
      case ReactSymbols["k" /* MEMO_SYMBOL_STRING */]:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn, currentDispatcherRef);

      case ReactSymbols["h" /* LAZY_NUMBER */]:
      case ReactSymbols["i" /* LAZY_SYMBOL_STRING */]:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn, currentDispatcherRef);
          } catch (x) {}
        }
    }
  }

  return '';
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactFiberComponentStack.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).

function describeFiber(workTagMap, workInProgress, currentDispatcherRef) {
  var HostComponent = workTagMap.HostComponent,
      LazyComponent = workTagMap.LazyComponent,
      SuspenseComponent = workTagMap.SuspenseComponent,
      SuspenseListComponent = workTagMap.SuspenseListComponent,
      FunctionComponent = workTagMap.FunctionComponent,
      IndeterminateComponent = workTagMap.IndeterminateComponent,
      SimpleMemoComponent = workTagMap.SimpleMemoComponent,
      ForwardRef = workTagMap.ForwardRef,
      ClassComponent = workTagMap.ClassComponent;
  var owner =  false ? undefined : null;

  switch (workInProgress.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(workInProgress.type, owner);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy', owner);

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense', owner);

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList', owner);

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(workInProgress.type, owner, currentDispatcherRef);

    case ForwardRef:
      return describeFunctionComponentFrame(workInProgress.type.render, owner, currentDispatcherRef);

    case ClassComponent:
      return describeClassComponentFrame(workInProgress.type, owner, currentDispatcherRef);

    default:
      return '';
  }
}
function getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {
  try {
    var info = '';
    var node = workInProgress;

    do {
      info += describeFiber(workTagMap, node, currentDispatcherRef); // $FlowFixMe[incompatible-type] we bail out when we get a null

      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export REACT_ELEMENT_TYPE */
/* unused harmony export REACT_PORTAL_TYPE */
/* unused harmony export REACT_FRAGMENT_TYPE */
/* unused harmony export REACT_STRICT_MODE_TYPE */
/* unused harmony export REACT_PROFILER_TYPE */
/* unused harmony export REACT_PROVIDER_TYPE */
/* unused harmony export REACT_CONTEXT_TYPE */
/* unused harmony export REACT_SERVER_CONTEXT_TYPE */
/* unused harmony export REACT_FORWARD_REF_TYPE */
/* unused harmony export REACT_SUSPENSE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REACT_SUSPENSE_LIST_TYPE; });
/* unused harmony export REACT_MEMO_TYPE */
/* unused harmony export REACT_LAZY_TYPE */
/* unused harmony export REACT_SCOPE_TYPE */
/* unused harmony export REACT_DEBUG_TRACING_MODE_TYPE */
/* unused harmony export REACT_OFFSCREEN_TYPE */
/* unused harmony export REACT_LEGACY_HIDDEN_TYPE */
/* unused harmony export REACT_CACHE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return REACT_TRACING_MARKER_TYPE; });
/* unused harmony export REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED */
/* unused harmony export REACT_MEMO_CACHE_SENTINEL */
/* unused harmony export getIteratorFn */
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_SCOPE_TYPE = Symbol.for('react.scope');
var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
var REACT_CACHE_TYPE = Symbol.for('react.cache');
var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');
var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/***/ }),
/* 16 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // A linked list to keep track of recently-used-ness

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Yallist = __webpack_require__(20);

var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

var naiveLength = function naiveLength() {
  return 1;
}; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    _classCallCheck(this, LRUCache);

    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  _createClass(LRUCache, [{
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map(); // hash of items by key

      this[LRU_LIST] = new Yallist(); // list of items in order of use recency

      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this2 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value; // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now(); // A previous serialized cache has the most recent items first

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now; // dont add already expired items

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this3 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this3, key, false);
      });
    }
  }, {
    key: "max",
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    },
    get: function get() {
      return this[MAX];
    }
  }, {
    key: "allowStale",
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    },
    get: function get() {
      return this[ALLOW_STALE];
    }
  }, {
    key: "maxAge",
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    },
    get: function get() {
      return this[MAX_AGE];
    } // resize the cache when the lengthCalculator changes.

  }, {
    key: "lengthCalculator",
    set: function set(lC) {
      var _this4 = this;

      if (typeof lC !== 'function') lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
          _this4[LENGTH] += hit.length;
        });
      }

      trim(this);
    },
    get: function get() {
      return this[LENGTH_CALCULATOR];
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }]);

  return LRUCache;
}();

var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);

  if (node) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;

      _del(self, walker);

      walker = prev;
    }
  }
};

var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

var Entry = function Entry(key, value, length, now, maxAge) {
  _classCallCheck(this, Entry);

  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
};

var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;

  if (isStale(self, hit)) {
    _del(self, node);

    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(23);
} else {}

/***/ }),
/* 19 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount
/*, ...nodes */
) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(21)(Yallist);
} catch (er) {}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var walker;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;

          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return walker.value;

          case 4:
            walker = walker.next;
            _context.next = 1;
            break;

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var b = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    d = Symbol.for("react.fragment"),
    e = Symbol.for("react.strict_mode"),
    f = Symbol.for("react.profiler"),
    g = Symbol.for("react.provider"),
    h = Symbol.for("react.context"),
    k = Symbol.for("react.server_context"),
    l = Symbol.for("react.forward_ref"),
    m = Symbol.for("react.suspense"),
    n = Symbol.for("react.suspense_list"),
    p = Symbol.for("react.memo"),
    q = Symbol.for("react.lazy"),
    t = Symbol.for("react.offscreen"),
    u = Symbol.for("react.cache"),
    v = Symbol.for("react.client.reference");

function w(a) {
  if ("object" === _typeof(a) && null !== a) {
    var r = a.$$typeof;

    switch (r) {
      case b:
        switch (a = a.type, a) {
          case d:
          case f:
          case e:
          case m:
          case n:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case h:
              case l:
              case q:
              case p:
              case g:
                return a;

              default:
                return r;
            }

        }

      case c:
        return r;
    }
  }
}

exports.ContextConsumer = h;
exports.ContextProvider = g;
exports.Element = b;
exports.ForwardRef = l;
exports.Fragment = d;
exports.Lazy = q;
exports.Memo = p;
exports.Portal = c;
exports.Profiler = f;
exports.StrictMode = e;
exports.Suspense = m;
exports.SuspenseList = n;

exports.isAsyncMode = function () {
  return !1;
};

exports.isConcurrentMode = function () {
  return !1;
};

exports.isContextConsumer = function (a) {
  return w(a) === h;
};

exports.isContextProvider = function (a) {
  return w(a) === g;
};

exports.isElement = function (a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === b;
};

exports.isForwardRef = function (a) {
  return w(a) === l;
};

exports.isFragment = function (a) {
  return w(a) === d;
};

exports.isLazy = function (a) {
  return w(a) === q;
};

exports.isMemo = function (a) {
  return w(a) === p;
};

exports.isPortal = function (a) {
  return w(a) === c;
};

exports.isProfiler = function (a) {
  return w(a) === f;
};

exports.isStrictMode = function (a) {
  return w(a) === e;
};

exports.isSuspense = function (a) {
  return w(a) === m;
};

exports.isSuspenseList = function (a) {
  return w(a) === n;
};

exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || a === u || "object" === _typeof(a) && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === v || void 0 !== a.getModuleId) ? !0 : !1;
};

exports.typeOf = w;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react-debug-tools.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var h = __webpack_require__(24),
    p = __webpack_require__(26),
    q = Object.assign,
    w = p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    x = [],
    y = null;

function z() {
  if (null === y) {
    var a = new Map();

    try {
      A.useContext({
        _currentValue: null
      }), A.useState(null), A.useReducer(function (c) {
        return c;
      }, null), A.useRef(null), "function" === typeof A.useCacheRefresh && A.useCacheRefresh(), A.useLayoutEffect(function () {}), A.useInsertionEffect(function () {}), A.useEffect(function () {}), A.useImperativeHandle(void 0, function () {
        return null;
      }), A.useDebugValue(null), A.useCallback(function () {}), A.useMemo(function () {
        return null;
      });
    } finally {
      var b = x;
      x = [];
    }

    for (var e = 0; e < b.length; e++) {
      var g = b[e];
      a.set(g.primitive, h.parse(g.stackError));
    }

    y = a;
  }

  return y;
}

var B = null;

function C() {
  var a = B;
  null !== a && (B = a.next);
  return a;
}

var A = {
  readContext: function readContext(a) {
    return a._currentValue;
  },
  useCacheRefresh: function useCacheRefresh() {
    var a = C();
    x.push({
      primitive: "CacheRefresh",
      stackError: Error(),
      value: null !== a ? a.memoizedState : function () {}
    });
    return function () {};
  },
  useCallback: function useCallback(a) {
    var b = C();
    x.push({
      primitive: "Callback",
      stackError: Error(),
      value: null !== b ? b.memoizedState[0] : a
    });
    return a;
  },
  useContext: function useContext(a) {
    x.push({
      primitive: "Context",
      stackError: Error(),
      value: a._currentValue
    });
    return a._currentValue;
  },
  useEffect: function useEffect(a) {
    C();
    x.push({
      primitive: "Effect",
      stackError: Error(),
      value: a
    });
  },
  useImperativeHandle: function useImperativeHandle(a) {
    C();
    var b = void 0;
    null !== a && "object" === _typeof(a) && (b = a.current);
    x.push({
      primitive: "ImperativeHandle",
      stackError: Error(),
      value: b
    });
  },
  useDebugValue: function useDebugValue(a, b) {
    x.push({
      primitive: "DebugValue",
      stackError: Error(),
      value: "function" === typeof b ? b(a) : a
    });
  },
  useLayoutEffect: function useLayoutEffect(a) {
    C();
    x.push({
      primitive: "LayoutEffect",
      stackError: Error(),
      value: a
    });
  },
  useInsertionEffect: function useInsertionEffect(a) {
    C();
    x.push({
      primitive: "InsertionEffect",
      stackError: Error(),
      value: a
    });
  },
  useMemo: function useMemo(a) {
    var b = C();
    a = null !== b ? b.memoizedState[0] : a();
    x.push({
      primitive: "Memo",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useReducer: function useReducer(a, b, e) {
    a = C();
    b = null !== a ? a.memoizedState : void 0 !== e ? e(b) : b;
    x.push({
      primitive: "Reducer",
      stackError: Error(),
      value: b
    });
    return [b, function () {}];
  },
  useRef: function useRef(a) {
    var b = C();
    a = null !== b ? b.memoizedState : {
      current: a
    };
    x.push({
      primitive: "Ref",
      stackError: Error(),
      value: a.current
    });
    return a;
  },
  useState: function useState(a) {
    var b = C();
    a = null !== b ? b.memoizedState : "function" === typeof a ? a() : a;
    x.push({
      primitive: "State",
      stackError: Error(),
      value: a
    });
    return [a, function () {}];
  },
  useTransition: function useTransition() {
    C();
    C();
    x.push({
      primitive: "Transition",
      stackError: Error(),
      value: void 0
    });
    return [!1, function () {}];
  },
  useMutableSource: function useMutableSource(a, b) {
    C();
    C();
    C();
    C();
    a = b(a._source);
    x.push({
      primitive: "MutableSource",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useSyncExternalStore: function useSyncExternalStore(a, b) {
    C();
    C();
    a = b();
    x.push({
      primitive: "SyncExternalStore",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useDeferredValue: function useDeferredValue(a) {
    var b = C();
    x.push({
      primitive: "DeferredValue",
      stackError: Error(),
      value: null !== b ? b.memoizedState : a
    });
    return a;
  },
  useId: function useId() {
    var a = C();
    a = null !== a ? a.memoizedState : "";
    x.push({
      primitive: "Id",
      stackError: Error(),
      value: a
    });
    return a;
  }
},
    D = {
  get: function get(a, b) {
    if (a.hasOwnProperty(b)) return a[b];
    a = Error("Missing method in Dispatcher: " + b);
    a.name = "ReactDebugToolsUnsupportedHookError";
    throw a;
  }
},
    E = "undefined" === typeof Proxy ? A : new Proxy(A, D),
    F = 0;

function G(a, b, e) {
  var g = b[e].source,
      c = 0;

  a: for (; c < a.length; c++) {
    if (a[c].source === g) {
      for (var k = e + 1, r = c + 1; k < b.length && r < a.length; k++, r++) {
        if (a[r].source !== b[k].source) continue a;
      }

      return c;
    }
  }

  return -1;
}

function H(a, b) {
  if (!a) return !1;
  b = "use" + b;
  return a.length < b.length ? !1 : a.lastIndexOf(b) === a.length - b.length;
}

function I(a, b, e) {
  for (var g = [], c = null, k = g, r = 0, t = [], v = 0; v < b.length; v++) {
    var u = b[v];
    var d = a;
    var l = h.parse(u.stackError);

    b: {
      var m = l,
          n = G(m, d, F);
      if (-1 !== n) d = n;else {
        for (var f = 0; f < d.length && 5 > f; f++) {
          if (n = G(m, d, f), -1 !== n) {
            F = f;
            d = n;
            break b;
          }
        }

        d = -1;
      }
    }

    b: {
      m = l;
      n = z().get(u.primitive);
      if (void 0 !== n) for (f = 0; f < n.length && f < m.length; f++) {
        if (n[f].source !== m[f].source) {
          f < m.length - 1 && H(m[f].functionName, u.primitive) && f++;
          f < m.length - 1 && H(m[f].functionName, u.primitive) && f++;
          m = f;
          break b;
        }
      }
      m = -1;
    }

    l = -1 === d || -1 === m || 2 > d - m ? null : l.slice(m, d - 1);

    if (null !== l) {
      d = 0;

      if (null !== c) {
        for (; d < l.length && d < c.length && l[l.length - d - 1].source === c[c.length - d - 1].source;) {
          d++;
        }

        for (c = c.length - 1; c > d; c--) {
          k = t.pop();
        }
      }

      for (c = l.length - d - 1; 1 <= c; c--) {
        d = [], m = l[c], (n = l[c - 1].functionName) ? (f = n.lastIndexOf("."), -1 === f && (f = 0), "use" === n.slice(f, f + 3) && (f += 3), n = n.slice(f)) : n = "", n = {
          id: null,
          isStateEditable: !1,
          name: n,
          value: void 0,
          subHooks: d
        }, e && (n.hookSource = {
          lineNumber: m.lineNumber,
          columnNumber: m.columnNumber,
          functionName: m.functionName,
          fileName: m.fileName
        }), k.push(n), t.push(k), k = d;
      }

      c = l;
    }

    d = u.primitive;
    u = {
      id: "Context" === d || "DebugValue" === d ? null : r++,
      isStateEditable: "Reducer" === d || "State" === d,
      name: d,
      value: u.value,
      subHooks: []
    };
    e && (d = {
      lineNumber: null,
      functionName: null,
      fileName: null,
      columnNumber: null
    }, l && 1 <= l.length && (l = l[0], d.lineNumber = l.lineNumber, d.functionName = l.functionName, d.fileName = l.fileName, d.columnNumber = l.columnNumber), u.hookSource = d);
    k.push(u);
  }

  J(g, null);
  return g;
}

function J(a, b) {
  for (var e = [], g = 0; g < a.length; g++) {
    var c = a[g];
    "DebugValue" === c.name && 0 === c.subHooks.length ? (a.splice(g, 1), g--, e.push(c)) : J(c.subHooks, c);
  }

  null !== b && (1 === e.length ? b.value = e[0].value : 1 < e.length && (b.value = e.map(function (k) {
    return k.value;
  })));
}

function K(a) {
  if (a instanceof Error && "ReactDebugToolsUnsupportedHookError" === a.name) throw a;
  var b = Error("Error rendering inspected component", {
    cause: a
  });
  b.name = "ReactDebugToolsRenderError";
  b.cause = a;
  throw b;
}

function L(a, b, e) {
  var g = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : !1;
  null == e && (e = w.ReactCurrentDispatcher);
  var c = e.current;
  e.current = E;

  try {
    var k = Error();
    a(b);
  } catch (t) {
    K(t);
  } finally {
    var r = x;
    x = [];
    e.current = c;
  }

  c = h.parse(k);
  return I(c, r, g);
}

function M(a) {
  a.forEach(function (b, e) {
    return e._currentValue = b;
  });
}

exports.inspectHooks = L;

exports.inspectHooksOfFiber = function (a, b) {
  var e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1;
  null == b && (b = w.ReactCurrentDispatcher);
  if (0 !== a.tag && 15 !== a.tag && 11 !== a.tag) throw Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
  z();
  var g = a.type,
      c = a.memoizedProps;

  if (g !== a.elementType && g && g.defaultProps) {
    c = q({}, c);
    var k = g.defaultProps;

    for (r in k) {
      void 0 === c[r] && (c[r] = k[r]);
    }
  }

  B = a.memoizedState;
  var r = new Map();

  try {
    for (k = a; k;) {
      if (10 === k.tag) {
        var t = k.type._context;
        r.has(t) || (r.set(t, t._currentValue), t._currentValue = k.memoizedProps.value);
      }

      k = k.return;
    }

    if (11 === a.tag) {
      var v = g.render;
      g = c;
      var u = a.ref;
      t = b;
      var d = t.current;
      t.current = E;

      try {
        var l = Error();
        v(g, u);
      } catch (f) {
        K(f);
      } finally {
        var m = x;
        x = [];
        t.current = d;
      }

      var n = h.parse(l);
      return I(n, m, e);
    }

    return L(g, c, b, e);
  } finally {
    B = null, M(r);
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(25)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function ErrorStackParser(StackFrame) {
  'use strict';

  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    /**
     * Given an Error object, extract the most information from it.
     *
     * @param {Error} error object
     * @return {Array} of StackFrames
     */
    parse: function ErrorStackParser$$parse(error) {
      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
        return this.parseOpera(error);
      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error);
      } else if (error.stack) {
        return this.parseFFOrSafari(error);
      } else {
        throw new Error('Cannot parse given Error object');
      }
    },
    // Separate line and column numbers from a string of the form: (URI:Line:Column)
    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
      // Fail-fast but return locations like "(native)"
      if (urlLike.indexOf(':') === -1) {
        return [urlLike];
      }

      var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
      return [parts[1], parts[2] || undefined, parts[3] || undefined];
    },
    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
      }, this);
      return filtered.map(function (line) {
        if (line.indexOf('(eval ') > -1) {
          // Throw away eval information until we implement stacktrace.js/stackframe#8
          line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
        }

        var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '('); // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
        // case it has spaces in it, as the string is split on \s+ later on

        var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/); // remove the parenthesized location from the line, if it was matched

        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;
        var tokens = sanitizedLine.split(/\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token

        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
        var functionName = tokens.join(' ') || undefined;
        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];
        return new StackFrame({
          functionName: functionName,
          fileName: fileName,
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    },
    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !line.match(SAFARI_NATIVE_CODE_REGEXP);
      }, this);
      return filtered.map(function (line) {
        // Throw away eval information until we implement stacktrace.js/stackframe#8
        if (line.indexOf(' > eval') > -1) {
          line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
        }

        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
          // Safari eval frames only have function names and nothing else
          return new StackFrame({
            functionName: line
          });
        } else {
          var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
          var matches = line.match(functionNameRegex);
          var functionName = matches && matches[1] ? matches[1] : undefined;
          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));
          return new StackFrame({
            functionName: functionName,
            fileName: locationParts[0],
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            source: line
          });
        }
      }, this);
    },
    parseOpera: function ErrorStackParser$$parseOpera(e) {
      if (!e.stacktrace || e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
        return this.parseOpera9(e);
      } else if (!e.stack) {
        return this.parseOpera10(e);
      } else {
        return this.parseOpera11(e);
      }
    },
    parseOpera9: function ErrorStackParser$$parseOpera9(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
      var lines = e.message.split('\n');
      var result = [];

      for (var i = 2, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    parseOpera10: function ErrorStackParser$$parseOpera10(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
      var lines = e.stacktrace.split('\n');
      var result = [];

      for (var i = 0, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            functionName: match[3] || undefined,
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    // Opera 10.65+ Error.stack very similar to FF/Safari
    parseOpera11: function ErrorStackParser$$parseOpera11(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
      }, this);
      return filtered.map(function (line) {
        var tokens = line.split('@');
        var locationParts = this.extractLocation(tokens.pop());
        var functionCall = tokens.shift() || '';
        var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, '$2').replace(/\([^)]*\)/g, '') || undefined;
        var argsRaw;

        if (functionCall.match(/\(([^)]*)\)/)) {
          argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
        }

        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');
        return new StackFrame({
          functionName: functionName,
          args: args,
          fileName: locationParts[0],
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    }
  };
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  'use strict';

  function _isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  }

  function _getter(p) {
    return function () {
      return this[p];
    };
  }

  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
  var numericProps = ['columnNumber', 'lineNumber'];
  var stringProps = ['fileName', 'functionName', 'source'];
  var arrayProps = ['args'];
  var props = booleanProps.concat(numericProps, stringProps, arrayProps);

  function StackFrame(obj) {
    if (!obj) return;

    for (var i = 0; i < props.length; i++) {
      if (obj[props[i]] !== undefined) {
        this['set' + _capitalize(props[i])](obj[props[i]]);
      }
    }
  }

  StackFrame.prototype = {
    getArgs: function getArgs() {
      return this.args;
    },
    setArgs: function setArgs(v) {
      if (Object.prototype.toString.call(v) !== '[object Array]') {
        throw new TypeError('Args must be an Array');
      }

      this.args = v;
    },
    getEvalOrigin: function getEvalOrigin() {
      return this.evalOrigin;
    },
    setEvalOrigin: function setEvalOrigin(v) {
      if (v instanceof StackFrame) {
        this.evalOrigin = v;
      } else if (v instanceof Object) {
        this.evalOrigin = new StackFrame(v);
      } else {
        throw new TypeError('Eval Origin must be an Object or StackFrame');
      }
    },
    toString: function toString() {
      var fileName = this.getFileName() || '';
      var lineNumber = this.getLineNumber() || '';
      var columnNumber = this.getColumnNumber() || '';
      var functionName = this.getFunctionName() || '';

      if (this.getIsEval()) {
        if (fileName) {
          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
        }

        return '[eval]:' + lineNumber + ':' + columnNumber;
      }

      if (functionName) {
        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
      }

      return fileName + ':' + lineNumber + ':' + columnNumber;
    }
  };

  StackFrame.fromString = function StackFrame$$fromString(str) {
    var argsStartIndex = str.indexOf('(');
    var argsEndIndex = str.lastIndexOf(')');
    var functionName = str.substring(0, argsStartIndex);
    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
    var locationString = str.substring(argsEndIndex + 1);

    if (locationString.indexOf('@') === 0) {
      var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
      var fileName = parts[1];
      var lineNumber = parts[2];
      var columnNumber = parts[3];
    }

    return new StackFrame({
      functionName: functionName,
      args: args || undefined,
      fileName: fileName,
      lineNumber: lineNumber || undefined,
      columnNumber: columnNumber || undefined
    });
  };

  for (var i = 0; i < booleanProps.length; i++) {
    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);

    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {
      return function (v) {
        this[p] = Boolean(v);
      };
    }(booleanProps[i]);
  }

  for (var j = 0; j < numericProps.length; j++) {
    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);

    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {
      return function (v) {
        if (!_isNumber(v)) {
          throw new TypeError(p + ' must be a Number');
        }

        this[p] = Number(v);
      };
    }(numericProps[j]);
  }

  for (var k = 0; k < stringProps.length; k++) {
    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);

    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {
      return function (v) {
        this[p] = String(v);
      };
    }(stringProps[k]);
  }

  return StackFrame;
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(27);
} else {}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var l = Symbol.for("react.element"),
    n = Symbol.for("react.portal"),
    p = Symbol.for("react.fragment"),
    q = Symbol.for("react.strict_mode"),
    r = Symbol.for("react.profiler"),
    t = Symbol.for("react.provider"),
    u = Symbol.for("react.context"),
    v = Symbol.for("react.server_context"),
    w = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    y = Symbol.for("react.suspense_list"),
    z = Symbol.for("react.memo"),
    A = Symbol.for("react.lazy"),
    aa = Symbol.for("react.debug_trace_mode"),
    ba = Symbol.for("react.offscreen"),
    ca = Symbol.for("react.cache"),
    B = Symbol.for("react.default_value"),
    C = Symbol.iterator;

function da(a) {
  if (null === a || "object" !== _typeof(a)) return null;
  a = C && a[C] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

var D = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueForceUpdate: function enqueueForceUpdate() {},
  enqueueReplaceState: function enqueueReplaceState() {},
  enqueueSetState: function enqueueSetState() {}
},
    E = Object.assign,
    F = {};

function G(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = F;
  this.updater = c || D;
}

G.prototype.isReactComponent = {};

G.prototype.setState = function (a, b) {
  if ("object" !== _typeof(a) && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};

G.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function H() {}

H.prototype = G.prototype;

function I(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = F;
  this.updater = c || D;
}

var J = I.prototype = new H();
J.constructor = I;
E(J, G.prototype);
J.isPureReactComponent = !0;
var K = Array.isArray,
    L = Object.prototype.hasOwnProperty,
    M = {
  current: null
},
    N = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function O(a, b, c) {
  var d,
      e = {},
      f = null,
      g = null;
  if (null != b) for (d in void 0 !== b.ref && (g = b.ref), void 0 !== b.key && (f = "" + b.key), b) {
    L.call(b, d) && !N.hasOwnProperty(d) && (e[d] = b[d]);
  }
  var h = arguments.length - 2;
  if (1 === h) e.children = c;else if (1 < h) {
    for (var k = Array(h), m = 0; m < h; m++) {
      k[m] = arguments[m + 2];
    }

    e.children = k;
  }
  if (a && a.defaultProps) for (d in h = a.defaultProps, h) {
    void 0 === e[d] && (e[d] = h[d]);
  }
  return {
    $$typeof: l,
    type: a,
    key: f,
    ref: g,
    props: e,
    _owner: M.current
  };
}

function ea(a, b) {
  return {
    $$typeof: l,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}

function P(a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === l;
}

function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (c) {
    return b[c];
  });
}

var Q = /\/+/g;

function R(a, b) {
  return "object" === _typeof(a) && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}

function S(a, b, c, d, e) {
  var f = _typeof(a);

  if ("undefined" === f || "boolean" === f) a = null;
  var g = !1;
  if (null === a) g = !0;else switch (f) {
    case "string":
    case "number":
      g = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case l:
        case n:
          g = !0;
      }

  }
  if (g) return g = a, e = e(g), a = "" === d ? "." + R(g, 0) : d, K(e) ? (c = "", null != a && (c = a.replace(Q, "$&/") + "/"), S(e, b, c, "", function (m) {
    return m;
  })) : null != e && (P(e) && (e = ea(e, c + (!e.key || g && g.key === e.key ? "" : ("" + e.key).replace(Q, "$&/") + "/") + a)), b.push(e)), 1;
  g = 0;
  d = "" === d ? "." : d + ":";
  if (K(a)) for (var h = 0; h < a.length; h++) {
    f = a[h];
    var k = d + R(f, h);
    g += S(f, b, c, k, e);
  } else if (k = da(a), "function" === typeof k) for (a = k.call(a), h = 0; !(f = a.next()).done;) {
    f = f.value, k = d + R(f, h++), g += S(f, b, c, k, e);
  } else if ("object" === f) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return g;
}

function T(a, b, c) {
  if (null == a) return a;
  var d = [],
      e = 0;
  S(a, d, "", "", function (f) {
    return b.call(c, f, e++);
  });
  return d;
}

function fa(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function (c) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = c;
    }, function (c) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = c;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }

  if (1 === a._status) return a._result.default;
  throw a._result;
}

var U = {
  current: null
};

function ha() {
  return new WeakMap();
}

function V() {
  return {
    s: 0,
    v: void 0,
    o: null,
    p: null
  };
}

var W = {
  current: null
},
    X = {
  transition: null
},
    Y = {
  ReactCurrentDispatcher: W,
  ReactCurrentCache: U,
  ReactCurrentBatchConfig: X,
  ReactCurrentOwner: M,
  ContextRegistry: {}
},
    Z = Y.ContextRegistry;
exports.Children = {
  map: T,
  forEach: function forEach(a, b, c) {
    T(a, function () {
      b.apply(this, arguments);
    }, c);
  },
  count: function count(a) {
    var b = 0;
    T(a, function () {
      b++;
    });
    return b;
  },
  toArray: function toArray(a) {
    return T(a, function (b) {
      return b;
    }) || [];
  },
  only: function only(a) {
    if (!P(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  }
};
exports.Component = G;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = I;
exports.StrictMode = q;
exports.Suspense = x;
exports.SuspenseList = y;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y;

exports.cache = function (a) {
  return function () {
    var b = U.current;
    if (!b) return a.apply(null, arguments);
    var c = b.getCacheForType(ha);
    b = c.get(a);
    void 0 === b && (b = V(), c.set(a, b));
    c = 0;

    for (var d = arguments.length; c < d; c++) {
      var e = arguments[c];

      if ("function" === typeof e || "object" === _typeof(e) && null !== e) {
        var f = b.o;
        null === f && (b.o = f = new WeakMap());
        b = f.get(e);
        void 0 === b && (b = V(), f.set(e, b));
      } else f = b.p, null === f && (b.p = f = new Map()), b = f.get(e), void 0 === b && (b = V(), f.set(e, b));
    }

    if (1 === b.s) return b.v;
    if (2 === b.s) throw b.v;

    try {
      var g = a.apply(null, arguments);
      c = b;
      c.s = 1;
      return c.v = g;
    } catch (h) {
      throw g = b, g.s = 2, g.v = h, h;
    }
  };
};

exports.cloneElement = function (a, b, c) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = E({}, a.props),
      e = a.key,
      f = a.ref,
      g = a._owner;

  if (null != b) {
    void 0 !== b.ref && (f = b.ref, g = M.current);
    void 0 !== b.key && (e = "" + b.key);
    if (a.type && a.type.defaultProps) var h = a.type.defaultProps;

    for (k in b) {
      L.call(b, k) && !N.hasOwnProperty(k) && (d[k] = void 0 === b[k] && void 0 !== h ? h[k] : b[k]);
    }
  }

  var k = arguments.length - 2;
  if (1 === k) d.children = c;else if (1 < k) {
    h = Array(k);

    for (var m = 0; m < k; m++) {
      h[m] = arguments[m + 2];
    }

    d.children = h;
  }
  return {
    $$typeof: l,
    type: a.type,
    key: e,
    ref: f,
    props: d,
    _owner: g
  };
};

exports.createContext = function (a) {
  a = {
    $$typeof: u,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  };
  a.Provider = {
    $$typeof: t,
    _context: a
  };
  return a.Consumer = a;
};

exports.createElement = O;

exports.createFactory = function (a) {
  var b = O.bind(null, a);
  b.type = a;
  return b;
};

exports.createRef = function () {
  return {
    current: null
  };
};

exports.createServerContext = function (a, b) {
  var c = !0;

  if (!Z[a]) {
    c = !1;
    var d = {
      $$typeof: v,
      _currentValue: b,
      _currentValue2: b,
      _defaultValue: b,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _globalName: a
    };
    d.Provider = {
      $$typeof: t,
      _context: d
    };
    Z[a] = d;
  }

  d = Z[a];
  if (d._defaultValue === B) d._defaultValue = b, d._currentValue === B && (d._currentValue = b), d._currentValue2 === B && (d._currentValue2 = b);else if (c) throw Error("ServerContext: " + a + " already defined");
  return d;
};

exports.experimental_useEffectEvent = function (a) {
  return W.current.useEffectEvent(a);
};

exports.forwardRef = function (a) {
  return {
    $$typeof: w,
    render: a
  };
};

exports.isValidElement = P;

exports.lazy = function (a) {
  return {
    $$typeof: A,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: fa
  };
};

exports.memo = function (a, b) {
  return {
    $$typeof: z,
    type: a,
    compare: void 0 === b ? null : b
  };
};

exports.startTransition = function (a) {
  var b = X.transition;
  X.transition = {};

  try {
    a();
  } finally {
    X.transition = b;
  }
};

exports.unstable_Cache = ca;
exports.unstable_DebugTracingMode = aa;
exports.unstable_Offscreen = ba;

exports.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};

exports.unstable_getCacheForType = function (a) {
  var b = U.current;
  return b ? b.getCacheForType(a) : a();
};

exports.unstable_getCacheSignal = function () {
  var a = U.current;
  return a ? a.getCacheSignal() : (a = new AbortController(), a.abort(Error("This CacheSignal was requested outside React which means that it is immediately aborted.")), a.signal);
};

exports.unstable_useCacheRefresh = function () {
  return W.current.useCacheRefresh();
};

exports.unstable_useMemoCache = function (a) {
  return W.current.useMemoCache(a);
};

exports.use = function (a) {
  return W.current.use(a);
};

exports.useCallback = function (a, b) {
  return W.current.useCallback(a, b);
};

exports.useContext = function (a) {
  return W.current.useContext(a);
};

exports.useDebugValue = function () {};

exports.useDeferredValue = function (a) {
  return W.current.useDeferredValue(a);
};

exports.useEffect = function (a, b) {
  return W.current.useEffect(a, b);
};

exports.useId = function () {
  return W.current.useId();
};

exports.useImperativeHandle = function (a, b, c) {
  return W.current.useImperativeHandle(a, b, c);
};

exports.useInsertionEffect = function (a, b) {
  return W.current.useInsertionEffect(a, b);
};

exports.useLayoutEffect = function (a, b) {
  return W.current.useLayoutEffect(a, b);
};

exports.useMemo = function (a, b) {
  return W.current.useMemo(a, b);
};

exports.useReducer = function (a, b, c) {
  return W.current.useReducer(a, b, c);
};

exports.useRef = function (a) {
  return W.current.useRef(a);
};

exports.useState = function (a) {
  return W.current.useState(a);
};

exports.useSyncExternalStore = function (a, b, c) {
  return W.current.useSyncExternalStore(a, b, c);
};

exports.useTransition = function () {
  return W.current.useTransition();
};

exports.version = "18.3.0-experimental-7f8c501f6-20230420";

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "connectToDevTools", function() { return /* binding */ connectToDevTools; });

// CONCATENATED MODULE: ../react-devtools-shared/src/events.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    _defineProperty(this, "listenersMap", new Map());
  }

  _createClass(EventEmitter, [{
    key: "addListener",
    value: function addListener(event, listener) {
      var listeners = this.listenersMap.get(event);

      if (listeners === undefined) {
        this.listenersMap.set(event, [listener]);
      } else {
        var index = listeners.indexOf(listener);

        if (index < 0) {
          listeners.push(listener);
        }
      }
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var listeners = this.listenersMap.get(event);

      if (listeners !== undefined) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        if (listeners.length === 1) {
          // No need to clone or try/catch
          var listener = listeners[0];
          listener.apply(null, args);
        } else {
          var didThrow = false;
          var caughtError = null;
          var clonedListeners = Array.from(listeners);

          for (var i = 0; i < clonedListeners.length; i++) {
            var _listener = clonedListeners[i];

            try {
              _listener.apply(null, args);
            } catch (error) {
              if (caughtError === null) {
                didThrow = true;
                caughtError = error;
              }
            }
          }

          if (didThrow) {
            throw caughtError;
          }
        }
      }
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners() {
      this.listenersMap.clear();
    }
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      var listeners = this.listenersMap.get(event);

      if (listeners !== undefined) {
        var index = listeners.indexOf(listener);

        if (index >= 0) {
          listeners.splice(index, 1);
        }
      }
    }
  }]);

  return EventEmitter;
}();


// EXTERNAL MODULE: /Users/hoxy/repos/react/node_modules/lodash.throttle/index.js
var lodash_throttle = __webpack_require__(12);
var lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);

// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js
var constants = __webpack_require__(2);

// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js
var storage = __webpack_require__(5);

// CONCATENATED MODULE: /Users/hoxy/repos/react/node_modules/memoize-one/esm/index.js
var simpleIsEqual = function simpleIsEqual(a, b) {
  return a === b;
};

/* harmony default export */ var esm = (function (resultFn) {
  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;
  var lastThis = void 0;
  var lastArgs = [];
  var lastResult = void 0;
  var calledOnce = false;

  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
    return isEqual(newArg, lastArgs[index]);
  };

  var result = function result() {
    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }

    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
      return lastResult;
    }

    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    lastResult = resultFn.apply(this, newArgs);
    return lastResult;
  };

  return result;
});
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/utils.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Get the window object for the document that a node belongs to,
// or return null if it cannot be found (node not attached to DOM,
// etc).
function getOwnerWindow(node) {
  if (!node.ownerDocument) {
    return null;
  }

  return node.ownerDocument.defaultView;
} // Get the iframe containing a node, or return null if it cannot
// be found (node not within iframe, etc).

function getOwnerIframe(node) {
  var nodeWindow = getOwnerWindow(node);

  if (nodeWindow) {
    return nodeWindow.frameElement;
  }

  return null;
} // Get a bounding client rect for a node, with an
// offset added to compensate for its border.

function getBoundingClientRectWithBorderOffset(node) {
  var dimensions = getElementDimensions(node);
  return mergeRectOffsets([node.getBoundingClientRect(), {
    top: dimensions.borderTop,
    left: dimensions.borderLeft,
    bottom: dimensions.borderBottom,
    right: dimensions.borderRight,
    // This width and height won't get used by mergeRectOffsets (since this
    // is not the first rect in the array), but we set them so that this
    // object type checks as a ClientRect.
    width: 0,
    height: 0
  }]);
} // Add together the top, left, bottom, and right properties of
// each ClientRect, but keep the width and height of the first one.

function mergeRectOffsets(rects) {
  return rects.reduce(function (previousRect, rect) {
    if (previousRect == null) {
      return rect;
    }

    return {
      top: previousRect.top + rect.top,
      left: previousRect.left + rect.left,
      width: previousRect.width,
      height: previousRect.height,
      bottom: previousRect.bottom + rect.bottom,
      right: previousRect.right + rect.right
    };
  });
} // Calculate a boundingClientRect for a node relative to boundaryWindow,
// taking into account any offsets caused by intermediate iframes.

function getNestedBoundingClientRect(node, boundaryWindow) {
  var ownerIframe = getOwnerIframe(node);

  if (ownerIframe && ownerIframe !== boundaryWindow) {
    var rects = [node.getBoundingClientRect()];
    var currentIframe = ownerIframe;
    var onlyOneMore = false;

    while (currentIframe) {
      var rect = getBoundingClientRectWithBorderOffset(currentIframe);
      rects.push(rect);
      currentIframe = getOwnerIframe(currentIframe);

      if (onlyOneMore) {
        break;
      } // We don't want to calculate iframe offsets upwards beyond
      // the iframe containing the boundaryWindow, but we
      // need to calculate the offset relative to the boundaryWindow.


      if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {
        onlyOneMore = true;
      }
    }

    return mergeRectOffsets(rects);
  } else {
    return node.getBoundingClientRect();
  }
}
function getElementDimensions(domElement) {
  var calculatedStyle = window.getComputedStyle(domElement);
  return {
    borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),
    borderRight: parseInt(calculatedStyle.borderRightWidth, 10),
    borderTop: parseInt(calculatedStyle.borderTopWidth, 10),
    borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),
    marginLeft: parseInt(calculatedStyle.marginLeft, 10),
    marginRight: parseInt(calculatedStyle.marginRight, 10),
    marginTop: parseInt(calculatedStyle.marginTop, 10),
    marginBottom: parseInt(calculatedStyle.marginBottom, 10),
    paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),
    paddingRight: parseInt(calculatedStyle.paddingRight, 10),
    paddingTop: parseInt(calculatedStyle.paddingTop, 10),
    paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js
function Overlay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Overlay_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Overlay_createClass(Constructor, protoProps, staticProps) { if (protoProps) Overlay_defineProperties(Constructor.prototype, protoProps); if (staticProps) Overlay_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var Overlay_assign = Object.assign; // Note that the Overlay components are not affected by the active Theme,
// because they highlight elements in the main Chrome window (outside of devtools).
// The colors below were chosen to roughly match those used by Chrome devtools.

var OverlayRect = /*#__PURE__*/function () {
  function OverlayRect(doc, container) {
    Overlay_classCallCheck(this, OverlayRect);

    this.node = doc.createElement('div');
    this.border = doc.createElement('div');
    this.padding = doc.createElement('div');
    this.content = doc.createElement('div');
    this.border.style.borderColor = overlayStyles.border;
    this.padding.style.borderColor = overlayStyles.padding;
    this.content.style.backgroundColor = overlayStyles.background;
    Overlay_assign(this.node.style, {
      borderColor: overlayStyles.margin,
      pointerEvents: 'none',
      position: 'fixed'
    });
    this.node.style.zIndex = '10000000';
    this.node.appendChild(this.border);
    this.border.appendChild(this.padding);
    this.padding.appendChild(this.content);
    container.appendChild(this.node);
  }

  Overlay_createClass(OverlayRect, [{
    key: "remove",
    value: function remove() {
      if (this.node.parentNode) {
        this.node.parentNode.removeChild(this.node);
      }
    }
  }, {
    key: "update",
    value: function update(box, dims) {
      boxWrap(dims, 'margin', this.node);
      boxWrap(dims, 'border', this.border);
      boxWrap(dims, 'padding', this.padding);
      Overlay_assign(this.content.style, {
        height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',
        width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'
      });
      Overlay_assign(this.node.style, {
        top: box.top - dims.marginTop + 'px',
        left: box.left - dims.marginLeft + 'px'
      });
    }
  }]);

  return OverlayRect;
}();

var OverlayTip = /*#__PURE__*/function () {
  function OverlayTip(doc, container) {
    Overlay_classCallCheck(this, OverlayTip);

    this.tip = doc.createElement('div');
    Overlay_assign(this.tip.style, {
      display: 'flex',
      flexFlow: 'row nowrap',
      backgroundColor: '#333740',
      borderRadius: '2px',
      fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
      fontWeight: 'bold',
      padding: '3px 5px',
      pointerEvents: 'none',
      position: 'fixed',
      fontSize: '12px',
      whiteSpace: 'nowrap'
    });
    this.nameSpan = doc.createElement('span');
    this.tip.appendChild(this.nameSpan);
    Overlay_assign(this.nameSpan.style, {
      color: '#ee78e6',
      borderRight: '1px solid #aaaaaa',
      paddingRight: '0.5rem',
      marginRight: '0.5rem'
    });
    this.dimSpan = doc.createElement('span');
    this.tip.appendChild(this.dimSpan);
    Overlay_assign(this.dimSpan.style, {
      color: '#d7d7d7'
    });
    this.tip.style.zIndex = '10000000';
    container.appendChild(this.tip);
  }

  Overlay_createClass(OverlayTip, [{
    key: "remove",
    value: function remove() {
      if (this.tip.parentNode) {
        this.tip.parentNode.removeChild(this.tip);
      }
    }
  }, {
    key: "updateText",
    value: function updateText(name, width, height) {
      this.nameSpan.textContent = name;
      this.dimSpan.textContent = Math.round(width) + 'px × ' + Math.round(height) + 'px';
    }
  }, {
    key: "updatePosition",
    value: function updatePosition(dims, bounds) {
      var tipRect = this.tip.getBoundingClientRect();
      var tipPos = findTipPos(dims, bounds, {
        width: tipRect.width,
        height: tipRect.height
      });
      Overlay_assign(this.tip.style, tipPos.style);
    }
  }]);

  return OverlayTip;
}();

var Overlay_Overlay = /*#__PURE__*/function () {
  function Overlay(agent) {
    Overlay_classCallCheck(this, Overlay);

    // Find the root window, because overlays are positioned relative to it.
    var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.

    var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.tipBoundsWindow = tipBoundsWindow;
    var doc = currentWindow.document;
    this.container = doc.createElement('div');
    this.container.style.zIndex = '10000000';
    this.tip = new OverlayTip(doc, this.container);
    this.rects = [];
    this.agent = agent;
    doc.body.appendChild(this.container);
  }

  Overlay_createClass(Overlay, [{
    key: "remove",
    value: function remove() {
      this.tip.remove();
      this.rects.forEach(function (rect) {
        rect.remove();
      });
      this.rects.length = 0;

      if (this.container.parentNode) {
        this.container.parentNode.removeChild(this.container);
      }
    }
  }, {
    key: "inspect",
    value: function inspect(nodes, name) {
      var _this = this;

      // We can't get the size of text nodes or comment nodes. React as of v15
      // heavily uses comment nodes to delimit text.
      var elements = nodes.filter(function (node) {
        return node.nodeType === Node.ELEMENT_NODE;
      });

      while (this.rects.length > elements.length) {
        var rect = this.rects.pop();
        rect.remove();
      }

      if (elements.length === 0) {
        return;
      }

      while (this.rects.length < elements.length) {
        this.rects.push(new OverlayRect(this.window.document, this.container));
      }

      var outerBox = {
        top: Number.POSITIVE_INFINITY,
        right: Number.NEGATIVE_INFINITY,
        bottom: Number.NEGATIVE_INFINITY,
        left: Number.POSITIVE_INFINITY
      };
      elements.forEach(function (element, index) {
        var box = getNestedBoundingClientRect(element, _this.window);
        var dims = getElementDimensions(element);
        outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);
        outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);
        outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);
        outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);
        var rect = _this.rects[index];
        rect.update(box, dims);
      });

      if (!name) {
        name = elements[0].nodeName.toLowerCase();
        var node = elements[0];
        var rendererInterface = this.agent.getBestMatchingRendererInterface(node);

        if (rendererInterface) {
          var id = rendererInterface.getFiberIDForNative(node, true);

          if (id) {
            var ownerName = rendererInterface.getDisplayNameForFiberID(id, true);

            if (ownerName) {
              name += ' (in ' + ownerName + ')';
            }
          }
        }
      }

      this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);
      var tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);
      this.tip.updatePosition({
        top: outerBox.top,
        left: outerBox.left,
        height: outerBox.bottom - outerBox.top,
        width: outerBox.right - outerBox.left
      }, {
        top: tipBounds.top + this.tipBoundsWindow.scrollY,
        left: tipBounds.left + this.tipBoundsWindow.scrollX,
        height: this.tipBoundsWindow.innerHeight,
        width: this.tipBoundsWindow.innerWidth
      });
    }
  }]);

  return Overlay;
}();



function findTipPos(dims, bounds, tipSize) {
  var tipHeight = Math.max(tipSize.height, 20);
  var tipWidth = Math.max(tipSize.width, 60);
  var margin = 5;
  var top;

  if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {
    if (dims.top + dims.height < bounds.top + 0) {
      top = bounds.top + margin;
    } else {
      top = dims.top + dims.height + margin;
    }
  } else if (dims.top - tipHeight <= bounds.top + bounds.height) {
    if (dims.top - tipHeight - margin < bounds.top + margin) {
      top = bounds.top + margin;
    } else {
      top = dims.top - tipHeight - margin;
    }
  } else {
    top = bounds.top + bounds.height - tipHeight - margin;
  }

  var left = dims.left + margin;

  if (dims.left < bounds.left) {
    left = bounds.left + margin;
  }

  if (dims.left + tipWidth > bounds.left + bounds.width) {
    left = bounds.left + bounds.width - tipWidth - margin;
  }

  top += 'px';
  left += 'px';
  return {
    style: {
      top: top,
      left: left
    }
  };
}

function boxWrap(dims, what, node) {
  Overlay_assign(node.style, {
    borderTopWidth: dims[what + 'Top'] + 'px',
    borderLeftWidth: dims[what + 'Left'] + 'px',
    borderRightWidth: dims[what + 'Right'] + 'px',
    borderBottomWidth: dims[what + 'Bottom'] + 'px',
    borderStyle: 'solid'
  });
}

var overlayStyles = {
  background: 'rgba(120, 170, 210, 0.7)',
  padding: 'rgba(77, 200, 0, 0.3)',
  margin: 'rgba(255, 155, 0, 0.3)',
  border: 'rgba(255, 200, 50, 0.3)'
};
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var SHOW_DURATION = 2000;
var timeoutID = null;
var overlay = null;
function hideOverlay(agent) {
  if (window.document == null) {
    agent.emit('hideNativeHighlight');
    return;
  }

  timeoutID = null;

  if (overlay !== null) {
    overlay.remove();
    overlay = null;
  }
}
function showOverlay(elements, componentName, agent, hideAfterTimeout) {
  if (window.document == null) {
    if (elements != null && elements[0] != null) {
      agent.emit('showNativeHighlight', elements[0]);
    }

    return;
  }

  if (timeoutID !== null) {
    clearTimeout(timeoutID);
  }

  if (elements == null) {
    return;
  }

  if (overlay === null) {
    overlay = new Overlay_Overlay(agent);
  }

  overlay.inspect(elements, componentName);

  if (hideAfterTimeout) {
    timeoutID = setTimeout(function () {
      return hideOverlay(agent);
    }, SHOW_DURATION);
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/index.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




// This plug-in provides in-page highlighting of the selected element.
// It is used by the browser extension and the standalone DevTools shell (when connected to a browser).
// It is not currently the mechanism used to highlight React Native views.
// That is done by the React Native Inspector component.
var iframesListeningTo = new Set();
function setupHighlighter(bridge, agent) {
  bridge.addListener('clearNativeElementHighlight', clearNativeElementHighlight);
  bridge.addListener('highlightNativeElement', highlightNativeElement);
  bridge.addListener('shutdown', stopInspectingNative);
  bridge.addListener('startInspectingNative', startInspectingNative);
  bridge.addListener('stopInspectingNative', stopInspectingNative);

  function startInspectingNative() {
    registerListenersOnWindow(window);
  }

  function registerListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.addEventListener === 'function') {
      window.addEventListener('click', onClick, true);
      window.addEventListener('mousedown', onMouseEvent, true);
      window.addEventListener('mouseover', onMouseEvent, true);
      window.addEventListener('mouseup', onMouseEvent, true);
      window.addEventListener('pointerdown', onPointerDown, true);
      window.addEventListener('pointerover', onPointerOver, true);
      window.addEventListener('pointerup', onPointerUp, true);
    } else {
      agent.emit('startInspectingNative');
    }
  }

  function stopInspectingNative() {
    hideOverlay(agent);
    removeListenersOnWindow(window);
    iframesListeningTo.forEach(function (frame) {
      try {
        removeListenersOnWindow(frame.contentWindow);
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    });
    iframesListeningTo = new Set();
  }

  function removeListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.removeEventListener === 'function') {
      window.removeEventListener('click', onClick, true);
      window.removeEventListener('mousedown', onMouseEvent, true);
      window.removeEventListener('mouseover', onMouseEvent, true);
      window.removeEventListener('mouseup', onMouseEvent, true);
      window.removeEventListener('pointerdown', onPointerDown, true);
      window.removeEventListener('pointerover', onPointerOver, true);
      window.removeEventListener('pointerup', onPointerUp, true);
    } else {
      agent.emit('stopInspectingNative');
    }
  }

  function clearNativeElementHighlight() {
    hideOverlay(agent);
  }

  function highlightNativeElement(_ref) {
    var displayName = _ref.displayName,
        hideAfterTimeout = _ref.hideAfterTimeout,
        id = _ref.id,
        openNativeElementsPanel = _ref.openNativeElementsPanel,
        rendererID = _ref.rendererID,
        scrollIntoView = _ref.scrollIntoView;
    var renderer = agent.rendererInterfaces[rendererID];

    if (renderer == null) {
      console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
    }

    var nodes = null;

    if (renderer != null) {
      nodes = renderer.findNativeNodesForFiberID(id);
    }

    if (nodes != null && nodes[0] != null) {
      var node = nodes[0]; // $FlowFixMe[method-unbinding]

      if (scrollIntoView && typeof node.scrollIntoView === 'function') {
        // If the node isn't visible show it before highlighting it.
        // We may want to reconsider this; it might be a little disruptive.
        node.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });
      }

      showOverlay(nodes, displayName, agent, hideAfterTimeout);

      if (openNativeElementsPanel) {
        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;
        bridge.send('syncSelectionToNativeElementsPanel');
      }
    } else {
      hideOverlay(agent);
    }
  }

  function onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    stopInspectingNative();
    bridge.send('stopInspectingNative', true);
  }

  function onMouseEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function onPointerDown(event) {
    event.preventDefault();
    event.stopPropagation();
    selectFiberForNode(event.target);
  }

  function onPointerOver(event) {
    event.preventDefault();
    event.stopPropagation();
    var target = event.target;

    if (target.tagName === 'IFRAME') {
      var iframe = target;

      try {
        if (!iframesListeningTo.has(iframe)) {
          var _window = iframe.contentWindow;
          registerListenersOnWindow(_window);
          iframesListeningTo.add(iframe);
        }
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    } // Don't pass the name explicitly.
    // It will be inferred from DOM tag and Fiber owner.


    showOverlay([target], null, agent, false);
    selectFiberForNode(target);
  }

  function onPointerUp(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  var selectFiberForNode = lodash_throttle_default()(esm(function (node) {
    var id = agent.getIDForNode(node);

    if (id !== null) {
      bridge.send('selectFiber', id);
    }
  }), 200, // Don't change the selection in the very first 200ms
  // because those are usually unintentional as you lift the cursor.
  {
    leading: false
  });
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var OUTLINE_COLOR = '#f0f0f0'; // Note these colors are in sync with DevTools Profiler chart colors.

var COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];
var canvas = null;
function draw(nodeToData, agent) {
  if (window.document == null) {
    var nodesToDraw = [];
    iterateNodes(nodeToData, function (_, color, node) {
      nodesToDraw.push({
        node: node,
        color: color
      });
    });
    agent.emit('drawTraceUpdates', nodesToDraw);
    return;
  }

  if (canvas === null) {
    initialize();
  }

  var canvasFlow = canvas;
  canvasFlow.width = window.innerWidth;
  canvasFlow.height = window.innerHeight;
  var context = canvasFlow.getContext('2d');
  context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);
  iterateNodes(nodeToData, function (rect, color) {
    if (rect !== null) {
      drawBorder(context, rect, color);
    }
  });
}

function iterateNodes(nodeToData, execute) {
  nodeToData.forEach(function (_ref, node) {
    var count = _ref.count,
        rect = _ref.rect;
    var colorIndex = Math.min(COLORS.length - 1, count - 1);
    var color = COLORS[colorIndex];
    execute(rect, color, node);
  });
}

function drawBorder(context, rect, color) {
  var height = rect.height,
      left = rect.left,
      top = rect.top,
      width = rect.width; // outline

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left - 1, top - 1, width + 2, height + 2); // inset

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left + 1, top + 1, width - 1, height - 1);
  context.strokeStyle = color;
  context.setLineDash([0]); // border

  context.lineWidth = 1;
  context.strokeRect(left, top, width - 1, height - 1);
  context.setLineDash([0]);
}

function destroy(agent) {
  if (window.document == null) {
    agent.emit('disableTraceUpdates');
    return;
  }

  if (canvas !== null) {
    if (canvas.parentNode != null) {
      canvas.parentNode.removeChild(canvas);
    }

    canvas = null;
  }
}

function initialize() {
  canvas = window.document.createElement('canvas');
  canvas.style.cssText = "\n    xx-background-color: red;\n    xx-opacity: 0.5;\n    bottom: 0;\n    left: 0;\n    pointer-events: none;\n    position: fixed;\n    right: 0;\n    top: 0;\n    z-index: 1000000000;\n  ";
  var root = window.document.documentElement;
  root.insertBefore(canvas, root.firstChild);
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// How long the rect should be shown for?
var DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?
// This can be important if we're getting a flurry of events (e.g. scroll update).

var MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?

var REMEASUREMENT_AFTER_DURATION = 250; // Some environments (e.g. React Native / Hermes) don't support the performance API yet.

var getCurrentTime = // $FlowFixMe[method-unbinding]
(typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var nodeToData = new Map();
var TraceUpdates_agent = null;
var drawAnimationFrameID = null;
var isEnabled = false;
var redrawTimeoutID = null;
function TraceUpdates_initialize(injectedAgent) {
  TraceUpdates_agent = injectedAgent;
  TraceUpdates_agent.addListener('traceUpdates', traceUpdates);
}
function toggleEnabled(value) {
  isEnabled = value;

  if (!isEnabled) {
    nodeToData.clear();

    if (drawAnimationFrameID !== null) {
      cancelAnimationFrame(drawAnimationFrameID);
      drawAnimationFrameID = null;
    }

    if (redrawTimeoutID !== null) {
      clearTimeout(redrawTimeoutID);
      redrawTimeoutID = null;
    }

    destroy(TraceUpdates_agent);
  }
}

function traceUpdates(nodes) {
  if (!isEnabled) {
    return;
  }

  nodes.forEach(function (node) {
    var data = nodeToData.get(node);
    var now = getCurrentTime();
    var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;
    var rect = data != null ? data.rect : null;

    if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {
      lastMeasuredAt = now;
      rect = measureNode(node);
    }

    nodeToData.set(node, {
      count: data != null ? data.count + 1 : 1,
      expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,
      lastMeasuredAt: lastMeasuredAt,
      rect: rect
    });
  });

  if (redrawTimeoutID !== null) {
    clearTimeout(redrawTimeoutID);
    redrawTimeoutID = null;
  }

  if (drawAnimationFrameID === null) {
    drawAnimationFrameID = requestAnimationFrame(prepareToDraw);
  }
}

function prepareToDraw() {
  drawAnimationFrameID = null;
  redrawTimeoutID = null;
  var now = getCurrentTime();
  var earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.

  nodeToData.forEach(function (data, node) {
    if (data.expirationTime < now) {
      nodeToData.delete(node);
    } else {
      earliestExpiration = Math.min(earliestExpiration, data.expirationTime);
    }
  });
  draw(nodeToData, TraceUpdates_agent);

  if (earliestExpiration !== Number.MAX_VALUE) {
    redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);
  }
}

function measureNode(node) {
  if (!node || typeof node.getBoundingClientRect !== 'function') {
    return null;
  }

  var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
  return getNestedBoundingClientRect(node, currentWindow);
}
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/console.js
var backend_console = __webpack_require__(8);

// CONCATENATED MODULE: ../react-devtools-shared/src/bridge.js
function bridge_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bridge_typeof = function _typeof(obj) { return typeof obj; }; } else { bridge_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bridge_typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function bridge_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bridge_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bridge_createClass(Constructor, protoProps, staticProps) { if (protoProps) bridge_defineProperties(Constructor.prototype, protoProps); if (staticProps) bridge_defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (bridge_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function bridge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var BATCH_DURATION = 100; // This message specifies the version of the DevTools protocol currently supported by the backend,
// as well as the earliest NPM version (e.g. "4.13.0") that protocol is supported by on the frontend.
// This enables an older frontend to display an upgrade message to users for a newer, unsupported backend.

// Bump protocol version whenever a backwards breaking change is made
// in the messages sent between BackendBridge and FrontendBridge.
// This mapping is embedded in both frontend and backend builds.
//
// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.
//
// When an older frontend connects to a newer backend,
// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.
//
// When a newer frontend connects with an older protocol version,
// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.
var BRIDGE_PROTOCOL = [// This version technically never existed,
// but a backwards breaking change was added in 4.11,
// so the safest guess to downgrade the frontend would be to version 4.10.
{
  version: 0,
  minNpmVersion: '"<4.11.0"',
  maxNpmVersion: '"<4.11.0"'
}, // Versions 4.11.x – 4.12.x contained the backwards breaking change,
// but we didn't add the "fix" of checking the protocol version until 4.13,
// so we don't recommend downgrading to 4.11 or 4.12.
{
  version: 1,
  minNpmVersion: '4.13.0',
  maxNpmVersion: '4.21.0'
}, // Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.
{
  version: 2,
  minNpmVersion: '4.22.0',
  maxNpmVersion: null
}];
var currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];

var Bridge = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Bridge, _EventEmitter);

  var _super = _createSuper(Bridge);

  function Bridge(wall) {
    var _this;

    bridge_classCallCheck(this, Bridge);

    _this = _super.call(this);

    bridge_defineProperty(_assertThisInitialized(_this), "_isShutdown", false);

    bridge_defineProperty(_assertThisInitialized(_this), "_messageQueue", []);

    bridge_defineProperty(_assertThisInitialized(_this), "_timeoutID", null);

    bridge_defineProperty(_assertThisInitialized(_this), "_wallUnlisten", null);

    bridge_defineProperty(_assertThisInitialized(_this), "_flush", function () {
      // This method is used after the bridge is marked as destroyed in shutdown sequence,
      // so we do not bail out if the bridge marked as destroyed.
      // It is a private method that the bridge ensures is only called at the right times.
      if (_this._timeoutID !== null) {
        clearTimeout(_this._timeoutID);
        _this._timeoutID = null;
      }

      if (_this._messageQueue.length) {
        for (var i = 0; i < _this._messageQueue.length; i += 2) {
          var _this$_wall;

          (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(_toConsumableArray(_this._messageQueue[i + 1])));
        }

        _this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep
        // flushing in a loop as long as messages continue to be added. Once no
        // more are, the timer expires.

        _this._timeoutID = setTimeout(_this._flush, BATCH_DURATION);
      }
    });

    bridge_defineProperty(_assertThisInitialized(_this), "overrideValueAtPath", function (_ref) {
      var id = _ref.id,
          path = _ref.path,
          rendererID = _ref.rendererID,
          type = _ref.type,
          value = _ref.value;

      switch (type) {
        case 'context':
          _this.send('overrideContext', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'hooks':
          _this.send('overrideHookState', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'props':
          _this.send('overrideProps', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'state':
          _this.send('overrideState', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;
      }
    });

    _this._wall = wall;
    _this._wallUnlisten = wall.listen(function (message) {
      if (message && message.event) {
        _assertThisInitialized(_this).emit(message.event, message.payload);
      }
    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    _this.addListener('overrideValueAtPath', _this.overrideValueAtPath);

    return _this;
  } // Listening directly to the wall isn't advised.
  // It can be used to listen for legacy (v3) messages (since they use a different format).


  bridge_createClass(Bridge, [{
    key: "send",
    value: function send(event) {
      if (this._isShutdown) {
        console.warn("Cannot send message \"".concat(event, "\" through a Bridge that has been shutdown."));
        return;
      } // When we receive a message:
      // - we add it to our queue of messages to be sent
      // - if there hasn't been a message recently, we set a timer for 0 ms in
      //   the future, allowing all messages created in the same tick to be sent
      //   together
      // - if there *has* been a message flushed in the last BATCH_DURATION ms
      //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will
      //   be set, and we'll simply add to the queue and wait for that


      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }

      this._messageQueue.push(event, payload);

      if (!this._timeoutID) {
        this._timeoutID = setTimeout(this._flush, 0);
      }
    }
  }, {
    key: "shutdown",
    value: function shutdown() {
      if (this._isShutdown) {
        console.warn('Bridge was already shutdown.');
        return;
      } // Queue the shutdown outgoing message for subscribers.


      this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.

      this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.
      // $FlowFixMe[cannot-write] This property is not writable.

      this.addListener = function () {}; // $FlowFixMe[cannot-write] This property is not writable.


      this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.
      // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.


      this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.

      var wallUnlisten = this._wallUnlisten;

      if (wallUnlisten) {
        wallUnlisten();
      } // Synchronously flush all queued outgoing messages.
      // At this step the subscribers' code may run in this call stack.


      do {
        this._flush();
      } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.


      if (this._timeoutID !== null) {
        clearTimeout(this._timeoutID);
        this._timeoutID = null;
      }
    }
  }, {
    key: "wall",
    get: function get() {
      return this._wall;
    }
  }]);

  return Bridge;
}(EventEmitter);

/* harmony default export */ var src_bridge = (Bridge);
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/utils.js + 1 modules
var utils = __webpack_require__(4);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/agent.js
function agent_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { agent_typeof = function _typeof(obj) { return typeof obj; }; } else { agent_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return agent_typeof(obj); }

function agent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function agent_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function agent_createClass(Constructor, protoProps, staticProps) { if (protoProps) agent_defineProperties(Constructor.prototype, protoProps); if (staticProps) agent_defineProperties(Constructor, staticProps); return Constructor; }

function agent_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) agent_setPrototypeOf(subClass, superClass); }

function agent_setPrototypeOf(o, p) { agent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return agent_setPrototypeOf(o, p); }

function agent_createSuper(Derived) { var hasNativeReflectConstruct = agent_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = agent_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = agent_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return agent_possibleConstructorReturn(this, result); }; }

function agent_possibleConstructorReturn(self, call) { if (call && (agent_typeof(call) === "object" || typeof call === "function")) { return call; } return agent_assertThisInitialized(self); }

function agent_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function agent_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function agent_getPrototypeOf(o) { agent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return agent_getPrototypeOf(o); }

function agent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










var agent_debug = function debug(methodName) {
  if (constants["s" /* __DEBUG__ */]) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["%cAgent %c".concat(methodName), 'color: purple; font-weight: bold;', 'font-weight: bold;'].concat(args));
  }
};

var agent_Agent = /*#__PURE__*/function (_EventEmitter) {
  agent_inherits(Agent, _EventEmitter);

  var _super = agent_createSuper(Agent);

  function Agent(bridge) {
    var _this;

    agent_classCallCheck(this, Agent);

    _this = _super.call(this);

    agent_defineProperty(agent_assertThisInitialized(_this), "_isProfiling", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "_recordChangeDescriptions", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "_rendererInterfaces", {});

    agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelection", null);

    agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelectionMatch", null);

    agent_defineProperty(agent_assertThisInitialized(_this), "_traceUpdatesEnabled", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsAndWarnings", function (_ref) {
      var rendererID = _ref.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearErrorsAndWarnings();
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsForFiberID", function (_ref2) {
      var id = _ref2.id,
          rendererID = _ref2.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearErrorsForFiberID(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "clearWarningsForFiberID", function (_ref3) {
      var id = _ref3.id,
          rendererID = _ref3.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearWarningsForFiberID(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "copyElementPath", function (_ref4) {
      var id = _ref4.id,
          path = _ref4.path,
          rendererID = _ref4.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        var value = renderer.getSerializedElementValueByPath(id, path);

        if (value != null) {
          _this._bridge.send('saveToClipboard', value);
        } else {
          console.warn("Unable to obtain serialized value for element \"".concat(id, "\""));
        }
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "deletePath", function (_ref5) {
      var hookID = _ref5.hookID,
          id = _ref5.id,
          path = _ref5.path,
          rendererID = _ref5.rendererID,
          type = _ref5.type;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.deletePath(type, id, hookID, path);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getBackendVersion", function () {
      var version = "4.27.6-7f8c501f6";

      if (version) {
        _this._bridge.send('backendVersion', version);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getBridgeProtocol", function () {
      _this._bridge.send('bridgeProtocol', currentBridgeProtocol);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingData", function (_ref6) {
      var rendererID = _ref6.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      }

      _this._bridge.send('profilingData', renderer.getProfilingData());
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingStatus", function () {
      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getOwnersList", function (_ref7) {
      var id = _ref7.id,
          rendererID = _ref7.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        var owners = renderer.getOwnersList(id);

        _this._bridge.send('ownersList', {
          id: id,
          owners: owners
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "inspectElement", function (_ref8) {
      var forceFullData = _ref8.forceFullData,
          id = _ref8.id,
          path = _ref8.path,
          rendererID = _ref8.rendererID,
          requestID = _ref8.requestID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        _this._bridge.send('inspectedElement', renderer.inspectElement(requestID, id, path, forceFullData)); // When user selects an element, stop trying to restore the selection,
        // and instead remember the current selection for the next reload.


        if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {
          _this._persistedSelection = null;
          _this._persistedSelectionMatch = null;
          renderer.setTrackedPath(null);

          _this._throttledPersistSelection(rendererID, id);
        } // TODO: If there was a way to change the selected DOM element
        // in native Elements tab without forcing a switch to it, we'd do it here.
        // For now, it doesn't seem like there is a way to do that:
        // https://github.com/bvaughn/react-devtools-experimental/issues/102
        // (Setting $0 doesn't work, and calling inspect() switches the tab.)

      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "logElementToConsole", function (_ref9) {
      var id = _ref9.id,
          rendererID = _ref9.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.logElementToConsole(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideError", function (_ref10) {
      var id = _ref10.id,
          rendererID = _ref10.rendererID,
          forceError = _ref10.forceError;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideError(id, forceError);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideSuspense", function (_ref11) {
      var id = _ref11.id,
          rendererID = _ref11.rendererID,
          forceFallback = _ref11.forceFallback;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideSuspense(id, forceFallback);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideValueAtPath", function (_ref12) {
      var hookID = _ref12.hookID,
          id = _ref12.id,
          path = _ref12.path,
          rendererID = _ref12.rendererID,
          type = _ref12.type,
          value = _ref12.value;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideValueAtPath(type, id, hookID, path, value);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideContext", function (_ref13) {
      var id = _ref13.id,
          path = _ref13.path,
          rendererID = _ref13.rendererID,
          wasForwarded = _ref13.wasForwarded,
          value = _ref13.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'context',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideHookState", function (_ref14) {
      var id = _ref14.id,
          hookID = _ref14.hookID,
          path = _ref14.path,
          rendererID = _ref14.rendererID,
          wasForwarded = _ref14.wasForwarded,
          value = _ref14.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'hooks',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideProps", function (_ref15) {
      var id = _ref15.id,
          path = _ref15.path,
          rendererID = _ref15.rendererID,
          wasForwarded = _ref15.wasForwarded,
          value = _ref15.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'props',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideState", function (_ref16) {
      var id = _ref16.id,
          path = _ref16.path,
          rendererID = _ref16.rendererID,
          wasForwarded = _ref16.wasForwarded,
          value = _ref16.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'state',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "reloadAndProfile", function (recordChangeDescriptions) {
      Object(storage["e" /* sessionStorageSetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */], 'true');
      Object(storage["e" /* sessionStorageSetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */], recordChangeDescriptions ? 'true' : 'false'); // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.
      // In that case, the shell must also listen for this specific message to know when it needs to reload the app.
      // The agent can't do this in a way that is renderer agnostic.

      _this._bridge.send('reloadAppForProfiling');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "renamePath", function (_ref17) {
      var hookID = _ref17.hookID,
          id = _ref17.id,
          newPath = _ref17.newPath,
          oldPath = _ref17.oldPath,
          rendererID = _ref17.rendererID,
          type = _ref17.type;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.renamePath(type, id, hookID, oldPath, newPath);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "setTraceUpdatesEnabled", function (traceUpdatesEnabled) {
      _this._traceUpdatesEnabled = traceUpdatesEnabled;
      toggleEnabled(traceUpdatesEnabled);

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "syncSelectionFromNativeElementsPanel", function () {
      var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;

      if (target == null) {
        return;
      }

      _this.selectNode(target);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "shutdown", function () {
      // Clean up the overlay if visible, and associated events.
      _this.emit('shutdown');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "startProfiling", function (recordChangeDescriptions) {
      _this._recordChangeDescriptions = recordChangeDescriptions;
      _this._isProfiling = true;

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.startProfiling(recordChangeDescriptions);
      }

      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "stopProfiling", function () {
      _this._isProfiling = false;
      _this._recordChangeDescriptions = false;

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.stopProfiling();
      }

      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "stopInspectingNative", function (selected) {
      _this._bridge.send('stopInspectingNative', selected);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "storeAsGlobal", function (_ref18) {
      var count = _ref18.count,
          id = _ref18.id,
          path = _ref18.path,
          rendererID = _ref18.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.storeAsGlobal(id, path, count);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "updateConsolePatchSettings", function (_ref19) {
      var appendComponentStack = _ref19.appendComponentStack,
          breakOnConsoleErrors = _ref19.breakOnConsoleErrors,
          showInlineWarningsAndErrors = _ref19.showInlineWarningsAndErrors,
          hideConsoleLogsInStrictMode = _ref19.hideConsoleLogsInStrictMode,
          browserTheme = _ref19.browserTheme;
      // If the frontend preferences have changed,
      // or in the case of React Native- if the backend is just finding out the preferences-
      // then reinstall the console overrides.
      // It's safe to call `patchConsole` multiple times.
      Object(backend_console["b" /* patch */])({
        appendComponentStack: appendComponentStack,
        breakOnConsoleErrors: breakOnConsoleErrors,
        showInlineWarningsAndErrors: showInlineWarningsAndErrors,
        hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,
        browserTheme: browserTheme
      });
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "updateComponentFilters", function (componentFilters) {
      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.updateComponentFilters(componentFilters);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "viewAttributeSource", function (_ref20) {
      var id = _ref20.id,
          path = _ref20.path,
          rendererID = _ref20.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.prepareViewAttributeSource(id, path);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "viewElementSource", function (_ref21) {
      var id = _ref21.id,
          rendererID = _ref21.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.prepareViewElementSource(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onTraceUpdates", function (nodes) {
      _this.emit('traceUpdates', nodes);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onFastRefreshScheduled", function () {
      if (constants["s" /* __DEBUG__ */]) {
        agent_debug('onFastRefreshScheduled');
      }

      _this._bridge.send('fastRefreshScheduled');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onHookOperations", function (operations) {
      if (constants["s" /* __DEBUG__ */]) {
        agent_debug('onHookOperations', "(".concat(operations.length, ") [").concat(operations.join(', '), "]"));
      } // TODO:
      // The chrome.runtime does not currently support transferables; it forces JSON serialization.
      // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134
      //
      // Regarding transferables, the postMessage doc states:
      // If the ownership of an object is transferred, it becomes unusable (neutered)
      // in the context it was sent from and becomes available only to the worker it was sent to.
      //
      // Even though Chrome is eventually JSON serializing the array buffer,
      // using the transferable approach also sometimes causes it to throw:
      //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.
      //
      // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25
      //
      // The Store has a fallback in place that parses the message as JSON if the type isn't an array.
      // For now the simplest fix seems to be to not transfer the array.
      // This will negatively impact performance on Firefox so it's unfortunate,
      // but until we're able to fix the Chrome error mentioned above, it seems necessary.
      //
      // this._bridge.send('operations', operations, [operations.buffer]);


      _this._bridge.send('operations', operations);

      if (_this._persistedSelection !== null) {
        var rendererID = operations[0];

        if (_this._persistedSelection.rendererID === rendererID) {
          // Check if we can select a deeper match for the persisted selection.
          var renderer = _this._rendererInterfaces[rendererID];

          if (renderer == null) {
            console.warn("Invalid renderer id \"".concat(rendererID, "\""));
          } else {
            var prevMatch = _this._persistedSelectionMatch;
            var nextMatch = renderer.getBestMatchForTrackedPath();
            _this._persistedSelectionMatch = nextMatch;
            var prevMatchID = prevMatch !== null ? prevMatch.id : null;
            var nextMatchID = nextMatch !== null ? nextMatch.id : null;

            if (prevMatchID !== nextMatchID) {
              if (nextMatchID !== null) {
                // We moved forward, unlocking a deeper node.
                _this._bridge.send('selectFiber', nextMatchID);
              }
            }

            if (nextMatch !== null && nextMatch.isFullMatch) {
              // We've just unlocked the innermost selected node.
              // There's no point tracking it further.
              _this._persistedSelection = null;
              _this._persistedSelectionMatch = null;
              renderer.setTrackedPath(null);
            }
          }
        }
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "_throttledPersistSelection", lodash_throttle_default()(function (rendererID, id) {
      // This is throttled, so both renderer and selected ID
      // might not be available by the time we read them.
      // This is why we need the defensive checks here.
      var renderer = _this._rendererInterfaces[rendererID];
      var path = renderer != null ? renderer.getPathForElement(id) : null;

      if (path !== null) {
        Object(storage["e" /* sessionStorageSetItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */], JSON.stringify({
          rendererID: rendererID,
          path: path
        }));
      } else {
        Object(storage["d" /* sessionStorageRemoveItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);
      }
    }, 1000));

    if (Object(storage["c" /* sessionStorageGetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {
      _this._recordChangeDescriptions = Object(storage["c" /* sessionStorageGetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true';
      _this._isProfiling = true;
      Object(storage["d" /* sessionStorageRemoveItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]);
      Object(storage["d" /* sessionStorageRemoveItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]);
    }

    var persistedSelectionString = Object(storage["c" /* sessionStorageGetItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);

    if (persistedSelectionString != null) {
      _this._persistedSelection = JSON.parse(persistedSelectionString);
    }

    _this._bridge = bridge;
    bridge.addListener('clearErrorsAndWarnings', _this.clearErrorsAndWarnings);
    bridge.addListener('clearErrorsForFiberID', _this.clearErrorsForFiberID);
    bridge.addListener('clearWarningsForFiberID', _this.clearWarningsForFiberID);
    bridge.addListener('copyElementPath', _this.copyElementPath);
    bridge.addListener('deletePath', _this.deletePath);
    bridge.addListener('getBackendVersion', _this.getBackendVersion);
    bridge.addListener('getBridgeProtocol', _this.getBridgeProtocol);
    bridge.addListener('getProfilingData', _this.getProfilingData);
    bridge.addListener('getProfilingStatus', _this.getProfilingStatus);
    bridge.addListener('getOwnersList', _this.getOwnersList);
    bridge.addListener('inspectElement', _this.inspectElement);
    bridge.addListener('logElementToConsole', _this.logElementToConsole);
    bridge.addListener('overrideError', _this.overrideError);
    bridge.addListener('overrideSuspense', _this.overrideSuspense);
    bridge.addListener('overrideValueAtPath', _this.overrideValueAtPath);
    bridge.addListener('reloadAndProfile', _this.reloadAndProfile);
    bridge.addListener('renamePath', _this.renamePath);
    bridge.addListener('setTraceUpdatesEnabled', _this.setTraceUpdatesEnabled);
    bridge.addListener('startProfiling', _this.startProfiling);
    bridge.addListener('stopProfiling', _this.stopProfiling);
    bridge.addListener('storeAsGlobal', _this.storeAsGlobal);
    bridge.addListener('syncSelectionFromNativeElementsPanel', _this.syncSelectionFromNativeElementsPanel);
    bridge.addListener('shutdown', _this.shutdown);
    bridge.addListener('updateConsolePatchSettings', _this.updateConsolePatchSettings);
    bridge.addListener('updateComponentFilters', _this.updateComponentFilters);
    bridge.addListener('viewAttributeSource', _this.viewAttributeSource);
    bridge.addListener('viewElementSource', _this.viewElementSource); // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    bridge.addListener('overrideContext', _this.overrideContext);
    bridge.addListener('overrideHookState', _this.overrideHookState);
    bridge.addListener('overrideProps', _this.overrideProps);
    bridge.addListener('overrideState', _this.overrideState);

    if (_this._isProfiling) {
      bridge.send('profilingStatus', true);
    } // Send the Bridge protocol and backend versions, after initialization, in case the frontend has already requested it.
    // The Store may be instantiated beore the agent.


    var _version = "4.27.6-7f8c501f6";

    if (_version) {
      _this._bridge.send('backendVersion', _version);
    }

    _this._bridge.send('bridgeProtocol', currentBridgeProtocol); // Notify the frontend if the backend supports the Storage API (e.g. localStorage).
    // If not, features like reload-and-profile will not work correctly and must be disabled.


    var isBackendStorageAPISupported = false;

    try {
      localStorage.getItem('test');
      isBackendStorageAPISupported = true;
    } catch (error) {}

    bridge.send('isBackendStorageAPISupported', isBackendStorageAPISupported);
    bridge.send('isSynchronousXHRSupported', Object(utils["k" /* isSynchronousXHRSupported */])());
    setupHighlighter(bridge, agent_assertThisInitialized(_this));
    TraceUpdates_initialize(agent_assertThisInitialized(_this));
    return _this;
  }

  agent_createClass(Agent, [{
    key: "getInstanceAndStyle",
    value: function getInstanceAndStyle(_ref22) {
      var id = _ref22.id,
          rendererID = _ref22.rendererID;
      var renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
        return null;
      }

      return renderer.getInstanceAndStyle(id);
    }
  }, {
    key: "getBestMatchingRendererInterface",
    value: function getBestMatchingRendererInterface(node) {
      var bestMatch = null;

      for (var rendererID in this._rendererInterfaces) {
        var renderer = this._rendererInterfaces[rendererID];
        var fiber = renderer.getFiberForNative(node);

        if (fiber !== null) {
          // check if fiber.stateNode is matching the original hostInstance
          if (fiber.stateNode === node) {
            return renderer;
          } else if (bestMatch === null) {
            bestMatch = renderer;
          }
        }
      } // if an exact match is not found, return the first valid renderer as fallback


      return bestMatch;
    }
  }, {
    key: "getIDForNode",
    value: function getIDForNode(node) {
      var rendererInterface = this.getBestMatchingRendererInterface(node);

      if (rendererInterface != null) {
        try {
          return rendererInterface.getFiberIDForNative(node, true);
        } catch (error) {// Some old React versions might throw if they can't find a match.
          // If so we should ignore it...
        }
      }

      return null;
    }
  }, {
    key: "selectNode",
    value: function selectNode(target) {
      var id = this.getIDForNode(target);

      if (id !== null) {
        this._bridge.send('selectFiber', id);
      }
    }
  }, {
    key: "setRendererInterface",
    value: function setRendererInterface(rendererID, rendererInterface) {
      this._rendererInterfaces[rendererID] = rendererInterface;

      if (this._isProfiling) {
        rendererInterface.startProfiling(this._recordChangeDescriptions);
      }

      rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether
      // we remember the previous selection that we'd like to restore.
      // It'll start tracking mounts for matches to the last selection path.

      var selection = this._persistedSelection;

      if (selection !== null && selection.rendererID === rendererID) {
        rendererInterface.setTrackedPath(selection.path);
      }
    }
  }, {
    key: "onUnsupportedRenderer",
    value: function onUnsupportedRenderer(rendererID) {
      this._bridge.send('unsupportedRendererVersion', rendererID);
    }
  }, {
    key: "rendererInterfaces",
    get: function get() {
      return this._rendererInterfaces;
    }
  }]);

  return Agent;
}(EventEmitter);


// CONCATENATED MODULE: ../react-devtools-shared/src/hook.js
function hook_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { hook_typeof = function _typeof(obj) { return typeof obj; }; } else { hook_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return hook_typeof(obj); }

function hook_toConsumableArray(arr) { return hook_arrayWithoutHoles(arr) || hook_iterableToArray(arr) || hook_unsupportedIterableToArray(arr) || hook_nonIterableSpread(); }

function hook_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hook_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return hook_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hook_arrayLikeToArray(o, minLen); }

function hook_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function hook_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return hook_arrayLikeToArray(arr); }

function hook_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Install the hook on window, which is an event emitter.
 * Note: this global hook __REACT_DEVTOOLS_GLOBAL_HOOK__ is a de facto public API.
 * It's especially important to avoid creating direct dependency on the DevTools Backend.
 * That's why we still inline the whole event emitter implementation,
 * the string format implementation, and part of the console implementation here.
 *
 * 
 */
function installHook(target) {
  if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {
    return null;
  }

  var targetConsole = console;
  var targetConsoleMethods = {};

  for (var method in console) {
    targetConsoleMethods[method] = console[method];
  }

  function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {
    targetConsole = targetConsoleForTesting;
    targetConsoleMethods = {};

    for (var _method in targetConsole) {
      targetConsoleMethods[_method] = console[_method];
    }
  }

  function detectReactBuildType(renderer) {
    try {
      if (typeof renderer.version === 'string') {
        // React DOM Fiber (16+)
        if (renderer.bundleType > 0) {
          // This is not a production build.
          // We are currently only using 0 (PROD) and 1 (DEV)
          // but might add 2 (PROFILE) in the future.
          return 'development';
        } // React 16 uses flat bundles. If we report the bundle as production
        // version, it means we also minified and envified it ourselves.


        return 'production'; // Note: There is still a risk that the CommonJS entry point has not
        // been envified or uglified. In this case the user would have *both*
        // development and production bundle, but only the prod one would run.
        // This would be really bad. We have a separate check for this because
        // it happens *outside* of the renderer injection. See `checkDCE` below.
      } // $FlowFixMe[method-unbinding]


      var _toString = Function.prototype.toString;

      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
        // React DOM Stack
        var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):


        if (renderRootCode.indexOf('function') !== 0) {
          // Hope for the best if we're not sure.
          return 'production';
        } // Check for React DOM Stack < 15.1.0 in development.
        // If it contains "storedMeasure" call, it's wrapped in ReactPerf (DEV only).
        // This would be true even if it's minified, as method name still matches.


        if (renderRootCode.indexOf('storedMeasure') !== -1) {
          return 'development';
        } // For other versions (and configurations) it's not so easy.
        // Let's quickly exclude proper production builds.
        // If it contains a warning message, it's either a DEV build,
        // or an PROD build without proper dead code elimination.


        if (renderRootCode.indexOf('should be a pure function') !== -1) {
          // Now how do we tell a DEV build from a bad PROD build?
          // If we see NODE_ENV, we're going to assume this is a dev build
          // because most likely it is referring to an empty shim.
          if (renderRootCode.indexOf('NODE_ENV') !== -1) {
            return 'development';
          } // If we see "development", we're dealing with an envified DEV build
          // (such as the official React DEV UMD).


          if (renderRootCode.indexOf('development') !== -1) {
            return 'development';
          } // I've seen process.env.NODE_ENV !== 'production' being smartly
          // replaced by `true` in DEV by Webpack. I don't know how that
          // works but we can safely guard against it because `true` was
          // never used in the function source since it was written.


          if (renderRootCode.indexOf('true') !== -1) {
            return 'development';
          } // By now either it is a production build that has not been minified,
          // or (worse) this is a minified development build using non-standard
          // environment (e.g. "staging"). We're going to look at whether
          // the function argument name is mangled:


          if ( // 0.13 to 15
          renderRootCode.indexOf('nextElement') !== -1 || // 0.12
          renderRootCode.indexOf('nextComponent') !== -1) {
            // We can't be certain whether this is a development build or not,
            // but it is definitely unminified.
            return 'unminified';
          } else {
            // This is likely a minified development build.
            return 'development';
          }
        } // By now we know that it's envified and dead code elimination worked,
        // but what if it's still not minified? (Is this even possible?)
        // Let's check matches for the first argument name.


        if ( // 0.13 to 15
        renderRootCode.indexOf('nextElement') !== -1 || // 0.12
        renderRootCode.indexOf('nextComponent') !== -1) {
          return 'unminified';
        } // Seems like we're using the production version.
        // However, the branch above is Stack-only so this is 15 or earlier.


        return 'outdated';
      }
    } catch (err) {// Weird environments may exist.
      // This code needs a higher fault tolerance
      // because it runs even with closed DevTools.
      // TODO: should we catch errors in all injected code, and not just this part?
    }

    return 'production';
  }

  function checkDCE(fn) {
    // This runs for production versions of React.
    // Needs to be super safe.
    try {
      // $FlowFixMe[method-unbinding]
      var _toString2 = Function.prototype.toString;

      var code = _toString2.call(fn); // This is a string embedded in the passed function under DEV-only
      // condition. However the function executes only in PROD. Therefore,
      // if we see it, dead code elimination did not work.


      if (code.indexOf('^_^') > -1) {
        // Remember to report during next injection.
        hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.
        // Not synchronously so that it doesn't break the calling code.

        setTimeout(function () {
          throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://reactjs.org/link/perf-use-production-build');
        });
      }
    } catch (err) {}
  } // NOTE: KEEP IN SYNC with src/backend/utils.js


  function formatWithStyles(inputArgs, style) {
    if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c
    typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {
      return inputArgs;
    } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)


    var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;

    if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {
      return ["%c".concat(inputArgs[0]), style].concat(hook_toConsumableArray(inputArgs.slice(1)));
    } else {
      var firstArg = inputArgs.reduce(function (formatStr, elem, i) {
        if (i > 0) {
          formatStr += ' ';
        }

        switch (hook_typeof(elem)) {
          case 'string':
          case 'boolean':
          case 'symbol':
            return formatStr += '%s';

          case 'number':
            var formatting = Number.isInteger(elem) ? '%i' : '%f';
            return formatStr += formatting;

          default:
            return formatStr += '%o';
        }
      }, '%c');
      return [firstArg, style].concat(hook_toConsumableArray(inputArgs));
    }
  }

  var unpatchFn = null; // NOTE: KEEP IN SYNC with src/backend/console.js:patchForStrictMode
  // This function hides or dims console logs during the initial double renderer
  // in Strict Mode. We need this function because during initial render,
  // React and DevTools are connecting and the renderer interface isn't avaiable
  // and we want to be able to have consistent logging behavior for double logs
  // during the initial renderer.

  function patchConsoleForInitialRenderInStrictMode(_ref) {
    var hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,
        browserTheme = _ref.browserTheme;
    var overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];

    if (unpatchFn !== null) {
      // Don't patch twice.
      return;
    }

    var originalConsoleMethods = {};

    unpatchFn = function unpatchFn() {
      for (var _method2 in originalConsoleMethods) {
        try {
          targetConsole[_method2] = originalConsoleMethods[_method2];
        } catch (error) {}
      }
    };

    overrideConsoleMethods.forEach(function (method) {
      try {
        var originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method];

        var overrideMethod = function overrideMethod() {
          if (!hideConsoleLogsInStrictMode) {
            // Dim the text color of the double logs if we're not
            // hiding them.
            var color;

            switch (method) {
              case 'warn':
                color = browserTheme === 'light' ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";
                break;

              case 'error':
                color = browserTheme === 'light' ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";
                break;

              case 'log':
              default:
                color = browserTheme === 'light' ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)";
                break;
            }

            if (color) {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              originalMethod.apply(void 0, hook_toConsumableArray(formatWithStyles(args, "color: ".concat(color))));
            } else {
              throw Error('Console color is not defined');
            }
          }
        };

        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;
        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;
        targetConsole[method] = overrideMethod;
      } catch (error) {}
    });
  } // NOTE: KEEP IN SYNC with src/backend/console.js:unpatchForStrictMode


  function unpatchConsoleForInitialRenderInStrictMode() {
    if (unpatchFn !== null) {
      unpatchFn();
      unpatchFn = null;
    }
  }

  var uidCounter = 0;

  function inject(renderer) {
    var id = ++uidCounter;
    renderers.set(id, renderer);
    var reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer); // Patching the console enables DevTools to do a few useful things:
    // * Append component stacks to warnings and error messages
    // * Disabling or marking logs during a double render in Strict Mode
    // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)
    //
    // Allow patching console early (during injection) to
    // provide developers with components stacks even if they don't run DevTools.

    if (target.hasOwnProperty('__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__')) {
      var _target$__REACT_DEVTO = target.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__,
          registerRendererWithConsole = _target$__REACT_DEVTO.registerRendererWithConsole,
          patchConsoleUsingWindowValues = _target$__REACT_DEVTO.patchConsoleUsingWindowValues;

      if (typeof registerRendererWithConsole === 'function' && typeof patchConsoleUsingWindowValues === 'function') {
        registerRendererWithConsole(renderer);
        patchConsoleUsingWindowValues();
      }
    } // If we have just reloaded to profile, we need to inject the renderer interface before the app loads.
    // Otherwise the renderer won't yet exist and we can skip this step.


    var attach = target.__REACT_DEVTOOLS_ATTACH__;

    if (typeof attach === 'function') {
      var rendererInterface = attach(hook, id, renderer, target);
      hook.rendererInterfaces.set(id, rendererInterface);
    }

    hook.emit('renderer', {
      id: id,
      renderer: renderer,
      reactBuildType: reactBuildType
    });
    return id;
  }

  var hasDetectedBadDCE = false;

  function sub(event, fn) {
    hook.on(event, fn);
    return function () {
      return hook.off(event, fn);
    };
  }

  function on(event, fn) {
    if (!listeners[event]) {
      listeners[event] = [];
    }

    listeners[event].push(fn);
  }

  function off(event, fn) {
    if (!listeners[event]) {
      return;
    }

    var index = listeners[event].indexOf(fn);

    if (index !== -1) {
      listeners[event].splice(index, 1);
    }

    if (!listeners[event].length) {
      delete listeners[event];
    }
  }

  function emit(event, data) {
    if (listeners[event]) {
      listeners[event].map(function (fn) {
        return fn(data);
      });
    }
  }

  function getFiberRoots(rendererID) {
    var roots = fiberRoots;

    if (!roots[rendererID]) {
      roots[rendererID] = new Set();
    }

    return roots[rendererID];
  }

  function onCommitFiberUnmount(rendererID, fiber) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberUnmount(fiber);
    }
  }

  function onCommitFiberRoot(rendererID, root, priorityLevel) {
    var mountedRoots = hook.getFiberRoots(rendererID);
    var current = root.current;
    var isKnownRoot = mountedRoots.has(root);
    var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.

    if (!isKnownRoot && !isUnmounting) {
      mountedRoots.add(root);
    } else if (isKnownRoot && isUnmounting) {
      mountedRoots.delete(root);
    }

    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberRoot(root, priorityLevel);
    }
  }

  function onPostCommitFiberRoot(rendererID, root) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handlePostCommitFiberRoot(root);
    }
  }

  function setStrictMode(rendererID, isStrictMode) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      if (isStrictMode) {
        rendererInterface.patchConsoleForStrictMode();
      } else {
        rendererInterface.unpatchConsoleForStrictMode();
      }
    } else {
      // This should only happen during initial render in the extension before DevTools
      // finishes its handshake with the injected renderer
      if (isStrictMode) {
        var hideConsoleLogsInStrictMode = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === true;
        var browserTheme = window.__REACT_DEVTOOLS_BROWSER_THEME__;
        patchConsoleForInitialRenderInStrictMode({
          hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,
          browserTheme: browserTheme
        });
      } else {
        unpatchConsoleForInitialRenderInStrictMode();
      }
    }
  }

  var openModuleRangesStack = [];
  var moduleRanges = [];

  function getTopStackFrameString(error) {
    var frames = error.stack.split('\n');
    var frame = frames.length > 1 ? frames[1] : null;
    return frame;
  }

  function getInternalModuleRanges() {
    return moduleRanges;
  }

  function registerInternalModuleStart(error) {
    var startStackFrame = getTopStackFrameString(error);

    if (startStackFrame !== null) {
      openModuleRangesStack.push(startStackFrame);
    }
  }

  function registerInternalModuleStop(error) {
    if (openModuleRangesStack.length > 0) {
      var startStackFrame = openModuleRangesStack.pop();
      var stopStackFrame = getTopStackFrameString(error);

      if (stopStackFrame !== null) {
        moduleRanges.push([startStackFrame, stopStackFrame]);
      }
    }
  } // TODO: More meaningful names for "rendererInterfaces" and "renderers".


  var fiberRoots = {};
  var rendererInterfaces = new Map();
  var listeners = {};
  var renderers = new Map();
  var backends = new Map();
  var hook = {
    rendererInterfaces: rendererInterfaces,
    listeners: listeners,
    backends: backends,
    // Fast Refresh for web relies on this.
    renderers: renderers,
    emit: emit,
    getFiberRoots: getFiberRoots,
    inject: inject,
    on: on,
    off: off,
    sub: sub,
    // This is a legacy flag.
    // React v16 checks the hook for this to ensure DevTools is new enough.
    supportsFiber: true,
    // React calls these methods.
    checkDCE: checkDCE,
    onCommitFiberUnmount: onCommitFiberUnmount,
    onCommitFiberRoot: onCommitFiberRoot,
    onPostCommitFiberRoot: onPostCommitFiberRoot,
    setStrictMode: setStrictMode,
    // Schedule Profiler runtime helpers.
    // These internal React modules to report their own boundaries
    // which in turn enables the profiler to dim or filter internal frames.
    getInternalModuleRanges: getInternalModuleRanges,
    registerInternalModuleStart: registerInternalModuleStart,
    registerInternalModuleStop: registerInternalModuleStop
  };

  if (false) {}

  Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {
    // This property needs to be configurable for the test environment,
    // else we won't be able to delete and recreate it between tests.
    configurable: false,
    enumerable: false,
    get: function get() {
      return hook;
    }
  });
  return hook;
}
// EXTERNAL MODULE: ../react-devtools-shared/src/backend/renderer.js + 6 modules
var backend_renderer = __webpack_require__(13);

// EXTERNAL MODULE: ../react-devtools-shared/src/types.js
var types = __webpack_require__(1);

// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js
var src_utils = __webpack_require__(0);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/utils.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function decorate(object, attr, fn) {
  var old = object[attr]; // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations

  object[attr] = function (instance) {
    return fn.call(this, old, arguments);
  };

  return old;
}
function decorateMany(source, fns) {
  var olds = {};

  for (var name in fns) {
    olds[name] = decorate(source, name, fns[name]);
  }

  return olds;
}
function restoreMany(source, olds) {
  for (var name in olds) {
    source[name] = olds[name];
  }
} // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations

function forceUpdate(instance) {
  if (typeof instance.forceUpdate === 'function') {
    instance.forceUpdate();
  } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {
    instance.updater.enqueueForceUpdate(this, function () {}, 'forceUpdate');
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/renderer.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function renderer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return renderer_typeof(obj); }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function getData(internalInstance) {
  var displayName = null;
  var key = null; // != used deliberately here to catch undefined and null

  if (internalInstance._currentElement != null) {
    if (internalInstance._currentElement.key) {
      key = String(internalInstance._currentElement.key);
    }

    var elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'string') {
      displayName = elementType;
    } else if (typeof elementType === 'function') {
      displayName = Object(src_utils["h" /* getDisplayName */])(elementType);
    }
  }

  return {
    displayName: displayName,
    key: key
  };
}

function getElementType(internalInstance) {
  // != used deliberately here to catch undefined and null
  if (internalInstance._currentElement != null) {
    var elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'function') {
      var publicInstance = internalInstance.getPublicInstance();

      if (publicInstance !== null) {
        return types["e" /* ElementTypeClass */];
      } else {
        return types["h" /* ElementTypeFunction */];
      }
    } else if (typeof elementType === 'string') {
      return types["i" /* ElementTypeHostComponent */];
    }
  }

  return types["k" /* ElementTypeOtherOrUnknown */];
}

function getChildren(internalInstance) {
  var children = []; // If the parent is a native node without rendered children, but with
  // multiple string children, then the `element` that gets passed in here is
  // a plain value -- a string or number.

  if (renderer_typeof(internalInstance) !== 'object') {// No children
  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children
  } else if (internalInstance._renderedComponent) {
    var child = internalInstance._renderedComponent;

    if (getElementType(child) !== types["k" /* ElementTypeOtherOrUnknown */]) {
      children.push(child);
    }
  } else if (internalInstance._renderedChildren) {
    var renderedChildren = internalInstance._renderedChildren;

    for (var name in renderedChildren) {
      var _child = renderedChildren[name];

      if (getElementType(_child) !== types["k" /* ElementTypeOtherOrUnknown */]) {
        children.push(_child);
      }
    }
  } // Note: we skip the case where children are just strings or numbers
  // because the new DevTools skips over host text nodes anyway.


  return children;
}

function attach(hook, rendererID, renderer, global) {
  var idToInternalInstanceMap = new Map();
  var internalInstanceToIDMap = new WeakMap();
  var internalInstanceToRootIDMap = new WeakMap();
  var getInternalIDForNative = null;
  var findNativeNodeForInternalID;

  var getFiberForNative = function getFiberForNative(node) {
    // Not implemented.
    return null;
  };

  if (renderer.ComponentTree) {
    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {
      var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);
      return internalInstanceToIDMap.get(internalInstance) || null;
    };

    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {
      var internalInstance = idToInternalInstanceMap.get(id);
      return renderer.ComponentTree.getNodeFromInstance(internalInstance);
    };

    getFiberForNative = function getFiberForNative(node) {
      return renderer.ComponentTree.getClosestInstanceFromNode(node);
    };
  } else if (renderer.Mount.getID && renderer.Mount.getNode) {
    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {
      // Not implemented.
      return null;
    };

    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {
      // Not implemented.
      return null;
    };
  }

  function getDisplayNameForFiberID(id) {
    var internalInstance = idToInternalInstanceMap.get(id);
    return internalInstance ? getData(internalInstance).displayName : null;
  }

  function getID(internalInstance) {
    if (renderer_typeof(internalInstance) !== 'object' || internalInstance === null) {
      throw new Error('Invalid internal instance: ' + internalInstance);
    }

    if (!internalInstanceToIDMap.has(internalInstance)) {
      var _id = Object(src_utils["k" /* getUID */])();

      internalInstanceToIDMap.set(internalInstance, _id);
      idToInternalInstanceMap.set(_id, internalInstance);
    }

    return internalInstanceToIDMap.get(internalInstance);
  }

  function areEqualArrays(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  } // This is shared mutable state that lets us keep track of where we are.


  var parentIDStack = [];
  var oldReconcilerMethods = null;

  if (renderer.Reconciler) {
    // React 15
    oldReconcilerMethods = decorateMany(renderer.Reconciler, {
      mountComponent: function mountComponent(fn, args) {
        var internalInstance = args[0];
        var hostContainerInfo = args[3];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        if (hostContainerInfo._topLevelWrapper === undefined) {
          // SSR
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance); // Push the operation.

        var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;
        recordMount(internalInstance, id, parentID);
        parentIDStack.push(id); // Remember the root.

        internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          parentIDStack.pop();
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);
        var prevChildren = getChildren(internalInstance);

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          var nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      receiveComponent: function receiveComponent(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);
        var prevChildren = getChildren(internalInstance);

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          var nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      unmountComponent: function unmountComponent(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);

        try {
          // $FlowFixMe[object-this-reference] found when upgrading Flow
          var result = fn.apply(this, args);
          parentIDStack.pop(); // Push the operation.

          recordUnmount(internalInstance, id);
          return result;
        } catch (err) {
          // $FlowFixMe[incompatible-type] found when upgrading Flow
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      }
    });
  }

  function cleanup() {
    if (oldReconcilerMethods !== null) {
      if (renderer.Component) {
        restoreMany(renderer.Component.Mixin, oldReconcilerMethods);
      } else {
        restoreMany(renderer.Reconciler, oldReconcilerMethods);
      }
    }

    oldReconcilerMethods = null;
  }

  function recordMount(internalInstance, id, parentID) {
    var isRoot = parentID === 0;

    if (constants["s" /* __DEBUG__ */]) {
      console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);
    }

    if (isRoot) {
      // TODO Is this right? For all versions?
      var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(types["m" /* ElementTypeRoot */]);
      pushOperation(0); // StrictMode compliant?

      pushOperation(0); // Profiling flag

      pushOperation(0); // StrictMode supported?

      pushOperation(hasOwnerMetadata ? 1 : 0);
    } else {
      var type = getElementType(internalInstance);

      var _getData = getData(internalInstance),
          displayName = _getData.displayName,
          key = _getData.key;

      var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;
      var displayNameStringID = getStringID(displayName);
      var keyStringID = getStringID(key);
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(type);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID);
    }
  }

  function recordReorder(internalInstance, id, nextChildren) {
    pushOperation(constants["o" /* TREE_OPERATION_REORDER_CHILDREN */]);
    pushOperation(id);
    var nextChildIDs = nextChildren.map(getID);
    pushOperation(nextChildIDs.length);

    for (var i = 0; i < nextChildIDs.length; i++) {
      pushOperation(nextChildIDs[i]);
    }
  }

  function recordUnmount(internalInstance, id) {
    pendingUnmountedIDs.push(id);
    idToInternalInstanceMap.delete(id);
  }

  function crawlAndRecordInitialMounts(id, parentID, rootID) {
    if (constants["s" /* __DEBUG__ */]) {
      console.group('crawlAndRecordInitialMounts() id:', id);
    }

    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      internalInstanceToRootIDMap.set(internalInstance, rootID);
      recordMount(internalInstance, id, parentID);
      getChildren(internalInstance).forEach(function (child) {
        return crawlAndRecordInitialMounts(getID(child), id, rootID);
      });
    }

    if (constants["s" /* __DEBUG__ */]) {
      console.groupEnd();
    }
  }

  function flushInitialOperations() {
    // Crawl roots though and register any nodes that mounted before we were injected.
    var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;

    for (var key in roots) {
      var internalInstance = roots[key];

      var _id2 = getID(internalInstance);

      crawlAndRecordInitialMounts(_id2, 0, _id2);
      flushPendingEvents(_id2);
    }
  }

  var pendingOperations = [];
  var pendingStringTable = new Map();
  var pendingUnmountedIDs = [];
  var pendingStringTableLength = 0;
  var pendingUnmountedRootID = null;

  function flushPendingEvents(rootID) {
    if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
      return;
    }

    var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    var operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber properations, states, and hooks to be inspected.

    var i = 0;
    operations[i++] = rendererID;
    operations[i++] = rootID; // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach(function (value, key) {
      operations[i++] = key.length;
      var encodedKey = Object(src_utils["p" /* utfEncodeString */])(key);

      for (var j = 0; j < encodedKey.length; j++) {
        operations[i + j] = encodedKey[j];
      }

      i += key.length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = constants["m" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the unmounts

      for (var j = 0; j < pendingUnmountedIDs.length; j++) {
        operations[i++] = pendingUnmountedIDs[j];
      } // The root ID should always be unmounted last.


      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (var _j = 0; _j < pendingOperations.length; _j++) {
      operations[i + _j] = pendingOperations[_j];
    }

    i += pendingOperations.length;

    if (constants["s" /* __DEBUG__ */]) {
      Object(src_utils["m" /* printOperationsArray */])(operations);
    } // If we've already connected to the frontend, just pass the operations through.


    hook.emit('operations', operations);
    pendingOperations.length = 0;
    pendingUnmountedIDs = [];
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function getStringID(str) {
    if (str === null) {
      return 0;
    }

    var existingID = pendingStringTable.get(str);

    if (existingID !== undefined) {
      return existingID;
    }

    var stringID = pendingStringTable.size + 1;
    pendingStringTable.set(str, stringID); // The string table total length needs to account
    // both for the string length, and for the array item
    // that contains the length itself. Hence + 1.

    pendingStringTableLength += str.length + 1;
    return stringID;
  }

  var currentlyInspectedElementID = null;
  var currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.

  function mergeInspectedPaths(path) {
    var current = currentlyInspectedPaths;
    path.forEach(function (key) {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      var current = currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (var i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  } // Fast path props lookup for React Native style editor.


  function getInstanceAndStyle(id) {
    var instance = null;
    var style = null;
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      instance = internalInstance._instance || null;
      var element = internalInstance._currentElement;

      if (element != null && element.props != null) {
        style = element.props.style || null;
      }
    }

    return {
      instance: instance,
      style: style
    };
  }

  function updateSelectedElement(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn("Could not find instance with id \"".concat(id, "\""));
      return;
    }

    switch (getElementType(internalInstance)) {
      case types["e" /* ElementTypeClass */]:
        global.$r = internalInstance._instance;
        break;

      case types["h" /* ElementTypeFunction */]:
        var element = internalInstance._currentElement;

        if (element == null) {
          console.warn("Could not find element with id \"".concat(id, "\""));
          return;
        }

        global.$r = {
          props: element.props,
          type: element.type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      var value = Object(src_utils["j" /* getInObject */])(inspectedElement, path);
      var key = "$reactTemp".concat(count);
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function getSerializedElementValueByPath(id, path) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      var valueToCopy = Object(src_utils["j" /* getInObject */])(inspectedElement, path);
      return Object(utils["l" /* serializeToString */])(valueToCopy);
    }
  }

  function inspectElement(requestID, id, path, forceFullData) {
    if (forceFullData || currentlyInspectedElementID !== id) {
      currentlyInspectedElementID = id;
      currentlyInspectedPaths = {};
    }

    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement === null) {
      return {
        id: id,
        responseID: requestID,
        type: 'not-found'
      };
    }

    if (path !== null) {
      mergeInspectedPaths(path);
    } // Any time an inspected element has an update,
    // we should update the selected $r value as wel.
    // Do this before dehydration (cleanForBridge).


    updateSelectedElement(id);
    inspectedElement.context = Object(utils["a" /* cleanForBridge */])(inspectedElement.context, createIsPathAllowed('context'));
    inspectedElement.props = Object(utils["a" /* cleanForBridge */])(inspectedElement.props, createIsPathAllowed('props'));
    inspectedElement.state = Object(utils["a" /* cleanForBridge */])(inspectedElement.state, createIsPathAllowed('state'));
    return {
      id: id,
      responseID: requestID,
      type: 'full-data',
      value: inspectedElement
    };
  }

  function inspectElementRaw(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      return null;
    }

    var _getData2 = getData(internalInstance),
        displayName = _getData2.displayName,
        key = _getData2.key;

    var type = getElementType(internalInstance);
    var context = null;
    var owners = null;
    var props = null;
    var state = null;
    var source = null;
    var element = internalInstance._currentElement;

    if (element !== null) {
      props = element.props;
      source = element._source != null ? element._source : null;
      var owner = element._owner;

      if (owner) {
        owners = [];

        while (owner != null) {
          owners.push({
            displayName: getData(owner).displayName || 'Unknown',
            id: getID(owner),
            key: element.key,
            type: getElementType(owner)
          });

          if (owner._currentElement) {
            owner = owner._currentElement._owner;
          }
        }
      }
    }

    var publicInstance = internalInstance._instance;

    if (publicInstance != null) {
      context = publicInstance.context || null;
      state = publicInstance.state || null;
    } // Not implemented


    var errors = [];
    var warnings = [];
    return {
      id: id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: false,
      canEditFunctionProps: false,
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: false,
      canEditHooksAndRenamePaths: false,
      canEditFunctionPropsDeletePaths: false,
      canEditFunctionPropsRenamePaths: false,
      // Toggle error boundary did not exist in legacy versions
      canToggleError: false,
      isErrored: false,
      targetErrorBoundaryID: null,
      // Suspense did not exist in legacy versions
      canToggleSuspense: false,
      // Can view component source location.
      canViewSource: type === types["e" /* ElementTypeClass */] || type === types["h" /* ElementTypeFunction */],
      // Only legacy context exists in legacy versions.
      hasLegacyContext: true,
      displayName: displayName,
      type: type,
      key: key != null ? key : null,
      // Inspectable properties.
      context: context,
      hooks: null,
      props: props,
      state: state,
      errors: errors,
      warnings: warnings,
      // List of owners
      owners: owners,
      // Location of component in source code.
      source: source,
      rootType: null,
      rendererPackageName: null,
      rendererVersion: null,
      plugins: {
        stylex: null
      }
    };
  }

  function logElementToConsole(id) {
    var result = inspectElementRaw(id);

    if (result === null) {
      console.warn("Could not find element with id \"".concat(id, "\""));
      return;
    }

    var supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed("[Click to expand] %c<".concat(result.displayName || 'Component', " />"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.context !== null) {
      console.log('Context:', result.context);
    }

    var nativeNode = findNativeNodeForInternalID(id);

    if (nativeNode !== null) {
      console.log('Node:', nativeNode);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function prepareViewAttributeSource(id, path) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      window.$attribute = Object(src_utils["j" /* getInObject */])(inspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn("Could not find instance with id \"".concat(id, "\""));
      return;
    }

    var element = internalInstance._currentElement;

    if (element == null) {
      console.warn("Could not find element with id \"".concat(id, "\""));
      return;
    }

    global.$type = element.type;
  }

  function deletePath(type, id, hookID, path) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(src_utils["c" /* deletePathInObject */])(publicInstance.context, path);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {
              props: Object(utils["b" /* copyWithDelete */])(element.props, path)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(src_utils["c" /* deletePathInObject */])(publicInstance.state, path);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(src_utils["n" /* renamePathInObject */])(publicInstance.context, oldPath, newPath);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {
              props: Object(utils["c" /* copyWithRename */])(element.props, oldPath, newPath)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(src_utils["n" /* renamePathInObject */])(publicInstance.state, oldPath, newPath);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(src_utils["o" /* setInObject */])(publicInstance.context, path, value);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {
              props: Object(utils["d" /* copyWithSet */])(element.props, path, value)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(src_utils["o" /* setInObject */])(publicInstance.state, path, value);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  } // v16+ only features


  var getProfilingData = function getProfilingData() {
    throw new Error('getProfilingData not supported by this renderer');
  };

  var handleCommitFiberRoot = function handleCommitFiberRoot() {
    throw new Error('handleCommitFiberRoot not supported by this renderer');
  };

  var handleCommitFiberUnmount = function handleCommitFiberUnmount() {
    throw new Error('handleCommitFiberUnmount not supported by this renderer');
  };

  var handlePostCommitFiberRoot = function handlePostCommitFiberRoot() {
    throw new Error('handlePostCommitFiberRoot not supported by this renderer');
  };

  var overrideError = function overrideError() {
    throw new Error('overrideError not supported by this renderer');
  };

  var overrideSuspense = function overrideSuspense() {
    throw new Error('overrideSuspense not supported by this renderer');
  };

  var startProfiling = function startProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  var stopProfiling = function stopProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  function getBestMatchForTrackedPath() {
    // Not implemented.
    return null;
  }

  function getPathForElement(id) {
    // Not implemented.
    return null;
  }

  function updateComponentFilters(componentFilters) {// Not implemented.
  }

  function setTraceUpdatesEnabled(enabled) {// Not implemented.
  }

  function setTrackedPath(path) {// Not implemented.
  }

  function getOwnersList(id) {
    // Not implemented.
    return null;
  }

  function clearErrorsAndWarnings() {// Not implemented
  }

  function clearErrorsForFiberID(id) {// Not implemented
  }

  function clearWarningsForFiberID(id) {// Not implemented
  }

  function patchConsoleForStrictMode() {}

  function unpatchConsoleForStrictMode() {}

  return {
    clearErrorsAndWarnings: clearErrorsAndWarnings,
    clearErrorsForFiberID: clearErrorsForFiberID,
    clearWarningsForFiberID: clearWarningsForFiberID,
    cleanup: cleanup,
    getSerializedElementValueByPath: getSerializedElementValueByPath,
    deletePath: deletePath,
    flushInitialOperations: flushInitialOperations,
    getBestMatchForTrackedPath: getBestMatchForTrackedPath,
    getDisplayNameForFiberID: getDisplayNameForFiberID,
    getFiberForNative: getFiberForNative,
    getFiberIDForNative: getInternalIDForNative,
    getInstanceAndStyle: getInstanceAndStyle,
    findNativeNodesForFiberID: function findNativeNodesForFiberID(id) {
      var nativeNode = findNativeNodeForInternalID(id);
      return nativeNode == null ? null : [nativeNode];
    },
    getOwnersList: getOwnersList,
    getPathForElement: getPathForElement,
    getProfilingData: getProfilingData,
    handleCommitFiberRoot: handleCommitFiberRoot,
    handleCommitFiberUnmount: handleCommitFiberUnmount,
    handlePostCommitFiberRoot: handlePostCommitFiberRoot,
    inspectElement: inspectElement,
    logElementToConsole: logElementToConsole,
    overrideError: overrideError,
    overrideSuspense: overrideSuspense,
    overrideValueAtPath: overrideValueAtPath,
    renamePath: renamePath,
    patchConsoleForStrictMode: patchConsoleForStrictMode,
    prepareViewAttributeSource: prepareViewAttributeSource,
    prepareViewElementSource: prepareViewElementSource,
    renderer: renderer,
    setTraceUpdatesEnabled: setTraceUpdatesEnabled,
    setTrackedPath: setTrackedPath,
    startProfiling: startProfiling,
    stopProfiling: stopProfiling,
    storeAsGlobal: storeAsGlobal,
    unpatchConsoleForStrictMode: unpatchConsoleForStrictMode,
    updateComponentFilters: updateComponentFilters
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/index.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





// this is the backend that is compactible with all older React versions
function isMatchingRender(version) {
  return !Object(utils["j" /* hasAssignedBackend */])(version);
}

function initBackend(hook, agent, global) {
  if (hook == null) {
    // DevTools didn't get injected into this page (maybe b'c of the contentType).
    return function () {};
  }

  var subs = [hook.sub('renderer-attached', function (_ref) {
    var id = _ref.id,
        renderer = _ref.renderer,
        rendererInterface = _ref.rendererInterface;
    agent.setRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,
    // it's time to flush the pending operation codes to the frontend.

    rendererInterface.flushInitialOperations();
  }), hook.sub('unsupported-renderer-version', function (id) {
    agent.onUnsupportedRenderer(id);
  }), hook.sub('fastRefreshScheduled', agent.onFastRefreshScheduled), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates) // TODO Add additional subscriptions required for profiling mode
  ];

  var attachRenderer = function attachRenderer(id, renderer) {
    // skip if already attached
    if (renderer.attached) {
      return;
    } // only attach if the renderer is compatible with the current version of the backend


    if (!isMatchingRender(renderer.reconcilerVersion || renderer.version)) {
      return;
    }

    var rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)

    if (rendererInterface == null) {
      if (typeof renderer.findFiberByHostInstance === 'function') {
        // react-reconciler v16+
        rendererInterface = Object(backend_renderer["a" /* attach */])(hook, id, renderer, global);
      } else if (renderer.ComponentTree) {
        // react-dom v15
        rendererInterface = attach(hook, id, renderer, global);
      } else {// Older react-dom or other unsupported renderer version
      }

      if (rendererInterface != null) {
        hook.rendererInterfaces.set(id, rendererInterface);
      }
    } // Notify the DevTools frontend about new renderers.
    // This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).


    if (rendererInterface != null) {
      hook.emit('renderer-attached', {
        id: id,
        renderer: renderer,
        rendererInterface: rendererInterface
      });
    } else {
      hook.emit('unsupported-renderer-version', id);
    }

    renderer.attached = true;
  }; // Connect renderers that have already injected themselves.


  hook.renderers.forEach(function (renderer, id) {
    attachRenderer(id, renderer);
  }); // Connect any new renderers that injected themselves.

  subs.push(hook.sub('renderer', function (_ref2) {
    var id = _ref2.id,
        renderer = _ref2.renderer;
    attachRenderer(id, renderer);
  }));
  hook.emit('react-devtools', agent);
  hook.reactDevtoolsAgent = agent;

  var onAgentShutdown = function onAgentShutdown() {
    subs.forEach(function (fn) {
      return fn();
    });
    hook.rendererInterfaces.forEach(function (rendererInterface) {
      rendererInterface.cleanup();
    });
    hook.reactDevtoolsAgent = null;
  };

  agent.addListener('shutdown', onAgentShutdown);
  subs.push(function () {
    agent.removeListener('shutdown', onAgentShutdown);
  });
  return function () {
    subs.forEach(function (fn) {
      return fn();
    });
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).
 *
 * Resolve a style property into it's component parts, e.g.
 *
 * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})
 * -> {top: 5, left: 5, right: 5, bottom: 10}
 */
function resolveBoxStyle(prefix, style) {
  var hasParts = false;
  var result = {
    bottom: 0,
    left: 0,
    right: 0,
    top: 0
  };
  var styleForAll = style[prefix];

  if (styleForAll != null) {
    // eslint-disable-next-line no-for-of-loops/no-for-of-loops
    for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      result[key] = styleForAll;
    }

    hasParts = true;
  }

  var styleForHorizontal = style[prefix + 'Horizontal'];

  if (styleForHorizontal != null) {
    result.left = styleForHorizontal;
    result.right = styleForHorizontal;
    hasParts = true;
  } else {
    var styleForLeft = style[prefix + 'Left'];

    if (styleForLeft != null) {
      result.left = styleForLeft;
      hasParts = true;
    }

    var styleForRight = style[prefix + 'Right'];

    if (styleForRight != null) {
      result.right = styleForRight;
      hasParts = true;
    }

    var styleForEnd = style[prefix + 'End'];

    if (styleForEnd != null) {
      // TODO RTL support
      result.right = styleForEnd;
      hasParts = true;
    }

    var styleForStart = style[prefix + 'Start'];

    if (styleForStart != null) {
      // TODO RTL support
      result.left = styleForStart;
      hasParts = true;
    }
  }

  var styleForVertical = style[prefix + 'Vertical'];

  if (styleForVertical != null) {
    result.bottom = styleForVertical;
    result.top = styleForVertical;
    hasParts = true;
  } else {
    var styleForBottom = style[prefix + 'Bottom'];

    if (styleForBottom != null) {
      result.bottom = styleForBottom;
      hasParts = true;
    }

    var styleForTop = style[prefix + 'Top'];

    if (styleForTop != null) {
      result.top = styleForTop;
      hasParts = true;
    }
  }

  return hasParts ? result : null;
}
// EXTERNAL MODULE: ../react-devtools-shared/src/isArray.js
var isArray = __webpack_require__(6);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js
function setupNativeStyleEditor_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { setupNativeStyleEditor_typeof = function _typeof(obj) { return typeof obj; }; } else { setupNativeStyleEditor_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return setupNativeStyleEditor_typeof(obj); }

function setupNativeStyleEditor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {
  bridge.addListener('NativeStyleEditor_measure', function (_ref) {
    var id = _ref.id,
        rendererID = _ref.rendererID;
    measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
  });
  bridge.addListener('NativeStyleEditor_renameAttribute', function (_ref2) {
    var id = _ref2.id,
        rendererID = _ref2.rendererID,
        oldName = _ref2.oldName,
        newName = _ref2.newName,
        value = _ref2.value;
    renameStyle(agent, id, rendererID, oldName, newName, value);
    setTimeout(function () {
      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
    });
  });
  bridge.addListener('NativeStyleEditor_setValue', function (_ref3) {
    var id = _ref3.id,
        rendererID = _ref3.rendererID,
        name = _ref3.name,
        value = _ref3.value;
    setStyle(agent, id, rendererID, name, value);
    setTimeout(function () {
      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
    });
  });
  bridge.send('isNativeStyleEditorSupported', {
    isSupported: true,
    validAttributes: validAttributes
  });
}
var EMPTY_BOX_STYLE = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
var componentIDToStyleOverrides = new Map();

function measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {
  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: null,
      style: null
    });
    return;
  }

  var instance = data.instance,
      style = data.style;
  var resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.

  var styleOverrides = componentIDToStyleOverrides.get(id);

  if (styleOverrides != null) {
    resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);
  }

  if (!instance || typeof instance.measure !== 'function') {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: null,
      style: resolvedStyle || null
    });
    return;
  }

  instance.measure(function (x, y, width, height, left, top) {
    // RN Android sometimes returns undefined here. Don't send measurements in this case.
    // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817
    if (typeof x !== 'number') {
      bridge.send('NativeStyleEditor_styleAndLayout', {
        id: id,
        layout: null,
        style: resolvedStyle || null
      });
      return;
    }

    var margin = resolvedStyle != null && resolveBoxStyle('margin', resolvedStyle) || EMPTY_BOX_STYLE;
    var padding = resolvedStyle != null && resolveBoxStyle('padding', resolvedStyle) || EMPTY_BOX_STYLE;
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: {
        x: x,
        y: y,
        width: width,
        height: height,
        left: left,
        top: top,
        margin: margin,
        padding: padding
      },
      style: resolvedStyle || null
    });
  });
}

function shallowClone(object) {
  var cloned = {};

  for (var n in object) {
    cloned[n] = object[n];
  }

  return cloned;
}

function renameStyle(agent, id, rendererID, oldName, newName, value) {
  var _ref4;

  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    return;
  }

  var instance = data.instance,
      style = data.style;
  var newStyle = newName ? (_ref4 = {}, setupNativeStyleEditor_defineProperty(_ref4, oldName, undefined), setupNativeStyleEditor_defineProperty(_ref4, newName, value), _ref4) : setupNativeStyleEditor_defineProperty({}, oldName, undefined);
  var customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.

  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    var styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Object(isArray["a" /* default */])(style)) {
    var lastIndex = style.length - 1;

    if (setupNativeStyleEditor_typeof(style[lastIndex]) === 'object' && !Object(isArray["a" /* default */])(style[lastIndex])) {
      customStyle = shallowClone(style[lastIndex]);
      delete customStyle[oldName];

      if (newName) {
        customStyle[newName] = value;
      } else {
        customStyle[oldName] = undefined;
      }

      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style', lastIndex],
        value: customStyle
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else if (setupNativeStyleEditor_typeof(style) === 'object') {
    customStyle = shallowClone(style);
    delete customStyle[oldName];

    if (newName) {
      customStyle[newName] = value;
    } else {
      customStyle[oldName] = undefined;
    }

    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: customStyle
    });
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}

function setStyle(agent, id, rendererID, name, value) {
  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    return;
  }

  var instance = data.instance,
      style = data.style;

  var newStyle = setupNativeStyleEditor_defineProperty({}, name, value); // TODO It would be nice if the renderer interface abstracted this away somehow.


  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    var styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Object(isArray["a" /* default */])(style)) {
    var lastLength = style.length - 1;

    if (setupNativeStyleEditor_typeof(style[lastLength]) === 'object' && !Object(isArray["a" /* default */])(style[lastLength])) {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style', lastLength, name],
        value: value
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}
// CONCATENATED MODULE: ./src/cachedSettings.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

 // Note: all keys should be optional in this type, because users can use newer
// versions of React DevTools with older versions of React Native, and the object
// provided by React Native may not include all of this type's fields.

function initializeUsingCachedSettings(devToolsSettingsManager) {
  initializeConsolePatchSettings(devToolsSettingsManager);
}

function initializeConsolePatchSettings(devToolsSettingsManager) {
  if (devToolsSettingsManager.getConsolePatchSettings == null) {
    return;
  }

  var consolePatchSettingsString = devToolsSettingsManager.getConsolePatchSettings();

  if (consolePatchSettingsString == null) {
    return;
  }

  var parsedConsolePatchSettings = parseConsolePatchSettings(consolePatchSettingsString);

  if (parsedConsolePatchSettings == null) {
    return;
  }

  Object(backend_console["g" /* writeConsolePatchSettingsToWindow */])(parsedConsolePatchSettings);
}

function parseConsolePatchSettings(consolePatchSettingsString) {
  var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;

  var parsedValue = JSON.parse(consolePatchSettingsString !== null && consolePatchSettingsString !== void 0 ? consolePatchSettingsString : '{}');
  var appendComponentStack = parsedValue.appendComponentStack,
      breakOnConsoleErrors = parsedValue.breakOnConsoleErrors,
      showInlineWarningsAndErrors = parsedValue.showInlineWarningsAndErrors,
      hideConsoleLogsInStrictMode = parsedValue.hideConsoleLogsInStrictMode,
      browserTheme = parsedValue.browserTheme;
  return {
    appendComponentStack: (_castBool = Object(src_utils["a" /* castBool */])(appendComponentStack)) !== null && _castBool !== void 0 ? _castBool : true,
    breakOnConsoleErrors: (_castBool2 = Object(src_utils["a" /* castBool */])(breakOnConsoleErrors)) !== null && _castBool2 !== void 0 ? _castBool2 : false,
    showInlineWarningsAndErrors: (_castBool3 = Object(src_utils["a" /* castBool */])(showInlineWarningsAndErrors)) !== null && _castBool3 !== void 0 ? _castBool3 : true,
    hideConsoleLogsInStrictMode: (_castBool4 = Object(src_utils["a" /* castBool */])(hideConsoleLogsInStrictMode)) !== null && _castBool4 !== void 0 ? _castBool4 : false,
    browserTheme: (_castBrowserTheme = Object(src_utils["b" /* castBrowserTheme */])(browserTheme)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : 'dark'
  };
}

function cacheConsolePatchSettings(devToolsSettingsManager, value) {
  if (devToolsSettingsManager.setConsolePatchSettings == null) {
    return;
  }

  devToolsSettingsManager.setConsolePatchSettings(JSON.stringify(value));
}
// CONCATENATED MODULE: ./src/backend.js
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









// Install a global variable to allow patching console early (during injection).
// This provides React Native developers with components stacks even if they don't run DevTools.
Object(backend_console["a" /* installConsoleFunctionsToWindow */])();
installHook(window);
var backend_hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
var savedComponentFilters = Object(src_utils["g" /* getDefaultComponentFilters */])();

function backend_debug(methodName) {
  if (constants["s" /* __DEBUG__ */]) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["%c[core/backend] %c".concat(methodName), 'color: teal; font-weight: bold;', 'font-weight: bold;'].concat(args));
  }
}

function connectToDevTools(options) {
  if (backend_hook == null) {
    // DevTools didn't get injected into this page (maybe b'c of the contentType).
    return;
  }

  var _ref = options || {},
      _ref$host = _ref.host,
      host = _ref$host === void 0 ? 'localhost' : _ref$host,
      nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes,
      _ref$useHttps = _ref.useHttps,
      useHttps = _ref$useHttps === void 0 ? false : _ref$useHttps,
      _ref$port = _ref.port,
      port = _ref$port === void 0 ? 8097 : _ref$port,
      websocket = _ref.websocket,
      _ref$resolveRNStyle = _ref.resolveRNStyle,
      resolveRNStyle = _ref$resolveRNStyle === void 0 ? null : _ref$resolveRNStyle,
      _ref$retryConnectionD = _ref.retryConnectionDelay,
      retryConnectionDelay = _ref$retryConnectionD === void 0 ? 2000 : _ref$retryConnectionD,
      _ref$isAppActive = _ref.isAppActive,
      isAppActive = _ref$isAppActive === void 0 ? function () {
    return true;
  } : _ref$isAppActive,
      devToolsSettingsManager = _ref.devToolsSettingsManager;

  var protocol = useHttps ? 'wss' : 'ws';
  var retryTimeoutID = null;

  function scheduleRetry() {
    if (retryTimeoutID === null) {
      // Two seconds because RN had issues with quick retries.
      retryTimeoutID = setTimeout(function () {
        return connectToDevTools(options);
      }, retryConnectionDelay);
    }
  }

  if (devToolsSettingsManager != null) {
    try {
      initializeUsingCachedSettings(devToolsSettingsManager);
    } catch (e) {
      // If we call a method on devToolsSettingsManager that throws, or if
      // is invalid data read out, don't throw and don't interrupt initialization
      console.error(e);
    }
  }

  if (!isAppActive()) {
    // If the app is in background, maybe retry later.
    // Don't actually attempt to connect until we're in foreground.
    scheduleRetry();
    return;
  }

  var bridge = null;
  var messageListeners = [];
  var uri = protocol + '://' + host + ':' + port; // If existing websocket is passed, use it.
  // This is necessary to support our custom integrations.
  // See D6251744.

  var ws = websocket ? websocket : new window.WebSocket(uri);
  ws.onclose = handleClose;
  ws.onerror = handleFailed;
  ws.onmessage = handleMessage;

  ws.onopen = function () {
    bridge = new src_bridge({
      listen: function listen(fn) {
        messageListeners.push(fn);
        return function () {
          var index = messageListeners.indexOf(fn);

          if (index >= 0) {
            messageListeners.splice(index, 1);
          }
        };
      },
      send: function send(event, payload, transferable) {
        if (ws.readyState === ws.OPEN) {
          if (constants["s" /* __DEBUG__ */]) {
            backend_debug('wall.send()', event, payload);
          }

          ws.send(JSON.stringify({
            event: event,
            payload: payload
          }));
        } else {
          if (constants["s" /* __DEBUG__ */]) {
            backend_debug('wall.send()', 'Shutting down bridge because of closed WebSocket connection');
          }

          if (bridge !== null) {
            bridge.shutdown();
          }

          scheduleRetry();
        }
      }
    });
    bridge.addListener('updateComponentFilters', function (componentFilters) {
      // Save filter changes in memory, in case DevTools is reloaded.
      // In that case, the renderer will already be using the updated values.
      // We'll lose these in between backend reloads but that can't be helped.
      savedComponentFilters = componentFilters;
    });

    if (devToolsSettingsManager != null && bridge != null) {
      bridge.addListener('updateConsolePatchSettings', function (consolePatchSettings) {
        return cacheConsolePatchSettings(devToolsSettingsManager, consolePatchSettings);
      });
    } // The renderer interface doesn't read saved component filters directly,
    // because they are generally stored in localStorage within the context of the extension.
    // Because of this it relies on the extension to pass filters.
    // In the case of the standalone DevTools being used with a website,
    // saved filters are injected along with the backend script tag so we shouldn't override them here.
    // This injection strategy doesn't work for React Native though.
    // Ideally the backend would save the filters itself, but RN doesn't provide a sync storage solution.
    // So for now we just fall back to using the default filters...


    if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      bridge.send('overrideComponentFilters', savedComponentFilters);
    } // TODO (npm-packages) Warn if "isBackendStorageAPISupported"
    // $FlowFixMe[incompatible-call] found when upgrading Flow


    var agent = new agent_Agent(bridge);
    agent.addListener('shutdown', function () {
      // If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,
      // and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.
      backend_hook.emit('shutdown');
    });
    initBackend(backend_hook, agent, window); // Setup React Native style editor if the environment supports it.

    if (resolveRNStyle != null || backend_hook.resolveRNStyle != null) {
      setupNativeStyleEditor( // $FlowFixMe[incompatible-call] found when upgrading Flow
      bridge, agent, resolveRNStyle || backend_hook.resolveRNStyle, nativeStyleEditorValidAttributes || backend_hook.nativeStyleEditorValidAttributes || null);
    } else {
      // Otherwise listen to detect if the environment later supports it.
      // For example, Flipper does not eagerly inject these values.
      // Instead it relies on the React Native Inspector to lazily inject them.
      var lazyResolveRNStyle;
      var lazyNativeStyleEditorValidAttributes;

      var initAfterTick = function initAfterTick() {
        if (bridge !== null) {
          setupNativeStyleEditor(bridge, agent, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);
        }
      };

      if (!backend_hook.hasOwnProperty('resolveRNStyle')) {
        Object.defineProperty(backend_hook, 'resolveRNStyle', {
          enumerable: false,
          get: function get() {
            return lazyResolveRNStyle;
          },
          set: function set(value) {
            lazyResolveRNStyle = value;
            initAfterTick();
          }
        });
      }

      if (!backend_hook.hasOwnProperty('nativeStyleEditorValidAttributes')) {
        Object.defineProperty(backend_hook, 'nativeStyleEditorValidAttributes', {
          enumerable: false,
          get: function get() {
            return lazyNativeStyleEditorValidAttributes;
          },
          set: function set(value) {
            lazyNativeStyleEditorValidAttributes = value;
            initAfterTick();
          }
        });
      }
    }
  };

  function handleClose() {
    if (constants["s" /* __DEBUG__ */]) {
      backend_debug('WebSocket.onclose');
    }

    if (bridge !== null) {
      bridge.emit('shutdown');
    }

    scheduleRetry();
  }

  function handleFailed() {
    if (constants["s" /* __DEBUG__ */]) {
      backend_debug('WebSocket.onerror');
    }

    scheduleRetry();
  }

  function handleMessage(event) {
    var data;

    try {
      if (typeof event.data === 'string') {
        data = JSON.parse(event.data);

        if (constants["s" /* __DEBUG__ */]) {
          backend_debug('WebSocket.onmessage', data);
        }
      } else {
        throw Error();
      }
    } catch (e) {
      console.error('[React DevTools] Failed to parse JSON: ' + event.data);
      return;
    }

    messageListeners.forEach(function (fn) {
      try {
        fn(data);
      } catch (error) {
        // jsc doesn't play so well with tracebacks that go into eval'd code,
        // so the stack trace here will stop at the `(0,eval)()` call. Getting the
        // message that caused the error is the best we can do for now.
        console.log('[React DevTools] Error calling listener', data);
        console.log('error:', error);
        throw error;
      }
    });
  }
}

/***/ })
/******/ ]);
});
//# sourceMappingURL=backend.js.map
      };
    };
  }
  }
}, {package:"react-devtools>react-devtools-core",file:"node_modules\\react-devtools-core\\dist\\backend.js",}],
["F:\\metamask-extension\\node_modules\\react-devtools\\index.js", {"react-devtools-core/backend":"F:\\metamask-extension\\node_modules\\react-devtools-core\\backend.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Creact-devtools%5Cindex.js
      return function (require, module, exports) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

const {connectToDevTools} = require('react-devtools-core/backend');

// Connect immediately with default options.
// If you need more control, use `react-devtools-core` directly instead of `react-devtools`.
connectToDevTools();

      };
    };
  }
  }
}, {package:"react-devtools",file:"node_modules\\react-devtools\\index.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdW5pcXVlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3V1aWQuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3V1aWRWLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS93ZWJBdXRob3JpdHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3dlYkZyYWdtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvd2ViUXVlcnlQYXJhbWV0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS93ZWJTZWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS93ZWJVcmwuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL1ZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL01vZGVsUnVubmVyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL1JlcGxheVBhdGguanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvY29tbWFuZHMvQ29tbWFuZFdyYXBwZXIuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvY29tbWFuZHMvQ29tbWFuZHNJdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9tb2RlbC9jb21tYW5kcy9TY2hlZHVsZWRDb21tYW5kLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3ByZWNvbmRpdGlvbi9QcmUuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmUuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvQXN5bmNQcm9wZXJ0eS5nZW5lcmljLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0FzeW5jUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvSVJhd1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0lnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvUHJvcGVydHkuZ2VuZXJpYy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Qcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Ta2lwQWZ0ZXJQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9UaW1lb3V0UHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvVW5iaWFzZWRQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvRGVjb3JhdGVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvUnVubmVyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9SdW5uZXJJdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvU2FtcGxlci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvU291cmNlVmFsdWVzSXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL1Rvc3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL1F1YWxpZmllZFBhcmFtZXRlcnMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWwuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL3JlcG9ydGVyL0V4ZWN1dGlvblN0YXR1cy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvcmVwb3J0ZXIvUnVuRXhlY3V0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci91dGlscy9QYXRoV2Fsa2VyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci91dGlscy9SdW5EZXRhaWxzRm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3N5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvZmFzdC1jaGVjay1kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2Zhc3QtY2hlY2suanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvcmFuZG9tL2dlbmVyYXRvci9SYW5kb20uanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvc3RyZWFtL0xhenlJdGVyYWJsZUl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL3N0cmVhbS9TdHJlYW0uanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvc3RyZWFtL1N0cmVhbUhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvdXRpbHMvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi91dGlscy9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9mb2N1c0luc2lkZS5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L2ZvY3VzSXNIaWRkZW4uanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9mb2N1c01lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvZm9jdXNhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvc2V0Rm9jdXMuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS9zaWJsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdGFiSG9vay5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL0RPTXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvYWxsLWFmZmVjdGVkLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS91dGlscy9hdXRvLWZvY3VzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvY29ycmVjdEZvY3VzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvZmlyc3RGb2N1cy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS91dGlscy9pcy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL3BhcmVudGluZy5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL3NhZmUuanMiLCJub2RlX21vZHVsZXMvZm9jdXMtbG9jay9kaXN0L2VzNS91dGlscy90YWJPcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9mb2N1cy1sb2NrL2Rpc3QvZXM1L3V0aWxzL3RhYlV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2ZvY3VzLWxvY2svZGlzdC9lczUvdXRpbHMvdGFiYmFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9ucy1oYXZlLW5hbWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1c2UuanMvZGlzdC9mdXNlLmpzIiwibm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LXBhcmFtcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW52ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbG9va0F0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvbXVsdGlwbHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDQuanMiLCJub2RlX21vZHVsZXMvZ3VkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtcHJvdG8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzIiwibm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGVhZGVyLWNhc2UvaGVhZGVyLWNhc2UuanMiLCJub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguY2pzLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kYXRlLW9iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtaW4tYnJvd3Nlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWxvd2VyLWNhc2UvaXMtbG93ZXItY2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtdXBwZXItY2FzZS9pcy11cHBlci1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL2lzLXdpbmRvdy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc2FuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL2N5Y2xlLmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL3BhdGgtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzYW4vbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcG9pbnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWNhbWVsLWNhc2UvZGlzdC9qc3MtcGx1Z2luLWNhbWVsLWNhc2UuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZGVmYXVsdC11bml0L2Rpc3QvanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZ2xvYmFsL2Rpc3QvanNzLXBsdWdpbi1nbG9iYWwuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tbmVzdGVkL2Rpc3QvanNzLXBsdWdpbi1uZXN0ZWQuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcHJvcHMtc29ydC9kaXN0L2pzcy1wbHVnaW4tcHJvcHMtc29ydC5janMuanMiLCJub2RlX21vZHVsZXMvanNzLXBsdWdpbi1ydWxlLXZhbHVlLWZ1bmN0aW9uL2Rpc3QvanNzLXBsdWdpbi1ydWxlLXZhbHVlLWZ1bmN0aW9uLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXZlbmRvci1wcmVmaXhlci9kaXN0L2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvZGlzdC9qc3MuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2xpbmtlZC1saXN0L19zb3VyY2UvbGlua2VkLWxpc3QuanMiLCJub2RlX21vZHVsZXMvbGlua2VkLWxpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9jYWxlLWN1cnJlbmN5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvY2FsZS1jdXJyZW5jeS9tYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5QWdncmVnYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZURpZmZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU3VtLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuaXEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RpZmZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2VzY2FwZVJlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQm9vbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNOdW1iZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9wYXJ0aXRpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pb24uanMiLCJub2RlX21vZHVsZXMvbG93ZXItY2FzZS1maXJzdC9sb3dlci1jYXNlLWZpcnN0LmpzIiwibm9kZV9tb2R1bGVzL2xvd2VyLWNhc2UvbG93ZXItY2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXJzZW5uZS10d2lzdGVyL3NyYy9tZXJzZW5uZS10d2lzdGVyLmpzIiwibm9kZV9tb2R1bGVzL21pbmktY3JlYXRlLXJlYWN0LWNvbnRleHQvZGlzdC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9iYXNlMTYuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZTMyLmpzIiwibm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbm8tY2FzZS9uby1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL25vLWNhc2UvdmVuZG9yL2NhbWVsLWNhc2UtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL25vLWNhc2UvdmVuZG9yL2NhbWVsLWNhc2UtdXBwZXItcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL25vLWNhc2UvdmVuZG9yL25vbi13b3JkLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25vZmlsdGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGFyYW0tY2FzZS9wYXJhbS1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL3Bhc2NhbC1jYXNlL3Bhc2NhbC1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtY2FzZS9wYXRoLWNhc2UuanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvdW1kL3BvcHBlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1VuaWZvcm1CaWdJbnREaXN0cmlidXRpb24uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5pZm9ybUludERpc3RyaWJ1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL2ludGVybmFscy9BcnJheUludC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9pbnRlcm5hbHMvVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9MaW5lYXJDb25ncnVlbnRpYWwuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvTWVyc2VubmVUd2lzdGVyLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZ2VuZXJhdG9yL1JhbmRvbUdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9Yb3JTaGlmdC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9Yb3JvU2hpcm8uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9wdXJlLXJhbmQtZGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL3B1cmUtcmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvOEJpdEJ5dGUuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL0JpdEJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvRXJyb3JDb3JyZWN0TGV2ZWwuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL1BvbHlub21pYWwuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL1FSQ29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvUlNCbG9jay5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvbW9kZS5qcyIsIm5vZGVfbW9kdWxlcy9xci5qcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9xcmNvZGUtZ2VuZXJhdG9yL3FyY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xcmNvZGUucmVhY3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWNsaWVudHNpZGUtZWZmZWN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kZXZ0b29scy1jb3JlL2JhY2tlbmQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZGV2dG9vbHMtY29yZS9kaXN0L2JhY2tlbmQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZGV2dG9vbHMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1ckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdDFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFhQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2c0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN2lnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InVpLTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5pcXVlQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBBcnJheUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9BcnJheUFyYml0cmFyeVwiKTtcbmNvbnN0IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9NYXhMZW5ndGhGcm9tTWluTGVuZ3RoXCIpO1xuY29uc3QgQ3VzdG9tRXF1YWxTZXRfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9DdXN0b21FcXVhbFNldFwiKTtcbmNvbnN0IFN0cmljdGx5RXF1YWxTZXRfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TdHJpY3RseUVxdWFsU2V0XCIpO1xuY29uc3QgU2FtZVZhbHVlU2V0XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU2FtZVZhbHVlU2V0XCIpO1xuY29uc3QgU2FtZVZhbHVlWmVyb1NldF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1NhbWVWYWx1ZVplcm9TZXRcIik7XG5mdW5jdGlvbiBidWlsZFVuaXF1ZUFycmF5U2V0QnVpbGRlcihjb25zdHJhaW50cykge1xuICAgIGlmICh0eXBlb2YgY29uc3RyYWludHMuY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoY29uc3RyYWludHMuc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IGNvbnN0cmFpbnRzLmNvbXBhcmF0b3I7XG4gICAgICAgICAgICBjb25zdCBpc0VxdWFsRm9yQnVpbGRlciA9IChuZXh0QSwgbmV4dEIpID0+IGNvbXBhcmF0b3IobmV4dEEudmFsdWVfLCBuZXh0Qi52YWx1ZV8pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDdXN0b21FcXVhbFNldF8xLkN1c3RvbUVxdWFsU2V0KGlzRXF1YWxGb3JCdWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gY29uc3RyYWludHMuY29tcGFyYXRvcjtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBjb25zdHJhaW50cy5zZWxlY3RvcjtcbiAgICAgICAgY29uc3QgcmVmaW5lZFNlbGVjdG9yID0gKG5leHQpID0+IHNlbGVjdG9yKG5leHQudmFsdWVfKTtcbiAgICAgICAgY29uc3QgaXNFcXVhbEZvckJ1aWxkZXIgPSAobmV4dEEsIG5leHRCKSA9PiBjb21wYXJhdG9yKHJlZmluZWRTZWxlY3RvcihuZXh0QSksIHJlZmluZWRTZWxlY3RvcihuZXh0QikpO1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IEN1c3RvbUVxdWFsU2V0XzEuQ3VzdG9tRXF1YWxTZXQoaXNFcXVhbEZvckJ1aWxkZXIpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RvciA9IGNvbnN0cmFpbnRzLnNlbGVjdG9yIHx8ICgodikgPT4gdik7XG4gICAgY29uc3QgcmVmaW5lZFNlbGVjdG9yID0gKG5leHQpID0+IHNlbGVjdG9yKG5leHQudmFsdWVfKTtcbiAgICBzd2l0Y2ggKGNvbnN0cmFpbnRzLmNvbXBhcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnSXNTdHJpY3RseUVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBuZXcgU3RyaWN0bHlFcXVhbFNldF8xLlN0cmljdGx5RXF1YWxTZXQocmVmaW5lZFNlbGVjdG9yKTtcbiAgICAgICAgY2FzZSAnU2FtZVZhbHVlWmVybyc6XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbmV3IFNhbWVWYWx1ZVplcm9TZXRfMS5TYW1lVmFsdWVaZXJvU2V0KHJlZmluZWRTZWxlY3Rvcik7XG4gICAgICAgIGNhc2UgJ1NhbWVWYWx1ZSc6XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgcmV0dXJuICgpID0+IG5ldyBTYW1lVmFsdWVTZXRfMS5TYW1lVmFsdWVTZXQocmVmaW5lZFNlbGVjdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bmlxdWVBcnJheShhcmIsIGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICBjb25zdCBtaW5MZW5ndGggPSBjb25zdHJhaW50cy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1pbkxlbmd0aCA6IDA7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gY29uc3RyYWludHMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5tYXhMZW5ndGggOiBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEuTWF4TGVuZ3RoVXBwZXJCb3VuZDtcbiAgICBjb25zdCBtYXhHZW5lcmF0ZWRMZW5ndGggPSAoMCwgTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLm1heEdlbmVyYXRlZExlbmd0aEZyb21TaXplRm9yQXJiaXRyYXJ5KShjb25zdHJhaW50cy5zaXplLCBtaW5MZW5ndGgsIG1heExlbmd0aCwgY29uc3RyYWludHMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGRlcHRoSWRlbnRpZmllciA9IGNvbnN0cmFpbnRzLmRlcHRoSWRlbnRpZmllcjtcbiAgICBjb25zdCBzZXRCdWlsZGVyID0gYnVpbGRVbmlxdWVBcnJheVNldEJ1aWxkZXIoY29uc3RyYWludHMpO1xuICAgIGNvbnN0IGFycmF5QXJiID0gbmV3IEFycmF5QXJiaXRyYXJ5XzEuQXJyYXlBcmJpdHJhcnkoYXJiLCBtaW5MZW5ndGgsIG1heEdlbmVyYXRlZExlbmd0aCwgbWF4TGVuZ3RoLCBkZXB0aElkZW50aWZpZXIsIHNldEJ1aWxkZXIsIFtdKTtcbiAgICBpZiAobWluTGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gYXJyYXlBcmI7XG4gICAgcmV0dXJuIGFycmF5QXJiLmZpbHRlcigodGFiKSA9PiB0YWIubGVuZ3RoID49IG1pbkxlbmd0aCk7XG59XG5leHBvcnRzLnVuaXF1ZUFycmF5ID0gdW5pcXVlQXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXVpZCA9IHZvaWQgMDtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IFBhZGRlZE51bWJlckFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvUGFkZGVkTnVtYmVyQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmNvbnN0IFBhZGRlZEVpZ2h0c1RvVXVpZF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL1BhZGRlZEVpZ2h0c1RvVXVpZFwiKTtcbmZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgY29uc3QgcGFkZGVkID0gKDAsIFBhZGRlZE51bWJlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFBhZGRlZE51bWJlckFyYml0cmFyeSkoMCwgMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgc2Vjb25kUGFkZGVkID0gKDAsIFBhZGRlZE51bWJlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFBhZGRlZE51bWJlckFyYml0cmFyeSkoMHgxMDAwMDAwMCwgMHg1ZmZmZmZmZik7XG4gICAgY29uc3QgdGhpcmRQYWRkZWQgPSAoMCwgUGFkZGVkTnVtYmVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkUGFkZGVkTnVtYmVyQXJiaXRyYXJ5KSgweDgwMDAwMDAwLCAweGJmZmZmZmZmKTtcbiAgICByZXR1cm4gKDAsIHR1cGxlXzEudHVwbGUpKHBhZGRlZCwgc2Vjb25kUGFkZGVkLCB0aGlyZFBhZGRlZCwgcGFkZGVkKS5tYXAoUGFkZGVkRWlnaHRzVG9VdWlkXzEucGFkZGVkRWlnaHRzVG9VdWlkTWFwcGVyLCBQYWRkZWRFaWdodHNUb1V1aWRfMS5wYWRkZWRFaWdodHNUb1V1aWRVbm1hcHBlcik7XG59XG5leHBvcnRzLnV1aWQgPSB1dWlkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV1aWRWID0gdm9pZCAwO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xuY29uc3QgUGFkZGVkTnVtYmVyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9QYWRkZWROdW1iZXJBcmJpdHJhcnlCdWlsZGVyXCIpO1xuY29uc3QgUGFkZGVkRWlnaHRzVG9VdWlkXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvUGFkZGVkRWlnaHRzVG9VdWlkXCIpO1xuZnVuY3Rpb24gdXVpZFYodmVyc2lvbk51bWJlcikge1xuICAgIGNvbnN0IHBhZGRlZCA9ICgwLCBQYWRkZWROdW1iZXJBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYWRkZWROdW1iZXJBcmJpdHJhcnkpKDAsIDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IG9mZnNldFNlY29uZCA9IHZlcnNpb25OdW1iZXIgKiAweDEwMDAwMDAwO1xuICAgIGNvbnN0IHNlY29uZFBhZGRlZCA9ICgwLCBQYWRkZWROdW1iZXJBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYWRkZWROdW1iZXJBcmJpdHJhcnkpKG9mZnNldFNlY29uZCwgb2Zmc2V0U2Vjb25kICsgMHgwZmZmZmZmZik7XG4gICAgY29uc3QgdGhpcmRQYWRkZWQgPSAoMCwgUGFkZGVkTnVtYmVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkUGFkZGVkTnVtYmVyQXJiaXRyYXJ5KSgweDgwMDAwMDAwLCAweGJmZmZmZmZmKTtcbiAgICByZXR1cm4gKDAsIHR1cGxlXzEudHVwbGUpKHBhZGRlZCwgc2Vjb25kUGFkZGVkLCB0aGlyZFBhZGRlZCwgcGFkZGVkKS5tYXAoUGFkZGVkRWlnaHRzVG9VdWlkXzEucGFkZGVkRWlnaHRzVG9VdWlkTWFwcGVyLCBQYWRkZWRFaWdodHNUb1V1aWRfMS5wYWRkZWRFaWdodHNUb1V1aWRVbm1hcHBlcik7XG59XG5leHBvcnRzLnV1aWRWID0gdXVpZFY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2ViQXV0aG9yaXR5ID0gdm9pZCAwO1xuY29uc3QgQ2hhcmFjdGVyUmFuZ2VBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NoYXJhY3RlclJhbmdlQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcbmNvbnN0IGRvbWFpbl8xID0gcmVxdWlyZShcIi4vZG9tYWluXCIpO1xuY29uc3QgaXBWNF8xID0gcmVxdWlyZShcIi4vaXBWNFwiKTtcbmNvbnN0IGlwVjRFeHRlbmRlZF8xID0gcmVxdWlyZShcIi4vaXBWNEV4dGVuZGVkXCIpO1xuY29uc3QgaXBWNl8xID0gcmVxdWlyZShcIi4vaXBWNlwiKTtcbmNvbnN0IG5hdF8xID0gcmVxdWlyZShcIi4vbmF0XCIpO1xuY29uc3Qgb25lb2ZfMSA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xuY29uc3Qgb3B0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHRpb25cIik7XG5jb25zdCBzdHJpbmdPZl8xID0gcmVxdWlyZShcIi4vc3RyaW5nT2ZcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5mdW5jdGlvbiBob3N0VXNlckluZm8oc2l6ZSkge1xuICAgIGNvbnN0IG90aGVycyA9IFsnLScsICcuJywgJ18nLCAnficsICchJywgJyQnLCAnJicsIFwiJ1wiLCAnKCcsICcpJywgJyonLCAnKycsICcsJywgJzsnLCAnPScsICc6J107XG4gICAgcmV0dXJuICgwLCBzdHJpbmdPZl8xLnN0cmluZ09mKSgoMCwgQ2hhcmFjdGVyUmFuZ2VBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiaXRyYXJ5KShvdGhlcnMpLCB7IHNpemUgfSk7XG59XG5mdW5jdGlvbiB1c2VySG9zdFBvcnRNYXBwZXIoW3UsIGgsIHBdKSB7XG4gICAgcmV0dXJuICh1ID09PSBudWxsID8gJycgOiBgJHt1fUBgKSArIGggKyAocCA9PT0gbnVsbCA/ICcnIDogYDoke3B9YCk7XG59XG5mdW5jdGlvbiB1c2VySG9zdFBvcnRVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgYXRQb3NpdGlvbiA9IHZhbHVlLmluZGV4T2YoJ0AnKTtcbiAgICBjb25zdCB1c2VyID0gYXRQb3NpdGlvbiAhPT0gLTEgPyB2YWx1ZS5zdWJzdHJpbmcoMCwgYXRQb3NpdGlvbikgOiBudWxsO1xuICAgIGNvbnN0IHBvcnRSZWdleCA9IC86KFxcZCspJC87XG4gICAgY29uc3QgbSA9IHBvcnRSZWdleC5leGVjKHZhbHVlKTtcbiAgICBjb25zdCBwb3J0ID0gbSAhPT0gbnVsbCA/IE51bWJlcihtWzFdKSA6IG51bGw7XG4gICAgY29uc3QgaG9zdCA9IG0gIT09IG51bGwgPyB2YWx1ZS5zdWJzdHJpbmcoYXRQb3NpdGlvbiArIDEsIHZhbHVlLmxlbmd0aCAtIG1bMV0ubGVuZ3RoIC0gMSkgOiB2YWx1ZS5zdWJzdHJpbmcoYXRQb3NpdGlvbiArIDEpO1xuICAgIHJldHVybiBbdXNlciwgaG9zdCwgcG9ydF07XG59XG5mdW5jdGlvbiBicmFja2V0ZWRNYXBwZXIocykge1xuICAgIHJldHVybiBgWyR7c31dYDtcbn1cbmZ1bmN0aW9uIGJyYWNrZXRlZFVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWVbMF0gIT09ICdbJyB8fCB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gJ10nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIHdlYkF1dGhvcml0eShjb25zdHJhaW50cykge1xuICAgIGNvbnN0IGMgPSBjb25zdHJhaW50cyB8fCB7fTtcbiAgICBjb25zdCBzaXplID0gYy5zaXplO1xuICAgIGNvbnN0IGhvc3RuYW1lQXJicyA9IFsoMCwgZG9tYWluXzEuZG9tYWluKSh7IHNpemUgfSldXG4gICAgICAgIC5jb25jYXQoYy53aXRoSVB2NCA9PT0gdHJ1ZSA/IFsoMCwgaXBWNF8xLmlwVjQpKCldIDogW10pXG4gICAgICAgIC5jb25jYXQoYy53aXRoSVB2NiA9PT0gdHJ1ZSA/IFsoMCwgaXBWNl8xLmlwVjYpKCkubWFwKGJyYWNrZXRlZE1hcHBlciwgYnJhY2tldGVkVW5tYXBwZXIpXSA6IFtdKVxuICAgICAgICAuY29uY2F0KGMud2l0aElQdjRFeHRlbmRlZCA9PT0gdHJ1ZSA/IFsoMCwgaXBWNEV4dGVuZGVkXzEuaXBWNEV4dGVuZGVkKSgpXSA6IFtdKTtcbiAgICByZXR1cm4gKDAsIHR1cGxlXzEudHVwbGUpKGMud2l0aFVzZXJJbmZvID09PSB0cnVlID8gKDAsIG9wdGlvbl8xLm9wdGlvbikoaG9zdFVzZXJJbmZvKHNpemUpKSA6ICgwLCBjb25zdGFudF8xLmNvbnN0YW50KShudWxsKSwgKDAsIG9uZW9mXzEub25lb2YpKC4uLmhvc3RuYW1lQXJicyksIGMud2l0aFBvcnQgPT09IHRydWUgPyAoMCwgb3B0aW9uXzEub3B0aW9uKSgoMCwgbmF0XzEubmF0KSg2NTUzNSkpIDogKDAsIGNvbnN0YW50XzEuY29uc3RhbnQpKG51bGwpKS5tYXAodXNlckhvc3RQb3J0TWFwcGVyLCB1c2VySG9zdFBvcnRVbm1hcHBlcik7XG59XG5leHBvcnRzLndlYkF1dGhvcml0eSA9IHdlYkF1dGhvcml0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53ZWJGcmFnbWVudHMgPSB2b2lkIDA7XG5jb25zdCBVcmlRdWVyeU9yRnJhZ21lbnRBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1VyaVF1ZXJ5T3JGcmFnbWVudEFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB3ZWJGcmFnbWVudHMoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiAoMCwgVXJpUXVlcnlPckZyYWdtZW50QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkVXJpUXVlcnlPckZyYWdtZW50QXJiaXRyYXJ5KShjb25zdHJhaW50cy5zaXplKTtcbn1cbmV4cG9ydHMud2ViRnJhZ21lbnRzID0gd2ViRnJhZ21lbnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndlYlF1ZXJ5UGFyYW1ldGVycyA9IHZvaWQgMDtcbmNvbnN0IFVyaVF1ZXJ5T3JGcmFnbWVudEFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVXJpUXVlcnlPckZyYWdtZW50QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIHdlYlF1ZXJ5UGFyYW1ldGVycyhjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuICgwLCBVcmlRdWVyeU9yRnJhZ21lbnRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRVcmlRdWVyeU9yRnJhZ21lbnRBcmJpdHJhcnkpKGNvbnN0cmFpbnRzLnNpemUpO1xufVxuZXhwb3J0cy53ZWJRdWVyeVBhcmFtZXRlcnMgPSB3ZWJRdWVyeVBhcmFtZXRlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2ViU2VnbWVudCA9IHZvaWQgMDtcbmNvbnN0IENoYXJhY3RlclJhbmdlQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJSYW5nZUFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBzdHJpbmdPZl8xID0gcmVxdWlyZShcIi4vc3RyaW5nT2ZcIik7XG5mdW5jdGlvbiB3ZWJTZWdtZW50KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICBjb25zdCBvdGhlcnMgPSBbJy0nLCAnLicsICdfJywgJ34nLCAnIScsICckJywgJyYnLCBcIidcIiwgJygnLCAnKScsICcqJywgJysnLCAnLCcsICc7JywgJz0nLCAnOicsICdAJ107XG4gICAgcmV0dXJuICgwLCBzdHJpbmdPZl8xLnN0cmluZ09mKSgoMCwgQ2hhcmFjdGVyUmFuZ2VBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiaXRyYXJ5KShvdGhlcnMpLCB7IHNpemU6IGNvbnN0cmFpbnRzLnNpemUgfSk7XG59XG5leHBvcnRzLndlYlNlZ21lbnQgPSB3ZWJTZWdtZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndlYlVybCA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50RnJvbV8xID0gcmVxdWlyZShcIi4vY29uc3RhbnRGcm9tXCIpO1xuY29uc3QgY29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50XCIpO1xuY29uc3Qgb3B0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHRpb25cIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5jb25zdCB3ZWJRdWVyeVBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL3dlYlF1ZXJ5UGFyYW1ldGVyc1wiKTtcbmNvbnN0IHdlYkZyYWdtZW50c18xID0gcmVxdWlyZShcIi4vd2ViRnJhZ21lbnRzXCIpO1xuY29uc3Qgd2ViQXV0aG9yaXR5XzEgPSByZXF1aXJlKFwiLi93ZWJBdXRob3JpdHlcIik7XG5jb25zdCBQYXJ0c1RvVXJsXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvUGFydHNUb1VybFwiKTtcbmNvbnN0IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9NYXhMZW5ndGhGcm9tTWluTGVuZ3RoXCIpO1xuY29uc3QgVXJpUGF0aEFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVXJpUGF0aEFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB3ZWJVcmwoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBjID0gY29uc3RyYWludHMgfHwge307XG4gICAgY29uc3QgcmVzb2x2ZWRTaXplID0gKDAsIE1heExlbmd0aEZyb21NaW5MZW5ndGhfMS5yZXNvbHZlU2l6ZSkoYy5zaXplKTtcbiAgICBjb25zdCByZXNvbHZlZEF1dGhvcml0eVNldHRpbmdzU2l6ZSA9IGMuYXV0aG9yaXR5U2V0dGluZ3MgIT09IHVuZGVmaW5lZCAmJiBjLmF1dGhvcml0eVNldHRpbmdzLnNpemUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/ICgwLCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEucmVsYXRpdmVTaXplVG9TaXplKShjLmF1dGhvcml0eVNldHRpbmdzLnNpemUsIHJlc29sdmVkU2l6ZSlcbiAgICAgICAgOiByZXNvbHZlZFNpemU7XG4gICAgY29uc3QgcmVzb2x2ZWRBdXRob3JpdHlTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYy5hdXRob3JpdHlTZXR0aW5ncyksIHsgc2l6ZTogcmVzb2x2ZWRBdXRob3JpdHlTZXR0aW5nc1NpemUgfSk7XG4gICAgY29uc3QgdmFsaWRTY2hlbWVzID0gYy52YWxpZFNjaGVtZXMgfHwgWydodHRwJywgJ2h0dHBzJ107XG4gICAgY29uc3Qgc2NoZW1lQXJiID0gKDAsIGNvbnN0YW50RnJvbV8xLmNvbnN0YW50RnJvbSkoLi4udmFsaWRTY2hlbWVzKTtcbiAgICBjb25zdCBhdXRob3JpdHlBcmIgPSAoMCwgd2ViQXV0aG9yaXR5XzEud2ViQXV0aG9yaXR5KShyZXNvbHZlZEF1dGhvcml0eVNldHRpbmdzKTtcbiAgICBjb25zdCBwYXRoQXJiID0gKDAsIFVyaVBhdGhBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRVcmlQYXRoQXJiaXRyYXJ5KShyZXNvbHZlZFNpemUpO1xuICAgIHJldHVybiAoMCwgdHVwbGVfMS50dXBsZSkoc2NoZW1lQXJiLCBhdXRob3JpdHlBcmIsIHBhdGhBcmIsIGMud2l0aFF1ZXJ5UGFyYW1ldGVycyA9PT0gdHJ1ZSA/ICgwLCBvcHRpb25fMS5vcHRpb24pKCgwLCB3ZWJRdWVyeVBhcmFtZXRlcnNfMS53ZWJRdWVyeVBhcmFtZXRlcnMpKHsgc2l6ZTogcmVzb2x2ZWRTaXplIH0pKSA6ICgwLCBjb25zdGFudF8xLmNvbnN0YW50KShudWxsKSwgYy53aXRoRnJhZ21lbnRzID09PSB0cnVlID8gKDAsIG9wdGlvbl8xLm9wdGlvbikoKDAsIHdlYkZyYWdtZW50c18xLndlYkZyYWdtZW50cykoeyBzaXplOiByZXNvbHZlZFNpemUgfSkpIDogKDAsIGNvbnN0YW50XzEuY29uc3RhbnQpKG51bGwpKS5tYXAoUGFydHNUb1VybF8xLnBhcnRzVG9VcmxNYXBwZXIsIFBhcnRzVG9VcmxfMS5wYXJ0c1RvVXJsVW5tYXBwZXIpO1xufVxuZXhwb3J0cy53ZWJVcmwgPSB3ZWJVcmw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0SXNBcmJpdHJhcnkgPSBleHBvcnRzLmlzQXJiaXRyYXJ5ID0gZXhwb3J0cy5BcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL3N5bWJvbHNcIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jbGFzcyBBcmJpdHJhcnkge1xuICAgIGZpbHRlcihyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyQXJiaXRyYXJ5KHRoaXMsIHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBtYXAobWFwcGVyLCB1bm1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IE1hcEFyYml0cmFyeSh0aGlzLCBtYXBwZXIsIHVubWFwcGVyKTtcbiAgICB9XG4gICAgY2hhaW4oY2hhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluQXJiaXRyYXJ5KHRoaXMsIGNoYWluZXIpO1xuICAgIH1cbiAgICBub1NocmluaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb1Nocmlua0FyYml0cmFyeSh0aGlzKTtcbiAgICB9XG4gICAgbm9CaWFzKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vQmlhc0FyYml0cmFyeSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkFyYml0cmFyeSA9IEFyYml0cmFyeTtcbmNsYXNzIENoYWluQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIGNoYWluZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMuY2hhaW5lciA9IGNoYWluZXI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkTXJuZyA9IG1ybmcuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc3JjID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQ2hhaW5lcihzcmMsIG1ybmcsIGNsb25lZE1ybmcsIGJpYXNGYWN0b3IpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pc1NhZmVDb250ZXh0KGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFjb250ZXh0LnN0b3BwZWRGb3JPcmlnaW5hbFxuICAgICAgICAgICAgICAgID8gdGhpcy5hcmJcbiAgICAgICAgICAgICAgICAgICAgLnNocmluayhjb250ZXh0Lm9yaWdpbmFsVmFsdWUsIGNvbnRleHQub3JpZ2luYWxDb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiB0aGlzLnZhbHVlQ2hhaW5lcih2LCBjb250ZXh0LmNsb25lZE1ybmcuY2xvbmUoKSwgY29udGV4dC5jbG9uZWRNcm5nLCBjb250ZXh0Lm9yaWdpbmFsQmlhcykpXG4gICAgICAgICAgICAgICAgOiBTdHJlYW1fMS5TdHJlYW0ubmlsKCkpLmpvaW4oY29udGV4dC5jaGFpbmVkQXJiaXRyYXJ5LnNocmluayh2YWx1ZSwgY29udGV4dC5jaGFpbmVkQ29udGV4dCkubWFwKChkc3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyBjaGFpbmVkQ29udGV4dDogZHN0LmNvbnRleHQsIHN0b3BwZWRGb3JPcmlnaW5hbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuVmFsdWUoZHN0LnZhbHVlXywgbmV3Q29udGV4dCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICB9XG4gICAgdmFsdWVDaGFpbmVyKHYsIGdlbmVyYXRlTXJuZywgY2xvbmVkTXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBjb25zdCBjaGFpbmVkQXJiaXRyYXJ5ID0gdGhpcy5jaGFpbmVyKHYudmFsdWVfKTtcbiAgICAgICAgY29uc3QgZHN0ID0gY2hhaW5lZEFyYml0cmFyeS5nZW5lcmF0ZShnZW5lcmF0ZU1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxCaWFzOiBiaWFzRmFjdG9yLFxuICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZTogdi52YWx1ZV8sXG4gICAgICAgICAgICBvcmlnaW5hbENvbnRleHQ6IHYuY29udGV4dCxcbiAgICAgICAgICAgIHN0b3BwZWRGb3JPcmlnaW5hbDogZmFsc2UsXG4gICAgICAgICAgICBjaGFpbmVkQXJiaXRyYXJ5LFxuICAgICAgICAgICAgY2hhaW5lZENvbnRleHQ6IGRzdC5jb250ZXh0LFxuICAgICAgICAgICAgY2xvbmVkTXJuZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlZhbHVlKGRzdC52YWx1ZV8sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpc1NhZmVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ29yaWdpbmFsQmlhcycgaW4gY29udGV4dCAmJlxuICAgICAgICAgICAgJ29yaWdpbmFsVmFsdWUnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbENvbnRleHQnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdzdG9wcGVkRm9yT3JpZ2luYWwnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdjaGFpbmVkQXJiaXRyYXJ5JyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnY2hhaW5lZENvbnRleHQnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdjbG9uZWRNcm5nJyBpbiBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBNYXBBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgbWFwcGVyLCB1bm1hcHBlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBtYXBwZXI7XG4gICAgICAgIHRoaXMudW5tYXBwZXIgPSB1bm1hcHBlcjtcbiAgICAgICAgdGhpcy5iaW5kVmFsdWVNYXBwZXIgPSB0aGlzLnZhbHVlTWFwcGVyLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU1hcHBlcihnKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudW5tYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bm1hcHBlZCA9IHRoaXMudW5tYXBwZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFyYi5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh1bm1hcHBlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pc1NhZmVDb250ZXh0KGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmIuc2hyaW5rKGNvbnRleHQub3JpZ2luYWxWYWx1ZSwgY29udGV4dC5vcmlnaW5hbENvbnRleHQpLm1hcCh0aGlzLmJpbmRWYWx1ZU1hcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5tYXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdW5tYXBwZWQgPSB0aGlzLnVubWFwcGVyKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyYi5zaHJpbmsodW5tYXBwZWQsIHVuZGVmaW5lZCkubWFwKHRoaXMuYmluZFZhbHVlTWFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgIH1cbiAgICBtYXBwZXJXaXRoQ2xvbmVJZk5lZWRlZCh2KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gdi52YWx1ZTtcbiAgICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSB0aGlzLm1hcHBlcihzb3VyY2VWYWx1ZSk7XG4gICAgICAgIGlmICh2Lmhhc1RvQmVDbG9uZWQgJiZcbiAgICAgICAgICAgICgodHlwZW9mIG1hcHBlZFZhbHVlID09PSAnb2JqZWN0JyAmJiBtYXBwZWRWYWx1ZSAhPT0gbnVsbCkgfHwgdHlwZW9mIG1hcHBlZFZhbHVlID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZShtYXBwZWRWYWx1ZSkgJiZcbiAgICAgICAgICAgICEoMCwgc3ltYm9sc18xLmhhc0Nsb25lTWV0aG9kKShtYXBwZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXBwZWRWYWx1ZSwgc3ltYm9sc18xLmNsb25lTWV0aG9kLCB7IGdldDogKCkgPT4gKCkgPT4gdGhpcy5tYXBwZXJXaXRoQ2xvbmVJZk5lZWRlZCh2KVswXSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21hcHBlZFZhbHVlLCBzb3VyY2VWYWx1ZV07XG4gICAgfVxuICAgIHZhbHVlTWFwcGVyKHYpIHtcbiAgICAgICAgY29uc3QgW21hcHBlZFZhbHVlLCBzb3VyY2VWYWx1ZV0gPSB0aGlzLm1hcHBlcldpdGhDbG9uZUlmTmVlZGVkKHYpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBvcmlnaW5hbFZhbHVlOiBzb3VyY2VWYWx1ZSwgb3JpZ2luYWxDb250ZXh0OiB2LmNvbnRleHQgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlZhbHVlKG1hcHBlZFZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaXNTYWZlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoY29udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbFZhbHVlJyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnb3JpZ2luYWxDb250ZXh0JyBpbiBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBGaWx0ZXJBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgcmVmaW5lbWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gcmVmaW5lbWVudDtcbiAgICAgICAgdGhpcy5iaW5kUmVmaW5lbWVudE9uVmFsdWUgPSB0aGlzLnJlZmluZW1lbnRPblZhbHVlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmluZW1lbnRPblZhbHVlKGcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSAmJiB0aGlzLnJlZmluZW1lbnQodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayh2YWx1ZSwgY29udGV4dCkuZmlsdGVyKHRoaXMuYmluZFJlZmluZW1lbnRPblZhbHVlKTtcbiAgICB9XG4gICAgcmVmaW5lbWVudE9uVmFsdWUodikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KHYudmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIE5vU2hyaW5rQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsoX3ZhbHVlLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgIH1cbiAgICBub1NocmluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgTm9CaWFzQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIF9iaWFzRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIG5vQmlhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBcmJpdHJhcnkoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnN0YW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgaW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICAgICAgJ2dlbmVyYXRlJyBpbiBpbnN0YW5jZSAmJlxuICAgICAgICAnc2hyaW5rJyBpbiBpbnN0YW5jZSAmJlxuICAgICAgICAnY2FuU2hyaW5rV2l0aG91dENvbnRleHQnIGluIGluc3RhbmNlKTtcbn1cbmV4cG9ydHMuaXNBcmJpdHJhcnkgPSBpc0FyYml0cmFyeTtcbmZ1bmN0aW9uIGFzc2VydElzQXJiaXRyYXJ5KGluc3RhbmNlKSB7XG4gICAgaWYgKCFpc0FyYml0cmFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIHJlY2VpdmVkOiBub3QgYW4gaW5zdGFuY2Ugb2YgQXJiaXRyYXJ5Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRJc0FyYml0cmFyeSA9IGFzc2VydElzQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlID0gdm9pZCAwO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL3N5bWJvbHNcIik7XG5jbGFzcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVfLCBjb250ZXh0LCBjdXN0b21HZXRWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZhbHVlXyA9IHZhbHVlXztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5oYXNUb0JlQ2xvbmVkID0gY3VzdG9tR2V0VmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoMCwgc3ltYm9sc18xLmhhc0Nsb25lTWV0aG9kKSh2YWx1ZV8pO1xuICAgICAgICB0aGlzLnJlYWRPbmNlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc1RvQmVDbG9uZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCB7IGdldDogY3VzdG9tR2V0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGN1c3RvbUdldFZhbHVlIDogdGhpcy5nZXRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1RvQmVDbG9uZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkT25jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlX1tzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWUgPSBWYWx1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zY2hlZHVsZWRNb2RlbFJ1biA9IGV4cG9ydHMuYXN5bmNNb2RlbFJ1biA9IGV4cG9ydHMubW9kZWxSdW4gPSB2b2lkIDA7XG5jb25zdCBTY2hlZHVsZWRDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kcy9TY2hlZHVsZWRDb21tYW5kXCIpO1xuY29uc3QgZ2VuZXJpY01vZGVsUnVuID0gKHMsIGNtZHMsIGluaXRpYWxWYWx1ZSwgcnVuQ21kLCB0aGVuKSA9PiB7XG4gICAgcmV0dXJuIHMudGhlbigobykgPT4ge1xuICAgICAgICBjb25zdCB7IG1vZGVsLCByZWFsIH0gPSBvO1xuICAgICAgICBsZXQgc3RhdGUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjbWRzKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoZW4oc3RhdGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVuQ21kKGMsIG1vZGVsLCByZWFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9KTtcbn07XG5jb25zdCBpbnRlcm5hbE1vZGVsUnVuID0gKHMsIGNtZHMpID0+IHtcbiAgICBjb25zdCB0aGVuID0gKF9wLCBjKSA9PiBjKCk7XG4gICAgY29uc3Qgc2V0dXBQcm9kdWNlciA9IHtcbiAgICAgICAgdGhlbjogKGZ1bikgPT4ge1xuICAgICAgICAgICAgZnVuKHMoKSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgY29uc3QgcnVuU3luYyA9IChjbWQsIG0sIHIpID0+IHtcbiAgICAgICAgaWYgKGNtZC5jaGVjayhtKSlcbiAgICAgICAgICAgIGNtZC5ydW4obSwgcik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuZXJpY01vZGVsUnVuKHNldHVwUHJvZHVjZXIsIGNtZHMsIHVuZGVmaW5lZCwgcnVuU3luYywgdGhlbik7XG59O1xuY29uc3QgaXNBc3luY1NldHVwID0gKHMpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHMudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn07XG5jb25zdCBpbnRlcm5hbEFzeW5jTW9kZWxSdW4gPSBhc3luYyAocywgY21kcywgZGVmYXVsdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkgPT4ge1xuICAgIGNvbnN0IHRoZW4gPSAocCwgYykgPT4gcC50aGVuKGMpO1xuICAgIGNvbnN0IHNldHVwUHJvZHVjZXIgPSB7XG4gICAgICAgIHRoZW46IChmdW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IHMoKTtcbiAgICAgICAgICAgIGlmIChpc0FzeW5jU2V0dXAob3V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0LnRoZW4oZnVuKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuKG91dCk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBydW5Bc3luYyA9IGFzeW5jIChjbWQsIG0sIHIpID0+IHtcbiAgICAgICAgaWYgKGF3YWl0IGNtZC5jaGVjayhtKSlcbiAgICAgICAgICAgIGF3YWl0IGNtZC5ydW4obSwgcik7XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgZ2VuZXJpY01vZGVsUnVuKHNldHVwUHJvZHVjZXIsIGNtZHMsIGRlZmF1bHRQcm9taXNlLCBydW5Bc3luYywgdGhlbik7XG59O1xuZnVuY3Rpb24gbW9kZWxSdW4ocywgY21kcykge1xuICAgIGludGVybmFsTW9kZWxSdW4ocywgY21kcyk7XG59XG5leHBvcnRzLm1vZGVsUnVuID0gbW9kZWxSdW47XG5hc3luYyBmdW5jdGlvbiBhc3luY01vZGVsUnVuKHMsIGNtZHMpIHtcbiAgICBhd2FpdCBpbnRlcm5hbEFzeW5jTW9kZWxSdW4ocywgY21kcyk7XG59XG5leHBvcnRzLmFzeW5jTW9kZWxSdW4gPSBhc3luY01vZGVsUnVuO1xuYXN5bmMgZnVuY3Rpb24gc2NoZWR1bGVkTW9kZWxSdW4oc2NoZWR1bGVyLCBzLCBjbWRzKSB7XG4gICAgY29uc3Qgc2NoZWR1bGVkQ29tbWFuZHMgPSAoMCwgU2NoZWR1bGVkQ29tbWFuZF8xLnNjaGVkdWxlQ29tbWFuZHMpKHNjaGVkdWxlciwgY21kcyk7XG4gICAgY29uc3Qgb3V0ID0gaW50ZXJuYWxBc3luY01vZGVsUnVuKHMsIHNjaGVkdWxlZENvbW1hbmRzLCBzY2hlZHVsZXIuc2NoZWR1bGUoUHJvbWlzZS5yZXNvbHZlKCksICdzdGFydE1vZGVsJykpO1xuICAgIGF3YWl0IHNjaGVkdWxlci53YWl0QWxsKCk7XG4gICAgYXdhaXQgb3V0O1xufVxuZXhwb3J0cy5zY2hlZHVsZWRNb2RlbFJ1biA9IHNjaGVkdWxlZE1vZGVsUnVuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlcGxheVBhdGggPSB2b2lkIDA7XG5jbGFzcyBSZXBsYXlQYXRoIHtcbiAgICBzdGF0aWMgcGFyc2UocmVwbGF5UGF0aFN0cikge1xuICAgICAgICBjb25zdCBbc2VyaWFsaXplZENvdW50LCBzZXJpYWxpemVkQ2hhbmdlc10gPSByZXBsYXlQYXRoU3RyLnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHRoaXMucGFyc2VDb3VudHMoc2VyaWFsaXplZENvdW50KTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMucGFyc2VDaGFuZ2VzKHNlcmlhbGl6ZWRDaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPY2N1cmVuY2VzKGNvdW50cywgY2hhbmdlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpbmdpZnkocmVwbGF5UGF0aCkge1xuICAgICAgICBjb25zdCBvY2N1cmVuY2VzID0gdGhpcy5jb3VudE9jY3VyZW5jZXMocmVwbGF5UGF0aCk7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDb3VudCA9IHRoaXMuc3RyaW5naWZ5Q291bnRzKG9jY3VyZW5jZXMpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hhbmdlcyA9IHRoaXMuc3RyaW5naWZ5Q2hhbmdlcyhvY2N1cmVuY2VzKTtcbiAgICAgICAgcmV0dXJuIGAke3NlcmlhbGl6ZWRDb3VudH06JHtzZXJpYWxpemVkQ2hhbmdlc31gO1xuICAgIH1cbiAgICBzdGF0aWMgaW50VG9CNjQobikge1xuICAgICAgICBpZiAobiA8IDI2KVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobiArIDY1KTtcbiAgICAgICAgaWYgKG4gPCA1MilcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gKyA5NyAtIDI2KTtcbiAgICAgICAgaWYgKG4gPCA2MilcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gKyA0OCAtIDUyKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobiA9PT0gNjIgPyA0MyA6IDQ3KTtcbiAgICB9XG4gICAgc3RhdGljIGI2NFRvSW50KGMpIHtcbiAgICAgICAgaWYgKGMgPj0gJ2EnKVxuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtIDk3ICsgMjY7XG4gICAgICAgIGlmIChjID49ICdBJylcbiAgICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSA2NTtcbiAgICAgICAgaWYgKGMgPj0gJzAnKVxuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtIDQ4ICsgNTI7XG4gICAgICAgIHJldHVybiBjID09PSAnKycgPyA2MiA6IDYzO1xuICAgIH1cbiAgICBzdGF0aWMgY291bnRPY2N1cmVuY2VzKHJlcGxheVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxheVBhdGgucmVkdWNlKChjb3VudHMsIGN1cikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50cy5sZW5ndGggPT09IDAgfHwgY291bnRzW2NvdW50cy5sZW5ndGggLSAxXS5jb3VudCA9PT0gNjQgfHwgY291bnRzW2NvdW50cy5sZW5ndGggLSAxXS52YWx1ZSAhPT0gY3VyKVxuICAgICAgICAgICAgICAgIGNvdW50cy5wdXNoKHsgdmFsdWU6IGN1ciwgY291bnQ6IDEgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY291bnRzW2NvdW50cy5sZW5ndGggLSAxXS5jb3VudCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50cztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VPY2N1cmVuY2VzKGNvdW50cywgY2hhbmdlcykge1xuICAgICAgICBjb25zdCByZXBsYXlQYXRoID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gY291bnRzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRzW2lkeF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbaWR4XTtcbiAgICAgICAgICAgIGZvciAobGV0IG51bSA9IDA7IG51bSAhPT0gY291bnQ7ICsrbnVtKVxuICAgICAgICAgICAgICAgIHJlcGxheVBhdGgucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxheVBhdGg7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpbmdpZnlDaGFuZ2VzKG9jY3VyZW5jZXMpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWRDaGFuZ2VzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG9jY3VyZW5jZXMubGVuZ3RoOyBpZHggKz0gNikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlc0ludCA9IG9jY3VyZW5jZXNcbiAgICAgICAgICAgICAgICAuc2xpY2UoaWR4LCBpZHggKyA2KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2VSaWdodCgocHJldiwgY3VyKSA9PiBwcmV2ICogMiArIChjdXIudmFsdWUgPyAxIDogMCksIDApO1xuICAgICAgICAgICAgc2VyaWFsaXplZENoYW5nZXMgKz0gdGhpcy5pbnRUb0I2NChjaGFuZ2VzSW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZENoYW5nZXM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUNoYW5nZXMoc2VyaWFsaXplZENoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlc0ludCA9IHNlcmlhbGl6ZWRDaGFuZ2VzLnNwbGl0KCcnKS5tYXAoKGMpID0+IHRoaXMuYjY0VG9JbnQoYykpO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gY2hhbmdlc0ludC5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNoYW5nZXNJbnRbaWR4XTtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuICE9PSA2OyArK24sIGN1cnJlbnQgPj49IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goY3VycmVudCAlIDIgPT09IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbiAgICBzdGF0aWMgc3RyaW5naWZ5Q291bnRzKG9jY3VyZW5jZXMpIHtcbiAgICAgICAgcmV0dXJuIG9jY3VyZW5jZXMubWFwKCh7IGNvdW50IH0pID0+IHRoaXMuaW50VG9CNjQoY291bnQgLSAxKSkuam9pbignJyk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUNvdW50cyhzZXJpYWxpemVkQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDb3VudC5zcGxpdCgnJykubWFwKChjKSA9PiB0aGlzLmI2NFRvSW50KGMpICsgMSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXBsYXlQYXRoID0gUmVwbGF5UGF0aDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tYW5kV3JhcHBlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmluZ2lmeV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL3N0cmluZ2lmeVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zeW1ib2xzXCIpO1xuY2xhc3MgQ29tbWFuZFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNtZCkge1xuICAgICAgICB0aGlzLmNtZCA9IGNtZDtcbiAgICAgICAgdGhpcy5oYXNSYW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKCgwLCBzdHJpbmdpZnlfMS5oYXNUb1N0cmluZ01ldGhvZCkoY21kKSkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gY21kW3N0cmluZ2lmeV8xLnRvU3RyaW5nTWV0aG9kXTtcbiAgICAgICAgICAgIHRoaXNbc3RyaW5naWZ5XzEudG9TdHJpbmdNZXRob2RdID0gZnVuY3Rpb24gdG9TdHJpbmdNZXRob2QoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGNtZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgc3RyaW5naWZ5XzEuaGFzQXN5bmNUb1N0cmluZ01ldGhvZCkoY21kKSkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gY21kW3N0cmluZ2lmeV8xLmFzeW5jVG9TdHJpbmdNZXRob2RdO1xuICAgICAgICAgICAgdGhpc1tzdHJpbmdpZnlfMS5hc3luY1RvU3RyaW5nTWV0aG9kXSA9IGZ1bmN0aW9uIGFzeW5jVG9TdHJpbmdNZXRob2QoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGNtZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21kLmNoZWNrKG0pO1xuICAgIH1cbiAgICBydW4obSwgcikge1xuICAgICAgICB0aGlzLmhhc1JhbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmNtZC5ydW4obSwgcik7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBpZiAoKDAsIHN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZCkodGhpcy5jbWQpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21tYW5kV3JhcHBlcih0aGlzLmNtZFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCkpO1xuICAgICAgICByZXR1cm4gbmV3IENvbW1hbmRXcmFwcGVyKHRoaXMuY21kKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtZC50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tbWFuZFdyYXBwZXIgPSBDb21tYW5kV3JhcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tYW5kc0l0ZXJhYmxlID0gdm9pZCAwO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL3N5bWJvbHNcIik7XG5jbGFzcyBDb21tYW5kc0l0ZXJhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kcywgbWV0YWRhdGFGb3JSZXBsYXkpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IGNvbW1hbmRzO1xuICAgICAgICB0aGlzLm1ldGFkYXRhRm9yUmVwbGF5ID0gbWV0YWRhdGFGb3JSZXBsYXk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbW1hbmRzSXRlcmFibGUodGhpcy5jb21tYW5kcy5tYXAoKGMpID0+IGMuY2xvbmUoKSksIHRoaXMubWV0YWRhdGFGb3JSZXBsYXkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENvbW1hbmRzID0gdGhpcy5jb21tYW5kc1xuICAgICAgICAgICAgLmZpbHRlcigoYykgPT4gYy5oYXNSYW4pXG4gICAgICAgICAgICAubWFwKChjKSA9PiBjLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFGb3JSZXBsYXkoKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmxlbmd0aCAhPT0gMCA/IGAke3NlcmlhbGl6ZWRDb21tYW5kc30gLyoke21ldGFkYXRhfSovYCA6IHNlcmlhbGl6ZWRDb21tYW5kcztcbiAgICB9XG59XG5leHBvcnRzLkNvbW1hbmRzSXRlcmFibGUgPSBDb21tYW5kc0l0ZXJhYmxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjaGVkdWxlQ29tbWFuZHMgPSBleHBvcnRzLlNjaGVkdWxlZENvbW1hbmQgPSB2b2lkIDA7XG5jbGFzcyBTY2hlZHVsZWRDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcihzLCBjbWQpIHtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5jbWQgPSBjbWQ7XG4gICAgfVxuICAgIGFzeW5jIGNoZWNrKG0pIHtcbiAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgbGV0IGNoZWNrUGFzc2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMucy5zY2hlZHVsZVNlcXVlbmNlKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogYGNoZWNrQCR7dGhpcy5jbWQudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgIGJ1aWxkZXI6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUGFzc2VkID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMuY21kLmNoZWNrKG0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKS50YXNrO1xuICAgICAgICBpZiAoc3RhdHVzLmZhdWx0eSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoZWNrUGFzc2VkO1xuICAgIH1cbiAgICBhc3luYyBydW4obSwgcikge1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLnMuc2NoZWR1bGVTZXF1ZW5jZShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGBydW5AJHt0aGlzLmNtZC50b1N0cmluZygpfWAsXG4gICAgICAgICAgICAgICAgYnVpbGRlcjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbWQucnVuKG0sIHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLnRhc2s7XG4gICAgICAgIGlmIChzdGF0dXMuZmF1bHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2NoZWR1bGVkQ29tbWFuZCA9IFNjaGVkdWxlZENvbW1hbmQ7XG5jb25zdCBzY2hlZHVsZUNvbW1hbmRzID0gZnVuY3Rpb24qIChzLCBjbWRzKSB7XG4gICAgZm9yIChjb25zdCBjbWQgb2YgY21kcykge1xuICAgICAgICB5aWVsZCBuZXcgU2NoZWR1bGVkQ29tbWFuZChzLCBjbWQpO1xuICAgIH1cbn07XG5leHBvcnRzLnNjaGVkdWxlQ29tbWFuZHMgPSBzY2hlZHVsZUNvbW1hbmRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZSA9IHZvaWQgMDtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5mdW5jdGlvbiBwcmUoZXhwZWN0VHJ1dGh5KSB7XG4gICAgaWYgKCFleHBlY3RUcnV0aHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5wcmUgPSBwcmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJlY29uZGl0aW9uRmFpbHVyZSA9IHZvaWQgMDtcbmNsYXNzIFByZWNvbmRpdGlvbkZhaWx1cmUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaW50ZXJydXB0RXhlY3V0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRFeGVjdXRpb24gPSBpbnRlcnJ1cHRFeGVjdXRpb247XG4gICAgICAgIHRoaXMuZm9vdHByaW50ID0gUHJlY29uZGl0aW9uRmFpbHVyZS5TaGFyZWRGb290UHJpbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBpc0ZhaWx1cmUoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnIgIT0gbnVsbCAmJiBlcnIuZm9vdHByaW50ID09PSBQcmVjb25kaXRpb25GYWlsdXJlLlNoYXJlZEZvb3RQcmludDtcbiAgICB9XG59XG5leHBvcnRzLlByZWNvbmRpdGlvbkZhaWx1cmUgPSBQcmVjb25kaXRpb25GYWlsdXJlO1xuUHJlY29uZGl0aW9uRmFpbHVyZS5TaGFyZWRGb290UHJpbnQgPSBTeW1ib2woJ2Zhc3QtY2hlY2svUHJlY29uZGl0aW9uRmFpbHVyZScpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzeW5jUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi4vcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5jb25zdCBJUmF3UHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL0lSYXdQcm9wZXJ0eVwiKTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uZXIvY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IE5vVW5kZWZpbmVkQXNDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9Ob1VuZGVmaW5lZEFzQ29udGV4dFwiKTtcbmNsYXNzIEFzeW5jUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgcHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgY29uc3QgeyBhc3luY0JlZm9yZUVhY2gsIGFzeW5jQWZ0ZXJFYWNoLCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSA9ICgwLCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCkoKSB8fCB7fTtcbiAgICAgICAgaWYgKGFzeW5jQmVmb3JlRWFjaCAhPT0gdW5kZWZpbmVkICYmIGJlZm9yZUVhY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0dsb2JhbCBcImFzeW5jQmVmb3JlRWFjaFwiIGFuZCBcImJlZm9yZUVhY2hcIiBwYXJhbWV0ZXJzIGNhblxcJ3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWUgd2hlbiBydW5uaW5nIGFzeW5jIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN5bmNBZnRlckVhY2ggIT09IHVuZGVmaW5lZCAmJiBhZnRlckVhY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0dsb2JhbCBcImFzeW5jQWZ0ZXJFYWNoXCIgYW5kIFwiYWZ0ZXJFYWNoXCIgcGFyYW1ldGVycyBjYW5cXCd0IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lIHdoZW4gcnVubmluZyBhc3luYyBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWZvcmVFYWNoSG9vayA9IGFzeW5jQmVmb3JlRWFjaCB8fCBiZWZvcmVFYWNoIHx8IEFzeW5jUHJvcGVydHkuZHVtbXlIb29rO1xuICAgICAgICB0aGlzLmFmdGVyRWFjaEhvb2sgPSBhc3luY0FmdGVyRWFjaCB8fCBhZnRlckVhY2ggfHwgQXN5bmNQcm9wZXJ0eS5kdW1teUhvb2s7XG4gICAgfVxuICAgIGlzQXN5bmMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBydW5JZCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIHJ1bklkICE9IG51bGwgPyAoMCwgSVJhd1Byb3BlcnR5XzEucnVuSWRUb0ZyZXF1ZW5jeSkocnVuSWQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuICgwLCBOb1VuZGVmaW5lZEFzQ29udGV4dF8xLm5vVW5kZWZpbmVkQXNDb250ZXh0KSh2YWx1ZSk7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuY29udGV4dCA9PT0gdW5kZWZpbmVkICYmICF0aGlzLmFyYi5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZS52YWx1ZV8pKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhZmVDb250ZXh0ID0gdmFsdWUuY29udGV4dCAhPT0gTm9VbmRlZmluZWRBc0NvbnRleHRfMS5VbmRlZmluZWRDb250ZXh0UGxhY2Vob2xkZXIgPyB2YWx1ZS5jb250ZXh0IDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuc2hyaW5rKHZhbHVlLnZhbHVlXywgc2FmZUNvbnRleHQpLm1hcChOb1VuZGVmaW5lZEFzQ29udGV4dF8xLm5vVW5kZWZpbmVkQXNDb250ZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgcnVuKHYpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVFYWNoSG9vaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5wcmVkaWNhdGUodik7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0ID09IG51bGwgfHwgb3V0cHV0ID09PSB0cnVlXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiB7IGVycm9yOiB1bmRlZmluZWQsIGVycm9yTWVzc2FnZTogJ1Byb3BlcnR5IGZhaWxlZCBieSByZXR1cm5pbmcgZmFsc2UnIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKFByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlLmlzRmFpbHVyZShlcnIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciwgZXJyb3JNZXNzYWdlOiBgJHtlcnJ9XFxuXFxuU3RhY2sgdHJhY2U6ICR7ZXJyLnN0YWNrfWAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBlcnIsIGVycm9yTWVzc2FnZTogU3RyaW5nKGVycikgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWZ0ZXJFYWNoSG9vaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJlZm9yZUVhY2goaG9va0Z1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQmVmb3JlRWFjaEhvb2sgPSB0aGlzLmJlZm9yZUVhY2hIb29rO1xuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rID0gKCkgPT4gaG9va0Z1bmN0aW9uKHByZXZpb3VzQmVmb3JlRWFjaEhvb2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWZ0ZXJFYWNoKGhvb2tGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91c0FmdGVyRWFjaEhvb2sgPSB0aGlzLmFmdGVyRWFjaEhvb2s7XG4gICAgICAgIHRoaXMuYWZ0ZXJFYWNoSG9vayA9ICgpID0+IGhvb2tGdW5jdGlvbihwcmV2aW91c0FmdGVyRWFjaEhvb2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkFzeW5jUHJvcGVydHkgPSBBc3luY1Byb3BlcnR5O1xuQXN5bmNQcm9wZXJ0eS5kdW1teUhvb2sgPSAoKSA9PiB7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXN5bmNQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeVwiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3R1cGxlXCIpO1xuY29uc3QgQXN5bmNQcm9wZXJ0eV9nZW5lcmljXzEgPSByZXF1aXJlKFwiLi9Bc3luY1Byb3BlcnR5LmdlbmVyaWNcIik7XG5jb25zdCBBbHdheXNTaHJpbmthYmxlQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L19pbnRlcm5hbHMvQWx3YXlzU2hyaW5rYWJsZUFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGFzeW5jUHJvcGVydHkoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3luY1Byb3BlcnR5IGV4cGVjdHMgYXQgbGVhc3QgdHdvIHBhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgYXJicyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBwID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGFyYnMuZm9yRWFjaChBcmJpdHJhcnlfMS5hc3NlcnRJc0FyYml0cmFyeSk7XG4gICAgY29uc3QgbWFwcGVkQXJicyA9IGFyYnMubWFwKChhcmIpID0+IG5ldyBBbHdheXNTaHJpbmthYmxlQXJiaXRyYXJ5XzEuQWx3YXlzU2hyaW5rYWJsZUFyYml0cmFyeShhcmIpKTtcbiAgICByZXR1cm4gbmV3IEFzeW5jUHJvcGVydHlfZ2VuZXJpY18xLkFzeW5jUHJvcGVydHkoKDAsIHR1cGxlXzEudHVwbGUpKC4uLm1hcHBlZEFyYnMpLCAodCkgPT4gcCguLi50KSk7XG59XG5leHBvcnRzLmFzeW5jUHJvcGVydHkgPSBhc3luY1Byb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJ1bklkVG9GcmVxdWVuY3kgPSB2b2lkIDA7XG5jb25zdCBydW5JZFRvRnJlcXVlbmN5ID0gKHJ1bklkKSA9PiAyICsgTWF0aC5mbG9vcihNYXRoLmxvZyhydW5JZCArIDEpIC8gTWF0aC5sb2coMTApKTtcbmV4cG9ydHMucnVuSWRUb0ZyZXF1ZW5jeSA9IHJ1bklkVG9GcmVxdWVuY3k7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IHN0cmluZ2lmeV8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL3N0cmluZ2lmeVwiKTtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuLi9wcmVjb25kaXRpb24vUHJlY29uZGl0aW9uRmFpbHVyZVwiKTtcbmZ1bmN0aW9uIGZyb21TeW5jQ2FjaGVkKGNhY2hlZFZhbHVlKSB7XG4gICAgcmV0dXJuIGNhY2hlZFZhbHVlID09PSBudWxsID8gbmV3IFByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlKCkgOiBjYWNoZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGZyb21DYWNoZWQoLi4uZGF0YSkge1xuICAgIGlmIChkYXRhWzFdKVxuICAgICAgICByZXR1cm4gZGF0YVswXS50aGVuKGZyb21TeW5jQ2FjaGVkKTtcbiAgICByZXR1cm4gZnJvbVN5bmNDYWNoZWQoZGF0YVswXSk7XG59XG5mdW5jdGlvbiBmcm9tQ2FjaGVkVW5zYWZlKGNhY2hlZFZhbHVlLCBpc0FzeW5jKSB7XG4gICAgcmV0dXJuIGZyb21DYWNoZWQoY2FjaGVkVmFsdWUsIGlzQXN5bmMpO1xufVxuY2xhc3MgSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHksIHNraXBSdW5zKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5za2lwUnVucyA9IHNraXBSdW5zO1xuICAgICAgICB0aGlzLmNvdmVyZWRDYXNlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaXNBc3luYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuaXNBc3luYygpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBydW5JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5nZW5lcmF0ZShtcm5nLCBydW5JZCk7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5zaHJpbmsodmFsdWUpO1xuICAgIH1cbiAgICBydW4odikge1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZFZhbHVlID0gKDAsIHN0cmluZ2lmeV8xLnN0cmluZ2lmeSkodik7XG4gICAgICAgIGlmICh0aGlzLmNvdmVyZWRDYXNlcy5oYXMoc3RyaW5naWZpZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RPdXRwdXQgPSB0aGlzLmNvdmVyZWRDYXNlcy5nZXQoc3RyaW5naWZpZWRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2tpcFJ1bnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdE91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2FjaGVkVW5zYWZlKGxhc3RPdXRwdXQsIHRoaXMucHJvcGVydHkuaXNBc3luYygpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLnByb3BlcnR5LnJ1bih2KTtcbiAgICAgICAgdGhpcy5jb3ZlcmVkQ2FzZXMuc2V0KHN0cmluZ2lmaWVkVmFsdWUsIG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuZXhwb3J0cy5JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5ID0gSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuLi9wcmVjb25kaXRpb24vUHJlY29uZGl0aW9uRmFpbHVyZVwiKTtcbmNvbnN0IElSYXdQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vSVJhd1Byb3BlcnR5XCIpO1xuY29uc3QgR2xvYmFsUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4uL3J1bm5lci9jb25maWd1cmF0aW9uL0dsb2JhbFBhcmFtZXRlcnNcIik7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgTm9VbmRlZmluZWRBc0NvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvX2ludGVybmFscy9oZWxwZXJzL05vVW5kZWZpbmVkQXNDb250ZXh0XCIpO1xuY2xhc3MgUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgcHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgY29uc3QgeyBiZWZvcmVFYWNoID0gUHJvcGVydHkuZHVtbXlIb29rLCBhZnRlckVhY2ggPSBQcm9wZXJ0eS5kdW1teUhvb2ssIGFzeW5jQmVmb3JlRWFjaCwgYXN5bmNBZnRlckVhY2gsIH0gPSAoMCwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwpKCkgfHwge307XG4gICAgICAgIGlmIChhc3luY0JlZm9yZUVhY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wiYXN5bmNCZWZvcmVFYWNoXCIgY2FuXFwndCBiZSBzZXQgd2hlbiBydW5uaW5nIHN5bmNocm9ub3VzIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN5bmNBZnRlckVhY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wiYXN5bmNBZnRlckVhY2hcIiBjYW5cXCd0IGJlIHNldCB3aGVuIHJ1bm5pbmcgc3luY2hyb25vdXMgcHJvcGVydGllcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVmb3JlRWFjaEhvb2sgPSBiZWZvcmVFYWNoO1xuICAgICAgICB0aGlzLmFmdGVyRWFjaEhvb2sgPSBhZnRlckVhY2g7XG4gICAgfVxuICAgIGlzQXN5bmMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBydW5JZCAhPSBudWxsID8gKDAsIElSYXdQcm9wZXJ0eV8xLnJ1bklkVG9GcmVxdWVuY3kpKHJ1bklkKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiAoMCwgTm9VbmRlZmluZWRBc0NvbnRleHRfMS5ub1VuZGVmaW5lZEFzQ29udGV4dCkodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnRleHQgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUudmFsdWVfKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlQ29udGV4dCA9IHZhbHVlLmNvbnRleHQgIT09IE5vVW5kZWZpbmVkQXNDb250ZXh0XzEuVW5kZWZpbmVkQ29udGV4dFBsYWNlaG9sZGVyID8gdmFsdWUuY29udGV4dCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayh2YWx1ZS52YWx1ZV8sIHNhZmVDb250ZXh0KS5tYXAoTm9VbmRlZmluZWRBc0NvbnRleHRfMS5ub1VuZGVmaW5lZEFzQ29udGV4dCk7XG4gICAgfVxuICAgIHJ1bih2KSB7XG4gICAgICAgIHRoaXMuYmVmb3JlRWFjaEhvb2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMucHJlZGljYXRlKHYpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCA9PSBudWxsIHx8IG91dHB1dCA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogeyBlcnJvcjogdW5kZWZpbmVkLCBlcnJvck1lc3NhZ2U6ICdQcm9wZXJ0eSBmYWlsZWQgYnkgcmV0dXJuaW5nIGZhbHNlJyB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZS5pc0ZhaWx1cmUoZXJyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBlcnIsIGVycm9yTWVzc2FnZTogYCR7ZXJyfVxcblxcblN0YWNrIHRyYWNlOiAke2Vyci5zdGFja31gIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyLCBlcnJvck1lc3NhZ2U6IFN0cmluZyhlcnIpIH07XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyRWFjaEhvb2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZWZvcmVFYWNoKGhvb2tGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91c0JlZm9yZUVhY2hIb29rID0gdGhpcy5iZWZvcmVFYWNoSG9vaztcbiAgICAgICAgdGhpcy5iZWZvcmVFYWNoSG9vayA9ICgpID0+IGhvb2tGdW5jdGlvbihwcmV2aW91c0JlZm9yZUVhY2hIb29rKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFmdGVyRWFjaChob29rRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBZnRlckVhY2hIb29rID0gdGhpcy5hZnRlckVhY2hIb29rO1xuICAgICAgICB0aGlzLmFmdGVyRWFjaEhvb2sgPSAoKSA9PiBob29rRnVuY3Rpb24ocHJldmlvdXNBZnRlckVhY2hIb29rKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xuUHJvcGVydHkuZHVtbXlIb29rID0gKCkgPT4geyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3BlcnR5ID0gdm9pZCAwO1xuY29uc3QgQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5XCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5jb25zdCBQcm9wZXJ0eV9nZW5lcmljXzEgPSByZXF1aXJlKFwiLi9Qcm9wZXJ0eS5nZW5lcmljXCIpO1xuY29uc3QgQWx3YXlzU2hyaW5rYWJsZUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9faW50ZXJuYWxzL0Fsd2F5c1Nocmlua2FibGVBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBwcm9wZXJ0eSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3BlcnR5IGV4cGVjdHMgYXQgbGVhc3QgdHdvIHBhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgYXJicyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBwID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGFyYnMuZm9yRWFjaChBcmJpdHJhcnlfMS5hc3NlcnRJc0FyYml0cmFyeSk7XG4gICAgY29uc3QgbWFwcGVkQXJicyA9IGFyYnMubWFwKChhcmIpID0+IG5ldyBBbHdheXNTaHJpbmthYmxlQXJiaXRyYXJ5XzEuQWx3YXlzU2hyaW5rYWJsZUFyYml0cmFyeShhcmIpKTtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5X2dlbmVyaWNfMS5Qcm9wZXJ0eSgoMCwgdHVwbGVfMS50dXBsZSkoLi4ubWFwcGVkQXJicyksICh0KSA9PiBwKC4uLnQpKTtcbn1cbmV4cG9ydHMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ta2lwQWZ0ZXJQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuLi9wcmVjb25kaXRpb24vUHJlY29uZGl0aW9uRmFpbHVyZVwiKTtcbmNsYXNzIFNraXBBZnRlclByb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSwgZ2V0VGltZSwgdGltZUxpbWl0LCBpbnRlcnJ1cHRFeGVjdXRpb24pIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICB0aGlzLmdldFRpbWUgPSBnZXRUaW1lO1xuICAgICAgICB0aGlzLmludGVycnVwdEV4ZWN1dGlvbiA9IGludGVycnVwdEV4ZWN1dGlvbjtcbiAgICAgICAgdGhpcy5za2lwQWZ0ZXJUaW1lID0gdGhpcy5nZXRUaW1lKCkgKyB0aW1lTGltaXQ7XG4gICAgfVxuICAgIGlzQXN5bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LmlzQXN5bmMoKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgcnVuSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuZ2VuZXJhdGUobXJuZywgcnVuSWQpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuc2hyaW5rKHZhbHVlKTtcbiAgICB9XG4gICAgcnVuKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGltZSgpID49IHRoaXMuc2tpcEFmdGVyVGltZSkge1xuICAgICAgICAgICAgY29uc3QgcHJlY29uZGl0aW9uRmFpbHVyZSA9IG5ldyBQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZSh0aGlzLmludGVycnVwdEV4ZWN1dGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FzeW5jKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByZWNvbmRpdGlvbkZhaWx1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNvbmRpdGlvbkZhaWx1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkucnVuKHYpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2tpcEFmdGVyUHJvcGVydHkgPSBTa2lwQWZ0ZXJQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaW1lb3V0UHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCB0aW1lb3V0QWZ0ZXIgPSAodGltZU1zKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRIYW5kbGUgPSBudWxsO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHsgZXJyb3I6IHVuZGVmaW5lZCwgZXJyb3JNZXNzYWdlOiBgUHJvcGVydHkgdGltZW91dDogZXhjZWVkZWQgbGltaXQgb2YgJHt0aW1lTXN9IG1pbGxpc2Vjb25kc2AgfSk7XG4gICAgICAgIH0sIHRpbWVNcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXI6ICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKSxcbiAgICAgICAgcHJvbWlzZSxcbiAgICB9O1xufTtcbmNsYXNzIFRpbWVvdXRQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHksIHRpbWVNcykge1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMudGltZU1zID0gdGltZU1zO1xuICAgIH1cbiAgICBpc0FzeW5jKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgcnVuSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuZ2VuZXJhdGUobXJuZywgcnVuSWQpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuc2hyaW5rKHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgcnVuKHYpIHtcbiAgICAgICAgY29uc3QgdCA9IHRpbWVvdXRBZnRlcih0aGlzLnRpbWVNcyk7XG4gICAgICAgIGNvbnN0IHByb3BSdW4gPSBQcm9taXNlLnJhY2UoW3RoaXMucHJvcGVydHkucnVuKHYpLCB0LnByb21pc2VdKTtcbiAgICAgICAgcHJvcFJ1bi50aGVuKHQuY2xlYXIsIHQuY2xlYXIpO1xuICAgICAgICByZXR1cm4gcHJvcFJ1bjtcbiAgICB9XG59XG5leHBvcnRzLlRpbWVvdXRQcm9wZXJ0eSA9IFRpbWVvdXRQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmJpYXNlZFByb3BlcnR5ID0gdm9pZCAwO1xuY2xhc3MgVW5iaWFzZWRQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICBpc0FzeW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5pc0FzeW5jKCk7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIF9ydW5JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5nZW5lcmF0ZShtcm5nLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuc2hyaW5rKHZhbHVlKTtcbiAgICB9XG4gICAgcnVuKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkucnVuKHYpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5iaWFzZWRQcm9wZXJ0eSA9IFVuYmlhc2VkUHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb3JhdGVQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IFNraXBBZnRlclByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvU2tpcEFmdGVyUHJvcGVydHlcIik7XG5jb25zdCBUaW1lb3V0UHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuLi9wcm9wZXJ0eS9UaW1lb3V0UHJvcGVydHlcIik7XG5jb25zdCBVbmJpYXNlZFByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvVW5iaWFzZWRQcm9wZXJ0eVwiKTtcbmNvbnN0IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuLi9wcm9wZXJ0eS9JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5XCIpO1xuZnVuY3Rpb24gZGVjb3JhdGVQcm9wZXJ0eShyYXdQcm9wZXJ0eSwgcVBhcmFtcykge1xuICAgIGxldCBwcm9wID0gcmF3UHJvcGVydHk7XG4gICAgaWYgKHJhd1Byb3BlcnR5LmlzQXN5bmMoKSAmJiBxUGFyYW1zLnRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBwcm9wID0gbmV3IFRpbWVvdXRQcm9wZXJ0eV8xLlRpbWVvdXRQcm9wZXJ0eShwcm9wLCBxUGFyYW1zLnRpbWVvdXQpO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy51bmJpYXNlZCkge1xuICAgICAgICBwcm9wID0gbmV3IFVuYmlhc2VkUHJvcGVydHlfMS5VbmJpYXNlZFByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy5za2lwQWxsQWZ0ZXJUaW1lTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBwcm9wID0gbmV3IFNraXBBZnRlclByb3BlcnR5XzEuU2tpcEFmdGVyUHJvcGVydHkocHJvcCwgRGF0ZS5ub3csIHFQYXJhbXMuc2tpcEFsbEFmdGVyVGltZUxpbWl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChxUGFyYW1zLmludGVycnVwdEFmdGVyVGltZUxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBTa2lwQWZ0ZXJQcm9wZXJ0eV8xLlNraXBBZnRlclByb3BlcnR5KHByb3AsIERhdGUubm93LCBxUGFyYW1zLmludGVycnVwdEFmdGVyVGltZUxpbWl0LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHFQYXJhbXMuc2tpcEVxdWFsVmFsdWVzKSB7XG4gICAgICAgIHByb3AgPSBuZXcgSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eV8xLklnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkocHJvcCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChxUGFyYW1zLmlnbm9yZUVxdWFsVmFsdWVzKSB7XG4gICAgICAgIHByb3AgPSBuZXcgSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eV8xLklnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkocHJvcCwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcDtcbn1cbmV4cG9ydHMuZGVjb3JhdGVQcm9wZXJ0eSA9IGRlY29yYXRlUHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5jaGVjayA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBHbG9iYWxQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uL0dsb2JhbFBhcmFtZXRlcnNcIik7XG5jb25zdCBRdWFsaWZpZWRQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uL1F1YWxpZmllZFBhcmFtZXRlcnNcIik7XG5jb25zdCBEZWNvcmF0ZVByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9EZWNvcmF0ZVByb3BlcnR5XCIpO1xuY29uc3QgUnVubmVySXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL1J1bm5lckl0ZXJhdG9yXCIpO1xuY29uc3QgU291cmNlVmFsdWVzSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL1NvdXJjZVZhbHVlc0l0ZXJhdG9yXCIpO1xuY29uc3QgVG9zc2VyXzEgPSByZXF1aXJlKFwiLi9Ub3NzZXJcIik7XG5jb25zdCBQYXRoV2Fsa2VyXzEgPSByZXF1aXJlKFwiLi91dGlscy9QYXRoV2Fsa2VyXCIpO1xuY29uc3QgUnVuRGV0YWlsc0Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvUnVuRGV0YWlsc0Zvcm1hdHRlclwiKTtcbmZ1bmN0aW9uIHJ1bkl0KHByb3BlcnR5LCBzaHJpbmssIHNvdXJjZVZhbHVlcywgdmVyYm9zZSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgUnVubmVySXRlcmF0b3JfMS5SdW5uZXJJdGVyYXRvcihzb3VyY2VWYWx1ZXMsIHNocmluaywgdmVyYm9zZSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpO1xuICAgIGZvciAoY29uc3QgdiBvZiBydW5uZXIpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gcHJvcGVydHkucnVuKHYpO1xuICAgICAgICBydW5uZXIuaGFuZGxlUmVzdWx0KG91dCk7XG4gICAgfVxuICAgIHJldHVybiBydW5uZXIucnVuRXhlY3V0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gYXN5bmNSdW5JdChwcm9wZXJ0eSwgc2hyaW5rLCBzb3VyY2VWYWx1ZXMsIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IFJ1bm5lckl0ZXJhdG9yXzEuUnVubmVySXRlcmF0b3Ioc291cmNlVmFsdWVzLCBzaHJpbmssIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IGF3YWl0IHByb3BlcnR5LnJ1bih2KTtcbiAgICAgICAgcnVubmVyLmhhbmRsZVJlc3VsdChvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gcnVubmVyLnJ1bkV4ZWN1dGlvbjtcbn1cbmZ1bmN0aW9uIHJ1bm5lclBhdGhXYWxrZXIodmFsdWVQcm9kdWNlcnMsIHNocmluaywgcGF0aCkge1xuICAgIGNvbnN0IHBhdGhQb2ludHMgPSBwYXRoLnNwbGl0KCc6Jyk7XG4gICAgY29uc3QgcGF0aFN0cmVhbSA9ICgwLCBTdHJlYW1fMS5zdHJlYW0pKHZhbHVlUHJvZHVjZXJzKVxuICAgICAgICAuZHJvcChwYXRoUG9pbnRzLmxlbmd0aCA+IDAgPyArcGF0aFBvaW50c1swXSA6IDApXG4gICAgICAgIC5tYXAoKHByb2R1Y2VyKSA9PiBwcm9kdWNlcigpKTtcbiAgICBjb25zdCBhZGFwdGVkUGF0aCA9IFsnMCcsIC4uLnBhdGhQb2ludHMuc2xpY2UoMSldLmpvaW4oJzonKTtcbiAgICByZXR1cm4gKDAsIFN0cmVhbV8xLnN0cmVhbSkoKDAsIFBhdGhXYWxrZXJfMS5wYXRoV2FsaykoYWRhcHRlZFBhdGgsIHBhdGhTdHJlYW0sIHNocmluaykpLm1hcCgodikgPT4gKCkgPT4gdik7XG59XG5mdW5jdGlvbiBidWlsZEluaXRpYWxWYWx1ZXModmFsdWVQcm9kdWNlcnMsIHNocmluaywgcVBhcmFtcykge1xuICAgIGlmIChxUGFyYW1zLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAoMCwgU3RyZWFtXzEuc3RyZWFtKSh2YWx1ZVByb2R1Y2Vycyk7XG4gICAgfVxuICAgIHJldHVybiBydW5uZXJQYXRoV2Fsa2VyKHZhbHVlUHJvZHVjZXJzLCBzaHJpbmssIHFQYXJhbXMucGF0aCk7XG59XG5mdW5jdGlvbiBjaGVjayhyYXdQcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgaWYgKHJhd1Byb3BlcnR5ID09IG51bGwgfHwgcmF3UHJvcGVydHkuZ2VuZXJhdGUgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb3BlcnR5IGVuY291bnRlcmVkLCBwbGVhc2UgdXNlIGEgdmFsaWQgcHJvcGVydHknKTtcbiAgICBpZiAocmF3UHJvcGVydHkucnVuID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSBlbmNvdW50ZXJlZCwgcGxlYXNlIHVzZSBhIHZhbGlkIHByb3BlcnR5IG5vdCBhbiBhcmJpdHJhcnknKTtcbiAgICBjb25zdCBxUGFyYW1zID0gUXVhbGlmaWVkUGFyYW1ldGVyc18xLlF1YWxpZmllZFBhcmFtZXRlcnMucmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCkoKSksIHBhcmFtcykpO1xuICAgIGlmIChxUGFyYW1zLnJlcG9ydGVyICE9PSBudWxsICYmIHFQYXJhbXMuYXN5bmNSZXBvcnRlciAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcnMgZW5jb3VudGVyZWQsIHJlcG9ydGVyIGFuZCBhc3luY1JlcG9ydGVyIGNhbm5vdCBiZSBzcGVjaWZpZWQgdG9nZXRoZXInKTtcbiAgICBpZiAocVBhcmFtcy5hc3luY1JlcG9ydGVyICE9PSBudWxsICYmICFyYXdQcm9wZXJ0eS5pc0FzeW5jKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXJzIGVuY291bnRlcmVkLCBvbmx5IGFzeW5jUHJvcGVydHkgY2FuIGJlIHVzZWQgd2hlbiBhc3luY1JlcG9ydGVyIHNwZWNpZmllZCcpO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gKDAsIERlY29yYXRlUHJvcGVydHlfMS5kZWNvcmF0ZVByb3BlcnR5KShyYXdQcm9wZXJ0eSwgcVBhcmFtcyk7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gKDAsIFRvc3Nlcl8xLnRvc3MpKHByb3BlcnR5LCBxUGFyYW1zLnNlZWQsIHFQYXJhbXMucmFuZG9tVHlwZSwgcVBhcmFtcy5leGFtcGxlcyk7XG4gICAgY29uc3QgbWF4SW5pdGlhbEl0ZXJhdGlvbnMgPSBxUGFyYW1zLnBhdGguaW5kZXhPZignOicpID09PSAtMSA/IHFQYXJhbXMubnVtUnVucyA6IC0xO1xuICAgIGNvbnN0IG1heFNraXBzID0gcVBhcmFtcy5udW1SdW5zICogcVBhcmFtcy5tYXhTa2lwc1BlclJ1bjtcbiAgICBjb25zdCBzaHJpbmsgPSBwcm9wZXJ0eS5zaHJpbmsuYmluZChwcm9wZXJ0eSk7XG4gICAgY29uc3QgaW5pdGlhbFZhbHVlcyA9IGJ1aWxkSW5pdGlhbFZhbHVlcyhnZW5lcmF0b3IsIHNocmluaywgcVBhcmFtcyk7XG4gICAgY29uc3Qgc291cmNlVmFsdWVzID0gbmV3IFNvdXJjZVZhbHVlc0l0ZXJhdG9yXzEuU291cmNlVmFsdWVzSXRlcmF0b3IoaW5pdGlhbFZhbHVlcywgbWF4SW5pdGlhbEl0ZXJhdGlvbnMsIG1heFNraXBzKTtcbiAgICBjb25zdCBmaW5hbFNocmluayA9ICFxUGFyYW1zLmVuZE9uRmFpbHVyZSA/IHNocmluayA6IFN0cmVhbV8xLlN0cmVhbS5uaWw7XG4gICAgcmV0dXJuIHByb3BlcnR5LmlzQXN5bmMoKVxuICAgICAgICA/IGFzeW5jUnVuSXQocHJvcGVydHksIGZpbmFsU2hyaW5rLCBzb3VyY2VWYWx1ZXMsIHFQYXJhbXMudmVyYm9zZSwgcVBhcmFtcy5tYXJrSW50ZXJydXB0QXNGYWlsdXJlKS50aGVuKChlKSA9PiBlLnRvUnVuRGV0YWlscyhxUGFyYW1zLnNlZWQsIHFQYXJhbXMucGF0aCwgbWF4U2tpcHMsIHFQYXJhbXMpKVxuICAgICAgICA6IHJ1bkl0KHByb3BlcnR5LCBmaW5hbFNocmluaywgc291cmNlVmFsdWVzLCBxUGFyYW1zLnZlcmJvc2UsIHFQYXJhbXMubWFya0ludGVycnVwdEFzRmFpbHVyZSkudG9SdW5EZXRhaWxzKHFQYXJhbXMuc2VlZCwgcVBhcmFtcy5wYXRoLCBtYXhTa2lwcywgcVBhcmFtcyk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBhc3NlcnQocHJvcGVydHksIHBhcmFtcykge1xuICAgIGNvbnN0IG91dCA9IGNoZWNrKHByb3BlcnR5LCBwYXJhbXMpO1xuICAgIGlmIChwcm9wZXJ0eS5pc0FzeW5jKCkpXG4gICAgICAgIHJldHVybiBvdXQudGhlbihSdW5EZXRhaWxzRm9ybWF0dGVyXzEuYXN5bmNSZXBvcnRSdW5EZXRhaWxzKTtcbiAgICBlbHNlXG4gICAgICAgICgwLCBSdW5EZXRhaWxzRm9ybWF0dGVyXzEucmVwb3J0UnVuRGV0YWlscykob3V0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bm5lckl0ZXJhdG9yID0gdm9pZCAwO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4uL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuY29uc3QgUnVuRXhlY3V0aW9uXzEgPSByZXF1aXJlKFwiLi9yZXBvcnRlci9SdW5FeGVjdXRpb25cIik7XG5jbGFzcyBSdW5uZXJJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlVmFsdWVzLCBzaHJpbmssIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKSB7XG4gICAgICAgIHRoaXMuc291cmNlVmFsdWVzID0gc291cmNlVmFsdWVzO1xuICAgICAgICB0aGlzLnNocmluayA9IHNocmluaztcbiAgICAgICAgdGhpcy5ydW5FeGVjdXRpb24gPSBuZXcgUnVuRXhlY3V0aW9uXzEuUnVuRXhlY3V0aW9uKHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50SWR4ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dFZhbHVlcyA9IHNvdXJjZVZhbHVlcztcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSB0aGlzLm5leHRWYWx1ZXMubmV4dCgpO1xuICAgICAgICBpZiAobmV4dFZhbHVlLmRvbmUgfHwgdGhpcy5ydW5FeGVjdXRpb24uaW50ZXJydXB0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZS52YWx1ZTtcbiAgICAgICAgKyt0aGlzLmN1cnJlbnRJZHg7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogbmV4dFZhbHVlLnZhbHVlLnZhbHVlXyB9O1xuICAgIH1cbiAgICBoYW5kbGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAhUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmUuaXNGYWlsdXJlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uLmZhaWwodGhpcy5jdXJyZW50VmFsdWUudmFsdWVfLCB0aGlzLmN1cnJlbnRJZHgsIHJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJZHggPSAtMTtcbiAgICAgICAgICAgIHRoaXMubmV4dFZhbHVlcyA9IHRoaXMuc2hyaW5rKHRoaXMuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuaW50ZXJydXB0RXhlY3V0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5FeGVjdXRpb24uc2tpcCh0aGlzLmN1cnJlbnRWYWx1ZS52YWx1ZV8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlVmFsdWVzLnNraXBwZWRPbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uLmludGVycnVwdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ydW5FeGVjdXRpb24uc3VjY2Vzcyh0aGlzLmN1cnJlbnRWYWx1ZS52YWx1ZV8pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uZXJJdGVyYXRvciA9IFJ1bm5lckl0ZXJhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0YXRpc3RpY3MgPSBleHBvcnRzLnNhbXBsZSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBQcm9wZXJ0eV9nZW5lcmljXzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvUHJvcGVydHkuZ2VuZXJpY1wiKTtcbmNvbnN0IFVuYmlhc2VkUHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuLi9wcm9wZXJ0eS9VbmJpYXNlZFByb3BlcnR5XCIpO1xuY29uc3QgR2xvYmFsUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuY29uc3QgUXVhbGlmaWVkUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi9RdWFsaWZpZWRQYXJhbWV0ZXJzXCIpO1xuY29uc3QgVG9zc2VyXzEgPSByZXF1aXJlKFwiLi9Ub3NzZXJcIik7XG5jb25zdCBQYXRoV2Fsa2VyXzEgPSByZXF1aXJlKFwiLi91dGlscy9QYXRoV2Fsa2VyXCIpO1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eShnZW5lcmF0b3IsIHFQYXJhbXMpIHtcbiAgICBjb25zdCBwcm9wID0gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnZW5lcmF0b3IsICdpc0FzeW5jJylcbiAgICAgICAgPyBuZXcgUHJvcGVydHlfZ2VuZXJpY18xLlByb3BlcnR5KGdlbmVyYXRvciwgKCkgPT4gdHJ1ZSlcbiAgICAgICAgOiBnZW5lcmF0b3I7XG4gICAgcmV0dXJuIHFQYXJhbXMudW5iaWFzZWQgPT09IHRydWUgPyBuZXcgVW5iaWFzZWRQcm9wZXJ0eV8xLlVuYmlhc2VkUHJvcGVydHkocHJvcCkgOiBwcm9wO1xufVxuZnVuY3Rpb24gc3RyZWFtU2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXh0ZW5kZWRQYXJhbXMgPSB0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJ1xuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKDAsIEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKSgpKSwgeyBudW1SdW5zOiBwYXJhbXMgfSkgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCkoKSksIHBhcmFtcyk7XG4gICAgY29uc3QgcVBhcmFtcyA9IFF1YWxpZmllZFBhcmFtZXRlcnNfMS5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWQoZXh0ZW5kZWRQYXJhbXMpO1xuICAgIGNvbnN0IG5leHRQcm9wZXJ0eSA9IHRvUHJvcGVydHkoZ2VuZXJhdG9yLCBxUGFyYW1zKTtcbiAgICBjb25zdCBzaHJpbmsgPSBuZXh0UHJvcGVydHkuc2hyaW5rLmJpbmQobmV4dFByb3BlcnR5KTtcbiAgICBjb25zdCB0b3NzZWRWYWx1ZXMgPSAoMCwgU3RyZWFtXzEuc3RyZWFtKSgoMCwgVG9zc2VyXzEudG9zcykobmV4dFByb3BlcnR5LCBxUGFyYW1zLnNlZWQsIHFQYXJhbXMucmFuZG9tVHlwZSwgcVBhcmFtcy5leGFtcGxlcykpO1xuICAgIGlmIChxUGFyYW1zLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0b3NzZWRWYWx1ZXMudGFrZShxUGFyYW1zLm51bVJ1bnMpLm1hcCgocykgPT4gcygpLnZhbHVlXyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgU3RyZWFtXzEuc3RyZWFtKSgoMCwgUGF0aFdhbGtlcl8xLnBhdGhXYWxrKShxUGFyYW1zLnBhdGgsIHRvc3NlZFZhbHVlcy5tYXAoKHMpID0+IHMoKSksIHNocmluaykpXG4gICAgICAgIC50YWtlKHFQYXJhbXMubnVtUnVucylcbiAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZV8pO1xufVxuZnVuY3Rpb24gc2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFsuLi5zdHJlYW1TYW1wbGUoZ2VuZXJhdG9yLCBwYXJhbXMpXTtcbn1cbmV4cG9ydHMuc2FtcGxlID0gc2FtcGxlO1xuZnVuY3Rpb24gcm91bmQyKG4pIHtcbiAgICByZXR1cm4gKE1hdGgucm91bmQobiAqIDEwMCkgLyAxMDApLnRvRml4ZWQoMik7XG59XG5mdW5jdGlvbiBzdGF0aXN0aWNzKGdlbmVyYXRvciwgY2xhc3NpZnksIHBhcmFtcykge1xuICAgIGNvbnN0IGV4dGVuZGVkUGFyYW1zID0gdHlwZW9mIHBhcmFtcyA9PT0gJ251bWJlcidcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCkoKSksIHsgbnVtUnVuczogcGFyYW1zIH0pIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwpKCkpLCBwYXJhbXMpO1xuICAgIGNvbnN0IHFQYXJhbXMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzXzEuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkKGV4dGVuZGVkUGFyYW1zKTtcbiAgICBjb25zdCByZWNvcmRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgZyBvZiBzdHJlYW1TYW1wbGUoZ2VuZXJhdG9yLCBwYXJhbXMpKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IGNsYXNzaWZ5KGcpO1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gQXJyYXkuaXNBcnJheShvdXQpID8gb3V0IDogW291dF07XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICByZWNvcmRlZFtjXSA9IChyZWNvcmRlZFtjXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IE9iamVjdC5lbnRyaWVzKHJlY29yZGVkKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG4gICAgICAgIC5tYXAoKGkpID0+IFtpWzBdLCBgJHtyb3VuZDIoKGlbMV0gKiAxMDAuMCkgLyBxUGFyYW1zLm51bVJ1bnMpfSVgXSk7XG4gICAgY29uc3QgbG9uZ2VzdE5hbWUgPSBkYXRhLm1hcCgoaSkgPT4gaVswXS5sZW5ndGgpLnJlZHVjZSgocCwgYykgPT4gTWF0aC5tYXgocCwgYyksIDApO1xuICAgIGNvbnN0IGxvbmdlc3RQZXJjZW50ID0gZGF0YS5tYXAoKGkpID0+IGlbMV0ubGVuZ3RoKS5yZWR1Y2UoKHAsIGMpID0+IE1hdGgubWF4KHAsIGMpLCAwKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YSkge1xuICAgICAgICBxUGFyYW1zLmxvZ2dlcihgJHtpdGVtWzBdLnBhZEVuZChsb25nZXN0TmFtZSwgJy4nKX0uLiR7aXRlbVsxXS5wYWRTdGFydChsb25nZXN0UGVyY2VudCwgJy4nKX1gKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXRpc3RpY3MgPSBzdGF0aXN0aWNzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvdXJjZVZhbHVlc0l0ZXJhdG9yID0gdm9pZCAwO1xuY2xhc3MgU291cmNlVmFsdWVzSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZXMsIG1heEluaXRpYWxJdGVyYXRpb25zLCByZW1haW5pbmdTa2lwcykge1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBpbml0aWFsVmFsdWVzO1xuICAgICAgICB0aGlzLm1heEluaXRpYWxJdGVyYXRpb25zID0gbWF4SW5pdGlhbEl0ZXJhdGlvbnM7XG4gICAgICAgIHRoaXMucmVtYWluaW5nU2tpcHMgPSByZW1haW5pbmdTa2lwcztcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAoLS10aGlzLm1heEluaXRpYWxJdGVyYXRpb25zICE9PSAtMSAmJiB0aGlzLnJlbWFpbmluZ1NraXBzID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmluaXRpYWxWYWx1ZXMubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFuLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG4udmFsdWUoKSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgfVxuICAgIHNraXBwZWRPbmUoKSB7XG4gICAgICAgIC0tdGhpcy5yZW1haW5pbmdTa2lwcztcbiAgICAgICAgKyt0aGlzLm1heEluaXRpYWxJdGVyYXRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuU291cmNlVmFsdWVzSXRlcmF0b3IgPSBTb3VyY2VWYWx1ZXNJdGVyYXRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b3NzID0gdm9pZCAwO1xuY29uc3QgcHVyZV9yYW5kXzEgPSByZXF1aXJlKFwicHVyZS1yYW5kXCIpO1xuY29uc3QgUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vcmFuZG9tL2dlbmVyYXRvci9SYW5kb21cIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4uL2FyYml0cmFyeS9kZWZpbml0aW9uL1ZhbHVlXCIpO1xuZnVuY3Rpb24gbGF6eUdlbmVyYXRlKGdlbmVyYXRvciwgcm5nLCBpZHgpIHtcbiAgICByZXR1cm4gKCkgPT4gZ2VuZXJhdG9yLmdlbmVyYXRlKG5ldyBSYW5kb21fMS5SYW5kb20ocm5nKSwgaWR4KTtcbn1cbmZ1bmN0aW9uKiB0b3NzKGdlbmVyYXRvciwgc2VlZCwgcmFuZG9tLCBleGFtcGxlcykge1xuICAgIHlpZWxkKiBleGFtcGxlcy5tYXAoKGUpID0+ICgpID0+IG5ldyBWYWx1ZV8xLlZhbHVlKGUsIHVuZGVmaW5lZCkpO1xuICAgIGxldCBpZHggPSAwO1xuICAgIGxldCBybmcgPSByYW5kb20oc2VlZCk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBybmcgPSBybmcuanVtcCA/IHJuZy5qdW1wKCkgOiAoMCwgcHVyZV9yYW5kXzEuc2tpcE4pKHJuZywgNDIpO1xuICAgICAgICB5aWVsZCBsYXp5R2VuZXJhdGUoZ2VuZXJhdG9yLCBybmcsIGlkeCsrKTtcbiAgICB9XG59XG5leHBvcnRzLnRvc3MgPSB0b3NzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc2V0Q29uZmlndXJlR2xvYmFsID0gZXhwb3J0cy5yZWFkQ29uZmlndXJlR2xvYmFsID0gZXhwb3J0cy5jb25maWd1cmVHbG9iYWwgPSB2b2lkIDA7XG5sZXQgZ2xvYmFsUGFyYW1ldGVycyA9IHt9O1xuZnVuY3Rpb24gY29uZmlndXJlR2xvYmFsKHBhcmFtZXRlcnMpIHtcbiAgICBnbG9iYWxQYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbn1cbmV4cG9ydHMuY29uZmlndXJlR2xvYmFsID0gY29uZmlndXJlR2xvYmFsO1xuZnVuY3Rpb24gcmVhZENvbmZpZ3VyZUdsb2JhbCgpIHtcbiAgICByZXR1cm4gZ2xvYmFsUGFyYW1ldGVycztcbn1cbmV4cG9ydHMucmVhZENvbmZpZ3VyZUdsb2JhbCA9IHJlYWRDb25maWd1cmVHbG9iYWw7XG5mdW5jdGlvbiByZXNldENvbmZpZ3VyZUdsb2JhbCgpIHtcbiAgICBnbG9iYWxQYXJhbWV0ZXJzID0ge307XG59XG5leHBvcnRzLnJlc2V0Q29uZmlndXJlR2xvYmFsID0gcmVzZXRDb25maWd1cmVHbG9iYWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVhbGlmaWVkUGFyYW1ldGVycyA9IHZvaWQgMDtcbmNvbnN0IHB1cmVfcmFuZF8xID0gcmVxdWlyZShcInB1cmUtcmFuZFwiKTtcbmNvbnN0IFZlcmJvc2l0eUxldmVsXzEgPSByZXF1aXJlKFwiLi9WZXJib3NpdHlMZXZlbFwiKTtcbmNsYXNzIFF1YWxpZmllZFBhcmFtZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKG9wKSB7XG4gICAgICAgIGNvbnN0IHAgPSBvcCB8fCB7fTtcbiAgICAgICAgdGhpcy5zZWVkID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkU2VlZChwKTtcbiAgICAgICAgdGhpcy5yYW5kb21UeXBlID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkUmFuZG9tVHlwZShwKTtcbiAgICAgICAgdGhpcy5udW1SdW5zID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkTnVtUnVucyhwKTtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkVmVyYm9zZShwKTtcbiAgICAgICAgdGhpcy5tYXhTa2lwc1BlclJ1biA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAnbWF4U2tpcHNQZXJSdW4nLCAxMDApO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ3RpbWVvdXQnLCBudWxsKTtcbiAgICAgICAgdGhpcy5za2lwQWxsQWZ0ZXJUaW1lTGltaXQgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ3NraXBBbGxBZnRlclRpbWVMaW1pdCcsIG51bGwpO1xuICAgICAgICB0aGlzLmludGVycnVwdEFmdGVyVGltZUxpbWl0ID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdpbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCcsIG51bGwpO1xuICAgICAgICB0aGlzLm1hcmtJbnRlcnJ1cHRBc0ZhaWx1cmUgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRCb29sZWFuKHAsICdtYXJrSW50ZXJydXB0QXNGYWlsdXJlJyk7XG4gICAgICAgIHRoaXMuc2tpcEVxdWFsVmFsdWVzID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbihwLCAnc2tpcEVxdWFsVmFsdWVzJyk7XG4gICAgICAgIHRoaXMuaWdub3JlRXF1YWxWYWx1ZXMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRCb29sZWFuKHAsICdpZ25vcmVFcXVhbFZhbHVlcycpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAnbG9nZ2VyJywgKHYpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXRoID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdwYXRoJywgJycpO1xuICAgICAgICB0aGlzLnVuYmlhc2VkID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbihwLCAndW5iaWFzZWQnKTtcbiAgICAgICAgdGhpcy5leGFtcGxlcyA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAnZXhhbXBsZXMnLCBbXSk7XG4gICAgICAgIHRoaXMuZW5kT25GYWlsdXJlID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbihwLCAnZW5kT25GYWlsdXJlJyk7XG4gICAgICAgIHRoaXMucmVwb3J0ZXIgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ3JlcG9ydGVyJywgbnVsbCk7XG4gICAgICAgIHRoaXMuYXN5bmNSZXBvcnRlciA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAnYXN5bmNSZXBvcnRlcicsIG51bGwpO1xuICAgIH1cbiAgICB0b1BhcmFtZXRlcnMoKSB7XG4gICAgICAgIGNvbnN0IG9yVW5kZWZpbmVkID0gKHZhbHVlKSA9PiAodmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWVkOiB0aGlzLnNlZWQsXG4gICAgICAgICAgICByYW5kb21UeXBlOiB0aGlzLnJhbmRvbVR5cGUsXG4gICAgICAgICAgICBudW1SdW5zOiB0aGlzLm51bVJ1bnMsXG4gICAgICAgICAgICBtYXhTa2lwc1BlclJ1bjogdGhpcy5tYXhTa2lwc1BlclJ1bixcbiAgICAgICAgICAgIHRpbWVvdXQ6IG9yVW5kZWZpbmVkKHRoaXMudGltZW91dCksXG4gICAgICAgICAgICBza2lwQWxsQWZ0ZXJUaW1lTGltaXQ6IG9yVW5kZWZpbmVkKHRoaXMuc2tpcEFsbEFmdGVyVGltZUxpbWl0KSxcbiAgICAgICAgICAgIGludGVycnVwdEFmdGVyVGltZUxpbWl0OiBvclVuZGVmaW5lZCh0aGlzLmludGVycnVwdEFmdGVyVGltZUxpbWl0KSxcbiAgICAgICAgICAgIG1hcmtJbnRlcnJ1cHRBc0ZhaWx1cmU6IHRoaXMubWFya0ludGVycnVwdEFzRmFpbHVyZSxcbiAgICAgICAgICAgIHNraXBFcXVhbFZhbHVlczogdGhpcy5za2lwRXF1YWxWYWx1ZXMsXG4gICAgICAgICAgICBpZ25vcmVFcXVhbFZhbHVlczogdGhpcy5pZ25vcmVFcXVhbFZhbHVlcyxcbiAgICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB1bmJpYXNlZDogdGhpcy51bmJpYXNlZCxcbiAgICAgICAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZSxcbiAgICAgICAgICAgIGV4YW1wbGVzOiB0aGlzLmV4YW1wbGVzLFxuICAgICAgICAgICAgZW5kT25GYWlsdXJlOiB0aGlzLmVuZE9uRmFpbHVyZSxcbiAgICAgICAgICAgIHJlcG9ydGVyOiBvclVuZGVmaW5lZCh0aGlzLnJlcG9ydGVyKSxcbiAgICAgICAgICAgIGFzeW5jUmVwb3J0ZXI6IG9yVW5kZWZpbmVkKHRoaXMuYXN5bmNSZXBvcnRlciksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyByZWFkKG9wKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhbGlmaWVkUGFyYW1ldGVycyhvcCk7XG4gICAgfVxufVxuZXhwb3J0cy5RdWFsaWZpZWRQYXJhbWV0ZXJzID0gUXVhbGlmaWVkUGFyYW1ldGVycztcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFNlZWQgPSAocCkgPT4ge1xuICAgIGlmIChwLnNlZWQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgXiAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKTtcbiAgICBjb25zdCBzZWVkMzIgPSBwLnNlZWQgfCAwO1xuICAgIGlmIChwLnNlZWQgPT09IHNlZWQzMilcbiAgICAgICAgcmV0dXJuIHNlZWQzMjtcbiAgICBjb25zdCBnYXAgPSBwLnNlZWQgLSBzZWVkMzI7XG4gICAgcmV0dXJuIHNlZWQzMiBeIChnYXAgKiAweDEwMDAwMDAwMCk7XG59O1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkUmFuZG9tVHlwZSA9IChwKSA9PiB7XG4gICAgaWYgKHAucmFuZG9tVHlwZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEuZGVmYXVsdC54b3JzaGlmdDEyOHBsdXM7XG4gICAgaWYgKHR5cGVvZiBwLnJhbmRvbVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAocC5yYW5kb21UeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdtZXJzZW5uZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQubWVyc2VubmU7XG4gICAgICAgICAgICBjYXNlICdjb25ncnVlbnRpYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0LmNvbmdydWVudGlhbDtcbiAgICAgICAgICAgIGNhc2UgJ2NvbmdydWVudGlhbDMyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEuZGVmYXVsdC5jb25ncnVlbnRpYWwzMjtcbiAgICAgICAgICAgIGNhc2UgJ3hvcnNoaWZ0MTI4cGx1cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQueG9yc2hpZnQxMjhwbHVzO1xuICAgICAgICAgICAgY2FzZSAneG9yb3NoaXJvMTI4cGx1cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQueG9yb3NoaXJvMTI4cGx1cztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJhbmRvbSBzcGVjaWZpZWQ6ICcke3AucmFuZG9tVHlwZX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHAucmFuZG9tVHlwZTtcbn07XG5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWROdW1SdW5zID0gKHApID0+IHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSAxMDA7XG4gICAgaWYgKHAubnVtUnVucyAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcC5udW1SdW5zO1xuICAgIGlmIChwLm51bV9ydW5zICE9IG51bGwpXG4gICAgICAgIHJldHVybiBwLm51bV9ydW5zO1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG59O1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkVmVyYm9zZSA9IChwKSA9PiB7XG4gICAgaWYgKHAudmVyYm9zZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5Ob25lO1xuICAgIGlmICh0eXBlb2YgcC52ZXJib3NlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHAudmVyYm9zZSA9PT0gdHJ1ZSA/IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyYm9zZSA6IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuTm9uZTtcbiAgICB9XG4gICAgaWYgKHAudmVyYm9zZSA8PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLk5vbmUpIHtcbiAgICAgICAgcmV0dXJuIFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuTm9uZTtcbiAgICB9XG4gICAgaWYgKHAudmVyYm9zZSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgIHJldHVybiBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlO1xuICAgIH1cbiAgICByZXR1cm4gcC52ZXJib3NlIHwgMDtcbn07XG5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRCb29sZWFuID0gKHAsIGtleSkgPT4gcFtrZXldID09PSB0cnVlO1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0ID0gKHAsIGtleSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBwW2tleV07XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSB2b2lkIDA7XG52YXIgVmVyYm9zaXR5TGV2ZWw7XG4oZnVuY3Rpb24gKFZlcmJvc2l0eUxldmVsKSB7XG4gICAgVmVyYm9zaXR5TGV2ZWxbVmVyYm9zaXR5TGV2ZWxbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBWZXJib3NpdHlMZXZlbFtWZXJib3NpdHlMZXZlbFtcIlZlcmJvc2VcIl0gPSAxXSA9IFwiVmVyYm9zZVwiO1xuICAgIFZlcmJvc2l0eUxldmVsW1ZlcmJvc2l0eUxldmVsW1wiVmVyeVZlcmJvc2VcIl0gPSAyXSA9IFwiVmVyeVZlcmJvc2VcIjtcbn0pKFZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5WZXJib3NpdHlMZXZlbCB8fCAoZXhwb3J0cy5WZXJib3NpdHlMZXZlbCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXhlY3V0aW9uU3RhdHVzID0gdm9pZCAwO1xudmFyIEV4ZWN1dGlvblN0YXR1cztcbihmdW5jdGlvbiAoRXhlY3V0aW9uU3RhdHVzKSB7XG4gICAgRXhlY3V0aW9uU3RhdHVzW0V4ZWN1dGlvblN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAwXSA9IFwiU3VjY2Vzc1wiO1xuICAgIEV4ZWN1dGlvblN0YXR1c1tFeGVjdXRpb25TdGF0dXNbXCJTa2lwcGVkXCJdID0gLTFdID0gXCJTa2lwcGVkXCI7XG4gICAgRXhlY3V0aW9uU3RhdHVzW0V4ZWN1dGlvblN0YXR1c1tcIkZhaWx1cmVcIl0gPSAxXSA9IFwiRmFpbHVyZVwiO1xufSkoRXhlY3V0aW9uU3RhdHVzID0gZXhwb3J0cy5FeGVjdXRpb25TdGF0dXMgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3RhdHVzID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5FeGVjdXRpb24gPSB2b2lkIDA7XG5jb25zdCBWZXJib3NpdHlMZXZlbF8xID0gcmVxdWlyZShcIi4uL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWxcIik7XG5jb25zdCBFeGVjdXRpb25TdGF0dXNfMSA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvblN0YXR1c1wiKTtcbmNsYXNzIFJ1bkV4ZWN1dGlvbiB7XG4gICAgY29uc3RydWN0b3IodmVyYm9zaXR5LCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSkge1xuICAgICAgICB0aGlzLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRlZEFzRmFpbHVyZSA9IGludGVycnVwdGVkQXNGYWlsdXJlO1xuICAgICAgICB0aGlzLmlzU3VjY2VzcyA9ICgpID0+IHRoaXMucGF0aFRvRmFpbHVyZSA9PSBudWxsO1xuICAgICAgICB0aGlzLmZpcnN0RmFpbHVyZSA9ICgpID0+ICh0aGlzLnBhdGhUb0ZhaWx1cmUgPyArdGhpcy5wYXRoVG9GYWlsdXJlLnNwbGl0KCc6JylbMF0gOiAtMSk7XG4gICAgICAgIHRoaXMubnVtU2hyaW5rcyA9ICgpID0+ICh0aGlzLnBhdGhUb0ZhaWx1cmUgPyB0aGlzLnBhdGhUb0ZhaWx1cmUuc3BsaXQoJzonKS5sZW5ndGggLSAxIDogMCk7XG4gICAgICAgIHRoaXMucm9vdEV4ZWN1dGlvblRyZWVzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsRXhlY3V0aW9uVHJlZXMgPSB0aGlzLnJvb3RFeGVjdXRpb25UcmVlcztcbiAgICAgICAgdGhpcy5mYWlsdXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5udW1Ta2lwcyA9IDA7XG4gICAgICAgIHRoaXMubnVtU3VjY2Vzc2VzID0gMDtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhcHBlbmRFeGVjdXRpb25UcmVlKHN0YXR1cywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRyZWUgPSB7IHN0YXR1cywgdmFsdWUsIGNoaWxkcmVuOiBbXSB9O1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEV4ZWN1dGlvblRyZWVzLnB1c2goY3VycmVudFRyZWUpO1xuICAgICAgICByZXR1cm4gY3VycmVudFRyZWU7XG4gICAgfVxuICAgIGZhaWwodmFsdWUsIGlkLCBmYWlsdXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcmJvc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmVlID0gdGhpcy5hcHBlbmRFeGVjdXRpb25UcmVlKEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1cy5GYWlsdXJlLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEV4ZWN1dGlvblRyZWVzID0gY3VycmVudFRyZWUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0aFRvRmFpbHVyZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5wYXRoVG9GYWlsdXJlID0gYCR7aWR9YDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wYXRoVG9GYWlsdXJlICs9IGA6JHtpZH1gO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IGZhaWx1cmU7XG4gICAgfVxuICAgIHNraXAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXhlY3V0aW9uVHJlZShFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuU2tpcHBlZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGhUb0ZhaWx1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgKyt0aGlzLm51bVNraXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1Y2Nlc3ModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXhlY3V0aW9uVHJlZShFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuU3VjY2VzcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGhUb0ZhaWx1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgKyt0aGlzLm51bVN1Y2Nlc3NlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnRlcnJ1cHQoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBleHRyYWN0RmFpbHVyZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3VjY2VzcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMucm9vdEV4ZWN1dGlvblRyZWVzO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLmxlbmd0aCA+IDAgJiYgY3Vyc29yW2N1cnNvci5sZW5ndGggLSAxXS5zdGF0dXMgPT09IEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1cy5GYWlsdXJlKSB7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlVHJlZSA9IGN1cnNvcltjdXJzb3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmVUcmVlLnZhbHVlKTtcbiAgICAgICAgICAgIGN1cnNvciA9IGZhaWx1cmVUcmVlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWlsdXJlcztcbiAgICB9XG4gICAgdG9SdW5EZXRhaWxzKHNlZWQsIGJhc2VQYXRoLCBtYXhTa2lwcywgcVBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdWNjZXNzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmFpbGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVycnVwdGVkOiB0aGlzLmludGVycnVwdGVkLFxuICAgICAgICAgICAgICAgIG51bVJ1bnM6IHRoaXMuZmlyc3RGYWlsdXJlKCkgKyAxIC0gdGhpcy5udW1Ta2lwcyxcbiAgICAgICAgICAgICAgICBudW1Ta2lwczogdGhpcy5udW1Ta2lwcyxcbiAgICAgICAgICAgICAgICBudW1TaHJpbmtzOiB0aGlzLm51bVNocmlua3MoKSxcbiAgICAgICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgICAgIGNvdW50ZXJleGFtcGxlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvdW50ZXJleGFtcGxlUGF0aDogUnVuRXhlY3V0aW9uLm1lcmdlUGF0aHMoYmFzZVBhdGgsIHRoaXMucGF0aFRvRmFpbHVyZSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuZmFpbHVyZS5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZXJyb3JJbnN0YW5jZTogdGhpcy5mYWlsdXJlLmVycm9yLFxuICAgICAgICAgICAgICAgIGZhaWx1cmVzOiB0aGlzLmV4dHJhY3RGYWlsdXJlcygpLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblN1bW1hcnk6IHRoaXMucm9vdEV4ZWN1dGlvblRyZWVzLFxuICAgICAgICAgICAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zaXR5LFxuICAgICAgICAgICAgICAgIHJ1bkNvbmZpZ3VyYXRpb246IHFQYXJhbXMudG9QYXJhbWV0ZXJzKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhaWxlZCA9IHRoaXMubnVtU2tpcHMgPiBtYXhTa2lwcyB8fCAodGhpcy5pbnRlcnJ1cHRlZCAmJiB0aGlzLmludGVycnVwdGVkQXNGYWlsdXJlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZhaWxlZCxcbiAgICAgICAgICAgIGludGVycnVwdGVkOiB0aGlzLmludGVycnVwdGVkLFxuICAgICAgICAgICAgbnVtUnVuczogdGhpcy5udW1TdWNjZXNzZXMsXG4gICAgICAgICAgICBudW1Ta2lwczogdGhpcy5udW1Ta2lwcyxcbiAgICAgICAgICAgIG51bVNocmlua3M6IDAsXG4gICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgY291bnRlcmV4YW1wbGU6IG51bGwsXG4gICAgICAgICAgICBjb3VudGVyZXhhbXBsZVBhdGg6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGVycm9ySW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICBmYWlsdXJlczogW10sXG4gICAgICAgICAgICBleGVjdXRpb25TdW1tYXJ5OiB0aGlzLnJvb3RFeGVjdXRpb25UcmVlcyxcbiAgICAgICAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zaXR5LFxuICAgICAgICAgICAgcnVuQ29uZmlndXJhdGlvbjogcVBhcmFtcy50b1BhcmFtZXRlcnMoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bkV4ZWN1dGlvbiA9IFJ1bkV4ZWN1dGlvbjtcblJ1bkV4ZWN1dGlvbi5tZXJnZVBhdGhzID0gKG9mZnNldFBhdGgsIHBhdGgpID0+IHtcbiAgICBpZiAob2Zmc2V0UGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIGNvbnN0IG9mZnNldEl0ZW1zID0gb2Zmc2V0UGF0aC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IHJlbWFpbmluZ0l0ZW1zID0gcGF0aC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IG1pZGRsZSA9ICtvZmZzZXRJdGVtc1tvZmZzZXRJdGVtcy5sZW5ndGggLSAxXSArICtyZW1haW5pbmdJdGVtc1swXTtcbiAgICByZXR1cm4gWy4uLm9mZnNldEl0ZW1zLnNsaWNlKDAsIG9mZnNldEl0ZW1zLmxlbmd0aCAtIDEpLCBgJHttaWRkbGV9YCwgLi4ucmVtYWluaW5nSXRlbXMuc2xpY2UoMSldLmpvaW4oJzonKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGF0aFdhbGsgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuZnVuY3Rpb24gcGF0aFdhbGsocGF0aCwgaW5pdGlhbFZhbHVlcywgc2hyaW5rKSB7XG4gICAgbGV0IHZhbHVlcyA9ICgwLCBTdHJlYW1fMS5zdHJlYW0pKGluaXRpYWxWYWx1ZXMpO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnOicpLm1hcCgodGV4dCkgPT4gK3RleHQpO1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgaWYgKCFzZWdtZW50cy5ldmVyeSgodikgPT4gIU51bWJlci5pc05hTih2KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVwbGF5LCBnb3QgaW52YWxpZCBwYXRoPSR7cGF0aH1gKTtcbiAgICB9XG4gICAgdmFsdWVzID0gdmFsdWVzLmRyb3Aoc2VnbWVudHNbMF0pO1xuICAgIGZvciAoY29uc3QgcyBvZiBzZWdtZW50cy5zbGljZSgxKSkge1xuICAgICAgICBjb25zdCB2YWx1ZVRvU2hyaW5rID0gdmFsdWVzLmdldE50aE9yTGFzdCgwKTtcbiAgICAgICAgaWYgKHZhbHVlVG9TaHJpbmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVwbGF5LCBnb3Qgd3JvbmcgcGF0aD0ke3BhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzID0gc2hyaW5rKHZhbHVlVG9TaHJpbmspLmRyb3Aocyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnRzLnBhdGhXYWxrID0gcGF0aFdhbGs7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGV4cG9ydHMuZGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBleHBvcnRzLmFzeW5jUmVwb3J0UnVuRGV0YWlscyA9IGV4cG9ydHMucmVwb3J0UnVuRGV0YWlscyA9IHZvaWQgMDtcbmNvbnN0IHN0cmluZ2lmeV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL3N0cmluZ2lmeVwiKTtcbmNvbnN0IFZlcmJvc2l0eUxldmVsXzEgPSByZXF1aXJlKFwiLi4vY29uZmlndXJhdGlvbi9WZXJib3NpdHlMZXZlbFwiKTtcbmNvbnN0IEV4ZWN1dGlvblN0YXR1c18xID0gcmVxdWlyZShcIi4uL3JlcG9ydGVyL0V4ZWN1dGlvblN0YXR1c1wiKTtcbmZ1bmN0aW9uIGZvcm1hdEhpbnRzKGhpbnRzKSB7XG4gICAgaWYgKGhpbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYEhpbnQ6ICR7aGludHNbMF19YDtcbiAgICB9XG4gICAgcmV0dXJuIGhpbnRzLm1hcCgoaCwgaWR4KSA9PiBgSGludCAoJHtpZHggKyAxfSk6ICR7aH1gKS5qb2luKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEZhaWx1cmVzKGZhaWx1cmVzLCBzdHJpbmdpZnlPbmUpIHtcbiAgICByZXR1cm4gYEVuY291bnRlcmVkIGZhaWx1cmVzIHdlcmU6XFxuLSAke2ZhaWx1cmVzLm1hcChzdHJpbmdpZnlPbmUpLmpvaW4oJ1xcbi0gJyl9YDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEV4ZWN1dGlvblN1bW1hcnkoZXhlY3V0aW9uVHJlZXMsIHN0cmluZ2lmeU9uZSkge1xuICAgIGNvbnN0IHN1bW1hcnlMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHJlbWFpbmluZ1RyZWVzQW5kRGVwdGggPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRyZWUgb2YgZXhlY3V0aW9uVHJlZXMuc2xpY2UoKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgcmVtYWluaW5nVHJlZXNBbmREZXB0aC5wdXNoKHsgZGVwdGg6IDEsIHRyZWUgfSk7XG4gICAgfVxuICAgIHdoaWxlIChyZW1haW5pbmdUcmVlc0FuZERlcHRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VHJlZUFuZERlcHRoID0gcmVtYWluaW5nVHJlZXNBbmREZXB0aC5wb3AoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFRyZWUgPSBjdXJyZW50VHJlZUFuZERlcHRoLnRyZWU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREZXB0aCA9IGN1cnJlbnRUcmVlQW5kRGVwdGguZGVwdGg7XG4gICAgICAgIGNvbnN0IHN0YXR1c0ljb24gPSBjdXJyZW50VHJlZS5zdGF0dXMgPT09IEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1cy5TdWNjZXNzXG4gICAgICAgICAgICA/ICdcXHgxYlszMm1cXHUyMjFBXFx4MWJbMG0nXG4gICAgICAgICAgICA6IGN1cnJlbnRUcmVlLnN0YXR1cyA9PT0gRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLkZhaWx1cmVcbiAgICAgICAgICAgICAgICA/ICdcXHgxYlszMW1cXHhEN1xceDFiWzBtJ1xuICAgICAgICAgICAgICAgIDogJ1xceDFiWzMzbSFcXHgxYlswbSc7XG4gICAgICAgIGNvbnN0IGxlZnRQYWRkaW5nID0gQXJyYXkoY3VycmVudERlcHRoKS5qb2luKCcuICcpO1xuICAgICAgICBzdW1tYXJ5TGluZXMucHVzaChgJHtsZWZ0UGFkZGluZ30ke3N0YXR1c0ljb259ICR7c3RyaW5naWZ5T25lKGN1cnJlbnRUcmVlLnZhbHVlKX1gKTtcbiAgICAgICAgZm9yIChjb25zdCB0cmVlIG9mIGN1cnJlbnRUcmVlLmNoaWxkcmVuLnNsaWNlKCkucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICByZW1haW5pbmdUcmVlc0FuZERlcHRoLnB1c2goeyBkZXB0aDogY3VycmVudERlcHRoICsgMSwgdHJlZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYEV4ZWN1dGlvbiBzdW1tYXJ5OlxcbiR7c3VtbWFyeUxpbmVzLmpvaW4oJ1xcbicpfWA7XG59XG5mdW5jdGlvbiBwcmVGb3JtYXRUb29NYW55U2tpcHBlZChvdXQsIHN0cmluZ2lmeU9uZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRmFpbGVkIHRvIHJ1biBwcm9wZXJ0eSwgdG9vIG1hbnkgcHJlLWNvbmRpdGlvbiBmYWlsdXJlcyBlbmNvdW50ZXJlZFxcbnsgc2VlZDogJHtvdXQuc2VlZH0gfVxcblxcblJhbiAke291dC5udW1SdW5zfSB0aW1lKHMpXFxuU2tpcHBlZCAke291dC5udW1Ta2lwc30gdGltZShzKWA7XG4gICAgbGV0IGRldGFpbHMgPSBudWxsO1xuICAgIGNvbnN0IGhpbnRzID0gW1xuICAgICAgICAnVHJ5IHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHJlamVjdGVkIHZhbHVlcyBieSBjb21iaW5pbmcgbWFwLCBmbGF0TWFwIGFuZCBidWlsdC1pbiBhcmJpdHJhcmllcycsXG4gICAgICAgICdJbmNyZWFzZSBmYWlsdXJlIHRvbGVyYW5jZSBieSBzZXR0aW5nIG1heFNraXBzUGVyUnVuIHRvIGFuIGhpZ2hlciB2YWx1ZScsXG4gICAgXTtcbiAgICBpZiAob3V0LnZlcmJvc2UgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICBkZXRhaWxzID0gZm9ybWF0RXhlY3V0aW9uU3VtbWFyeShvdXQuZXhlY3V0aW9uU3VtbWFyeSwgc3RyaW5naWZ5T25lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhpbnRzLnB1c2goJ0VuYWJsZSB2ZXJib3NlIG1vZGUgYXQgbGV2ZWwgVmVyeVZlcmJvc2UgaW4gb3JkZXIgdG8gY2hlY2sgYWxsIGdlbmVyYXRlZCB2YWx1ZXMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UsIGRldGFpbHMsIGhpbnRzIH07XG59XG5mdW5jdGlvbiBwcmVGb3JtYXRGYWlsdXJlKG91dCwgc3RyaW5naWZ5T25lKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBQcm9wZXJ0eSBmYWlsZWQgYWZ0ZXIgJHtvdXQubnVtUnVuc30gdGVzdHNcXG57IHNlZWQ6ICR7b3V0LnNlZWR9LCBwYXRoOiBcIiR7b3V0LmNvdW50ZXJleGFtcGxlUGF0aH1cIiwgZW5kT25GYWlsdXJlOiB0cnVlIH1cXG5Db3VudGVyZXhhbXBsZTogJHtzdHJpbmdpZnlPbmUob3V0LmNvdW50ZXJleGFtcGxlKX1cXG5TaHJ1bmsgJHtvdXQubnVtU2hyaW5rc30gdGltZShzKVxcbkdvdCBlcnJvcjogJHtvdXQuZXJyb3J9YDtcbiAgICBsZXQgZGV0YWlscyA9IG51bGw7XG4gICAgY29uc3QgaGludHMgPSBbXTtcbiAgICBpZiAob3V0LnZlcmJvc2UgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICBkZXRhaWxzID0gZm9ybWF0RXhlY3V0aW9uU3VtbWFyeShvdXQuZXhlY3V0aW9uU3VtbWFyeSwgc3RyaW5naWZ5T25lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0LnZlcmJvc2UgPT09IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyYm9zZSkge1xuICAgICAgICBkZXRhaWxzID0gZm9ybWF0RmFpbHVyZXMob3V0LmZhaWx1cmVzLCBzdHJpbmdpZnlPbmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGludHMucHVzaCgnRW5hYmxlIHZlcmJvc2UgbW9kZSBpbiBvcmRlciB0byBoYXZlIHRoZSBsaXN0IG9mIGFsbCBmYWlsaW5nIHZhbHVlcyBlbmNvdW50ZXJlZCBkdXJpbmcgdGhlIHJ1bicpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlLCBkZXRhaWxzLCBoaW50cyB9O1xufVxuZnVuY3Rpb24gcHJlRm9ybWF0RWFybHlJbnRlcnJ1cHRlZChvdXQsIHN0cmluZ2lmeU9uZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgUHJvcGVydHkgaW50ZXJydXB0ZWQgYWZ0ZXIgJHtvdXQubnVtUnVuc30gdGVzdHNcXG57IHNlZWQ6ICR7b3V0LnNlZWR9IH1gO1xuICAgIGxldCBkZXRhaWxzID0gbnVsbDtcbiAgICBjb25zdCBoaW50cyA9IFtdO1xuICAgIGlmIChvdXQudmVyYm9zZSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgIGRldGFpbHMgPSBmb3JtYXRFeGVjdXRpb25TdW1tYXJ5KG91dC5leGVjdXRpb25TdW1tYXJ5LCBzdHJpbmdpZnlPbmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGludHMucHVzaCgnRW5hYmxlIHZlcmJvc2UgbW9kZSBhdCBsZXZlbCBWZXJ5VmVyYm9zZSBpbiBvcmRlciB0byBjaGVjayBhbGwgZ2VuZXJhdGVkIHZhbHVlcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBzdGF0dXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSwgZGV0YWlscywgaGludHMgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZXBvcnRNZXNzYWdlSW50ZXJuYWwob3V0LCBzdHJpbmdpZnlPbmUpIHtcbiAgICBpZiAoIW91dC5mYWlsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGRldGFpbHMsIGhpbnRzIH0gPSBvdXQuY291bnRlcmV4YW1wbGVQYXRoID09PSBudWxsXG4gICAgICAgID8gb3V0LmludGVycnVwdGVkXG4gICAgICAgICAgICA/IHByZUZvcm1hdEVhcmx5SW50ZXJydXB0ZWQob3V0LCBzdHJpbmdpZnlPbmUpXG4gICAgICAgICAgICA6IHByZUZvcm1hdFRvb01hbnlTa2lwcGVkKG91dCwgc3RyaW5naWZ5T25lKVxuICAgICAgICA6IHByZUZvcm1hdEZhaWx1cmUob3V0LCBzdHJpbmdpZnlPbmUpO1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIGlmIChkZXRhaWxzICE9IG51bGwpXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuXFxuJHtkZXRhaWxzfWA7XG4gICAgaWYgKGhpbnRzLmxlbmd0aCA+IDApXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuXFxuJHtmb3JtYXRIaW50cyhoaW50cyl9YDtcbiAgICByZXR1cm4gZXJyb3JNZXNzYWdlO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlcG9ydE1lc3NhZ2Uob3V0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRSZXBvcnRNZXNzYWdlSW50ZXJuYWwob3V0LCBzdHJpbmdpZnlfMS5zdHJpbmdpZnkpO1xufVxuZXhwb3J0cy5kZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGRlZmF1bHRSZXBvcnRNZXNzYWdlO1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZShvdXQpIHtcbiAgICBjb25zdCBwZW5kaW5nU3RyaW5naWZpZWRzID0gW107XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5T25lKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gKDAsIHN0cmluZ2lmeV8xLnBvc3NpYmx5QXN5bmNTdHJpbmdpZnkpKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmdpZmllZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nU3RyaW5naWZpZWRzLnB1c2goUHJvbWlzZS5hbGwoW3ZhbHVlLCBzdHJpbmdpZmllZF0pKTtcbiAgICAgICAgcmV0dXJuICdcXHUyMDI2JztcbiAgICB9XG4gICAgY29uc3QgZmlyc3RUcnlNZXNzYWdlID0gZGVmYXVsdFJlcG9ydE1lc3NhZ2VJbnRlcm5hbChvdXQsIHN0cmluZ2lmeU9uZSk7XG4gICAgaWYgKHBlbmRpbmdTdHJpbmdpZmllZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFRyeU1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lzdGVyZWRWYWx1ZXMgPSBuZXcgTWFwKGF3YWl0IFByb21pc2UuYWxsKHBlbmRpbmdTdHJpbmdpZmllZHMpKTtcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlTZWNvbmQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXN5bmNTdHJpbmdpZmllZElmUmVnaXN0ZXJlZCA9IHJlZ2lzdGVyZWRWYWx1ZXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKGFzeW5jU3RyaW5naWZpZWRJZlJlZ2lzdGVyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jU3RyaW5naWZpZWRJZlJlZ2lzdGVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBzdHJpbmdpZnlfMS5zdHJpbmdpZnkpKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXBvcnRNZXNzYWdlSW50ZXJuYWwob3V0LCBzdHJpbmdpZnlTZWNvbmQpO1xufVxuZXhwb3J0cy5hc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlID0gYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZTtcbmZ1bmN0aW9uIHRocm93SWZGYWlsZWQob3V0KSB7XG4gICAgaWYgKCFvdXQuZmFpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgdGhyb3cgbmV3IEVycm9yKGRlZmF1bHRSZXBvcnRNZXNzYWdlKG91dCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXN5bmNUaHJvd0lmRmFpbGVkKG91dCkge1xuICAgIGlmICghb3V0LmZhaWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCBhc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlKG91dCkpO1xufVxuZnVuY3Rpb24gcmVwb3J0UnVuRGV0YWlscyhvdXQpIHtcbiAgICBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24uYXN5bmNSZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIob3V0KTtcbiAgICBlbHNlIGlmIChvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLnJlcG9ydGVyKG91dCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhyb3dJZkZhaWxlZChvdXQpO1xufVxuZXhwb3J0cy5yZXBvcnRSdW5EZXRhaWxzID0gcmVwb3J0UnVuRGV0YWlscztcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jUmVwb3J0UnVuRGV0YWlscyhvdXQpIHtcbiAgICBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24uYXN5bmNSZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIob3V0KTtcbiAgICBlbHNlIGlmIChvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLnJlcG9ydGVyKG91dCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYXN5bmNUaHJvd0lmRmFpbGVkKG91dCk7XG59XG5leHBvcnRzLmFzeW5jUmVwb3J0UnVuRGV0YWlscyA9IGFzeW5jUmVwb3J0UnVuRGV0YWlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9uZUlmTmVlZGVkID0gZXhwb3J0cy5oYXNDbG9uZU1ldGhvZCA9IGV4cG9ydHMuY2xvbmVNZXRob2QgPSB2b2lkIDA7XG5leHBvcnRzLmNsb25lTWV0aG9kID0gU3ltYm9sKCdmYXN0LWNoZWNrL2Nsb25lTWV0aG9kJyk7XG5mdW5jdGlvbiBoYXNDbG9uZU1ldGhvZChpbnN0YW5jZSkge1xuICAgIHJldHVybiAoaW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICAgICAgKHR5cGVvZiBpbnN0YW5jZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGluc3RhbmNlID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgICBleHBvcnRzLmNsb25lTWV0aG9kIGluIGluc3RhbmNlICYmXG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZVtleHBvcnRzLmNsb25lTWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmhhc0Nsb25lTWV0aG9kID0gaGFzQ2xvbmVNZXRob2Q7XG5mdW5jdGlvbiBjbG9uZUlmTmVlZGVkKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGhhc0Nsb25lTWV0aG9kKGluc3RhbmNlKSA/IGluc3RhbmNlW2V4cG9ydHMuY2xvbmVNZXRob2RdKCkgOiBpbnN0YW5jZTtcbn1cbmV4cG9ydHMuY2xvbmVJZk5lZWRlZCA9IGNsb25lSWZOZWVkZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3BhcnNlQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5zdWJhcnJheSA9IGV4cG9ydHMuc2h1ZmZsZWRTdWJhcnJheSA9IGV4cG9ydHMuY2xvbmUgPSBleHBvcnRzLm9uZW9mID0gZXhwb3J0cy5vcHRpb24gPSBleHBvcnRzLm1hcFRvQ29uc3RhbnQgPSBleHBvcnRzLmNvbnN0YW50RnJvbSA9IGV4cG9ydHMuY29uc3RhbnQgPSBleHBvcnRzLmxvcmVtID0gZXhwb3J0cy5iYXNlNjRTdHJpbmcgPSBleHBvcnRzLmhleGFTdHJpbmcgPSBleHBvcnRzLmZ1bGxVbmljb2RlU3RyaW5nID0gZXhwb3J0cy51bmljb2RlU3RyaW5nID0gZXhwb3J0cy5zdHJpbmdPZiA9IGV4cG9ydHMuc3RyaW5nMTZiaXRzID0gZXhwb3J0cy5hc2NpaVN0cmluZyA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5taXhlZENhc2UgPSBleHBvcnRzLmJhc2U2NCA9IGV4cG9ydHMuaGV4YSA9IGV4cG9ydHMuZnVsbFVuaWNvZGUgPSBleHBvcnRzLnVuaWNvZGUgPSBleHBvcnRzLmNoYXIxNmJpdHMgPSBleHBvcnRzLmFzY2lpID0gZXhwb3J0cy5jaGFyID0gZXhwb3J0cy5iaWdVaW50ID0gZXhwb3J0cy5iaWdJbnQgPSBleHBvcnRzLmJpZ1VpbnROID0gZXhwb3J0cy5iaWdJbnROID0gZXhwb3J0cy5tYXhTYWZlTmF0ID0gZXhwb3J0cy5tYXhTYWZlSW50ZWdlciA9IGV4cG9ydHMubmF0ID0gZXhwb3J0cy5pbnRlZ2VyID0gZXhwb3J0cy5kb3VibGUgPSBleHBvcnRzLmZsb2F0ID0gZXhwb3J0cy5mYWxzeSA9IGV4cG9ydHMuYm9vbGVhbiA9IGV4cG9ydHMuYXN5bmNQcm9wZXJ0eSA9IGV4cG9ydHMucHJvcGVydHkgPSBleHBvcnRzLlByZWNvbmRpdGlvbkZhaWx1cmUgPSBleHBvcnRzLnByZSA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5jaGVjayA9IGV4cG9ydHMuc3RhdGlzdGljcyA9IGV4cG9ydHMuc2FtcGxlID0gZXhwb3J0cy5fX2NvbW1pdEhhc2ggPSBleHBvcnRzLl9fdmVyc2lvbiA9IGV4cG9ydHMuX190eXBlID0gdm9pZCAwO1xuZXhwb3J0cy5jbG9uZU1ldGhvZCA9IGV4cG9ydHMuVmFsdWUgPSBleHBvcnRzLkFyYml0cmFyeSA9IGV4cG9ydHMuc2NoZWR1bGVyRm9yID0gZXhwb3J0cy5zY2hlZHVsZXIgPSBleHBvcnRzLmNvbW1hbmRzID0gZXhwb3J0cy5zY2hlZHVsZWRNb2RlbFJ1biA9IGV4cG9ydHMubW9kZWxSdW4gPSBleHBvcnRzLmFzeW5jTW9kZWxSdW4gPSBleHBvcnRzLmJpZ1VpbnQ2NEFycmF5ID0gZXhwb3J0cy5iaWdJbnQ2NEFycmF5ID0gZXhwb3J0cy5mbG9hdDY0QXJyYXkgPSBleHBvcnRzLmZsb2F0MzJBcnJheSA9IGV4cG9ydHMudWludDMyQXJyYXkgPSBleHBvcnRzLmludDMyQXJyYXkgPSBleHBvcnRzLnVpbnQxNkFycmF5ID0gZXhwb3J0cy5pbnQxNkFycmF5ID0gZXhwb3J0cy51aW50OENsYW1wZWRBcnJheSA9IGV4cG9ydHMudWludDhBcnJheSA9IGV4cG9ydHMuaW50OEFycmF5ID0gZXhwb3J0cy51dWlkViA9IGV4cG9ydHMudXVpZCA9IGV4cG9ydHMuZW1haWxBZGRyZXNzID0gZXhwb3J0cy53ZWJVcmwgPSBleHBvcnRzLndlYlF1ZXJ5UGFyYW1ldGVycyA9IGV4cG9ydHMud2ViRnJhZ21lbnRzID0gZXhwb3J0cy53ZWJTZWdtZW50ID0gZXhwb3J0cy53ZWJBdXRob3JpdHkgPSBleHBvcnRzLmRvbWFpbiA9IGV4cG9ydHMuaXBWNiA9IGV4cG9ydHMuaXBWNEV4dGVuZGVkID0gZXhwb3J0cy5pcFY0ID0gZXhwb3J0cy5kYXRlID0gZXhwb3J0cy5jb250ZXh0ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5jb21wYXJlRnVuYyA9IGV4cG9ydHMuY29tcGFyZUJvb2xlYW5GdW5jID0gZXhwb3J0cy5tZW1vID0gZXhwb3J0cy5sZXRyZWMgPSBleHBvcnRzLnVuaWNvZGVKc29uVmFsdWUgPSBleHBvcnRzLnVuaWNvZGVKc29uID0gZXhwb3J0cy5qc29uVmFsdWUgPSBleHBvcnRzLmpzb24gPSBleHBvcnRzLm9iamVjdCA9IGV4cG9ydHMuYW55dGhpbmcgPSBleHBvcnRzLmRpY3Rpb25hcnkgPSBleHBvcnRzLnJlY29yZCA9IGV4cG9ydHMudHVwbGUgPSBleHBvcnRzLnVuaXF1ZUFycmF5ID0gZXhwb3J0cy5pbmZpbml0ZVN0cmVhbSA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlRGVwdGhJZGVudGlmaWVyID0gZXhwb3J0cy5zdHJlYW0gPSBleHBvcnRzLlN0cmVhbSA9IGV4cG9ydHMuUmFuZG9tID0gZXhwb3J0cy5FeGVjdXRpb25TdGF0dXMgPSBleHBvcnRzLnJlc2V0Q29uZmlndXJlR2xvYmFsID0gZXhwb3J0cy5yZWFkQ29uZmlndXJlR2xvYmFsID0gZXhwb3J0cy5jb25maWd1cmVHbG9iYWwgPSBleHBvcnRzLlZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5oYXNoID0gZXhwb3J0cy5hc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlID0gZXhwb3J0cy5kZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGV4cG9ydHMuYXN5bmNTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0RGVwdGhDb250ZXh0Rm9yID0gZXhwb3J0cy5oYXNBc3luY1RvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy5oYXNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMudG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmhhc0Nsb25lTWV0aG9kID0gZXhwb3J0cy5jbG9uZUlmTmVlZGVkID0gdm9pZCAwO1xuY29uc3QgUHJlXzEgPSByZXF1aXJlKFwiLi9jaGVjay9wcmVjb25kaXRpb24vUHJlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcmVfMS5wcmU7IH0gfSk7XG5jb25zdCBBc3luY1Byb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9wcm9wZXJ0eS9Bc3luY1Byb3BlcnR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXN5bmNQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXN5bmNQcm9wZXJ0eV8xLmFzeW5jUHJvcGVydHk7IH0gfSk7XG5jb25zdCBQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vY2hlY2svcHJvcGVydHkvUHJvcGVydHlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvcGVydHlfMS5wcm9wZXJ0eTsgfSB9KTtcbmNvbnN0IFJ1bm5lcl8xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL1J1bm5lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUnVubmVyXzEuYXNzZXJ0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bm5lcl8xLmNoZWNrOyB9IH0pO1xuY29uc3QgU2FtcGxlcl8xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL1NhbXBsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYW1wbGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNhbXBsZXJfMS5zYW1wbGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0aXN0aWNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTYW1wbGVyXzEuc3RhdGlzdGljczsgfSB9KTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJyYXlfMS5hcnJheTsgfSB9KTtcbmNvbnN0IGJpZ0ludF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ0ludFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJpZ0ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnSW50XzEuYmlnSW50OyB9IH0pO1xuY29uc3QgYmlnSW50Tl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ0ludE5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiaWdJbnROXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdJbnROXzEuYmlnSW50TjsgfSB9KTtcbmNvbnN0IGJpZ1VpbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdVaW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnVWludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnVWludF8xLmJpZ1VpbnQ7IH0gfSk7XG5jb25zdCBiaWdVaW50Tl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ1VpbnROXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnVWludE5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ1VpbnROXzEuYmlnVWludE47IH0gfSk7XG5jb25zdCBib29sZWFuXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYm9vbGVhblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJvb2xlYW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvb2xlYW5fMS5ib29sZWFuOyB9IH0pO1xuY29uc3QgZmFsc3lfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mYWxzeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZhbHN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzeV8xLmZhbHN5OyB9IH0pO1xuY29uc3QgYXNjaWlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9hc2NpaVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc2NpaV8xLmFzY2lpOyB9IH0pO1xuY29uc3QgYmFzZTY0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYmFzZTY0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmFzZTY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNjRfMS5iYXNlNjQ7IH0gfSk7XG5jb25zdCBjaGFyXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY2hhclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoYXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYXJfMS5jaGFyOyB9IH0pO1xuY29uc3QgY2hhcjE2Yml0c18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NoYXIxNmJpdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGFyMTZiaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFyMTZiaXRzXzEuY2hhcjE2Yml0czsgfSB9KTtcbmNvbnN0IGZ1bGxVbmljb2RlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZnVsbFVuaWNvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmdWxsVW5pY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVsbFVuaWNvZGVfMS5mdWxsVW5pY29kZTsgfSB9KTtcbmNvbnN0IGhleGFfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9oZXhhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4YV8xLmhleGE7IH0gfSk7XG5jb25zdCB1bmljb2RlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdW5pY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaWNvZGVfMS51bmljb2RlOyB9IH0pO1xuY29uc3QgY29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jb25zdGFudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnN0YW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudF8xLmNvbnN0YW50OyB9IH0pO1xuY29uc3QgY29uc3RhbnRGcm9tXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29uc3RhbnRGcm9tXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uc3RhbnRGcm9tXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudEZyb21fMS5jb25zdGFudEZyb207IH0gfSk7XG5jb25zdCBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29udGV4dFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnRleHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRleHRfMS5jb250ZXh0OyB9IH0pO1xuY29uc3QgZGF0ZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2RhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRlXzEuZGF0ZTsgfSB9KTtcbmNvbnN0IGNsb25lXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY2xvbmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xvbmVfMS5jbG9uZTsgfSB9KTtcbmNvbnN0IGRpY3Rpb25hcnlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9kaWN0aW9uYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGljdGlvbmFyeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGljdGlvbmFyeV8xLmRpY3Rpb25hcnk7IH0gfSk7XG5jb25zdCBlbWFpbEFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9lbWFpbEFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbWFpbEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVtYWlsQWRkcmVzc18xLmVtYWlsQWRkcmVzczsgfSB9KTtcbmNvbnN0IGRvdWJsZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2RvdWJsZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvdWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG91YmxlXzEuZG91YmxlOyB9IH0pO1xuY29uc3QgZmxvYXRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mbG9hdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZsb2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbG9hdF8xLmZsb2F0OyB9IH0pO1xuY29uc3QgY29tcGFyZUJvb2xlYW5GdW5jXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29tcGFyZUJvb2xlYW5GdW5jXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcGFyZUJvb2xlYW5GdW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wYXJlQm9vbGVhbkZ1bmNfMS5jb21wYXJlQm9vbGVhbkZ1bmM7IH0gfSk7XG5jb25zdCBjb21wYXJlRnVuY18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NvbXBhcmVGdW5jXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcGFyZUZ1bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBhcmVGdW5jXzEuY29tcGFyZUZ1bmM7IH0gfSk7XG5jb25zdCBmdW5jXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZnVuY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZ1bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmNfMS5mdW5jOyB9IH0pO1xuY29uc3QgZG9tYWluXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZG9tYWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG9tYWluXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb21haW5fMS5kb21haW47IH0gfSk7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaW50ZWdlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludGVnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVnZXJfMS5pbnRlZ2VyOyB9IH0pO1xuY29uc3QgbWF4U2FmZUludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9tYXhTYWZlSW50ZWdlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1heFNhZmVJbnRlZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhTYWZlSW50ZWdlcl8xLm1heFNhZmVJbnRlZ2VyOyB9IH0pO1xuY29uc3QgbWF4U2FmZU5hdF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L21heFNhZmVOYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXhTYWZlTmF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhTYWZlTmF0XzEubWF4U2FmZU5hdDsgfSB9KTtcbmNvbnN0IG5hdF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L25hdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5hdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0XzEubmF0OyB9IH0pO1xuY29uc3QgaXBWNF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2lwVjRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpcFY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpcFY0XzEuaXBWNDsgfSB9KTtcbmNvbnN0IGlwVjRFeHRlbmRlZF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2lwVjRFeHRlbmRlZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlwVjRFeHRlbmRlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXBWNEV4dGVuZGVkXzEuaXBWNEV4dGVuZGVkOyB9IH0pO1xuY29uc3QgaXBWNl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2lwVjZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpcFY2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpcFY2XzEuaXBWNjsgfSB9KTtcbmNvbnN0IGxldHJlY18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2xldHJlY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxldHJlY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGV0cmVjXzEubGV0cmVjOyB9IH0pO1xuY29uc3QgbG9yZW1fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9sb3JlbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvcmVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb3JlbV8xLmxvcmVtOyB9IH0pO1xuY29uc3QgbWFwVG9Db25zdGFudF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L21hcFRvQ29uc3RhbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXBUb0NvbnN0YW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXBUb0NvbnN0YW50XzEubWFwVG9Db25zdGFudDsgfSB9KTtcbmNvbnN0IG1lbW9fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9tZW1vXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWVtb1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVtb18xLm1lbW87IH0gfSk7XG5jb25zdCBtaXhlZENhc2VfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9taXhlZENhc2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtaXhlZENhc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1peGVkQ2FzZV8xLm1peGVkQ2FzZTsgfSB9KTtcbmNvbnN0IG9iamVjdF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L29iamVjdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9iamVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqZWN0XzEub2JqZWN0OyB9IH0pO1xuY29uc3QganNvbl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2pzb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJqc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uXzEuanNvbjsgfSB9KTtcbmNvbnN0IGFueXRoaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYW55dGhpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhbnl0aGluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYW55dGhpbmdfMS5hbnl0aGluZzsgfSB9KTtcbmNvbnN0IHVuaWNvZGVKc29uVmFsdWVfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91bmljb2RlSnNvblZhbHVlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5pY29kZUpzb25WYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pY29kZUpzb25WYWx1ZV8xLnVuaWNvZGVKc29uVmFsdWU7IH0gfSk7XG5jb25zdCBqc29uVmFsdWVfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9qc29uVmFsdWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJqc29uVmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25WYWx1ZV8xLmpzb25WYWx1ZTsgfSB9KTtcbmNvbnN0IHVuaWNvZGVKc29uXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdW5pY29kZUpzb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmljb2RlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pY29kZUpzb25fMS51bmljb2RlSnNvbjsgfSB9KTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvb25lb2ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbmVvZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb25lb2ZfMS5vbmVvZjsgfSB9KTtcbmNvbnN0IG9wdGlvbl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L29wdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9wdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb3B0aW9uXzEub3B0aW9uOyB9IH0pO1xuY29uc3QgcmVjb3JkXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvcmVjb3JkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVjb3JkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWNvcmRfMS5yZWNvcmQ7IH0gfSk7XG5jb25zdCB1bmlxdWVBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VuaXF1ZUFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5pcXVlQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXF1ZUFycmF5XzEudW5pcXVlQXJyYXk7IH0gfSk7XG5jb25zdCBpbmZpbml0ZVN0cmVhbV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2luZmluaXRlU3RyZWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5maW5pdGVTdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZmluaXRlU3RyZWFtXzEuaW5maW5pdGVTdHJlYW07IH0gfSk7XG5jb25zdCBhc2NpaVN0cmluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2FzY2lpU3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNjaWlTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzY2lpU3RyaW5nXzEuYXNjaWlTdHJpbmc7IH0gfSk7XG5jb25zdCBiYXNlNjRTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iYXNlNjRTdHJpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiYXNlNjRTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2U2NFN0cmluZ18xLmJhc2U2NFN0cmluZzsgfSB9KTtcbmNvbnN0IGZ1bGxVbmljb2RlU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZnVsbFVuaWNvZGVTdHJpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmdWxsVW5pY29kZVN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVsbFVuaWNvZGVTdHJpbmdfMS5mdWxsVW5pY29kZVN0cmluZzsgfSB9KTtcbmNvbnN0IGhleGFTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9oZXhhU3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4YVN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4YVN0cmluZ18xLmhleGFTdHJpbmc7IH0gfSk7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9zdHJpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ18xLnN0cmluZzsgfSB9KTtcbmNvbnN0IHN0cmluZzE2Yml0c18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3N0cmluZzE2Yml0c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZzE2Yml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nMTZiaXRzXzEuc3RyaW5nMTZiaXRzOyB9IH0pO1xuY29uc3Qgc3RyaW5nT2ZfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9zdHJpbmdPZlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ09mXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdPZl8xLnN0cmluZ09mOyB9IH0pO1xuY29uc3QgdW5pY29kZVN0cmluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VuaWNvZGVTdHJpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmljb2RlU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmljb2RlU3RyaW5nXzEudW5pY29kZVN0cmluZzsgfSB9KTtcbmNvbnN0IHN1YmFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc3ViYXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJhcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViYXJyYXlfMS5zdWJhcnJheTsgfSB9KTtcbmNvbnN0IHNodWZmbGVkU3ViYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9zaHVmZmxlZFN1YmFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2h1ZmZsZWRTdWJhcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2h1ZmZsZWRTdWJhcnJheV8xLnNodWZmbGVkU3ViYXJyYXk7IH0gfSk7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3R1cGxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHVwbGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR1cGxlXzEudHVwbGU7IH0gfSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdXVpZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV1aWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV1aWRfMS51dWlkOyB9IH0pO1xuY29uc3QgdXVpZFZfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91dWlkVlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV1aWRWXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dWlkVl8xLnV1aWRWOyB9IH0pO1xuY29uc3Qgd2ViQXV0aG9yaXR5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvd2ViQXV0aG9yaXR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2ViQXV0aG9yaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3ZWJBdXRob3JpdHlfMS53ZWJBdXRob3JpdHk7IH0gfSk7XG5jb25zdCB3ZWJGcmFnbWVudHNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS93ZWJGcmFnbWVudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3ZWJGcmFnbWVudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYkZyYWdtZW50c18xLndlYkZyYWdtZW50czsgfSB9KTtcbmNvbnN0IHdlYlF1ZXJ5UGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3dlYlF1ZXJ5UGFyYW1ldGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndlYlF1ZXJ5UGFyYW1ldGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViUXVlcnlQYXJhbWV0ZXJzXzEud2ViUXVlcnlQYXJhbWV0ZXJzOyB9IH0pO1xuY29uc3Qgd2ViU2VnbWVudF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3dlYlNlZ21lbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3ZWJTZWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3ZWJTZWdtZW50XzEud2ViU2VnbWVudDsgfSB9KTtcbmNvbnN0IHdlYlVybF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3dlYlVybFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndlYlVybFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViVXJsXzEud2ViVXJsOyB9IH0pO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jb21tYW5kc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbW1hbmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tYW5kc18xLmNvbW1hbmRzOyB9IH0pO1xuY29uc3QgTW9kZWxSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL21vZGVsL01vZGVsUnVubmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXN5bmNNb2RlbFJ1blwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9kZWxSdW5uZXJfMS5hc3luY01vZGVsUnVuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibW9kZWxSdW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vZGVsUnVubmVyXzEubW9kZWxSdW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY2hlZHVsZWRNb2RlbFJ1blwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9kZWxSdW5uZXJfMS5zY2hlZHVsZWRNb2RlbFJ1bjsgfSB9KTtcbmNvbnN0IFJhbmRvbV8xID0gcmVxdWlyZShcIi4vcmFuZG9tL2dlbmVyYXRvci9SYW5kb21cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSYW5kb21cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhbmRvbV8xLlJhbmRvbTsgfSB9KTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL0dsb2JhbFBhcmFtZXRlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25maWd1cmVHbG9iYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdsb2JhbFBhcmFtZXRlcnNfMS5jb25maWd1cmVHbG9iYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWFkQ29uZmlndXJlR2xvYmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc2V0Q29uZmlndXJlR2xvYmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHbG9iYWxQYXJhbWV0ZXJzXzEucmVzZXRDb25maWd1cmVHbG9iYWw7IH0gfSk7XG5jb25zdCBWZXJib3NpdHlMZXZlbF8xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZXJib3NpdHlMZXZlbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbDsgfSB9KTtcbmNvbnN0IEV4ZWN1dGlvblN0YXR1c18xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL3JlcG9ydGVyL0V4ZWN1dGlvblN0YXR1c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV4ZWN1dGlvblN0YXR1c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzOyB9IH0pO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4vY2hlY2svc3ltYm9sc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW1ib2xzXzEuY2xvbmVNZXRob2Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZUlmTmVlZGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW1ib2xzXzEuY2xvbmVJZk5lZWRlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc0Nsb25lTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW1ib2xzXzEuaGFzQ2xvbmVNZXRob2Q7IH0gfSk7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS9TdHJlYW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmVhbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyZWFtXzEuc3RyZWFtOyB9IH0pO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4vdXRpbHMvaGFzaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hfMS5oYXNoOyB9IH0pO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi91dGlscy9zdHJpbmdpZnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jU3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5hc3luY1N0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU3RyaW5nTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS50b1N0cmluZ01ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc1RvU3RyaW5nTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5oYXNUb1N0cmluZ01ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jVG9TdHJpbmdNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLmFzeW5jVG9TdHJpbmdNZXRob2Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNBc3luY1RvU3RyaW5nTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5oYXNBc3luY1RvU3RyaW5nTWV0aG9kOyB9IH0pO1xuY29uc3Qgc2NoZWR1bGVyXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc2NoZWR1bGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NoZWR1bGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2hlZHVsZXJfMS5zY2hlZHVsZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY2hlZHVsZXJGb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjaGVkdWxlcl8xLnNjaGVkdWxlckZvcjsgfSB9KTtcbmNvbnN0IFJ1bkRldGFpbHNGb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci91dGlscy9SdW5EZXRhaWxzRm9ybWF0dGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFJlcG9ydE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bkRldGFpbHNGb3JtYXR0ZXJfMS5kZWZhdWx0UmVwb3J0TWVzc2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bkRldGFpbHNGb3JtYXR0ZXJfMS5hc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlOyB9IH0pO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4vY2hlY2svcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcmVjb25kaXRpb25GYWlsdXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZTsgfSB9KTtcbmNvbnN0IGludDhBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2ludDhBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludDhBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50OEFycmF5XzEuaW50OEFycmF5OyB9IH0pO1xuY29uc3QgaW50MTZBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2ludDE2QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnQxNkFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnQxNkFycmF5XzEuaW50MTZBcnJheTsgfSB9KTtcbmNvbnN0IGludDMyQXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbnQzMkFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50MzJBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50MzJBcnJheV8xLmludDMyQXJyYXk7IH0gfSk7XG5jb25zdCB1aW50OEFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdWludDhBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVpbnQ4QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVpbnQ4QXJyYXlfMS51aW50OEFycmF5OyB9IH0pO1xuY29uc3QgdWludDhDbGFtcGVkQXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91aW50OENsYW1wZWRBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVpbnQ4Q2xhbXBlZEFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aW50OENsYW1wZWRBcnJheV8xLnVpbnQ4Q2xhbXBlZEFycmF5OyB9IH0pO1xuY29uc3QgdWludDE2QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91aW50MTZBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVpbnQxNkFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aW50MTZBcnJheV8xLnVpbnQxNkFycmF5OyB9IH0pO1xuY29uc3QgdWludDMyQXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91aW50MzJBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVpbnQzMkFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aW50MzJBcnJheV8xLnVpbnQzMkFycmF5OyB9IH0pO1xuY29uc3QgZmxvYXQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZmxvYXQzMkFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmxvYXQzMkFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbG9hdDMyQXJyYXlfMS5mbG9hdDMyQXJyYXk7IH0gfSk7XG5jb25zdCBmbG9hdDY0QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mbG9hdDY0QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmbG9hdDY0QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZsb2F0NjRBcnJheV8xLmZsb2F0NjRBcnJheTsgfSB9KTtcbmNvbnN0IHNwYXJzZUFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc3BhcnNlQXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzcGFyc2VBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3BhcnNlQXJyYXlfMS5zcGFyc2VBcnJheTsgfSB9KTtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXJiaXRyYXJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBcmJpdHJhcnlfMS5BcmJpdHJhcnk7IH0gfSk7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vVmFsdWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVmFsdWVfMS5WYWx1ZTsgfSB9KTtcbmNvbnN0IERlcHRoQ29udGV4dF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9EZXB0aENvbnRleHRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVEZXB0aElkZW50aWZpZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlcHRoQ29udGV4dF8xLmNyZWF0ZURlcHRoSWRlbnRpZmllcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERlcHRoQ29udGV4dEZvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVwdGhDb250ZXh0XzEuZ2V0RGVwdGhDb250ZXh0Rm9yOyB9IH0pO1xuY29uc3QgYmlnSW50NjRBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ0ludDY0QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiaWdJbnQ2NEFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdJbnQ2NEFycmF5XzEuYmlnSW50NjRBcnJheTsgfSB9KTtcbmNvbnN0IGJpZ1VpbnQ2NEFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYmlnVWludDY0QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiaWdVaW50NjRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnVWludDY0QXJyYXlfMS5iaWdVaW50NjRBcnJheTsgfSB9KTtcbmNvbnN0IF9fdHlwZSA9ICdjb21tb25qcyc7XG5leHBvcnRzLl9fdHlwZSA9IF9fdHlwZTtcbmNvbnN0IF9fdmVyc2lvbiA9ICczLjEuMSc7XG5leHBvcnRzLl9fdmVyc2lvbiA9IF9fdmVyc2lvbjtcbmNvbnN0IF9fY29tbWl0SGFzaCA9ICczNWFjNzc1ZDNhMjM1M2E5NDU4YjE0MjZjMmFjOTczOTdiOTljZGJkJztcbmV4cG9ydHMuX19jb21taXRIYXNoID0gX19jb21taXRIYXNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZjID0gcmVxdWlyZShcIi4vZmFzdC1jaGVjay1kZWZhdWx0XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmM7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmFzdC1jaGVjay1kZWZhdWx0XCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SYW5kb20gPSB2b2lkIDA7XG5jb25zdCBwdXJlX3JhbmRfMSA9IHJlcXVpcmUoXCJwdXJlLXJhbmRcIik7XG5jbGFzcyBSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZVJuZykge1xuICAgICAgICB0aGlzLmludGVybmFsUm5nID0gc291cmNlUm5nLmNsb25lKCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmRvbSh0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dChiaXRzKSB7XG4gICAgICAgIHJldHVybiAoMCwgcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbikoMCwgKDEgPDwgYml0cykgLSAxLCB0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dEJvb2xlYW4oKSB7XG4gICAgICAgIHJldHVybiAoMCwgcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbikoMCwgMSwgdGhpcy5pbnRlcm5hbFJuZykgPT0gMTtcbiAgICB9XG4gICAgbmV4dEludChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gKDAsIHB1cmVfcmFuZF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24pKG1pbiA9PSBudWxsID8gUmFuZG9tLk1JTl9JTlQgOiBtaW4sIG1heCA9PSBudWxsID8gUmFuZG9tLk1BWF9JTlQgOiBtYXgsIHRoaXMuaW50ZXJuYWxSbmcpO1xuICAgIH1cbiAgICBuZXh0QmlnSW50KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiAoMCwgcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbikobWluLCBtYXgsIHRoaXMuaW50ZXJuYWxSbmcpO1xuICAgIH1cbiAgICBuZXh0QXJyYXlJbnQobWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwdXJlX3JhbmRfMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24pKG1pbiwgbWF4LCB0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dERvdWJsZSgpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMubmV4dCgyNik7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLm5leHQoMjcpO1xuICAgICAgICByZXR1cm4gKGEgKiBSYW5kb20uREJMX0ZBQ1RPUiArIGIpICogUmFuZG9tLkRCTF9ESVZJU09SO1xuICAgIH1cbn1cbmV4cG9ydHMuUmFuZG9tID0gUmFuZG9tO1xuUmFuZG9tLk1JTl9JTlQgPSAweDgwMDAwMDAwIHwgMDtcblJhbmRvbS5NQVhfSU5UID0gMHg3ZmZmZmZmZiB8IDA7XG5SYW5kb20uREJMX0ZBQ1RPUiA9IE1hdGgucG93KDIsIDI3KTtcblJhbmRvbS5EQkxfRElWSVNPUiA9IE1hdGgucG93KDIsIC01Myk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZUxhenkgPSB2b2lkIDA7XG5jbGFzcyBMYXp5SXRlcmFibGVJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IocHJvZHVjZXIpIHtcbiAgICAgICAgdGhpcy5wcm9kdWNlciA9IHByb2R1Y2VyO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pdCA9IHRoaXMucHJvZHVjZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdDtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pdCA9IHRoaXMucHJvZHVjZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdC5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUxhenkocHJvZHVjZXIpIHtcbiAgICByZXR1cm4gbmV3IExhenlJdGVyYWJsZUl0ZXJhdG9yKHByb2R1Y2VyKTtcbn1cbmV4cG9ydHMubWFrZUxhenkgPSBtYWtlTGF6eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJlYW0gPSBleHBvcnRzLlN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbUhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL1N0cmVhbUhlbHBlcnNcIik7XG5jbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGcpIHtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICB9XG4gICAgc3RhdGljIG5pbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oKDAsIFN0cmVhbUhlbHBlcnNfMS5uaWxIZWxwZXIpKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgb2YoLi4uZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oZWxlbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZy5uZXh0KCk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nO1xuICAgIH1cbiAgICBtYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbSgoMCwgU3RyZWFtSGVscGVyc18xLm1hcEhlbHBlcikodGhpcy5nLCBmKSk7XG4gICAgfVxuICAgIGZsYXRNYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbSgoMCwgU3RyZWFtSGVscGVyc18xLmZsYXRNYXBIZWxwZXIpKHRoaXMuZywgZikpO1xuICAgIH1cbiAgICBkcm9wV2hpbGUoZikge1xuICAgICAgICBsZXQgZm91bmRFbGlnaWJsZSA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiogaGVscGVyKHYpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZEVsaWdpYmxlIHx8ICFmKHYpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRFbGlnaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgeWllbGQgdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mbGF0TWFwKGhlbHBlcik7XG4gICAgfVxuICAgIGRyb3Aobikge1xuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgZnVuY3Rpb24gaGVscGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkeCsrIDwgbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kcm9wV2hpbGUoaGVscGVyKTtcbiAgICB9XG4gICAgdGFrZVdoaWxlKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oKDAsIFN0cmVhbUhlbHBlcnNfMS50YWtlV2hpbGVIZWxwZXIpKHRoaXMuZywgZikpO1xuICAgIH1cbiAgICB0YWtlKG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oKDAsIFN0cmVhbUhlbHBlcnNfMS50YWtlTkhlbHBlcikodGhpcy5nLCBuKSk7XG4gICAgfVxuICAgIGZpbHRlcihmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKCgwLCBTdHJlYW1IZWxwZXJzXzEuZmlsdGVySGVscGVyKSh0aGlzLmcsIGYpKTtcbiAgICB9XG4gICAgZXZlcnkoZikge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5nKSB7XG4gICAgICAgICAgICBpZiAoIWYodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhcyhmKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLmcpIHtcbiAgICAgICAgICAgIGlmIChmKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCB2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBudWxsXTtcbiAgICB9XG4gICAgam9pbiguLi5vdGhlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oKDAsIFN0cmVhbUhlbHBlcnNfMS5qb2luSGVscGVyKSh0aGlzLmcsIG90aGVycykpO1xuICAgIH1cbiAgICBnZXROdGhPckxhc3QobnRoKSB7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSBudGg7XG4gICAgICAgIGxldCBsYXN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuZykge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZy0tID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgbGFzdCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG5mdW5jdGlvbiBzdHJlYW0oZykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtKGcpO1xufVxuZXhwb3J0cy5zdHJlYW0gPSBzdHJlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuam9pbkhlbHBlciA9IGV4cG9ydHMudGFrZVdoaWxlSGVscGVyID0gZXhwb3J0cy50YWtlTkhlbHBlciA9IGV4cG9ydHMuZmlsdGVySGVscGVyID0gZXhwb3J0cy5mbGF0TWFwSGVscGVyID0gZXhwb3J0cy5tYXBIZWxwZXIgPSBleHBvcnRzLm5pbEhlbHBlciA9IHZvaWQgMDtcbmNsYXNzIE5pbCB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lOiB0cnVlIH07XG4gICAgfVxufVxuTmlsLm5pbCA9IG5ldyBOaWwoKTtcbmZ1bmN0aW9uIG5pbEhlbHBlcigpIHtcbiAgICByZXR1cm4gTmlsLm5pbDtcbn1cbmV4cG9ydHMubmlsSGVscGVyID0gbmlsSGVscGVyO1xuZnVuY3Rpb24qIG1hcEhlbHBlcihnLCBmKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIGcpIHtcbiAgICAgICAgeWllbGQgZih2KTtcbiAgICB9XG59XG5leHBvcnRzLm1hcEhlbHBlciA9IG1hcEhlbHBlcjtcbmZ1bmN0aW9uKiBmbGF0TWFwSGVscGVyKGcsIGYpIHtcbiAgICBmb3IgKGNvbnN0IHYgb2YgZykge1xuICAgICAgICB5aWVsZCogZih2KTtcbiAgICB9XG59XG5leHBvcnRzLmZsYXRNYXBIZWxwZXIgPSBmbGF0TWFwSGVscGVyO1xuZnVuY3Rpb24qIGZpbHRlckhlbHBlcihnLCBmKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIGcpIHtcbiAgICAgICAgaWYgKGYodikpIHtcbiAgICAgICAgICAgIHlpZWxkIHY7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZpbHRlckhlbHBlciA9IGZpbHRlckhlbHBlcjtcbmZ1bmN0aW9uKiB0YWtlTkhlbHBlcihnLCBuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgY3VyID0gZy5uZXh0KCk7XG4gICAgICAgIGlmIChjdXIuZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZU5IZWxwZXIgPSB0YWtlTkhlbHBlcjtcbmZ1bmN0aW9uKiB0YWtlV2hpbGVIZWxwZXIoZywgZikge1xuICAgIGxldCBjdXIgPSBnLm5leHQoKTtcbiAgICB3aGlsZSAoIWN1ci5kb25lICYmIGYoY3VyLnZhbHVlKSkge1xuICAgICAgICB5aWVsZCBjdXIudmFsdWU7XG4gICAgICAgIGN1ciA9IGcubmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZVdoaWxlSGVscGVyID0gdGFrZVdoaWxlSGVscGVyO1xuZnVuY3Rpb24qIGpvaW5IZWxwZXIoZywgb3RoZXJzKSB7XG4gICAgZm9yIChsZXQgY3VyID0gZy5uZXh0KCk7ICFjdXIuZG9uZTsgY3VyID0gZy5uZXh0KCkpIHtcbiAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHMgb2Ygb3RoZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHMubmV4dCgpOyAhY3VyLmRvbmU7IGN1ciA9IHMubmV4dCgpKSB7XG4gICAgICAgICAgICB5aWVsZCBjdXIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmpvaW5IZWxwZXIgPSBqb2luSGVscGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2ggPSB2b2lkIDA7XG5jb25zdCBjcmMzMlRhYmxlID0gW1xuICAgIDB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4ZWUwZTYxMmMsIDB4OTkwOTUxYmEsIDB4MDc2ZGM0MTksIDB4NzA2YWY0OGYsIDB4ZTk2M2E1MzUsIDB4OWU2NDk1YTMsIDB4MGVkYjg4MzIsXG4gICAgMHg3OWRjYjhhNCwgMHhlMGQ1ZTkxZSwgMHg5N2QyZDk4OCwgMHgwOWI2NGMyYiwgMHg3ZWIxN2NiZCwgMHhlN2I4MmQwNywgMHg5MGJmMWQ5MSwgMHgxZGI3MTA2NCwgMHg2YWIwMjBmMixcbiAgICAweGYzYjk3MTQ4LCAweDg0YmU0MWRlLCAweDFhZGFkNDdkLCAweDZkZGRlNGViLCAweGY0ZDRiNTUxLCAweDgzZDM4NWM3LCAweDEzNmM5ODU2LCAweDY0NmJhOGMwLCAweGZkNjJmOTdhLFxuICAgIDB4OGE2NWM5ZWMsIDB4MTQwMTVjNGYsIDB4NjMwNjZjZDksIDB4ZmEwZjNkNjMsIDB4OGQwODBkZjUsIDB4M2I2ZTIwYzgsIDB4NGM2OTEwNWUsIDB4ZDU2MDQxZTQsIDB4YTI2NzcxNzIsXG4gICAgMHgzYzAzZTRkMSwgMHg0YjA0ZDQ0NywgMHhkMjBkODVmZCwgMHhhNTBhYjU2YiwgMHgzNWI1YThmYSwgMHg0MmIyOTg2YywgMHhkYmJiYzlkNiwgMHhhY2JjZjk0MCwgMHgzMmQ4NmNlMyxcbiAgICAweDQ1ZGY1Yzc1LCAweGRjZDYwZGNmLCAweGFiZDEzZDU5LCAweDI2ZDkzMGFjLCAweDUxZGUwMDNhLCAweGM4ZDc1MTgwLCAweGJmZDA2MTE2LCAweDIxYjRmNGI1LCAweDU2YjNjNDIzLFxuICAgIDB4Y2ZiYTk1OTksIDB4YjhiZGE1MGYsIDB4MjgwMmI4OWUsIDB4NWYwNTg4MDgsIDB4YzYwY2Q5YjIsIDB4YjEwYmU5MjQsIDB4MmY2ZjdjODcsIDB4NTg2ODRjMTEsIDB4YzE2MTFkYWIsXG4gICAgMHhiNjY2MmQzZCwgMHg3NmRjNDE5MCwgMHgwMWRiNzEwNiwgMHg5OGQyMjBiYywgMHhlZmQ1MTAyYSwgMHg3MWIxODU4OSwgMHgwNmI2YjUxZiwgMHg5ZmJmZTRhNSwgMHhlOGI4ZDQzMyxcbiAgICAweDc4MDdjOWEyLCAweDBmMDBmOTM0LCAweDk2MDlhODhlLCAweGUxMGU5ODE4LCAweDdmNmEwZGJiLCAweDA4NmQzZDJkLCAweDkxNjQ2Yzk3LCAweGU2NjM1YzAxLCAweDZiNmI1MWY0LFxuICAgIDB4MWM2YzYxNjIsIDB4ODU2NTMwZDgsIDB4ZjI2MjAwNGUsIDB4NmMwNjk1ZWQsIDB4MWIwMWE1N2IsIDB4ODIwOGY0YzEsIDB4ZjUwZmM0NTcsIDB4NjViMGQ5YzYsIDB4MTJiN2U5NTAsXG4gICAgMHg4YmJlYjhlYSwgMHhmY2I5ODg3YywgMHg2MmRkMWRkZiwgMHgxNWRhMmQ0OSwgMHg4Y2QzN2NmMywgMHhmYmQ0NGM2NSwgMHg0ZGIyNjE1OCwgMHgzYWI1NTFjZSwgMHhhM2JjMDA3NCxcbiAgICAweGQ0YmIzMGUyLCAweDRhZGZhNTQxLCAweDNkZDg5NWQ3LCAweGE0ZDFjNDZkLCAweGQzZDZmNGZiLCAweDQzNjllOTZhLCAweDM0NmVkOWZjLCAweGFkNjc4ODQ2LCAweGRhNjBiOGQwLFxuICAgIDB4NDQwNDJkNzMsIDB4MzMwMzFkZTUsIDB4YWEwYTRjNWYsIDB4ZGQwZDdjYzksIDB4NTAwNTcxM2MsIDB4MjcwMjQxYWEsIDB4YmUwYjEwMTAsIDB4YzkwYzIwODYsIDB4NTc2OGI1MjUsXG4gICAgMHgyMDZmODViMywgMHhiOTY2ZDQwOSwgMHhjZTYxZTQ5ZiwgMHg1ZWRlZjkwZSwgMHgyOWQ5Yzk5OCwgMHhiMGQwOTgyMiwgMHhjN2Q3YThiNCwgMHg1OWIzM2QxNywgMHgyZWI0MGQ4MSxcbiAgICAweGI3YmQ1YzNiLCAweGMwYmE2Y2FkLCAweGVkYjg4MzIwLCAweDlhYmZiM2I2LCAweDAzYjZlMjBjLCAweDc0YjFkMjlhLCAweGVhZDU0NzM5LCAweDlkZDI3N2FmLCAweDA0ZGIyNjE1LFxuICAgIDB4NzNkYzE2ODMsIDB4ZTM2MzBiMTIsIDB4OTQ2NDNiODQsIDB4MGQ2ZDZhM2UsIDB4N2E2YTVhYTgsIDB4ZTQwZWNmMGIsIDB4OTMwOWZmOWQsIDB4MGEwMGFlMjcsIDB4N2QwNzllYjEsXG4gICAgMHhmMDBmOTM0NCwgMHg4NzA4YTNkMiwgMHgxZTAxZjI2OCwgMHg2OTA2YzJmZSwgMHhmNzYyNTc1ZCwgMHg4MDY1NjdjYiwgMHgxOTZjMzY3MSwgMHg2ZTZiMDZlNywgMHhmZWQ0MWI3NixcbiAgICAweDg5ZDMyYmUwLCAweDEwZGE3YTVhLCAweDY3ZGQ0YWNjLCAweGY5YjlkZjZmLCAweDhlYmVlZmY5LCAweDE3YjdiZTQzLCAweDYwYjA4ZWQ1LCAweGQ2ZDZhM2U4LCAweGExZDE5MzdlLFxuICAgIDB4MzhkOGMyYzQsIDB4NGZkZmYyNTIsIDB4ZDFiYjY3ZjEsIDB4YTZiYzU3NjcsIDB4M2ZiNTA2ZGQsIDB4NDhiMjM2NGIsIDB4ZDgwZDJiZGEsIDB4YWYwYTFiNGMsIDB4MzYwMzRhZjYsXG4gICAgMHg0MTA0N2E2MCwgMHhkZjYwZWZjMywgMHhhODY3ZGY1NSwgMHgzMTZlOGVlZiwgMHg0NjY5YmU3OSwgMHhjYjYxYjM4YywgMHhiYzY2ODMxYSwgMHgyNTZmZDJhMCwgMHg1MjY4ZTIzNixcbiAgICAweGNjMGM3Nzk1LCAweGJiMGI0NzAzLCAweDIyMDIxNmI5LCAweDU1MDUyNjJmLCAweGM1YmEzYmJlLCAweGIyYmQwYjI4LCAweDJiYjQ1YTkyLCAweDVjYjM2YTA0LCAweGMyZDdmZmE3LFxuICAgIDB4YjVkMGNmMzEsIDB4MmNkOTllOGIsIDB4NWJkZWFlMWQsIDB4OWI2NGMyYjAsIDB4ZWM2M2YyMjYsIDB4NzU2YWEzOWMsIDB4MDI2ZDkzMGEsIDB4OWMwOTA2YTksIDB4ZWIwZTM2M2YsXG4gICAgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMywgMHg5NWJmNGE4MiwgMHhlMmI4N2ExNCwgMHg3YmIxMmJhZSwgMHgwY2I2MWIzOCwgMHg5MmQyOGU5YiwgMHhlNWQ1YmUwZCwgMHg3Y2RjZWZiNyxcbiAgICAweDBiZGJkZjIxLCAweDg2ZDNkMmQ0LCAweGYxZDRlMjQyLCAweDY4ZGRiM2Y4LCAweDFmZGE4MzZlLCAweDgxYmUxNmNkLCAweGY2YjkyNjViLCAweDZmYjA3N2UxLCAweDE4Yjc0Nzc3LFxuICAgIDB4ODgwODVhZTYsIDB4ZmYwZjZhNzAsIDB4NjYwNjNiY2EsIDB4MTEwMTBiNWMsIDB4OGY2NTllZmYsIDB4Zjg2MmFlNjksIDB4NjE2YmZmZDMsIDB4MTY2Y2NmNDUsIDB4YTAwYWUyNzgsXG4gICAgMHhkNzBkZDJlZSwgMHg0ZTA0ODM1NCwgMHgzOTAzYjNjMiwgMHhhNzY3MjY2MSwgMHhkMDYwMTZmNywgMHg0OTY5NDc0ZCwgMHgzZTZlNzdkYiwgMHhhZWQxNmE0YSwgMHhkOWQ2NWFkYyxcbiAgICAweDQwZGYwYjY2LCAweDM3ZDgzYmYwLCAweGE5YmNhZTUzLCAweGRlYmI5ZWM1LCAweDQ3YjJjZjdmLCAweDMwYjVmZmU5LCAweGJkYmRmMjFjLCAweGNhYmFjMjhhLCAweDUzYjM5MzMwLFxuICAgIDB4MjRiNGEzYTYsIDB4YmFkMDM2MDUsIDB4Y2RkNzA2OTMsIDB4NTRkZTU3MjksIDB4MjNkOTY3YmYsIDB4YjM2NjdhMmUsIDB4YzQ2MTRhYjgsIDB4NWQ2ODFiMDIsIDB4MmE2ZjJiOTQsXG4gICAgMHhiNDBiYmUzNywgMHhjMzBjOGVhMSwgMHg1YTA1ZGYxYiwgMHgyZDAyZWY4ZCxcbl07XG5mdW5jdGlvbiBoYXNoKHJlcHIpIHtcbiAgICBsZXQgY3JjID0gMHhmZmZmZmZmZjtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCByZXByLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgY29uc3QgYyA9IHJlcHIuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gY10gXiAoY3JjID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTkyIHwgKChjID4+IDYpICYgMzEpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTI4IHwgKGMgJiA2MykpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8IDB4ZTAwMCkge1xuICAgICAgICAgICAgY29uc3QgY05leHQgPSByZXByLmNoYXJDb2RlQXQoKytpZHgpO1xuICAgICAgICAgICAgaWYgKGMgPj0gMHhkYzAwIHx8IGNOZXh0IDwgMHhkYzAwIHx8IGNOZXh0ID4gMHhkZmZmIHx8IE51bWJlci5pc05hTihjTmV4dCkpIHtcbiAgICAgICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIDB4ZWZdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIDB4YmZdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIDB4YmRdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMxID0gKGMgJiAxMDIzKSArIDY0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gY05leHQgJiAxMDIzO1xuICAgICAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDI0MCB8ICgoYzEgPj4gOCkgJiA3KSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoKGMxID4+IDIpICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8ICgoYzIgPj4gNikgJiAxNSkgfCAoKGMxICYgMykgPDwgNCkpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTI4IHwgKGMyICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMjI0IHwgKChjID4+IDEyKSAmIDE1KSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8ICgoYyA+PiA2KSAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8IChjICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoY3JjIHwgMCkgKyAweDgwMDAwMDAwO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3luY1N0cmluZ2lmeSA9IGV4cG9ydHMucG9zc2libHlBc3luY1N0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnlJbnRlcm5hbCA9IGV4cG9ydHMuaGFzQXN5bmNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMuaGFzVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLnRvU3RyaW5nTWV0aG9kID0gdm9pZCAwO1xuZXhwb3J0cy50b1N0cmluZ01ldGhvZCA9IFN5bWJvbCgnZmFzdC1jaGVjay90b1N0cmluZ01ldGhvZCcpO1xuZnVuY3Rpb24gaGFzVG9TdHJpbmdNZXRob2QoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgZXhwb3J0cy50b1N0cmluZ01ldGhvZCBpbiBpbnN0YW5jZSAmJlxuICAgICAgICB0eXBlb2YgaW5zdGFuY2VbZXhwb3J0cy50b1N0cmluZ01ldGhvZF0gPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5oYXNUb1N0cmluZ01ldGhvZCA9IGhhc1RvU3RyaW5nTWV0aG9kO1xuZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kID0gU3ltYm9sKCdmYXN0LWNoZWNrL2FzeW5jVG9TdHJpbmdNZXRob2QnKTtcbmZ1bmN0aW9uIGhhc0FzeW5jVG9TdHJpbmdNZXRob2QoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kIGluIGluc3RhbmNlICYmXG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZVtleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2RdID09PSAnZnVuY3Rpb24nKTtcbn1cbmV4cG9ydHMuaGFzQXN5bmNUb1N0cmluZ01ldGhvZCA9IGhhc0FzeW5jVG9TdHJpbmdNZXRob2Q7XG5jb25zdCBmaW5kU3ltYm9sTmFtZVJlZ2V4ID0gL15TeW1ib2xcXCgoLiopXFwpJC87XG5mdW5jdGlvbiBnZXRTeW1ib2xEZXNjcmlwdGlvbihzKSB7XG4gICAgaWYgKHMuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHMuZGVzY3JpcHRpb247XG4gICAgY29uc3QgbSA9IGZpbmRTeW1ib2xOYW1lUmVnZXguZXhlYyhTdHJpbmcocykpO1xuICAgIHJldHVybiBtICYmIG1bMV0ubGVuZ3RoID8gbVsxXSA6IG51bGw7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIobnVtVmFsdWUpIHtcbiAgICBzd2l0Y2ggKG51bVZhbHVlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAxIC8gbnVtVmFsdWUgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA/ICctMCcgOiAnMCc7XG4gICAgICAgIGNhc2UgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFknO1xuICAgICAgICBjYXNlIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTpcbiAgICAgICAgICAgIHJldHVybiAnTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudW1WYWx1ZSA9PT0gbnVtVmFsdWUgPyBTdHJpbmcobnVtVmFsdWUpIDogJ051bWJlci5OYU4nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3BhcnNlQXJyYXkoYXJyKSB7XG4gICAgbGV0IHByZXZpb3VzTnVtYmVyZWRJbmRleCA9IC0xO1xuICAgIGZvciAoY29uc3QgaW5kZXggaW4gYXJyKSB7XG4gICAgICAgIGNvbnN0IG51bWJlcmVkSW5kZXggPSBOdW1iZXIoaW5kZXgpO1xuICAgICAgICBpZiAobnVtYmVyZWRJbmRleCAhPT0gcHJldmlvdXNOdW1iZXJlZEluZGV4ICsgMSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBwcmV2aW91c051bWJlcmVkSW5kZXggPSBudW1iZXJlZEluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNOdW1iZXJlZEluZGV4ICsgMSAhPT0gYXJyLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUludGVybmFsKHZhbHVlLCBwcmV2aW91c1ZhbHVlcywgZ2V0QXN5bmNDb250ZW50KSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlcyA9IHByZXZpb3VzVmFsdWVzLmNvbmNhdChbdmFsdWVdKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tjeWNsaWNdJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzQXN5bmNUb1N0cmluZ01ldGhvZCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGdldEFzeW5jQ29udGVudCh2YWx1ZSk7XG4gICAgICAgIGlmIChjb250ZW50LnN0YXRlID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1RvU3RyaW5nTWV0aG9kKHZhbHVlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2V4cG9ydHMudG9TdHJpbmdNZXRob2RdKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSkge1xuICAgICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPj0gNTAgJiYgaXNTcGFyc2VBcnJheShhcnIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIGFycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihOdW1iZXIoaW5kZXgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2goYCR7aW5kZXh9OiR7c3RyaW5naWZ5SW50ZXJuYWwoYXJyW2luZGV4XSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnbm1lbnRzLmxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGBPYmplY3QuYXNzaWduKEFycmF5KCR7YXJyLmxlbmd0aH0pLHske2Fzc2lnbm1lbnRzLmpvaW4oJywnKX19KWBcbiAgICAgICAgICAgICAgICAgICAgOiBgQXJyYXkoJHthcnIubGVuZ3RofSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRBcnJheSA9IGFyci5tYXAoKHYpID0+IHN0cmluZ2lmeUludGVybmFsKHYsIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCkpLmpvaW4oJywnKTtcbiAgICAgICAgICAgIHJldHVybiBhcnIubGVuZ3RoID09PSAwIHx8IGFyci5sZW5ndGggLSAxIGluIGFyciA/IGBbJHtzdHJpbmdpZmllZEFycmF5fV1gIDogYFske3N0cmluZ2lmaWVkQXJyYXl9LF1gO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQmlnSW50XSc6XG4gICAgICAgICAgICByZXR1cm4gYCR7dmFsdWV9bmA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYG5ldyBCb29sZWFuKCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSlgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzoge1xuICAgICAgICAgICAgY29uc3QgZCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkLmdldFRpbWUoKSkgPyBgbmV3IERhdGUoTmFOKWAgOiBgbmV3IERhdGUoJHtKU09OLnN0cmluZ2lmeShkLnRvSVNPU3RyaW5nKCkpfSlgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTWFwXSc6XG4gICAgICAgICAgICByZXR1cm4gYG5ldyBNYXAoJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlKSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBOdWxsXSc6XG4gICAgICAgICAgICByZXR1cm4gYG51bGxgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBzdHJpbmdpZnlOdW1iZXIodmFsdWUpIDogYG5ldyBOdW1iZXIoJHtzdHJpbmdpZnlOdW1iZXIoTnVtYmVyKHZhbHVlKSl9KWA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9TdHJpbmdBY2Nlc3NvciA9IHZhbHVlLnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9TdHJpbmdBY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZ0FjY2Vzc29yICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXBwZXIgPSAoaykgPT4gYCR7ayA9PT0gJ19fcHJvdG9fXydcbiAgICAgICAgICAgICAgICA/ICdbXCJfX3Byb3RvX19cIl0nXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgayA9PT0gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgICAgPyBgWyR7c3RyaW5naWZ5SW50ZXJuYWwoaywgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX1dYFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGspfToke3N0cmluZ2lmeUludGVybmFsKHZhbHVlW2tdLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfWA7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModmFsdWUpLm1hcChtYXBwZXIpLFxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChtYXBwZXIpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1JlcHIgPSAneycgKyBzdHJpbmdpZmllZFByb3BlcnRpZXMuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3UmVwciA9PT0gJ3t9JyA/ICdPYmplY3QuY3JlYXRlKG51bGwpJyA6IGBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksJHtyYXdSZXByfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhd1JlcHI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnW29iamVjdCBTZXRdJzpcbiAgICAgICAgICAgIHJldHVybiBgbmV3IFNldCgke3N0cmluZ2lmeUludGVybmFsKEFycmF5LmZyb20odmFsdWUpLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgbmV3IFN0cmluZygke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzoge1xuICAgICAgICAgICAgY29uc3QgcyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKFN5bWJvbC5rZXlGb3IocykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgU3ltYm9sLmZvcigke0pTT04uc3RyaW5naWZ5KFN5bWJvbC5rZXlGb3IocykpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVzYyA9IGdldFN5bWJvbERlc2NyaXB0aW9uKHMpO1xuICAgICAgICAgICAgaWYgKGRlc2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1N5bWJvbCgpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtub3duU3ltYm9sID0gZGVzYy5zdGFydHNXaXRoKCdTeW1ib2wuJykgJiYgU3ltYm9sW2Rlc2Muc3Vic3RyaW5nKDcpXTtcbiAgICAgICAgICAgIHJldHVybiBzID09PSBrbm93blN5bWJvbCA/IGRlc2MgOiBgU3ltYm9sKCR7SlNPTi5zdHJpbmdpZnkoZGVzYyl9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnW29iamVjdCBQcm9taXNlXSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VDb250ZW50ID0gZ2V0QXN5bmNDb250ZW50KHZhbHVlKTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvbWlzZUNvbnRlbnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmdWxmaWxsZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFByb21pc2UucmVzb2x2ZSgke3N0cmluZ2lmeUludGVybmFsKHByb21pc2VDb250ZW50LnZhbHVlLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBQcm9taXNlLnJlamVjdCgke3N0cmluZ2lmeUludGVybmFsKHByb21pc2VDb250ZW50LnZhbHVlLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyBQcm9taXNlKCgpID0+IHsvKnBlbmRpbmcqL30pYDtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmtub3duJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyBQcm9taXNlKCgpID0+IHsvKnVua25vd24qL30pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgbmV3IEVycm9yKCR7c3RyaW5naWZ5SW50ZXJuYWwodmFsdWUubWVzc2FnZSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOlxuICAgICAgICAgICAgcmV0dXJuIGB1bmRlZmluZWRgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEludDhBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IFVpbnQ4QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEludDE2QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50MTZBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEludDMyQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50MzJBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEJpZ0ludDY0QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBCaWdVaW50NjRBcnJheV0nOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBCdWZmZXIuZnJvbSgke3N0cmluZ2lmeUludGVybmFsKEFycmF5LmZyb20odmFsdWUudmFsdWVzKCkpLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdmFsdWVQcm90b3R5cGUgJiYgdmFsdWVQcm90b3R5cGUuY29uc3RydWN0b3IgJiYgdmFsdWVQcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXNGcm9tVHlwZWRBcnIgPSB0eXBlZEFycmF5LnZhbHVlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtjbGFzc05hbWV9LmZyb20oJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlc0Zyb21UeXBlZEFyciksIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5naWZ5SW50ZXJuYWwgPSBzdHJpbmdpZnlJbnRlcm5hbDtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZSwgW10sICgpID0+ICh7IHN0YXRlOiAndW5rbm93bicsIHZhbHVlOiB1bmRlZmluZWQgfSkpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBwb3NzaWJseUFzeW5jU3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgY29uc3Qgc3RpbGxQZW5kaW5nTWFya2VyID0gU3ltYm9sKCk7XG4gICAgY29uc3QgcGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUgPSBbXTtcbiAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVEZWxheTAoKSB7XG4gICAgICAgIGxldCBoYW5kbGVJZCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZUlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc3RpbGxQZW5kaW5nTWFya2VyKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZGVsYXksIGNhbmNlbCB9O1xuICAgIH1cbiAgICBjb25zdCB1bmtub3duU3RhdGUgPSB7IHN0YXRlOiAndW5rbm93bicsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICBjb25zdCBnZXRBc3luY0NvbnRlbnQgPSBmdW5jdGlvbiBnZXRBc3luY0NvbnRlbnQoZGF0YSkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGRhdGE7XG4gICAgICAgIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxheTAgPSBjcmVhdGVEZWxheTAoKTtcbiAgICAgICAgY29uc3QgcCA9IGV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCBpbiBkYXRhXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZGF0YVtleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2RdKCkpXG4gICAgICAgICAgICA6IGRhdGE7XG4gICAgICAgIHAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgcGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUucHVzaChQcm9taXNlLnJhY2UoW3AsIGRlbGF5MC5kZWxheV0pLnRoZW4oKHN1Y2Nlc3NWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NWYWx1ZSA9PT0gc3RpbGxQZW5kaW5nTWFya2VyKVxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgeyBzdGF0ZTogJ3BlbmRpbmcnLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgeyBzdGF0ZTogJ2Z1bGZpbGxlZCcsIHZhbHVlOiBzdWNjZXNzVmFsdWUgfSk7XG4gICAgICAgICAgICBkZWxheTAuY2FuY2VsKCk7XG4gICAgICAgIH0sIChlcnJvclZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHsgc3RhdGU6ICdyZWplY3RlZCcsIHZhbHVlOiBlcnJvclZhbHVlIH0pO1xuICAgICAgICAgICAgZGVsYXkwLmNhbmNlbCgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgdW5rbm93blN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHVua25vd25TdGF0ZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkVmFsdWUgPSBzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZSwgW10sIGdldEFzeW5jQ29udGVudCk7XG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZXNGb3JDYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nUHJvbWlzZXNGb3JDYWNoZS5zcGxpY2UoMCkpLnRoZW4obG9vcCk7XG4gICAgfVxuICAgIHJldHVybiBsb29wKCk7XG59XG5leHBvcnRzLnBvc3NpYmx5QXN5bmNTdHJpbmdpZnkgPSBwb3NzaWJseUFzeW5jU3RyaW5naWZ5O1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNTdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBvc3NpYmx5QXN5bmNTdHJpbmdpZnkodmFsdWUpKTtcbn1cbmV4cG9ydHMuYXN5bmNTdHJpbmdpZnkgPSBhc3luY1N0cmluZ2lmeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GT0NVU19OT19BVVRPRk9DVVMgPSBleHBvcnRzLkZPQ1VTX0FVVE8gPSBleHBvcnRzLkZPQ1VTX0FMTE9XID0gZXhwb3J0cy5GT0NVU19ESVNBQkxFRCA9IGV4cG9ydHMuRk9DVVNfR1JPVVAgPSB2b2lkIDA7XG4vKipcbiAqIGRlZmluZXMgYSBmb2N1cyBncm91cFxuICovXG5leHBvcnRzLkZPQ1VTX0dST1VQID0gJ2RhdGEtZm9jdXMtbG9jayc7XG4vKipcbiAqIGRpc2FibGVzIGVsZW1lbnQgZGlzY292ZXJ5IGluc2lkZSBhIGdyb3VwIG1hcmtlZCBieSBrZXlcbiAqL1xuZXhwb3J0cy5GT0NVU19ESVNBQkxFRCA9ICdkYXRhLWZvY3VzLWxvY2stZGlzYWJsZWQnO1xuLyoqXG4gKiBhbGxvd3MgdW5jb250cm9sbGVkIGZvY3VzIHdpdGhpbiB0aGUgbWFya2VkIGFyZWEsIGVmZmVjdGl2ZWx5IGRpc2FibGluZyBmb2N1cyBsb2NrIGZvciBpdCdzIGNvbnRlbnRcbiAqL1xuZXhwb3J0cy5GT0NVU19BTExPVyA9ICdkYXRhLW5vLWZvY3VzLWxvY2snO1xuLyoqXG4gKiBpbnN0cnVjdHMgYXV0b2ZvY3VzIGVuZ2luZSB0byBwaWNrIGRlZmF1bHQgYXV0b2ZvY3VzIGluc2lkZSBhIGdpdmVuIG5vZGVcbiAqIGNhbiBiZSBzZXQgb24gdGhlIGVsZW1lbnQgb3IgY29udGFpbmVyXG4gKi9cbmV4cG9ydHMuRk9DVVNfQVVUTyA9ICdkYXRhLWF1dG9mb2N1cy1pbnNpZGUnO1xuLyoqXG4gKiBpbnN0cnVjdHMgYXV0b2ZvY3VzIHRvIGlnbm9yZSBlbGVtZW50cyB3aXRoaW4gYSBnaXZlbiBub2RlXG4gKiBjYW4gYmUgc2V0IG9uIHRoZSBlbGVtZW50IG9yIGNvbnRhaW5lclxuICovXG5leHBvcnRzLkZPQ1VTX05PX0FVVE9GT0NVUyA9ICdkYXRhLW5vLWF1dG9mb2N1cyc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9jdXNJbnNpZGUgPSB2b2lkIDA7XG52YXIgRE9NdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0RPTXV0aWxzXCIpO1xudmFyIGFsbF9hZmZlY3RlZF8xID0gcmVxdWlyZShcIi4vdXRpbHMvYWxsLWFmZmVjdGVkXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi91dGlscy9hcnJheVwiKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50XzEgPSByZXF1aXJlKFwiLi91dGlscy9nZXRBY3RpdmVFbGVtZW50XCIpO1xudmFyIGZvY3VzSW5GcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSwgYWN0aXZlRWxlbWVudCkgeyByZXR1cm4gZnJhbWUgPT09IGFjdGl2ZUVsZW1lbnQ7IH07XG52YXIgZm9jdXNJbnNpZGVJZnJhbWUgPSBmdW5jdGlvbiAodG9wTm9kZSwgYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybiBCb29sZWFuKCgwLCBhcnJheV8xLnRvQXJyYXkpKHRvcE5vZGUucXVlcnlTZWxlY3RvckFsbCgnaWZyYW1lJykpLnNvbWUoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGZvY3VzSW5GcmFtZShub2RlLCBhY3RpdmVFbGVtZW50KTsgfSkpO1xufTtcbi8qKlxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUsIGlmIHRoZSBjdXJyZW50IGZvY3VzIGlzIGluc2lkZSBnaXZlbiBub2RlIG9yIG5vZGVzXG4gKi9cbnZhciBmb2N1c0luc2lkZSA9IGZ1bmN0aW9uICh0b3BOb2RlLCBhY3RpdmVFbGVtZW50KSB7XG4gICAgLy8gY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50ICYmIGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gdm9pZCAwKSB7IGFjdGl2ZUVsZW1lbnQgPSAoMCwgZ2V0QWN0aXZlRWxlbWVudF8xLmdldEFjdGl2ZUVsZW1lbnQpKCgwLCBhcnJheV8xLmdldEZpcnN0KSh0b3BOb2RlKS5vd25lckRvY3VtZW50KTsgfVxuICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAoYWN0aXZlRWxlbWVudC5kYXRhc2V0ICYmIGFjdGl2ZUVsZW1lbnQuZGF0YXNldC5mb2N1c0d1YXJkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYWxsX2FmZmVjdGVkXzEuZ2V0QWxsQWZmZWN0ZWROb2RlcykodG9wTm9kZSkuc29tZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gKDAsIERPTXV0aWxzXzEuY29udGFpbnMpKG5vZGUsIGFjdGl2ZUVsZW1lbnQpIHx8IGZvY3VzSW5zaWRlSWZyYW1lKG5vZGUsIGFjdGl2ZUVsZW1lbnQpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZm9jdXNJbnNpZGUgPSBmb2N1c0luc2lkZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb2N1c0lzSGlkZGVuID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIERPTXV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlscy9ET011dGlsc1wiKTtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vdXRpbHMvYXJyYXlcIik7XG52YXIgZ2V0QWN0aXZlRWxlbWVudF8xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0QWN0aXZlRWxlbWVudFwiKTtcbi8qKlxuICogZm9jdXMgaXMgaGlkZGVuIEZST00gdGhlIGZvY3VzLWxvY2tcbiAqIGllIGNvbnRhaW5lZCBpbnNpZGUgYSBub2RlIGZvY3VzLWxvY2sgc2hhbGwgaWdub3JlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gZm9jdXMgaXMgY3VycmVudGx5IGlzIGluIFwiYWxsb3dcIiBhcmVhXG4gKi9cbnZhciBmb2N1c0lzSGlkZGVuID0gZnVuY3Rpb24gKGluRG9jdW1lbnQpIHtcbiAgICBpZiAoaW5Eb2N1bWVudCA9PT0gdm9pZCAwKSB7IGluRG9jdW1lbnQgPSBkb2N1bWVudDsgfVxuICAgIHZhciBhY3RpdmVFbGVtZW50ID0gKDAsIGdldEFjdGl2ZUVsZW1lbnRfMS5nZXRBY3RpdmVFbGVtZW50KShpbkRvY3VtZW50KTtcbiAgICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB0aGlzIGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyBGT0NVU19BTExPVyB3aXRoaW4gc2hhZG93IGRvbVxuICAgIHJldHVybiAoMCwgYXJyYXlfMS50b0FycmF5KShpbkRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIuY29uY2F0KGNvbnN0YW50c18xLkZPQ1VTX0FMTE9XLCBcIl1cIikpKS5zb21lKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoMCwgRE9NdXRpbHNfMS5jb250YWlucykobm9kZSwgYWN0aXZlRWxlbWVudCk7IH0pO1xufTtcbmV4cG9ydHMuZm9jdXNJc0hpZGRlbiA9IGZvY3VzSXNIaWRkZW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Rm9jdXNNZXJnZSA9IHZvaWQgMDtcbnZhciBzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3NvbHZlclwiKTtcbnZhciBET011dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvRE9NdXRpbHNcIik7XG52YXIgYWxsX2FmZmVjdGVkXzEgPSByZXF1aXJlKFwiLi91dGlscy9hbGwtYWZmZWN0ZWRcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2FycmF5XCIpO1xudmFyIGF1dG9fZm9jdXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2F1dG8tZm9jdXNcIik7XG52YXIgZ2V0QWN0aXZlRWxlbWVudF8xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0QWN0aXZlRWxlbWVudFwiKTtcbnZhciBpc18xID0gcmVxdWlyZShcIi4vdXRpbHMvaXNcIik7XG52YXIgcGFyZW50aW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9wYXJlbnRpbmdcIik7XG52YXIgcmVvcmRlck5vZGVzID0gZnVuY3Rpb24gKHNyY05vZGVzLCBkc3ROb2Rlcykge1xuICAgIHZhciByZW1hcCA9IG5ldyBNYXAoKTtcbiAgICAvLyBubyBTZXQoZHN0Tm9kZXMpIGZvciBJRTExIDooXG4gICAgZHN0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50aXR5KSB7IHJldHVybiByZW1hcC5zZXQoZW50aXR5Lm5vZGUsIGVudGl0eSk7IH0pO1xuICAgIC8vIHJlbWFwIHRvIGRzdE5vZGVzXG4gICAgcmV0dXJuIHNyY05vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gcmVtYXAuZ2V0KG5vZGUpOyB9KS5maWx0ZXIoaXNfMS5pc0RlZmluZWQpO1xufTtcbi8qKlxuICogZ2l2ZW4gdG9wIG5vZGUocykgYW5kIHRoZSBsYXN0IGFjdGl2ZSBlbGVtZW50IHJldHVybiB0aGUgZWxlbWVudCB0byBiZSBmb2N1c2VkIG5leHRcbiAqIEBwYXJhbSB0b3BOb2RlXG4gKiBAcGFyYW0gbGFzdE5vZGVcbiAqL1xudmFyIGdldEZvY3VzTWVyZ2UgPSBmdW5jdGlvbiAodG9wTm9kZSwgbGFzdE5vZGUpIHtcbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9ICgwLCBnZXRBY3RpdmVFbGVtZW50XzEuZ2V0QWN0aXZlRWxlbWVudCkoKDAsIGFycmF5XzEuYXNBcnJheSkodG9wTm9kZSkubGVuZ3RoID4gMCA/IGRvY3VtZW50IDogKDAsIGFycmF5XzEuZ2V0Rmlyc3QpKHRvcE5vZGUpLm93bmVyRG9jdW1lbnQpO1xuICAgIHZhciBlbnRyaWVzID0gKDAsIGFsbF9hZmZlY3RlZF8xLmdldEFsbEFmZmVjdGVkTm9kZXMpKHRvcE5vZGUpLmZpbHRlcihpc18xLmlzTm90QUd1YXJkKTtcbiAgICB2YXIgY29tbW9uUGFyZW50ID0gKDAsIHBhcmVudGluZ18xLmdldFRvcENvbW1vblBhcmVudCkoYWN0aXZlRWxlbWVudCB8fCB0b3BOb2RlLCB0b3BOb2RlLCBlbnRyaWVzKTtcbiAgICB2YXIgdmlzaWJpbGl0eUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHZhciBhbnlGb2N1c2FibGUgPSAoMCwgRE9NdXRpbHNfMS5nZXRBbGxUYWJiYWJsZU5vZGVzKShlbnRyaWVzLCB2aXNpYmlsaXR5Q2FjaGUpO1xuICAgIHZhciBpbm5lckVsZW1lbnRzID0gKDAsIERPTXV0aWxzXzEuZ2V0VGFiYmFibGVOb2RlcykoZW50cmllcywgdmlzaWJpbGl0eUNhY2hlKS5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuICgwLCBpc18xLmlzTm90QUd1YXJkKShub2RlKTtcbiAgICB9KTtcbiAgICBpZiAoIWlubmVyRWxlbWVudHNbMF0pIHtcbiAgICAgICAgaW5uZXJFbGVtZW50cyA9IGFueUZvY3VzYWJsZTtcbiAgICAgICAgaWYgKCFpbm5lckVsZW1lbnRzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBvdXRlck5vZGVzID0gKDAsIERPTXV0aWxzXzEuZ2V0QWxsVGFiYmFibGVOb2RlcykoW2NvbW1vblBhcmVudF0sIHZpc2liaWxpdHlDYWNoZSkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHZhciBvcmRlcmVkSW5uZXJFbGVtZW50cyA9IHJlb3JkZXJOb2RlcyhvdXRlck5vZGVzLCBpbm5lckVsZW1lbnRzKTtcbiAgICB2YXIgaW5uZXJOb2RlcyA9IG9yZGVyZWRJbm5lckVsZW1lbnRzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICB2YXIgbmV3SWQgPSAoMCwgc29sdmVyXzEubmV3Rm9jdXMpKGlubmVyTm9kZXMsIG91dGVyTm9kZXMsIGFjdGl2ZUVsZW1lbnQsIGxhc3ROb2RlKTtcbiAgICBpZiAobmV3SWQgPT09IHNvbHZlcl8xLk5FV19GT0NVUykge1xuICAgICAgICB2YXIgZm9jdXNOb2RlID0gKDAsIGF1dG9fZm9jdXNfMS5waWNrQXV0b2ZvY3VzKShhbnlGb2N1c2FibGUsIGlubmVyTm9kZXMsICgwLCBwYXJlbnRpbmdfMS5hbGxQYXJlbnRBdXRvZm9jdXNhYmxlcykoZW50cmllcywgdmlzaWJpbGl0eUNhY2hlKSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IGZvY3VzTm9kZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdmb2N1cy1sb2NrOiBjYW5ub3QgZmluZCBhbnkgbm9kZSB0byBtb3ZlIGZvY3VzIGludG8nKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ld0lkO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXJlZElubmVyRWxlbWVudHNbbmV3SWRdO1xufTtcbmV4cG9ydHMuZ2V0Rm9jdXNNZXJnZSA9IGdldEZvY3VzTWVyZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Rm9jdXNhYmxlSW4gPSBleHBvcnRzLmdldEZvY3VzYWJsZWRJbiA9IHZvaWQgMDtcbnZhciBET011dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvRE9NdXRpbHNcIik7XG52YXIgYWxsX2FmZmVjdGVkXzEgPSByZXF1aXJlKFwiLi91dGlscy9hbGwtYWZmZWN0ZWRcIik7XG52YXIgaXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzXCIpO1xudmFyIHBhcmVudGluZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyZW50aW5nXCIpO1xuLyoqXG4gKiByZXR1cm4gbGlzdCBvZiBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIGEgZ2l2ZW4gdG9wIG5vZGVcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgZ2V0Rm9jdXNhYmxlSW59LiBZZXAsIHRoZXJlIGlzIHR5cG8gaW4gdGhlIGZ1bmN0aW9uIG5hbWVcbiAqL1xudmFyIGdldEZvY3VzYWJsZWRJbiA9IGZ1bmN0aW9uICh0b3BOb2RlKSB7XG4gICAgdmFyIGVudHJpZXMgPSAoMCwgYWxsX2FmZmVjdGVkXzEuZ2V0QWxsQWZmZWN0ZWROb2RlcykodG9wTm9kZSkuZmlsdGVyKGlzXzEuaXNOb3RBR3VhcmQpO1xuICAgIHZhciBjb21tb25QYXJlbnQgPSAoMCwgcGFyZW50aW5nXzEuZ2V0VG9wQ29tbW9uUGFyZW50KSh0b3BOb2RlLCB0b3BOb2RlLCBlbnRyaWVzKTtcbiAgICB2YXIgdmlzaWJpbGl0eUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHZhciBvdXRlck5vZGVzID0gKDAsIERPTXV0aWxzXzEuZ2V0VGFiYmFibGVOb2RlcykoW2NvbW1vblBhcmVudF0sIHZpc2liaWxpdHlDYWNoZSwgdHJ1ZSk7XG4gICAgdmFyIGlubmVyRWxlbWVudHMgPSAoMCwgRE9NdXRpbHNfMS5nZXRUYWJiYWJsZU5vZGVzKShlbnRyaWVzLCB2aXNpYmlsaXR5Q2FjaGUpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuICgwLCBpc18xLmlzTm90QUd1YXJkKShub2RlKTtcbiAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRlck5vZGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBsb2NrSXRlbTogaW5uZXJFbGVtZW50cy5pbmRleE9mKG5vZGUpID49IDAsXG4gICAgICAgICAgICBndWFyZDogKDAsIGlzXzEuaXNHdWFyZCkobm9kZSksXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZ2V0Rm9jdXNhYmxlZEluID0gZ2V0Rm9jdXNhYmxlZEluO1xuLyoqXG4gKiByZXR1cm4gbGlzdCBvZiBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIGEgZ2l2ZW4gdG9wIG5vZGVcbiAqL1xuZXhwb3J0cy5nZXRGb2N1c2FibGVJbiA9IGV4cG9ydHMuZ2V0Rm9jdXNhYmxlZEluO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFjdGl2ZUVsZW1lbnQgPSBleHBvcnRzLmZvY3VzUHJldkVsZW1lbnQgPSBleHBvcnRzLmZvY3VzTmV4dEVsZW1lbnQgPSBleHBvcnRzLmdldEFsbEFmZmVjdGVkTm9kZXMgPSBleHBvcnRzLmNvbnN0YW50cyA9IGV4cG9ydHMuZ2V0Rm9jdXNhYmxlZEluID0gZXhwb3J0cy5nZXRGb2N1c2FibGVJbiA9IGV4cG9ydHMuZm9jdXNNZXJnZSA9IGV4cG9ydHMuZm9jdXNJc0hpZGRlbiA9IGV4cG9ydHMuZm9jdXNJbnNpZGUgPSBleHBvcnRzLnRhYkhvb2sgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjb25zdGFudHMgPSAoMCwgdHNsaWJfMS5fX2ltcG9ydFN0YXIpKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSk7XG5leHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbnZhciBmb2N1c0luc2lkZV8xID0gcmVxdWlyZShcIi4vZm9jdXNJbnNpZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb2N1c0luc2lkZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9jdXNJbnNpZGVfMS5mb2N1c0luc2lkZTsgfSB9KTtcbnZhciBmb2N1c0lzSGlkZGVuXzEgPSByZXF1aXJlKFwiLi9mb2N1c0lzSGlkZGVuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9jdXNJc0hpZGRlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9jdXNJc0hpZGRlbl8xLmZvY3VzSXNIaWRkZW47IH0gfSk7XG52YXIgZm9jdXNNZXJnZV8xID0gcmVxdWlyZShcIi4vZm9jdXNNZXJnZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvY3VzTWVyZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvY3VzTWVyZ2VfMS5nZXRGb2N1c01lcmdlOyB9IH0pO1xudmFyIGZvY3VzYWJsZXNfMSA9IHJlcXVpcmUoXCIuL2ZvY3VzYWJsZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGb2N1c2FibGVkSW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvY3VzYWJsZXNfMS5nZXRGb2N1c2FibGVkSW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGb2N1c2FibGVJblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9jdXNhYmxlc18xLmdldEZvY3VzYWJsZUluOyB9IH0pO1xudmFyIHNldEZvY3VzXzEgPSByZXF1aXJlKFwiLi9zZXRGb2N1c1wiKTtcbnZhciBzaWJsaW5nXzEgPSByZXF1aXJlKFwiLi9zaWJsaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9jdXNOZXh0RWxlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2libGluZ18xLmZvY3VzTmV4dEVsZW1lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb2N1c1ByZXZFbGVtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWJsaW5nXzEuZm9jdXNQcmV2RWxlbWVudDsgfSB9KTtcbnZhciB0YWJIb29rXzEgPSAoMCwgdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQpKHJlcXVpcmUoXCIuL3RhYkhvb2tcIikpO1xuZXhwb3J0cy50YWJIb29rID0gdGFiSG9va18xLmRlZmF1bHQ7XG52YXIgYWxsX2FmZmVjdGVkXzEgPSByZXF1aXJlKFwiLi91dGlscy9hbGwtYWZmZWN0ZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBbGxBZmZlY3RlZE5vZGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxfYWZmZWN0ZWRfMS5nZXRBbGxBZmZlY3RlZE5vZGVzOyB9IH0pO1xudmFyIGdldEFjdGl2ZUVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldEFjdGl2ZUVsZW1lbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBY3RpdmVFbGVtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRBY3RpdmVFbGVtZW50XzEuZ2V0QWN0aXZlRWxlbWVudDsgfSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNldEZvY3VzXzEuc2V0Rm9jdXM7XG4vL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldEZvY3VzID0gZXhwb3J0cy5mb2N1c09uID0gdm9pZCAwO1xudmFyIGZvY3VzTWVyZ2VfMSA9IHJlcXVpcmUoXCIuL2ZvY3VzTWVyZ2VcIik7XG52YXIgZm9jdXNPbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGZvY3VzT3B0aW9ucykge1xuICAgIGlmICgnZm9jdXMnIGluIHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuZm9jdXMoZm9jdXNPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKCdjb250ZW50V2luZG93JyBpbiB0YXJnZXQgJiYgdGFyZ2V0LmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRXaW5kb3cuZm9jdXMoKTtcbiAgICB9XG59O1xuZXhwb3J0cy5mb2N1c09uID0gZm9jdXNPbjtcbnZhciBndWFyZENvdW50ID0gMDtcbnZhciBsb2NrRGlzYWJsZWQgPSBmYWxzZTtcbi8qKlxuICogU2V0cyBmb2N1cyBhdCBhIGdpdmVuIG5vZGUuIFRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudCB3aWxsIGhlbHAgdG8gZGV0ZXJtaW5lIHdoaWNoIGVsZW1lbnQoZmlyc3Qgb3IgbGFzdCkgc2hvdWxkIGJlIGZvY3VzZWQuXG4gKiBIVE1MIG1hcmtlcnMgKHNlZSB7QGxpbmsgX19pbXBvcnRfXygnLi9jb25zdGFudHMnKS5GT0NVU19BVVRPfSBjb25zdGFudHMpIGNhbiBjb250cm9sIGF1dG9mb2N1c1xuICogQHBhcmFtIHRvcE5vZGVcbiAqIEBwYXJhbSBsYXN0Tm9kZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xudmFyIHNldEZvY3VzID0gZnVuY3Rpb24gKHRvcE5vZGUsIGxhc3ROb2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZm9jdXNhYmxlID0gKDAsIGZvY3VzTWVyZ2VfMS5nZXRGb2N1c01lcmdlKSh0b3BOb2RlLCBsYXN0Tm9kZSk7XG4gICAgaWYgKGxvY2tEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmb2N1c2FibGUpIHtcbiAgICAgICAgaWYgKGd1YXJkQ291bnQgPiAyKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRm9jdXNMb2NrOiBmb2N1cy1maWdodGluZyBkZXRlY3RlZC4gT25seSBvbmUgZm9jdXMgbWFuYWdlbWVudCBzeXN0ZW0gY291bGQgYmUgYWN0aXZlLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvZm9jdXMtbG9jay8jZm9jdXMtZmlnaHRpbmcnKTtcbiAgICAgICAgICAgIGxvY2tEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsb2NrRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGd1YXJkQ291bnQrKztcbiAgICAgICAgKDAsIGV4cG9ydHMuZm9jdXNPbikoZm9jdXNhYmxlLm5vZGUsIG9wdGlvbnMuZm9jdXNPcHRpb25zKTtcbiAgICAgICAgZ3VhcmRDb3VudC0tO1xuICAgIH1cbn07XG5leHBvcnRzLnNldEZvY3VzID0gc2V0Rm9jdXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9jdXNQcmV2RWxlbWVudCA9IGV4cG9ydHMuZm9jdXNOZXh0RWxlbWVudCA9IHZvaWQgMDtcbnZhciBzZXRGb2N1c18xID0gcmVxdWlyZShcIi4vc2V0Rm9jdXNcIik7XG52YXIgRE9NdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0RPTXV0aWxzXCIpO1xudmFyIGdldFJlbGF0aXZlRm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNjb3BlKSB7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFzY29wZSB8fCAhKDAsIERPTXV0aWxzXzEuY29udGFpbnMpKHNjb3BlLCBlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHZhciBmb2N1c2FibGVzID0gKDAsIERPTXV0aWxzXzEuZ2V0VGFiYmFibGVOb2RlcykoW3Njb3BlXSwgbmV3IE1hcCgpKTtcbiAgICB2YXIgY3VycmVudCA9IGZvY3VzYWJsZXMuZmluZEluZGV4KGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiBub2RlID09PSBlbGVtZW50O1xuICAgIH0pO1xuICAgIGlmIChjdXJyZW50ID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByZXY6IGZvY3VzYWJsZXNbY3VycmVudCAtIDFdLFxuICAgICAgICBuZXh0OiBmb2N1c2FibGVzW2N1cnJlbnQgKyAxXSxcbiAgICAgICAgZmlyc3Q6IGZvY3VzYWJsZXNbMF0sXG4gICAgICAgIGxhc3Q6IGZvY3VzYWJsZXNbZm9jdXNhYmxlcy5sZW5ndGggLSAxXSxcbiAgICB9O1xufTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBzY29wZTogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgY3ljbGU6IHRydWUsXG4gICAgfSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBmb2N1c2VzIG5leHQgZWxlbWVudCBpbiB0aGUgdGFiLW9yZGVyXG4gKiBAcGFyYW0gYmFzZUVsZW1lbnQgLSBjb21tb24gcGFyZW50IHRvIHNjb3BlIGFjdGl2ZSBlbGVtZW50IHNlYXJjaCBvciB0YWIgY3ljbGUgb3JkZXJcbiAqIEBwYXJhbSB7Rm9jdXNOZXh0T3B0aW9uc30gW29wdGlvbnNdIC0gZm9jdXMgb3B0aW9uc1xuICovXG52YXIgZm9jdXNOZXh0RWxlbWVudCA9IGZ1bmN0aW9uIChiYXNlRWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gZGVmYXVsdE9wdGlvbnMob3B0aW9ucyksIHNjb3BlID0gX2Euc2NvcGUsIGN5Y2xlID0gX2EuY3ljbGU7XG4gICAgdmFyIF9iID0gZ2V0UmVsYXRpdmVGb2N1c2FibGUoYmFzZUVsZW1lbnQsIHNjb3BlKSwgbmV4dCA9IF9iLm5leHQsIGZpcnN0ID0gX2IuZmlyc3Q7XG4gICAgdmFyIG5ld1RhcmdldCA9IG5leHQgfHwgKGN5Y2xlICYmIGZpcnN0KTtcbiAgICBpZiAobmV3VGFyZ2V0KSB7XG4gICAgICAgICgwLCBzZXRGb2N1c18xLmZvY3VzT24pKG5ld1RhcmdldC5ub2RlLCBvcHRpb25zLmZvY3VzT3B0aW9ucyk7XG4gICAgfVxufTtcbmV4cG9ydHMuZm9jdXNOZXh0RWxlbWVudCA9IGZvY3VzTmV4dEVsZW1lbnQ7XG4vKipcbiAqIGZvY3VzZXMgcHJldiBlbGVtZW50IGluIHRoZSB0YWIgb3JkZXJcbiAqIEBwYXJhbSBiYXNlRWxlbWVudCAtIGNvbW1vbiBwYXJlbnQgdG8gc2NvcGUgYWN0aXZlIGVsZW1lbnQgc2VhcmNoIG9yIHRhYiBjeWNsZSBvcmRlclxuICogQHBhcmFtIHtGb2N1c05leHRPcHRpb25zfSBbb3B0aW9uc10gLSBmb2N1cyBvcHRpb25zXG4gKi9cbnZhciBmb2N1c1ByZXZFbGVtZW50ID0gZnVuY3Rpb24gKGJhc2VFbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBkZWZhdWx0T3B0aW9ucyhvcHRpb25zKSwgc2NvcGUgPSBfYS5zY29wZSwgY3ljbGUgPSBfYS5jeWNsZTtcbiAgICB2YXIgX2IgPSBnZXRSZWxhdGl2ZUZvY3VzYWJsZShiYXNlRWxlbWVudCwgc2NvcGUpLCBwcmV2ID0gX2IucHJldiwgbGFzdCA9IF9iLmxhc3Q7XG4gICAgdmFyIG5ld1RhcmdldCA9IHByZXYgfHwgKGN5Y2xlICYmIGxhc3QpO1xuICAgIGlmIChuZXdUYXJnZXQpIHtcbiAgICAgICAgKDAsIHNldEZvY3VzXzEuZm9jdXNPbikobmV3VGFyZ2V0Lm5vZGUsIG9wdGlvbnMuZm9jdXNPcHRpb25zKTtcbiAgICB9XG59O1xuZXhwb3J0cy5mb2N1c1ByZXZFbGVtZW50ID0gZm9jdXNQcmV2RWxlbWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uZXdGb2N1cyA9IGV4cG9ydHMuTkVXX0ZPQ1VTID0gdm9pZCAwO1xudmFyIGNvcnJlY3RGb2N1c18xID0gcmVxdWlyZShcIi4vdXRpbHMvY29ycmVjdEZvY3VzXCIpO1xudmFyIGZpcnN0Rm9jdXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZpcnN0Rm9jdXNcIik7XG52YXIgaXNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzXCIpO1xuZXhwb3J0cy5ORVdfRk9DVVMgPSAnTkVXX0ZPQ1VTJztcbi8qKlxuICogTWFpbiBzb2x2ZXIgZm9yIHRoZSBcImZpbmQgbmV4dCBmb2N1c1wiIHF1ZXN0aW9uXG4gKiBAcGFyYW0gaW5uZXJOb2Rlc1xuICogQHBhcmFtIG91dGVyTm9kZXNcbiAqIEBwYXJhbSBhY3RpdmVFbGVtZW50XG4gKiBAcGFyYW0gbGFzdE5vZGVcbiAqIEByZXR1cm5zIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZHwqfVxuICovXG52YXIgbmV3Rm9jdXMgPSBmdW5jdGlvbiAoaW5uZXJOb2Rlcywgb3V0ZXJOb2RlcywgYWN0aXZlRWxlbWVudCwgbGFzdE5vZGUpIHtcbiAgICB2YXIgY250ID0gaW5uZXJOb2Rlcy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0Rm9jdXMgPSBpbm5lck5vZGVzWzBdO1xuICAgIHZhciBsYXN0Rm9jdXMgPSBpbm5lck5vZGVzW2NudCAtIDFdO1xuICAgIHZhciBpc09uR3VhcmQgPSAoMCwgaXNfMS5pc0d1YXJkKShhY3RpdmVFbGVtZW50KTtcbiAgICAvLyBmb2N1cyBpcyBpbnNpZGVcbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBpbm5lck5vZGVzLmluZGV4T2YoYWN0aXZlRWxlbWVudCkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgYWN0aXZlSW5kZXggPSBhY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBvdXRlck5vZGVzLmluZGV4T2YoYWN0aXZlRWxlbWVudCkgOiAtMTtcbiAgICB2YXIgbGFzdEluZGV4ID0gbGFzdE5vZGUgPyBvdXRlck5vZGVzLmluZGV4T2YobGFzdE5vZGUpIDogYWN0aXZlSW5kZXg7XG4gICAgdmFyIGxhc3ROb2RlSW5zaWRlID0gbGFzdE5vZGUgPyBpbm5lck5vZGVzLmluZGV4T2YobGFzdE5vZGUpIDogLTE7XG4gICAgdmFyIGluZGV4RGlmZiA9IGFjdGl2ZUluZGV4IC0gbGFzdEluZGV4O1xuICAgIHZhciBmaXJzdE5vZGVJbmRleCA9IG91dGVyTm9kZXMuaW5kZXhPZihmaXJzdEZvY3VzKTtcbiAgICB2YXIgbGFzdE5vZGVJbmRleCA9IG91dGVyTm9kZXMuaW5kZXhPZihsYXN0Rm9jdXMpO1xuICAgIHZhciBjb3JyZWN0ZWROb2RlcyA9ICgwLCBjb3JyZWN0Rm9jdXNfMS5jb3JyZWN0Tm9kZXMpKG91dGVyTm9kZXMpO1xuICAgIHZhciBjb3JyZWN0ZWRJbmRleCA9IGFjdGl2ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCA/IGNvcnJlY3RlZE5vZGVzLmluZGV4T2YoYWN0aXZlRWxlbWVudCkgOiAtMTtcbiAgICB2YXIgY29ycmVjdGVkSW5kZXhEaWZmID0gY29ycmVjdGVkSW5kZXggLSAobGFzdE5vZGUgPyBjb3JyZWN0ZWROb2Rlcy5pbmRleE9mKGxhc3ROb2RlKSA6IGFjdGl2ZUluZGV4KTtcbiAgICB2YXIgcmV0dXJuRmlyc3ROb2RlID0gKDAsIGZpcnN0Rm9jdXNfMS5waWNrRm9jdXNhYmxlKShpbm5lck5vZGVzLCAwKTtcbiAgICB2YXIgcmV0dXJuTGFzdE5vZGUgPSAoMCwgZmlyc3RGb2N1c18xLnBpY2tGb2N1c2FibGUpKGlubmVyTm9kZXMsIGNudCAtIDEpO1xuICAgIC8vIG5ldyBmb2N1c1xuICAgIGlmIChhY3RpdmVJbmRleCA9PT0gLTEgfHwgbGFzdE5vZGVJbnNpZGUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk5FV19GT0NVUztcbiAgICB9XG4gICAgLy8gb2xkIGZvY3VzXG4gICAgaWYgKCFpbmRleERpZmYgJiYgbGFzdE5vZGVJbnNpZGUgPj0gMCkge1xuICAgICAgICByZXR1cm4gbGFzdE5vZGVJbnNpZGU7XG4gICAgfVxuICAgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICBpZiAoYWN0aXZlSW5kZXggPD0gZmlyc3ROb2RlSW5kZXggJiYgaXNPbkd1YXJkICYmIE1hdGguYWJzKGluZGV4RGlmZikgPiAxKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5MYXN0Tm9kZTtcbiAgICB9XG4gICAgLy8gbGFzdCBlbGVtZW50XG4gICAgaWYgKGFjdGl2ZUluZGV4ID49IGxhc3ROb2RlSW5kZXggJiYgaXNPbkd1YXJkICYmIE1hdGguYWJzKGluZGV4RGlmZikgPiAxKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5GaXJzdE5vZGU7XG4gICAgfVxuICAgIC8vIGp1bXAgb3V0LCBidXQgbm90IG9uIHRoZSBndWFyZFxuICAgIGlmIChpbmRleERpZmYgJiYgTWF0aC5hYnMoY29ycmVjdGVkSW5kZXhEaWZmKSA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGxhc3ROb2RlSW5zaWRlO1xuICAgIH1cbiAgICAvLyBmb2N1cyBhYm92ZSBsb2NrXG4gICAgaWYgKGFjdGl2ZUluZGV4IDw9IGZpcnN0Tm9kZUluZGV4KSB7XG4gICAgICAgIHJldHVybiByZXR1cm5MYXN0Tm9kZTtcbiAgICB9XG4gICAgLy8gZm9jdXMgYmVsb3cgbG9ja1xuICAgIGlmIChhY3RpdmVJbmRleCA+IGxhc3ROb2RlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0Tm9kZTtcbiAgICB9XG4gICAgLy8gaW5kZXggaXMgaW5zaWRlIHRhYiBvcmRlciwgYnV0IG91dHNpZGUgTG9ja1xuICAgIGlmIChpbmRleERpZmYpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGluZGV4RGlmZikgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdE5vZGVJbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjbnQgKyBsYXN0Tm9kZUluc2lkZSArIGluZGV4RGlmZikgJSBjbnQ7XG4gICAgfVxuICAgIC8vIGRvIG5vdGhpbmdcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMubmV3Rm9jdXMgPSBuZXdGb2N1cztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgZG9lcyBub3RoaW5nXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udGFpbnMgPSBleHBvcnRzLnBhcmVudEF1dG9mb2N1c2FibGVzID0gZXhwb3J0cy5nZXRBbGxUYWJiYWJsZU5vZGVzID0gZXhwb3J0cy5nZXRUYWJiYWJsZU5vZGVzID0gZXhwb3J0cy5maWx0ZXJBdXRvRm9jdXNhYmxlID0gZXhwb3J0cy5maWx0ZXJGb2N1c2FibGUgPSB2b2lkIDA7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xudmFyIGlzXzEgPSByZXF1aXJlKFwiLi9pc1wiKTtcbnZhciB0YWJPcmRlcl8xID0gcmVxdWlyZShcIi4vdGFiT3JkZXJcIik7XG52YXIgdGFiVXRpbHNfMSA9IHJlcXVpcmUoXCIuL3RhYlV0aWxzXCIpO1xuLyoqXG4gKiBnaXZlbiBsaXN0IG9mIGZvY3VzYWJsZSBlbGVtZW50cyBrZWVwcyB0aGUgb25lcyB1c2VyIGNhbiBpbnRlcmFjdCB3aXRoXG4gKiBAcGFyYW0gbm9kZXNcbiAqIEBwYXJhbSB2aXNpYmlsaXR5Q2FjaGVcbiAqL1xudmFyIGZpbHRlckZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlcywgdmlzaWJpbGl0eUNhY2hlKSB7XG4gICAgcmV0dXJuICgwLCBhcnJheV8xLnRvQXJyYXkpKG5vZGVzKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoMCwgaXNfMS5pc1Zpc2libGVDYWNoZWQpKHZpc2liaWxpdHlDYWNoZSwgbm9kZSk7IH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuICgwLCBpc18xLm5vdEhpZGRlbklucHV0KShub2RlKTsgfSk7XG59O1xuZXhwb3J0cy5maWx0ZXJGb2N1c2FibGUgPSBmaWx0ZXJGb2N1c2FibGU7XG52YXIgZmlsdGVyQXV0b0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlcywgY2FjaGUpIHtcbiAgICBpZiAoY2FjaGUgPT09IHZvaWQgMCkgeyBjYWNoZSA9IG5ldyBNYXAoKTsgfVxuICAgIHJldHVybiAoMCwgYXJyYXlfMS50b0FycmF5KShub2RlcykuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoMCwgaXNfMS5pc0F1dG9Gb2N1c0FsbG93ZWRDYWNoZWQpKGNhY2hlLCBub2RlKTsgfSk7XG59O1xuZXhwb3J0cy5maWx0ZXJBdXRvRm9jdXNhYmxlID0gZmlsdGVyQXV0b0ZvY3VzYWJsZTtcbi8qKlxuICogb25seSB0YWJiYWJsZSBvbmVzXG4gKiAoYnV0IHdpdGggZ3VhcmRzIHdoaWNoIHdvdWxkIGJlIGlnbm9yZWQpXG4gKi9cbnZhciBnZXRUYWJiYWJsZU5vZGVzID0gZnVuY3Rpb24gKHRvcE5vZGVzLCB2aXNpYmlsaXR5Q2FjaGUsIHdpdGhHdWFyZHMpIHtcbiAgICByZXR1cm4gKDAsIHRhYk9yZGVyXzEub3JkZXJCeVRhYkluZGV4KSgoMCwgZXhwb3J0cy5maWx0ZXJGb2N1c2FibGUpKCgwLCB0YWJVdGlsc18xLmdldEZvY3VzYWJsZXMpKHRvcE5vZGVzLCB3aXRoR3VhcmRzKSwgdmlzaWJpbGl0eUNhY2hlKSwgdHJ1ZSwgd2l0aEd1YXJkcyk7XG59O1xuZXhwb3J0cy5nZXRUYWJiYWJsZU5vZGVzID0gZ2V0VGFiYmFibGVOb2Rlcztcbi8qKlxuICogYWN0dWFsbHkgYW55dGhpbmcgXCJmb2N1c2FibGVcIiwgbm90IG9ubHkgdGFiYmFibGVcbiAqICh3aXRob3V0IGd1YXJkcywgYXMgbG9uZyBhcyB0aGV5IGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgZm9jdXNlZClcbiAqL1xudmFyIGdldEFsbFRhYmJhYmxlTm9kZXMgPSBmdW5jdGlvbiAodG9wTm9kZXMsIHZpc2liaWxpdHlDYWNoZSkge1xuICAgIHJldHVybiAoMCwgdGFiT3JkZXJfMS5vcmRlckJ5VGFiSW5kZXgpKCgwLCBleHBvcnRzLmZpbHRlckZvY3VzYWJsZSkoKDAsIHRhYlV0aWxzXzEuZ2V0Rm9jdXNhYmxlcykodG9wTm9kZXMpLCB2aXNpYmlsaXR5Q2FjaGUpLCBmYWxzZSk7XG59O1xuZXhwb3J0cy5nZXRBbGxUYWJiYWJsZU5vZGVzID0gZ2V0QWxsVGFiYmFibGVOb2Rlcztcbi8qKlxuICogcmV0dXJuIGxpc3Qgb2Ygbm9kZXMgd2hpY2ggYXJlIGV4cGVjdGVkIHRvIGJlIGF1dG8tZm9jdXNlZFxuICogQHBhcmFtIHRvcE5vZGVcbiAqIEBwYXJhbSB2aXNpYmlsaXR5Q2FjaGVcbiAqL1xudmFyIHBhcmVudEF1dG9mb2N1c2FibGVzID0gZnVuY3Rpb24gKHRvcE5vZGUsIHZpc2liaWxpdHlDYWNoZSkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5maWx0ZXJGb2N1c2FibGUpKCgwLCB0YWJVdGlsc18xLmdldFBhcmVudEF1dG9mb2N1c2FibGVzKSh0b3BOb2RlKSwgdmlzaWJpbGl0eUNhY2hlKTtcbn07XG5leHBvcnRzLnBhcmVudEF1dG9mb2N1c2FibGVzID0gcGFyZW50QXV0b2ZvY3VzYWJsZXM7XG4vKlxuICogRGV0ZXJtaW5lcyBpZiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBzY29wZSwgaW5jbHVkaW5nIG5lc3RlZCBzaGFkb3cgRE9Nc1xuICovXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQpIHtcbiAgICBpZiAoc2NvcGUuc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuY29udGFpbnMpKHNjb3BlLnNoYWRvd1Jvb3QsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihzY29wZSkuY29udGFpbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNjb3BlKS5jb250YWlucy5jYWxsKHNjb3BlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBhcnJheV8xLnRvQXJyYXkpKHNjb3BlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWZyYW1lQm9keSA9IChfYSA9IGNoaWxkLmNvbnRlbnREb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGlmcmFtZUJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmNvbnRhaW5zKShpZnJhbWVCb2R5LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmNvbnRhaW5zKShjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QWxsQWZmZWN0ZWROb2RlcyA9IHZvaWQgMDtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuLyoqXG4gKiBpbiBjYXNlIG9mIG11bHRpcGxlIG5vZGVzIG5lc3RlZCBpbnNpZGUgZWFjaCBvdGhlclxuICoga2VlcHMgb25seSB0b3Agb25lc1xuICogdGhpcyBpcyBPKG5sb2duKVxuICogQHBhcmFtIG5vZGVzXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xudmFyIGZpbHRlck5lc3RlZCA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgIHZhciBjb250YWluZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGwgPSBub2Rlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBub2Rlc1tpXS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2Rlc1tqXSk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgICAgICAgICBpZiAoKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lZC5hZGQoaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUykgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVkLmFkZChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpbmRleCkgeyByZXR1cm4gIWNvbnRhaW5lZC5oYXMoaW5kZXgpOyB9KTtcbn07XG4vKipcbiAqIGZpbmRzIHRvcCBtb3N0IHBhcmVudCBmb3IgYSBub2RlXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBnZXRUb3BQYXJlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgPyBnZXRUb3BQYXJlbnQobm9kZS5wYXJlbnROb2RlKSA6IG5vZGU7XG59O1xuLyoqXG4gKiByZXR1cm5zIGFsbCBcImZvY3VzIGNvbnRhaW5lcnNcIiBpbnNpZGUgYSBnaXZlbiBub2RlXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMge1R9XG4gKi9cbnZhciBnZXRBbGxBZmZlY3RlZE5vZGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgbm9kZXMgPSAoMCwgYXJyYXlfMS5hc0FycmF5KShub2RlKTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJyZW50Tm9kZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSBjdXJyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoY29uc3RhbnRzXzEuRk9DVVNfR1JPVVApO1xuICAgICAgICBhY2MucHVzaC5hcHBseShhY2MsIChncm91cFxuICAgICAgICAgICAgPyBmaWx0ZXJOZXN0ZWQoKDAsIGFycmF5XzEudG9BcnJheSkoZ2V0VG9wUGFyZW50KGN1cnJlbnROb2RlKS5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiLmNvbmNhdChjb25zdGFudHNfMS5GT0NVU19HUk9VUCwgXCI9XFxcIlwiKS5jb25jYXQoZ3JvdXAsIFwiXFxcIl06bm90KFtcIikuY29uY2F0KGNvbnN0YW50c18xLkZPQ1VTX0RJU0FCTEVELCBcIj1cXFwiZGlzYWJsZWRcXFwiXSlcIikpKSlcbiAgICAgICAgICAgIDogW2N1cnJlbnROb2RlXSkpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbn07XG5leHBvcnRzLmdldEFsbEFmZmVjdGVkTm9kZXMgPSBnZXRBbGxBZmZlY3RlZE5vZGVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuSUUxMSBzdXBwb3J0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Rmlyc3QgPSBleHBvcnRzLmFzQXJyYXkgPSBleHBvcnRzLnRvQXJyYXkgPSB2b2lkIDA7XG52YXIgdG9BcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHJldCA9IEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gYVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xudmFyIGFzQXJyYXkgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdKTsgfTtcbmV4cG9ydHMuYXNBcnJheSA9IGFzQXJyYXk7XG52YXIgZ2V0Rmlyc3QgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKEFycmF5LmlzQXJyYXkoYSkgPyBhWzBdIDogYSk7IH07XG5leHBvcnRzLmdldEZpcnN0ID0gZ2V0Rmlyc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGlja0F1dG9mb2N1cyA9IHZvaWQgMDtcbnZhciBET011dGlsc18xID0gcmVxdWlyZShcIi4vRE9NdXRpbHNcIik7XG52YXIgZmlyc3RGb2N1c18xID0gcmVxdWlyZShcIi4vZmlyc3RGb2N1c1wiKTtcbnZhciBpc18xID0gcmVxdWlyZShcIi4vaXNcIik7XG52YXIgZmluZEF1dG9Gb2N1c2VkID0gZnVuY3Rpb24gKGF1dG9Gb2N1c2FibGVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGF1dG9mb2N1cyA9IChfYSA9ICgwLCBpc18xLmdldERhdGFzZXQpKG5vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b2ZvY3VzO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIG5vZGUuYXV0b2ZvY3VzIHx8XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgKGF1dG9mb2N1cyAhPT0gdW5kZWZpbmVkICYmIGF1dG9mb2N1cyAhPT0gJ2ZhbHNlJykgfHxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBhdXRvRm9jdXNhYmxlcy5pbmRleE9mKG5vZGUpID49IDApO1xuICAgIH07XG59O1xudmFyIHBpY2tBdXRvZm9jdXMgPSBmdW5jdGlvbiAobm9kZXNJbmRleGVzLCBvcmRlcmVkTm9kZXMsIGdyb3Vwcykge1xuICAgIHZhciBub2RlcyA9IG5vZGVzSW5kZXhlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgdmFyIGF1dG9Gb2N1c2FibGUgPSAoMCwgRE9NdXRpbHNfMS5maWx0ZXJBdXRvRm9jdXNhYmxlKShub2Rlcy5maWx0ZXIoZmluZEF1dG9Gb2N1c2VkKGdyb3VwcykpKTtcbiAgICBpZiAoYXV0b0ZvY3VzYWJsZSAmJiBhdXRvRm9jdXNhYmxlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gKDAsIGZpcnN0Rm9jdXNfMS5waWNrRmlyc3RGb2N1cykoYXV0b0ZvY3VzYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZmlyc3RGb2N1c18xLnBpY2tGaXJzdEZvY3VzKSgoMCwgRE9NdXRpbHNfMS5maWx0ZXJBdXRvRm9jdXNhYmxlKShvcmRlcmVkTm9kZXMpKTtcbn07XG5leHBvcnRzLnBpY2tBdXRvZm9jdXMgPSBwaWNrQXV0b2ZvY3VzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvcnJlY3ROb2RlcyA9IGV4cG9ydHMuY29ycmVjdE5vZGUgPSB2b2lkIDA7XG52YXIgaXNfMSA9IHJlcXVpcmUoXCIuL2lzXCIpO1xudmFyIGZpbmRTZWxlY3RlZFJhZGlvID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzXG4gICAgICAgIC5maWx0ZXIoaXNfMS5pc1JhZGlvRWxlbWVudClcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLm5hbWUgPT09IG5vZGUubmFtZTsgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoZWNrZWQ7IH0pWzBdIHx8IG5vZGU7XG59O1xudmFyIGNvcnJlY3ROb2RlID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVzKSB7XG4gICAgaWYgKCgwLCBpc18xLmlzUmFkaW9FbGVtZW50KShub2RlKSAmJiBub2RlLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3RlZFJhZGlvKG5vZGUsIG5vZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuZXhwb3J0cy5jb3JyZWN0Tm9kZSA9IGNvcnJlY3ROb2RlO1xuLyoqXG4gKiBnaXZpbmcgYSBzZXQgb2YgcmFkaW8gaW5wdXRzIGtlZXBzIG9ubHkgc2VsZWN0ZWQgKHRhYmJhYmxlKSBvbmVzXG4gKiBAcGFyYW0gbm9kZXNcbiAqL1xudmFyIGNvcnJlY3ROb2RlcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgIC8vIElFMTEgaGFzIG5vIFNldChhcnJheSkgY29uc3RydWN0b3JcbiAgICB2YXIgcmVzdWx0U2V0ID0gbmV3IFNldCgpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHJlc3VsdFNldC5hZGQoKDAsIGV4cG9ydHMuY29ycmVjdE5vZGUpKG5vZGUsIG5vZGVzKSk7IH0pO1xuICAgIC8vIHVzaW5nIGZpbHRlciB0byBzdXBwb3J0IElFMTFcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiByZXN1bHRTZXQuaGFzKG5vZGUpOyB9KTtcbn07XG5leHBvcnRzLmNvcnJlY3ROb2RlcyA9IGNvcnJlY3ROb2RlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5waWNrRm9jdXNhYmxlID0gZXhwb3J0cy5waWNrRmlyc3RGb2N1cyA9IHZvaWQgMDtcbnZhciBjb3JyZWN0Rm9jdXNfMSA9IHJlcXVpcmUoXCIuL2NvcnJlY3RGb2N1c1wiKTtcbnZhciBwaWNrRmlyc3RGb2N1cyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgIGlmIChub2Rlc1swXSAmJiBub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiAoMCwgY29ycmVjdEZvY3VzXzEuY29ycmVjdE5vZGUpKG5vZGVzWzBdLCBub2Rlcyk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1swXTtcbn07XG5leHBvcnRzLnBpY2tGaXJzdEZvY3VzID0gcGlja0ZpcnN0Rm9jdXM7XG52YXIgcGlja0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlcywgaW5kZXgpIHtcbiAgICBpZiAobm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gbm9kZXMuaW5kZXhPZigoMCwgY29ycmVjdEZvY3VzXzEuY29ycmVjdE5vZGUpKG5vZGVzW2luZGV4XSwgbm9kZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufTtcbmV4cG9ydHMucGlja0ZvY3VzYWJsZSA9IHBpY2tGb2N1c2FibGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QWN0aXZlRWxlbWVudCA9IHZvaWQgMDtcbi8qKlxuICogcmV0dXJucyBhY3RpdmUgZWxlbWVudCBmcm9tIGRvY3VtZW50IG9yIGZyb20gbmVzdGVkIHNoYWRvd2RvbXNcbiAqL1xudmFyIHNhZmVfMSA9IHJlcXVpcmUoXCIuL3NhZmVcIik7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IGZ1bmN0aW9uIChpbkRvY3VtZW50KSB7XG4gICAgaWYgKGluRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBpbkRvY3VtZW50ID0gZG9jdW1lbnQ7IH1cbiAgICBpZiAoIWluRG9jdW1lbnQgfHwgIWluRG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGluRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gKGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdFxuICAgICAgICA/ICgwLCBleHBvcnRzLmdldEFjdGl2ZUVsZW1lbnQpKGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdClcbiAgICAgICAgOiBhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQgJiYgKDAsIHNhZmVfMS5zYWZlUHJvYmUpKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjdGl2ZUVsZW1lbnQuY29udGVudFdpbmRvdy5kb2N1bWVudDsgfSlcbiAgICAgICAgICAgID8gKDAsIGV4cG9ydHMuZ2V0QWN0aXZlRWxlbWVudCkoYWN0aXZlRWxlbWVudC5jb250ZW50V2luZG93LmRvY3VtZW50KVxuICAgICAgICAgICAgOiBhY3RpdmVFbGVtZW50KTtcbn07XG5leHBvcnRzLmdldEFjdGl2ZUVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzRGVmaW5lZCA9IGV4cG9ydHMuaXNOb3RBR3VhcmQgPSBleHBvcnRzLmlzR3VhcmQgPSBleHBvcnRzLmlzQXV0b0ZvY3VzQWxsb3dlZCA9IGV4cG9ydHMubm90SGlkZGVuSW5wdXQgPSBleHBvcnRzLmlzUmFkaW9FbGVtZW50ID0gZXhwb3J0cy5pc0hUTUxJbnB1dEVsZW1lbnQgPSBleHBvcnRzLmlzSFRNTEJ1dHRvbkVsZW1lbnQgPSBleHBvcnRzLmdldERhdGFzZXQgPSBleHBvcnRzLmlzQXV0b0ZvY3VzQWxsb3dlZENhY2hlZCA9IGV4cG9ydHMuaXNWaXNpYmxlQ2FjaGVkID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBpc0VsZW1lbnRIaWRkZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIHdlIGNhbiBtZWFzdXJlIG9ubHkgXCJlbGVtZW50c1wiXG4gICAgLy8gY29uc2lkZXIgb3RoZXJzIGFzIFwidmlzaWJsZVwiXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKTtcbiAgICBpZiAoIWNvbXB1dGVkU3R5bGUgfHwgIWNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgPT09ICdub25lJyB8fCBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ2hpZGRlbicpO1xufTtcbnZhciBnZXRQYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIGNhbiBhbHNvIHBvaW50IG9uIFNoYWRvd1Jvb3QuIEluIHRoaXMgY2FzZSAuaG9zdCB3aWxsIHBvaW50IG9uIHRoZSBuZXh0IG5vZGVcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG4gICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5ob3N0XG4gICAgICAgIDogbm9kZS5wYXJlbnROb2RlO1xufTtcbnZhciBpc1RvcE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbm9kZSA9PT0gZG9jdW1lbnQgfHwgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKTtcbn07XG52YXIgaXNWaXNpYmxlVW5jYWNoZWQgPSBmdW5jdGlvbiAobm9kZSwgY2hlY2tQYXJlbnQpIHtcbiAgICByZXR1cm4gIW5vZGUgfHwgaXNUb3BOb2RlKG5vZGUpIHx8ICghaXNFbGVtZW50SGlkZGVuKG5vZGUpICYmIGNoZWNrUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpKTtcbn07XG52YXIgaXNWaXNpYmxlQ2FjaGVkID0gZnVuY3Rpb24gKHZpc2liaWxpdHlDYWNoZSwgbm9kZSkge1xuICAgIHZhciBjYWNoZWQgPSB2aXNpYmlsaXR5Q2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gaXNWaXNpYmxlVW5jYWNoZWQobm9kZSwgZXhwb3J0cy5pc1Zpc2libGVDYWNoZWQuYmluZCh1bmRlZmluZWQsIHZpc2liaWxpdHlDYWNoZSkpO1xuICAgIHZpc2liaWxpdHlDYWNoZS5zZXQobm9kZSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuaXNWaXNpYmxlQ2FjaGVkID0gaXNWaXNpYmxlQ2FjaGVkO1xudmFyIGlzQXV0b0ZvY3VzQWxsb3dlZFVuY2FjaGVkID0gZnVuY3Rpb24gKG5vZGUsIGNoZWNrUGFyZW50KSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgIWlzVG9wTm9kZShub2RlKSA/ICgoMCwgZXhwb3J0cy5pc0F1dG9Gb2N1c0FsbG93ZWQpKG5vZGUpID8gY2hlY2tQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSkgOiBmYWxzZSkgOiB0cnVlO1xufTtcbnZhciBpc0F1dG9Gb2N1c0FsbG93ZWRDYWNoZWQgPSBmdW5jdGlvbiAoY2FjaGUsIG5vZGUpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gaXNBdXRvRm9jdXNBbGxvd2VkVW5jYWNoZWQobm9kZSwgZXhwb3J0cy5pc0F1dG9Gb2N1c0FsbG93ZWRDYWNoZWQuYmluZCh1bmRlZmluZWQsIGNhY2hlKSk7XG4gICAgY2FjaGUuc2V0KG5vZGUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmlzQXV0b0ZvY3VzQWxsb3dlZENhY2hlZCA9IGlzQXV0b0ZvY3VzQWxsb3dlZENhY2hlZDtcbnZhciBnZXREYXRhc2V0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIG5vZGUuZGF0YXNldDtcbn07XG5leHBvcnRzLmdldERhdGFzZXQgPSBnZXREYXRhc2V0O1xudmFyIGlzSFRNTEJ1dHRvbkVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnQlVUVE9OJzsgfTtcbmV4cG9ydHMuaXNIVE1MQnV0dG9uRWxlbWVudCA9IGlzSFRNTEJ1dHRvbkVsZW1lbnQ7XG52YXIgaXNIVE1MSW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJzsgfTtcbmV4cG9ydHMuaXNIVE1MSW5wdXRFbGVtZW50ID0gaXNIVE1MSW5wdXRFbGVtZW50O1xudmFyIGlzUmFkaW9FbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNIVE1MSW5wdXRFbGVtZW50KShub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xuZXhwb3J0cy5pc1JhZGlvRWxlbWVudCA9IGlzUmFkaW9FbGVtZW50O1xudmFyIG5vdEhpZGRlbklucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gISgoKDAsIGV4cG9ydHMuaXNIVE1MSW5wdXRFbGVtZW50KShub2RlKSB8fCAoMCwgZXhwb3J0cy5pc0hUTUxCdXR0b25FbGVtZW50KShub2RlKSkgJiYgKG5vZGUudHlwZSA9PT0gJ2hpZGRlbicgfHwgbm9kZS5kaXNhYmxlZCkpO1xufTtcbmV4cG9ydHMubm90SGlkZGVuSW5wdXQgPSBub3RIaWRkZW5JbnB1dDtcbnZhciBpc0F1dG9Gb2N1c0FsbG93ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBhdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZShjb25zdGFudHNfMS5GT0NVU19OT19BVVRPRk9DVVMpO1xuICAgIHJldHVybiAhW3RydWUsICd0cnVlJywgJyddLmluY2x1ZGVzKGF0dHJpYnV0ZSk7XG59O1xuZXhwb3J0cy5pc0F1dG9Gb2N1c0FsbG93ZWQgPSBpc0F1dG9Gb2N1c0FsbG93ZWQ7XG52YXIgaXNHdWFyZCA9IGZ1bmN0aW9uIChub2RlKSB7IHZhciBfYTsgcmV0dXJuIEJvb2xlYW4obm9kZSAmJiAoKF9hID0gKDAsIGV4cG9ydHMuZ2V0RGF0YXNldCkobm9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1c0d1YXJkKSk7IH07XG5leHBvcnRzLmlzR3VhcmQgPSBpc0d1YXJkO1xudmFyIGlzTm90QUd1YXJkID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuICEoMCwgZXhwb3J0cy5pc0d1YXJkKShub2RlKTsgfTtcbmV4cG9ydHMuaXNOb3RBR3VhcmQgPSBpc05vdEFHdWFyZDtcbnZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gQm9vbGVhbih4KTsgfTtcbmV4cG9ydHMuaXNEZWZpbmVkID0gaXNEZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFsbFBhcmVudEF1dG9mb2N1c2FibGVzID0gZXhwb3J0cy5nZXRUb3BDb21tb25QYXJlbnQgPSBleHBvcnRzLmdldENvbW1vblBhcmVudCA9IHZvaWQgMDtcbnZhciBET011dGlsc18xID0gcmVxdWlyZShcIi4vRE9NdXRpbHNcIik7XG52YXIgRE9NdXRpbHNfMiA9IHJlcXVpcmUoXCIuL0RPTXV0aWxzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbnZhciBnZXRQYXJlbnRzID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudHMpIHtcbiAgICBpZiAocGFyZW50cyA9PT0gdm9pZCAwKSB7IHBhcmVudHMgPSBbXTsgfVxuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGdldFBhcmVudHMobm9kZS5wYXJlbnROb2RlLmhvc3QgfHwgbm9kZS5wYXJlbnROb2RlLCBwYXJlbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59O1xuLyoqXG4gKiBmaW5kcyBhIHBhcmVudCBmb3IgYm90aCBub2RlQSBhbmQgbm9kZUJcbiAqIEBwYXJhbSBub2RlQVxuICogQHBhcmFtIG5vZGVCXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxuICovXG52YXIgZ2V0Q29tbW9uUGFyZW50ID0gZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICAgIHZhciBwYXJlbnRzQSA9IGdldFBhcmVudHMobm9kZUEpO1xuICAgIHZhciBwYXJlbnRzQiA9IGdldFBhcmVudHMobm9kZUIpO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItZm9yLW9mXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzQS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY3VycmVudFBhcmVudCA9IHBhcmVudHNBW2ldO1xuICAgICAgICBpZiAocGFyZW50c0IuaW5kZXhPZihjdXJyZW50UGFyZW50KSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5nZXRDb21tb25QYXJlbnQgPSBnZXRDb21tb25QYXJlbnQ7XG52YXIgZ2V0VG9wQ29tbW9uUGFyZW50ID0gZnVuY3Rpb24gKGJhc2VBY3RpdmVFbGVtZW50LCBsZWZ0RW50cnksIHJpZ2h0RW50cmllcykge1xuICAgIHZhciBhY3RpdmVFbGVtZW50cyA9ICgwLCBhcnJheV8xLmFzQXJyYXkpKGJhc2VBY3RpdmVFbGVtZW50KTtcbiAgICB2YXIgbGVmdEVudHJpZXMgPSAoMCwgYXJyYXlfMS5hc0FycmF5KShsZWZ0RW50cnkpO1xuICAgIHZhciBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudHNbMF07XG4gICAgdmFyIHRvcENvbW1vbiA9IGZhbHNlO1xuICAgIGxlZnRFbnRyaWVzLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICB0b3BDb21tb24gPSAoMCwgZXhwb3J0cy5nZXRDb21tb25QYXJlbnQpKHRvcENvbW1vbiB8fCBlbnRyeSwgZW50cnkpIHx8IHRvcENvbW1vbjtcbiAgICAgICAgcmlnaHRFbnRyaWVzLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJFbnRyeSkge1xuICAgICAgICAgICAgdmFyIGNvbW1vbiA9ICgwLCBleHBvcnRzLmdldENvbW1vblBhcmVudCkoYWN0aXZlRWxlbWVudCwgc3ViRW50cnkpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbikge1xuICAgICAgICAgICAgICAgIGlmICghdG9wQ29tbW9uIHx8ICgwLCBET011dGlsc18yLmNvbnRhaW5zKShjb21tb24sIHRvcENvbW1vbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQ29tbW9uID0gY29tbW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQ29tbW9uID0gKDAsIGV4cG9ydHMuZ2V0Q29tbW9uUGFyZW50KShjb21tb24sIHRvcENvbW1vbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBhZGQgYXNzZXJ0IGhlcmU/XG4gICAgcmV0dXJuIHRvcENvbW1vbjtcbn07XG5leHBvcnRzLmdldFRvcENvbW1vblBhcmVudCA9IGdldFRvcENvbW1vblBhcmVudDtcbi8qKlxuICogcmV0dXJuIGxpc3Qgb2Ygbm9kZXMgd2hpY2ggYXJlIGV4cGVjdGVkIHRvIGJlIGF1dG9mb2N1c2VkIGluc2lkZSBhIGdpdmVuIHRvcCBub2Rlc1xuICogQHBhcmFtIGVudHJpZXNcbiAqIEBwYXJhbSB2aXNpYmlsaXR5Q2FjaGVcbiAqL1xudmFyIGFsbFBhcmVudEF1dG9mb2N1c2FibGVzID0gZnVuY3Rpb24gKGVudHJpZXMsIHZpc2liaWxpdHlDYWNoZSkge1xuICAgIHJldHVybiBlbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBhY2MuY29uY2F0KCgwLCBET011dGlsc18xLnBhcmVudEF1dG9mb2N1c2FibGVzKShub2RlLCB2aXNpYmlsaXR5Q2FjaGUpKTsgfSwgW10pO1xufTtcbmV4cG9ydHMuYWxsUGFyZW50QXV0b2ZvY3VzYWJsZXMgPSBhbGxQYXJlbnRBdXRvZm9jdXNhYmxlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zYWZlUHJvYmUgPSB2b2lkIDA7XG52YXIgc2FmZVByb2JlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbmV4cG9ydHMuc2FmZVByb2JlID0gc2FmZVByb2JlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9yZGVyQnlUYWJJbmRleCA9IGV4cG9ydHMudGFiU29ydCA9IHZvaWQgMDtcbnZhciBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG52YXIgdGFiU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHRhYkRpZmYgPSBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbiAgICB2YXIgaW5kZXhEaWZmID0gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgaWYgKHRhYkRpZmYpIHtcbiAgICAgICAgaWYgKCFhLnRhYkluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWIudGFiSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFiRGlmZiB8fCBpbmRleERpZmY7XG59O1xuZXhwb3J0cy50YWJTb3J0ID0gdGFiU29ydDtcbnZhciBvcmRlckJ5VGFiSW5kZXggPSBmdW5jdGlvbiAobm9kZXMsIGZpbHRlck5lZ2F0aXZlLCBrZWVwR3VhcmRzKSB7XG4gICAgcmV0dXJuICgwLCBhcnJheV8xLnRvQXJyYXkpKG5vZGVzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChub2RlLCBpbmRleCkgeyByZXR1cm4gKHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICB0YWJJbmRleDoga2VlcEd1YXJkcyAmJiBub2RlLnRhYkluZGV4ID09PSAtMSA/ICgobm9kZS5kYXRhc2V0IHx8IHt9KS5mb2N1c0d1YXJkID8gMCA6IC0xKSA6IG5vZGUudGFiSW5kZXgsXG4gICAgfSk7IH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuICFmaWx0ZXJOZWdhdGl2ZSB8fCBkYXRhLnRhYkluZGV4ID49IDA7IH0pXG4gICAgICAgIC5zb3J0KGV4cG9ydHMudGFiU29ydCk7XG59O1xuZXhwb3J0cy5vcmRlckJ5VGFiSW5kZXggPSBvcmRlckJ5VGFiSW5kZXg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGFyZW50QXV0b2ZvY3VzYWJsZXMgPSBleHBvcnRzLmdldEZvY3VzYWJsZXMgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbnZhciB0YWJiYWJsZXNfMSA9IHJlcXVpcmUoXCIuL3RhYmJhYmxlc1wiKTtcbnZhciBxdWVyeVRhYmJhYmxlcyA9IHRhYmJhYmxlc18xLnRhYmJhYmxlcy5qb2luKCcsJyk7XG52YXIgcXVlcnlHdWFyZFRhYmJhYmxlcyA9IFwiXCIuY29uY2F0KHF1ZXJ5VGFiYmFibGVzLCBcIiwgW2RhdGEtZm9jdXMtZ3VhcmRdXCIpO1xudmFyIGdldEZvY3VzYWJsZXNXaXRoU2hhZG93RG9tID0gZnVuY3Rpb24gKHBhcmVudCwgd2l0aEd1YXJkcykge1xuICAgIHJldHVybiAoMCwgYXJyYXlfMS50b0FycmF5KSgocGFyZW50LnNoYWRvd1Jvb3QgfHwgcGFyZW50KS5jaGlsZHJlbikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KGNoaWxkLm1hdGNoZXMod2l0aEd1YXJkcyA/IHF1ZXJ5R3VhcmRUYWJiYWJsZXMgOiBxdWVyeVRhYmJhYmxlcykgPyBbY2hpbGRdIDogW10sIGdldEZvY3VzYWJsZXNXaXRoU2hhZG93RG9tKGNoaWxkKSk7XG4gICAgfSwgW10pO1xufTtcbnZhciBnZXRGb2N1c2FibGVzV2l0aElGcmFtZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHdpdGhHdWFyZHMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gY29udGVudERvY3VtZW50IG9mIGlmcmFtZSB3aWxsIGJlIG51bGwgaWYgY3VycmVudCBvcmlnaW4gY2Fubm90IGFjY2VzcyBpdFxuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCAmJiAoKF9hID0gcGFyZW50LmNvbnRlbnREb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvZHkpKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5nZXRGb2N1c2FibGVzKShbcGFyZW50LmNvbnRlbnREb2N1bWVudC5ib2R5XSwgd2l0aEd1YXJkcyk7XG4gICAgfVxuICAgIHJldHVybiBbcGFyZW50XTtcbn07XG52YXIgZ2V0Rm9jdXNhYmxlcyA9IGZ1bmN0aW9uIChwYXJlbnRzLCB3aXRoR3VhcmRzKSB7XG4gICAgcmV0dXJuIHBhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBhcmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBmb2N1c2FibGVXaXRoU2hhZG93RG9tID0gZ2V0Rm9jdXNhYmxlc1dpdGhTaGFkb3dEb20ocGFyZW50LCB3aXRoR3VhcmRzKTtcbiAgICAgICAgdmFyIGZvY3VzYWJsZVdpdGhJZnJhbWVzID0gKF9hID0gW10pLmNvbmNhdC5hcHBseShfYSwgZm9jdXNhYmxlV2l0aFNoYWRvd0RvbS5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGdldEZvY3VzYWJsZXNXaXRoSUZyYW1lKG5vZGUsIHdpdGhHdWFyZHMpOyB9KSk7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KFxuICAgICAgICAvLyBhZGQgYWxsIHRhYmJhYmxlcyBpbnNpZGUgYW5kIHdpdGhpbiBzaGFkb3cgRE9NcyBpbiBET00gb3JkZXJcbiAgICAgICAgZm9jdXNhYmxlV2l0aElmcmFtZXMsIFxuICAgICAgICAvLyBhZGQgaWYgbm9kZSBpcyB0YWJiYWJsZSBpdHNlbGZcbiAgICAgICAgcGFyZW50LnBhcmVudE5vZGVcbiAgICAgICAgICAgID8gKDAsIGFycmF5XzEudG9BcnJheSkocGFyZW50LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeVRhYmJhYmxlcykpLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZSA9PT0gcGFyZW50OyB9KVxuICAgICAgICAgICAgOiBbXSk7XG4gICAgfSwgW10pO1xufTtcbmV4cG9ydHMuZ2V0Rm9jdXNhYmxlcyA9IGdldEZvY3VzYWJsZXM7XG4vKipcbiAqIHJldHVybiBhIGxpc3Qgb2YgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBhbiBhcmVhIG1hcmtlZCBhcyBcImF1dG8tZm9jdXNhYmxlXCJcbiAqIEBwYXJhbSBwYXJlbnRcbiAqL1xudmFyIGdldFBhcmVudEF1dG9mb2N1c2FibGVzID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIHZhciBwYXJlbnRGb2N1cyA9IHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiLmNvbmNhdChjb25zdGFudHNfMS5GT0NVU19BVVRPLCBcIl1cIikpO1xuICAgIHJldHVybiAoMCwgYXJyYXlfMS50b0FycmF5KShwYXJlbnRGb2N1cylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0Rm9jdXNhYmxlcykoW25vZGVdKTsgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlcykgeyByZXR1cm4gYWNjLmNvbmNhdChub2Rlcyk7IH0sIFtdKTtcbn07XG5leHBvcnRzLmdldFBhcmVudEF1dG9mb2N1c2FibGVzID0gZ2V0UGFyZW50QXV0b2ZvY3VzYWJsZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGFiYmFibGVzID0gdm9pZCAwO1xuLyoqXG4gKiBsaXN0IG9mIHRoZSBvYmplY3QgdG8gYmUgY29uc2lkZXJlZCBhcyBmb2N1c2FibGVcbiAqL1xuZXhwb3J0cy50YWJiYWJsZXMgPSBbXG4gICAgJ2J1dHRvbjplbmFibGVkJyxcbiAgICAnc2VsZWN0OmVuYWJsZWQnLFxuICAgICd0ZXh0YXJlYTplbmFibGVkJyxcbiAgICAnaW5wdXQ6ZW5hYmxlZCcsXG4gICAgLy8gZWxlbWVudHMgd2l0aCBleHBsaWNpdCByb2xlcyB3aWxsIGFsc28gdXNlIGV4cGxpY2l0IHRhYmluZGV4XG4gICAgLy8gJ1tyb2xlPVwiYnV0dG9uXCJdJyxcbiAgICAnYVtocmVmXScsXG4gICAgJ2FyZWFbaHJlZl0nLFxuICAgICdzdW1tYXJ5JyxcbiAgICAnaWZyYW1lJyxcbiAgICAnb2JqZWN0JyxcbiAgICAnZW1iZWQnLFxuICAgICdhdWRpb1tjb250cm9sc10nLFxuICAgICd2aWRlb1tjb250cm9sc10nLFxuICAgICdbdGFiaW5kZXhdJyxcbiAgICAnW2NvbnRlbnRlZGl0YWJsZV0nLFxuICAgICdbYXV0b2ZvY3VzXScsXG5dO1xuIiwiXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAob2JqLCBmbiwgY3R4KSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgbCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGwgPT09ICtsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gZnVuY3Rpb24gZnVuY3Rpb25zSGF2ZU5hbWVzKCkge1xuXHRyZXR1cm4gdHlwZW9mIGZ1bmN0aW9uIGYoKSB7fS5uYW1lID09PSAnc3RyaW5nJztcbn07XG5cbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmIChnT1BEKSB7XG5cdHRyeSB7XG5cdFx0Z09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbmZ1bmN0aW9uc0hhdmVOYW1lcy5mdW5jdGlvbnNIYXZlQ29uZmlndXJhYmxlTmFtZXMgPSBmdW5jdGlvbiBmdW5jdGlvbnNIYXZlQ29uZmlndXJhYmxlTmFtZXMoKSB7XG5cdGlmICghZnVuY3Rpb25zSGF2ZU5hbWVzKCkgfHwgIWdPUEQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dmFyIGRlc2MgPSBnT1BEKGZ1bmN0aW9uICgpIHt9LCAnbmFtZScpO1xuXHRyZXR1cm4gISFkZXNjICYmICEhZGVzYy5jb25maWd1cmFibGU7XG59O1xuXG52YXIgJGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcblxuZnVuY3Rpb25zSGF2ZU5hbWVzLmJvdW5kRnVuY3Rpb25zSGF2ZU5hbWVzID0gZnVuY3Rpb24gYm91bmRGdW5jdGlvbnNIYXZlTmFtZXMoKSB7XG5cdHJldHVybiBmdW5jdGlvbnNIYXZlTmFtZXMoKSAmJiB0eXBlb2YgJGJpbmQgPT09ICdmdW5jdGlvbicgJiYgZnVuY3Rpb24gZigpIHt9LmJpbmQoKS5uYW1lICE9PSAnJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb25zSGF2ZU5hbWVzO1xuIiwiLyohXG4gKiBGdXNlLmpzIHYzLjYuMSAtIExpZ2h0d2VpZ2h0IGZ1enp5LXNlYXJjaCAoaHR0cDovL2Z1c2Vqcy5pbylcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgS2lyb2xsb3MgUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqIFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiRnVzZVwiLFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuRnVzZT10KCk6ZS5GdXNlPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiByKG4pe2lmKHRbbl0pcmV0dXJuIHRbbl0uZXhwb3J0czt2YXIgbz10W25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxyKSxvLmw9ITAsby5leHBvcnRzfXJldHVybiByLm09ZSxyLmM9dCxyLmQ9ZnVuY3Rpb24oZSx0LG4pe3IubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPXIoZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBvIGluIGUpci5kKG4sbyxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLG8pKTtyZXR1cm4gbn0sci5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHIucD1cIlwiLHIoci5zPTApfShbZnVuY3Rpb24oZSx0LHIpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuKG49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIG8oZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fXZhciBpPXIoMSksYT1yKDcpLHM9YS5nZXQsYz0oYS5kZWVwVmFsdWUsYS5pc0FycmF5KSxoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LHIpe3ZhciBuPXIubG9jYXRpb24sbz12b2lkIDA9PT1uPzA6bixpPXIuZGlzdGFuY2UsYT12b2lkIDA9PT1pPzEwMDppLGM9ci50aHJlc2hvbGQsaD12b2lkIDA9PT1jPy42OmMsbD1yLm1heFBhdHRlcm5MZW5ndGgsdT12b2lkIDA9PT1sPzMyOmwsZj1yLmNhc2VTZW5zaXRpdmUsdj12b2lkIDAhPT1mJiZmLHA9ci50b2tlblNlcGFyYXRvcixkPXZvaWQgMD09PXA/LyArL2c6cCxnPXIuZmluZEFsbE1hdGNoZXMseT12b2lkIDAhPT1nJiZnLG09ci5taW5NYXRjaENoYXJMZW5ndGgsaz12b2lkIDA9PT1tPzE6bSxiPXIuaWQsUz12b2lkIDA9PT1iP251bGw6Yix4PXIua2V5cyxNPXZvaWQgMD09PXg/W106eCxfPXIuc2hvdWxkU29ydCx3PXZvaWQgMD09PV98fF8sTD1yLmdldEZuLEE9dm9pZCAwPT09TD9zOkwsTz1yLnNvcnRGbixDPXZvaWQgMD09PU8/ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5zY29yZS10LnNjb3JlfTpPLGo9ci50b2tlbml6ZSxQPXZvaWQgMCE9PWomJmosST1yLm1hdGNoQWxsVG9rZW5zLEY9dm9pZCAwIT09SSYmSSxUPXIuaW5jbHVkZU1hdGNoZXMsTj12b2lkIDAhPT1UJiZULHo9ci5pbmNsdWRlU2NvcmUsRT12b2lkIDAhPT16JiZ6LFc9ci52ZXJib3NlLEs9dm9pZCAwIT09VyYmVzshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMub3B0aW9ucz17bG9jYXRpb246byxkaXN0YW5jZTphLHRocmVzaG9sZDpoLG1heFBhdHRlcm5MZW5ndGg6dSxpc0Nhc2VTZW5zaXRpdmU6dix0b2tlblNlcGFyYXRvcjpkLGZpbmRBbGxNYXRjaGVzOnksbWluTWF0Y2hDaGFyTGVuZ3RoOmssaWQ6UyxrZXlzOk0saW5jbHVkZU1hdGNoZXM6TixpbmNsdWRlU2NvcmU6RSxzaG91bGRTb3J0OncsZ2V0Rm46QSxzb3J0Rm46Qyx2ZXJib3NlOkssdG9rZW5pemU6UCxtYXRjaEFsbFRva2VuczpGfSx0aGlzLnNldENvbGxlY3Rpb24odCksdGhpcy5fcHJvY2Vzc0tleXMoTSl9dmFyIHQscixhO3JldHVybiB0PWUsKHI9W3trZXk6XCJzZXRDb2xsZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGlzdD1lLGV9fSx7a2V5OlwiX3Byb2Nlc3NLZXlzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy5fa2V5V2VpZ2h0cz17fSx0aGlzLl9rZXlOYW1lcz1bXSxlLmxlbmd0aCYmXCJzdHJpbmdcIj09dHlwZW9mIGVbMF0pZm9yKHZhciB0PTAscj1lLmxlbmd0aDt0PHI7dCs9MSl7dmFyIG49ZVt0XTt0aGlzLl9rZXlXZWlnaHRzW25dPTEsdGhpcy5fa2V5TmFtZXMucHVzaChuKX1lbHNle2Zvcih2YXIgbz1udWxsLGk9bnVsbCxhPTAscz0wLGM9ZS5sZW5ndGg7czxjO3MrPTEpe3ZhciBoPWVbc107aWYoIWguaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKXRocm93IG5ldyBFcnJvcignTWlzc2luZyBcIm5hbWVcIiBwcm9wZXJ0eSBpbiBrZXkgb2JqZWN0Jyk7dmFyIGw9aC5uYW1lO2lmKHRoaXMuX2tleU5hbWVzLnB1c2gobCksIWguaGFzT3duUHJvcGVydHkoXCJ3ZWlnaHRcIikpdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwid2VpZ2h0XCIgcHJvcGVydHkgaW4ga2V5IG9iamVjdCcpO3ZhciB1PWgud2VpZ2h0O2lmKHU8MHx8dT4xKXRocm93IG5ldyBFcnJvcignXCJ3ZWlnaHRcIiBwcm9wZXJ0eSBpbiBrZXkgbXVzdCBiZWluIHRoZSByYW5nZSBvZiBbMCwgMSknKTtpPW51bGw9PWk/dTpNYXRoLm1heChpLHUpLG89bnVsbD09bz91Ok1hdGgubWluKG8sdSksdGhpcy5fa2V5V2VpZ2h0c1tsXT11LGErPXV9aWYoYT4xKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIG9mIHdlaWdodHMgY2Fubm90IGV4Y2VlZCAxXCIpfX19LHtrZXk6XCJzZWFyY2hcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e2xpbWl0OiExfTt0aGlzLl9sb2coJy0tLS0tLS0tLVxcblNlYXJjaCBwYXR0ZXJuOiBcIicuY29uY2F0KGUsJ1wiJykpO3ZhciByPXRoaXMuX3ByZXBhcmVTZWFyY2hlcnMoZSksbj1yLnRva2VuU2VhcmNoZXJzLG89ci5mdWxsU2VhcmNoZXIsaT10aGlzLl9zZWFyY2gobixvKTtyZXR1cm4gdGhpcy5fY29tcHV0ZVNjb3JlKGkpLHRoaXMub3B0aW9ucy5zaG91bGRTb3J0JiZ0aGlzLl9zb3J0KGkpLHQubGltaXQmJlwibnVtYmVyXCI9PXR5cGVvZiB0LmxpbWl0JiYoaT1pLnNsaWNlKDAsdC5saW1pdCkpLHRoaXMuX2Zvcm1hdChpKX19LHtrZXk6XCJfcHJlcGFyZVNlYXJjaGVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlwiXCIsdD1bXTtpZih0aGlzLm9wdGlvbnMudG9rZW5pemUpZm9yKHZhciByPWUuc3BsaXQodGhpcy5vcHRpb25zLnRva2VuU2VwYXJhdG9yKSxuPTAsbz1yLmxlbmd0aDtuPG87bis9MSl0LnB1c2gobmV3IGkocltuXSx0aGlzLm9wdGlvbnMpKTtyZXR1cm57dG9rZW5TZWFyY2hlcnM6dCxmdWxsU2VhcmNoZXI6bmV3IGkoZSx0aGlzLm9wdGlvbnMpfX19LHtrZXk6XCJfc2VhcmNoXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W10sdD1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxyPXRoaXMubGlzdCxuPXt9LG89W107aWYoXCJzdHJpbmdcIj09dHlwZW9mIHJbMF0pe2Zvcih2YXIgaT0wLGE9ci5sZW5ndGg7aTxhO2krPTEpdGhpcy5fYW5hbHl6ZSh7a2V5OlwiXCIsdmFsdWU6cltpXSxyZWNvcmQ6aSxpbmRleDppfSx7cmVzdWx0TWFwOm4scmVzdWx0czpvLHRva2VuU2VhcmNoZXJzOmUsZnVsbFNlYXJjaGVyOnR9KTtyZXR1cm4gb31mb3IodmFyIHM9MCxjPXIubGVuZ3RoO3M8YztzKz0xKWZvcih2YXIgaD1yW3NdLGw9MCx1PXRoaXMuX2tleU5hbWVzLmxlbmd0aDtsPHU7bCs9MSl7dmFyIGY9dGhpcy5fa2V5TmFtZXNbbF07dGhpcy5fYW5hbHl6ZSh7a2V5OmYsdmFsdWU6dGhpcy5vcHRpb25zLmdldEZuKGgsZikscmVjb3JkOmgsaW5kZXg6c30se3Jlc3VsdE1hcDpuLHJlc3VsdHM6byx0b2tlblNlYXJjaGVyczplLGZ1bGxTZWFyY2hlcjp0fSl9cmV0dXJuIG99fSx7a2V5OlwiX2FuYWx5emVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMsbj1lLmtleSxvPWUuYXJyYXlJbmRleCxpPXZvaWQgMD09PW8/LTE6byxhPWUudmFsdWUscz1lLnJlY29yZCxoPWUuaW5kZXgsbD10LnRva2VuU2VhcmNoZXJzLHU9dm9pZCAwPT09bD9bXTpsLGY9dC5mdWxsU2VhcmNoZXIsdj10LnJlc3VsdE1hcCxwPXZvaWQgMD09PXY/e306dixkPXQucmVzdWx0cyxnPXZvaWQgMD09PWQ/W106ZDshZnVuY3Rpb24gZSh0LG8saSxhKXtpZihudWxsIT1vKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBvKXt2YXIgcz0hMSxoPS0xLGw9MDtyLl9sb2coXCJcXG5LZXk6IFwiLmNvbmNhdChcIlwiPT09bj9cIi0tXCI6bikpO3ZhciB2PWYuc2VhcmNoKG8pO2lmKHIuX2xvZygnRnVsbCB0ZXh0OiBcIicuY29uY2F0KG8sJ1wiLCBzY29yZTogJykuY29uY2F0KHYuc2NvcmUpKSxyLm9wdGlvbnMudG9rZW5pemUpe2Zvcih2YXIgZD1vLnNwbGl0KHIub3B0aW9ucy50b2tlblNlcGFyYXRvcikseT1kLmxlbmd0aCxtPVtdLGs9MCxiPXUubGVuZ3RoO2s8YjtrKz0xKXt2YXIgUz11W2tdO3IuX2xvZygnXFxuUGF0dGVybjogXCInLmNvbmNhdChTLnBhdHRlcm4sJ1wiJykpO2Zvcih2YXIgeD0hMSxNPTA7TTx5O00rPTEpe3ZhciBfPWRbTV0sdz1TLnNlYXJjaChfKSxMPXt9O3cuaXNNYXRjaD8oTFtfXT13LnNjb3JlLHM9ITAseD0hMCxtLnB1c2gody5zY29yZSkpOihMW19dPTEsci5vcHRpb25zLm1hdGNoQWxsVG9rZW5zfHxtLnB1c2goMSkpLHIuX2xvZygnVG9rZW46IFwiJy5jb25jYXQoXywnXCIsIHNjb3JlOiAnKS5jb25jYXQoTFtfXSkpfXgmJihsKz0xKX1oPW1bMF07Zm9yKHZhciBBPW0ubGVuZ3RoLE89MTtPPEE7Tys9MSloKz1tW09dO2gvPUEsci5fbG9nKFwiVG9rZW4gc2NvcmUgYXZlcmFnZTpcIixoKX12YXIgQz12LnNjb3JlO2g+LTEmJihDPShDK2gpLzIpLHIuX2xvZyhcIlNjb3JlIGF2ZXJhZ2U6XCIsQyk7dmFyIGo9IXIub3B0aW9ucy50b2tlbml6ZXx8IXIub3B0aW9ucy5tYXRjaEFsbFRva2Vuc3x8bD49dS5sZW5ndGg7aWYoci5fbG9nKFwiXFxuQ2hlY2sgTWF0Y2hlczogXCIuY29uY2F0KGopKSwoc3x8di5pc01hdGNoKSYmail7dmFyIFA9e2tleTpuLGFycmF5SW5kZXg6dCx2YWx1ZTpvLHNjb3JlOkN9O3Iub3B0aW9ucy5pbmNsdWRlTWF0Y2hlcyYmKFAubWF0Y2hlZEluZGljZXM9di5tYXRjaGVkSW5kaWNlcyk7dmFyIEk9cFthXTtJP0kub3V0cHV0LnB1c2goUCk6KHBbYV09e2l0ZW06aSxvdXRwdXQ6W1BdfSxnLnB1c2gocFthXSkpfX1lbHNlIGlmKGMobykpZm9yKHZhciBGPTAsVD1vLmxlbmd0aDtGPFQ7Ris9MSllKEYsb1tGXSxpLGEpfShpLGEscyxoKX19LHtrZXk6XCJfY29tcHV0ZVNjb3JlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fbG9nKFwiXFxuXFxuQ29tcHV0aW5nIHNjb3JlOlxcblwiKTtmb3IodmFyIHQ9dGhpcy5fa2V5V2VpZ2h0cyxyPSEhT2JqZWN0LmtleXModCkubGVuZ3RoLG49MCxvPWUubGVuZ3RoO248bztuKz0xKXtmb3IodmFyIGk9ZVtuXSxhPWkub3V0cHV0LHM9YS5sZW5ndGgsYz0xLGg9MDtoPHM7aCs9MSl7dmFyIGw9YVtoXSx1PWwua2V5LGY9cj90W3VdOjEsdj0wPT09bC5zY29yZSYmdCYmdFt1XT4wP051bWJlci5FUFNJTE9OOmwuc2NvcmU7Yyo9TWF0aC5wb3codixmKX1pLnNjb3JlPWMsdGhpcy5fbG9nKGkpfX19LHtrZXk6XCJfc29ydFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX2xvZyhcIlxcblxcblNvcnRpbmcuLi4uXCIpLGUuc29ydCh0aGlzLm9wdGlvbnMuc29ydEZuKX19LHtrZXk6XCJfZm9ybWF0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9W107aWYodGhpcy5vcHRpb25zLnZlcmJvc2Upe3ZhciByPVtdO3RoaXMuX2xvZyhcIlxcblxcbk91dHB1dDpcXG5cXG5cIixKU09OLnN0cmluZ2lmeShlLGZ1bmN0aW9uKGUsdCl7aWYoXCJvYmplY3RcIj09PW4odCkmJm51bGwhPT10KXtpZigtMSE9PXIuaW5kZXhPZih0KSlyZXR1cm47ci5wdXNoKHQpfXJldHVybiB0fSwyKSkscj1udWxsfXZhciBvPVtdO3RoaXMub3B0aW9ucy5pbmNsdWRlTWF0Y2hlcyYmby5wdXNoKGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5vdXRwdXQ7dC5tYXRjaGVzPVtdO2Zvcih2YXIgbj0wLG89ci5sZW5ndGg7bjxvO24rPTEpe3ZhciBpPXJbbl07aWYoMCE9PWkubWF0Y2hlZEluZGljZXMubGVuZ3RoKXt2YXIgYT17aW5kaWNlczppLm1hdGNoZWRJbmRpY2VzLHZhbHVlOmkudmFsdWV9O2kua2V5JiYoYS5rZXk9aS5rZXkpLGkuaGFzT3duUHJvcGVydHkoXCJhcnJheUluZGV4XCIpJiZpLmFycmF5SW5kZXg+LTEmJihhLmFycmF5SW5kZXg9aS5hcnJheUluZGV4KSx0Lm1hdGNoZXMucHVzaChhKX19fSksdGhpcy5vcHRpb25zLmluY2x1ZGVTY29yZSYmby5wdXNoKGZ1bmN0aW9uKGUsdCl7dC5zY29yZT1lLnNjb3JlfSk7Zm9yKHZhciBpPTAsYT1lLmxlbmd0aDtpPGE7aSs9MSl7dmFyIHM9ZVtpXTtpZih0aGlzLm9wdGlvbnMuaWQmJihzLml0ZW09dGhpcy5vcHRpb25zLmdldEZuKHMuaXRlbSx0aGlzLm9wdGlvbnMuaWQpWzBdKSxvLmxlbmd0aCl7Zm9yKHZhciBjPXtpdGVtOnMuaXRlbX0saD0wLGw9by5sZW5ndGg7aDxsO2grPTEpb1toXShzLGMpO3QucHVzaChjKX1lbHNlIHQucHVzaChzLml0ZW0pfXJldHVybiB0fX0se2tleTpcIl9sb2dcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO3RoaXMub3B0aW9ucy52ZXJib3NlJiYoZT1jb25zb2xlKS5sb2cuYXBwbHkoZSxhcmd1bWVudHMpfX1dKSYmbyh0LnByb3RvdHlwZSxyKSxhJiZvKHQsYSksZX0oKTtlLmV4cG9ydHM9aH0sZnVuY3Rpb24oZSx0LHIpe2Z1bmN0aW9uIG4oZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fXZhciBvPXIoMiksaT1yKDMpLGE9cig2KSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LHIpe3ZhciBuPXIubG9jYXRpb24sbz12b2lkIDA9PT1uPzA6bixpPXIuZGlzdGFuY2Uscz12b2lkIDA9PT1pPzEwMDppLGM9ci50aHJlc2hvbGQsaD12b2lkIDA9PT1jPy42OmMsbD1yLm1heFBhdHRlcm5MZW5ndGgsdT12b2lkIDA9PT1sPzMyOmwsZj1yLmlzQ2FzZVNlbnNpdGl2ZSx2PXZvaWQgMCE9PWYmJmYscD1yLnRva2VuU2VwYXJhdG9yLGQ9dm9pZCAwPT09cD8vICsvZzpwLGc9ci5maW5kQWxsTWF0Y2hlcyx5PXZvaWQgMCE9PWcmJmcsbT1yLm1pbk1hdGNoQ2hhckxlbmd0aCxrPXZvaWQgMD09PW0/MTptLGI9ci5pbmNsdWRlTWF0Y2hlcyxTPXZvaWQgMCE9PWImJmI7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxlKSx0aGlzLm9wdGlvbnM9e2xvY2F0aW9uOm8sZGlzdGFuY2U6cyx0aHJlc2hvbGQ6aCxtYXhQYXR0ZXJuTGVuZ3RoOnUsaXNDYXNlU2Vuc2l0aXZlOnYsdG9rZW5TZXBhcmF0b3I6ZCxmaW5kQWxsTWF0Y2hlczp5LGluY2x1ZGVNYXRjaGVzOlMsbWluTWF0Y2hDaGFyTGVuZ3RoOmt9LHRoaXMucGF0dGVybj12P3Q6dC50b0xvd2VyQ2FzZSgpLHRoaXMucGF0dGVybi5sZW5ndGg8PXUmJih0aGlzLnBhdHRlcm5BbHBoYWJldD1hKHRoaXMucGF0dGVybikpfXZhciB0LHIscztyZXR1cm4gdD1lLChyPVt7a2V5Olwic2VhcmNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5vcHRpb25zLHI9dC5pc0Nhc2VTZW5zaXRpdmUsbj10LmluY2x1ZGVNYXRjaGVzO2lmKHJ8fChlPWUudG9Mb3dlckNhc2UoKSksdGhpcy5wYXR0ZXJuPT09ZSl7dmFyIGE9e2lzTWF0Y2g6ITAsc2NvcmU6MH07cmV0dXJuIG4mJihhLm1hdGNoZWRJbmRpY2VzPVtbMCxlLmxlbmd0aC0xXV0pLGF9dmFyIHM9dGhpcy5vcHRpb25zLGM9cy5tYXhQYXR0ZXJuTGVuZ3RoLGg9cy50b2tlblNlcGFyYXRvcjtpZih0aGlzLnBhdHRlcm4ubGVuZ3RoPmMpcmV0dXJuIG8oZSx0aGlzLnBhdHRlcm4saCk7dmFyIGw9dGhpcy5vcHRpb25zLHU9bC5sb2NhdGlvbixmPWwuZGlzdGFuY2Usdj1sLnRocmVzaG9sZCxwPWwuZmluZEFsbE1hdGNoZXMsZD1sLm1pbk1hdGNoQ2hhckxlbmd0aDtyZXR1cm4gaShlLHRoaXMucGF0dGVybix0aGlzLnBhdHRlcm5BbHBoYWJldCx7bG9jYXRpb246dSxkaXN0YW5jZTpmLHRocmVzaG9sZDp2LGZpbmRBbGxNYXRjaGVzOnAsbWluTWF0Y2hDaGFyTGVuZ3RoOmQsaW5jbHVkZU1hdGNoZXM6bn0pfX1dKSYmbih0LnByb3RvdHlwZSxyKSxzJiZuKHQscyksZX0oKTtlLmV4cG9ydHM9c30sZnVuY3Rpb24oZSx0KXt2YXIgcj0vW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2c7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOi8gKy9nLG89bmV3IFJlZ0V4cCh0LnJlcGxhY2UocixcIlxcXFwkJlwiKS5yZXBsYWNlKG4sXCJ8XCIpKSxpPWUubWF0Y2gobyksYT0hIWkscz1bXTtpZihhKWZvcih2YXIgYz0wLGg9aS5sZW5ndGg7YzxoO2MrPTEpe3ZhciBsPWlbY107cy5wdXNoKFtlLmluZGV4T2YobCksbC5sZW5ndGgtMV0pfXJldHVybntzY29yZTphPy41OjEsaXNNYXRjaDphLG1hdGNoZWRJbmRpY2VzOnN9fX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoNCksbz1yKDUpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscixpKXtmb3IodmFyIGE9aS5sb2NhdGlvbixzPXZvaWQgMD09PWE/MDphLGM9aS5kaXN0YW5jZSxoPXZvaWQgMD09PWM/MTAwOmMsbD1pLnRocmVzaG9sZCx1PXZvaWQgMD09PWw/LjY6bCxmPWkuZmluZEFsbE1hdGNoZXMsdj12b2lkIDAhPT1mJiZmLHA9aS5taW5NYXRjaENoYXJMZW5ndGgsZD12b2lkIDA9PT1wPzE6cCxnPWkuaW5jbHVkZU1hdGNoZXMseT12b2lkIDAhPT1nJiZnLG09cyxrPWUubGVuZ3RoLGI9dSxTPWUuaW5kZXhPZih0LG0pLHg9dC5sZW5ndGgsTT1bXSxfPTA7XzxrO18rPTEpTVtfXT0wO2lmKC0xIT09Uyl7dmFyIHc9bih0LHtlcnJvcnM6MCxjdXJyZW50TG9jYXRpb246UyxleHBlY3RlZExvY2F0aW9uOm0sZGlzdGFuY2U6aH0pO2lmKGI9TWF0aC5taW4odyxiKSwtMSE9PShTPWUubGFzdEluZGV4T2YodCxtK3gpKSl7dmFyIEw9bih0LHtlcnJvcnM6MCxjdXJyZW50TG9jYXRpb246UyxleHBlY3RlZExvY2F0aW9uOm0sZGlzdGFuY2U6aH0pO2I9TWF0aC5taW4oTCxiKX19Uz0tMTtmb3IodmFyIEE9W10sTz0xLEM9eCtrLGo9MTw8KHg8PTMxP3gtMTozMCksUD0wO1A8eDtQKz0xKXtmb3IodmFyIEk9MCxGPUM7STxGOyl7bih0LHtlcnJvcnM6UCxjdXJyZW50TG9jYXRpb246bStGLGV4cGVjdGVkTG9jYXRpb246bSxkaXN0YW5jZTpofSk8PWI/ST1GOkM9RixGPU1hdGguZmxvb3IoKEMtSSkvMitJKX1DPUY7dmFyIFQ9TWF0aC5tYXgoMSxtLUYrMSksTj12P2s6TWF0aC5taW4obStGLGspK3gsej1BcnJheShOKzIpO3pbTisxXT0oMTw8UCktMTtmb3IodmFyIEU9TjtFPj1UO0UtPTEpe3ZhciBXPUUtMSxLPXJbZS5jaGFyQXQoVyldO2lmKEsmJihNW1ddPTEpLHpbRV09KHpbRSsxXTw8MXwxKSZLLDAhPT1QJiYoeltFXXw9KEFbRSsxXXxBW0VdKTw8MXwxfEFbRSsxXSkseltFXSZqJiYoTz1uKHQse2Vycm9yczpQLGN1cnJlbnRMb2NhdGlvbjpXLGV4cGVjdGVkTG9jYXRpb246bSxkaXN0YW5jZTpofSkpPD1iKXtpZihiPU8sKFM9Vyk8PW0pYnJlYWs7VD1NYXRoLm1heCgxLDIqbS1TKX19aWYobih0LHtlcnJvcnM6UCsxLGN1cnJlbnRMb2NhdGlvbjptLGV4cGVjdGVkTG9jYXRpb246bSxkaXN0YW5jZTpofSk+YilicmVhaztBPXp9dmFyICQ9e2lzTWF0Y2g6Uz49MCxzY29yZTowPT09Tz8uMDAxOk99O3JldHVybiB5JiYoJC5tYXRjaGVkSW5kaWNlcz1vKE0sZCkpLCR9fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3ZhciByPXQuZXJyb3JzLG49dm9pZCAwPT09cj8wOnIsbz10LmN1cnJlbnRMb2NhdGlvbixpPXZvaWQgMD09PW8/MDpvLGE9dC5leHBlY3RlZExvY2F0aW9uLHM9dm9pZCAwPT09YT8wOmEsYz10LmRpc3RhbmNlLGg9dm9pZCAwPT09Yz8xMDA6YyxsPW4vZS5sZW5ndGgsdT1NYXRoLmFicyhzLWkpO3JldHVybiBoP2wrdS9oOnU/MTpsfX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOltdLHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjEscj1bXSxuPS0xLG89LTEsaT0wLGE9ZS5sZW5ndGg7aTxhO2krPTEpe3ZhciBzPWVbaV07cyYmLTE9PT1uP249aTpzfHwtMT09PW58fCgobz1pLTEpLW4rMT49dCYmci5wdXNoKFtuLG9dKSxuPS0xKX1yZXR1cm4gZVtpLTFdJiZpLW4+PXQmJnIucHVzaChbbixpLTFdKSxyfX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXt9LHI9ZS5sZW5ndGgsbj0wO248cjtuKz0xKXRbZS5jaGFyQXQobildPTA7Zm9yKHZhciBvPTA7bzxyO28rPTEpdFtlLmNoYXJBdChvKV18PTE8PHItby0xO3JldHVybiB0fX0sZnVuY3Rpb24oZSx0KXt2YXIgcj1mdW5jdGlvbihlKXtyZXR1cm4gQXJyYXkuaXNBcnJheT9BcnJheS5pc0FycmF5KGUpOlwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX0sbj1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9cIlwiOmZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBlO3ZhciB0PWUrXCJcIjtyZXR1cm5cIjBcIj09dCYmMS9lPT0tMS8wP1wiLTBcIjp0fShlKX0sbz1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZX0saT1mdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZX07ZS5leHBvcnRzPXtnZXQ6ZnVuY3Rpb24oZSx0KXt2YXIgYT1bXTtyZXR1cm4gZnVuY3Rpb24gZSh0LHMpe2lmKHMpe3ZhciBjPXMuaW5kZXhPZihcIi5cIiksaD1zLGw9bnVsbDstMSE9PWMmJihoPXMuc2xpY2UoMCxjKSxsPXMuc2xpY2UoYysxKSk7dmFyIHU9dFtoXTtpZihudWxsIT11KWlmKGx8fCFvKHUpJiYhaSh1KSlpZihyKHUpKWZvcih2YXIgZj0wLHY9dS5sZW5ndGg7Zjx2O2YrPTEpZSh1W2ZdLGwpO2Vsc2UgbCYmZSh1LGwpO2Vsc2UgYS5wdXNoKG4odSkpfWVsc2UgYS5wdXNoKHQpfShlLHQpLGF9LGlzQXJyYXk6cixpc1N0cmluZzpvLGlzTnVtOmksdG9TdHJpbmc6bn19XSl9KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1Byb3RvID0gcmVxdWlyZSgnaGFzLXByb3RvJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IChcblx0aGFzUHJvdG9cblx0XHQ/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cdFx0OiBudWxsXG4pO1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG5pZiAoZ2V0UHJvdG8pIHtcblx0dHJ5IHtcblx0XHRudWxsLmVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc2hhZG93cmVhbG0vcHVsbC8zODQjaXNzdWVjb21tZW50LTEzNjQyNjQyMjlcblx0XHR2YXIgZXJyb3JQcm90byA9IGdldFByb3RvKGdldFByb3RvKGUpKTtcblx0XHRJTlRSSU5TSUNTWyclRXJyb3IucHJvdG90eXBlJSddID0gZXJyb3JQcm90bztcblx0fVxufVxuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuICYmIGdldFByb3RvKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xudmFyIEdldFBhcmFtcyA9IGZ1bmN0aW9uIChmdW5jKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHR2YXIgcGF0dGVybkNvbW1lbnRzID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xuXHR2YXIgcGF0dGVybkFyZ3VtZW50cyA9IC8oW15cXHMsXSspL2c7XG5cblx0dmFyIGZ1bmNTdHJpbmcgPSBmdW5jXG5cdFx0LnRvU3RyaW5nKClcblx0XHQucmVwbGFjZShwYXR0ZXJuQ29tbWVudHMsICcnKTtcblxuXHR2YXIgcmVzdWx0ID0gZnVuY1N0cmluZ1xuXHRcdC5zbGljZShcblx0XHRcdGZ1bmNTdHJpbmcuaW5kZXhPZignKCcpICsgMSxcblx0XHRcdGZ1bmNTdHJpbmcuaW5kZXhPZignKScpXG5cdFx0KVxuXHRcdC5tYXRjaChwYXR0ZXJuQXJndW1lbnRzKTtcblxuXHRpZiAocmVzdWx0ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gR2V0UGFyYW1zO1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LkdldFBhcmFtcyA9IEdldFBhcmFtcztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydDtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb29rQXQ7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IDAuMDAwMDAxKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBlcnNwZWN0aXZlO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IDAuMDAwMDAxKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdXG4gICAgdyA9IHcgfHwgMS4wXG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHdcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gd1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gd1xuICAgIHJldHVybiBvdXRcbn0iLCIvLyBAZmxvd1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5ID0gJ19fZ2xvYmFsX3VuaXF1ZV9pZF9fJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdsb2JhbFtrZXldID0gKGdsb2JhbFtrZXldIHx8IDApICsgMTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHRyeSB7XG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbmhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcblx0Ly8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG5cdGlmICghaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gJGRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJbiBGaXJlZm94IDQtMjIsIGRlZmluaW5nIGxlbmd0aCBvbiBhbiBhcnJheSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJ2YXIgbm9DYXNlID0gcmVxdWlyZSgnbm8tY2FzZScpXG52YXIgdXBwZXJDYXNlID0gcmVxdWlyZSgndXBwZXItY2FzZScpXG5cbi8qKlxuICogSGVhZGVyIGNhc2UgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBbbG9jYWxlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbG9jYWxlKSB7XG4gIHJldHVybiBub0Nhc2UodmFsdWUsIGxvY2FsZSwgJy0nKS5yZXBsYWNlKC9eLnwtLi9nLCBmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiB1cHBlckNhc2UobSwgbG9jYWxlKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuTWVtb10gPSBNRU1PX1NUQVRJQ1M7XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIC8vIFJlYWN0IHYxNi4xMSBhbmQgYmVsb3dcbiAgaWYgKHJlYWN0SXMuaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9IC8vIFJlYWN0IHYxNi4xMiBhbmQgYWJvdmVcblxuXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICB2YXIgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciwgcHJlZmVyLXRlbXBsYXRlICovXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcbnZhciBjYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB0b0h5cGhlbkxvd2VyKG1hdGNoKSB7XG4gIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBjYWNoZVtuYW1lXVxuICB9XG5cbiAgdmFyIGhOYW1lID0gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIHRvSHlwaGVuTG93ZXIpO1xuICByZXR1cm4gKGNhY2hlW25hbWVdID0gbXNQYXR0ZXJuLnRlc3QoaE5hbWUpID8gJy0nICsgaE5hbWUgOiBoTmFtZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RGF5ID0gRGF0ZS5wcm90b3R5cGUuZ2V0RGF5O1xudmFyIHRyeURhdGVPYmplY3QgPSBmdW5jdGlvbiB0cnlEYXRlR2V0RGF5Q2FsbCh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGdldERheS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGF0ZU9iamVjdCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlEYXRlT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBkYXRlQ2xhc3M7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXMtb2JqZWN0JylcbnZhciBpc1dpbmRvdyA9IHJlcXVpcmUoJ2lzLXdpbmRvdycpXG5cbmZ1bmN0aW9uIGlzTm9kZSAodmFsKSB7XG4gIGlmICghaXNPYmplY3QodmFsKSB8fCAhaXNXaW5kb3cod2luZG93KSB8fCB0eXBlb2Ygd2luZG93Lk5vZGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiB2YWwubm9kZU5hbWUgPT09ICdzdHJpbmcnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBpc0Jyb3dzZXIgPSBleHBvcnRzLmlzQnJvd3NlciA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09ICdvYmplY3QnICYmIGRvY3VtZW50Lm5vZGVUeXBlID09PSA5O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0Jyb3dzZXI7IiwidmFyIGxvd2VyQ2FzZSA9IHJlcXVpcmUoJ2xvd2VyLWNhc2UnKVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGxvd2VyIGNhc2UuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgc3RyaW5nXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBbbG9jYWxlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nLCBsb2NhbGUpIHtcbiAgcmV0dXJuIGxvd2VyQ2FzZShzdHJpbmcsIGxvY2FsZSkgPT09IHN0cmluZ1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuXHRyZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGhhcztcbnZhciAkZXhlYztcbnZhciBpc1JlZ2V4TWFya2VyO1xudmFyIGJhZFN0cmluZ2lmaWVyO1xuXG5pZiAoaGFzVG9TdHJpbmdUYWcpIHtcblx0aGFzID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5Jyk7XG5cdCRleGVjID0gY2FsbEJvdW5kKCdSZWdFeHAucHJvdG90eXBlLmV4ZWMnKTtcblx0aXNSZWdleE1hcmtlciA9IHt9O1xuXG5cdHZhciB0aHJvd1JlZ2V4TWFya2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGlzUmVnZXhNYXJrZXI7XG5cdH07XG5cdGJhZFN0cmluZ2lmaWVyID0ge1xuXHRcdHRvU3RyaW5nOiB0aHJvd1JlZ2V4TWFya2VyLFxuXHRcdHZhbHVlT2Y6IHRocm93UmVnZXhNYXJrZXJcblx0fTtcblxuXHRpZiAodHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSA9PT0gJ3N5bWJvbCcpIHtcblx0XHRiYWRTdHJpbmdpZmllcltTeW1ib2wudG9QcmltaXRpdmVdID0gdGhyb3dSZWdleE1hcmtlcjtcblx0fVxufVxuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1RvU3RyaW5nVGFnXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHQ/IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcblx0XHR2YXIgaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBoYXMoZGVzY3JpcHRvciwgJ3ZhbHVlJyk7XG5cdFx0aWYgKCFoYXNMYXN0SW5kZXhEYXRhUHJvcGVydHkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0JGV4ZWModmFsdWUsIGJhZFN0cmluZ2lmaWVyKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZSA9PT0gaXNSZWdleE1hcmtlcjtcblx0XHR9XG5cdH1cblx0OiBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0Ly8gSW4gb2xkZXIgYnJvd3NlcnMsIHR5cGVvZiByZWdleCBpbmNvcnJlY3RseSByZXR1cm5zICdmdW5jdGlvbidcblx0XHRpZiAoIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gcmVnZXhDbGFzcztcblx0fTtcbiIsInZhciB1cHBlckNhc2UgPSByZXF1aXJlKCd1cHBlci1jYXNlJylcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyB1cHBlciBjYXNlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIHN0cmluZ1xuICogQHBhcmFtICB7U3RyaW5nfSAgW2xvY2FsZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZywgbG9jYWxlKSB7XG4gIHJldHVybiB1cHBlckNhc2Uoc3RyaW5nLCBsb2NhbGUpID09PSBzdHJpbmdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG8gPSBPYmplY3Qob2JqKTtcblxuICByZXR1cm4gbyA9PT0gby53aW5kb3c7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpO1xuIiwidmFyIHBhdGhHZXR0ZXIgPSByZXF1aXJlKCcuL3BhdGgtZ2V0dGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBXTWFwID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnP1xuICBXZWFrTWFwOlxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGtleXNbaV0gPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvY3ljbGUuanNcblxuZXhwb3J0cy5kZWN5Y2xlID0gZnVuY3Rpb24gZGVjeWNsZShvYmplY3QsIG9wdGlvbnMsIHJlcGxhY2VyLCBtYXApIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIG1hcCA9IG1hcCB8fCBuZXcgV01hcCgpO1xuXG4gIHZhciBub0NpcmN1bGFyT3B0aW9uID0gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnY2lyY3VsYXInKTtcbiAgdmFyIHdpdGhSZWZzID0gb3B0aW9ucy5yZWZzICE9PSBmYWxzZTtcblxuICByZXR1cm4gKGZ1bmN0aW9uIGRlcmV6KF92YWx1ZSwgcGF0aCwga2V5KSB7XG5cbiAgICAvLyBUaGUgZGVyZXogcmVjdXJzZXMgdGhyb3VnaCB0aGUgb2JqZWN0LCBwcm9kdWNpbmcgdGhlIGRlZXAgY29weS5cblxuICAgIHZhciBpLCAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlclxuICAgICAgbmFtZSwgICAgICAgLy8gUHJvcGVydHkgbmFtZVxuICAgICAgbnU7ICAgICAgICAgLy8gVGhlIG5ldyBvYmplY3Qgb3IgYXJyYXlcblxuICAgIC8vIHR5cGVvZiBudWxsID09PSAnb2JqZWN0Jywgc28gZ28gb24gaWYgdGhpcyB2YWx1ZSBpcyByZWFsbHkgYW4gb2JqZWN0IGJ1dCBub3RcbiAgICAvLyBvbmUgb2YgdGhlIHdlaXJkIGJ1aWx0aW4gb2JqZWN0cy5cblxuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlcGxhY2VyKGtleSB8fCAnJywgX3ZhbHVlKSA6IF92YWx1ZTtcblxuICAgIGlmIChvcHRpb25zLmRhdGUgJiYgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4geyRqc2FuOiAnZCcgKyB2YWx1ZS5nZXRUaW1lKCl9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWdleCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHskanNhbjogJ3InICsgdXRpbHMuZ2V0UmVnZXhGbGFncyh2YWx1ZSkgKyAnLCcgKyB2YWx1ZS5zb3VyY2V9O1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snZnVuY3Rpb24nXSAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICdmJyArIHV0aWxzLnN0cmluZ2lmeUZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zWydmdW5jdGlvbiddKX1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ25hbiddICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4geyRqc2FuOiAnbid9XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydpbmZpbml0eSddKSB7XG4gICAgICBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSB2YWx1ZSkgcmV0dXJuIHskanNhbjogJ2knfVxuICAgICAgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gdmFsdWUpIHJldHVybiB7JGpzYW46ICd5J31cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ3VuZGVmaW5lZCddICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICd1J31cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2Vycm9yJ10gJiYgdmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHskanNhbjogJ2UnICsgdmFsdWUubWVzc2FnZX1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ3N5bWJvbCddICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHZhciBzeW1ib2xLZXkgPSBTeW1ib2wua2V5Rm9yKHZhbHVlKVxuICAgICAgaWYgKHN5bWJvbEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7JGpzYW46ICdnJyArIHN5bWJvbEtleX1cbiAgICAgIH1cblxuICAgICAgLy8gJ1N5bWJvbChmb28pJy5zbGljZSg3LCAtMSkgPT09ICdmb28nXG4gICAgICByZXR1cm4geyRqc2FuOiAncycgKyB2YWx1ZS50b1N0cmluZygpLnNsaWNlKDcsIC0xKX1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1snbWFwJ10gJiYgdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCAmJiB0eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHskanNhbjogJ20nICsgSlNPTi5zdHJpbmdpZnkoZGVjeWNsZShBcnJheS5mcm9tKHZhbHVlKSwgb3B0aW9ucywgcmVwbGFjZXIsIG1hcCkpfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zWydzZXQnXSAmJiB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0ICYmIHR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4geyRqc2FuOiAnbCcgKyBKU09OLnN0cmluZ2lmeShkZWN5Y2xlKEFycmF5LmZyb20odmFsdWUpLCBvcHRpb25zLCByZXBsYWNlciwgbWFwKSl9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIga2V5U3RyaW5nID0gKGtleSB8fCAnJCcpO1xuICAgICAgICByZXR1cm4gXCJ0b0pTT04gZmFpbGVkIGZvciAnXCIgKyAobWFwLmdldCh2YWx1ZSkgfHwga2V5U3RyaW5nKSArIFwiJ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAgICAmJlxuICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgICYmXG4gICAgICAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSAgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpICAmJlxuICAgICAgISh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSAgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikpIHtcblxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IG9yIGFycmF5LCBsb29rIHRvIHNlZSBpZiB3ZSBoYXZlIGFscmVhZHlcbiAgICAgICAgLy8gZW5jb3VudGVyZWQgaXQuIElmIHNvLCByZXR1cm4gYSAkcmVmL3BhdGggb2JqZWN0LlxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgZm91bmRQYXRoID0gbWFwLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChmb3VuZFBhdGgpIHtcbiAgICAgICAgICBpZiAobm9DaXJjdWxhck9wdGlvbiAmJiB3aXRoUmVmcykge1xuICAgICAgICAgICAgcmV0dXJuIHskanNhbjogZm91bmRQYXRofTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGEgdHJ1ZSBjaXJjdWxhciByZWZlcmVuY2UgaWYgdGhlIHBhcmVudCBwYXRoIGlzIGluc2lkZSBvZiBmb3VuZFBhdGhcbiAgICAgICAgICAvLyBkcm9wIHRoZSBsYXN0IGNvbXBvbmVudCBvZiB0aGUgY3VycmVudCBwYXRoIGFuZCBjaGVjayBpZiBpdCBzdGFydHMgd2l0aCBmb3VuZFBhdGhcbiAgICAgICAgICB2YXIgcGFyZW50UGF0aCA9IHBhdGguc3BsaXQoJy4nKS5zbGljZSgwLCAtMSkuam9pbignLicpO1xuICAgICAgICAgIGlmIChwYXJlbnRQYXRoLmluZGV4T2YoZm91bmRQYXRoKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCFub0NpcmN1bGFyT3B0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5jaXJjdWxhciA9PT0gJ2Z1bmN0aW9uJz9cbiAgICAgICAgICAgICAgb3B0aW9ucy5jaXJjdWxhcih2YWx1ZSwgcGF0aCwgZm91bmRQYXRoKTpcbiAgICAgICAgICAgICAgb3B0aW9ucy5jaXJjdWxhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7JGpzYW46IGZvdW5kUGF0aH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aXRoUmVmcykgcmV0dXJuIHskanNhbjogZm91bmRQYXRofTtcbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KHZhbHVlLCBwYXRoKTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgcmVwbGljYXRlIHRoZSBhcnJheS5cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgbnUgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScsIGkpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYW4gb2JqZWN0LCByZXBsaWNhdGUgdGhlIG9iamVjdC5cblxuICAgICAgICBudSA9IHt9O1xuICAgICAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBuYW1lKSkge1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0gL15cXHcrJC8udGVzdChuYW1lKSA/XG4gICAgICAgICAgICAgICcuJyArIG5hbWUgOlxuICAgICAgICAgICAgICAnWycgKyBKU09OLnN0cmluZ2lmeShuYW1lKSArICddJztcbiAgICAgICAgICAgIG51W25hbWVdID0gbmFtZSA9PT0gJyRqc2FuJyA/IFtkZXJleih2YWx1ZVtuYW1lXSwgcGF0aCArIG5leHRQYXRoKV0gOiBkZXJleih2YWx1ZVtuYW1lXSwgcGF0aCArIG5leHRQYXRoLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KG9iamVjdCwgJyQnKSk7XG59O1xuXG5cbmV4cG9ydHMucmV0cm9jeWNsZSA9IGZ1bmN0aW9uIHJldHJvY3ljbGUoJCkge1xuICAndXNlIHN0cmljdCc7XG5cblxuICByZXR1cm4gKGZ1bmN0aW9uIHJleih2YWx1ZSkge1xuXG4gICAgLy8gVGhlIHJleiBmdW5jdGlvbiB3YWxrcyByZWN1cnNpdmVseSB0aHJvdWdoIHRoZSBvYmplY3QgbG9va2luZyBmb3IgJGpzYW5cbiAgICAvLyBwcm9wZXJ0aWVzLiBXaGVuIGl0IGZpbmRzIG9uZSB0aGF0IGhhcyBhIHZhbHVlIHRoYXQgaXMgYSBwYXRoLCB0aGVuIGl0XG4gICAgLy8gcmVwbGFjZXMgdGhlICRqc2FuIG9iamVjdCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSB2YWx1ZSB0aGF0IGlzIGZvdW5kIGJ5XG4gICAgLy8gdGhlIHBhdGguXG5cbiAgICB2YXIgaSwgaXRlbSwgbmFtZSwgcGF0aDtcblxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgIGlmIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uJGpzYW4pIHtcbiAgICAgICAgICAgICAgdmFsdWVbaV0gPSB1dGlscy5yZXN0b3JlKGl0ZW0uJGpzYW4sICQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV6KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgLy8gYmFzZSBjYXNlIHBhc3NlZCByYXcgb2JqZWN0XG4gICAgICAgICAgaWYodHlwZW9mIHZhbHVlW25hbWVdID09PSAnc3RyaW5nJyAmJiBuYW1lID09PSAnJGpzYW4nKXtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5yZXN0b3JlKHZhbHVlLiRqc2FuLCAkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnJGpzYW4nKSB7XG4gICAgICAgICAgICAgIHZhbHVlW25hbWVdID0gdmFsdWVbbmFtZV1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW25hbWVdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbbmFtZV07XG4gICAgICAgICAgICAgIGlmIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLiRqc2FuKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHV0aWxzLnJlc3RvcmUoaXRlbS4kanNhbiwgJCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJleihpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KCQpKTtcbn07XG4iLCJ2YXIgY3ljbGUgPSByZXF1aXJlKCcuL2N5Y2xlJyk7XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIF9vcHRpb25zKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkuYXBwbHkoSlNPTiwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCBmYWxzZTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgJ2RhdGUnOiBvcHRpb25zLFxuICAgICAgJ2Z1bmN0aW9uJzogb3B0aW9ucyxcbiAgICAgICdyZWdleCc6IG9wdGlvbnMsXG4gICAgICAndW5kZWZpbmVkJzogb3B0aW9ucyxcbiAgICAgICdlcnJvcic6IG9wdGlvbnMsXG4gICAgICAnc3ltYm9sJzogb3B0aW9ucyxcbiAgICAgICdtYXAnOiBvcHRpb25zLFxuICAgICAgJ3NldCc6IG9wdGlvbnMsXG4gICAgICAnbmFuJzogb3B0aW9ucyxcbiAgICAgICdpbmZpbml0eSc6IG9wdGlvbnNcbiAgICB9XG4gIH1cblxuICB2YXIgZGVjeWNsZWQgPSBjeWNsZS5kZWN5Y2xlKHZhbHVlLCBvcHRpb25zLCByZXBsYWNlcik7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlY3ljbGVkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWN5Y2xlIGFscmVhZHkgaGFuZGxlcyB3aGVuIHJlcGxhY2VyIGlzIGEgZnVuY3Rpb24uXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlY3ljbGVkLCBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSA/IHJlcGxhY2VyIDogbnVsbCwgc3BhY2UpO1xuICB9XG59XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0LCByZXZpdmVyKSB7XG4gIHZhciBuZWVkc1JldHJvY3ljbGUgPSAvXCJcXCRqc2FuXCIvLnRlc3QodGV4dCk7XG4gIHZhciBwYXJzZWQ7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHRleHQsIHJldml2ZXIpO1xuICB9XG4gIGlmIChuZWVkc1JldHJvY3ljbGUpIHtcbiAgICBwYXJzZWQgPSBjeWNsZS5yZXRyb2N5Y2xlKHBhcnNlZCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcGF0aEdldHRlcjtcblxuZnVuY3Rpb24gcGF0aEdldHRlcihvYmosIHBhdGgpIHtcbiAgaWYgKHBhdGggIT09ICckJykge1xuICAgIHZhciBwYXRocyA9IGdldFBhdGhzKHBhdGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGggPSBwYXRoc1tpXS50b1N0cmluZygpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKTtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW3BhdGhdID09PSAndW5kZWZpbmVkJyAmJiBpICE9PSBwYXRocy5sZW5ndGggLSAxKSBjb250aW51ZTtcbiAgICAgIG9iaiA9IG9ialtwYXRoXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0aHMocGF0aFN0cmluZykge1xuICB2YXIgcmVnZXggPSAvKD86XFwuKFxcdyspKXwoPzpcXFsoXFxkKylcXF0pfCg/OlxcW1wiKCg/OlteXFxcXFwiXXxcXFxcLikqKVwiXFxdKS9nO1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlZ2V4LmV4ZWMocGF0aFN0cmluZykpIHtcbiAgICBtYXRjaGVzLnB1c2goIG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdICk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG4iLCJ2YXIgcGF0aEdldHRlciA9IHJlcXVpcmUoJy4vcGF0aC1nZXR0ZXInKTtcbnZhciBqc2FuID0gcmVxdWlyZSgnLi8nKTtcblxuZXhwb3J0cy5nZXRSZWdleEZsYWdzID0gZnVuY3Rpb24gZ2V0UmVnZXhGbGFncyhyZWdleCkge1xuICB2YXIgZmxhZ3MgPSAnJztcbiAgaWYgKHJlZ2V4Lmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJztcbiAgaWYgKHJlZ2V4Lmdsb2JhbCkgZmxhZ3MgKz0gJ2cnO1xuICBpZiAocmVnZXgubXVsdGlsaW5lKSBmbGFncyArPSAnbSc7XG4gIHJldHVybiBmbGFncztcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5RnVuY3Rpb24gPSBmdW5jdGlvbiBzdHJpbmdpZnlGdW5jdGlvbihmbiwgY3VzdG9tVG9TdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21Ub1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjdXN0b21Ub1N0cmluZyhmbik7XG4gIH1cbiAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXltee10qe3xeW149XSo9Pi8pO1xuICB2YXIgc3RhcnQgPSBtYXRjaCA/IG1hdGNoWzBdIDogJzxmdW5jdGlvbj4gJztcbiAgdmFyIGVuZCA9IHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICd9JyA/ICd9JyA6ICcnO1xuICByZXR1cm4gc3RhcnQucmVwbGFjZSgvXFxyXFxufFxcbi9nLCAnICcpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgLyogLi4uICovICcgKyBlbmQ7XG59O1xuXG5leHBvcnRzLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKG9iaiwgcm9vdCkge1xuICB2YXIgdHlwZSA9IG9ialswXTtcbiAgdmFyIHJlc3QgPSBvYmouc2xpY2UoMSk7XG4gIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSAnJCc6XG4gICAgICByZXR1cm4gcGF0aEdldHRlcihyb290LCBvYmopO1xuICAgIGNhc2UgJ3InOlxuICAgICAgdmFyIGNvbW1hID0gcmVzdC5pbmRleE9mKCcsJyk7XG4gICAgICB2YXIgZmxhZ3MgPSByZXN0LnNsaWNlKDAsIGNvbW1hKTtcbiAgICAgIHZhciBzb3VyY2UgPSByZXN0LnNsaWNlKGNvbW1hICsgMSk7XG4gICAgICByZXR1cm4gUmVnRXhwKHNvdXJjZSwgZmxhZ3MpO1xuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCtyZXN0KTtcbiAgICBjYXNlICdmJzpcbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBydW4ganNhbiBwYXJzZWQgZnVuY3Rpb25cIikgfTtcbiAgICAgIGZuLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiByZXN0OyB9O1xuICAgICAgcmV0dXJuIGZuO1xuICAgIGNhc2UgJ3UnOlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihyZXN0KTtcbiAgICAgIGVycm9yLnN0YWNrID0gJ1N0YWNrIGlzIHVuYXZhaWxhYmxlIGZvciBqc2FuIHBhcnNlZCBlcnJvcnMnO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIFN5bWJvbChyZXN0KTtcbiAgICBjYXNlICdnJzpcbiAgICAgIHJldHVybiBTeW1ib2wuZm9yKHJlc3QpO1xuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG5ldyBNYXAoanNhbi5wYXJzZShyZXN0KSk7XG4gICAgY2FzZSAnbCc6XG4gICAgICByZXR1cm4gbmV3IFNldChqc2FuLnBhcnNlKHJlc3QpKTtcbiAgICBjYXNlICduJzpcbiAgICAgIHJldHVybiBOYU47XG4gICAgY2FzZSAnaSc6XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLndhcm4oJ3Vua25vd24gdHlwZScsIG9iaik7XG4gICAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cblxuLyoqXG4gKiBDb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCB0aGUgYXBpLlxuICogQ2FsbHMgYC5nZXRgIHdoZW4gY2FsbGVkIHdpdGggYW4gYG9iamVjdGAgYW5kIGEgYHBvaW50ZXJgLlxuICogQ2FsbHMgYC5zZXRgIHdoZW4gYWxzbyBjYWxsZWQgd2l0aCBgdmFsdWVgLlxuICogSWYgb25seSBzdXBwbGllZCBgb2JqZWN0YCwgcmV0dXJucyBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLCBtYXBwZWQgdG8gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcG9pbnRlclxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBhcGkgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgICAvLyAuc2V0KClcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gYXBpLnNldChvYmosIHBvaW50ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gLmdldCgpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5nZXQob2JqLCBwb2ludGVyKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24gb24gYG9iamAuXG4gICAgdmFyIHdyYXBwZWQgPSBhcGkuYmluZChhcGksIG9iaik7XG5cbiAgICAvLyBTdXBwb3J0IGZvciBvbyBzdHlsZVxuICAgIGZvciAodmFyIG5hbWUgaW4gYXBpKSB7XG4gICAgICAgIGlmIChhcGkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHdyYXBwZWRbbmFtZV0gPSBhcGlbbmFtZV0uYmluZCh3cmFwcGVkLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkO1xufVxuXG5cbi8qKlxuICogTG9va3VwIGEganNvbiBwb2ludGVyIGluIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwb2ludGVyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuYXBpLmdldCA9IGZ1bmN0aW9uIGdldCAob2JqLCBwb2ludGVyKSB7XG4gICAgdmFyIHJlZlRva2VucyA9IEFycmF5LmlzQXJyYXkocG9pbnRlcikgPyBwb2ludGVyIDogYXBpLnBhcnNlKHBvaW50ZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZUb2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHRvayA9IHJlZlRva2Vuc1tpXTtcbiAgICAgICAgaWYgKCEodHlwZW9mIG9iaiA9PSAnb2JqZWN0JyAmJiB0b2sgaW4gb2JqKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlZmVyZW5jZSB0b2tlbjogJyArIHRvayk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gb2JqW3Rva107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFNldHMgYSB2YWx1ZSBvbiBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcG9pbnRlclxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmFwaS5zZXQgPSBmdW5jdGlvbiBzZXQgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgICB2YXIgcmVmVG9rZW5zID0gQXJyYXkuaXNBcnJheShwb2ludGVyKSA/IHBvaW50ZXIgOiBhcGkucGFyc2UocG9pbnRlciksXG4gICAgICBuZXh0VG9rID0gcmVmVG9rZW5zWzBdO1xuXG4gICAgaWYgKHJlZlRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHNldCB0aGUgcm9vdCBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZlRva2Vucy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgdmFyIHRvayA9IHJlZlRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2sgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB0b2sgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdG9rID0gU3RyaW5nKHRvaylcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rID09PSBcIl9fcHJvdG9fX1wiIHx8IHRvayA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IHRvayA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rID09PSAnLScgJiYgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgdG9rID0gb2JqLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VG9rID0gcmVmVG9rZW5zW2kgKyAxXTtcblxuICAgICAgICBpZiAoISh0b2sgaW4gb2JqKSkge1xuICAgICAgICAgICAgaWYgKG5leHRUb2subWF0Y2goL14oXFxkK3wtKSQvKSkge1xuICAgICAgICAgICAgICAgIG9ialt0b2tdID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialt0b2tdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gb2JqW3Rva107XG4gICAgfVxuICAgIGlmIChuZXh0VG9rID09PSAnLScgJiYgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBuZXh0VG9rID0gb2JqLmxlbmd0aDtcbiAgICB9XG4gICAgb2JqW25leHRUb2tdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBvaW50ZXJcbiAqL1xuYXBpLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmosIHBvaW50ZXIpIHtcbiAgICB2YXIgcmVmVG9rZW5zID0gQXJyYXkuaXNBcnJheShwb2ludGVyKSA/IHBvaW50ZXIgOiBhcGkucGFyc2UocG9pbnRlcik7XG4gICAgdmFyIGZpbmFsVG9rZW4gPSByZWZUb2tlbnNbcmVmVG9rZW5zLmxlbmd0aCAtMV07XG4gICAgaWYgKGZpbmFsVG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyIGZvciByZW1vdmU6IFwiJyArIHBvaW50ZXIgKyAnXCInKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gYXBpLmdldChvYmosIHJlZlRva2Vucy5zbGljZSgwLCAtMSkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHZhciBpbmRleCA9ICtmaW5hbFRva2VuO1xuICAgICAgaWYgKGZpbmFsVG9rZW4gPT09ICcnICYmIGlzTmFOKGluZGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJyYXkgaW5kZXg6IFwiJyArIGZpbmFsVG9rZW4gKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKHBhcmVudCwgaW5kZXgsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgcGFyZW50W2ZpbmFsVG9rZW5dO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIChwb2ludGVyIC0+IHZhbHVlKSBkaWN0aW9uYXJ5IGZvciBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZXNjZW5kXG4gKiBAcmV0dXJucyB7fVxuICovXG5hcGkuZGljdCA9IGZ1bmN0aW9uIGRpY3QgKG9iaiwgZGVzY2VuZCkge1xuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgYXBpLndhbGsob2JqLCBmdW5jdGlvbiAodmFsdWUsIHBvaW50ZXIpIHtcbiAgICAgICAgcmVzdWx0c1twb2ludGVyXSA9IHZhbHVlO1xuICAgIH0sIGRlc2NlbmQpO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGFuIG9iamVjdFxuICogSXRlcmF0b3I6IGZ1bmN0aW9uICh2YWx1ZSwgcG9pbnRlcikge31cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGVzY2VuZFxuICovXG5hcGkud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaiwgaXRlcmF0b3IsIGRlc2NlbmQpIHtcbiAgICB2YXIgcmVmVG9rZW5zID0gW107XG5cbiAgICBkZXNjZW5kID0gZGVzY2VuZCB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgKGZ1bmN0aW9uIG5leHQgKGN1cikge1xuICAgICAgICBlYWNoKGN1ciwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHJlZlRva2Vucy5wdXNoKFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgIGlmIChkZXNjZW5kKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih2YWx1ZSwgYXBpLmNvbXBpbGUocmVmVG9rZW5zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZUb2tlbnMucG9wKCk7XG4gICAgICAgIH0pO1xuICAgIH0ob2JqKSk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIGFuIG9iamVjdCBoYXMgYSB2YWx1ZSBmb3IgYSBqc29uIHBvaW50ZXJcbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gcG9pbnRlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmFwaS5oYXMgPSBmdW5jdGlvbiBoYXMgKG9iaiwgcG9pbnRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGFwaS5nZXQob2JqLCBwb2ludGVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEVzY2FwZXMgYSByZWZlcmVuY2UgdG9rZW5cbiAqXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5hcGkuZXNjYXBlID0gZnVuY3Rpb24gZXNjYXBlIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59O1xuXG4vKipcbiAqIFVuZXNjYXBlcyBhIHJlZmVyZW5jZSB0b2tlblxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFwaS51bmVzY2FwZSA9IGZ1bmN0aW9uIHVuZXNjYXBlIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBqc29uIHBvaW50ZXIgaW50byBhIGFycmF5IG9mIHJlZmVyZW5jZSB0b2tlbnNcbiAqXG4gKiBAcGFyYW0gcG9pbnRlclxuICogQHJldHVybnMge0FycmF5fVxuICovXG5hcGkucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAocG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09PSAnJykgeyByZXR1cm4gW107IH1cbiAgICBpZiAocG9pbnRlci5jaGFyQXQoMCkgIT09ICcvJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyOiAnICsgcG9pbnRlcik7IH1cbiAgICByZXR1cm4gcG9pbnRlci5zdWJzdHJpbmcoMSkuc3BsaXQoL1xcLy8pLm1hcChhcGkudW5lc2NhcGUpO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBqc29uIHBvaW50ZXIgZnJvbSBhIGFycmF5IG9mIHJlZmVyZW5jZSB0b2tlbnNcbiAqXG4gKiBAcGFyYW0gcmVmVG9rZW5zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5hcGkuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUgKHJlZlRva2Vucykge1xuICAgIGlmIChyZWZUb2tlbnMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIHJldHVybiAnLycgKyByZWZUb2tlbnMubWFwKGFwaS5lc2NhcGUpLmpvaW4oJy8nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgaHlwaGVuYXRlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2h5cGhlbmF0ZS1zdHlsZS1uYW1lJykpO1xuXG4vKipcbiAqIENvbnZlcnQgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gZGFzaCBzZXBhcmF0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gY29udmVydENhc2Uoc3R5bGUpIHtcbiAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICB2YXIga2V5ID0gcHJvcC5pbmRleE9mKCctLScpID09PSAwID8gcHJvcCA6IGh5cGhlbmF0ZShwcm9wKTtcbiAgICBjb252ZXJ0ZWRba2V5XSA9IHN0eWxlW3Byb3BdO1xuICB9XG5cbiAgaWYgKHN0eWxlLmZhbGxiYWNrcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmZhbGxiYWNrcykpIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3MubWFwKGNvbnZlcnRDYXNlKTtlbHNlIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBjb252ZXJ0Q2FzZShzdHlsZS5mYWxsYmFja3MpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbi8qKlxuICogQWxsb3cgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgYnkgY29udmVydGluZyB0aGVtIGJhY2sgdG8gZGFzaGVyaXplZC5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbWVsQ2FzZSgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBydWxlcyBsaWtlIEBmb250LWZhY2UsIHdoaWNoIGNhbiBoYXZlIG11bHRpcGxlIHN0eWxlcyBpbiBhbiBhcnJheVxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHlsZVtpbmRleF0gPSBjb252ZXJ0Q2FzZShzdHlsZVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRDYXNlKHN0eWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICBpZiAocHJvcC5pbmRleE9mKCctLScpID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGh5cGhlbmF0ZWRQcm9wID0gaHlwaGVuYXRlKHByb3ApOyAvLyBUaGVyZSB3YXMgbm8gY2FtZWwgY2FzZSBpbiBwbGFjZVxuXG4gICAgaWYgKHByb3AgPT09IGh5cGhlbmF0ZWRQcm9wKSByZXR1cm4gdmFsdWU7XG4gICAgcnVsZS5wcm9wKGh5cGhlbmF0ZWRQcm9wLCB2YWx1ZSk7IC8vIENvcmUgd2lsbCBpZ25vcmUgdGhhdCBwcm9wZXJ0eSB2YWx1ZSB3ZSBzZXQgdGhlIHByb3BlciBvbmUgYWJvdmUuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLFxuICAgIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWVcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY2FtZWxDYXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIganNzID0gcmVxdWlyZSgnanNzJyk7XG5cbnZhciBweCA9IGpzcy5oYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5weCA6ICdweCc7XG52YXIgbXMgPSBqc3MuaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MubXMgOiAnbXMnO1xudmFyIHBlcmNlbnQgPSBqc3MuaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MucGVyY2VudCA6ICclJztcbi8qKlxuICogR2VuZXJhdGVkIGpzcy1wbHVnaW4tZGVmYXVsdC11bml0IENTUyBwcm9wZXJ0eSB1bml0c1xuICpcbiAqIEB0eXBlIG9iamVjdFxuICovXG5cbnZhciBkZWZhdWx0VW5pdHMgPSB7XG4gIC8vIEFuaW1hdGlvbiBwcm9wZXJ0aWVzXG4gICdhbmltYXRpb24tZGVsYXknOiBtcyxcbiAgJ2FuaW1hdGlvbi1kdXJhdGlvbic6IG1zLFxuICAvLyBCYWNrZ3JvdW5kIHByb3BlcnRpZXNcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiBweCxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6IHB4LFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogcHgsXG4gICdiYWNrZ3JvdW5kLXNpemUnOiBweCxcbiAgLy8gQm9yZGVyIFByb3BlcnRpZXNcbiAgYm9yZGVyOiBweCxcbiAgJ2JvcmRlci1ib3R0b20nOiBweCxcbiAgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItYm90dG9tLXdpZHRoJzogcHgsXG4gICdib3JkZXItbGVmdCc6IHB4LFxuICAnYm9yZGVyLWxlZnQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1yaWdodCc6IHB4LFxuICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogcHgsXG4gICdib3JkZXItdG9wJzogcHgsXG4gICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXRvcC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXdpZHRoJzogcHgsXG4gIC8vIE1hcmdpbiBwcm9wZXJ0aWVzXG4gIG1hcmdpbjogcHgsXG4gICdtYXJnaW4tYm90dG9tJzogcHgsXG4gICdtYXJnaW4tbGVmdCc6IHB4LFxuICAnbWFyZ2luLXJpZ2h0JzogcHgsXG4gICdtYXJnaW4tdG9wJzogcHgsXG4gIC8vIFBhZGRpbmcgcHJvcGVydGllc1xuICBwYWRkaW5nOiBweCxcbiAgJ3BhZGRpbmctYm90dG9tJzogcHgsXG4gICdwYWRkaW5nLWxlZnQnOiBweCxcbiAgJ3BhZGRpbmctcmlnaHQnOiBweCxcbiAgJ3BhZGRpbmctdG9wJzogcHgsXG4gIC8vIE1hc2sgcHJvcGVydGllc1xuICAnbWFzay1wb3NpdGlvbi14JzogcHgsXG4gICdtYXNrLXBvc2l0aW9uLXknOiBweCxcbiAgJ21hc2stc2l6ZSc6IHB4LFxuICAvLyBXaWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAgaGVpZ2h0OiBweCxcbiAgd2lkdGg6IHB4LFxuICAnbWluLWhlaWdodCc6IHB4LFxuICAnbWF4LWhlaWdodCc6IHB4LFxuICAnbWluLXdpZHRoJzogcHgsXG4gICdtYXgtd2lkdGgnOiBweCxcbiAgLy8gUG9zaXRpb24gcHJvcGVydGllc1xuICBib3R0b206IHB4LFxuICBsZWZ0OiBweCxcbiAgdG9wOiBweCxcbiAgcmlnaHQ6IHB4LFxuICAvLyBTaGFkb3cgcHJvcGVydGllc1xuICAnYm94LXNoYWRvdyc6IHB4LFxuICAndGV4dC1zaGFkb3cnOiBweCxcbiAgLy8gQ29sdW1uIHByb3BlcnRpZXNcbiAgJ2NvbHVtbi1nYXAnOiBweCxcbiAgJ2NvbHVtbi1ydWxlJzogcHgsXG4gICdjb2x1bW4tcnVsZS13aWR0aCc6IHB4LFxuICAnY29sdW1uLXdpZHRoJzogcHgsXG4gIC8vIEZvbnQgYW5kIHRleHQgcHJvcGVydGllc1xuICAnZm9udC1zaXplJzogcHgsXG4gICdmb250LXNpemUtZGVsdGEnOiBweCxcbiAgJ2xldHRlci1zcGFjaW5nJzogcHgsXG4gICd0ZXh0LWluZGVudCc6IHB4LFxuICAndGV4dC1zdHJva2UnOiBweCxcbiAgJ3RleHQtc3Ryb2tlLXdpZHRoJzogcHgsXG4gICd3b3JkLXNwYWNpbmcnOiBweCxcbiAgLy8gTW90aW9uIHByb3BlcnRpZXNcbiAgbW90aW9uOiBweCxcbiAgJ21vdGlvbi1vZmZzZXQnOiBweCxcbiAgLy8gT3V0bGluZSBwcm9wZXJ0aWVzXG4gIG91dGxpbmU6IHB4LFxuICAnb3V0bGluZS1vZmZzZXQnOiBweCxcbiAgJ291dGxpbmUtd2lkdGgnOiBweCxcbiAgLy8gUGVyc3BlY3RpdmUgcHJvcGVydGllc1xuICBwZXJzcGVjdGl2ZTogcHgsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teSc6IHBlcmNlbnQsXG4gIC8vIFRyYW5zZm9ybSBwcm9wZXJ0aWVzXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXknOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi16JzogcGVyY2VudCxcbiAgLy8gVHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICd0cmFuc2l0aW9uLWRlbGF5JzogbXMsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEFsaWdubWVudCBwcm9wZXJ0aWVzXG4gICd2ZXJ0aWNhbC1hbGlnbic6IHB4LFxuICAnZmxleC1iYXNpcyc6IHB4LFxuICAvLyBTb21lIHJhbmRvbSBwcm9wZXJ0aWVzXG4gICdzaGFwZS1tYXJnaW4nOiBweCxcbiAgc2l6ZTogcHgsXG4gIC8vIEdyaWQgcHJvcGVydGllc1xuICBncmlkOiBweCxcbiAgJ2dyaWQtZ2FwJzogcHgsXG4gICdncmlkLXJvdy1nYXAnOiBweCxcbiAgJ2dyaWQtY29sdW1uLWdhcCc6IHB4LFxuICAnZ3JpZC10ZW1wbGF0ZS1yb3dzJzogcHgsXG4gICdncmlkLXRlbXBsYXRlLWNvbHVtbnMnOiBweCxcbiAgJ2dyaWQtYXV0by1yb3dzJzogcHgsXG4gICdncmlkLWF1dG8tY29sdW1ucyc6IHB4LFxuICAvLyBOb3QgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAgLy8gVXNlZCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWV4cGFuZCBpbnRlZ3JhdGlvbi5cbiAgJ2JveC1zaGFkb3cteCc6IHB4LFxuICAnYm94LXNoYWRvdy15JzogcHgsXG4gICdib3gtc2hhZG93LWJsdXInOiBweCxcbiAgJ2JveC1zaGFkb3ctc3ByZWFkJzogcHgsXG4gICdmb250LWxpbmUtaGVpZ2h0JzogcHgsXG4gICd0ZXh0LXNoYWRvdy14JzogcHgsXG4gICd0ZXh0LXNoYWRvdy15JzogcHgsXG4gICd0ZXh0LXNoYWRvdy1ibHVyJzogcHhcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBvYmplY3QgYW5kIGFkZHMgYSBjYW1lbCBjYXNlZCBwcm9wZXJ0eSB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBhZGRDYW1lbENhc2VkVmVyc2lvbihvYmopIHtcbiAgdmFyIHJlZ0V4cCA9IC8oLVthLXpdKS9nO1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzFdLnRvVXBwZXJDYXNlKCk7XG4gIH07XG5cbiAgdmFyIG5ld09iaiA9IHt9O1xuXG4gIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgbmV3T2JqW19rZXldID0gb2JqW19rZXldO1xuICAgIG5ld09ialtfa2V5LnJlcGxhY2UocmVnRXhwLCByZXBsYWNlKV0gPSBvYmpbX2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG52YXIgdW5pdHMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihkZWZhdWx0VW5pdHMpO1xuLyoqXG4gKiBSZWN1cnNpdmUgZGVlcCBzdHlsZSBwYXNzaW5nIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVbaV0gPSBpdGVyYXRlKHByb3AsIHZhbHVlW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJykge1xuICAgICAgZm9yICh2YXIgaW5uZXJQcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlW2lubmVyUHJvcF0gPSBpdGVyYXRlKGlubmVyUHJvcCwgdmFsdWVbaW5uZXJQcm9wXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9pbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFsdWVbX2lubmVyUHJvcF0gPSBpdGVyYXRlKHByb3AgKyBcIi1cIiArIF9pbm5lclByb3AsIHZhbHVlW19pbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHZhciB1bml0ID0gb3B0aW9uc1twcm9wXSB8fCB1bml0c1twcm9wXTtcblxuICAgIGlmICh1bml0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHVuaXQgPT09ICdmdW5jdGlvbicgPyB1bml0KHZhbHVlKS50b1N0cmluZygpIDogXCJcIiArIHZhbHVlICsgdW5pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQWRkIHVuaXQgdG8gbnVtZXJpYyB2YWx1ZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0VW5pdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgY2FtZWxDYXNlZE9wdGlvbnMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihvcHRpb25zKTtcblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHN0eWxlW3Byb3BdID0gaXRlcmF0ZShwcm9wLCBzdHlsZVtwcm9wXSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3ApIHtcbiAgICByZXR1cm4gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0VW5pdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBfZXh0ZW5kcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKSk7XG52YXIganNzID0gcmVxdWlyZSgnanNzJyk7XG5cbnZhciBhdCA9ICdAZ2xvYmFsJztcbnZhciBhdFByZWZpeCA9ICdAZ2xvYmFsICc7XG5cbnZhciBHbG9iYWxDb250YWluZXJSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsQ29udGFpbmVyUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLnJ1bGVzID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IGpzcy5SdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChzZWxlY3Rvciwgc3R5bGVzW3NlbGVjdG9yXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEdsb2JhbENvbnRhaW5lclJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBHbG9iYWxDb250YWluZXJSdWxlO1xufSgpO1xuXG52YXIgR2xvYmFsUHJlZml4ZWRSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsUHJlZml4ZWRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZ2xvYmFsJztcbiAgICB0aGlzLmF0ID0gYXQ7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2VsZWN0b3IgPSBrZXkuc3Vic3RyKGF0UHJlZml4Lmxlbmd0aCk7XG4gICAgdGhpcy5ydWxlID0gb3B0aW9ucy5qc3MuY3JlYXRlUnVsZShzZWxlY3Rvciwgc3R5bGUsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEdsb2JhbFByZWZpeGVkUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlID8gdGhpcy5ydWxlLnRvU3RyaW5nKG9wdGlvbnMpIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbFByZWZpeGVkUnVsZTtcbn0oKTtcblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcblxuZnVuY3Rpb24gYWRkU2NvcGUoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHZhciBwYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gIHZhciBzY29wZWQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2NvcGVkICs9IHNjb3BlICsgXCIgXCIgKyBwYXJ0c1tpXS50cmltKCk7XG4gICAgaWYgKHBhcnRzW2kgKyAxXSkgc2NvcGVkICs9ICcsICc7XG4gIH1cblxuICByZXR1cm4gc2NvcGVkO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUpIHtcbiAgdmFyIG9wdGlvbnMgPSBydWxlLm9wdGlvbnMsXG4gICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gIHZhciBydWxlcyA9IHN0eWxlID8gc3R5bGVbYXRdIDogbnVsbDtcbiAgaWYgKCFydWxlcykgcmV0dXJuO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcnVsZXMpIHtcbiAgICBvcHRpb25zLnNoZWV0LmFkZFJ1bGUobmFtZSwgcnVsZXNbbmFtZV0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3RvcjogYWRkU2NvcGUobmFtZSwgcnVsZS5zZWxlY3RvcilcbiAgICB9KSk7XG4gIH1cblxuICBkZWxldGUgc3R5bGVbYXRdO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgaWYgKHByb3BbMF0gIT09ICdAJyB8fCBwcm9wLnN1YnN0cigwLCBhdC5sZW5ndGgpICE9PSBhdCkgY29udGludWU7XG4gICAgdmFyIHNlbGVjdG9yID0gYWRkU2NvcGUocHJvcC5zdWJzdHIoYXQubGVuZ3RoKSwgcnVsZS5zZWxlY3Rvcik7XG4gICAgb3B0aW9ucy5zaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBzdHlsZVtwcm9wXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgIH0pKTtcbiAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gIH1cbn1cbi8qKlxuICogQ29udmVydCBuZXN0ZWQgcnVsZXMgdG8gc2VwYXJhdGUsIHJlbW92ZSB0aGVtIGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGpzc0dsb2JhbCgpIHtcbiAgZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAobmFtZSA9PT0gYXQpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsQ29udGFpbmVyUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChuYW1lWzBdID09PSAnQCcgJiYgbmFtZS5zdWJzdHIoMCwgYXRQcmVmaXgubGVuZ3RoKSA9PT0gYXRQcmVmaXgpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsUHJlZml4ZWRSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnZ2xvYmFsJyB8fCBwYXJlbnQub3B0aW9ucy5wYXJlbnQgJiYgcGFyZW50Lm9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgIG9wdGlvbnMuc2NvcGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NvcGVkID09PSBmYWxzZSkge1xuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm47XG4gICAgaGFuZGxlTmVzdGVkR2xvYmFsQ29udGFpbmVyUnVsZShydWxlKTtcbiAgICBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uQ3JlYXRlUnVsZTogb25DcmVhdGVSdWxlLFxuICAgIG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGVcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0ganNzR2xvYmFsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIF9leHRlbmRzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpKTtcbnZhciB3YXJuaW5nID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3Rpbnktd2FybmluZycpKTtcblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcbnZhciBwYXJlbnRSZWdFeHAgPSAvJi9nO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcbi8qKlxuICogQ29udmVydCBuZXN0ZWQgcnVsZXMgdG8gc2VwYXJhdGUsIHJlbW92ZSB0aGVtIGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBqc3NOZXN0ZWQoKSB7XG4gIC8vIEdldCBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yICRyZWYgcmVwbGFjZW1lbnQuXG4gIGZ1bmN0aW9uIGdldFJlcGxhY2VSZWYoY29udGFpbmVyLCBzaGVldCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgdmFyIHJ1bGUgPSBjb250YWluZXIuZ2V0UnVsZShrZXkpIHx8IHNoZWV0ICYmIHNoZWV0LmdldFJ1bGUoa2V5KTtcblxuICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgcnVsZSA9IHJ1bGU7XG4gICAgICAgIHJldHVybiBydWxlLnNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBDb3VsZCBub3QgZmluZCB0aGUgcmVmZXJlbmNlZCBydWxlIFxcXCJcIiArIGtleSArIFwiXFxcIiBpbiBcXFwiXCIgKyAoY29udGFpbmVyLm9wdGlvbnMubWV0YSB8fCBjb250YWluZXIudG9TdHJpbmcoKSkgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVBhcmVudFJlZnMobmVzdGVkUHJvcCwgcGFyZW50UHJvcCkge1xuICAgIHZhciBwYXJlbnRTZWxlY3RvcnMgPSBwYXJlbnRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gICAgdmFyIG5lc3RlZFNlbGVjdG9ycyA9IG5lc3RlZFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFNlbGVjdG9yc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXN0ZWRTZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5lc3RlZCA9IG5lc3RlZFNlbGVjdG9yc1tqXTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICcsICc7IC8vIFJlcGxhY2UgYWxsICYgYnkgdGhlIHBhcmVudCBvciBwcmVmaXggJiB3aXRoIHRoZSBwYXJlbnQuXG5cbiAgICAgICAgcmVzdWx0ICs9IG5lc3RlZC5pbmRleE9mKCcmJykgIT09IC0xID8gbmVzdGVkLnJlcGxhY2UocGFyZW50UmVnRXhwLCBwYXJlbnQpIDogcGFyZW50ICsgXCIgXCIgKyBuZXN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMocnVsZSwgY29udGFpbmVyLCBwcmV2T3B0aW9ucykge1xuICAgIC8vIE9wdGlvbnMgaGFzIGJlZW4gYWxyZWFkeSBjcmVhdGVkLCBub3cgd2Ugb25seSBpbmNyZWFzZSBpbmRleC5cbiAgICBpZiAocHJldk9wdGlvbnMpIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJldk9wdGlvbnMsIHtcbiAgICAgIGluZGV4OiBwcmV2T3B0aW9ucy5pbmRleCArIDFcbiAgICB9KTtcbiAgICB2YXIgbmVzdGluZ0xldmVsID0gcnVsZS5vcHRpb25zLm5lc3RpbmdMZXZlbDtcbiAgICBuZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWwgPT09IHVuZGVmaW5lZCA/IDEgOiBuZXN0aW5nTGV2ZWwgKyAxO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgcnVsZS5vcHRpb25zLCB7XG4gICAgICBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCxcbiAgICAgIGluZGV4OiBjb250YWluZXIuaW5kZXhPZihydWxlKSArIDEgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgcGFyZW50IG5hbWUgdG8gYmUgc2V0IG9wdGlvbnMgZm9yIGNobGlkLlxuXG4gICAgfSk7XG5cbiAgICBkZWxldGUgb3B0aW9ucy5uYW1lO1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBjb250YWluZXIgPSBzdHlsZVJ1bGUub3B0aW9ucy5wYXJlbnQ7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgdmFyIHJlcGxhY2VSZWY7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgaXNOZXN0ZWQgPSBwcm9wLmluZGV4T2YoJyYnKSAhPT0gLTE7XG4gICAgICB2YXIgaXNOZXN0ZWRDb25kaXRpb25hbCA9IHByb3BbMF0gPT09ICdAJztcbiAgICAgIGlmICghaXNOZXN0ZWQgJiYgIWlzTmVzdGVkQ29uZGl0aW9uYWwpIGNvbnRpbnVlO1xuICAgICAgb3B0aW9ucyA9IGdldE9wdGlvbnMoc3R5bGVSdWxlLCBjb250YWluZXIsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gcmVwbGFjZVBhcmVudFJlZnMocHJvcCwgc3R5bGVSdWxlLnNlbGVjdG9yKTsgLy8gTGF6aWx5IGNyZWF0ZSB0aGUgcmVmIHJlcGxhY2VyIGZ1bmN0aW9uIGp1c3Qgb25jZSBmb3JcbiAgICAgICAgLy8gYWxsIG5lc3RlZCBydWxlcyB3aXRoaW4gdGhlIHNoZWV0LlxuXG4gICAgICAgIGlmICghcmVwbGFjZVJlZikgcmVwbGFjZVJlZiA9IGdldFJlcGxhY2VSZWYoY29udGFpbmVyLCBzaGVldCk7IC8vIFJlcGxhY2UgYWxsICRyZWZzLlxuXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShyZWZSZWdFeHAsIHJlcGxhY2VSZWYpO1xuICAgICAgICBjb250YWluZXIuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXN0ZWRDb25kaXRpb25hbCkge1xuICAgICAgICAvLyBQbGFjZSBjb25kaXRpb25hbCByaWdodCBhZnRlciB0aGUgcGFyZW50IHJ1bGUgdG8gZW5zdXJlIHJpZ2h0IG9yZGVyaW5nLlxuICAgICAgICBjb250YWluZXIuYWRkUnVsZShwcm9wLCB7fSwgb3B0aW9ucykgLy8gRmxvdyBleHBlY3RzIG1vcmUgb3B0aW9ucyBidXQgdGhleSBhcmVuJ3QgcmVxdWlyZWRcbiAgICAgICAgLy8gQW5kIGZsb3cgZG9lc24ndCBrbm93IHRoaXMgd2lsbCBhbHdheXMgYmUgYSBTdHlsZVJ1bGUgd2hpY2ggaGFzIHRoZSBhZGRSdWxlIG1ldGhvZFxuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIC5hZGRSdWxlKHN0eWxlUnVsZS5rZXksIHN0eWxlW3Byb3BdLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHN0eWxlUnVsZS5zZWxlY3RvclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlXG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGpzc05lc3RlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBTb3J0IHByb3BzIGJ5IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24ganNzUHJvcHNTb3J0KCkge1xuICB2YXIgc29ydCA9IGZ1bmN0aW9uIHNvcnQocHJvcDAsIHByb3AxKSB7XG4gICAgaWYgKHByb3AwLmxlbmd0aCA9PT0gcHJvcDEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcHJvcDAgPiBwcm9wMSA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDAubGVuZ3RoIC0gcHJvcDEubGVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgICB2YXIgbmV3U3R5bGUgPSB7fTtcbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKHN0eWxlKS5zb3J0KHNvcnQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1N0eWxlW3Byb3BzW2ldXSA9IHN0eWxlW3Byb3BzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0ganNzUHJvcHNTb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIHdhcm5pbmcgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgndGlueS13YXJuaW5nJykpO1xudmFyIGpzcyA9IHJlcXVpcmUoJ2pzcycpO1xuXG52YXIgbm93ID0gRGF0ZS5ub3coKTtcbnZhciBmblZhbHVlc05zID0gXCJmblZhbHVlc1wiICsgbm93O1xudmFyIGZuUnVsZU5zID0gXCJmblN0eWxlXCIgKyArK25vdztcbmZ1bmN0aW9uIGZ1bmN0aW9uUGx1Z2luKCkge1xuICByZXR1cm4ge1xuICAgIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVjbCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcnVsZSA9IGpzcy5jcmVhdGVSdWxlKG5hbWUsIHt9LCBvcHRpb25zKTtcbiAgICAgIHJ1bGVbZm5SdWxlTnNdID0gZGVjbDtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGV4dHJhY3QgZnVuY3Rpb24gdmFsdWVzIGZyb20gdGhlIGRlY2xhcmF0aW9uLCBzbyB0aGF0IHdlIGNhbiBrZWVwIGNvcmUgdW5hd2FyZSBvZiB0aGVtLlxuICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGF0IG9ubHkgb25jZS5cbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZXh0cmFjdCBmdW5jdGlvbnMgb24gZWFjaCBzdHlsZSB1cGRhdGUsIHNpbmNlIHRoaXMgY2FuIGhhcHBlbiBvbmx5IG9uY2UuXG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IGZ1bmN0aW9uIHZhbHVlcyBpbnNpZGUgb2YgZnVuY3Rpb24gcnVsZXMuXG4gICAgICBpZiAoZm5WYWx1ZXNOcyBpbiBydWxlIHx8IGZuUnVsZU5zIGluIHJ1bGUpIHJldHVybiBzdHlsZTtcbiAgICAgIHZhciBmblZhbHVlcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgICBmblZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgcnVsZVtmblZhbHVlc05zXSA9IGZuVmFsdWVzO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG4gICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICAgIHZhciBmblJ1bGUgPSBzdHlsZVJ1bGVbZm5SdWxlTnNdOyAvLyBJZiB3ZSBoYXZlIGEgc3R5bGUgZnVuY3Rpb24sIHRoZSBlbnRpcmUgcnVsZSBpcyBkeW5hbWljIGFuZCBzdHlsZSBvYmplY3RcbiAgICAgIC8vIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGF0IGZ1bmN0aW9uLlxuXG4gICAgICBpZiAoZm5SdWxlKSB7XG4gICAgICAgIC8vIEVtcHR5IG9iamVjdCB3aWxsIHJlbW92ZSBhbGwgY3VycmVudGx5IGRlZmluZWQgcHJvcHNcbiAgICAgICAgLy8gaW4gY2FzZSBmdW5jdGlvbiBydWxlIHJldHVybnMgYSBmYWxzeSB2YWx1ZS5cbiAgICAgICAgc3R5bGVSdWxlLnN0eWxlID0gZm5SdWxlKGRhdGEpIHx8IHt9O1xuXG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlUnVsZS5zdHlsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVJ1bGUuc3R5bGVbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBGdW5jdGlvbiB2YWx1ZXMgaW5zaWRlIGZ1bmN0aW9uIHJ1bGVzIGFyZSBub3Qgc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZuVmFsdWVzID0gc3R5bGVSdWxlW2ZuVmFsdWVzTnNdOyAvLyBJZiB3ZSBoYXZlIGEgZm4gdmFsdWVzIG1hcCwgaXQgaXMgYSBydWxlIHdpdGggZnVuY3Rpb24gdmFsdWVzLlxuXG4gICAgICBpZiAoZm5WYWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZm5WYWx1ZXMpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChfcHJvcCwgZm5WYWx1ZXNbX3Byb3BdKGRhdGEpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb25QbHVnaW47XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2ZW5kb3IgPSByZXF1aXJlKCdjc3MtdmVuZG9yJyk7XG52YXIganNzID0gcmVxdWlyZSgnanNzJyk7XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXggdG8gYSBwcm9wZXJ0eSBuYW1lIHdoZW4gbmVlZGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24ganNzVmVuZG9yUHJlZml4ZXIoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICB2YXIgYXRSdWxlID0gcnVsZTtcbiAgICAgIGF0UnVsZS5hdCA9IHZlbmRvci5zdXBwb3J0ZWRLZXlmcmFtZXMoYXRSdWxlLmF0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmaXhTdHlsZShzdHlsZSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgc3R5bGVbcHJvcF0gPSB2YWx1ZS5tYXAocHJlZml4U3R5bGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZVByb3AgPSBmYWxzZTtcbiAgICAgIHZhciBzdXBwb3J0ZWRQcm9wID0gdmVuZG9yLnN1cHBvcnRlZFByb3BlcnR5KHByb3ApO1xuICAgICAgaWYgKHN1cHBvcnRlZFByb3AgJiYgc3VwcG9ydGVkUHJvcCAhPT0gcHJvcCkgY2hhbmdlUHJvcCA9IHRydWU7XG4gICAgICB2YXIgY2hhbmdlVmFsdWUgPSBmYWxzZTtcbiAgICAgIHZhciBzdXBwb3J0ZWRWYWx1ZSA9IHZlbmRvci5zdXBwb3J0ZWRWYWx1ZShzdXBwb3J0ZWRQcm9wLCBqc3MudG9Dc3NWYWx1ZSh2YWx1ZSkpO1xuICAgICAgaWYgKHN1cHBvcnRlZFZhbHVlICYmIHN1cHBvcnRlZFZhbHVlICE9PSB2YWx1ZSkgY2hhbmdlVmFsdWUgPSB0cnVlO1xuXG4gICAgICBpZiAoY2hhbmdlUHJvcCB8fCBjaGFuZ2VWYWx1ZSkge1xuICAgICAgICBpZiAoY2hhbmdlUHJvcCkgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgICBzdHlsZVtzdXBwb3J0ZWRQcm9wIHx8IHByb3BdID0gc3VwcG9ydGVkVmFsdWUgfHwgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgcmV0dXJuIHByZWZpeFN0eWxlKHN0eWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3ApIHtcbiAgICByZXR1cm4gdmVuZG9yLnN1cHBvcnRlZFZhbHVlKHByb3AsIGpzcy50b0Nzc1ZhbHVlKHZhbHVlKSkgfHwgdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGUsXG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLFxuICAgIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWVcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0ganNzVmVuZG9yUHJlZml4ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgX2V4dGVuZHMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJykpO1xudmFyIGlzSW5Ccm93c2VyID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2lzLWluLWJyb3dzZXInKSk7XG52YXIgd2FybmluZyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0aW55LXdhcm5pbmcnKSk7XG52YXIgX2NyZWF0ZUNsYXNzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKSk7XG52YXIgX2luaGVyaXRzTG9vc2UgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlJykpO1xudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnKSk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJykpO1xuXG52YXIgcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGNsb25lU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09IG51bGwgfHwgdHlwZW9mIHN0eWxlICE9PSAnb2JqZWN0JykgcmV0dXJuIHN0eWxlO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHJldHVybiBzdHlsZS5tYXAoY2xvbmVTdHlsZSk7XG4gIGlmIChzdHlsZS5jb25zdHJ1Y3RvciAhPT0gcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IpIHJldHVybiBzdHlsZTtcbiAgdmFyIG5ld1N0eWxlID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgIG5ld1N0eWxlW25hbWVdID0gY2xvbmVTdHlsZShzdHlsZVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcnVsZSBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSAndW5uYW1lZCc7XG4gIH1cblxuICB2YXIganNzID0gb3B0aW9ucy5qc3M7XG4gIHZhciBkZWNsQ29weSA9IGNsb25lU3R5bGUoZGVjbCk7XG4gIHZhciBydWxlID0ganNzLnBsdWdpbnMub25DcmVhdGVSdWxlKG5hbWUsIGRlY2xDb3B5LCBvcHRpb25zKTtcbiAgaWYgKHJ1bGUpIHJldHVybiBydWxlOyAvLyBJdCBpcyBhbiBhdC1ydWxlIGFuZCBpdCBoYXMgbm8gaW5zdGFuY2UuXG5cbiAgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gcnVsZSBcIiArIG5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBqb2luID0gZnVuY3Rpb24gam9pbih2YWx1ZSwgYnkpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBSZW1vdmUgIWltcG9ydGFudCBmcm9tIHRoZSB2YWx1ZSwgaXQgd2lsbCBiZSByZWFkZGVkIGxhdGVyLlxuICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gYnk7XG4gICAgcmVzdWx0ICs9IHZhbHVlW2ldO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnRzIGFycmF5IHZhbHVlcyB0byBzdHJpbmcuXG4gKlxuICogYG1hcmdpbjogW1snNXB4JywgJzEwcHgnXV1gID4gYG1hcmdpbjogNXB4IDEwcHg7YFxuICogYGJvcmRlcjogWycxcHgnLCAnMnB4J11gID4gYGJvcmRlcjogMXB4LCAycHg7YFxuICogYG1hcmdpbjogW1snNXB4JywgJzEwcHgnXSwgJyFpbXBvcnRhbnQnXWAgPiBgbWFyZ2luOiA1cHggMTBweCAhaW1wb3J0YW50O2BcbiAqIGBjb2xvcjogWydyZWQnLCAhaW1wb3J0YW50XWAgPiBgY29sb3I6IHJlZCAhaW1wb3J0YW50O2BcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ3NzVmFsdWUodmFsdWUsIGlnbm9yZUltcG9ydGFudCkge1xuICBpZiAoaWdub3JlSW1wb3J0YW50ID09PSB2b2lkIDApIHtcbiAgICBpZ25vcmVJbXBvcnRhbnQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIGNzc1ZhbHVlID0gJyc7IC8vIFN1cHBvcnQgc3BhY2Ugc2VwYXJhdGVkIHZhbHVlcyB2aWEgYFtbJzVweCcsICcxMHB4J11dYC5cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgICBpZiAoY3NzVmFsdWUpIGNzc1ZhbHVlICs9ICcsICc7XG4gICAgICBjc3NWYWx1ZSArPSBqb2luKHZhbHVlW2ldLCAnICcpO1xuICAgIH1cbiAgfSBlbHNlIGNzc1ZhbHVlID0gam9pbih2YWx1ZSwgJywgJyk7IC8vIEFkZCAhaW1wb3J0YW50LCBiZWNhdXNlIGl0IHdhcyBpZ25vcmVkLlxuXG5cbiAgaWYgKCFpZ25vcmVJbXBvcnRhbnQgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgIGNzc1ZhbHVlICs9ICcgIWltcG9ydGFudCc7XG4gIH1cblxuICByZXR1cm4gY3NzVmFsdWU7XG59XG5cbi8qKlxuICogSW5kZW50IGEgc3RyaW5nLlxuICogaHR0cDovL2pzcGVyZi5jb20vYXJyYXktam9pbi12cy1mb3JcbiAqL1xuZnVuY3Rpb24gaW5kZW50U3RyKHN0ciwgaW5kZW50KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5kZW50OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ICs9ICcgICc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICsgc3RyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFJ1bGUgdG8gQ1NTIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ3NzKHNlbGVjdG9yLCBzdHlsZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAoIXN0eWxlKSByZXR1cm4gcmVzdWx0O1xuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkaW5kZW50ID0gX29wdGlvbnMuaW5kZW50LFxuICAgICAgaW5kZW50ID0gX29wdGlvbnMkaW5kZW50ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkaW5kZW50O1xuICB2YXIgZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzO1xuICBpZiAoc2VsZWN0b3IpIGluZGVudCsrOyAvLyBBcHBseSBmYWxsYmFja3MgZmlyc3QuXG5cbiAgaWYgKGZhbGxiYWNrcykge1xuICAgIC8vIEFycmF5IHN5bnRheCB7ZmFsbGJhY2tzOiBbe3Byb3A6IHZhbHVlfV19XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW2luZGV4XTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmFsbGJhY2tbcHJvcF07XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXCIgKyBpbmRlbnRTdHIocHJvcCArIFwiOiBcIiArIHRvQ3NzVmFsdWUodmFsdWUpICsgXCI7XCIsIGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdCBzeW50YXgge2ZhbGxiYWNrczoge3Byb3A6IHZhbHVlfX1cbiAgICAgIGZvciAodmFyIF9wcm9wIGluIGZhbGxiYWNrcykge1xuICAgICAgICB2YXIgX3ZhbHVlID0gZmFsbGJhY2tzW19wcm9wXTtcblxuICAgICAgICBpZiAoX3ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiXCIgKyBpbmRlbnRTdHIoX3Byb3AgKyBcIjogXCIgKyB0b0Nzc1ZhbHVlKF92YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wMiBpbiBzdHlsZSkge1xuICAgIHZhciBfdmFsdWUyID0gc3R5bGVbX3Byb3AyXTtcblxuICAgIGlmIChfdmFsdWUyICE9IG51bGwgJiYgX3Byb3AyICE9PSAnZmFsbGJhY2tzJykge1xuICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgcmVzdWx0ICs9IFwiXCIgKyBpbmRlbnRTdHIoX3Byb3AyICsgXCI6IFwiICsgdG9Dc3NWYWx1ZShfdmFsdWUyKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgIH1cbiAgfSAvLyBBbGxvdyBlbXB0eSBzdHlsZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIGR5bmFtaWNhbGx5LlxuXG5cbiAgaWYgKCFyZXN1bHQgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSkgcmV0dXJuIHJlc3VsdDsgLy8gV2hlbiBydWxlIGlzIGJlaW5nIHN0cmluZ2lmaWVkIGJlZm9yZSBzZWxlY3RvciB3YXMgZGVmaW5lZC5cblxuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gcmVzdWx0O1xuICBpbmRlbnQtLTtcbiAgaWYgKHJlc3VsdCkgcmVzdWx0ID0gXCJcXG5cIiArIHJlc3VsdCArIFwiXFxuXCI7XG4gIHJldHVybiBpbmRlbnRTdHIoc2VsZWN0b3IgKyBcIiB7XCIgKyByZXN1bHQsIGluZGVudCkgKyBpbmRlbnRTdHIoJ30nLCBpbmRlbnQpO1xufVxuXG52YXIgZXNjYXBlUmVnZXggPSAvKFtbXFxdLiMqJD48K349fF46KCksXCInYFxcc10pL2c7XG52YXIgbmF0aXZlRXNjYXBlID0gdHlwZW9mIENTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgQ1NTLmVzY2FwZTtcbnZhciBlc2NhcGUgPSAoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gbmF0aXZlRXNjYXBlID8gbmF0aXZlRXNjYXBlKHN0cikgOiBzdHIucmVwbGFjZShlc2NhcGVSZWdleCwgJ1xcXFwkMScpO1xufSk7XG5cbnZhciBCYXNlU3R5bGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3N0eWxlJztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRlcmVyID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdmFyIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIGlmIChzaGVldCkgdGhpcy5yZW5kZXJlciA9IHNoZWV0LnJlbmRlcmVyO2Vsc2UgaWYgKFJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQmFzZVN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnByb3AgPSBmdW5jdGlvbiBwcm9wKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgLy8gSXQncyBhIGdldHRlci5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuc3R5bGVbbmFtZV07IC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQuXG5cbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zID8gb3B0aW9ucy5mb3JjZSA6IGZhbHNlO1xuICAgIGlmICghZm9yY2UgJiYgdGhpcy5zdHlsZVtuYW1lXSA9PT0gdmFsdWUpIHJldHVybiB0aGlzO1xuICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMucHJvY2VzcyAhPT0gZmFsc2UpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uQ2hhbmdlVmFsdWUodmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBpc0VtcHR5ID0gbmV3VmFsdWUgPT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gZmFsc2U7XG4gICAgdmFyIGlzRGVmaW5lZCA9IG5hbWUgaW4gdGhpcy5zdHlsZTsgLy8gVmFsdWUgaXMgZW1wdHkgYW5kIHdhc24ndCBkZWZpbmVkIGJlZm9yZS5cblxuICAgIGlmIChpc0VtcHR5ICYmICFpc0RlZmluZWQgJiYgIWZvcmNlKSByZXR1cm4gdGhpczsgLy8gV2UgYXJlIGdvaW5nIHRvIHJlbW92ZSB0aGlzIHZhbHVlLlxuXG4gICAgdmFyIHJlbW92ZSA9IGlzRW1wdHkgJiYgaXNEZWZpbmVkO1xuICAgIGlmIChyZW1vdmUpIGRlbGV0ZSB0aGlzLnN0eWxlW25hbWVdO2Vsc2UgdGhpcy5zdHlsZVtuYW1lXSA9IG5ld1ZhbHVlOyAvLyBSZW5kZXJhYmxlIGlzIGRlZmluZWQgaWYgU3R5bGVTaGVldCBvcHRpb24gYGxpbmtgIGlzIHRydWUuXG5cbiAgICBpZiAodGhpcy5yZW5kZXJhYmxlICYmIHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIGlmIChyZW1vdmUpIHRoaXMucmVuZGVyZXIucmVtb3ZlUHJvcGVydHkodGhpcy5yZW5kZXJhYmxlLCBuYW1lKTtlbHNlIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5yZW5kZXJhYmxlLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQuYXR0YWNoZWQpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gUnVsZSBpcyBub3QgbGlua2VkLiBNaXNzaW5nIHNoZWV0IG9wdGlvbiBcImxpbms6IHRydWVcIi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFzZVN0eWxlUnVsZTtcbn0oKTtcbnZhciBTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0eWxlUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsKHRoaXMsIGtleSwgc3R5bGUsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gdm9pZCAwO1xuICAgIF90aGlzLmlkID0gdm9pZCAwO1xuICAgIF90aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucy5zZWxlY3RvcixcbiAgICAgICAgc2NvcGVkID0gb3B0aW9ucy5zY29wZWQsXG4gICAgICAgIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgZ2VuZXJhdGVJZCA9IG9wdGlvbnMuZ2VuZXJhdGVJZDtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgfSBlbHNlIGlmIChzY29wZWQgIT09IGZhbHNlKSB7XG4gICAgICBfdGhpcy5pZCA9IGdlbmVyYXRlSWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIHNoZWV0KTtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IFwiLlwiICsgZXNjYXBlKF90aGlzLmlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RvciBzdHJpbmcuXG4gICAqIEF0dGVudGlvbjogdXNlIHRoaXMgd2l0aCBjYXV0aW9uLiBNb3N0IGJyb3dzZXJzIGRpZG4ndCBpbXBsZW1lbnRcbiAgICogc2VsZWN0b3JUZXh0IHNldHRlciwgc28gdGhpcyBtYXkgcmVzdWx0IGluIHJlcmVuZGVyaW5nIG9mIGVudGlyZSBTdHlsZSBTaGVldC5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvMiA9IFN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEFwcGx5IHJ1bGUgdG8gYW4gZWxlbWVudCBpbmxpbmUuXG4gICAqL1xuICBfcHJvdG8yLmFwcGx5VG8gPSBmdW5jdGlvbiBhcHBseVRvKHJlbmRlcmFibGUpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICB2YXIganNvbiA9IHRoaXMudG9KU09OKCk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4ganNvbikge1xuICAgICAgICByZW5kZXJlci5zZXRQcm9wZXJ0eShyZW5kZXJhYmxlLCBwcm9wLCBqc29uW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydWxlLlxuICAgKiBGYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIFVzZWZ1bCBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0eWxlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIGpzb25bcHJvcF0gPSB2YWx1ZTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkganNvbltwcm9wXSA9IHRvQ3NzVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5zZWxlY3RvclRleHQsIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVJ1bGUsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gdGhpcy5zZWxlY3RvclRleHQpIHJldHVybjtcbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgICBpZiAoIXJlbmRlcmFibGUgfHwgIXJlbmRlcmVyKSByZXR1cm47XG4gICAgICB2YXIgaGFzQ2hhbmdlZCA9IHJlbmRlcmVyLnNldFNlbGVjdG9yKHJlbmRlcmFibGUsIHNlbGVjdG9yKTsgLy8gSWYgc2VsZWN0b3Igc2V0dGVyIGlzIG5vdCBpbXBsZW1lbnRlZCwgcmVyZW5kZXIgdGhlIHJ1bGUuXG5cbiAgICAgIGlmICghaGFzQ2hhbmdlZCkge1xuICAgICAgICByZW5kZXJlci5yZXBsYWNlUnVsZShyZW5kZXJhYmxlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RvclRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlUnVsZTtcbn0oQmFzZVN0eWxlUnVsZSk7XG52YXIgcGx1Z2luU3R5bGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChuYW1lWzBdID09PSAnQCcgfHwgb3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3R5bGVSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgYXRSZWdFeHAgPSAvQChbXFx3LV0rKS87XG4vKipcbiAqIENvbmRpdGlvbmFsIHJ1bGUgZm9yIEBtZWRpYSwgQHN1cHBvcnRzXG4gKi9cblxudmFyIENvbmRpdGlvbmFsUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb25hbCc7XG4gICAgdGhpcy5hdCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXJ5ID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7IC8vIEtleSBtaWdodCBjb250YWluIGEgdW5pcXVlIHN1ZmZpeCBpbiBjYXNlIHRoZSBgbmFtZWAgcGFzc2VkIGJ5IHVzZXIgd2FzIGR1cGxpY2F0ZS5cblxuICAgIHRoaXMucXVlcnkgPSBvcHRpb25zLm5hbWU7XG4gICAgdmFyIGF0TWF0Y2ggPSBrZXkubWF0Y2goYXRSZWdFeHApO1xuICAgIHRoaXMuYXQgPSBhdE1hdGNoID8gYXRNYXRjaFsxXSA6ICd1bmtub3duJztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBDb25kaXRpb25hbFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5jaGlsZHJlbjtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnkgKyBcIiB7fVwiO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gdGhpcy5xdWVyeSArIFwiIHtcXG5cIiArIGNoaWxkcmVuICsgXCJcXG59XCIgOiAnJztcbiAgfTtcblxuICByZXR1cm4gQ29uZGl0aW9uYWxSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCA9IC9AbWVkaWF8QHN1cHBvcnRzXFxzKy87XG52YXIgcGx1Z2luQ29uZGl0aW9uYWxSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXlSZWdFeHAudGVzdChrZXkpID8gbmV3IENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxID0ge1xuICBpbmRlbnQ6IDEsXG4gIGNoaWxkcmVuOiB0cnVlXG59O1xudmFyIG5hbWVSZWdFeHAgPSAvQGtleWZyYW1lc1xccysoW1xcdy1dKykvO1xuLyoqXG4gKiBSdWxlIGZvciBAa2V5ZnJhbWVzXG4gKi9cblxudmFyIEtleWZyYW1lc1J1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2tleWZyYW1lcyc7XG4gICAgdGhpcy5hdCA9ICdAa2V5ZnJhbWVzJztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJ1bGVzID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lTWF0Y2ggPSBrZXkubWF0Y2gobmFtZVJlZ0V4cCk7XG5cbiAgICBpZiAobmFtZU1hdGNoICYmIG5hbWVNYXRjaFsxXSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZU1hdGNoWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5hbWUgPSAnbm9uYW1lJztcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEJhZCBrZXlmcmFtZXMgbmFtZSBcIiArIGtleSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSB0aGlzLnR5cGUgKyBcIi1cIiArIHRoaXMubmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuICAgIHRoaXMuaWQgPSBzY29wZWQgPT09IGZhbHNlID8gdGhpcy5uYW1lIDogZXNjYXBlKGdlbmVyYXRlSWQodGhpcywgc2hlZXQpKTtcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGZyYW1lcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgZnJhbWVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVzUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDE7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4pIGNoaWxkcmVuID0gXCJcXG5cIiArIGNoaWxkcmVuICsgXCJcXG5cIjtcbiAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHtcIiArIGNoaWxkcmVuICsgXCJ9XCI7XG4gIH07XG5cbiAgcmV0dXJuIEtleWZyYW1lc1J1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDEgPSAvQGtleWZyYW1lc1xccysvO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcblxudmFyIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUgPSBmdW5jdGlvbiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwga2V5ZnJhbWVzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWwucmVwbGFjZShyZWZSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFJlZmVyZW5jZWQga2V5ZnJhbWVzIHJ1bGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZC5cIikgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbi8qKlxuICogUmVwbGFjZSB0aGUgcmVmZXJlbmNlIGZvciBhIGFuaW1hdGlvbiBuYW1lLlxuICovXG5cblxudmFyIHJlcGxhY2VSZWYgPSBmdW5jdGlvbiByZXBsYWNlUmVmKHN0eWxlLCBwcm9wLCBrZXlmcmFtZXMpIHtcbiAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG4gIHZhciByZWZLZXlmcmFtZSA9IGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsdWUsIGtleWZyYW1lcyk7XG5cbiAgaWYgKHJlZktleWZyYW1lICE9PSB2YWx1ZSkge1xuICAgIHN0eWxlW3Byb3BdID0gcmVmS2V5ZnJhbWU7XG4gIH1cbn07XG5cbnZhciBwbHVnaW4gPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleVJlZ0V4cCQxLnRlc3Qoa2V5KSA/IG5ldyBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH0sXG4gIC8vIEFuaW1hdGlvbiBuYW1lIHJlZiByZXBsYWNlci5cbiAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScgfHwgIXNoZWV0KSByZXR1cm4gc3R5bGU7XG4gICAgaWYgKCdhbmltYXRpb24tbmFtZScgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24tbmFtZScsIHNoZWV0LmtleWZyYW1lcyk7XG4gICAgaWYgKCdhbmltYXRpb24nIGluIHN0eWxlKSByZXBsYWNlUmVmKHN0eWxlLCAnYW5pbWF0aW9uJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIG9uQ2hhbmdlVmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsLCBwcm9wLCBydWxlKSB7XG4gICAgdmFyIHNoZWV0ID0gcnVsZS5vcHRpb25zLnNoZWV0O1xuXG4gICAgaWYgKCFzaGVldCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgY2FzZSAnYW5pbWF0aW9uLW5hbWUnOlxuICAgICAgICByZXR1cm4gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWwsIHNoZWV0LmtleWZyYW1lcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgS2V5ZnJhbWVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZVN0eWxlUnVsZSkge1xuICBfaW5oZXJpdHNMb29zZShLZXlmcmFtZVJ1bGUsIF9CYXNlU3R5bGVSdWxlKTtcblxuICBmdW5jdGlvbiBLZXlmcmFtZVJ1bGUoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX0Jhc2VTdHlsZVJ1bGUuY2FsbC5hcHBseShfQmFzZVN0eWxlUnVsZSwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBLZXlmcmFtZVJ1bGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG4gICAgdmFyIG9wdHMgPSBsaW5rID8gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFsbG93RW1wdHk6IHRydWVcbiAgICB9KSA6IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRzKTtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVSdWxlO1xufShCYXNlU3R5bGVSdWxlKTtcbnZhciBwbHVnaW5LZXlmcmFtZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgRm9udEZhY2VSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9udEZhY2VSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZm9udC1mYWNlJztcbiAgICB0aGlzLmF0ID0gJ0Bmb250LWZhY2UnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEZvbnRGYWNlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3R5bGUpKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHIgKz0gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZVtpbmRleF0pO1xuICAgICAgICBpZiAodGhpcy5zdHlsZVtpbmRleCArIDFdKSBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMuYXQsIHRoaXMuc3R5bGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBGb250RmFjZVJ1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDIgPSAvQGZvbnQtZmFjZS87XG52YXIgcGx1Z2luRm9udEZhY2VSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cCQyLnRlc3Qoa2V5KSA/IG5ldyBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgVmlld3BvcnRSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlld3BvcnRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAndmlld3BvcnQnO1xuICAgIHRoaXMuYXQgPSAnQHZpZXdwb3J0JztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBWaWV3cG9ydFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBWaWV3cG9ydFJ1bGU7XG59KCk7XG52YXIgcGx1Z2luVmlld3BvcnRSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleSA9PT0gJ0B2aWV3cG9ydCcgfHwga2V5ID09PSAnQC1tcy12aWV3cG9ydCcgPyBuZXcgVmlld3BvcnRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIFNpbXBsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW1wbGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnc2ltcGxlJztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICB2YXIgX3Byb3RvID0gU2ltcGxlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHIgKz0gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWVbaW5kZXhdICsgXCI7XCI7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWUgKyBcIjtcIjtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlUnVsZTtcbn0oKTtcbnZhciBrZXlzTWFwID0ge1xuICAnQGNoYXJzZXQnOiB0cnVlLFxuICAnQGltcG9ydCc6IHRydWUsXG4gICdAbmFtZXNwYWNlJzogdHJ1ZVxufTtcbnZhciBwbHVnaW5TaW1wbGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleSBpbiBrZXlzTWFwID8gbmV3IFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgcGx1Z2lucyA9IFtwbHVnaW5TdHlsZVJ1bGUsIHBsdWdpbkNvbmRpdGlvbmFsUnVsZSwgcGx1Z2luLCBwbHVnaW5LZXlmcmFtZVJ1bGUsIHBsdWdpbkZvbnRGYWNlUnVsZSwgcGx1Z2luVmlld3BvcnRSdWxlLCBwbHVnaW5TaW1wbGVSdWxlXTtcblxudmFyIGRlZmF1bHRVcGRhdGVPcHRpb25zID0ge1xuICBwcm9jZXNzOiB0cnVlXG59O1xudmFyIGZvcmNlVXBkYXRlT3B0aW9ucyA9IHtcbiAgZm9yY2U6IHRydWUsXG4gIHByb2Nlc3M6IHRydWVcbiAgLyoqXG4gICAqIENvbnRhaW5zIHJ1bGVzIG9iamVjdHMgYW5kIGFsbG93cyBhZGRpbmcvcmVtb3ZpbmcgZXRjLlxuICAgKiBJcyB1c2VkIGZvciBlLmcuIGJ5IGBTdHlsZVNoZWV0YCBvciBgQ29uZGl0aW9uYWxSdWxlYC5cbiAgICovXG5cbn07XG5cbnZhciBSdWxlTGlzdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIFJ1bGVzIHJlZ2lzdHJ5IGZvciBhY2Nlc3MgYnkgLmdldCgpIG1ldGhvZC5cbiAgLy8gSXQgY29udGFpbnMgdGhlIHNhbWUgcnVsZSByZWdpc3RlcmVkIGJ5IG5hbWUgYW5kIGJ5IHNlbGVjdG9yLlxuICAvLyBPcmlnaW5hbCBzdHlsZXMgb2JqZWN0LlxuICAvLyBVc2VkIHRvIGVuc3VyZSBjb3JyZWN0IHJ1bGVzIG9yZGVyLlxuICBmdW5jdGlvbiBSdWxlTGlzdChvcHRpb25zKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLnJhdyA9IHt9O1xuICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNsYXNzZXMgPSBvcHRpb25zLmNsYXNzZXM7XG4gICAgdGhpcy5rZXlmcmFtZXMgPSBvcHRpb25zLmtleWZyYW1lcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLlxuICAgKlxuICAgKiBXaWxsIG5vdCByZW5kZXIgYWZ0ZXIgU3R5bGUgU2hlZXQgd2FzIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBSdWxlTGlzdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBkZWNsLCBydWxlT3B0aW9ucykge1xuICAgIHZhciBfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwYXJlbnQgPSBfdGhpcyRvcHRpb25zLnBhcmVudCxcbiAgICAgICAgc2hlZXQgPSBfdGhpcyRvcHRpb25zLnNoZWV0LFxuICAgICAgICBqc3MgPSBfdGhpcyRvcHRpb25zLmpzcyxcbiAgICAgICAgUmVuZGVyZXIgPSBfdGhpcyRvcHRpb25zLlJlbmRlcmVyLFxuICAgICAgICBnZW5lcmF0ZUlkID0gX3RoaXMkb3B0aW9ucy5nZW5lcmF0ZUlkLFxuICAgICAgICBzY29wZWQgPSBfdGhpcyRvcHRpb25zLnNjb3BlZDtcblxuICAgIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICBzaGVldDogc2hlZXQsXG4gICAgICBqc3M6IGpzcyxcbiAgICAgIFJlbmRlcmVyOiBSZW5kZXJlcixcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQsXG4gICAgICBzY29wZWQ6IHNjb3BlZCxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9LCBydWxlT3B0aW9ucyk7IC8vIFdoZW4gdXNlciB1c2VzIC5jcmVhdGVTdHlsZVNoZWV0KCksIGR1cGxpY2F0ZSBuYW1lcyBhcmUgbm90IHBvc3NpYmxlLCBidXRcbiAgICAvLyBgc2hlZXQuYWRkUnVsZSgpYCBvcGVucyB0aGUgZG9vciBmb3IgYW55IGR1cGxpY2F0ZSBydWxlIG5hbWUuIFdoZW4gdGhpcyBoYXBwZW5zXG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHRoZSBrZXkgdW5pcXVlIHdpdGhpbiB0aGlzIFJ1bGVMaXN0IGluc3RhbmNlIHNjb3BlLlxuXG5cbiAgICB2YXIga2V5ID0gbmFtZTtcblxuICAgIGlmIChuYW1lIGluIHRoaXMucmF3KSB7XG4gICAgICBrZXkgPSBuYW1lICsgXCItZFwiICsgdGhpcy5jb3VudGVyKys7XG4gICAgfSAvLyBXZSBuZWVkIHRvIHNhdmUgdGhlIG9yaWdpbmFsIGRlY2wgYmVmb3JlIGNyZWF0aW5nIHRoZSBydWxlXG4gICAgLy8gYmVjYXVzZSBjYWNoZSBwbHVnaW4gbmVlZHMgdG8gdXNlIGl0IGFzIGEga2V5IHRvIHJldHVybiBhIGNhY2hlZCBydWxlLlxuXG5cbiAgICB0aGlzLnJhd1trZXldID0gZGVjbDtcblxuICAgIGlmIChrZXkgaW4gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAvLyBFLmcuIHJ1bGVzIGluc2lkZSBvZiBAbWVkaWEgY29udGFpbmVyXG4gICAgICBvcHRpb25zLnNlbGVjdG9yID0gXCIuXCIgKyBlc2NhcGUodGhpcy5jbGFzc2VzW2tleV0pO1xuICAgIH1cblxuICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShrZXksIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5yZWdpc3RlcihydWxlKTtcbiAgICB2YXIgaW5kZXggPSBvcHRpb25zLmluZGV4ID09PSB1bmRlZmluZWQgPyB0aGlzLmluZGV4Lmxlbmd0aCA6IG9wdGlvbnMuaW5kZXg7XG4gICAgdGhpcy5pbmRleC5zcGxpY2UoaW5kZXgsIDAsIHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHJ1bGUpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXIocnVsZSk7XG4gICAgZGVsZXRlIHRoaXMucmF3W3J1bGUua2V5XTtcbiAgICB0aGlzLmluZGV4LnNwbGljZSh0aGlzLmluZGV4LmluZGV4T2YocnVsZSksIDEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXguaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogUnVuIGBvblByb2Nlc3NSdWxlKClgIHBsdWdpbnMgb24gZXZlcnkgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgdmFyIHBsdWdpbnMgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnM7IC8vIFdlIG5lZWQgdG8gY2xvbmUgYXJyYXkgYmVjYXVzZSBpZiB3ZSBtb2RpZnkgdGhlIGluZGV4IHNvbWV3aGVyZSBlbHNlIGR1cmluZyBhIGxvb3BcbiAgICAvLyB3ZSBlbmQgdXAgd2l0aCB2ZXJ5IGhhcmQtdG8tdHJhY2stZG93biBzaWRlIGVmZmVjdHMuXG5cbiAgICB0aGlzLmluZGV4LnNsaWNlKDApLmZvckVhY2gocGx1Z2lucy5vblByb2Nlc3NSdWxlLCBwbHVnaW5zKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBydWxlIGluIGAubWFwYCwgYC5jbGFzc2VzYCBhbmQgYC5rZXlmcmFtZXNgIG1hcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIocnVsZSkge1xuICAgIHRoaXMubWFwW3J1bGUua2V5XSA9IHJ1bGU7XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl0gPSBydWxlO1xuICAgICAgaWYgKHJ1bGUuaWQpIHRoaXMuY2xhc3Nlc1tydWxlLmtleV0gPSBydWxlLmlkO1xuICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIEtleWZyYW1lc1J1bGUgJiYgdGhpcy5rZXlmcmFtZXMpIHtcbiAgICAgIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV0gPSBydWxlLmlkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyKHJ1bGUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5rZXldO1xuXG4gICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBTdHlsZVJ1bGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldO1xuICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIEtleWZyYW1lc1J1bGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1tydWxlLm5hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiAodHlwZW9mIChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07IC8vICRGbG93Rml4TWVcblxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB0aGlzLnVwZGF0ZU9uZSh0aGlzLm1hcFtuYW1lXSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB0aGlzLnVwZGF0ZU9uZSh0aGlzLmluZGV4W2luZGV4XSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIHBsdWdpbnMsIHVwZGF0ZSBydWxlIHByb3BzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VXBkYXRlT3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBsdWdpbnMgPSBfdGhpcyRvcHRpb25zMi5qc3MucGx1Z2lucyxcbiAgICAgICAgc2hlZXQgPSBfdGhpcyRvcHRpb25zMi5zaGVldDsgLy8gSXQgaXMgYSBydWxlcyBjb250YWluZXIgbGlrZSBmb3IgZS5nLiBDb25kaXRpb25hbFJ1bGUuXG5cbiAgICBpZiAocnVsZS5ydWxlcyBpbnN0YW5jZW9mIFJ1bGVMaXN0KSB7XG4gICAgICBydWxlLnJ1bGVzLnVwZGF0ZShkYXRhLCBvcHRpb25zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZVJ1bGUuc3R5bGU7XG4gICAgcGx1Z2lucy5vblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7IC8vIFdlIHJlbHkgb24gYSBuZXcgYHN0eWxlYCByZWYgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vay5cblxuICAgIGlmIChvcHRpb25zLnByb2Nlc3MgJiYgc3R5bGUgJiYgc3R5bGUgIT09IHN0eWxlUnVsZS5zdHlsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBydW4gdGhlIHBsdWdpbnMgaW4gY2FzZSBuZXcgYHN0eWxlYCByZWxpZXMgb24gc3ludGF4IHBsdWdpbnMuXG4gICAgICBwbHVnaW5zLm9uUHJvY2Vzc1N0eWxlKHN0eWxlUnVsZS5zdHlsZSwgc3R5bGVSdWxlLCBzaGVldCk7IC8vIFVwZGF0ZSBhbmQgYWRkIHByb3BzLlxuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlUnVsZS5zdHlsZSkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gc3R5bGVSdWxlLnN0eWxlW3Byb3BdO1xuICAgICAgICB2YXIgcHJldlZhbHVlID0gc3R5bGVbcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAobmV4dFZhbHVlICE9PSBwcmV2VmFsdWUpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChwcm9wLCBuZXh0VmFsdWUsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtb3ZlIHByb3BzLlxuXG5cbiAgICAgIGZvciAodmFyIF9wcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHZhciBfbmV4dFZhbHVlID0gc3R5bGVSdWxlLnN0eWxlW19wcm9wXTtcbiAgICAgICAgdmFyIF9wcmV2VmFsdWUgPSBzdHlsZVtfcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAoX25leHRWYWx1ZSA9PSBudWxsICYmIF9uZXh0VmFsdWUgIT09IF9wcmV2VmFsdWUpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChfcHJvcCwgbnVsbCwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuaW5kZXhbaW5kZXhdO1xuICAgICAgdmFyIGNzcyA9IHJ1bGUudG9TdHJpbmcob3B0aW9ucyk7IC8vIE5vIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IHJ1bGUuXG5cbiAgICAgIGlmICghY3NzICYmICFsaW5rKSBjb250aW51ZTtcbiAgICAgIGlmIChzdHIpIHN0ciArPSAnXFxuJztcbiAgICAgIHN0ciArPSBjc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICByZXR1cm4gUnVsZUxpc3Q7XG59KCk7XG5cbnZhciBTdHlsZVNoZWV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXBsb3llZCA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dGFjaGVkID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kZXJlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5xdWV1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIHRoaXMua2V5ZnJhbWVzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNoZWV0OiB0aGlzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAga2V5ZnJhbWVzOiB0aGlzLmtleWZyYW1lc1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuUmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgb3B0aW9ucy5SZW5kZXJlcih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KHRoaXMub3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIHJlbmRlcmFibGUgdG8gdGhlIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0YWNoID0gZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5hdHRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTsgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBiZWNhdXNlIHdlIGNhbid0IHVzZSBpbnNlcnRSdWxlIEFQSSBpZiBzdHlsZSBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZC5cblxuICAgIGlmICghdGhpcy5kZXBsb3llZCkgdGhpcy5kZXBsb3koKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHJlbmRlcmFibGUgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGlmICghdGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGV0YWNoKCk7XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBydWxlIHRvIHRoZSBjdXJyZW50IHN0eWxlc2hlZXQuXG4gICAqIFdpbGwgaW5zZXJ0IGEgcnVsZSBhbHNvIGFmdGVyIHRoZSBzdHlsZXNoZWV0IGhhcyBiZWVuIHJlbmRlcmVkIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlOyAvLyBQbHVnaW5zIGNhbiBjcmVhdGUgcnVsZXMuXG4gICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIHJpZ2h0IG9yZGVyLCB3ZSBuZWVkIHRvIHF1ZXVlIGFsbCBgLmFkZFJ1bGVgIGNhbGxzLFxuICAgIC8vIHdoaWNoIGhhcHBlbiBhZnRlciB0aGUgZmlyc3QgYHJ1bGVzLmFkZCgpYCBjYWxsLlxuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIXF1ZXVlKSB0aGlzLnF1ZXVlID0gW107XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICghdGhpcy5kZXBsb3llZCkgcmV0dXJuIHJ1bGU7IC8vIERvbid0IGluc2VydCBydWxlIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIHN0cmluZ2lmaWVkIHZlcnNpb24geWV0LlxuICAgICAgLy8gSXQgd2lsbCBiZSBpbnNlcnRlZCBhbGwgdG9nZXRoZXIgd2hlbiAuYXR0YWNoIGlzIGNhbGxlZC5cblxuICAgICAgaWYgKHF1ZXVlKSBxdWV1ZS5wdXNoKHJ1bGUpO2Vsc2Uge1xuICAgICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG5cbiAgICAgICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLmZvckVhY2godGhpcy5pbnNlcnRSdWxlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLnF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9IC8vIFdlIGNhbid0IGFkZCBydWxlcyB0byBhIGRldGFjaGVkIHN0eWxlIG5vZGUuXG4gICAgLy8gV2Ugd2lsbCByZWRlcGxveSB0aGUgc2hlZXQgb25jZSB1c2VyIHdpbGwgYXR0YWNoIGl0LlxuXG5cbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBydWxlIGludG8gdGhlIFN0eWxlU2hlZXRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydFJ1bGUocnVsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGFkZCBydWxlcy5cbiAgICogV2lsbCByZW5kZXIgYWxzbyBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGVzID0gZnVuY3Rpb24gYWRkUnVsZXMoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGFkZGVkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmFkZFJ1bGUobmFtZSwgc3R5bGVzW25hbWVdLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSBhZGRlZC5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZSBieSBuYW1lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlIGJ5IG5hbWUuXG4gICAqIFJldHVybnMgYHRydWVgOiBpZiBydWxlIGhhcyBiZWVuIGRlbGV0ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVSdWxlID0gZnVuY3Rpb24gZGVsZXRlUnVsZShuYW1lKSB7XG4gICAgdmFyIHJ1bGUgPSB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgPyBuYW1lIDogdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5ydWxlcy5yZW1vdmUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiBydWxlLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZGVsZXRlUnVsZShydWxlLnJlbmRlcmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95IHB1cmUgQ1NTIHN0cmluZyB0byBhIHJlbmRlcmFibGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXBsb3koKTtcbiAgICB0aGlzLmRlcGxveWVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJHJ1bGVzO1xuXG4gICAgKF90aGlzJHJ1bGVzID0gdGhpcy5ydWxlcykudXBkYXRlLmFwcGx5KF90aGlzJHJ1bGVzLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBzaW5nbGUgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnJ1bGVzLnVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZVNoZWV0O1xufSgpO1xuXG52YXIgUGx1Z2luc1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGx1Z2luc1JlZ2lzdHJ5KCkge1xuICAgIHRoaXMucGx1Z2lucyA9IHtcbiAgICAgIGludGVybmFsOiBbXSxcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgdGhpcy5yZWdpc3RyeSA9IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQbHVnaW5zUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBDYWxsIGBvbkNyZWF0ZVJ1bGVgIGhvb2tzIGFuZCByZXR1cm4gYW4gb2JqZWN0IGlmIHJldHVybmVkIGJ5IGEgaG9vay5cbiAgICovXG4gIF9wcm90by5vbkNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGVbaV0obmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1J1bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NSdWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUuaXNQcm9jZXNzZWQpIHJldHVybjtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlW2ldKHJ1bGUsIHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5zdHlsZSkgdGhpcy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgcnVsZS5pc1Byb2Nlc3NlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1N0eWxlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU3R5bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHJ1bGUuc3R5bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlW2ldKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1NoZWV0YCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU2hlZXQgPSBmdW5jdGlvbiBvblByb2Nlc3NTaGVldChzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldFtpXShzaGVldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblVwZGF0ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25VcGRhdGVbaV0oZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25DaGFuZ2VWYWx1ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uQ2hhbmdlVmFsdWUgPSBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gICAgdmFyIHByb2Nlc3NlZFZhbHVlID0gdmFsdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvY2Vzc2VkVmFsdWUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWVbaV0ocHJvY2Vzc2VkVmFsdWUsIHByb3AsIHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBwbHVnaW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdQbHVnaW4sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBxdWV1ZTogJ2V4dGVybmFsJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMucGx1Z2luc1tvcHRpb25zLnF1ZXVlXTsgLy8gQXZvaWRzIGFwcGx5aW5nIHNhbWUgcGx1Z2luIHR3aWNlLCBhdCBsZWFzdCBiYXNlZCBvbiByZWYuXG5cbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKG5ld1BsdWdpbikgIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGx1Z2lucy5wdXNoKG5ld1BsdWdpbik7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdLmNvbmNhdCh0aGlzLnBsdWdpbnMuZXh0ZXJuYWwsIHRoaXMucGx1Z2lucy5pbnRlcm5hbCkucmVkdWNlKGZ1bmN0aW9uIChyZWdpc3RyeSwgcGx1Z2luKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBsdWdpbikge1xuICAgICAgICBpZiAobmFtZSBpbiByZWdpc3RyeSkge1xuICAgICAgICAgIHJlZ2lzdHJ5W25hbWVdLnB1c2gocGx1Z2luW25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBVbmtub3duIGhvb2sgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgIH0sIHtcbiAgICAgIG9uQ3JlYXRlUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1N0eWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1NoZWV0OiBbXSxcbiAgICAgIG9uQ2hhbmdlVmFsdWU6IFtdLFxuICAgICAgb25VcGRhdGU6IFtdXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdpbnNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBTaGVldHMgcmVnaXN0cnkgdG8gYWNjZXNzIHRoZW0gYWxsIGF0IG9uZSBwbGFjZS5cbiAqL1xudmFyIFNoZWV0c1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c1JlZ2lzdHJ5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc2hlZXQpIHtcbiAgICB2YXIgcmVnaXN0cnkgPSB0aGlzLnJlZ2lzdHJ5O1xuICAgIHZhciBpbmRleCA9IHNoZWV0Lm9wdGlvbnMuaW5kZXg7XG4gICAgaWYgKHJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmluZGV4KSB7XG4gICAgICByZWdpc3RyeS5wdXNoKHNoZWV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZpbmQgYSBwb3NpdGlvbi5cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZ2lzdHJ5W2ldLm9wdGlvbnMuaW5kZXggPiBpbmRleCkge1xuICAgICAgICByZWdpc3RyeS5zcGxpY2UoaSwgMCwgc2hlZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHNoZWV0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5yZWdpc3RyeS5pbmRleE9mKHNoZWV0KTtcbiAgICB0aGlzLnJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgYWxsIGF0dGFjaGVkIHNoZWV0cyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBhdHRhY2hlZCA9IF9yZWYuYXR0YWNoZWQsXG4gICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhdHRhY2hlZFwiXSk7XG5cbiAgICB2YXIgY3NzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMucmVnaXN0cnlbaV07XG5cbiAgICAgIGlmIChhdHRhY2hlZCAhPSBudWxsICYmIHNoZWV0LmF0dGFjaGVkICE9PSBhdHRhY2hlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNzcykgY3NzICs9ICdcXG4nO1xuICAgICAgY3NzICs9IHNoZWV0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBjc3M7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c1JlZ2lzdHJ5LCBbe1xuICAgIGtleTogXCJpbmRleFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoaWdoZXN0IGluZGV4IG51bWJlci5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCA/IDAgOiB0aGlzLnJlZ2lzdHJ5W3RoaXMucmVnaXN0cnkubGVuZ3RoIC0gMV0ub3B0aW9ucy5pbmRleDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzUmVnaXN0cnk7XG59KCk7XG5cbi8qKlxuICogVGhpcyBpcyBhIGdsb2JhbCBzaGVldHMgcmVnaXN0cnkuIE9ubHkgRG9tUmVuZGVyZXIgd2lsbCBhZGQgc2hlZXRzIHRvIGl0LlxuICogT24gdGhlIHNlcnZlciBvbmUgc2hvdWxkIHVzZSBhbiBvd24gU2hlZXRzUmVnaXN0cnkgaW5zdGFuY2UgYW5kIGFkZCB0aGVcbiAqIHNoZWV0cyB0byBpdCwgYmVjYXVzZSB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdG8gY3JlYXRlIGEgbmV3IHJlZ2lzdHJ5IGZvclxuICogZWFjaCByZXF1ZXN0IGluIG9yZGVyIHRvIG5vdCBsZWFrIHNoZWV0cyBhY3Jvc3MgcmVxdWVzdHMuXG4gKi9cblxudmFyIHNoZWV0cyA9IG5ldyBTaGVldHNSZWdpc3RyeSgpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWxUaGlzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG5zID0gJzJmMWFjYzZjM2E2MDZiMDgyZTVlZWY1ZTU0NDE0ZmZiJztcbmlmIChnbG9iYWxUaGlzW25zXSA9PSBudWxsKSBnbG9iYWxUaGlzW25zXSA9IDA7IC8vIEJ1bmRsZSBtYXkgY29udGFpbiBtdWx0aXBsZSBKU1MgdmVyc2lvbnMgYXQgdGhlIHNhbWUgdGltZS4gSW4gb3JkZXIgdG8gaWRlbnRpZnlcbi8vIHRoZSBjdXJyZW50IHZlcnNpb24gd2l0aCBqdXN0IG9uZSBzaG9ydCBudW1iZXIgYW5kIHVzZSBpdCBmb3IgY2xhc3NlcyBnZW5lcmF0aW9uXG4vLyB3ZSB1c2UgYSBjb3VudGVyLiBBbHNvIGl0IGlzIG1vcmUgYWNjdXJhdGUsIGJlY2F1c2UgdXNlciBjYW4gbWFudWFsbHkgcmVldmFsdWF0ZVxuLy8gdGhlIG1vZHVsZS5cblxudmFyIG1vZHVsZUlkID0gZ2xvYmFsVGhpc1tuc10rKztcblxudmFyIG1heFJ1bGVzID0gMWUxMDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGVzIHVuaXF1ZSBjbGFzcyBuYW1lcyBiYXNlZCBvbiBjb3VudGVycy5cbiAqIFdoZW4gbmV3IGdlbmVyYXRvciBmdW5jdGlvbiBpcyBjcmVhdGVkLCBydWxlIGNvdW50ZXIgaXMgcmVzZXRlZC5cbiAqIFdlIG5lZWQgdG8gcmVzZXQgdGhlIHJ1bGUgY291bnRlciBmb3IgU1NSIGZvciBlYWNoIHJlcXVlc3QuXG4gKi9cbnZhciBjcmVhdGVHZW5lcmF0ZUlkID0gZnVuY3Rpb24gY3JlYXRlR2VuZXJhdGVJZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcnVsZUNvdW50ZXIgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKHJ1bGUsIHNoZWV0KSB7XG4gICAgcnVsZUNvdW50ZXIgKz0gMTtcblxuICAgIGlmIChydWxlQ291bnRlciA+IG1heFJ1bGVzKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLiBSdWxlIGNvdW50ZXIgaXMgYXQgXCIgKyBydWxlQ291bnRlciArIFwiLlwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIganNzSWQgPSAnJztcbiAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuanNzLmlkICE9IG51bGwpIHtcbiAgICAgICAganNzSWQgPSBTdHJpbmcoc2hlZXQub3B0aW9ucy5qc3MuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1pbmlmeSkge1xuICAgICAgLy8gVXNpbmcgXCJjXCIgYmVjYXVzZSBhIG51bWJlciBjYW4ndCBiZSB0aGUgZmlyc3QgY2hhciBpbiBhIGNsYXNzIG5hbWUuXG4gICAgICByZXR1cm4gXCJcIiArIChwcmVmaXggfHwgJ2MnKSArIG1vZHVsZUlkICsganNzSWQgKyBydWxlQ291bnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgcnVsZS5rZXkgKyBcIi1cIiArIG1vZHVsZUlkICsgKGpzc0lkID8gXCItXCIgKyBqc3NJZCA6ICcnKSArIFwiLVwiICsgcnVsZUNvdW50ZXI7XG4gIH07XG59O1xuXG4vKipcbiAqIENhY2hlIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCB0aW1lIGEgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICovXG52YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIHZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdmFsdWUpIHZhbHVlID0gZm4oKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuLyoqXG4gKiBHZXQgYSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWUoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICByZXR1cm4gY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5nZXQocHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzc1J1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFNldCBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxuZnVuY3Rpb24gc2V0UHJvcGVydHkoY3NzUnVsZSwgcHJvcCwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY3NzVmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY3NzVmFsdWUgPSB0b0Nzc1ZhbHVlKHZhbHVlLCB0cnVlKTtcblxuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFN1cHBvcnQgQ1NTVE9NLlxuXG5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5zZXQocHJvcCwgY3NzVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5kZWxldGUocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBET01FeGNlcHRpb24gXFxcIlwiICsgZXJyLm1lc3NhZ2UgKyBcIlxcXCIgd2FzIHRocm93bi4gVHJpZWQgdG8gcmVtb3ZlIHByb3BlcnR5IFxcXCJcIiArIHByb3AgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICB9XG59XG4vKipcbiAqIFNldCB0aGUgc2VsZWN0b3IuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rvcihjc3NSdWxlLCBzZWxlY3RvclRleHQpIHtcbiAgY3NzUnVsZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7IC8vIFJldHVybiBmYWxzZSBpZiBzZXR0ZXIgd2FzIG5vdCBzdWNjZXNzZnVsLlxuICAvLyBDdXJyZW50bHkgd29ya3MgaW4gY2hyb21lIG9ubHkuXG5cbiAgcmV0dXJuIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID09PSBzZWxlY3RvclRleHQ7XG59XG4vKipcbiAqIEdldHMgdGhlIGBoZWFkYCBlbGVtZW50IHVwb24gdGhlIGZpcnN0IGNhbGwgYW5kIGNhY2hlcyBpdC5cbiAqIFdlIGFzc3VtZSBpdCBjYW4ndCBiZSBudWxsLlxuICovXG5cblxudmFyIGdldEhlYWQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbn0pO1xuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggYW4gaW5kZXggaGlnaGVyIHRoYW4gdGhlIHBhc3NlZCBvbmUuXG4gKi9cblxuZnVuY3Rpb24gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluZGV4ID4gb3B0aW9ucy5pbmRleCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCB0aGUgaGlnaGVzdCBpbmRleC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IHJlZ2lzdHJ5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG5cbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGEgY29tbWVudCB3aXRoIFwianNzXCIgaW5zaWRlLlxuICovXG5cblxuZnVuY3Rpb24gZmluZENvbW1lbnROb2RlKHRleHQpIHtcbiAgdmFyIGhlYWQgPSBnZXRIZWFkKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGhlYWQuY2hpbGROb2Rlc1tpXTtcblxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBhIG5vZGUgYmVmb3JlIHdoaWNoIHdlIGNhbiBpbnNlcnQgdGhlIHNoZWV0LlxuICovXG5mdW5jdGlvbiBmaW5kUHJldk5vZGUob3B0aW9ucykge1xuICB2YXIgcmVnaXN0cnkgPSBzaGVldHMucmVnaXN0cnk7XG5cbiAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcnkgdG8gaW5zZXJ0IGJlZm9yZSB0aGUgbmV4dCBoaWdoZXIgc2hlZXQuXG4gICAgdmFyIHNoZWV0ID0gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKTtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBzaGVldC5yZW5kZXJlci5lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnRcbiAgICAgIH07XG4gICAgfSAvLyBPdGhlcndpc2UgaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IGF0dGFjaGVkLlxuXG5cbiAgICBzaGVldCA9IGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gVHJ5IHRvIGZpbmQgYSBjb21tZW50IHBsYWNlaG9sZGVyIGlmIHJlZ2lzdHJ5IGlzIGVtcHR5LlxuXG5cbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjb21tZW50ID0gZmluZENvbW1lbnROb2RlKGluc2VydGlvblBvaW50KTtcblxuICAgIGlmIChjb21tZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IGNvbW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogY29tbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9IC8vIElmIHVzZXIgc3BlY2lmaWVzIGFuIGluc2VydGlvbiBwb2ludCBhbmQgaXQgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGRvY3VtZW50IC1cbiAgICAvLyBiYWQgc3BlY2lmaWNpdHkgaXNzdWVzIG1heSBhcHBlYXIuXG5cblxuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEluc2VydGlvbiBwb2ludCBcXFwiXCIgKyBpbnNlcnRpb25Qb2ludCArIFwiXFxcIiBub3QgZm91bmQuXCIpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHRoZSBET00uXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuICB2YXIgbmV4dE5vZGUgPSBmaW5kUHJldk5vZGUob3B0aW9ucyk7XG5cbiAgaWYgKG5leHROb2RlICE9PSBmYWxzZSAmJiBuZXh0Tm9kZS5wYXJlbnQpIHtcbiAgICBuZXh0Tm9kZS5wYXJlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0Tm9kZS5ub2RlKTtcbiAgICByZXR1cm47XG4gIH0gLy8gV29ya3Mgd2l0aCBpZnJhbWVzIGFuZCBhbnkgbm9kZSB0eXBlcy5cblxuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQubm9kZVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDEzMjg3MjgvZm9yY2UtY2FzdGluZy1pbi1mbG93XG4gICAgdmFyIGluc2VydGlvblBvaW50RWxlbWVudCA9IGluc2VydGlvblBvaW50O1xuICAgIHZhciBwYXJlbnROb2RlID0gaW5zZXJ0aW9uUG9pbnRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBpbnNlcnRpb25Qb2ludEVsZW1lbnQubmV4dFNpYmxpbmcpO2Vsc2UgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBJbnNlcnRpb24gcG9pbnQgaXMgbm90IGluIHRoZSBET00uJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbi8qKlxuICogUmVhZCBqc3Mgbm9uY2Ugc2V0dGluZyBmcm9tIHRoZSBwYWdlIGlmIHRoZSB1c2VyIGhhcyBzZXQgaXQuXG4gKi9cblxuXG52YXIgZ2V0Tm9uY2UgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PVwiY3NwLW5vbmNlXCJdJyk7XG4gIHJldHVybiBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSA6IG51bGw7XG59KTtcblxudmFyIF9pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShjb250YWluZXIsIHJ1bGUsIGluZGV4KSB7XG4gIHZhciBtYXhJbmRleCA9IGNvbnRhaW5lci5jc3NSdWxlcy5sZW5ndGg7IC8vIEluIGNhc2UgcHJldmlvdXMgaW5zZXJ0aW9uIGZhaWxzLCBwYXNzZWQgaW5kZXggbWlnaHQgYmUgd3JvbmdcblxuICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA+IG1heEluZGV4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgaW5kZXggPSBtYXhJbmRleDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKCdpbnNlcnRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgIHZhciBjID0gY29udGFpbmVyO1xuICAgICAgYy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICB9IC8vIEtleWZyYW1lcyBydWxlLlxuICAgIGVsc2UgaWYgKCdhcHBlbmRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIF9jID0gY29udGFpbmVyO1xuXG4gICAgICAgIF9jLmFwcGVuZFJ1bGUocnVsZSk7XG4gICAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFwiICsgZXJyLm1lc3NhZ2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIuY3NzUnVsZXNbaW5kZXhdO1xufTtcblxudmFyIGNyZWF0ZVN0eWxlID0gZnVuY3Rpb24gY3JlYXRlU3R5bGUoKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7IC8vIFdpdGhvdXQgaXQsIElFIHdpbGwgaGF2ZSBhIGJyb2tlbiBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgaWYgd2VcbiAgLy8gaW5zZXJ0IHJ1bGVzIGFmdGVyIHdlIGluc2VydCB0aGUgc3R5bGUgdGFnLlxuICAvLyBJdCBzZWVtcyB0byBraWNrLW9mZiB0aGUgc291cmNlIG9yZGVyIHNwZWNpZmljaXR5IGFsZ29yaXRobS5cblxuICBlbC50ZXh0Q29udGVudCA9ICdcXG4nO1xuICByZXR1cm4gZWw7XG59O1xuXG52YXIgRG9tUmVuZGVyZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBIVE1MU3R5bGVFbGVtZW50IG5lZWRzIGZpeGluZyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjY5NlxuICBmdW5jdGlvbiBEb21SZW5kZXJlcihzaGVldCkge1xuICAgIHRoaXMuZ2V0UHJvcGVydHlWYWx1ZSA9IGdldFByb3BlcnR5VmFsdWU7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xuICAgIHRoaXMucmVtb3ZlUHJvcGVydHkgPSByZW1vdmVQcm9wZXJ0eTtcbiAgICB0aGlzLnNldFNlbGVjdG9yID0gc2V0U2VsZWN0b3I7XG4gICAgdGhpcy5lbGVtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuc2hlZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgLy8gVGhlcmUgaXMgbm8gc2hlZXQgd2hlbiB0aGUgcmVuZGVyZXIgaXMgdXNlZCBmcm9tIGEgc3RhbmRhbG9uZSBTdHlsZVJ1bGUuXG4gICAgaWYgKHNoZWV0KSBzaGVldHMuYWRkKHNoZWV0KTtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG5cbiAgICB2YXIgX3JlZiA9IHRoaXMuc2hlZXQgPyB0aGlzLnNoZWV0Lm9wdGlvbnMgOiB7fSxcbiAgICAgICAgbWVkaWEgPSBfcmVmLm1lZGlhLFxuICAgICAgICBtZXRhID0gX3JlZi5tZXRhLFxuICAgICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudCB8fCBjcmVhdGVTdHlsZSgpO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtanNzJywgJycpO1xuICAgIGlmIChtZWRpYSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgaWYgKG1ldGEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWV0YScsIG1ldGEpO1xuICAgIHZhciBub25jZSA9IGdldE5vbmNlKCk7XG4gICAgaWYgKG5vbmNlKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRG9tUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgLy8gSW4gdGhlIGNhc2UgdGhlIGVsZW1lbnQgbm9kZSBpcyBleHRlcm5hbCBhbmQgaXQgaXMgYWxyZWFkeSBpbiB0aGUgRE9NLlxuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSB8fCAhdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgIGluc2VydFN0eWxlKHRoaXMuZWxlbWVudCwgdGhpcy5zaGVldC5vcHRpb25zKTsgLy8gV2hlbiBydWxlcyBhcmUgaW5zZXJ0ZWQgdXNpbmcgYGluc2VydFJ1bGVgIEFQSSwgYWZ0ZXIgYHNoZWV0LmRldGFjaCgpLmF0dGFjaCgpYFxuICAgIC8vIG1vc3QgYnJvd3NlcnMgY3JlYXRlIGEgbmV3IENTU1N0eWxlU2hlZXQsIGV4Y2VwdCBvZiBhbGwgSUVzLlxuXG4gICAgdmFyIGRlcGxveWVkID0gQm9vbGVhbih0aGlzLnNoZWV0ICYmIHRoaXMuc2hlZXQuZGVwbG95ZWQpO1xuXG4gICAgaWYgKHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyAmJiBkZXBsb3llZCkge1xuICAgICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgICB0aGlzLmRlcGxveSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHN0eWxlIGVsZW1lbnQgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgfVxuICAvKipcbiAgICogSW5qZWN0IENTUyBzdHJpbmcgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXBsb3kgPSBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5zaGVldDtcbiAgICBpZiAoIXNoZWV0KSByZXR1cm47XG5cbiAgICBpZiAoc2hlZXQub3B0aW9ucy5saW5rKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGVzKHNoZWV0LnJ1bGVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSBcIlxcblwiICsgc2hlZXQudG9TdHJpbmcoKSArIFwiXFxuXCI7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBSdWxlTGlzdCBpbnRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGVzID0gZnVuY3Rpb24gaW5zZXJ0UnVsZXMocnVsZXMsIG5hdGl2ZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMuaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlcy5pbmRleFtpXSwgaSwgbmF0aXZlUGFyZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBhIHJ1bGUgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCwgbmF0aXZlUGFyZW50KSB7XG4gICAgaWYgKG5hdGl2ZVBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYXRpdmVQYXJlbnQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBydWxlO1xuICAgICAgdmFyIGxhdGVzdE5hdGl2ZVBhcmVudCA9IG5hdGl2ZVBhcmVudDtcblxuICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2NvbmRpdGlvbmFsJyB8fCBydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIHRoZSBjb250YWluZXIgd2l0aG91dCBjaGlsZHJlbiBmaXJzdC5cbiAgICAgICAgbGF0ZXN0TmF0aXZlUGFyZW50ID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBwYXJlbnQudG9TdHJpbmcoe1xuICAgICAgICAgIGNoaWxkcmVuOiBmYWxzZVxuICAgICAgICB9KSwgaW5kZXgpO1xuXG4gICAgICAgIGlmIChsYXRlc3ROYXRpdmVQYXJlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMocGFyZW50LnJ1bGVzLCBsYXRlc3ROYXRpdmVQYXJlbnQpO1xuICAgICAgcmV0dXJuIGxhdGVzdE5hdGl2ZVBhcmVudDtcbiAgICB9IC8vIElFIGtlZXBzIHRoZSBDU1NTdHlsZVNoZWV0IGFmdGVyIHN0eWxlIG5vZGUgaGFzIGJlZW4gcmVhdHRhY2hlZCxcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBgcmVuZGVyYWJsZWAgcmVmZXJlbmNlIHRoZSByaWdodCBzdHlsZSBzaGVldCBhbmQgbm90XG4gICAgLy8gcmVyZW5kZXIgdGhvc2UgcnVsZXMuXG5cblxuICAgIGlmIChydWxlLnJlbmRlcmFibGUgJiYgcnVsZS5yZW5kZXJhYmxlLnBhcmVudFN0eWxlU2hlZXQgPT09IHRoaXMuZWxlbWVudC5zaGVldCkge1xuICAgICAgcmV0dXJuIHJ1bGUucmVuZGVyYWJsZTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZVN0ciA9IHJ1bGUudG9TdHJpbmcoKTtcbiAgICBpZiAoIXJ1bGVTdHIpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBuYXRpdmVSdWxlID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBydWxlU3RyLCBpbmRleCk7XG5cbiAgICBpZiAobmF0aXZlUnVsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSB0cnVlO1xuICAgIHJ1bGUucmVuZGVyYWJsZSA9IG5hdGl2ZVJ1bGU7XG4gICAgcmV0dXJuIG5hdGl2ZVJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGNzc1J1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgQ1NTIFJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKGNzc1J1bGUpIHtcbiAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLmVsZW1lbnQuc2hlZXQuY3NzUnVsZXM7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY3NzUnVsZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoY3NzUnVsZSA9PT0gY3NzUnVsZXNbaW5kZXhdKSByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBDU1MgcnVsZSBhbmQgcmVwbGFjZSB0aGUgZXhpc3Rpbmcgb25lLlxuICAgKlxuICAgKiBPbmx5IHVzZWQgZm9yIHNvbWUgb2xkIGJyb3dzZXJzIGJlY2F1c2UgdGhleSBjYW4ndCBzZXQgYSBzZWxlY3Rvci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShjc3NSdWxlLCBydWxlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmVsZW1lbnQuc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgcnVsZXMgZWxlbWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcbiAgfTtcblxuICByZXR1cm4gRG9tUmVuZGVyZXI7XG59KCk7XG5cbnZhciBpbnN0YW5jZUNvdW50ZXIgPSAwO1xuXG52YXIgSnNzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSnNzKG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gaW5zdGFuY2VDb3VudGVyKys7XG4gICAgdGhpcy52ZXJzaW9uID0gXCIxMC4zLjBcIjtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgUGx1Z2luc1JlZ2lzdHJ5KCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaWQ6IHtcbiAgICAgICAgbWluaWZ5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUdlbmVyYXRlSWQ6IGNyZWF0ZUdlbmVyYXRlSWQsXG4gICAgICBSZW5kZXJlcjogaXNJbkJyb3dzZXIgPyBEb21SZW5kZXJlciA6IG51bGwsXG4gICAgICBwbHVnaW5zOiBbXVxuICAgIH07XG4gICAgdGhpcy5nZW5lcmF0ZUlkID0gY3JlYXRlR2VuZXJhdGVJZCh7XG4gICAgICBtaW5pZnk6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucGx1Z2lucy51c2UocGx1Z2luc1tpXSwge1xuICAgICAgICBxdWV1ZTogJ2ludGVybmFsJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGFyZXMgdmFyaW91cyBvcHRpb25zLCBhcHBsaWVzIHBsdWdpbnMuXG4gICAqIFNob3VsZCBub3QgYmUgdXNlZCB0d2ljZSBvbiB0aGUgc2FtZSBpbnN0YW5jZSwgYmVjYXVzZSB0aGVyZSBpcyBubyBwbHVnaW5zXG4gICAqIGRlZHVwbGljYXRpb24gbG9naWMuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEpzcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldHVwID0gZnVuY3Rpb24gc2V0dXAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCA9IG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlkID0gX2V4dGVuZHMoe30sIHRoaXMub3B0aW9ucy5pZCwgb3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCB8fCBvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSWQgPSB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCh0aGlzLm9wdGlvbnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluc2VydGlvblBvaW50ICE9IG51bGwpIHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgICBpZiAoJ1JlbmRlcmVyJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcblxuXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykgdGhpcy51c2UuYXBwbHkodGhpcywgb3B0aW9ucy5wbHVnaW5zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVN0eWxlU2hlZXQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICBpbmRleCA9IF9vcHRpb25zLmluZGV4O1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGluZGV4ID0gc2hlZXRzLmluZGV4ID09PSAwID8gMCA6IHNoZWV0cy5pbmRleCArIDE7XG4gICAgfVxuXG4gICAgdmFyIHNoZWV0ID0gbmV3IFN0eWxlU2hlZXQoc3R5bGVzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAganNzOiB0aGlzLFxuICAgICAgZ2VuZXJhdGVJZDogb3B0aW9ucy5nZW5lcmF0ZUlkIHx8IHRoaXMuZ2VuZXJhdGVJZCxcbiAgICAgIGluc2VydGlvblBvaW50OiB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQsXG4gICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSkpO1xuICAgIHRoaXMucGx1Z2lucy5vblByb2Nlc3NTaGVldChzaGVldCk7XG4gICAgcmV0dXJuIHNoZWV0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2ggdGhlIFN0eWxlIFNoZWV0IGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZVN0eWxlU2hlZXQgPSBmdW5jdGlvbiByZW1vdmVTdHlsZVNoZWV0KHNoZWV0KSB7XG4gICAgc2hlZXQuZGV0YWNoKCk7XG4gICAgc2hlZXRzLnJlbW92ZShzaGVldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJ1bGUgd2l0aG91dCBhIFN0eWxlIFNoZWV0LlxuICAgKiBbRGVwcmVjYXRlZF0gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBjcmVhdGVSdWxlJDEobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoc3R5bGUgPT09IHZvaWQgMCkge1xuICAgICAgc3R5bGUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIHJ1bGUgd2l0aG91dCBuYW1lIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJ1bGUodW5kZWZpbmVkLCBuYW1lLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVPcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyXG4gICAgfSk7XG5cbiAgICBpZiAoIXJ1bGVPcHRpb25zLmdlbmVyYXRlSWQpIHJ1bGVPcHRpb25zLmdlbmVyYXRlSWQgPSB0aGlzLmdlbmVyYXRlSWQ7XG4gICAgaWYgKCFydWxlT3B0aW9ucy5jbGFzc2VzKSBydWxlT3B0aW9ucy5jbGFzc2VzID0ge307XG4gICAgaWYgKCFydWxlT3B0aW9ucy5rZXlmcmFtZXMpIHJ1bGVPcHRpb25zLmtleWZyYW1lcyA9IHt9O1xuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKG5hbWUsIHN0eWxlLCBydWxlT3B0aW9ucyk7XG5cbiAgICBpZiAocnVsZSkgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHBsdWdpbi4gUGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB3aXRoIGEgcnVsZSBpbnN0YW5jZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIF90aGlzLnBsdWdpbnMudXNlKHBsdWdpbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEpzcztcbn0oKTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhIHN0eWxlcyBvYmplY3Qgd2l0aCBvbmx5IHByb3BzIHRoYXQgY29udGFpbiBmdW5jdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciB0byA9IG51bGw7XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICB0b1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhciBleHRyYWN0ZWQgPSBnZXREeW5hbWljU3R5bGVzKHZhbHVlKTtcblxuICAgICAgaWYgKGV4dHJhY3RlZCkge1xuICAgICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgICB0b1trZXldID0gZXh0cmFjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBTaGVldHNNYW5hZ2VyIGlzIGxpa2UgYSBXZWFrTWFwIHdoaWNoIGlzIGRlc2lnbmVkIHRvIGNvdW50IFN0eWxlU2hlZXRcbiAqIGluc3RhbmNlcyBhbmQgYXR0YWNoL2RldGFjaCBhdXRvbWF0aWNhbGx5LlxuICovXG52YXIgU2hlZXRzTWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c01hbmFnZXIoKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc2hlZXRzID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS5zaGVldDtcbiAgfTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKGtleSwgc2hlZXQpIHtcbiAgICBpZiAodGhpcy5zaGVldHMuaGFzKGtleSkpIHJldHVybjtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICAgIHRoaXMuc2hlZXRzLnNldChrZXksIHtcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIHJlZnM6IDBcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubWFuYWdlID0gZnVuY3Rpb24gbWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkge1xuICAgICAgICBlbnRyeS5zaGVldC5hdHRhY2goKTtcbiAgICAgIH1cblxuICAgICAgZW50cnkucmVmcysrO1xuICAgICAgcmV0dXJuIGVudHJ5LnNoZWV0O1xuICAgIH1cblxuICAgIHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byBtYW5hZ2VcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8udW5tYW5hZ2UgPSBmdW5jdGlvbiB1bm1hbmFnZShrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LnJlZnMgPiAwKSB7XG4gICAgICAgIGVudHJ5LnJlZnMtLTtcbiAgICAgICAgaWYgKGVudHJ5LnJlZnMgPT09IDApIGVudHJ5LnNoZWV0LmRldGFjaCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIlNoZWV0c01hbmFnZXI6IGNhbid0IGZpbmQgc2hlZXQgdG8gdW5tYW5hZ2VcIik7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c01hbmFnZXI7XG59KCk7XG5cbi8qKlxuICogQSBiZXR0ZXIgYWJzdHJhY3Rpb24gb3ZlciBDU1MuXG4gKlxuICogQGNvcHlyaWdodCBPbGVnIElzb25lbiAoU2xvYm9kc2tvaSkgLyBJc29uZW4gMjAxNC1wcmVzZW50XG4gKiBAd2Vic2l0ZSBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3NcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbi8qKlxuICogRXhwb3J0IGEgY29uc3RhbnQgaW5kaWNhdGluZyBpZiB0aGlzIGJyb3dzZXIgaGFzIENTU1RPTSBzdXBwb3J0LlxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxOC8wMy9jc3NvbVxuICovXG52YXIgaGFzQ1NTVE9NU3VwcG9ydCA9IHR5cGVvZiBDU1MgIT09ICd1bmRlZmluZWQnICYmIENTUyAmJiAnbnVtYmVyJyBpbiBDU1M7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSnNzLlxuICovXG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEpzcyhvcHRpb25zKTtcbn07XG4vKipcbiAqIEEgZ2xvYmFsIEpzcyBpbnN0YW5jZS5cbiAqL1xuXG52YXIgaW5kZXggPSBjcmVhdGUoKTtcblxuZXhwb3J0cy5SdWxlTGlzdCA9IFJ1bGVMaXN0O1xuZXhwb3J0cy5TaGVldHNNYW5hZ2VyID0gU2hlZXRzTWFuYWdlcjtcbmV4cG9ydHMuU2hlZXRzUmVnaXN0cnkgPSBTaGVldHNSZWdpc3RyeTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jcmVhdGVHZW5lcmF0ZUlkID0gY3JlYXRlR2VuZXJhdGVJZDtcbmV4cG9ydHMuY3JlYXRlUnVsZSA9IGNyZWF0ZVJ1bGU7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmRleDtcbmV4cG9ydHMuZ2V0RHluYW1pY1N0eWxlcyA9IGdldER5bmFtaWNTdHlsZXM7XG5leHBvcnRzLmhhc0NTU1RPTVN1cHBvcnQgPSBoYXNDU1NUT01TdXBwb3J0O1xuZXhwb3J0cy5zaGVldHMgPSBzaGVldHM7XG5leHBvcnRzLnRvQ3NzVmFsdWUgPSB0b0Nzc1ZhbHVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnN0YW50cy5cbiAqL1xuXG52YXIgZXJyb3JNZXNzYWdlO1xuXG5lcnJvck1lc3NhZ2UgPSAnQW4gYXJndW1lbnQgd2l0aG91dCBhcHBlbmQsIHByZXBlbmQsICcgK1xuICAgICdvciBkZXRhY2ggbWV0aG9kcyB3YXMgZ2l2ZW4gdG8gYExpc3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGlzdDogQSBsaW5rZWQgbGlzdCBpcyBhIGJpdCBsaWtlIGFuIEFycmF5LCBidXRcbiAqIGtub3dzIG5vdGhpbmcgYWJvdXQgaG93IG1hbnkgaXRlbXMgYXJlIGluIGl0LCBhbmQga25vd3Mgb25seSBhYm91dCBpdHNcbiAqIGZpcnN0IChgaGVhZGApIGFuZCBsYXN0IChgdGFpbGApIGl0ZW1zLiBFYWNoIGl0ZW0gKGUuZy4gYGhlYWRgLCBgdGFpbGAsXG4gKiAmYy4pIGtub3dzIHdoaWNoIGl0ZW0gY29tZXMgYmVmb3JlIG9yIGFmdGVyIGl0IChpdHMgbW9yZSBsaWtlIHRoZVxuICogaW1wbGVtZW50YXRpb24gb2YgdGhlIERPTSBpbiBKYXZhU2NyaXB0KS5cbiAqIEBnbG9iYWxcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjbGFzcyBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIExpc3QuXG4gKi9cblxuZnVuY3Rpb24gTGlzdCgvKml0ZW1zLi4uKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gTGlzdC5mcm9tKGFyZ3VtZW50cyk7XG4gICAgfVxufVxuXG52YXIgTGlzdFByb3RvdHlwZTtcblxuTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBmcm9tIHRoZSBhcmd1bWVudHMgKGVhY2ggYSBsaXN0IGl0ZW0pIHBhc3NlZCBpbi5cbiAqIEBuYW1lIExpc3Qub2ZcbiAqIEBwYXJhbSB7Li4uTGlzdEl0ZW19IFtpdGVtc10gLSBaZXJvIG9yIG1vcmUgaXRlbXMgdG8gYXR0YWNoLlxuICogQHJldHVybnMge2xpc3R9IC0gQSBuZXcgaW5zdGFuY2Ugb2YgTGlzdC5cbiAqL1xuXG5MaXN0Lm9mID0gZnVuY3Rpb24gKC8qaXRlbXMuLi4qLykge1xuICAgIHJldHVybiBMaXN0LmZyb20uY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXktbGlrZSBvYmplY3QgKGVhY2ggYSBsaXN0IGl0ZW0pXG4gKiBwYXNzZWQgaW4uXG4gKiBAbmFtZSBMaXN0LmZyb21cbiAqIEBwYXJhbSB7TGlzdEl0ZW1bXX0gW2l0ZW1zXSAtIFRoZSBpdGVtcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7bGlzdH0gLSBBIG5ldyBpbnN0YW5jZSBvZiBMaXN0LlxuICovXG5MaXN0LmZyb20gPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICB2YXIgbGlzdCA9IG5ldyB0aGlzKCksIGxlbmd0aCwgaXRlcmF0b3IsIGl0ZW07XG5cbiAgICBpZiAoaXRlbXMgJiYgKGxlbmd0aCA9IGl0ZW1zLmxlbmd0aCkpIHtcbiAgICAgICAgaXRlcmF0b3IgPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytpdGVyYXRvciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2l0ZXJhdG9yXTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5hcHBlbmQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8qKlxuICogTGlzdCNoZWFkXG4gKiBEZWZhdWx0IHRvIGBudWxsYC5cbiAqL1xuTGlzdFByb3RvdHlwZS5oZWFkID0gbnVsbDtcblxuLyoqXG4gKiBMaXN0I3RhaWxcbiAqIERlZmF1bHQgdG8gYG51bGxgLlxuICovXG5MaXN0UHJvdG90eXBlLnRhaWwgPSBudWxsO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3QncyBpdGVtcyBhcyBhbiBhcnJheS4gVGhpcyBkb2VzICpub3QqIGRldGFjaCB0aGUgaXRlbXMuXG4gKiBAbmFtZSBMaXN0I3RvQXJyYXlcbiAqIEByZXR1cm5zIHtMaXN0SXRlbVtdfSAtIEFuIGFycmF5IG9mIChzdGlsbCBhdHRhY2hlZCkgTGlzdEl0ZW1zLlxuICovXG5MaXN0UHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLmhlYWQsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIGl0ZW0gPSBpdGVtLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJlcGVuZHMgdGhlIGdpdmVuIGl0ZW0gdG8gdGhlIGxpc3Q6IEl0ZW0gd2lsbCBiZSB0aGUgbmV3IGZpcnN0IGl0ZW1cbiAqIChgaGVhZGApLlxuICogQG5hbWUgTGlzdCNwcmVwZW5kXG4gKiBAcGFyYW0ge0xpc3RJdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gcHJlcGVuZC5cbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBBbiBpbnN0YW5jZSBvZiBMaXN0SXRlbSAodGhlIGdpdmVuIGl0ZW0pLlxuICovXG5MaXN0UHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpdGVtLmFwcGVuZCB8fCAhaXRlbS5wcmVwZW5kIHx8ICFpdGVtLmRldGFjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlICsgJyNwcmVwZW5kYC4nKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiwgaGVhZDtcblxuICAgIC8vIENhY2hlIHNlbGYuXG4gICAgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiBzZWxmIGhhcyBhIGZpcnN0IGl0ZW0sIGRlZmVyIHByZXBlbmQgdG8gdGhlIGZpcnN0IGl0ZW1zIHByZXBlbmRcbiAgICAvLyBtZXRob2QsIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICBoZWFkID0gc2VsZi5oZWFkO1xuXG4gICAgaWYgKGhlYWQpIHtcbiAgICAgICAgcmV0dXJuIGhlYWQucHJlcGVuZChpdGVtKTtcbiAgICB9XG5cbiAgICAvLyAuLi5vdGhlcndpc2UsIHRoZXJlIGlzIG5vIGBoZWFkYCAob3IgYHRhaWxgKSBpdGVtIHlldC5cblxuICAgIC8vIERldGFjaCB0aGUgcHJlcGVuZGVlLlxuICAgIGl0ZW0uZGV0YWNoKCk7XG5cbiAgICAvLyBTZXQgdGhlIHByZXBlbmRlZXMgcGFyZW50IGxpc3QgdG8gcmVmZXJlbmNlIHNlbGYuXG4gICAgaXRlbS5saXN0ID0gc2VsZjtcblxuICAgIC8vIFNldCBzZWxmJ3MgZmlyc3QgaXRlbSB0byB0aGUgcHJlcGVuZGVlLCBhbmQgcmV0dXJuIHRoZSBpdGVtLlxuICAgIHNlbGYuaGVhZCA9IGl0ZW07XG5cbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZ2l2ZW4gaXRlbSB0byB0aGUgbGlzdDogSXRlbSB3aWxsIGJlIHRoZSBuZXcgbGFzdCBpdGVtIChgdGFpbGApXG4gKiBpZiB0aGUgbGlzdCBoYWQgYSBmaXJzdCBpdGVtLCBhbmQgaXRzIGZpcnN0IGl0ZW0gKGBoZWFkYCkgb3RoZXJ3aXNlLlxuICogQG5hbWUgTGlzdCNhcHBlbmRcbiAqIEBwYXJhbSB7TGlzdEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7TGlzdEl0ZW19IC0gQW4gaW5zdGFuY2Ugb2YgTGlzdEl0ZW0gKHRoZSBnaXZlbiBpdGVtKS5cbiAqL1xuXG5MaXN0UHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnI2FwcGVuZGAuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYsIGhlYWQsIHRhaWw7XG5cbiAgICAvLyBDYWNoZSBzZWxmLlxuICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSWYgc2VsZiBoYXMgYSBsYXN0IGl0ZW0sIGRlZmVyIGFwcGVuZGluZyB0byB0aGUgbGFzdCBpdGVtcyBhcHBlbmRcbiAgICAvLyBtZXRob2QsIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICB0YWlsID0gc2VsZi50YWlsO1xuXG4gICAgaWYgKHRhaWwpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwuYXBwZW5kKGl0ZW0pO1xuICAgIH1cblxuICAgIC8vIElmIHNlbGYgaGFzIGEgZmlyc3QgaXRlbSwgZGVmZXIgYXBwZW5kaW5nIHRvIHRoZSBmaXJzdCBpdGVtcyBhcHBlbmRcbiAgICAvLyBtZXRob2QsIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICBoZWFkID0gc2VsZi5oZWFkO1xuXG4gICAgaWYgKGhlYWQpIHtcbiAgICAgICAgcmV0dXJuIGhlYWQuYXBwZW5kKGl0ZW0pO1xuICAgIH1cblxuICAgIC8vIC4uLm90aGVyd2lzZSwgdGhlcmUgaXMgbm8gYHRhaWxgIG9yIGBoZWFkYCBpdGVtIHlldC5cblxuICAgIC8vIERldGFjaCB0aGUgYXBwZW5kZWUuXG4gICAgaXRlbS5kZXRhY2goKTtcblxuICAgIC8vIFNldCB0aGUgYXBwZW5kZWVzIHBhcmVudCBsaXN0IHRvIHJlZmVyZW5jZSBzZWxmLlxuICAgIGl0ZW0ubGlzdCA9IHNlbGY7XG5cbiAgICAvLyBTZXQgc2VsZidzIGZpcnN0IGl0ZW0gdG8gdGhlIGFwcGVuZGVlLCBhbmQgcmV0dXJuIHRoZSBpdGVtLlxuICAgIHNlbGYuaGVhZCA9IGl0ZW07XG5cbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMaXN0SXRlbTogQSBsaW5rZWQgbGlzdCBpdGVtIGlzIGEgYml0IGxpa2UgRE9NIG5vZGU6XG4gKiBJdCBrbm93cyBvbmx5IGFib3V0IGl0cyBcInBhcmVudFwiIChgbGlzdGApLCB0aGUgaXRlbSBiZWZvcmUgaXQgKGBwcmV2YCksXG4gKiBhbmQgdGhlIGl0ZW0gYWZ0ZXIgaXQgKGBuZXh0YCkuXG4gKiBAZ2xvYmFsXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAY2xhc3MgUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBMaXN0SXRlbS5cbiAqL1xuXG5mdW5jdGlvbiBMaXN0SXRlbSgpIHt9XG5cbkxpc3QuSXRlbSA9IExpc3RJdGVtO1xuXG52YXIgTGlzdEl0ZW1Qcm90b3R5cGUgPSBMaXN0SXRlbS5wcm90b3R5cGU7XG5cbkxpc3RJdGVtUHJvdG90eXBlLm5leHQgPSBudWxsO1xuXG5MaXN0SXRlbVByb3RvdHlwZS5wcmV2ID0gbnVsbDtcblxuTGlzdEl0ZW1Qcm90b3R5cGUubGlzdCA9IG51bGw7XG5cbi8qKlxuICogRGV0YWNoZXMgdGhlIGl0ZW0gb3BlcmF0ZWQgb24gZnJvbSBpdHMgcGFyZW50IGxpc3QuXG4gKiBAbmFtZSBMaXN0SXRlbSNkZXRhY2hcbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBUaGUgaXRlbSBvcGVyYXRlZCBvbi5cbiAqL1xuTGlzdEl0ZW1Qcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBpdGVtcy5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGxpc3QgPSBzZWxmLmxpc3QsXG4gICAgICAgIHByZXYgPSBzZWxmLnByZXYsXG4gICAgICAgIG5leHQgPSBzZWxmLm5leHQ7XG5cbiAgICAvLyBJZiB0aGUgaXRlbSBpcyBhbHJlYWR5IGRldGFjaGVkLCByZXR1cm4gc2VsZi5cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgc2VsZiBpcyB0aGUgbGFzdCBpdGVtIGluIHRoZSBwYXJlbnQgbGlzdCwgbGluayB0aGUgbGlzdHMgbGFzdCBpdGVtXG4gICAgLy8gdG8gdGhlIHByZXZpb3VzIGl0ZW0uXG4gICAgaWYgKGxpc3QudGFpbCA9PT0gc2VsZikge1xuICAgICAgICBsaXN0LnRhaWwgPSBwcmV2O1xuICAgIH1cblxuICAgIC8vIElmIHNlbGYgaXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBmaXJzdCBpdGVtXG4gICAgLy8gdG8gdGhlIG5leHQgaXRlbS5cbiAgICBpZiAobGlzdC5oZWFkID09PSBzZWxmKSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCB0aGUgbGFzdCBhbmQgZmlyc3QgaXRlbXMgaW4gdGhlIHBhcmVudCBsaXN0IGFyZSB0aGUgc2FtZSxcbiAgICAvLyByZW1vdmUgdGhlIGxpbmsgdG8gdGhlIGxhc3QgaXRlbS5cbiAgICBpZiAobGlzdC50YWlsID09PSBsaXN0LmhlYWQpIHtcbiAgICAgICAgbGlzdC50YWlsID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHByZXZpb3VzIGl0ZW0gZXhpc3RzLCBsaW5rIGl0cyBuZXh0IGl0ZW0gdG8gc2VsZnMgbmV4dCBpdGVtLlxuICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBuZXh0IGl0ZW0gZXhpc3RzLCBsaW5rIGl0cyBwcmV2aW91cyBpdGVtIHRvIHNlbGZzIHByZXZpb3VzIGl0ZW0uXG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgbGlua3MgZnJvbSBzZWxmIHRvIGJvdGggdGhlIG5leHQgYW5kIHByZXZpb3VzIGl0ZW1zLCBhbmQgdG8gdGhlXG4gICAgLy8gcGFyZW50IGxpc3QuXG4gICAgc2VsZi5wcmV2ID0gc2VsZi5uZXh0ID0gc2VsZi5saXN0ID0gbnVsbDtcblxuICAgIC8vIFJldHVybiBzZWxmLlxuICAgIHJldHVybiBzZWxmO1xufTtcblxuLyoqXG4gKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gaXRlbSAqYmVmb3JlKiB0aGUgaXRlbSBvcGVyYXRlZCBvbi5cbiAqIEBuYW1lIExpc3RJdGVtI3ByZXBlbmRcbiAqIEBwYXJhbSB7TGlzdEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBwcmVwZW5kLlxuICogQHJldHVybnMge0xpc3RJdGVtfSAtIFRoZSBpdGVtIG9wZXJhdGVkIG9uLCBvciBmYWxzZSB3aGVuIHRoYXQgaXRlbSBpcyBub3RcbiAqIGF0dGFjaGVkLlxuICovXG5MaXN0SXRlbVByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnSXRlbSNwcmVwZW5kYC4nKTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZSBzZWxmLCB0aGUgcGFyZW50IGxpc3QsIGFuZCB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGxpc3QgPSBzZWxmLmxpc3QsXG4gICAgICAgIHByZXYgPSBzZWxmLnByZXY7XG5cbiAgICAvLyBJZiBzZWxmIGlzIGRldGFjaGVkLCByZXR1cm4gZmFsc2UuXG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBEZXRhY2ggdGhlIHByZXBlbmRlZS5cbiAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgLy8gSWYgc2VsZiBoYXMgYSBwcmV2aW91cyBpdGVtLi4uXG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgLy8gLi4ubGluayB0aGUgcHJlcGVuZGVlcyBwcmV2aW91cyBpdGVtLCB0byBzZWxmcyBwcmV2aW91cyBpdGVtLlxuICAgICAgICBpdGVtLnByZXYgPSBwcmV2O1xuXG4gICAgICAgIC8vIC4uLmxpbmsgdGhlIHByZXZpb3VzIGl0ZW1zIG5leHQgaXRlbSwgdG8gc2VsZi5cbiAgICAgICAgcHJldi5uZXh0ID0gaXRlbTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIHByZXBlbmRlZXMgbmV4dCBpdGVtIHRvIHNlbGYuXG4gICAgaXRlbS5uZXh0ID0gc2VsZjtcblxuICAgIC8vIFNldCB0aGUgcHJlcGVuZGVlcyBwYXJlbnQgbGlzdCB0byBzZWxmcyBwYXJlbnQgbGlzdC5cbiAgICBpdGVtLmxpc3QgPSBsaXN0O1xuXG4gICAgLy8gU2V0IHRoZSBwcmV2aW91cyBpdGVtIG9mIHNlbGYgdG8gdGhlIHByZXBlbmRlZS5cbiAgICBzZWxmLnByZXYgPSBpdGVtO1xuXG4gICAgLy8gSWYgc2VsZiBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgcGFyZW50IGxpc3QsIGxpbmsgdGhlIGxpc3RzIGZpcnN0IGl0ZW1cbiAgICAvLyB0byB0aGUgcHJlcGVuZGVlLlxuICAgIGlmIChzZWxmID09PSBsaXN0LmhlYWQpIHtcbiAgICAgICAgbGlzdC5oZWFkID0gaXRlbTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGhlIHBhcmVudCBsaXN0IGhhcyBubyBsYXN0IGl0ZW0sIGxpbmsgdGhlIGxpc3RzIGxhc3QgaXRlbSB0b1xuICAgIC8vIHNlbGYuXG4gICAgaWYgKCFsaXN0LnRhaWwpIHtcbiAgICAgICAgbGlzdC50YWlsID0gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIHByZXBlbmRlZS5cbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZ2l2ZW4gaXRlbSAqYWZ0ZXIqIHRoZSBpdGVtIG9wZXJhdGVkIG9uLlxuICogQG5hbWUgTGlzdEl0ZW0jYXBwZW5kXG4gKiBAcGFyYW0ge0xpc3RJdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gYXBwZW5kLlxuICogQHJldHVybnMge0xpc3RJdGVtfSAtIFRoZSBpdGVtIG9wZXJhdGVkIG9uLCBvciBmYWxzZSB3aGVuIHRoYXQgaXRlbSBpcyBub3RcbiAqIGF0dGFjaGVkLlxuICovXG5MaXN0SXRlbVByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIC8vIElmIGl0ZW0gaXMgZmFsc2V5LCByZXR1cm4gZmFsc2UuXG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmFwcGVuZCB8fCAhaXRlbS5wcmVwZW5kIHx8ICFpdGVtLmRldGFjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlICsgJ0l0ZW0jYXBwZW5kYC4nKTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZSBzZWxmLCB0aGUgcGFyZW50IGxpc3QsIGFuZCB0aGUgbmV4dCBpdGVtLlxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgICAgbmV4dCA9IHNlbGYubmV4dDtcblxuICAgIC8vIElmIHNlbGYgaXMgZGV0YWNoZWQsIHJldHVybiBmYWxzZS5cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERldGFjaCB0aGUgYXBwZW5kZWUuXG4gICAgaXRlbS5kZXRhY2goKTtcblxuICAgIC8vIElmIHNlbGYgaGFzIGEgbmV4dCBpdGVtLi4uXG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgLy8gLi4ubGluayB0aGUgYXBwZW5kZWVzIG5leHQgaXRlbSwgdG8gc2VsZnMgbmV4dCBpdGVtLlxuICAgICAgICBpdGVtLm5leHQgPSBuZXh0O1xuXG4gICAgICAgIC8vIC4uLmxpbmsgdGhlIG5leHQgaXRlbXMgcHJldmlvdXMgaXRlbSwgdG8gdGhlIGFwcGVuZGVlLlxuICAgICAgICBuZXh0LnByZXYgPSBpdGVtO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgYXBwZW5kZWVzIHByZXZpb3VzIGl0ZW0gdG8gc2VsZi5cbiAgICBpdGVtLnByZXYgPSBzZWxmO1xuXG4gICAgLy8gU2V0IHRoZSBhcHBlbmRlZXMgcGFyZW50IGxpc3QgdG8gc2VsZnMgcGFyZW50IGxpc3QuXG4gICAgaXRlbS5saXN0ID0gbGlzdDtcblxuICAgIC8vIFNldCB0aGUgbmV4dCBpdGVtIG9mIHNlbGYgdG8gdGhlIGFwcGVuZGVlLlxuICAgIHNlbGYubmV4dCA9IGl0ZW07XG5cbiAgICAvLyBJZiB0aGUgdGhlIHBhcmVudCBsaXN0IGhhcyBubyBsYXN0IGl0ZW0gb3IgaWYgc2VsZiBpcyB0aGUgcGFyZW50IGxpc3RzXG4gICAgLy8gbGFzdCBpdGVtLCBsaW5rIHRoZSBsaXN0cyBsYXN0IGl0ZW0gdG8gdGhlIGFwcGVuZGVlLlxuICAgIGlmIChzZWxmID09PSBsaXN0LnRhaWwgfHwgIWxpc3QudGFpbCkge1xuICAgICAgICBsaXN0LnRhaWwgPSBpdGVtO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgYXBwZW5kZWUuXG4gICAgcmV0dXJuIGl0ZW07XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgTGlzdGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX3NvdXJjZS9saW5rZWQtbGlzdC5qcycpO1xuIiwidmFyIG1hcCA9IHJlcXVpcmUoXCIuL21hcFwiKTtcblxudmFyIGdldENvdW50cnlDb2RlID0gZnVuY3Rpb24obG9jYWxlU3RyaW5nKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBsb2NhbGVTdHJpbmcuc3BsaXQoXCJfXCIpO1xuICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzLnBvcCgpO1xuICAgIH1cbiAgICBjb21wb25lbnRzID0gbG9jYWxlU3RyaW5nLnNwbGl0KFwiLVwiKTtcbiAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50cy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVN0cmluZztcbn1cblxuZXhwb3J0cy5nZXRDdXJyZW5jeSA9IGZ1bmN0aW9uKGxvY2FsZSkge1xuICAgIHZhciBjb3VudHJ5Q29kZSA9IGdldENvdW50cnlDb2RlKGxvY2FsZSkudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoY291bnRyeUNvZGUgaW4gbWFwKSB7XG4gICAgICAgIHJldHVybiBtYXBbY291bnRyeUNvZGVdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5nZXRMb2NhbGVzID0gZnVuY3Rpb24oY3VycmVuY3lDb2RlKSB7XG4gICAgY3VycmVuY3lDb2RlID0gY3VycmVuY3lDb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGxvY2FsZXMgPSBbXTtcbiAgICBmb3IgKGNvdW50cnlDb2RlIGluIG1hcCkge1xuICAgICAgICBpZiAobWFwW2NvdW50cnlDb2RlXSA9PT0gY3VycmVuY3lDb2RlKSB7XG4gICAgICAgICAgICBsb2NhbGVzLnB1c2goY291bnRyeUNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzO1xufSIsIi8vIEdlbmVyYXRlZCB1c2luZyBTaG93Q3VycmVuY2llcy5qYXZhXG52YXIgbWFwID0ge1xuQUQ6ICdFVVInLFxuQUU6ICdBRUQnLFxuQUY6ICdBRk4nLFxuQUc6ICdYQ0QnLFxuQUk6ICdYQ0QnLFxuQUw6ICdBTEwnLFxuQU06ICdBTUQnLFxuQU46ICdBTkcnLFxuQU86ICdBT0EnLFxuQVI6ICdBUlMnLFxuQVM6ICdVU0QnLFxuQVQ6ICdFVVInLFxuQVU6ICdBVUQnLFxuQVc6ICdBV0cnLFxuQVg6ICdFVVInLFxuQVo6ICdBWk4nLFxuQkE6ICdCQU0nLFxuQkI6ICdCQkQnLFxuQkQ6ICdCRFQnLFxuQkU6ICdFVVInLFxuQkY6ICdYT0YnLFxuQkc6ICdCR04nLFxuQkg6ICdCSEQnLFxuQkk6ICdCSUYnLFxuQko6ICdYT0YnLFxuQkw6ICdFVVInLFxuQk06ICdCTUQnLFxuQk46ICdCTkQnLFxuQk86ICdCT0InLFxuQlE6ICdVU0QnLFxuQlI6ICdCUkwnLFxuQlM6ICdCU0QnLFxuQlQ6ICdCVE4nLFxuQlY6ICdOT0snLFxuQlc6ICdCV1AnLFxuQlk6ICdCWVInLFxuQlo6ICdCWkQnLFxuQ0E6ICdDQUQnLFxuQ0M6ICdBVUQnLFxuQ0Q6ICdDREYnLFxuQ0Y6ICdYQUYnLFxuQ0c6ICdYQUYnLFxuQ0g6ICdDSEYnLFxuQ0k6ICdYT0YnLFxuQ0s6ICdOWkQnLFxuQ0w6ICdDTFAnLFxuQ006ICdYQUYnLFxuQ046ICdDTlknLFxuQ086ICdDT1AnLFxuQ1I6ICdDUkMnLFxuQ1U6ICdDVVAnLFxuQ1Y6ICdDVkUnLFxuQ1c6ICdBTkcnLFxuQ1g6ICdBVUQnLFxuQ1k6ICdFVVInLFxuQ1o6ICdDWksnLFxuREU6ICdFVVInLFxuREo6ICdESkYnLFxuREs6ICdES0snLFxuRE06ICdYQ0QnLFxuRE86ICdET1AnLFxuRFo6ICdEWkQnLFxuRUM6ICdVU0QnLFxuRUU6ICdFVVInLFxuRUc6ICdFR1AnLFxuRUg6ICdNQUQnLFxuRVI6ICdFUk4nLFxuRVM6ICdFVVInLFxuRVQ6ICdFVEInLFxuRkk6ICdFVVInLFxuRko6ICdGSkQnLFxuRks6ICdGS1AnLFxuRk06ICdVU0QnLFxuRk86ICdES0snLFxuRlI6ICdFVVInLFxuR0E6ICdYQUYnLFxuR0I6ICdHQlAnLFxuR0Q6ICdYQ0QnLFxuR0U6ICdHRUwnLFxuR0Y6ICdFVVInLFxuR0c6ICdHQlAnLFxuR0g6ICdHSFMnLFxuR0k6ICdHSVAnLFxuR0w6ICdES0snLFxuR006ICdHTUQnLFxuR046ICdHTkYnLFxuR1A6ICdFVVInLFxuR1E6ICdYQUYnLFxuR1I6ICdFVVInLFxuR1M6ICdHQlAnLFxuR1Q6ICdHVFEnLFxuR1U6ICdVU0QnLFxuR1c6ICdYT0YnLFxuR1k6ICdHWUQnLFxuSEs6ICdIS0QnLFxuSE06ICdBVUQnLFxuSE46ICdITkwnLFxuSFI6ICdIUksnLFxuSFQ6ICdIVEcnLFxuSFU6ICdIVUYnLFxuSUQ6ICdJRFInLFxuSUU6ICdFVVInLFxuSUw6ICdJTFMnLFxuSU06ICdHQlAnLFxuSU46ICdJTlInLFxuSU86ICdVU0QnLFxuSVE6ICdJUUQnLFxuSVI6ICdJUlInLFxuSVM6ICdJU0snLFxuSVQ6ICdFVVInLFxuSkU6ICdHQlAnLFxuSk06ICdKTUQnLFxuSk86ICdKT0QnLFxuSlA6ICdKUFknLFxuS0U6ICdLRVMnLFxuS0c6ICdLR1MnLFxuS0g6ICdLSFInLFxuS0k6ICdBVUQnLFxuS006ICdLTUYnLFxuS046ICdYQ0QnLFxuS1A6ICdLUFcnLFxuS1I6ICdLUlcnLFxuS1c6ICdLV0QnLFxuS1k6ICdLWUQnLFxuS1o6ICdLWlQnLFxuTEE6ICdMQUsnLFxuTEI6ICdMQlAnLFxuTEM6ICdYQ0QnLFxuTEk6ICdDSEYnLFxuTEs6ICdMS1InLFxuTFI6ICdMUkQnLFxuTFM6ICdMU0wnLFxuTFQ6ICdMVEwnLFxuTFU6ICdFVVInLFxuTFY6ICdMVkwnLFxuTFk6ICdMWUQnLFxuTUE6ICdNQUQnLFxuTUM6ICdFVVInLFxuTUQ6ICdNREwnLFxuTUU6ICdFVVInLFxuTUY6ICdFVVInLFxuTUc6ICdNR0EnLFxuTUg6ICdVU0QnLFxuTUs6ICdNS0QnLFxuTUw6ICdYT0YnLFxuTU06ICdNTUsnLFxuTU46ICdNTlQnLFxuTU86ICdNT1AnLFxuTVA6ICdVU0QnLFxuTVE6ICdFVVInLFxuTVI6ICdNUk8nLFxuTVM6ICdYQ0QnLFxuTVQ6ICdFVVInLFxuTVU6ICdNVVInLFxuTVY6ICdNVlInLFxuTVc6ICdNV0snLFxuTVg6ICdNWE4nLFxuTVk6ICdNWVInLFxuTVo6ICdNWk4nLFxuTkE6ICdOQUQnLFxuTkM6ICdYUEYnLFxuTkU6ICdYT0YnLFxuTkY6ICdBVUQnLFxuTkc6ICdOR04nLFxuTkk6ICdOSU8nLFxuTkw6ICdFVVInLFxuTk86ICdOT0snLFxuTlA6ICdOUFInLFxuTlI6ICdBVUQnLFxuTlU6ICdOWkQnLFxuTlo6ICdOWkQnLFxuT006ICdPTVInLFxuUEE6ICdQQUInLFxuUEU6ICdQRU4nLFxuUEY6ICdYUEYnLFxuUEc6ICdQR0snLFxuUEg6ICdQSFAnLFxuUEs6ICdQS1InLFxuUEw6ICdQTE4nLFxuUE06ICdFVVInLFxuUE46ICdOWkQnLFxuUFI6ICdVU0QnLFxuUFM6ICdJTFMnLFxuUFQ6ICdFVVInLFxuUFc6ICdVU0QnLFxuUFk6ICdQWUcnLFxuUUE6ICdRQVInLFxuUkU6ICdFVVInLFxuUk86ICdST04nLFxuUlM6ICdSU0QnLFxuUlU6ICdSVUInLFxuUlc6ICdSV0YnLFxuU0E6ICdTQVInLFxuU0I6ICdTQkQnLFxuU0M6ICdTQ1InLFxuU0Q6ICdTREcnLFxuU0U6ICdTRUsnLFxuU0c6ICdTR0QnLFxuU0g6ICdTSFAnLFxuU0k6ICdFVVInLFxuU0o6ICdOT0snLFxuU0s6ICdFVVInLFxuU0w6ICdTTEwnLFxuU006ICdFVVInLFxuU046ICdYT0YnLFxuU086ICdTT1MnLFxuU1I6ICdTUkQnLFxuU1Q6ICdTVEQnLFxuU1Y6ICdTVkMnLFxuU1g6ICdBTkcnLFxuU1k6ICdTWVAnLFxuU1o6ICdTWkwnLFxuVEM6ICdVU0QnLFxuVEQ6ICdYQUYnLFxuVEY6ICdFVVInLFxuVEc6ICdYT0YnLFxuVEg6ICdUSEInLFxuVEo6ICdUSlMnLFxuVEs6ICdOWkQnLFxuVEw6ICdVU0QnLFxuVE06ICdUTVQnLFxuVE46ICdUTkQnLFxuVE86ICdUT1AnLFxuVFI6ICdUUlknLFxuVFQ6ICdUVEQnLFxuVFY6ICdBVUQnLFxuVFc6ICdUV0QnLFxuVFo6ICdUWlMnLFxuVUE6ICdVQUgnLFxuVUc6ICdVR1gnLFxuVU06ICdVU0QnLFxuVVM6ICdVU0QnLFxuVVk6ICdVWVUnLFxuVVo6ICdVWlMnLFxuVkE6ICdFVVInLFxuVkM6ICdYQ0QnLFxuVkU6ICdWRUYnLFxuVkc6ICdVU0QnLFxuVkk6ICdVU0QnLFxuVk46ICdWTkQnLFxuVlU6ICdWVVYnLFxuV0Y6ICdYUEYnLFxuV1M6ICdXU1QnLFxuWUU6ICdZRVInLFxuWVQ6ICdFVVInLFxuWkE6ICdaQVInLFxuWk06ICdaTUsnLFxuWlc6ICdaV0wnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcDsiLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlBZ2dyZWdhdG9yO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBZ2dyZWdhdG9yO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChpdGVyYXRlZSkge1xuICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gIH1cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRGlmZmVyZW5jZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gKi9cbmZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU3VtO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyksXG4gICAgY3JlYXRlU2V0ID0gcmVxdWlyZSgnLi9fY3JlYXRlU2V0JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcbiIsInZhciBhcnJheUFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL19hcnJheUFnZ3JlZ2F0b3InKSxcbiAgICBiYXNlQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vX2Jhc2VBZ2dyZWdhdG9yJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBZ2dyZWdhdG9yO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwidmFyIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJ2YXIgYmFzZURpZmZlcmVuY2UgPSByZXF1aXJlKCcuL19iYXNlRGlmZmVyZW5jZScpLFxuICAgIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAqIC8vID0+IFsxXVxuICovXG52YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgIDogW107XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmZXJlbmNlO1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuLyoqXG4gKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlUmVnRXhwO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQm9vbGVhbihudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCb29sZWFuO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOdW1iZXIoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc051bWJlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIGNyZWF0ZUFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL19jcmVhdGVBZ2dyZWdhdG9yJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICovXG52YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbn0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnRpdGlvbjtcbiIsInZhciBiYXNlU3VtID0gcmVxdWlyZSgnLi9fYmFzZVN1bScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy40LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICogLy8gPT4gMjBcbiAqL1xuZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1bTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICogLy8gPT4gWzIsIDFdXG4gKi9cbnZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pb247XG4iLCJ2YXIgbG93ZXJDYXNlID0gcmVxdWlyZSgnbG93ZXItY2FzZScpXG5cbi8qKlxuICogTG93ZXIgY2FzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgbG9jYWxlKSB7XG4gIGlmIChzdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgc3RyID0gU3RyaW5nKHN0cilcblxuICByZXR1cm4gbG93ZXJDYXNlKHN0ci5jaGFyQXQoMCksIGxvY2FsZSkgKyBzdHIuc3Vic3RyKDEpXG59XG4iLCIvKipcbiAqIFNwZWNpYWwgbGFuZ3VhZ2Utc3BlY2lmaWMgb3ZlcnJpZGVzLlxuICpcbiAqIFNvdXJjZTogZnRwOi8vZnRwLnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9TcGVjaWFsQ2FzaW5nLnR4dFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBMQU5HVUFHRVMgPSB7XG4gIHRyOiB7XG4gICAgcmVnZXhwOiAvXFx1MDEzMHxcXHUwMDQ5fFxcdTAwNDlcXHUwMzA3L2csXG4gICAgbWFwOiB7XG4gICAgICAnXFx1MDEzMCc6ICdcXHUwMDY5JyxcbiAgICAgICdcXHUwMDQ5JzogJ1xcdTAxMzEnLFxuICAgICAgJ1xcdTAwNDlcXHUwMzA3JzogJ1xcdTAwNjknXG4gICAgfVxuICB9LFxuICBhejoge1xuICAgIHJlZ2V4cDogL1tcXHUwMTMwXS9nLFxuICAgIG1hcDoge1xuICAgICAgJ1xcdTAxMzAnOiAnXFx1MDA2OScsXG4gICAgICAnXFx1MDA0OSc6ICdcXHUwMTMxJyxcbiAgICAgICdcXHUwMDQ5XFx1MDMwNyc6ICdcXHUwMDY5J1xuICAgIH1cbiAgfSxcbiAgbHQ6IHtcbiAgICByZWdleHA6IC9bXFx1MDA0OVxcdTAwNEFcXHUwMTJFXFx1MDBDQ1xcdTAwQ0RcXHUwMTI4XS9nLFxuICAgIG1hcDoge1xuICAgICAgJ1xcdTAwNDknOiAnXFx1MDA2OVxcdTAzMDcnLFxuICAgICAgJ1xcdTAwNEEnOiAnXFx1MDA2QVxcdTAzMDcnLFxuICAgICAgJ1xcdTAxMkUnOiAnXFx1MDEyRlxcdTAzMDcnLFxuICAgICAgJ1xcdTAwQ0MnOiAnXFx1MDA2OVxcdTAzMDdcXHUwMzAwJyxcbiAgICAgICdcXHUwMENEJzogJ1xcdTAwNjlcXHUwMzA3XFx1MDMwMScsXG4gICAgICAnXFx1MDEyOCc6ICdcXHUwMDY5XFx1MDMwN1xcdTAzMDMnXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTG93ZXJjYXNlIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgbG9jYWxlKSB7XG4gIHZhciBsYW5nID0gTEFOR1VBR0VTW2xvY2FsZV1cblxuICBzdHIgPSBzdHIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cilcblxuICBpZiAobGFuZykge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKGxhbmcucmVnZXhwLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbGFuZy5tYXBbbV0gfSlcbiAgfVxuXG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKVxufVxuIiwiLypcbiAgaHR0cHM6Ly9naXRodWIuY29tL2JhbmtzZWFuIHdyYXBwZWQgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSdzIGNvZGUgaW4gYSBuYW1lc3BhY2VcbiAgc28gaXQncyBiZXR0ZXIgZW5jYXBzdWxhdGVkLiBOb3cgeW91IGNhbiBoYXZlIG11bHRpcGxlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yc1xuICBhbmQgdGhleSB3b24ndCBzdG9tcCBhbGwgb3ZlciBlYWNob3RoZXIncyBzdGF0ZS5cblxuICBJZiB5b3Ugd2FudCB0byB1c2UgdGhpcyBhcyBhIHN1YnN0aXR1dGUgZm9yIE1hdGgucmFuZG9tKCksIHVzZSB0aGUgcmFuZG9tKClcbiAgbWV0aG9kIGxpa2Ugc286XG5cbiAgdmFyIG0gPSBuZXcgTWVyc2VubmVUd2lzdGVyKCk7XG4gIHZhciByYW5kb21OdW1iZXIgPSBtLnJhbmRvbSgpO1xuXG4gIFlvdSBjYW4gYWxzbyBjYWxsIHRoZSBvdGhlciBnZW5yYW5kX3tmb299KCkgbWV0aG9kcyBvbiB0aGUgaW5zdGFuY2UuXG5cbiAgSWYgeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lmaWMgc2VlZCBpbiBvcmRlciB0byBnZXQgYSByZXBlYXRhYmxlIHJhbmRvbVxuICBzZXF1ZW5jZSwgcGFzcyBhbiBpbnRlZ2VyIGludG8gdGhlIGNvbnN0cnVjdG9yOlxuXG4gIHZhciBtID0gbmV3IE1lcnNlbm5lVHdpc3RlcigxMjMpO1xuXG4gIGFuZCB0aGF0IHdpbGwgYWx3YXlzIHByb2R1Y2UgdGhlIHNhbWUgcmFuZG9tIHNlcXVlbmNlLlxuXG4gIFNlYW4gTWNDdWxsb3VnaCAoYmFua3NlYW5AZ21haWwuY29tKVxuKi9cblxuLypcbiAgIEEgQy1wcm9ncmFtIGZvciBNVDE5OTM3LCB3aXRoIGluaXRpYWxpemF0aW9uIGltcHJvdmVkIDIwMDIvMS8yNi5cbiAgIENvZGVkIGJ5IFRha3VqaSBOaXNoaW11cmEgYW5kIE1ha290byBNYXRzdW1vdG8uXG5cbiAgIEJlZm9yZSB1c2luZywgaW5pdGlhbGl6ZSB0aGUgc3RhdGUgYnkgdXNpbmcgaW5pdF9zZWVkKHNlZWQpXG4gICBvciBpbml0X2J5X2FycmF5KGluaXRfa2V5LCBrZXlfbGVuZ3RoKS5cblxuICAgQ29weXJpZ2h0IChDKSAxOTk3IC0gMjAwMiwgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSxcbiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICBhcmUgbWV0OlxuXG4gICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAgMy4gVGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZVxuICAgICAgICBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW5cbiAgICAgICAgcGVybWlzc2lvbi5cblxuICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICAgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gICBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcbiAgIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICAgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gICBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuXG4gICBBbnkgZmVlZGJhY2sgaXMgdmVyeSB3ZWxjb21lLlxuICAgaHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWxcbiAgIGVtYWlsOiBtLW1hdCBAIG1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwIChyZW1vdmUgc3BhY2UpXG4qL1xuXG52YXIgTWVyc2VubmVUd2lzdGVyID0gZnVuY3Rpb24oc2VlZCkge1xuXHRpZiAoc2VlZCA9PSB1bmRlZmluZWQpIHtcblx0XHRzZWVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH1cblxuXHQvKiBQZXJpb2QgcGFyYW1ldGVycyAqL1xuXHR0aGlzLk4gPSA2MjQ7XG5cdHRoaXMuTSA9IDM5Nztcblx0dGhpcy5NQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cblx0dGhpcy5VUFBFUl9NQVNLID0gMHg4MDAwMDAwMDsgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuXHR0aGlzLkxPV0VSX01BU0sgPSAweDdmZmZmZmZmOyAvKiBsZWFzdCBzaWduaWZpY2FudCByIGJpdHMgKi9cblxuXHR0aGlzLm10ID0gbmV3IEFycmF5KHRoaXMuTik7IC8qIHRoZSBhcnJheSBmb3IgdGhlIHN0YXRlIHZlY3RvciAqL1xuXHR0aGlzLm10aT10aGlzLk4rMTsgLyogbXRpPT1OKzEgbWVhbnMgbXRbTl0gaXMgbm90IGluaXRpYWxpemVkICovXG5cblx0aWYgKHNlZWQuY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcblx0XHR0aGlzLmluaXRfYnlfYXJyYXkoc2VlZCwgc2VlZC5sZW5ndGgpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHRoaXMuaW5pdF9zZWVkKHNlZWQpO1xuXHR9XG59XG5cbi8qIGluaXRpYWxpemVzIG10W05dIHdpdGggYSBzZWVkICovXG4vKiBvcmlnaW4gbmFtZSBpbml0X2dlbnJhbmQgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUuaW5pdF9zZWVkID0gZnVuY3Rpb24ocykge1xuXHR0aGlzLm10WzBdID0gcyA+Pj4gMDtcblx0Zm9yICh0aGlzLm10aT0xOyB0aGlzLm10aTx0aGlzLk47IHRoaXMubXRpKyspIHtcblx0XHR2YXIgcyA9IHRoaXMubXRbdGhpcy5tdGktMV0gXiAodGhpcy5tdFt0aGlzLm10aS0xXSA+Pj4gMzApO1xuXHRcdHRoaXMubXRbdGhpcy5tdGldID0gKCgoKChzICYgMHhmZmZmMDAwMCkgPj4+IDE2KSAqIDE4MTI0MzMyNTMpIDw8IDE2KSArIChzICYgMHgwMDAwZmZmZikgKiAxODEyNDMzMjUzKVxuXHRcdCsgdGhpcy5tdGk7XG5cdFx0LyogU2VlIEtudXRoIFRBT0NQIFZvbDIuIDNyZCBFZC4gUC4xMDYgZm9yIG11bHRpcGxpZXIuICovXG5cdFx0LyogSW4gdGhlIHByZXZpb3VzIHZlcnNpb25zLCBNU0JzIG9mIHRoZSBzZWVkIGFmZmVjdCAgICovXG5cdFx0Lyogb25seSBNU0JzIG9mIHRoZSBhcnJheSBtdFtdLiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFx0LyogMjAwMi8wMS8wOSBtb2RpZmllZCBieSBNYWtvdG8gTWF0c3Vtb3RvICAgICAgICAgICAgICovXG5cdFx0dGhpcy5tdFt0aGlzLm10aV0gPj4+PSAwO1xuXHRcdC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXG5cdH1cbn1cblxuLyogaW5pdGlhbGl6ZSBieSBhbiBhcnJheSB3aXRoIGFycmF5LWxlbmd0aCAqL1xuLyogaW5pdF9rZXkgaXMgdGhlIGFycmF5IGZvciBpbml0aWFsaXppbmcga2V5cyAqL1xuLyoga2V5X2xlbmd0aCBpcyBpdHMgbGVuZ3RoICovXG4vKiBzbGlnaHQgY2hhbmdlIGZvciBDKyssIDIwMDQvMi8yNiAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5pbml0X2J5X2FycmF5ID0gZnVuY3Rpb24oaW5pdF9rZXksIGtleV9sZW5ndGgpIHtcblx0dmFyIGksIGosIGs7XG5cdHRoaXMuaW5pdF9zZWVkKDE5NjUwMjE4KTtcblx0aT0xOyBqPTA7XG5cdGsgPSAodGhpcy5OPmtleV9sZW5ndGggPyB0aGlzLk4gOiBrZXlfbGVuZ3RoKTtcblx0Zm9yICg7IGs7IGstLSkge1xuXHRcdHZhciBzID0gdGhpcy5tdFtpLTFdIF4gKHRoaXMubXRbaS0xXSA+Pj4gMzApXG5cdFx0dGhpcy5tdFtpXSA9ICh0aGlzLm10W2ldIF4gKCgoKChzICYgMHhmZmZmMDAwMCkgPj4+IDE2KSAqIDE2NjQ1MjUpIDw8IDE2KSArICgocyAmIDB4MDAwMGZmZmYpICogMTY2NDUyNSkpKVxuXHRcdCsgaW5pdF9rZXlbal0gKyBqOyAvKiBub24gbGluZWFyICovXG5cdFx0dGhpcy5tdFtpXSA+Pj49IDA7IC8qIGZvciBXT1JEU0laRSA+IDMyIG1hY2hpbmVzICovXG5cdFx0aSsrOyBqKys7XG5cdFx0aWYgKGk+PXRoaXMuTikgeyB0aGlzLm10WzBdID0gdGhpcy5tdFt0aGlzLk4tMV07IGk9MTsgfVxuXHRcdGlmIChqPj1rZXlfbGVuZ3RoKSBqPTA7XG5cdH1cblx0Zm9yIChrPXRoaXMuTi0xOyBrOyBrLS0pIHtcblx0XHR2YXIgcyA9IHRoaXMubXRbaS0xXSBeICh0aGlzLm10W2ktMV0gPj4+IDMwKTtcblx0XHR0aGlzLm10W2ldID0gKHRoaXMubXRbaV0gXiAoKCgoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpICogMTU2NjA4Mzk0MSkgPDwgMTYpICsgKHMgJiAweDAwMDBmZmZmKSAqIDE1NjYwODM5NDEpKVxuXHRcdC0gaTsgLyogbm9uIGxpbmVhciAqL1xuXHRcdHRoaXMubXRbaV0gPj4+PSAwOyAvKiBmb3IgV09SRFNJWkUgPiAzMiBtYWNoaW5lcyAqL1xuXHRcdGkrKztcblx0XHRpZiAoaT49dGhpcy5OKSB7IHRoaXMubXRbMF0gPSB0aGlzLm10W3RoaXMuTi0xXTsgaT0xOyB9XG5cdH1cblxuXHR0aGlzLm10WzBdID0gMHg4MDAwMDAwMDsgLyogTVNCIGlzIDE7IGFzc3VyaW5nIG5vbi16ZXJvIGluaXRpYWwgYXJyYXkgKi9cbn1cblxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweGZmZmZmZmZmXS1pbnRlcnZhbCAqL1xuLyogb3JpZ2luIG5hbWUgZ2VucmFuZF9pbnQzMiAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5yYW5kb21faW50ID0gZnVuY3Rpb24oKSB7XG5cdHZhciB5O1xuXHR2YXIgbWFnMDEgPSBuZXcgQXJyYXkoMHgwLCB0aGlzLk1BVFJJWF9BKTtcblx0LyogbWFnMDFbeF0gPSB4ICogTUFUUklYX0EgIGZvciB4PTAsMSAqL1xuXG5cdGlmICh0aGlzLm10aSA+PSB0aGlzLk4pIHsgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xuXHRcdHZhciBraztcblxuXHRcdGlmICh0aGlzLm10aSA9PSB0aGlzLk4rMSkgIC8qIGlmIGluaXRfc2VlZCgpIGhhcyBub3QgYmVlbiBjYWxsZWQsICovXG5cdFx0XHR0aGlzLmluaXRfc2VlZCg1NDg5KTsgIC8qIGEgZGVmYXVsdCBpbml0aWFsIHNlZWQgaXMgdXNlZCAqL1xuXG5cdFx0Zm9yIChraz0wO2trPHRoaXMuTi10aGlzLk07a2srKykge1xuXHRcdFx0eSA9ICh0aGlzLm10W2trXSZ0aGlzLlVQUEVSX01BU0spfCh0aGlzLm10W2trKzFdJnRoaXMuTE9XRVJfTUFTSyk7XG5cdFx0XHR0aGlzLm10W2trXSA9IHRoaXMubXRba2srdGhpcy5NXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXHRcdH1cblx0XHRmb3IgKDtrazx0aGlzLk4tMTtraysrKSB7XG5cdFx0XHR5ID0gKHRoaXMubXRba2tdJnRoaXMuVVBQRVJfTUFTSyl8KHRoaXMubXRba2srMV0mdGhpcy5MT1dFUl9NQVNLKTtcblx0XHRcdHRoaXMubXRba2tdID0gdGhpcy5tdFtraysodGhpcy5NLXRoaXMuTildIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG5cdFx0fVxuXHRcdHkgPSAodGhpcy5tdFt0aGlzLk4tMV0mdGhpcy5VUFBFUl9NQVNLKXwodGhpcy5tdFswXSZ0aGlzLkxPV0VSX01BU0spO1xuXHRcdHRoaXMubXRbdGhpcy5OLTFdID0gdGhpcy5tdFt0aGlzLk0tMV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcblxuXHRcdHRoaXMubXRpID0gMDtcblx0fVxuXG5cdHkgPSB0aGlzLm10W3RoaXMubXRpKytdO1xuXG5cdC8qIFRlbXBlcmluZyAqL1xuXHR5IF49ICh5ID4+PiAxMSk7XG5cdHkgXj0gKHkgPDwgNykgJiAweDlkMmM1NjgwO1xuXHR5IF49ICh5IDw8IDE1KSAmIDB4ZWZjNjAwMDA7XG5cdHkgXj0gKHkgPj4+IDE4KTtcblxuXHRyZXR1cm4geSA+Pj4gMDtcbn1cblxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweDdmZmZmZmZmXS1pbnRlcnZhbCAqL1xuLyogb3JpZ2luIG5hbWUgZ2VucmFuZF9pbnQzMSAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5yYW5kb21faW50MzEgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICh0aGlzLnJhbmRvbV9pbnQoKT4+PjEpO1xufVxuXG4vKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDFdLXJlYWwtaW50ZXJ2YWwgKi9cbi8qIG9yaWdpbiBuYW1lIGdlbnJhbmRfcmVhbDEgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tX2luY2wgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucmFuZG9tX2ludCgpKigxLjAvNDI5NDk2NzI5NS4wKTtcblx0LyogZGl2aWRlZCBieSAyXjMyLTEgKi9cbn1cblxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKS1yZWFsLWludGVydmFsICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnJhbmRvbSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5yYW5kb21faW50KCkqKDEuMC80Mjk0OTY3Mjk2LjApO1xuXHQvKiBkaXZpZGVkIGJ5IDJeMzIgKi9cbn1cblxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiAoMCwxKS1yZWFsLWludGVydmFsICovXG4vKiBvcmlnaW4gbmFtZSBnZW5yYW5kX3JlYWwzICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnJhbmRvbV9leGNsID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAodGhpcy5yYW5kb21faW50KCkgKyAwLjUpKigxLjAvNDI5NDk2NzI5Ni4wKTtcblx0LyogZGl2aWRlZCBieSAyXjMyICovXG59XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMSkgd2l0aCA1My1iaXQgcmVzb2x1dGlvbiovXG4vKiBvcmlnaW4gbmFtZSBnZW5yYW5kX3JlczUzICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnJhbmRvbV9sb25nID0gZnVuY3Rpb24oKSB7XG5cdHZhciBhPXRoaXMucmFuZG9tX2ludCgpPj4+NSwgYj10aGlzLnJhbmRvbV9pbnQoKT4+PjY7XG5cdHJldHVybihhKjY3MTA4ODY0LjArYikqKDEuMC85MDA3MTk5MjU0NzQwOTkyLjApO1xufVxuXG4vKiBUaGVzZSByZWFsIHZlcnNpb25zIGFyZSBkdWUgdG8gSXNha3UgV2FkYSwgMjAwMi8wMS8wOSBhZGRlZCAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lcnNlbm5lVHdpc3RlcjtcbiIsIid1c2Ugc3RyaWN0JztmdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQoZSl7cmV0dXJuKGUmJih0eXBlb2YgZT09PSdvYmplY3QnKSYmJ2RlZmF1bHQnaW4gZSk/ZVsnZGVmYXVsdCddOmV9dmFyIFJlYWN0PXJlcXVpcmUoJ3JlYWN0JyksUmVhY3RfX2RlZmF1bHQ9X2ludGVyb3BEZWZhdWx0KFJlYWN0KSxfaW5oZXJpdHNMb29zZT1faW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlJykpLFByb3BUeXBlcz1faW50ZXJvcERlZmF1bHQocmVxdWlyZSgncHJvcC10eXBlcycpKSxndWQ9X2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2d1ZCcpKSx3YXJuaW5nPV9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0aW55LXdhcm5pbmcnKSk7dmFyIE1BWF9TSUdORURfMzFfQklUX0lOVCA9IDEwNzM3NDE4MjM7XG5cbmZ1bmN0aW9uIG9iamVjdElzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEVtaXR0ZXIodmFsdWUpIHtcbiAgdmFyIGhhbmRsZXJzID0gW107XG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uIG9uKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gaCAhPT0gaGFuZGxlcjtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSwgY2hhbmdlZEJpdHMpIHtcbiAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKHZhbHVlLCBjaGFuZ2VkQml0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZWFjdENvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICB2YXIgX1Byb3ZpZGVyJGNoaWxkQ29udGV4LCBfQ29uc3VtZXIkY29udGV4dFR5cGU7XG5cbiAgdmFyIGNvbnRleHRQcm9wID0gJ19fY3JlYXRlLXJlYWN0LWNvbnRleHQtJyArIGd1ZCgpICsgJ19fJztcblxuICB2YXIgUHJvdmlkZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUHJvdmlkZXIoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5lbWl0dGVyID0gY3JlYXRlRXZlbnRFbWl0dGVyKF90aGlzLnByb3BzLnZhbHVlKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gUHJvdmlkZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW2NvbnRleHRQcm9wXSA9IHRoaXMuZW1pdHRlciwgX3JlZjtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IG5leHRQcm9wcy52YWx1ZSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBjaGFuZ2VkQml0cztcblxuICAgICAgICBpZiAob2JqZWN0SXMob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgIGNoYW5nZWRCaXRzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKG9sZFZhbHVlLCBuZXdWYWx1ZSkgOiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG5cbiAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMsICdjYWxjdWxhdGVDaGFuZ2VkQml0czogRXhwZWN0ZWQgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBhICcgKyAnMzEtYml0IGludGVnZXIuIEluc3RlYWQgcmVjZWl2ZWQ6ICcgKyBjaGFuZ2VkQml0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZEJpdHMgfD0gMDtcblxuICAgICAgICAgIGlmIChjaGFuZ2VkQml0cyAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnNldChuZXh0UHJvcHMudmFsdWUsIGNoYW5nZWRCaXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvdmlkZXI7XG4gIH0oUmVhY3QuQ29tcG9uZW50KTtcblxuICBQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IChfUHJvdmlkZXIkY2hpbGRDb250ZXggPSB7fSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W2NvbnRleHRQcm9wXSA9IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4KTtcblxuICB2YXIgQ29uc3VtZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQ29tcG9uZW50Mikge1xuICAgIF9pbmhlcml0c0xvb3NlKENvbnN1bWVyLCBfQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBDb25zdW1lcigpIHtcbiAgICAgIHZhciBfdGhpczI7XG5cbiAgICAgIF90aGlzMiA9IF9Db21wb25lbnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzMi5zdGF0ZSA9IHtcbiAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICB9O1xuXG4gICAgICBfdGhpczIub25VcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUsIGNoYW5nZWRCaXRzKSB7XG4gICAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBfdGhpczIub2JzZXJ2ZWRCaXRzIHwgMDtcblxuICAgICAgICBpZiAoKG9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogX3RoaXMyLmdldFZhbHVlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzMjtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvMiA9IENvbnN1bWVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gbmV4dFByb3BzLm9ic2VydmVkQml0cztcbiAgICAgIHRoaXMub2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzID09PSB1bmRlZmluZWQgfHwgb2JzZXJ2ZWRCaXRzID09PSBudWxsID8gTUFYX1NJR05FRF8zMV9CSVRfSU5UIDogb2JzZXJ2ZWRCaXRzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLm9uKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gdGhpcy5wcm9wcy5vYnNlcnZlZEJpdHM7XG4gICAgICB0aGlzLm9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCA/IE1BWF9TSUdORURfMzFfQklUX0lOVCA6IG9ic2VydmVkQml0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5vZmYodGhpcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLmdldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29uc3VtZXI7XG4gIH0oUmVhY3QuQ29tcG9uZW50KTtcblxuICBDb25zdW1lci5jb250ZXh0VHlwZXMgPSAoX0NvbnN1bWVyJGNvbnRleHRUeXBlID0ge30sIF9Db25zdW1lciRjb250ZXh0VHlwZVtjb250ZXh0UHJvcF0gPSBQcm9wVHlwZXMub2JqZWN0LCBfQ29uc3VtZXIkY29udGV4dFR5cGUpO1xuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBQcm92aWRlcixcbiAgICBDb25zdW1lcjogQ29uc3VtZXJcbiAgfTtcbn12YXIgaW5kZXggPSBSZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0IHx8IGNyZWF0ZVJlYWN0Q29udGV4dDttb2R1bGUuZXhwb3J0cz1pbmRleDsiLCIndXNlIHN0cmljdCdcblxuY2xhc3MgQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuYWxwaGFiZXQgPSBhbHBoYWJldFxuICAgIGlmIChpbXBsZW1lbnRhdGlvbiAmJiBhbHBoYWJldCkge1xuICAgICAgdGhpcy5lbmdpbmUgPSBpbXBsZW1lbnRhdGlvbihhbHBoYWJldClcbiAgICB9XG4gIH1cblxuICBlbmNvZGUgKHN0cmluZ09yQnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5naW5lLmVuY29kZShzdHJpbmdPckJ1ZmZlcilcbiAgfVxuXG4gIGRlY29kZSAoc3RyaW5nT3JCdWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmUuZGVjb2RlKHN0cmluZ09yQnVmZmVyKVxuICB9XG5cbiAgaXNJbXBsZW1lbnRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5naW5lXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlXG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhc2UxNiAoYWxwaGFiZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGUgKGlucHV0KSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQpLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0LnRvU3RyaW5nKCdoZXgnKVxuICAgIH0sXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgZm9yIChjb25zdCBjaGFyIG9mIGlucHV0KSB7XG4gICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiYXNlMTYgY2hhcmFjdGVyJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGlucHV0LCAnaGV4JylcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBkZWNvZGUgKGlucHV0LCBhbHBoYWJldCkge1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UobmV3IFJlZ0V4cCgnPScsICdnJyksICcnKVxuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGhcblxuICBsZXQgYml0cyA9IDBcbiAgbGV0IHZhbHVlID0gMFxuXG4gIGxldCBpbmRleCA9IDBcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoKGxlbmd0aCAqIDUgLyA4KSB8IDApXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhbHVlID0gKHZhbHVlIDw8IDUpIHwgYWxwaGFiZXQuaW5kZXhPZihpbnB1dFtpXSlcbiAgICBiaXRzICs9IDVcblxuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIG91dHB1dFtpbmRleCsrXSA9ICh2YWx1ZSA+Pj4gKGJpdHMgLSA4KSkgJiAyNTVcbiAgICAgIGJpdHMgLT0gOFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGVuY29kZSAoYnVmZmVyLCBhbHBoYWJldCkge1xuICBjb25zdCBsZW5ndGggPSBidWZmZXIuYnl0ZUxlbmd0aFxuICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICBjb25zdCBwYWRkaW5nID0gYWxwaGFiZXQuaW5kZXhPZignPScpID09PSBhbHBoYWJldC5sZW5ndGggLSAxXG5cbiAgaWYgKHBhZGRpbmcpIHtcbiAgICBhbHBoYWJldCA9IGFscGhhYmV0LnN1YnN0cmluZygwLCBhbHBoYWJldC5sZW5ndGggLSAxKVxuICB9XG5cbiAgbGV0IGJpdHMgPSAwXG4gIGxldCB2YWx1ZSA9IDBcbiAgbGV0IG91dHB1dCA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhbHVlID0gKHZhbHVlIDw8IDgpIHwgdmlld1tpXVxuICAgIGJpdHMgKz0gOFxuXG4gICAgd2hpbGUgKGJpdHMgPj0gNSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0Wyh2YWx1ZSA+Pj4gKGJpdHMgLSA1KSkgJiAzMV1cbiAgICAgIGJpdHMgLT0gNVxuICAgIH1cbiAgfVxuXG4gIGlmIChiaXRzID4gMCkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFsodmFsdWUgPDwgKDUgLSBiaXRzKSkgJiAzMV1cbiAgfVxuXG4gIGlmIChwYWRkaW5nKSB7XG4gICAgd2hpbGUgKChvdXRwdXQubGVuZ3RoICUgOCkgIT09IDApIHtcbiAgICAgIG91dHB1dCArPSAnPSdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTMyIChhbHBoYWJldCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUoVWludDhBcnJheS5mcm9tKGlucHV0KSwgYWxwaGFiZXQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0KVxuICAgIH0sXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgZm9yIChjb25zdCBjaGFyIG9mIGlucHV0KSB7XG4gICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiYXNlMzIgY2hhcmFjdGVyJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVjb2RlKGlucHV0LCBhbHBoYWJldClcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTY0IChhbHBoYWJldCkge1xuICAvLyBUaGUgYWxwaGFiZXQgaXMgb25seSB1c2VkIHRvIGtub3c6XG4gIC8vICAgMS4gSWYgcGFkZGluZyBpcyBlbmFibGVkIChtdXN0IGNvbnRhaW4gJz0nKVxuICAvLyAgIDIuIElmIHRoZSBvdXRwdXQgbXVzdCBiZSB1cmwtc2FmZSAobXVzdCBjb250YWluICctJyBhbmQgJ18nKVxuICAvLyAgIDMuIElmIHRoZSBpbnB1dCBvZiB0aGUgb3V0cHV0IGZ1bmN0aW9uIGlzIHZhbGlkXG4gIC8vIFRoZSBhbHBoYWJldHMgZnJvbSBSRkMgNDY0OCBhcmUgYWx3YXlzIHVzZWQuXG4gIGNvbnN0IHBhZGRpbmcgPSBhbHBoYWJldC5pbmRleE9mKCc9JykgPiAtMVxuICBjb25zdCB1cmwgPSBhbHBoYWJldC5pbmRleE9mKCctJykgPiAtMSAmJiBhbHBoYWJldC5pbmRleE9mKCdfJykgPiAtMVxuXG4gIHJldHVybiB7XG4gICAgZW5jb2RlIChpbnB1dCkge1xuICAgICAgbGV0IG91dHB1dCA9ICcnXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG91dHB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0KS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IGlucHV0LnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgfVxuXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYWQgPSBvdXRwdXQuaW5kZXhPZignPScpXG4gICAgICBpZiAocGFkID4gMCAmJiAhcGFkZGluZykge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3Vic3RyaW5nKDAsIHBhZClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH0sXG4gICAgZGVjb2RlIChpbnB1dCkge1xuICAgICAgZm9yIChjb25zdCBjaGFyIG9mIGlucHV0KSB7XG4gICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiYXNlNjQgY2hhcmFjdGVyJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQsICdiYXNlNjQnKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKVxuY29uc3QgYmFzZVggPSByZXF1aXJlKCdiYXNlLXgnKVxuY29uc3QgYmFzZTE2ID0gcmVxdWlyZSgnLi9iYXNlMTYnKVxuY29uc3QgYmFzZTMyID0gcmVxdWlyZSgnLi9iYXNlMzInKVxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKVxuXG4vLyBuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXRcbmNvbnN0IGNvbnN0YW50cyA9IFtcbiAgWydiYXNlMScsICcxJywgJycsICcxJ10sXG4gIFsnYmFzZTInLCAnMCcsIGJhc2VYLCAnMDEnXSxcbiAgWydiYXNlOCcsICc3JywgYmFzZVgsICcwMTIzNDU2NyddLFxuICBbJ2Jhc2UxMCcsICc5JywgYmFzZVgsICcwMTIzNDU2Nzg5J10sXG4gIFsnYmFzZTE2JywgJ2YnLCBiYXNlMTYsICcwMTIzNDU2Nzg5YWJjZGVmJ10sXG4gIFsnYmFzZTMyJywgJ2InLCBiYXNlMzIsICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2NyddLFxuICBbJ2Jhc2UzMnBhZCcsICdjJywgYmFzZTMyLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9J10sXG4gIFsnYmFzZTMyaGV4JywgJ3YnLCBiYXNlMzIsICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1diddLFxuICBbJ2Jhc2UzMmhleHBhZCcsICd0JywgYmFzZTMyLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9J10sXG4gIFsnYmFzZTMyeicsICdoJywgYmFzZTMyLCAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknXSxcbiAgWydiYXNlNThmbGlja3InLCAnWicsIGJhc2VYLCAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U1OGJ0YycsICd6JywgYmFzZVgsICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTY0JywgJ20nLCBiYXNlNjQsICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10sXG4gIFsnYmFzZTY0cGFkJywgJ00nLCBiYXNlNjQsICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSddLFxuICBbJ2Jhc2U2NHVybCcsICd1JywgYmFzZTY0LCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXyddLFxuICBbJ2Jhc2U2NHVybHBhZCcsICdVJywgYmFzZTY0LCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nXVxuXVxuXG5jb25zdCBuYW1lcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVswXV0gPSBuZXcgQmFzZSh0dXBwbGVbMF0sIHR1cHBsZVsxXSwgdHVwcGxlWzJdLCB0dXBwbGVbM10pXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxuY29uc3QgY29kZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMV1dID0gbmFtZXNbdHVwcGxlWzBdXVxuICByZXR1cm4gcHJldlxufSwge30pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lczogbmFtZXMsXG4gIGNvZGVzOiBjb2Rlc1xufVxuIiwiLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW211bHRpYmFzZV0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWJhc2UpIHNwZWNpZmljYXRpb24uXG4gKiBAbW9kdWxlIE11bHRpYmFzZVxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG11bHRpYmFzZVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlXG5leHBvcnRzLmlzRW5jb2RlZCA9IGlzRW5jb2RlZFxuZXhwb3J0cy5uYW1lcyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmtleXMoY29uc3RhbnRzLm5hbWVzKSlcbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKE9iamVjdC5rZXlzKGNvbnN0YW50cy5jb2RlcykpXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJ1ZmZlciB3aXRoIHRoZSBtdWx0aWJhc2UgdmFyaW50K2NvZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIHByZWZpeGVkIHdpdGggbXVsdGliYXNlLlxuICogQG1lbWJlcm9mIE11bHRpYmFzZVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gbXVsdGliYXNlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgaWYgKCFidWYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGFuIGVuY29kZWQgYnVmZmVyJylcbiAgfVxuICBjb25zdCBiYXNlID0gZ2V0QmFzZShuYW1lT3JDb2RlKVxuICBjb25zdCBjb2RlQnVmID0gQnVmZmVyLmZyb20oYmFzZS5jb2RlKVxuXG4gIGNvbnN0IG5hbWUgPSBiYXNlLm5hbWVcbiAgdmFsaWRFbmNvZGUobmFtZSwgYnVmKVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY29kZUJ1ZiwgYnVmXSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIHRoZSBzcGVjaWZpZWQgYmFzZSBhbmQgYWRkIHRoZSBtdWx0aWJhc2UgcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgZGF0YSB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEBtZW1iZXJvZiBNdWx0aWJhc2VcbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgY29uc3QgYmFzZSA9IGdldEJhc2UobmFtZU9yQ29kZSlcbiAgY29uc3QgbmFtZSA9IGJhc2UubmFtZVxuXG4gIHJldHVybiBtdWx0aWJhc2UobmFtZSwgQnVmZmVyLmZyb20oYmFzZS5lbmNvZGUoYnVmKSkpXG59XG5cbi8qKlxuICogVGFrZXMgYSBidWZmZXIgb3Igc3RyaW5nIGVuY29kZWQgd2l0aCBtdWx0aWJhc2UgaGVhZGVyLCBkZWNvZGVzIGl0IGFuZFxuICogcmV0dXJucyB0aGUgZGVjb2RlZCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGJ1Zk9yU3RyaW5nXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQG1lbWJlcm9mIE11bHRpYmFzZVxuICpcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChidWZPclN0cmluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1Zk9yU3RyaW5nKSkge1xuICAgIGJ1Zk9yU3RyaW5nID0gYnVmT3JTdHJpbmcudG9TdHJpbmcoKVxuICB9XG5cbiAgY29uc3QgY29kZSA9IGJ1Zk9yU3RyaW5nLnN1YnN0cmluZygwLCAxKVxuICBidWZPclN0cmluZyA9IGJ1Zk9yU3RyaW5nLnN1YnN0cmluZygxLCBidWZPclN0cmluZy5sZW5ndGgpXG5cbiAgaWYgKHR5cGVvZiBidWZPclN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZPclN0cmluZyA9IEJ1ZmZlci5mcm9tKGJ1Zk9yU3RyaW5nKVxuICB9XG5cbiAgY29uc3QgYmFzZSA9IGdldEJhc2UoY29kZSlcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2UuZGVjb2RlKGJ1Zk9yU3RyaW5nLnRvU3RyaW5nKCkpKVxufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBkYXRhIG11bHRpYmFzZSBlbmNvZGVkP1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gYnVmT3JTdHJpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQG1lbWJlcm9mIE11bHRpYmFzZVxuICovXG5mdW5jdGlvbiBpc0VuY29kZWQgKGJ1Zk9yU3RyaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmT3JTdHJpbmcpKSB7XG4gICAgYnVmT3JTdHJpbmcgPSBidWZPclN0cmluZy50b1N0cmluZygpXG4gIH1cblxuICAvLyBFbnN1cmUgYnVmT3JTdHJpbmcgaXMgYSBzdHJpbmdcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChidWZPclN0cmluZykgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBjb2RlID0gYnVmT3JTdHJpbmcuc3Vic3RyaW5nKDAsIDEpXG4gIHRyeSB7XG4gICAgY29uc3QgYmFzZSA9IGdldEJhc2UoY29kZSlcbiAgICByZXR1cm4gYmFzZS5uYW1lXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiB2YWxpZEVuY29kZSAobmFtZSwgYnVmKSB7XG4gIGNvbnN0IGJhc2UgPSBnZXRCYXNlKG5hbWUpXG4gIGJhc2UuZGVjb2RlKGJ1Zi50b1N0cmluZygpKVxufVxuXG5mdW5jdGlvbiBnZXRCYXNlIChuYW1lT3JDb2RlKSB7XG4gIGxldCBiYXNlXG5cbiAgaWYgKGNvbnN0YW50cy5uYW1lc1tuYW1lT3JDb2RlXSkge1xuICAgIGJhc2UgPSBjb25zdGFudHMubmFtZXNbbmFtZU9yQ29kZV1cbiAgfSBlbHNlIGlmIChjb25zdGFudHMuY29kZXNbbmFtZU9yQ29kZV0pIHtcbiAgICBiYXNlID0gY29uc3RhbnRzLmNvZGVzW25hbWVPckNvZGVdXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNvZGluZycpXG4gIH1cblxuICBpZiAoIWJhc2UuaXNJbXBsZW1lbnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlICcgKyBuYW1lT3JDb2RlICsgJyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxuXG4gIHJldHVybiBiYXNlXG59XG4iLCIvKiBlc2xpbnQgcXVvdGUtcHJvcHM6IG9mZiAqL1xuLyogZXNsaW50IGtleS1zcGFjaW5nOiBvZmYgKi9cbid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLm5hbWVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICdpZGVudGl0eSc6ICAgMHgwLFxuICAnc2hhMSc6ICAgICAgIDB4MTEsXG4gICdzaGEyLTI1Nic6ICAgMHgxMixcbiAgJ3NoYTItNTEyJzogICAweDEzLFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ3NoYTMtMjI0JzogICAweDE3LFxuICAnc2hhMy0yNTYnOiAgIDB4MTYsXG4gICdzaGEzLTM4NCc6ICAgMHgxNSxcbiAgJ3NoYTMtNTEyJzogICAweDE0LFxuICAnc2hha2UtMTI4JzogIDB4MTgsXG4gICdzaGFrZS0yNTYnOiAgMHgxOSxcbiAgJ2tlY2Nhay0yMjQnOiAweDFBLFxuICAna2VjY2FrLTI1Nic6IDB4MUIsXG4gICdrZWNjYWstMzg0JzogMHgxQyxcbiAgJ2tlY2Nhay01MTInOiAweDFELFxuICAnbXVybXVyMy0xMjgnOiAweDIyLFxuICAnbXVybXVyMy0zMic6ICAweDIzLFxuICAnbWQ0JzogICAgICAgICAweGQ0LFxuICAnbWQ1JzogICAgICAgICAweGQ1LFxuICAnYmxha2UyYi04JzogICAweGIyMDEsXG4gICdibGFrZTJiLTE2JzogIDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAgMHhiMjAzLFxuICAnYmxha2UyYi0zMic6ICAweGIyMDQsXG4gICdibGFrZTJiLTQwJzogIDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAgMHhiMjA2LFxuICAnYmxha2UyYi01Nic6ICAweGIyMDcsXG4gICdibGFrZTJiLTY0JzogIDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAgMHhiMjA5LFxuICAnYmxha2UyYi04MCc6ICAweGIyMGEsXG4gICdibGFrZTJiLTg4JzogIDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAgMHhiMjBjLFxuICAnYmxha2UyYi0xMDQnOiAweGIyMGQsXG4gICdibGFrZTJiLTExMic6IDB4YjIwZSxcbiAgJ2JsYWtlMmItMTIwJzogMHhiMjBmLFxuICAnYmxha2UyYi0xMjgnOiAweGIyMTAsXG4gICdibGFrZTJiLTEzNic6IDB4YjIxMSxcbiAgJ2JsYWtlMmItMTQ0JzogMHhiMjEyLFxuICAnYmxha2UyYi0xNTInOiAweGIyMTMsXG4gICdibGFrZTJiLTE2MCc6IDB4YjIxNCxcbiAgJ2JsYWtlMmItMTY4JzogMHhiMjE1LFxuICAnYmxha2UyYi0xNzYnOiAweGIyMTYsXG4gICdibGFrZTJiLTE4NCc6IDB4YjIxNyxcbiAgJ2JsYWtlMmItMTkyJzogMHhiMjE4LFxuICAnYmxha2UyYi0yMDAnOiAweGIyMTksXG4gICdibGFrZTJiLTIwOCc6IDB4YjIxYSxcbiAgJ2JsYWtlMmItMjE2JzogMHhiMjFiLFxuICAnYmxha2UyYi0yMjQnOiAweGIyMWMsXG4gICdibGFrZTJiLTIzMic6IDB4YjIxZCxcbiAgJ2JsYWtlMmItMjQwJzogMHhiMjFlLFxuICAnYmxha2UyYi0yNDgnOiAweGIyMWYsXG4gICdibGFrZTJiLTI1Nic6IDB4YjIyMCxcbiAgJ2JsYWtlMmItMjY0JzogMHhiMjIxLFxuICAnYmxha2UyYi0yNzInOiAweGIyMjIsXG4gICdibGFrZTJiLTI4MCc6IDB4YjIyMyxcbiAgJ2JsYWtlMmItMjg4JzogMHhiMjI0LFxuICAnYmxha2UyYi0yOTYnOiAweGIyMjUsXG4gICdibGFrZTJiLTMwNCc6IDB4YjIyNixcbiAgJ2JsYWtlMmItMzEyJzogMHhiMjI3LFxuICAnYmxha2UyYi0zMjAnOiAweGIyMjgsXG4gICdibGFrZTJiLTMyOCc6IDB4YjIyOSxcbiAgJ2JsYWtlMmItMzM2JzogMHhiMjJhLFxuICAnYmxha2UyYi0zNDQnOiAweGIyMmIsXG4gICdibGFrZTJiLTM1Mic6IDB4YjIyYyxcbiAgJ2JsYWtlMmItMzYwJzogMHhiMjJkLFxuICAnYmxha2UyYi0zNjgnOiAweGIyMmUsXG4gICdibGFrZTJiLTM3Nic6IDB4YjIyZixcbiAgJ2JsYWtlMmItMzg0JzogMHhiMjMwLFxuICAnYmxha2UyYi0zOTInOiAweGIyMzEsXG4gICdibGFrZTJiLTQwMCc6IDB4YjIzMixcbiAgJ2JsYWtlMmItNDA4JzogMHhiMjMzLFxuICAnYmxha2UyYi00MTYnOiAweGIyMzQsXG4gICdibGFrZTJiLTQyNCc6IDB4YjIzNSxcbiAgJ2JsYWtlMmItNDMyJzogMHhiMjM2LFxuICAnYmxha2UyYi00NDAnOiAweGIyMzcsXG4gICdibGFrZTJiLTQ0OCc6IDB4YjIzOCxcbiAgJ2JsYWtlMmItNDU2JzogMHhiMjM5LFxuICAnYmxha2UyYi00NjQnOiAweGIyM2EsXG4gICdibGFrZTJiLTQ3Mic6IDB4YjIzYixcbiAgJ2JsYWtlMmItNDgwJzogMHhiMjNjLFxuICAnYmxha2UyYi00ODgnOiAweGIyM2QsXG4gICdibGFrZTJiLTQ5Nic6IDB4YjIzZSxcbiAgJ2JsYWtlMmItNTA0JzogMHhiMjNmLFxuICAnYmxha2UyYi01MTInOiAweGIyNDAsXG4gICdibGFrZTJzLTgnOiAgIDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAgMHhiMjQyLFxuICAnYmxha2Uycy0yNCc6ICAweGIyNDMsXG4gICdibGFrZTJzLTMyJzogIDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAgMHhiMjQ1LFxuICAnYmxha2Uycy00OCc6ICAweGIyNDYsXG4gICdibGFrZTJzLTU2JzogIDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAgMHhiMjQ4LFxuICAnYmxha2Uycy03Mic6ICAweGIyNDksXG4gICdibGFrZTJzLTgwJzogIDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAgMHhiMjRiLFxuICAnYmxha2Uycy05Nic6ICAweGIyNGMsXG4gICdibGFrZTJzLTEwNCc6IDB4YjI0ZCxcbiAgJ2JsYWtlMnMtMTEyJzogMHhiMjRlLFxuICAnYmxha2Uycy0xMjAnOiAweGIyNGYsXG4gICdibGFrZTJzLTEyOCc6IDB4YjI1MCxcbiAgJ2JsYWtlMnMtMTM2JzogMHhiMjUxLFxuICAnYmxha2Uycy0xNDQnOiAweGIyNTIsXG4gICdibGFrZTJzLTE1Mic6IDB4YjI1MyxcbiAgJ2JsYWtlMnMtMTYwJzogMHhiMjU0LFxuICAnYmxha2Uycy0xNjgnOiAweGIyNTUsXG4gICdibGFrZTJzLTE3Nic6IDB4YjI1NixcbiAgJ2JsYWtlMnMtMTg0JzogMHhiMjU3LFxuICAnYmxha2Uycy0xOTInOiAweGIyNTgsXG4gICdibGFrZTJzLTIwMCc6IDB4YjI1OSxcbiAgJ2JsYWtlMnMtMjA4JzogMHhiMjVhLFxuICAnYmxha2Uycy0yMTYnOiAweGIyNWIsXG4gICdibGFrZTJzLTIyNCc6IDB4YjI1YyxcbiAgJ2JsYWtlMnMtMjMyJzogMHhiMjVkLFxuICAnYmxha2Uycy0yNDAnOiAweGIyNWUsXG4gICdibGFrZTJzLTI0OCc6IDB4YjI1ZixcbiAgJ2JsYWtlMnMtMjU2JzogMHhiMjYwLFxuICAnU2tlaW4yNTYtOCc6IDB4YjMwMSxcbiAgJ1NrZWluMjU2LTE2JzogMHhiMzAyLFxuICAnU2tlaW4yNTYtMjQnOiAweGIzMDMsXG4gICdTa2VpbjI1Ni0zMic6IDB4YjMwNCxcbiAgJ1NrZWluMjU2LTQwJzogMHhiMzA1LFxuICAnU2tlaW4yNTYtNDgnOiAweGIzMDYsXG4gICdTa2VpbjI1Ni01Nic6IDB4YjMwNyxcbiAgJ1NrZWluMjU2LTY0JzogMHhiMzA4LFxuICAnU2tlaW4yNTYtNzInOiAweGIzMDksXG4gICdTa2VpbjI1Ni04MCc6IDB4YjMwYSxcbiAgJ1NrZWluMjU2LTg4JzogMHhiMzBiLFxuICAnU2tlaW4yNTYtOTYnOiAweGIzMGMsXG4gICdTa2VpbjI1Ni0xMDQnOiAweGIzMGQsXG4gICdTa2VpbjI1Ni0xMTInOiAweGIzMGUsXG4gICdTa2VpbjI1Ni0xMjAnOiAweGIzMGYsXG4gICdTa2VpbjI1Ni0xMjgnOiAweGIzMTAsXG4gICdTa2VpbjI1Ni0xMzYnOiAweGIzMTEsXG4gICdTa2VpbjI1Ni0xNDQnOiAweGIzMTIsXG4gICdTa2VpbjI1Ni0xNTInOiAweGIzMTMsXG4gICdTa2VpbjI1Ni0xNjAnOiAweGIzMTQsXG4gICdTa2VpbjI1Ni0xNjgnOiAweGIzMTUsXG4gICdTa2VpbjI1Ni0xNzYnOiAweGIzMTYsXG4gICdTa2VpbjI1Ni0xODQnOiAweGIzMTcsXG4gICdTa2VpbjI1Ni0xOTInOiAweGIzMTgsXG4gICdTa2VpbjI1Ni0yMDAnOiAweGIzMTksXG4gICdTa2VpbjI1Ni0yMDgnOiAweGIzMWEsXG4gICdTa2VpbjI1Ni0yMTYnOiAweGIzMWIsXG4gICdTa2VpbjI1Ni0yMjQnOiAweGIzMWMsXG4gICdTa2VpbjI1Ni0yMzInOiAweGIzMWQsXG4gICdTa2VpbjI1Ni0yNDAnOiAweGIzMWUsXG4gICdTa2VpbjI1Ni0yNDgnOiAweGIzMWYsXG4gICdTa2VpbjI1Ni0yNTYnOiAweGIzMjAsXG4gICdTa2VpbjUxMi04JzogMHhiMzIxLFxuICAnU2tlaW41MTItMTYnOiAweGIzMjIsXG4gICdTa2VpbjUxMi0yNCc6IDB4YjMyMyxcbiAgJ1NrZWluNTEyLTMyJzogMHhiMzI0LFxuICAnU2tlaW41MTItNDAnOiAweGIzMjUsXG4gICdTa2VpbjUxMi00OCc6IDB4YjMyNixcbiAgJ1NrZWluNTEyLTU2JzogMHhiMzI3LFxuICAnU2tlaW41MTItNjQnOiAweGIzMjgsXG4gICdTa2VpbjUxMi03Mic6IDB4YjMyOSxcbiAgJ1NrZWluNTEyLTgwJzogMHhiMzJhLFxuICAnU2tlaW41MTItODgnOiAweGIzMmIsXG4gICdTa2VpbjUxMi05Nic6IDB4YjMyYyxcbiAgJ1NrZWluNTEyLTEwNCc6IDB4YjMyZCxcbiAgJ1NrZWluNTEyLTExMic6IDB4YjMyZSxcbiAgJ1NrZWluNTEyLTEyMCc6IDB4YjMyZixcbiAgJ1NrZWluNTEyLTEyOCc6IDB4YjMzMCxcbiAgJ1NrZWluNTEyLTEzNic6IDB4YjMzMSxcbiAgJ1NrZWluNTEyLTE0NCc6IDB4YjMzMixcbiAgJ1NrZWluNTEyLTE1Mic6IDB4YjMzMyxcbiAgJ1NrZWluNTEyLTE2MCc6IDB4YjMzNCxcbiAgJ1NrZWluNTEyLTE2OCc6IDB4YjMzNSxcbiAgJ1NrZWluNTEyLTE3Nic6IDB4YjMzNixcbiAgJ1NrZWluNTEyLTE4NCc6IDB4YjMzNyxcbiAgJ1NrZWluNTEyLTE5Mic6IDB4YjMzOCxcbiAgJ1NrZWluNTEyLTIwMCc6IDB4YjMzOSxcbiAgJ1NrZWluNTEyLTIwOCc6IDB4YjMzYSxcbiAgJ1NrZWluNTEyLTIxNic6IDB4YjMzYixcbiAgJ1NrZWluNTEyLTIyNCc6IDB4YjMzYyxcbiAgJ1NrZWluNTEyLTIzMic6IDB4YjMzZCxcbiAgJ1NrZWluNTEyLTI0MCc6IDB4YjMzZSxcbiAgJ1NrZWluNTEyLTI0OCc6IDB4YjMzZixcbiAgJ1NrZWluNTEyLTI1Nic6IDB4YjM0MCxcbiAgJ1NrZWluNTEyLTI2NCc6IDB4YjM0MSxcbiAgJ1NrZWluNTEyLTI3Mic6IDB4YjM0MixcbiAgJ1NrZWluNTEyLTI4MCc6IDB4YjM0MyxcbiAgJ1NrZWluNTEyLTI4OCc6IDB4YjM0NCxcbiAgJ1NrZWluNTEyLTI5Nic6IDB4YjM0NSxcbiAgJ1NrZWluNTEyLTMwNCc6IDB4YjM0NixcbiAgJ1NrZWluNTEyLTMxMic6IDB4YjM0NyxcbiAgJ1NrZWluNTEyLTMyMCc6IDB4YjM0OCxcbiAgJ1NrZWluNTEyLTMyOCc6IDB4YjM0OSxcbiAgJ1NrZWluNTEyLTMzNic6IDB4YjM0YSxcbiAgJ1NrZWluNTEyLTM0NCc6IDB4YjM0YixcbiAgJ1NrZWluNTEyLTM1Mic6IDB4YjM0YyxcbiAgJ1NrZWluNTEyLTM2MCc6IDB4YjM0ZCxcbiAgJ1NrZWluNTEyLTM2OCc6IDB4YjM0ZSxcbiAgJ1NrZWluNTEyLTM3Nic6IDB4YjM0ZixcbiAgJ1NrZWluNTEyLTM4NCc6IDB4YjM1MCxcbiAgJ1NrZWluNTEyLTM5Mic6IDB4YjM1MSxcbiAgJ1NrZWluNTEyLTQwMCc6IDB4YjM1MixcbiAgJ1NrZWluNTEyLTQwOCc6IDB4YjM1MyxcbiAgJ1NrZWluNTEyLTQxNic6IDB4YjM1NCxcbiAgJ1NrZWluNTEyLTQyNCc6IDB4YjM1NSxcbiAgJ1NrZWluNTEyLTQzMic6IDB4YjM1NixcbiAgJ1NrZWluNTEyLTQ0MCc6IDB4YjM1NyxcbiAgJ1NrZWluNTEyLTQ0OCc6IDB4YjM1OCxcbiAgJ1NrZWluNTEyLTQ1Nic6IDB4YjM1OSxcbiAgJ1NrZWluNTEyLTQ2NCc6IDB4YjM1YSxcbiAgJ1NrZWluNTEyLTQ3Mic6IDB4YjM1YixcbiAgJ1NrZWluNTEyLTQ4MCc6IDB4YjM1YyxcbiAgJ1NrZWluNTEyLTQ4OCc6IDB4YjM1ZCxcbiAgJ1NrZWluNTEyLTQ5Nic6IDB4YjM1ZSxcbiAgJ1NrZWluNTEyLTUwNCc6IDB4YjM1ZixcbiAgJ1NrZWluNTEyLTUxMic6IDB4YjM2MCxcbiAgJ1NrZWluMTAyNC04JzogMHhiMzYxLFxuICAnU2tlaW4xMDI0LTE2JzogMHhiMzYyLFxuICAnU2tlaW4xMDI0LTI0JzogMHhiMzYzLFxuICAnU2tlaW4xMDI0LTMyJzogMHhiMzY0LFxuICAnU2tlaW4xMDI0LTQwJzogMHhiMzY1LFxuICAnU2tlaW4xMDI0LTQ4JzogMHhiMzY2LFxuICAnU2tlaW4xMDI0LTU2JzogMHhiMzY3LFxuICAnU2tlaW4xMDI0LTY0JzogMHhiMzY4LFxuICAnU2tlaW4xMDI0LTcyJzogMHhiMzY5LFxuICAnU2tlaW4xMDI0LTgwJzogMHhiMzZhLFxuICAnU2tlaW4xMDI0LTg4JzogMHhiMzZiLFxuICAnU2tlaW4xMDI0LTk2JzogMHhiMzZjLFxuICAnU2tlaW4xMDI0LTEwNCc6IDB4YjM2ZCxcbiAgJ1NrZWluMTAyNC0xMTInOiAweGIzNmUsXG4gICdTa2VpbjEwMjQtMTIwJzogMHhiMzZmLFxuICAnU2tlaW4xMDI0LTEyOCc6IDB4YjM3MCxcbiAgJ1NrZWluMTAyNC0xMzYnOiAweGIzNzEsXG4gICdTa2VpbjEwMjQtMTQ0JzogMHhiMzcyLFxuICAnU2tlaW4xMDI0LTE1Mic6IDB4YjM3MyxcbiAgJ1NrZWluMTAyNC0xNjAnOiAweGIzNzQsXG4gICdTa2VpbjEwMjQtMTY4JzogMHhiMzc1LFxuICAnU2tlaW4xMDI0LTE3Nic6IDB4YjM3NixcbiAgJ1NrZWluMTAyNC0xODQnOiAweGIzNzcsXG4gICdTa2VpbjEwMjQtMTkyJzogMHhiMzc4LFxuICAnU2tlaW4xMDI0LTIwMCc6IDB4YjM3OSxcbiAgJ1NrZWluMTAyNC0yMDgnOiAweGIzN2EsXG4gICdTa2VpbjEwMjQtMjE2JzogMHhiMzdiLFxuICAnU2tlaW4xMDI0LTIyNCc6IDB4YjM3YyxcbiAgJ1NrZWluMTAyNC0yMzInOiAweGIzN2QsXG4gICdTa2VpbjEwMjQtMjQwJzogMHhiMzdlLFxuICAnU2tlaW4xMDI0LTI0OCc6IDB4YjM3ZixcbiAgJ1NrZWluMTAyNC0yNTYnOiAweGIzODAsXG4gICdTa2VpbjEwMjQtMjY0JzogMHhiMzgxLFxuICAnU2tlaW4xMDI0LTI3Mic6IDB4YjM4MixcbiAgJ1NrZWluMTAyNC0yODAnOiAweGIzODMsXG4gICdTa2VpbjEwMjQtMjg4JzogMHhiMzg0LFxuICAnU2tlaW4xMDI0LTI5Nic6IDB4YjM4NSxcbiAgJ1NrZWluMTAyNC0zMDQnOiAweGIzODYsXG4gICdTa2VpbjEwMjQtMzEyJzogMHhiMzg3LFxuICAnU2tlaW4xMDI0LTMyMCc6IDB4YjM4OCxcbiAgJ1NrZWluMTAyNC0zMjgnOiAweGIzODksXG4gICdTa2VpbjEwMjQtMzM2JzogMHhiMzhhLFxuICAnU2tlaW4xMDI0LTM0NCc6IDB4YjM4YixcbiAgJ1NrZWluMTAyNC0zNTInOiAweGIzOGMsXG4gICdTa2VpbjEwMjQtMzYwJzogMHhiMzhkLFxuICAnU2tlaW4xMDI0LTM2OCc6IDB4YjM4ZSxcbiAgJ1NrZWluMTAyNC0zNzYnOiAweGIzOGYsXG4gICdTa2VpbjEwMjQtMzg0JzogMHhiMzkwLFxuICAnU2tlaW4xMDI0LTM5Mic6IDB4YjM5MSxcbiAgJ1NrZWluMTAyNC00MDAnOiAweGIzOTIsXG4gICdTa2VpbjEwMjQtNDA4JzogMHhiMzkzLFxuICAnU2tlaW4xMDI0LTQxNic6IDB4YjM5NCxcbiAgJ1NrZWluMTAyNC00MjQnOiAweGIzOTUsXG4gICdTa2VpbjEwMjQtNDMyJzogMHhiMzk2LFxuICAnU2tlaW4xMDI0LTQ0MCc6IDB4YjM5NyxcbiAgJ1NrZWluMTAyNC00NDgnOiAweGIzOTgsXG4gICdTa2VpbjEwMjQtNDU2JzogMHhiMzk5LFxuICAnU2tlaW4xMDI0LTQ2NCc6IDB4YjM5YSxcbiAgJ1NrZWluMTAyNC00NzInOiAweGIzOWIsXG4gICdTa2VpbjEwMjQtNDgwJzogMHhiMzljLFxuICAnU2tlaW4xMDI0LTQ4OCc6IDB4YjM5ZCxcbiAgJ1NrZWluMTAyNC00OTYnOiAweGIzOWUsXG4gICdTa2VpbjEwMjQtNTA0JzogMHhiMzlmLFxuICAnU2tlaW4xMDI0LTUxMic6IDB4YjNhMCxcbiAgJ1NrZWluMTAyNC01MjAnOiAweGIzYTEsXG4gICdTa2VpbjEwMjQtNTI4JzogMHhiM2EyLFxuICAnU2tlaW4xMDI0LTUzNic6IDB4YjNhMyxcbiAgJ1NrZWluMTAyNC01NDQnOiAweGIzYTQsXG4gICdTa2VpbjEwMjQtNTUyJzogMHhiM2E1LFxuICAnU2tlaW4xMDI0LTU2MCc6IDB4YjNhNixcbiAgJ1NrZWluMTAyNC01NjgnOiAweGIzYTcsXG4gICdTa2VpbjEwMjQtNTc2JzogMHhiM2E4LFxuICAnU2tlaW4xMDI0LTU4NCc6IDB4YjNhOSxcbiAgJ1NrZWluMTAyNC01OTInOiAweGIzYWEsXG4gICdTa2VpbjEwMjQtNjAwJzogMHhiM2FiLFxuICAnU2tlaW4xMDI0LTYwOCc6IDB4YjNhYyxcbiAgJ1NrZWluMTAyNC02MTYnOiAweGIzYWQsXG4gICdTa2VpbjEwMjQtNjI0JzogMHhiM2FlLFxuICAnU2tlaW4xMDI0LTYzMic6IDB4YjNhZixcbiAgJ1NrZWluMTAyNC02NDAnOiAweGIzYjAsXG4gICdTa2VpbjEwMjQtNjQ4JzogMHhiM2IxLFxuICAnU2tlaW4xMDI0LTY1Nic6IDB4YjNiMixcbiAgJ1NrZWluMTAyNC02NjQnOiAweGIzYjMsXG4gICdTa2VpbjEwMjQtNjcyJzogMHhiM2I0LFxuICAnU2tlaW4xMDI0LTY4MCc6IDB4YjNiNSxcbiAgJ1NrZWluMTAyNC02ODgnOiAweGIzYjYsXG4gICdTa2VpbjEwMjQtNjk2JzogMHhiM2I3LFxuICAnU2tlaW4xMDI0LTcwNCc6IDB4YjNiOCxcbiAgJ1NrZWluMTAyNC03MTInOiAweGIzYjksXG4gICdTa2VpbjEwMjQtNzIwJzogMHhiM2JhLFxuICAnU2tlaW4xMDI0LTcyOCc6IDB4YjNiYixcbiAgJ1NrZWluMTAyNC03MzYnOiAweGIzYmMsXG4gICdTa2VpbjEwMjQtNzQ0JzogMHhiM2JkLFxuICAnU2tlaW4xMDI0LTc1Mic6IDB4YjNiZSxcbiAgJ1NrZWluMTAyNC03NjAnOiAweGIzYmYsXG4gICdTa2VpbjEwMjQtNzY4JzogMHhiM2MwLFxuICAnU2tlaW4xMDI0LTc3Nic6IDB4YjNjMSxcbiAgJ1NrZWluMTAyNC03ODQnOiAweGIzYzIsXG4gICdTa2VpbjEwMjQtNzkyJzogMHhiM2MzLFxuICAnU2tlaW4xMDI0LTgwMCc6IDB4YjNjNCxcbiAgJ1NrZWluMTAyNC04MDgnOiAweGIzYzUsXG4gICdTa2VpbjEwMjQtODE2JzogMHhiM2M2LFxuICAnU2tlaW4xMDI0LTgyNCc6IDB4YjNjNyxcbiAgJ1NrZWluMTAyNC04MzInOiAweGIzYzgsXG4gICdTa2VpbjEwMjQtODQwJzogMHhiM2M5LFxuICAnU2tlaW4xMDI0LTg0OCc6IDB4YjNjYSxcbiAgJ1NrZWluMTAyNC04NTYnOiAweGIzY2IsXG4gICdTa2VpbjEwMjQtODY0JzogMHhiM2NjLFxuICAnU2tlaW4xMDI0LTg3Mic6IDB4YjNjZCxcbiAgJ1NrZWluMTAyNC04ODAnOiAweGIzY2UsXG4gICdTa2VpbjEwMjQtODg4JzogMHhiM2NmLFxuICAnU2tlaW4xMDI0LTg5Nic6IDB4YjNkMCxcbiAgJ1NrZWluMTAyNC05MDQnOiAweGIzZDEsXG4gICdTa2VpbjEwMjQtOTEyJzogMHhiM2QyLFxuICAnU2tlaW4xMDI0LTkyMCc6IDB4YjNkMyxcbiAgJ1NrZWluMTAyNC05MjgnOiAweGIzZDQsXG4gICdTa2VpbjEwMjQtOTM2JzogMHhiM2Q1LFxuICAnU2tlaW4xMDI0LTk0NCc6IDB4YjNkNixcbiAgJ1NrZWluMTAyNC05NTInOiAweGIzZDcsXG4gICdTa2VpbjEwMjQtOTYwJzogMHhiM2Q4LFxuICAnU2tlaW4xMDI0LTk2OCc6IDB4YjNkOSxcbiAgJ1NrZWluMTAyNC05NzYnOiAweGIzZGEsXG4gICdTa2VpbjEwMjQtOTg0JzogMHhiM2RiLFxuICAnU2tlaW4xMDI0LTk5Mic6IDB4YjNkYyxcbiAgJ1NrZWluMTAyNC0xMDAwJzogMHhiM2RkLFxuICAnU2tlaW4xMDI0LTEwMDgnOiAweGIzZGUsXG4gICdTa2VpbjEwMjQtMTAxNic6IDB4YjNkZixcbiAgJ1NrZWluMTAyNC0xMDI0JzogMHhiM2UwXG59KVxuXG5leHBvcnRzLmNvZGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIDB4MDogJ2lkZW50aXR5JyxcblxuICAvLyBzaGEgZmFtaWx5XG4gIDB4MTE6ICdzaGExJyxcbiAgMHgxMjogJ3NoYTItMjU2JyxcbiAgMHgxMzogJ3NoYTItNTEyJyxcbiAgMHg1NjogJ2RibC1zaGEyLTI1NicsXG4gIDB4MTc6ICdzaGEzLTIyNCcsXG4gIDB4MTY6ICdzaGEzLTI1NicsXG4gIDB4MTU6ICdzaGEzLTM4NCcsXG4gIDB4MTQ6ICdzaGEzLTUxMicsXG4gIDB4MTg6ICdzaGFrZS0xMjgnLFxuICAweDE5OiAnc2hha2UtMjU2JyxcbiAgMHgxQTogJ2tlY2Nhay0yMjQnLFxuICAweDFCOiAna2VjY2FrLTI1NicsXG4gIDB4MUM6ICdrZWNjYWstMzg0JyxcbiAgMHgxRDogJ2tlY2Nhay01MTInLFxuXG4gIDB4MjI6ICdtdXJtdXIzLTEyOCcsXG4gIDB4MjM6ICdtdXJtdXIzLTMyJyxcblxuICAweGQ0OiAnbWQ0JyxcbiAgMHhkNTogJ21kNScsXG5cbiAgLy8gYmxha2UyXG4gIDB4YjIwMTogJ2JsYWtlMmItOCcsXG4gIDB4YjIwMjogJ2JsYWtlMmItMTYnLFxuICAweGIyMDM6ICdibGFrZTJiLTI0JyxcbiAgMHhiMjA0OiAnYmxha2UyYi0zMicsXG4gIDB4YjIwNTogJ2JsYWtlMmItNDAnLFxuICAweGIyMDY6ICdibGFrZTJiLTQ4JyxcbiAgMHhiMjA3OiAnYmxha2UyYi01NicsXG4gIDB4YjIwODogJ2JsYWtlMmItNjQnLFxuICAweGIyMDk6ICdibGFrZTJiLTcyJyxcbiAgMHhiMjBhOiAnYmxha2UyYi04MCcsXG4gIDB4YjIwYjogJ2JsYWtlMmItODgnLFxuICAweGIyMGM6ICdibGFrZTJiLTk2JyxcbiAgMHhiMjBkOiAnYmxha2UyYi0xMDQnLFxuICAweGIyMGU6ICdibGFrZTJiLTExMicsXG4gIDB4YjIwZjogJ2JsYWtlMmItMTIwJyxcbiAgMHhiMjEwOiAnYmxha2UyYi0xMjgnLFxuICAweGIyMTE6ICdibGFrZTJiLTEzNicsXG4gIDB4YjIxMjogJ2JsYWtlMmItMTQ0JyxcbiAgMHhiMjEzOiAnYmxha2UyYi0xNTInLFxuICAweGIyMTQ6ICdibGFrZTJiLTE2MCcsXG4gIDB4YjIxNTogJ2JsYWtlMmItMTY4JyxcbiAgMHhiMjE2OiAnYmxha2UyYi0xNzYnLFxuICAweGIyMTc6ICdibGFrZTJiLTE4NCcsXG4gIDB4YjIxODogJ2JsYWtlMmItMTkyJyxcbiAgMHhiMjE5OiAnYmxha2UyYi0yMDAnLFxuICAweGIyMWE6ICdibGFrZTJiLTIwOCcsXG4gIDB4YjIxYjogJ2JsYWtlMmItMjE2JyxcbiAgMHhiMjFjOiAnYmxha2UyYi0yMjQnLFxuICAweGIyMWQ6ICdibGFrZTJiLTIzMicsXG4gIDB4YjIxZTogJ2JsYWtlMmItMjQwJyxcbiAgMHhiMjFmOiAnYmxha2UyYi0yNDgnLFxuICAweGIyMjA6ICdibGFrZTJiLTI1NicsXG4gIDB4YjIyMTogJ2JsYWtlMmItMjY0JyxcbiAgMHhiMjIyOiAnYmxha2UyYi0yNzInLFxuICAweGIyMjM6ICdibGFrZTJiLTI4MCcsXG4gIDB4YjIyNDogJ2JsYWtlMmItMjg4JyxcbiAgMHhiMjI1OiAnYmxha2UyYi0yOTYnLFxuICAweGIyMjY6ICdibGFrZTJiLTMwNCcsXG4gIDB4YjIyNzogJ2JsYWtlMmItMzEyJyxcbiAgMHhiMjI4OiAnYmxha2UyYi0zMjAnLFxuICAweGIyMjk6ICdibGFrZTJiLTMyOCcsXG4gIDB4YjIyYTogJ2JsYWtlMmItMzM2JyxcbiAgMHhiMjJiOiAnYmxha2UyYi0zNDQnLFxuICAweGIyMmM6ICdibGFrZTJiLTM1MicsXG4gIDB4YjIyZDogJ2JsYWtlMmItMzYwJyxcbiAgMHhiMjJlOiAnYmxha2UyYi0zNjgnLFxuICAweGIyMmY6ICdibGFrZTJiLTM3NicsXG4gIDB4YjIzMDogJ2JsYWtlMmItMzg0JyxcbiAgMHhiMjMxOiAnYmxha2UyYi0zOTInLFxuICAweGIyMzI6ICdibGFrZTJiLTQwMCcsXG4gIDB4YjIzMzogJ2JsYWtlMmItNDA4JyxcbiAgMHhiMjM0OiAnYmxha2UyYi00MTYnLFxuICAweGIyMzU6ICdibGFrZTJiLTQyNCcsXG4gIDB4YjIzNjogJ2JsYWtlMmItNDMyJyxcbiAgMHhiMjM3OiAnYmxha2UyYi00NDAnLFxuICAweGIyMzg6ICdibGFrZTJiLTQ0OCcsXG4gIDB4YjIzOTogJ2JsYWtlMmItNDU2JyxcbiAgMHhiMjNhOiAnYmxha2UyYi00NjQnLFxuICAweGIyM2I6ICdibGFrZTJiLTQ3MicsXG4gIDB4YjIzYzogJ2JsYWtlMmItNDgwJyxcbiAgMHhiMjNkOiAnYmxha2UyYi00ODgnLFxuICAweGIyM2U6ICdibGFrZTJiLTQ5NicsXG4gIDB4YjIzZjogJ2JsYWtlMmItNTA0JyxcbiAgMHhiMjQwOiAnYmxha2UyYi01MTInLFxuICAweGIyNDE6ICdibGFrZTJzLTgnLFxuICAweGIyNDI6ICdibGFrZTJzLTE2JyxcbiAgMHhiMjQzOiAnYmxha2Uycy0yNCcsXG4gIDB4YjI0NDogJ2JsYWtlMnMtMzInLFxuICAweGIyNDU6ICdibGFrZTJzLTQwJyxcbiAgMHhiMjQ2OiAnYmxha2Uycy00OCcsXG4gIDB4YjI0NzogJ2JsYWtlMnMtNTYnLFxuICAweGIyNDg6ICdibGFrZTJzLTY0JyxcbiAgMHhiMjQ5OiAnYmxha2Uycy03MicsXG4gIDB4YjI0YTogJ2JsYWtlMnMtODAnLFxuICAweGIyNGI6ICdibGFrZTJzLTg4JyxcbiAgMHhiMjRjOiAnYmxha2Uycy05NicsXG4gIDB4YjI0ZDogJ2JsYWtlMnMtMTA0JyxcbiAgMHhiMjRlOiAnYmxha2Uycy0xMTInLFxuICAweGIyNGY6ICdibGFrZTJzLTEyMCcsXG4gIDB4YjI1MDogJ2JsYWtlMnMtMTI4JyxcbiAgMHhiMjUxOiAnYmxha2Uycy0xMzYnLFxuICAweGIyNTI6ICdibGFrZTJzLTE0NCcsXG4gIDB4YjI1MzogJ2JsYWtlMnMtMTUyJyxcbiAgMHhiMjU0OiAnYmxha2Uycy0xNjAnLFxuICAweGIyNTU6ICdibGFrZTJzLTE2OCcsXG4gIDB4YjI1NjogJ2JsYWtlMnMtMTc2JyxcbiAgMHhiMjU3OiAnYmxha2Uycy0xODQnLFxuICAweGIyNTg6ICdibGFrZTJzLTE5MicsXG4gIDB4YjI1OTogJ2JsYWtlMnMtMjAwJyxcbiAgMHhiMjVhOiAnYmxha2Uycy0yMDgnLFxuICAweGIyNWI6ICdibGFrZTJzLTIxNicsXG4gIDB4YjI1YzogJ2JsYWtlMnMtMjI0JyxcbiAgMHhiMjVkOiAnYmxha2Uycy0yMzInLFxuICAweGIyNWU6ICdibGFrZTJzLTI0MCcsXG4gIDB4YjI1ZjogJ2JsYWtlMnMtMjQ4JyxcbiAgMHhiMjYwOiAnYmxha2Uycy0yNTYnLFxuXG4gIC8vIHNrZWluXG4gIDB4YjMwMTogJ1NrZWluMjU2LTgnLFxuICAweGIzMDI6ICdTa2VpbjI1Ni0xNicsXG4gIDB4YjMwMzogJ1NrZWluMjU2LTI0JyxcbiAgMHhiMzA0OiAnU2tlaW4yNTYtMzInLFxuICAweGIzMDU6ICdTa2VpbjI1Ni00MCcsXG4gIDB4YjMwNjogJ1NrZWluMjU2LTQ4JyxcbiAgMHhiMzA3OiAnU2tlaW4yNTYtNTYnLFxuICAweGIzMDg6ICdTa2VpbjI1Ni02NCcsXG4gIDB4YjMwOTogJ1NrZWluMjU2LTcyJyxcbiAgMHhiMzBhOiAnU2tlaW4yNTYtODAnLFxuICAweGIzMGI6ICdTa2VpbjI1Ni04OCcsXG4gIDB4YjMwYzogJ1NrZWluMjU2LTk2JyxcbiAgMHhiMzBkOiAnU2tlaW4yNTYtMTA0JyxcbiAgMHhiMzBlOiAnU2tlaW4yNTYtMTEyJyxcbiAgMHhiMzBmOiAnU2tlaW4yNTYtMTIwJyxcbiAgMHhiMzEwOiAnU2tlaW4yNTYtMTI4JyxcbiAgMHhiMzExOiAnU2tlaW4yNTYtMTM2JyxcbiAgMHhiMzEyOiAnU2tlaW4yNTYtMTQ0JyxcbiAgMHhiMzEzOiAnU2tlaW4yNTYtMTUyJyxcbiAgMHhiMzE0OiAnU2tlaW4yNTYtMTYwJyxcbiAgMHhiMzE1OiAnU2tlaW4yNTYtMTY4JyxcbiAgMHhiMzE2OiAnU2tlaW4yNTYtMTc2JyxcbiAgMHhiMzE3OiAnU2tlaW4yNTYtMTg0JyxcbiAgMHhiMzE4OiAnU2tlaW4yNTYtMTkyJyxcbiAgMHhiMzE5OiAnU2tlaW4yNTYtMjAwJyxcbiAgMHhiMzFhOiAnU2tlaW4yNTYtMjA4JyxcbiAgMHhiMzFiOiAnU2tlaW4yNTYtMjE2JyxcbiAgMHhiMzFjOiAnU2tlaW4yNTYtMjI0JyxcbiAgMHhiMzFkOiAnU2tlaW4yNTYtMjMyJyxcbiAgMHhiMzFlOiAnU2tlaW4yNTYtMjQwJyxcbiAgMHhiMzFmOiAnU2tlaW4yNTYtMjQ4JyxcbiAgMHhiMzIwOiAnU2tlaW4yNTYtMjU2JyxcbiAgMHhiMzIxOiAnU2tlaW41MTItOCcsXG4gIDB4YjMyMjogJ1NrZWluNTEyLTE2JyxcbiAgMHhiMzIzOiAnU2tlaW41MTItMjQnLFxuICAweGIzMjQ6ICdTa2VpbjUxMi0zMicsXG4gIDB4YjMyNTogJ1NrZWluNTEyLTQwJyxcbiAgMHhiMzI2OiAnU2tlaW41MTItNDgnLFxuICAweGIzMjc6ICdTa2VpbjUxMi01NicsXG4gIDB4YjMyODogJ1NrZWluNTEyLTY0JyxcbiAgMHhiMzI5OiAnU2tlaW41MTItNzInLFxuICAweGIzMmE6ICdTa2VpbjUxMi04MCcsXG4gIDB4YjMyYjogJ1NrZWluNTEyLTg4JyxcbiAgMHhiMzJjOiAnU2tlaW41MTItOTYnLFxuICAweGIzMmQ6ICdTa2VpbjUxMi0xMDQnLFxuICAweGIzMmU6ICdTa2VpbjUxMi0xMTInLFxuICAweGIzMmY6ICdTa2VpbjUxMi0xMjAnLFxuICAweGIzMzA6ICdTa2VpbjUxMi0xMjgnLFxuICAweGIzMzE6ICdTa2VpbjUxMi0xMzYnLFxuICAweGIzMzI6ICdTa2VpbjUxMi0xNDQnLFxuICAweGIzMzM6ICdTa2VpbjUxMi0xNTInLFxuICAweGIzMzQ6ICdTa2VpbjUxMi0xNjAnLFxuICAweGIzMzU6ICdTa2VpbjUxMi0xNjgnLFxuICAweGIzMzY6ICdTa2VpbjUxMi0xNzYnLFxuICAweGIzMzc6ICdTa2VpbjUxMi0xODQnLFxuICAweGIzMzg6ICdTa2VpbjUxMi0xOTInLFxuICAweGIzMzk6ICdTa2VpbjUxMi0yMDAnLFxuICAweGIzM2E6ICdTa2VpbjUxMi0yMDgnLFxuICAweGIzM2I6ICdTa2VpbjUxMi0yMTYnLFxuICAweGIzM2M6ICdTa2VpbjUxMi0yMjQnLFxuICAweGIzM2Q6ICdTa2VpbjUxMi0yMzInLFxuICAweGIzM2U6ICdTa2VpbjUxMi0yNDAnLFxuICAweGIzM2Y6ICdTa2VpbjUxMi0yNDgnLFxuICAweGIzNDA6ICdTa2VpbjUxMi0yNTYnLFxuICAweGIzNDE6ICdTa2VpbjUxMi0yNjQnLFxuICAweGIzNDI6ICdTa2VpbjUxMi0yNzInLFxuICAweGIzNDM6ICdTa2VpbjUxMi0yODAnLFxuICAweGIzNDQ6ICdTa2VpbjUxMi0yODgnLFxuICAweGIzNDU6ICdTa2VpbjUxMi0yOTYnLFxuICAweGIzNDY6ICdTa2VpbjUxMi0zMDQnLFxuICAweGIzNDc6ICdTa2VpbjUxMi0zMTInLFxuICAweGIzNDg6ICdTa2VpbjUxMi0zMjAnLFxuICAweGIzNDk6ICdTa2VpbjUxMi0zMjgnLFxuICAweGIzNGE6ICdTa2VpbjUxMi0zMzYnLFxuICAweGIzNGI6ICdTa2VpbjUxMi0zNDQnLFxuICAweGIzNGM6ICdTa2VpbjUxMi0zNTInLFxuICAweGIzNGQ6ICdTa2VpbjUxMi0zNjAnLFxuICAweGIzNGU6ICdTa2VpbjUxMi0zNjgnLFxuICAweGIzNGY6ICdTa2VpbjUxMi0zNzYnLFxuICAweGIzNTA6ICdTa2VpbjUxMi0zODQnLFxuICAweGIzNTE6ICdTa2VpbjUxMi0zOTInLFxuICAweGIzNTI6ICdTa2VpbjUxMi00MDAnLFxuICAweGIzNTM6ICdTa2VpbjUxMi00MDgnLFxuICAweGIzNTQ6ICdTa2VpbjUxMi00MTYnLFxuICAweGIzNTU6ICdTa2VpbjUxMi00MjQnLFxuICAweGIzNTY6ICdTa2VpbjUxMi00MzInLFxuICAweGIzNTc6ICdTa2VpbjUxMi00NDAnLFxuICAweGIzNTg6ICdTa2VpbjUxMi00NDgnLFxuICAweGIzNTk6ICdTa2VpbjUxMi00NTYnLFxuICAweGIzNWE6ICdTa2VpbjUxMi00NjQnLFxuICAweGIzNWI6ICdTa2VpbjUxMi00NzInLFxuICAweGIzNWM6ICdTa2VpbjUxMi00ODAnLFxuICAweGIzNWQ6ICdTa2VpbjUxMi00ODgnLFxuICAweGIzNWU6ICdTa2VpbjUxMi00OTYnLFxuICAweGIzNWY6ICdTa2VpbjUxMi01MDQnLFxuICAweGIzNjA6ICdTa2VpbjUxMi01MTInLFxuICAweGIzNjE6ICdTa2VpbjEwMjQtOCcsXG4gIDB4YjM2MjogJ1NrZWluMTAyNC0xNicsXG4gIDB4YjM2MzogJ1NrZWluMTAyNC0yNCcsXG4gIDB4YjM2NDogJ1NrZWluMTAyNC0zMicsXG4gIDB4YjM2NTogJ1NrZWluMTAyNC00MCcsXG4gIDB4YjM2NjogJ1NrZWluMTAyNC00OCcsXG4gIDB4YjM2NzogJ1NrZWluMTAyNC01NicsXG4gIDB4YjM2ODogJ1NrZWluMTAyNC02NCcsXG4gIDB4YjM2OTogJ1NrZWluMTAyNC03MicsXG4gIDB4YjM2YTogJ1NrZWluMTAyNC04MCcsXG4gIDB4YjM2YjogJ1NrZWluMTAyNC04OCcsXG4gIDB4YjM2YzogJ1NrZWluMTAyNC05NicsXG4gIDB4YjM2ZDogJ1NrZWluMTAyNC0xMDQnLFxuICAweGIzNmU6ICdTa2VpbjEwMjQtMTEyJyxcbiAgMHhiMzZmOiAnU2tlaW4xMDI0LTEyMCcsXG4gIDB4YjM3MDogJ1NrZWluMTAyNC0xMjgnLFxuICAweGIzNzE6ICdTa2VpbjEwMjQtMTM2JyxcbiAgMHhiMzcyOiAnU2tlaW4xMDI0LTE0NCcsXG4gIDB4YjM3MzogJ1NrZWluMTAyNC0xNTInLFxuICAweGIzNzQ6ICdTa2VpbjEwMjQtMTYwJyxcbiAgMHhiMzc1OiAnU2tlaW4xMDI0LTE2OCcsXG4gIDB4YjM3NjogJ1NrZWluMTAyNC0xNzYnLFxuICAweGIzNzc6ICdTa2VpbjEwMjQtMTg0JyxcbiAgMHhiMzc4OiAnU2tlaW4xMDI0LTE5MicsXG4gIDB4YjM3OTogJ1NrZWluMTAyNC0yMDAnLFxuICAweGIzN2E6ICdTa2VpbjEwMjQtMjA4JyxcbiAgMHhiMzdiOiAnU2tlaW4xMDI0LTIxNicsXG4gIDB4YjM3YzogJ1NrZWluMTAyNC0yMjQnLFxuICAweGIzN2Q6ICdTa2VpbjEwMjQtMjMyJyxcbiAgMHhiMzdlOiAnU2tlaW4xMDI0LTI0MCcsXG4gIDB4YjM3ZjogJ1NrZWluMTAyNC0yNDgnLFxuICAweGIzODA6ICdTa2VpbjEwMjQtMjU2JyxcbiAgMHhiMzgxOiAnU2tlaW4xMDI0LTI2NCcsXG4gIDB4YjM4MjogJ1NrZWluMTAyNC0yNzInLFxuICAweGIzODM6ICdTa2VpbjEwMjQtMjgwJyxcbiAgMHhiMzg0OiAnU2tlaW4xMDI0LTI4OCcsXG4gIDB4YjM4NTogJ1NrZWluMTAyNC0yOTYnLFxuICAweGIzODY6ICdTa2VpbjEwMjQtMzA0JyxcbiAgMHhiMzg3OiAnU2tlaW4xMDI0LTMxMicsXG4gIDB4YjM4ODogJ1NrZWluMTAyNC0zMjAnLFxuICAweGIzODk6ICdTa2VpbjEwMjQtMzI4JyxcbiAgMHhiMzhhOiAnU2tlaW4xMDI0LTMzNicsXG4gIDB4YjM4YjogJ1NrZWluMTAyNC0zNDQnLFxuICAweGIzOGM6ICdTa2VpbjEwMjQtMzUyJyxcbiAgMHhiMzhkOiAnU2tlaW4xMDI0LTM2MCcsXG4gIDB4YjM4ZTogJ1NrZWluMTAyNC0zNjgnLFxuICAweGIzOGY6ICdTa2VpbjEwMjQtMzc2JyxcbiAgMHhiMzkwOiAnU2tlaW4xMDI0LTM4NCcsXG4gIDB4YjM5MTogJ1NrZWluMTAyNC0zOTInLFxuICAweGIzOTI6ICdTa2VpbjEwMjQtNDAwJyxcbiAgMHhiMzkzOiAnU2tlaW4xMDI0LTQwOCcsXG4gIDB4YjM5NDogJ1NrZWluMTAyNC00MTYnLFxuICAweGIzOTU6ICdTa2VpbjEwMjQtNDI0JyxcbiAgMHhiMzk2OiAnU2tlaW4xMDI0LTQzMicsXG4gIDB4YjM5NzogJ1NrZWluMTAyNC00NDAnLFxuICAweGIzOTg6ICdTa2VpbjEwMjQtNDQ4JyxcbiAgMHhiMzk5OiAnU2tlaW4xMDI0LTQ1NicsXG4gIDB4YjM5YTogJ1NrZWluMTAyNC00NjQnLFxuICAweGIzOWI6ICdTa2VpbjEwMjQtNDcyJyxcbiAgMHhiMzljOiAnU2tlaW4xMDI0LTQ4MCcsXG4gIDB4YjM5ZDogJ1NrZWluMTAyNC00ODgnLFxuICAweGIzOWU6ICdTa2VpbjEwMjQtNDk2JyxcbiAgMHhiMzlmOiAnU2tlaW4xMDI0LTUwNCcsXG4gIDB4YjNhMDogJ1NrZWluMTAyNC01MTInLFxuICAweGIzYTE6ICdTa2VpbjEwMjQtNTIwJyxcbiAgMHhiM2EyOiAnU2tlaW4xMDI0LTUyOCcsXG4gIDB4YjNhMzogJ1NrZWluMTAyNC01MzYnLFxuICAweGIzYTQ6ICdTa2VpbjEwMjQtNTQ0JyxcbiAgMHhiM2E1OiAnU2tlaW4xMDI0LTU1MicsXG4gIDB4YjNhNjogJ1NrZWluMTAyNC01NjAnLFxuICAweGIzYTc6ICdTa2VpbjEwMjQtNTY4JyxcbiAgMHhiM2E4OiAnU2tlaW4xMDI0LTU3NicsXG4gIDB4YjNhOTogJ1NrZWluMTAyNC01ODQnLFxuICAweGIzYWE6ICdTa2VpbjEwMjQtNTkyJyxcbiAgMHhiM2FiOiAnU2tlaW4xMDI0LTYwMCcsXG4gIDB4YjNhYzogJ1NrZWluMTAyNC02MDgnLFxuICAweGIzYWQ6ICdTa2VpbjEwMjQtNjE2JyxcbiAgMHhiM2FlOiAnU2tlaW4xMDI0LTYyNCcsXG4gIDB4YjNhZjogJ1NrZWluMTAyNC02MzInLFxuICAweGIzYjA6ICdTa2VpbjEwMjQtNjQwJyxcbiAgMHhiM2IxOiAnU2tlaW4xMDI0LTY0OCcsXG4gIDB4YjNiMjogJ1NrZWluMTAyNC02NTYnLFxuICAweGIzYjM6ICdTa2VpbjEwMjQtNjY0JyxcbiAgMHhiM2I0OiAnU2tlaW4xMDI0LTY3MicsXG4gIDB4YjNiNTogJ1NrZWluMTAyNC02ODAnLFxuICAweGIzYjY6ICdTa2VpbjEwMjQtNjg4JyxcbiAgMHhiM2I3OiAnU2tlaW4xMDI0LTY5NicsXG4gIDB4YjNiODogJ1NrZWluMTAyNC03MDQnLFxuICAweGIzYjk6ICdTa2VpbjEwMjQtNzEyJyxcbiAgMHhiM2JhOiAnU2tlaW4xMDI0LTcyMCcsXG4gIDB4YjNiYjogJ1NrZWluMTAyNC03MjgnLFxuICAweGIzYmM6ICdTa2VpbjEwMjQtNzM2JyxcbiAgMHhiM2JkOiAnU2tlaW4xMDI0LTc0NCcsXG4gIDB4YjNiZTogJ1NrZWluMTAyNC03NTInLFxuICAweGIzYmY6ICdTa2VpbjEwMjQtNzYwJyxcbiAgMHhiM2MwOiAnU2tlaW4xMDI0LTc2OCcsXG4gIDB4YjNjMTogJ1NrZWluMTAyNC03NzYnLFxuICAweGIzYzI6ICdTa2VpbjEwMjQtNzg0JyxcbiAgMHhiM2MzOiAnU2tlaW4xMDI0LTc5MicsXG4gIDB4YjNjNDogJ1NrZWluMTAyNC04MDAnLFxuICAweGIzYzU6ICdTa2VpbjEwMjQtODA4JyxcbiAgMHhiM2M2OiAnU2tlaW4xMDI0LTgxNicsXG4gIDB4YjNjNzogJ1NrZWluMTAyNC04MjQnLFxuICAweGIzYzg6ICdTa2VpbjEwMjQtODMyJyxcbiAgMHhiM2M5OiAnU2tlaW4xMDI0LTg0MCcsXG4gIDB4YjNjYTogJ1NrZWluMTAyNC04NDgnLFxuICAweGIzY2I6ICdTa2VpbjEwMjQtODU2JyxcbiAgMHhiM2NjOiAnU2tlaW4xMDI0LTg2NCcsXG4gIDB4YjNjZDogJ1NrZWluMTAyNC04NzInLFxuICAweGIzY2U6ICdTa2VpbjEwMjQtODgwJyxcbiAgMHhiM2NmOiAnU2tlaW4xMDI0LTg4OCcsXG4gIDB4YjNkMDogJ1NrZWluMTAyNC04OTYnLFxuICAweGIzZDE6ICdTa2VpbjEwMjQtOTA0JyxcbiAgMHhiM2QyOiAnU2tlaW4xMDI0LTkxMicsXG4gIDB4YjNkMzogJ1NrZWluMTAyNC05MjAnLFxuICAweGIzZDQ6ICdTa2VpbjEwMjQtOTI4JyxcbiAgMHhiM2Q1OiAnU2tlaW4xMDI0LTkzNicsXG4gIDB4YjNkNjogJ1NrZWluMTAyNC05NDQnLFxuICAweGIzZDc6ICdTa2VpbjEwMjQtOTUyJyxcbiAgMHhiM2Q4OiAnU2tlaW4xMDI0LTk2MCcsXG4gIDB4YjNkOTogJ1NrZWluMTAyNC05NjgnLFxuICAweGIzZGE6ICdTa2VpbjEwMjQtOTc2JyxcbiAgMHhiM2RiOiAnU2tlaW4xMDI0LTk4NCcsXG4gIDB4YjNkYzogJ1NrZWluMTAyNC05OTInLFxuICAweGIzZGQ6ICdTa2VpbjEwMjQtMTAwMCcsXG4gIDB4YjNkZTogJ1NrZWluMTAyNC0xMDA4JyxcbiAgMHhiM2RmOiAnU2tlaW4xMDI0LTEwMTYnLFxuICAweGIzZTA6ICdTa2VpbjEwMjQtMTAyNCdcbn0pXG5cbmV4cG9ydHMuZGVmYXVsdExlbmd0aHMgPSBPYmplY3QuZnJlZXplKHtcbiAgMHgxMTogMjAsXG4gIDB4MTI6IDMyLFxuICAweDEzOiA2NCxcbiAgMHg1NjogMzIsXG4gIDB4MTc6IDI4LFxuICAweDE2OiAzMixcbiAgMHgxNTogNDgsXG4gIDB4MTQ6IDY0LFxuICAweDE4OiAzMixcbiAgMHgxOTogNjQsXG4gIDB4MUE6IDI4LFxuICAweDFCOiAzMixcbiAgMHgxQzogNDgsXG4gIDB4MUQ6IDY0LFxuICAweDIyOiAzMixcblxuICAweGIyMDE6IDB4MDEsXG4gIDB4YjIwMjogMHgwMixcbiAgMHhiMjAzOiAweDAzLFxuICAweGIyMDQ6IDB4MDQsXG4gIDB4YjIwNTogMHgwNSxcbiAgMHhiMjA2OiAweDA2LFxuICAweGIyMDc6IDB4MDcsXG4gIDB4YjIwODogMHgwOCxcbiAgMHhiMjA5OiAweDA5LFxuICAweGIyMGE6IDB4MGEsXG4gIDB4YjIwYjogMHgwYixcbiAgMHhiMjBjOiAweDBjLFxuICAweGIyMGQ6IDB4MGQsXG4gIDB4YjIwZTogMHgwZSxcbiAgMHhiMjBmOiAweDBmLFxuICAweGIyMTA6IDB4MTAsXG4gIDB4YjIxMTogMHgxMSxcbiAgMHhiMjEyOiAweDEyLFxuICAweGIyMTM6IDB4MTMsXG4gIDB4YjIxNDogMHgxNCxcbiAgMHhiMjE1OiAweDE1LFxuICAweGIyMTY6IDB4MTYsXG4gIDB4YjIxNzogMHgxNyxcbiAgMHhiMjE4OiAweDE4LFxuICAweGIyMTk6IDB4MTksXG4gIDB4YjIxYTogMHgxYSxcbiAgMHhiMjFiOiAweDFiLFxuICAweGIyMWM6IDB4MWMsXG4gIDB4YjIxZDogMHgxZCxcbiAgMHhiMjFlOiAweDFlLFxuICAweGIyMWY6IDB4MWYsXG4gIDB4YjIyMDogMHgyMCxcbiAgMHhiMjIxOiAweDIxLFxuICAweGIyMjI6IDB4MjIsXG4gIDB4YjIyMzogMHgyMyxcbiAgMHhiMjI0OiAweDI0LFxuICAweGIyMjU6IDB4MjUsXG4gIDB4YjIyNjogMHgyNixcbiAgMHhiMjI3OiAweDI3LFxuICAweGIyMjg6IDB4MjgsXG4gIDB4YjIyOTogMHgyOSxcbiAgMHhiMjJhOiAweDJhLFxuICAweGIyMmI6IDB4MmIsXG4gIDB4YjIyYzogMHgyYyxcbiAgMHhiMjJkOiAweDJkLFxuICAweGIyMmU6IDB4MmUsXG4gIDB4YjIyZjogMHgyZixcbiAgMHhiMjMwOiAweDMwLFxuICAweGIyMzE6IDB4MzEsXG4gIDB4YjIzMjogMHgzMixcbiAgMHhiMjMzOiAweDMzLFxuICAweGIyMzQ6IDB4MzQsXG4gIDB4YjIzNTogMHgzNSxcbiAgMHhiMjM2OiAweDM2LFxuICAweGIyMzc6IDB4MzcsXG4gIDB4YjIzODogMHgzOCxcbiAgMHhiMjM5OiAweDM5LFxuICAweGIyM2E6IDB4M2EsXG4gIDB4YjIzYjogMHgzYixcbiAgMHhiMjNjOiAweDNjLFxuICAweGIyM2Q6IDB4M2QsXG4gIDB4YjIzZTogMHgzZSxcbiAgMHhiMjNmOiAweDNmLFxuICAweGIyNDA6IDB4NDAsXG4gIDB4YjI0MTogMHgwMSxcbiAgMHhiMjQyOiAweDAyLFxuICAweGIyNDM6IDB4MDMsXG4gIDB4YjI0NDogMHgwNCxcbiAgMHhiMjQ1OiAweDA1LFxuICAweGIyNDY6IDB4MDYsXG4gIDB4YjI0NzogMHgwNyxcbiAgMHhiMjQ4OiAweDA4LFxuICAweGIyNDk6IDB4MDksXG4gIDB4YjI0YTogMHgwYSxcbiAgMHhiMjRiOiAweDBiLFxuICAweGIyNGM6IDB4MGMsXG4gIDB4YjI0ZDogMHgwZCxcbiAgMHhiMjRlOiAweDBlLFxuICAweGIyNGY6IDB4MGYsXG4gIDB4YjI1MDogMHgxMCxcbiAgMHhiMjUxOiAweDExLFxuICAweGIyNTI6IDB4MTIsXG4gIDB4YjI1MzogMHgxMyxcbiAgMHhiMjU0OiAweDE0LFxuICAweGIyNTU6IDB4MTUsXG4gIDB4YjI1NjogMHgxNixcbiAgMHhiMjU3OiAweDE3LFxuICAweGIyNTg6IDB4MTgsXG4gIDB4YjI1OTogMHgxOSxcbiAgMHhiMjVhOiAweDFhLFxuICAweGIyNWI6IDB4MWIsXG4gIDB4YjI1YzogMHgxYyxcbiAgMHhiMjVkOiAweDFkLFxuICAweGIyNWU6IDB4MWUsXG4gIDB4YjI1ZjogMHgxZixcbiAgMHhiMjYwOiAweDIwLFxuICAweGIzMDE6IDB4MDEsXG4gIDB4YjMwMjogMHgwMixcbiAgMHhiMzAzOiAweDAzLFxuICAweGIzMDQ6IDB4MDQsXG4gIDB4YjMwNTogMHgwNSxcbiAgMHhiMzA2OiAweDA2LFxuICAweGIzMDc6IDB4MDcsXG4gIDB4YjMwODogMHgwOCxcbiAgMHhiMzA5OiAweDA5LFxuICAweGIzMGE6IDB4MGEsXG4gIDB4YjMwYjogMHgwYixcbiAgMHhiMzBjOiAweDBjLFxuICAweGIzMGQ6IDB4MGQsXG4gIDB4YjMwZTogMHgwZSxcbiAgMHhiMzBmOiAweDBmLFxuICAweGIzMTA6IDB4MTAsXG4gIDB4YjMxMTogMHgxMSxcbiAgMHhiMzEyOiAweDEyLFxuICAweGIzMTM6IDB4MTMsXG4gIDB4YjMxNDogMHgxNCxcbiAgMHhiMzE1OiAweDE1LFxuICAweGIzMTY6IDB4MTYsXG4gIDB4YjMxNzogMHgxNyxcbiAgMHhiMzE4OiAweDE4LFxuICAweGIzMTk6IDB4MTksXG4gIDB4YjMxYTogMHgxYSxcbiAgMHhiMzFiOiAweDFiLFxuICAweGIzMWM6IDB4MWMsXG4gIDB4YjMxZDogMHgxZCxcbiAgMHhiMzFlOiAweDFlLFxuICAweGIzMWY6IDB4MWYsXG4gIDB4YjMyMDogMHgyMCxcbiAgMHhiMzIxOiAweDAxLFxuICAweGIzMjI6IDB4MDIsXG4gIDB4YjMyMzogMHgwMyxcbiAgMHhiMzI0OiAweDA0LFxuICAweGIzMjU6IDB4MDUsXG4gIDB4YjMyNjogMHgwNixcbiAgMHhiMzI3OiAweDA3LFxuICAweGIzMjg6IDB4MDgsXG4gIDB4YjMyOTogMHgwOSxcbiAgMHhiMzJhOiAweDBhLFxuICAweGIzMmI6IDB4MGIsXG4gIDB4YjMyYzogMHgwYyxcbiAgMHhiMzJkOiAweDBkLFxuICAweGIzMmU6IDB4MGUsXG4gIDB4YjMyZjogMHgwZixcbiAgMHhiMzMwOiAweDEwLFxuICAweGIzMzE6IDB4MTEsXG4gIDB4YjMzMjogMHgxMixcbiAgMHhiMzMzOiAweDEzLFxuICAweGIzMzQ6IDB4MTQsXG4gIDB4YjMzNTogMHgxNSxcbiAgMHhiMzM2OiAweDE2LFxuICAweGIzMzc6IDB4MTcsXG4gIDB4YjMzODogMHgxOCxcbiAgMHhiMzM5OiAweDE5LFxuICAweGIzM2E6IDB4MWEsXG4gIDB4YjMzYjogMHgxYixcbiAgMHhiMzNjOiAweDFjLFxuICAweGIzM2Q6IDB4MWQsXG4gIDB4YjMzZTogMHgxZSxcbiAgMHhiMzNmOiAweDFmLFxuICAweGIzNDA6IDB4MjAsXG4gIDB4YjM0MTogMHgyMSxcbiAgMHhiMzQyOiAweDIyLFxuICAweGIzNDM6IDB4MjMsXG4gIDB4YjM0NDogMHgyNCxcbiAgMHhiMzQ1OiAweDI1LFxuICAweGIzNDY6IDB4MjYsXG4gIDB4YjM0NzogMHgyNyxcbiAgMHhiMzQ4OiAweDI4LFxuICAweGIzNDk6IDB4MjksXG4gIDB4YjM0YTogMHgyYSxcbiAgMHhiMzRiOiAweDJiLFxuICAweGIzNGM6IDB4MmMsXG4gIDB4YjM0ZDogMHgyZCxcbiAgMHhiMzRlOiAweDJlLFxuICAweGIzNGY6IDB4MmYsXG4gIDB4YjM1MDogMHgzMCxcbiAgMHhiMzUxOiAweDMxLFxuICAweGIzNTI6IDB4MzIsXG4gIDB4YjM1MzogMHgzMyxcbiAgMHhiMzU0OiAweDM0LFxuICAweGIzNTU6IDB4MzUsXG4gIDB4YjM1NjogMHgzNixcbiAgMHhiMzU3OiAweDM3LFxuICAweGIzNTg6IDB4MzgsXG4gIDB4YjM1OTogMHgzOSxcbiAgMHhiMzVhOiAweDNhLFxuICAweGIzNWI6IDB4M2IsXG4gIDB4YjM1YzogMHgzYyxcbiAgMHhiMzVkOiAweDNkLFxuICAweGIzNWU6IDB4M2UsXG4gIDB4YjM1ZjogMHgzZixcbiAgMHhiMzYwOiAweDQwLFxuICAweGIzNjE6IDB4MDEsXG4gIDB4YjM2MjogMHgwMixcbiAgMHhiMzYzOiAweDAzLFxuICAweGIzNjQ6IDB4MDQsXG4gIDB4YjM2NTogMHgwNSxcbiAgMHhiMzY2OiAweDA2LFxuICAweGIzNjc6IDB4MDcsXG4gIDB4YjM2ODogMHgwOCxcbiAgMHhiMzY5OiAweDA5LFxuICAweGIzNmE6IDB4MGEsXG4gIDB4YjM2YjogMHgwYixcbiAgMHhiMzZjOiAweDBjLFxuICAweGIzNmQ6IDB4MGQsXG4gIDB4YjM2ZTogMHgwZSxcbiAgMHhiMzZmOiAweDBmLFxuICAweGIzNzA6IDB4MTAsXG4gIDB4YjM3MTogMHgxMSxcbiAgMHhiMzcyOiAweDEyLFxuICAweGIzNzM6IDB4MTMsXG4gIDB4YjM3NDogMHgxNCxcbiAgMHhiMzc1OiAweDE1LFxuICAweGIzNzY6IDB4MTYsXG4gIDB4YjM3NzogMHgxNyxcbiAgMHhiMzc4OiAweDE4LFxuICAweGIzNzk6IDB4MTksXG4gIDB4YjM3YTogMHgxYSxcbiAgMHhiMzdiOiAweDFiLFxuICAweGIzN2M6IDB4MWMsXG4gIDB4YjM3ZDogMHgxZCxcbiAgMHhiMzdlOiAweDFlLFxuICAweGIzN2Y6IDB4MWYsXG4gIDB4YjM4MDogMHgyMCxcbiAgMHhiMzgxOiAweDIxLFxuICAweGIzODI6IDB4MjIsXG4gIDB4YjM4MzogMHgyMyxcbiAgMHhiMzg0OiAweDI0LFxuICAweGIzODU6IDB4MjUsXG4gIDB4YjM4NjogMHgyNixcbiAgMHhiMzg3OiAweDI3LFxuICAweGIzODg6IDB4MjgsXG4gIDB4YjM4OTogMHgyOSxcbiAgMHhiMzhhOiAweDJhLFxuICAweGIzOGI6IDB4MmIsXG4gIDB4YjM4YzogMHgyYyxcbiAgMHhiMzhkOiAweDJkLFxuICAweGIzOGU6IDB4MmUsXG4gIDB4YjM4ZjogMHgyZixcbiAgMHhiMzkwOiAweDMwLFxuICAweGIzOTE6IDB4MzEsXG4gIDB4YjM5MjogMHgzMixcbiAgMHhiMzkzOiAweDMzLFxuICAweGIzOTQ6IDB4MzQsXG4gIDB4YjM5NTogMHgzNSxcbiAgMHhiMzk2OiAweDM2LFxuICAweGIzOTc6IDB4MzcsXG4gIDB4YjM5ODogMHgzOCxcbiAgMHhiMzk5OiAweDM5LFxuICAweGIzOWE6IDB4M2EsXG4gIDB4YjM5YjogMHgzYixcbiAgMHhiMzljOiAweDNjLFxuICAweGIzOWQ6IDB4M2QsXG4gIDB4YjM5ZTogMHgzZSxcbiAgMHhiMzlmOiAweDNmLFxuICAweGIzYTA6IDB4NDAsXG4gIDB4YjNhMTogMHg0MSxcbiAgMHhiM2EyOiAweDQyLFxuICAweGIzYTM6IDB4NDMsXG4gIDB4YjNhNDogMHg0NCxcbiAgMHhiM2E1OiAweDQ1LFxuICAweGIzYTY6IDB4NDYsXG4gIDB4YjNhNzogMHg0NyxcbiAgMHhiM2E4OiAweDQ4LFxuICAweGIzYTk6IDB4NDksXG4gIDB4YjNhYTogMHg0YSxcbiAgMHhiM2FiOiAweDRiLFxuICAweGIzYWM6IDB4NGMsXG4gIDB4YjNhZDogMHg0ZCxcbiAgMHhiM2FlOiAweDRlLFxuICAweGIzYWY6IDB4NGYsXG4gIDB4YjNiMDogMHg1MCxcbiAgMHhiM2IxOiAweDUxLFxuICAweGIzYjI6IDB4NTIsXG4gIDB4YjNiMzogMHg1MyxcbiAgMHhiM2I0OiAweDU0LFxuICAweGIzYjU6IDB4NTUsXG4gIDB4YjNiNjogMHg1NixcbiAgMHhiM2I3OiAweDU3LFxuICAweGIzYjg6IDB4NTgsXG4gIDB4YjNiOTogMHg1OSxcbiAgMHhiM2JhOiAweDVhLFxuICAweGIzYmI6IDB4NWIsXG4gIDB4YjNiYzogMHg1YyxcbiAgMHhiM2JkOiAweDVkLFxuICAweGIzYmU6IDB4NWUsXG4gIDB4YjNiZjogMHg1ZixcbiAgMHhiM2MwOiAweDYwLFxuICAweGIzYzE6IDB4NjEsXG4gIDB4YjNjMjogMHg2MixcbiAgMHhiM2MzOiAweDYzLFxuICAweGIzYzQ6IDB4NjQsXG4gIDB4YjNjNTogMHg2NSxcbiAgMHhiM2M2OiAweDY2LFxuICAweGIzYzc6IDB4NjcsXG4gIDB4YjNjODogMHg2OCxcbiAgMHhiM2M5OiAweDY5LFxuICAweGIzY2E6IDB4NmEsXG4gIDB4YjNjYjogMHg2YixcbiAgMHhiM2NjOiAweDZjLFxuICAweGIzY2Q6IDB4NmQsXG4gIDB4YjNjZTogMHg2ZSxcbiAgMHhiM2NmOiAweDZmLFxuICAweGIzZDA6IDB4NzAsXG4gIDB4YjNkMTogMHg3MSxcbiAgMHhiM2QyOiAweDcyLFxuICAweGIzZDM6IDB4NzMsXG4gIDB4YjNkNDogMHg3NCxcbiAgMHhiM2Q1OiAweDc1LFxuICAweGIzZDY6IDB4NzYsXG4gIDB4YjNkNzogMHg3NyxcbiAgMHhiM2Q4OiAweDc4LFxuICAweGIzZDk6IDB4NzksXG4gIDB4YjNkYTogMHg3YSxcbiAgMHhiM2RiOiAweDdiLFxuICAweGIzZGM6IDB4N2MsXG4gIDB4YjNkZDogMHg3ZCxcbiAgMHhiM2RlOiAweDdlLFxuICAweGIzZGY6IDB4N2YsXG4gIDB4YjNlMDogMHg4MFxufSlcbiIsIi8qKlxuICogTXVsdGloYXNoIGltcGxlbWVudGF0aW9uIGluIEphdmFTY3JpcHQuXG4gKlxuICogQG1vZHVsZSBtdWx0aWhhc2hcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgbXVsdGliYXNlID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCBjcyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuZXhwb3J0cy5uYW1lcyA9IGNzLm5hbWVzXG5leHBvcnRzLmNvZGVzID0gY3MuY29kZXNcbmV4cG9ydHMuZGVmYXVsdExlbmd0aHMgPSBjcy5kZWZhdWx0TGVuZ3Roc1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIG11bHRpaGFzaCB0byBhIGhleCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0hleFN0cmluZyA9IGZ1bmN0aW9uIHRvSGV4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGhhc2gpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIHBhc3NlZCBhIGJ1ZmZlcicpXG4gIH1cblxuICByZXR1cm4gaGFzaC50b1N0cmluZygnaGV4Jylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBoZXggZW5jb2RlZCBzdHJpbmcgdG8gYSBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZnJvbUhleFN0cmluZyA9IGZ1bmN0aW9uIGZyb21IZXhTdHJpbmcgKGhhc2gpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2gsICdoZXgnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIG11bHRpaGFzaCB0byBhIGJhc2U1OCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0I1OFN0cmluZyA9IGZ1bmN0aW9uIHRvQjU4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGhhc2gpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIHBhc3NlZCBhIGJ1ZmZlcicpXG4gIH1cblxuICByZXR1cm4gbXVsdGliYXNlLmVuY29kZSgnYmFzZTU4YnRjJywgaGFzaCkudG9TdHJpbmcoKS5zbGljZSgxKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGJhc2U1OCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZnJvbUI1OFN0cmluZyA9IGZ1bmN0aW9uIGZyb21CNThTdHJpbmcgKGhhc2gpIHtcbiAgbGV0IGVuY29kZWQgPSBoYXNoXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaGFzaCkpIHtcbiAgICBlbmNvZGVkID0gaGFzaC50b1N0cmluZygpXG4gIH1cblxuICByZXR1cm4gbXVsdGliYXNlLmRlY29kZSgneicgKyBlbmNvZGVkKVxufVxuXG4vKipcbiAqIERlY29kZSBhIGhhc2ggZnJvbSB0aGUgZ2l2ZW4gbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm5zIHt7Y29kZTogbnVtYmVyLCBuYW1lOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyLCBkaWdlc3Q6IEJ1ZmZlcn19IHJlc3VsdFxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZSAoYnVmKSB7XG4gIGlmICghKEJ1ZmZlci5pc0J1ZmZlcihidWYpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKGJ1Zi5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggdG9vIHNob3J0LiBtdXN0IGJlID4gMiBieXRlcy4nKVxuICB9XG5cbiAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoYnVmKVxuICBpZiAoIWV4cG9ydHMuaXNWYWxpZENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCB1bmtub3duIGZ1bmN0aW9uIGNvZGU6IDB4JHtjb2RlLnRvU3RyaW5nKDE2KX1gKVxuICB9XG4gIGJ1ZiA9IGJ1Zi5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGNvbnN0IGxlbiA9IHZhcmludC5kZWNvZGUoYnVmKVxuICBpZiAobGVuIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIGludmFsaWQgbGVuZ3RoOiAke2xlbn1gKVxuICB9XG4gIGJ1ZiA9IGJ1Zi5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGlmIChidWYubGVuZ3RoICE9PSBsZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCBsZW5ndGggaW5jb25zaXN0ZW50OiAweCR7YnVmLnRvU3RyaW5nKCdoZXgnKX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlOiBjb2RlLFxuICAgIG5hbWU6IGNzLmNvZGVzW2NvZGVdLFxuICAgIGxlbmd0aDogbGVuLFxuICAgIGRpZ2VzdDogYnVmXG4gIH1cbn1cblxuLyoqXG4gKiAgRW5jb2RlIGEgaGFzaCBkaWdlc3QgYWxvbmcgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGNvZGUuXG4gKlxuICogPiAqKk5vdGU6KiogdGhlIGxlbmd0aCBpcyBkZXJpdmVkIGZyb20gdGhlIGxlbmd0aCBvZiB0aGUgZGlnZXN0IGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGlnZXN0XG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKGRpZ2VzdCwgY29kZSwgbGVuZ3RoKSB7XG4gIGlmICghZGlnZXN0IHx8IGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIGVuY29kZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJnczogZGlnZXN0LCBjb2RlJylcbiAgfVxuXG4gIC8vIGVuc3VyZSBpdCdzIGEgaGFzaGZ1bmN0aW9uIGNvZGUuXG4gIGNvbnN0IGhhc2hmbiA9IGV4cG9ydHMuY29lcmNlQ29kZShjb2RlKVxuXG4gIGlmICghKEJ1ZmZlci5pc0J1ZmZlcihkaWdlc3QpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICBsZW5ndGggPSBkaWdlc3QubGVuZ3RoXG4gIH1cblxuICBpZiAobGVuZ3RoICYmIGRpZ2VzdC5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0IGxlbmd0aCBzaG91bGQgYmUgZXF1YWwgdG8gc3BlY2lmaWVkIGxlbmd0aC4nKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgIEJ1ZmZlci5mcm9tKHZhcmludC5lbmNvZGUoaGFzaGZuKSksXG4gICAgQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShsZW5ndGgpKSxcbiAgICBkaWdlc3RcbiAgXSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhhc2ggZnVuY3Rpb24gbmFtZSBpbnRvIHRoZSBtYXRjaGluZyBjb2RlLlxuICogSWYgcGFzc2VkIGEgbnVtYmVyIGl0IHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgaWYgaXQncyBhIHZhbGlkIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuY29lcmNlQ29kZSA9IGZ1bmN0aW9uIGNvZXJjZUNvZGUgKG5hbWUpIHtcbiAgbGV0IGNvZGUgPSBuYW1lXG5cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmIChjcy5uYW1lc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBoYXNoIGZ1bmN0aW9uIG5hbWVkOiAke25hbWV9YClcbiAgICB9XG4gICAgY29kZSA9IGNzLm5hbWVzW25hbWVdXG4gIH1cblxuICBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBIYXNoIGZ1bmN0aW9uIGNvZGUgc2hvdWxkIGJlIGEgbnVtYmVyLiBHb3Q6ICR7Y29kZX1gKVxuICB9XG5cbiAgaWYgKGNzLmNvZGVzW2NvZGVdID09PSB1bmRlZmluZWQgJiYgIWV4cG9ydHMuaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZnVuY3Rpb24gY29kZTogJHtjb2RlfWApXG4gIH1cblxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIENoZWNrcyB3ZXRoZXIgYSBjb2RlIGlzIHBhcnQgb2YgdGhlIGFwcCByYW5nZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0FwcENvZGUgPSBmdW5jdGlvbiBhcHBDb2RlIChjb2RlKSB7XG4gIHJldHVybiBjb2RlID4gMCAmJiBjb2RlIDwgMHgxMFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgbXVsdGloYXNoIGNvZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRDb2RlID0gZnVuY3Rpb24gdmFsaWRDb2RlIChjb2RlKSB7XG4gIGlmIChleHBvcnRzLmlzQXBwQ29kZShjb2RlKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY3MuY29kZXNbY29kZV0pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGJ1ZmZlciBpcyBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXVsdGloYXNoXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlIChtdWx0aWhhc2gpIHtcbiAgZXhwb3J0cy5kZWNvZGUobXVsdGloYXNoKSAvLyB0aHJvd3MgaWYgYmFkLlxufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlXG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZpeCBmcm9tIGEgdmFsaWQgbXVsdGloYXNoLiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5wcmVmaXggPSBmdW5jdGlvbiBwcmVmaXggKG11bHRpaGFzaCkge1xuICB2YWxpZGF0ZShtdWx0aWhhc2gpXG5cbiAgcmV0dXJuIG11bHRpaGFzaC5zbGljZSgwLCAyKVxufVxuIiwiLy8gVGhpcyBhbHBoYWJldCB1c2VzIGEteiBBLVogMC05IF8tIHN5bWJvbHMuXG4vLyBTeW1ib2xzIGFyZSBnZW5lcmF0ZWQgZm9yIHNtYWxsZXIgc2l6ZS5cbi8vIC1fenl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmE5ODc2NTQzMjEwWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFcbnZhciB1cmwgPSAnLV8nXG4vLyBMb29wIGZyb20gMzYgdG8gMCAoZnJvbSB6IHRvIGEgYW5kIDkgdG8gMCBpbiBCYXNlMzYpLlxudmFyIGkgPSAzNlxud2hpbGUgKGktLSkge1xuICAvLyAzNiBpcyByYWRpeC4gTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZygzNikgcmV0dXJucyBudW1iZXJcbiAgLy8gaW4gQmFzZTM2IHJlcHJlc2VudGF0aW9uLiBCYXNlMzYgaXMgbGlrZSBoZXgsIGJ1dCBpdCB1c2VzIDDigJM5IGFuZCBhLXouXG4gIHVybCArPSBpLnRvU3RyaW5nKDM2KVxufVxuLy8gTG9vcCBmcm9tIDM2IHRvIDEwIChmcm9tIFogdG8gQSBpbiBCYXNlMzYpLlxuaSA9IDM2XG53aGlsZSAoaS0tIC0gMTApIHtcbiAgdXJsICs9IGkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKClcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBVUkwtZnJpZW5kbHkgdW5pcXVlIElELiBUaGlzIG1ldGhvZCB1c2Ugbm9uLXNlY3VyZSBwcmVkaWN0YWJsZVxuICogcmFuZG9tIGdlbmVyYXRvciB3aXRoIGJpZ2dlciBjb2xsaXNpb24gcHJvYmFiaWxpdHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTIxXSBUaGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gSUQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBSYW5kb20gc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBuYW5vaWQgPSByZXF1aXJlKCduYW5vaWQvbm9uLXNlY3VyZScpXG4gKiBtb2RlbC5pZCA9IG5hbm9pZCgpIC8vPT4gXCJVYWtnYl9KNW05Zy0wSkRNYmNKcUxcIlxuICpcbiAqIEBuYW1lIG5vblNlY3VyZVxuICogQGZ1bmN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgdmFyIGlkID0gJydcbiAgaSA9IHNpemUgfHwgMjFcbiAgLy8gQ29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKWBcbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIGB8IDBgIGlzIGNvbXBhY3QgYW5kIGZhc3RlciBhbHRlcm5hdGl2ZSBmb3IgYE1hdGguZmxvb3IoKWBcbiAgICBpZCArPSB1cmxbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbiIsInZhciBsb3dlckNhc2UgPSByZXF1aXJlKCdsb3dlci1jYXNlJylcblxudmFyIE5PTl9XT1JEX1JFR0VYUCA9IHJlcXVpcmUoJy4vdmVuZG9yL25vbi13b3JkLXJlZ2V4cCcpXG52YXIgQ0FNRUxfQ0FTRV9SRUdFWFAgPSByZXF1aXJlKCcuL3ZlbmRvci9jYW1lbC1jYXNlLXJlZ2V4cCcpXG52YXIgQ0FNRUxfQ0FTRV9VUFBFUl9SRUdFWFAgPSByZXF1aXJlKCcuL3ZlbmRvci9jYW1lbC1jYXNlLXVwcGVyLXJlZ2V4cCcpXG5cbi8qKlxuICogU2VudGVuY2UgY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHBhcmFtICB7c3RyaW5nfSBsb2NhbGVcbiAqIEBwYXJhbSAge3N0cmluZ30gcmVwbGFjZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBsb2NhbGUsIHJlcGxhY2VtZW50KSB7XG4gIGlmIChzdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgcmVwbGFjZW1lbnQgPSB0eXBlb2YgcmVwbGFjZW1lbnQgIT09ICdzdHJpbmcnID8gJyAnIDogcmVwbGFjZW1lbnRcblxuICBmdW5jdGlvbiByZXBsYWNlIChtYXRjaCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSAodmFsdWUubGVuZ3RoIC0gbWF0Y2gubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcGxhY2VtZW50XG4gIH1cblxuICBzdHIgPSBTdHJpbmcoc3RyKVxuICAgIC8vIFN1cHBvcnQgY2FtZWwgY2FzZSAoXCJjYW1lbENhc2VcIiAtPiBcImNhbWVsIENhc2VcIikuXG4gICAgLnJlcGxhY2UoQ0FNRUxfQ0FTRV9SRUdFWFAsICckMSAkMicpXG4gICAgLy8gU3VwcG9ydCBvZGQgY2FtZWwgY2FzZSAoXCJDQU1FTENhc2VcIiAtPiBcIkNBTUVMIENhc2VcIikuXG4gICAgLnJlcGxhY2UoQ0FNRUxfQ0FTRV9VUFBFUl9SRUdFWFAsICckMSAkMicpXG4gICAgLy8gUmVtb3ZlIGFsbCBub24td29yZCBjaGFyYWN0ZXJzIGFuZCByZXBsYWNlIHdpdGggYSBzaW5nbGUgc3BhY2UuXG4gICAgLnJlcGxhY2UoTk9OX1dPUkRfUkVHRVhQLCByZXBsYWNlKVxuXG4gIC8vIExvd2VyIGNhc2UgdGhlIGVudGlyZSBzdHJpbmcuXG4gIHJldHVybiBsb3dlckNhc2Uoc3RyLCBsb2NhbGUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IC8oW2EtelxceEI1XFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJBRlxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0ItXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxRDAwLVxcdTFEMkJcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEOUFcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTg0XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdCXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2RlxcdUE3NzEtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI2MC1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBMC05XFx4QjJcXHhCM1xceEI5XFx4QkMtXFx4QkVcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcXHUwN0MwLVxcdTA3QzlcXHUwOTY2LVxcdTA5NkZcXHUwOUU2LVxcdTA5RUZcXHUwOUY0LVxcdTA5RjlcXHUwQTY2LVxcdTBBNkZcXHUwQUU2LVxcdTBBRUZcXHUwQjY2LVxcdTBCNkZcXHUwQjcyLVxcdTBCNzdcXHUwQkU2LVxcdTBCRjJcXHUwQzY2LVxcdTBDNkZcXHUwQzc4LVxcdTBDN0VcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENzVcXHUwREU2LVxcdTBERUZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMzNcXHUxMDQwLVxcdTEwNDlcXHUxMDkwLVxcdTEwOTlcXHUxMzY5LVxcdTEzN0NcXHUxNkVFLVxcdTE2RjBcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxOTQ2LVxcdTE5NEZcXHUxOUQwLVxcdTE5REFcXHUxQTgwLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQjUwLVxcdTFCNTlcXHUxQkIwLVxcdTFCQjlcXHUxQzQwLVxcdTFDNDlcXHUxQzUwLVxcdTFDNTlcXHUyMDcwXFx1MjA3NC1cXHUyMDc5XFx1MjA4MC1cXHUyMDg5XFx1MjE1MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg5XFx1MjQ2MC1cXHUyNDlCXFx1MjRFQS1cXHUyNEZGXFx1Mjc3Ni1cXHUyNzkzXFx1MkNGRFxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0FcXHUzMTkyLVxcdTMxOTVcXHUzMjIwLVxcdTMyMjlcXHUzMjQ4LVxcdTMyNEZcXHUzMjUxLVxcdTMyNUZcXHUzMjgwLVxcdTMyODlcXHUzMkIxLVxcdTMyQkZcXHVBNjIwLVxcdUE2MjlcXHVBNkU2LVxcdUE2RUZcXHVBODMwLVxcdUE4MzVcXHVBOEQwLVxcdUE4RDlcXHVBOTAwLVxcdUE5MDlcXHVBOUQwLVxcdUE5RDlcXHVBOUYwLVxcdUE5RjlcXHVBQTUwLVxcdUFBNTlcXHVBQkYwLVxcdUFCRjlcXHVGRjEwLVxcdUZGMTldKShbQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE4M1xcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FEXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQV0pL2dcbiIsIm1vZHVsZS5leHBvcnRzID0gLyhbQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE4M1xcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FEXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQV0pKFtBLVpcXHhDMC1cXHhENlxceEQ4LVxceERFXFx1MDEwMFxcdTAxMDJcXHUwMTA0XFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAxMEVcXHUwMTEwXFx1MDExMlxcdTAxMTRcXHUwMTE2XFx1MDExOFxcdTAxMUFcXHUwMTFDXFx1MDExRVxcdTAxMjBcXHUwMTIyXFx1MDEyNFxcdTAxMjZcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTJFXFx1MDEzMFxcdTAxMzJcXHUwMTM0XFx1MDEzNlxcdTAxMzlcXHUwMTNCXFx1MDEzRFxcdTAxM0ZcXHUwMTQxXFx1MDE0M1xcdTAxNDVcXHUwMTQ3XFx1MDE0QVxcdTAxNENcXHUwMTRFXFx1MDE1MFxcdTAxNTJcXHUwMTU0XFx1MDE1NlxcdTAxNThcXHUwMTVBXFx1MDE1Q1xcdTAxNUVcXHUwMTYwXFx1MDE2MlxcdTAxNjRcXHUwMTY2XFx1MDE2OFxcdTAxNkFcXHUwMTZDXFx1MDE2RVxcdTAxNzBcXHUwMTcyXFx1MDE3NFxcdTAxNzZcXHUwMTc4XFx1MDE3OVxcdTAxN0JcXHUwMTdEXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDN1xcdTAxQ0FcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjFcXHUwMUY0XFx1MDFGNi1cXHUwMUY4XFx1MDFGQVxcdTAxRkNcXHUwMUZFXFx1MDIwMFxcdTAyMDJcXHUwMjA0XFx1MDIwNlxcdTAyMDhcXHUwMjBBXFx1MDIwQ1xcdTAyMEVcXHUwMjEwXFx1MDIxMlxcdTAyMTRcXHUwMjE2XFx1MDIxOFxcdTAyMUFcXHUwMjFDXFx1MDIxRVxcdTAyMjBcXHUwMjIyXFx1MDIyNFxcdTAyMjZcXHUwMjI4XFx1MDIyQVxcdTAyMkNcXHUwMjJFXFx1MDIzMFxcdTAyMzJcXHUwMjNBXFx1MDIzQlxcdTAyM0RcXHUwMjNFXFx1MDI0MVxcdTAyNDMtXFx1MDI0NlxcdTAyNDhcXHUwMjRBXFx1MDI0Q1xcdTAyNEVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFXFx1MDM4RlxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBQlxcdTAzQ0ZcXHUwM0QyLVxcdTAzRDRcXHUwM0Q4XFx1MDNEQVxcdTAzRENcXHUwM0RFXFx1MDNFMFxcdTAzRTJcXHUwM0U0XFx1MDNFNlxcdTAzRThcXHUwM0VBXFx1MDNFQ1xcdTAzRUVcXHUwM0Y0XFx1MDNGN1xcdTAzRjlcXHUwM0ZBXFx1MDNGRC1cXHUwNDJGXFx1MDQ2MFxcdTA0NjJcXHUwNDY0XFx1MDQ2NlxcdTA0NjhcXHUwNDZBXFx1MDQ2Q1xcdTA0NkVcXHUwNDcwXFx1MDQ3MlxcdTA0NzRcXHUwNDc2XFx1MDQ3OFxcdTA0N0FcXHUwNDdDXFx1MDQ3RVxcdTA0ODBcXHUwNDhBXFx1MDQ4Q1xcdTA0OEVcXHUwNDkwXFx1MDQ5MlxcdTA0OTRcXHUwNDk2XFx1MDQ5OFxcdTA0OUFcXHUwNDlDXFx1MDQ5RVxcdTA0QTBcXHUwNEEyXFx1MDRBNFxcdTA0QTZcXHUwNEE4XFx1MDRBQVxcdTA0QUNcXHUwNEFFXFx1MDRCMFxcdTA0QjJcXHUwNEI0XFx1MDRCNlxcdTA0QjhcXHUwNEJBXFx1MDRCQ1xcdTA0QkVcXHUwNEMwXFx1MDRDMVxcdTA0QzNcXHUwNEM1XFx1MDRDN1xcdTA0QzlcXHUwNENCXFx1MDRDRFxcdTA0RDBcXHUwNEQyXFx1MDRENFxcdTA0RDZcXHUwNEQ4XFx1MDREQVxcdTA0RENcXHUwNERFXFx1MDRFMFxcdTA0RTJcXHUwNEU0XFx1MDRFNlxcdTA0RThcXHUwNEVBXFx1MDRFQ1xcdTA0RUVcXHUwNEYwXFx1MDRGMlxcdTA0RjRcXHUwNEY2XFx1MDRGOFxcdTA0RkFcXHUwNEZDXFx1MDRGRVxcdTA1MDBcXHUwNTAyXFx1MDUwNFxcdTA1MDZcXHUwNTA4XFx1MDUwQVxcdTA1MENcXHUwNTBFXFx1MDUxMFxcdTA1MTJcXHUwNTE0XFx1MDUxNlxcdTA1MThcXHUwNTFBXFx1MDUxQ1xcdTA1MUVcXHUwNTIwXFx1MDUyMlxcdTA1MjRcXHUwNTI2XFx1MDUyOFxcdTA1MkFcXHUwNTJDXFx1MDUyRVxcdTA1MzEtXFx1MDU1NlxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTNBMC1cXHUxM0Y1XFx1MUUwMFxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTFFMDhcXHUxRTBBXFx1MUUwQ1xcdTFFMEVcXHUxRTEwXFx1MUUxMlxcdTFFMTRcXHUxRTE2XFx1MUUxOFxcdTFFMUFcXHUxRTFDXFx1MUUxRVxcdTFFMjBcXHUxRTIyXFx1MUUyNFxcdTFFMjZcXHUxRTI4XFx1MUUyQVxcdTFFMkNcXHUxRTJFXFx1MUUzMFxcdTFFMzJcXHUxRTM0XFx1MUUzNlxcdTFFMzhcXHUxRTNBXFx1MUUzQ1xcdTFFM0VcXHUxRTQwXFx1MUU0MlxcdTFFNDRcXHUxRTQ2XFx1MUU0OFxcdTFFNEFcXHUxRTRDXFx1MUU0RVxcdTFFNTBcXHUxRTUyXFx1MUU1NFxcdTFFNTZcXHUxRTU4XFx1MUU1QVxcdTFFNUNcXHUxRTVFXFx1MUU2MFxcdTFFNjJcXHUxRTY0XFx1MUU2NlxcdTFFNjhcXHUxRTZBXFx1MUU2Q1xcdTFFNkVcXHUxRTcwXFx1MUU3MlxcdTFFNzRcXHUxRTc2XFx1MUU3OFxcdTFFN0FcXHUxRTdDXFx1MUU3RVxcdTFFODBcXHUxRTgyXFx1MUU4NFxcdTFFODZcXHUxRTg4XFx1MUU4QVxcdTFFOENcXHUxRThFXFx1MUU5MFxcdTFFOTJcXHUxRTk0XFx1MUU5RVxcdTFFQTBcXHUxRUEyXFx1MUVBNFxcdTFFQTZcXHUxRUE4XFx1MUVBQVxcdTFFQUNcXHUxRUFFXFx1MUVCMFxcdTFFQjJcXHUxRUI0XFx1MUVCNlxcdTFFQjhcXHUxRUJBXFx1MUVCQ1xcdTFFQkVcXHUxRUMwXFx1MUVDMlxcdTFFQzRcXHUxRUM2XFx1MUVDOFxcdTFFQ0FcXHUxRUNDXFx1MUVDRVxcdTFFRDBcXHUxRUQyXFx1MUVENFxcdTFFRDZcXHUxRUQ4XFx1MUVEQVxcdTFFRENcXHUxRURFXFx1MUVFMFxcdTFFRTJcXHUxRUU0XFx1MUVFNlxcdTFFRThcXHUxRUVBXFx1MUVFQ1xcdTFFRUVcXHUxRUYwXFx1MUVGMlxcdTFFRjRcXHUxRUY2XFx1MUVGOFxcdTFFRkFcXHUxRUZDXFx1MUVGRVxcdTFGMDgtXFx1MUYwRlxcdTFGMTgtXFx1MUYxRFxcdTFGMjgtXFx1MUYyRlxcdTFGMzgtXFx1MUYzRlxcdTFGNDgtXFx1MUY0RFxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRkI4LVxcdTFGQkJcXHUxRkM4LVxcdTFGQ0JcXHUxRkQ4LVxcdTFGREJcXHUxRkU4LVxcdTFGRUNcXHUxRkY4LVxcdTFGRkJcXHUyMTAyXFx1MjEwN1xcdTIxMEItXFx1MjEwRFxcdTIxMTAtXFx1MjExMlxcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTMwLVxcdTIxMzNcXHUyMTNFXFx1MjEzRlxcdTIxNDVcXHUyMTgzXFx1MkMwMC1cXHUyQzJFXFx1MkM2MFxcdTJDNjItXFx1MkM2NFxcdTJDNjdcXHUyQzY5XFx1MkM2QlxcdTJDNkQtXFx1MkM3MFxcdTJDNzJcXHUyQzc1XFx1MkM3RS1cXHUyQzgwXFx1MkM4MlxcdTJDODRcXHUyQzg2XFx1MkM4OFxcdTJDOEFcXHUyQzhDXFx1MkM4RVxcdTJDOTBcXHUyQzkyXFx1MkM5NFxcdTJDOTZcXHUyQzk4XFx1MkM5QVxcdTJDOUNcXHUyQzlFXFx1MkNBMFxcdTJDQTJcXHUyQ0E0XFx1MkNBNlxcdTJDQThcXHUyQ0FBXFx1MkNBQ1xcdTJDQUVcXHUyQ0IwXFx1MkNCMlxcdTJDQjRcXHUyQ0I2XFx1MkNCOFxcdTJDQkFcXHUyQ0JDXFx1MkNCRVxcdTJDQzBcXHUyQ0MyXFx1MkNDNFxcdTJDQzZcXHUyQ0M4XFx1MkNDQVxcdTJDQ0NcXHUyQ0NFXFx1MkNEMFxcdTJDRDJcXHUyQ0Q0XFx1MkNENlxcdTJDRDhcXHUyQ0RBXFx1MkNEQ1xcdTJDREVcXHUyQ0UwXFx1MkNFMlxcdTJDRUJcXHUyQ0VEXFx1MkNGMlxcdUE2NDBcXHVBNjQyXFx1QTY0NFxcdUE2NDZcXHVBNjQ4XFx1QTY0QVxcdUE2NENcXHVBNjRFXFx1QTY1MFxcdUE2NTJcXHVBNjU0XFx1QTY1NlxcdUE2NThcXHVBNjVBXFx1QTY1Q1xcdUE2NUVcXHVBNjYwXFx1QTY2MlxcdUE2NjRcXHVBNjY2XFx1QTY2OFxcdUE2NkFcXHVBNjZDXFx1QTY4MFxcdUE2ODJcXHVBNjg0XFx1QTY4NlxcdUE2ODhcXHVBNjhBXFx1QTY4Q1xcdUE2OEVcXHVBNjkwXFx1QTY5MlxcdUE2OTRcXHVBNjk2XFx1QTY5OFxcdUE2OUFcXHVBNzIyXFx1QTcyNFxcdUE3MjZcXHVBNzI4XFx1QTcyQVxcdUE3MkNcXHVBNzJFXFx1QTczMlxcdUE3MzRcXHVBNzM2XFx1QTczOFxcdUE3M0FcXHVBNzNDXFx1QTczRVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3NDZcXHVBNzQ4XFx1QTc0QVxcdUE3NENcXHVBNzRFXFx1QTc1MFxcdUE3NTJcXHVBNzU0XFx1QTc1NlxcdUE3NThcXHVBNzVBXFx1QTc1Q1xcdUE3NUVcXHVBNzYwXFx1QTc2MlxcdUE3NjRcXHVBNzY2XFx1QTc2OFxcdUE3NkFcXHVBNzZDXFx1QTc2RVxcdUE3NzlcXHVBNzdCXFx1QTc3RFxcdUE3N0VcXHVBNzgwXFx1QTc4MlxcdUE3ODRcXHVBNzg2XFx1QTc4QlxcdUE3OERcXHVBNzkwXFx1QTc5MlxcdUE3OTZcXHVBNzk4XFx1QTc5QVxcdUE3OUNcXHVBNzlFXFx1QTdBMFxcdUE3QTJcXHVBN0E0XFx1QTdBNlxcdUE3QThcXHVBN0FBLVxcdUE3QURcXHVBN0IwLVxcdUE3QjRcXHVBN0I2XFx1RkYyMS1cXHVGRjNBXVthLXpcXHhCNVxceERGLVxceEY2XFx4RjgtXFx4RkZcXHUwMTAxXFx1MDEwM1xcdTAxMDVcXHUwMTA3XFx1MDEwOVxcdTAxMEJcXHUwMTBEXFx1MDEwRlxcdTAxMTFcXHUwMTEzXFx1MDExNVxcdTAxMTdcXHUwMTE5XFx1MDExQlxcdTAxMURcXHUwMTFGXFx1MDEyMVxcdTAxMjNcXHUwMTI1XFx1MDEyN1xcdTAxMjlcXHUwMTJCXFx1MDEyRFxcdTAxMkZcXHUwMTMxXFx1MDEzM1xcdTAxMzVcXHUwMTM3XFx1MDEzOFxcdTAxM0FcXHUwMTNDXFx1MDEzRVxcdTAxNDBcXHUwMTQyXFx1MDE0NFxcdTAxNDZcXHUwMTQ4XFx1MDE0OVxcdTAxNEJcXHUwMTREXFx1MDE0RlxcdTAxNTFcXHUwMTUzXFx1MDE1NVxcdTAxNTdcXHUwMTU5XFx1MDE1QlxcdTAxNURcXHUwMTVGXFx1MDE2MVxcdTAxNjNcXHUwMTY1XFx1MDE2N1xcdTAxNjlcXHUwMTZCXFx1MDE2RFxcdTAxNkZcXHUwMTcxXFx1MDE3M1xcdTAxNzVcXHUwMTc3XFx1MDE3QVxcdTAxN0NcXHUwMTdFLVxcdTAxODBcXHUwMTgzXFx1MDE4NVxcdTAxODhcXHUwMThDXFx1MDE4RFxcdTAxOTJcXHUwMTk1XFx1MDE5OS1cXHUwMTlCXFx1MDE5RVxcdTAxQTFcXHUwMUEzXFx1MDFBNVxcdTAxQThcXHUwMUFBXFx1MDFBQlxcdTAxQURcXHUwMUIwXFx1MDFCNFxcdTAxQjZcXHUwMUI5XFx1MDFCQVxcdTAxQkQtXFx1MDFCRlxcdTAxQzZcXHUwMUM5XFx1MDFDQ1xcdTAxQ0VcXHUwMUQwXFx1MDFEMlxcdTAxRDRcXHUwMUQ2XFx1MDFEOFxcdTAxREFcXHUwMURDXFx1MDFERFxcdTAxREZcXHUwMUUxXFx1MDFFM1xcdTAxRTVcXHUwMUU3XFx1MDFFOVxcdTAxRUJcXHUwMUVEXFx1MDFFRlxcdTAxRjBcXHUwMUYzXFx1MDFGNVxcdTAxRjlcXHUwMUZCXFx1MDFGRFxcdTAxRkZcXHUwMjAxXFx1MDIwM1xcdTAyMDVcXHUwMjA3XFx1MDIwOVxcdTAyMEJcXHUwMjBEXFx1MDIwRlxcdTAyMTFcXHUwMjEzXFx1MDIxNVxcdTAyMTdcXHUwMjE5XFx1MDIxQlxcdTAyMURcXHUwMjFGXFx1MDIyMVxcdTAyMjNcXHUwMjI1XFx1MDIyN1xcdTAyMjlcXHUwMjJCXFx1MDIyRFxcdTAyMkZcXHUwMjMxXFx1MDIzMy1cXHUwMjM5XFx1MDIzQ1xcdTAyM0ZcXHUwMjQwXFx1MDI0MlxcdTAyNDdcXHUwMjQ5XFx1MDI0QlxcdTAyNERcXHUwMjRGLVxcdTAyOTNcXHUwMjk1LVxcdTAyQUZcXHUwMzcxXFx1MDM3M1xcdTAzNzdcXHUwMzdCLVxcdTAzN0RcXHUwMzkwXFx1MDNBQy1cXHUwM0NFXFx1MDNEMFxcdTAzRDFcXHUwM0Q1LVxcdTAzRDdcXHUwM0Q5XFx1MDNEQlxcdTAzRERcXHUwM0RGXFx1MDNFMVxcdTAzRTNcXHUwM0U1XFx1MDNFN1xcdTAzRTlcXHUwM0VCXFx1MDNFRFxcdTAzRUYtXFx1MDNGM1xcdTAzRjVcXHUwM0Y4XFx1MDNGQlxcdTAzRkNcXHUwNDMwLVxcdTA0NUZcXHUwNDYxXFx1MDQ2M1xcdTA0NjVcXHUwNDY3XFx1MDQ2OVxcdTA0NkJcXHUwNDZEXFx1MDQ2RlxcdTA0NzFcXHUwNDczXFx1MDQ3NVxcdTA0NzdcXHUwNDc5XFx1MDQ3QlxcdTA0N0RcXHUwNDdGXFx1MDQ4MVxcdTA0OEJcXHUwNDhEXFx1MDQ4RlxcdTA0OTFcXHUwNDkzXFx1MDQ5NVxcdTA0OTdcXHUwNDk5XFx1MDQ5QlxcdTA0OURcXHUwNDlGXFx1MDRBMVxcdTA0QTNcXHUwNEE1XFx1MDRBN1xcdTA0QTlcXHUwNEFCXFx1MDRBRFxcdTA0QUZcXHUwNEIxXFx1MDRCM1xcdTA0QjVcXHUwNEI3XFx1MDRCOVxcdTA0QkJcXHUwNEJEXFx1MDRCRlxcdTA0QzJcXHUwNEM0XFx1MDRDNlxcdTA0QzhcXHUwNENBXFx1MDRDQ1xcdTA0Q0VcXHUwNENGXFx1MDREMVxcdTA0RDNcXHUwNEQ1XFx1MDREN1xcdTA0RDlcXHUwNERCXFx1MDRERFxcdTA0REZcXHUwNEUxXFx1MDRFM1xcdTA0RTVcXHUwNEU3XFx1MDRFOVxcdTA0RUJcXHUwNEVEXFx1MDRFRlxcdTA0RjFcXHUwNEYzXFx1MDRGNVxcdTA0RjdcXHUwNEY5XFx1MDRGQlxcdTA0RkRcXHUwNEZGXFx1MDUwMVxcdTA1MDNcXHUwNTA1XFx1MDUwN1xcdTA1MDlcXHUwNTBCXFx1MDUwRFxcdTA1MEZcXHUwNTExXFx1MDUxM1xcdTA1MTVcXHUwNTE3XFx1MDUxOVxcdTA1MUJcXHUwNTFEXFx1MDUxRlxcdTA1MjFcXHUwNTIzXFx1MDUyNVxcdTA1MjdcXHUwNTI5XFx1MDUyQlxcdTA1MkRcXHUwNTJGXFx1MDU2MS1cXHUwNTg3XFx1MTNGOC1cXHUxM0ZEXFx1MUQwMC1cXHUxRDJCXFx1MUQ2Qi1cXHUxRDc3XFx1MUQ3OS1cXHUxRDlBXFx1MUUwMVxcdTFFMDNcXHUxRTA1XFx1MUUwN1xcdTFFMDlcXHUxRTBCXFx1MUUwRFxcdTFFMEZcXHUxRTExXFx1MUUxM1xcdTFFMTVcXHUxRTE3XFx1MUUxOVxcdTFFMUJcXHUxRTFEXFx1MUUxRlxcdTFFMjFcXHUxRTIzXFx1MUUyNVxcdTFFMjdcXHUxRTI5XFx1MUUyQlxcdTFFMkRcXHUxRTJGXFx1MUUzMVxcdTFFMzNcXHUxRTM1XFx1MUUzN1xcdTFFMzlcXHUxRTNCXFx1MUUzRFxcdTFFM0ZcXHUxRTQxXFx1MUU0M1xcdTFFNDVcXHUxRTQ3XFx1MUU0OVxcdTFFNEJcXHUxRTREXFx1MUU0RlxcdTFFNTFcXHUxRTUzXFx1MUU1NVxcdTFFNTdcXHUxRTU5XFx1MUU1QlxcdTFFNURcXHUxRTVGXFx1MUU2MVxcdTFFNjNcXHUxRTY1XFx1MUU2N1xcdTFFNjlcXHUxRTZCXFx1MUU2RFxcdTFFNkZcXHUxRTcxXFx1MUU3M1xcdTFFNzVcXHUxRTc3XFx1MUU3OVxcdTFFN0JcXHUxRTdEXFx1MUU3RlxcdTFFODFcXHUxRTgzXFx1MUU4NVxcdTFFODdcXHUxRTg5XFx1MUU4QlxcdTFFOERcXHUxRThGXFx1MUU5MVxcdTFFOTNcXHUxRTk1LVxcdTFFOURcXHUxRTlGXFx1MUVBMVxcdTFFQTNcXHUxRUE1XFx1MUVBN1xcdTFFQTlcXHUxRUFCXFx1MUVBRFxcdTFFQUZcXHUxRUIxXFx1MUVCM1xcdTFFQjVcXHUxRUI3XFx1MUVCOVxcdTFFQkJcXHUxRUJEXFx1MUVCRlxcdTFFQzFcXHUxRUMzXFx1MUVDNVxcdTFFQzdcXHUxRUM5XFx1MUVDQlxcdTFFQ0RcXHUxRUNGXFx1MUVEMVxcdTFFRDNcXHUxRUQ1XFx1MUVEN1xcdTFFRDlcXHUxRURCXFx1MUVERFxcdTFFREZcXHUxRUUxXFx1MUVFM1xcdTFFRTVcXHUxRUU3XFx1MUVFOVxcdTFFRUJcXHUxRUVEXFx1MUVFRlxcdTFFRjFcXHUxRUYzXFx1MUVGNVxcdTFFRjdcXHUxRUY5XFx1MUVGQlxcdTFFRkRcXHUxRUZGLVxcdTFGMDdcXHUxRjEwLVxcdTFGMTVcXHUxRjIwLVxcdTFGMjdcXHUxRjMwLVxcdTFGMzdcXHUxRjQwLVxcdTFGNDVcXHUxRjUwLVxcdTFGNTdcXHUxRjYwLVxcdTFGNjdcXHUxRjcwLVxcdTFGN0RcXHUxRjgwLVxcdTFGODdcXHUxRjkwLVxcdTFGOTdcXHUxRkEwLVxcdTFGQTdcXHUxRkIwLVxcdTFGQjRcXHUxRkI2XFx1MUZCN1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2XFx1MUZDN1xcdTFGRDAtXFx1MUZEM1xcdTFGRDZcXHUxRkQ3XFx1MUZFMC1cXHUxRkU3XFx1MUZGMi1cXHUxRkY0XFx1MUZGNlxcdTFGRjdcXHUyMTBBXFx1MjEwRVxcdTIxMEZcXHUyMTEzXFx1MjEyRlxcdTIxMzRcXHUyMTM5XFx1MjEzQ1xcdTIxM0RcXHUyMTQ2LVxcdTIxNDlcXHUyMTRFXFx1MjE4NFxcdTJDMzAtXFx1MkM1RVxcdTJDNjFcXHUyQzY1XFx1MkM2NlxcdTJDNjhcXHUyQzZBXFx1MkM2Q1xcdTJDNzFcXHUyQzczXFx1MkM3NFxcdTJDNzYtXFx1MkM3QlxcdTJDODFcXHUyQzgzXFx1MkM4NVxcdTJDODdcXHUyQzg5XFx1MkM4QlxcdTJDOERcXHUyQzhGXFx1MkM5MVxcdTJDOTNcXHUyQzk1XFx1MkM5N1xcdTJDOTlcXHUyQzlCXFx1MkM5RFxcdTJDOUZcXHUyQ0ExXFx1MkNBM1xcdTJDQTVcXHUyQ0E3XFx1MkNBOVxcdTJDQUJcXHUyQ0FEXFx1MkNBRlxcdTJDQjFcXHUyQ0IzXFx1MkNCNVxcdTJDQjdcXHUyQ0I5XFx1MkNCQlxcdTJDQkRcXHUyQ0JGXFx1MkNDMVxcdTJDQzNcXHUyQ0M1XFx1MkNDN1xcdTJDQzlcXHUyQ0NCXFx1MkNDRFxcdTJDQ0ZcXHUyQ0QxXFx1MkNEM1xcdTJDRDVcXHUyQ0Q3XFx1MkNEOVxcdTJDREJcXHUyQ0REXFx1MkNERlxcdTJDRTFcXHUyQ0UzXFx1MkNFNFxcdTJDRUNcXHUyQ0VFXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1QTY0MVxcdUE2NDNcXHVBNjQ1XFx1QTY0N1xcdUE2NDlcXHVBNjRCXFx1QTY0RFxcdUE2NEZcXHVBNjUxXFx1QTY1M1xcdUE2NTVcXHVBNjU3XFx1QTY1OVxcdUE2NUJcXHVBNjVEXFx1QTY1RlxcdUE2NjFcXHVBNjYzXFx1QTY2NVxcdUE2NjdcXHVBNjY5XFx1QTY2QlxcdUE2NkRcXHVBNjgxXFx1QTY4M1xcdUE2ODVcXHVBNjg3XFx1QTY4OVxcdUE2OEJcXHVBNjhEXFx1QTY4RlxcdUE2OTFcXHVBNjkzXFx1QTY5NVxcdUE2OTdcXHVBNjk5XFx1QTY5QlxcdUE3MjNcXHVBNzI1XFx1QTcyN1xcdUE3MjlcXHVBNzJCXFx1QTcyRFxcdUE3MkYtXFx1QTczMVxcdUE3MzNcXHVBNzM1XFx1QTczN1xcdUE3MzlcXHVBNzNCXFx1QTczRFxcdUE3M0ZcXHVBNzQxXFx1QTc0M1xcdUE3NDVcXHVBNzQ3XFx1QTc0OVxcdUE3NEJcXHVBNzREXFx1QTc0RlxcdUE3NTFcXHVBNzUzXFx1QTc1NVxcdUE3NTdcXHVBNzU5XFx1QTc1QlxcdUE3NURcXHVBNzVGXFx1QTc2MVxcdUE3NjNcXHVBNzY1XFx1QTc2N1xcdUE3NjlcXHVBNzZCXFx1QTc2RFxcdUE3NkZcXHVBNzcxLVxcdUE3NzhcXHVBNzdBXFx1QTc3Q1xcdUE3N0ZcXHVBNzgxXFx1QTc4M1xcdUE3ODVcXHVBNzg3XFx1QTc4Q1xcdUE3OEVcXHVBNzkxXFx1QTc5My1cXHVBNzk1XFx1QTc5N1xcdUE3OTlcXHVBNzlCXFx1QTc5RFxcdUE3OUZcXHVBN0ExXFx1QTdBM1xcdUE3QTVcXHVBN0E3XFx1QTdBOVxcdUE3QjVcXHVBN0I3XFx1QTdGQVxcdUFCMzAtXFx1QUI1QVxcdUFCNjAtXFx1QUI2NVxcdUFCNzAtXFx1QUJCRlxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZGNDEtXFx1RkY1QV0pL2dcbiIsIm1vZHVsZS5leHBvcnRzID0gL1teQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDMC05XFx4QjJcXHhCM1xceEI5XFx4QkMtXFx4QkVcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcXHUwN0MwLVxcdTA3QzlcXHUwOTY2LVxcdTA5NkZcXHUwOUU2LVxcdTA5RUZcXHUwOUY0LVxcdTA5RjlcXHUwQTY2LVxcdTBBNkZcXHUwQUU2LVxcdTBBRUZcXHUwQjY2LVxcdTBCNkZcXHUwQjcyLVxcdTBCNzdcXHUwQkU2LVxcdTBCRjJcXHUwQzY2LVxcdTBDNkZcXHUwQzc4LVxcdTBDN0VcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENzVcXHUwREU2LVxcdTBERUZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMzNcXHUxMDQwLVxcdTEwNDlcXHUxMDkwLVxcdTEwOTlcXHUxMzY5LVxcdTEzN0NcXHUxNkVFLVxcdTE2RjBcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxOTQ2LVxcdTE5NEZcXHUxOUQwLVxcdTE5REFcXHUxQTgwLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQjUwLVxcdTFCNTlcXHUxQkIwLVxcdTFCQjlcXHUxQzQwLVxcdTFDNDlcXHUxQzUwLVxcdTFDNTlcXHUyMDcwXFx1MjA3NC1cXHUyMDc5XFx1MjA4MC1cXHUyMDg5XFx1MjE1MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg5XFx1MjQ2MC1cXHUyNDlCXFx1MjRFQS1cXHUyNEZGXFx1Mjc3Ni1cXHUyNzkzXFx1MkNGRFxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0FcXHUzMTkyLVxcdTMxOTVcXHUzMjIwLVxcdTMyMjlcXHUzMjQ4LVxcdTMyNEZcXHUzMjUxLVxcdTMyNUZcXHUzMjgwLVxcdTMyODlcXHUzMkIxLVxcdTMyQkZcXHVBNjIwLVxcdUE2MjlcXHVBNkU2LVxcdUE2RUZcXHVBODMwLVxcdUE4MzVcXHVBOEQwLVxcdUE4RDlcXHVBOTAwLVxcdUE5MDlcXHVBOUQwLVxcdUE5RDlcXHVBOUYwLVxcdUE5RjlcXHVBQTUwLVxcdUFBNTlcXHVBQkYwLVxcdUFCRjlcXHVGRjEwLVxcdUZGMTldKy9nXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gQW4gYXVnbWVudGVkIEFWTCBUcmVlIHdoZXJlIGVhY2ggbm9kZSBtYWludGFpbnMgYSBsaXN0IG9mIHJlY29yZHMgYW5kIHRoZWlyIHNlYXJjaCBpbnRlcnZhbHMuXHJcbi8vIFJlY29yZCBpcyBjb21wb3NlZCBvZiBhbiBpbnRlcnZhbCBhbmQgaXRzIHVuZGVybHlpbmcgZGF0YSwgc2VudCBieSBhIGNsaWVudC4gVGhpcyBhbGxvd3MgdGhlXHJcbi8vIGludGVydmFsIHRyZWUgdG8gaGF2ZSB0aGUgc2FtZSBpbnRlcnZhbCBpbnNlcnRlZCBtdWx0aXBsZSB0aW1lcywgYXMgbG9uZyBpdHMgZGF0YSBpcyBkaWZmZXJlbnQuXHJcbi8vIEJvdGggaW5zZXJ0aW9uIGFuZCBkZWxldGlvbiByZXF1aXJlIE8obG9nIG4pIHRpbWUuIFNlYXJjaGluZyByZXF1aXJlcyBPKGsqbG9nbikgdGltZSwgd2hlcmUgYGtgXHJcbi8vIGlzIHRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzIGluIHRoZSBvdXRwdXQgbGlzdC5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaXNTYW1lID0gcmVxdWlyZShcInNoYWxsb3dlcXVhbFwiKTtcclxuZnVuY3Rpb24gaGVpZ2h0KG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbm9kZS5oZWlnaHQ7XHJcbiAgICB9XHJcbn1cclxudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKGludGVydmFsVHJlZSwgcmVjb3JkKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUgPSBpbnRlcnZhbFRyZWU7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gW107XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMua2V5ID0gcmVjb3JkLmxvdztcclxuICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIC8vIFNhdmUgdGhlIGFycmF5IG9mIGFsbCByZWNvcmRzIHdpdGggdGhlIHNhbWUga2V5IGZvciB0aGlzIG5vZGVcclxuICAgICAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xyXG4gICAgfVxyXG4gICAgLy8gR2V0cyB0aGUgaGlnaGVzdCByZWNvcmQuaGlnaCB2YWx1ZSBmb3IgdGhpcyBub2RlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXROb2RlSGlnaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGlnaCA9IHRoaXMucmVjb3Jkc1swXS5oaWdoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29yZHNbaV0uaGlnaCA+IGhpZ2gpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSB0aGlzLnJlY29yZHNbaV0uaGlnaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGlnaDtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGhlaWdodCB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FsbGVkIGR1cmluZyBpbnNlcnRpb24sIHJlYmFsYW5jZSwgcmVtb3ZhbFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0KHRoaXMubGVmdCksIGhlaWdodCh0aGlzLnJpZ2h0KSkgKyAxO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdGhlIG1heCB2YWx1ZSBvZiBhbGwgdGhlIHBhcmVudHMgYWZ0ZXIgaW5zZXJ0aW5nIGludG8gYWxyZWFkeSBleGlzdGluZyBub2RlLCBhcyB3ZWxsIGFzXHJcbiAgICAvLyByZW1vdmluZyB0aGUgbm9kZSBjb21wbGV0ZWx5IG9yIHJlbW92aW5nIHRoZSByZWNvcmQgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBub2RlLiBTdGFydHMgd2l0aFxyXG4gICAgLy8gdGhlIHBhcmVudCBvZiBhbiBhZmZlY3RlZCBub2RlIGFuZCBidWJibGVzIHVwIHRvIHJvb3RcclxuICAgIE5vZGUucHJvdG90eXBlLnVwZGF0ZU1heE9mUGFyZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLnJpZ2h0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTGVmdC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgICAgIHkgICBUNCAgICAgIFJpZ2h0IFJvdGF0ZSAoeikgICAgICAgICAgeCAgICAgelxyXG4gICAgICAgIC8gXFwgICAgICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAgIC8gXFwgICAvIFxcXHJcbiAgICAgICB4ICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgIC8gXFxcclxuICAgIFQxICAgVDJcclxuICBcclxuICAgIExlZnQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgIHkgICBUNCAgTGVmdCBSb3RhdGUgKHkpICAgICAgICAgeCAgVDQgIFJpZ2h0IFJvdGF0ZSh6KSAgICAgeSAgICAgelxyXG4gICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgIFQxICAgeCAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgIFQzICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcXHJcbiAgICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDJcclxuICAgICovXHJcbiAgICAvLyBIYW5kbGVzIExlZnQtTGVmdCBjYXNlIGFuZCBMZWZ0LVJpZ2h0IGNhc2UgYWZ0ZXIgcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgbGVmdCA9IHBhcmVudC5sZWZ0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgbGVmdCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50TGVmdEhpZ2ggPSBsZWZ0LmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgIT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50TGVmdEhpZ2gsIGxlZnQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSB0aGlzUGFyZW50TGVmdEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KGxlZnQubGVmdC5tYXgsIGxlZnQucmlnaHQubWF4KSwgdGhpc1BhcmVudExlZnRIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBpdHNlbGYgKHopXHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBwYXJlbnQgKHkgaW4gZmlyc3QgY2FzZSwgeCBpbiBzZWNvbmQpXHJcbiAgICAgICAgcGFyZW50Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHBhcmVudC5sZWZ0Lm1heCwgcGFyZW50LnJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmlnaHQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgIFQxICB5ICAgICBMZWZ0IFJvdGF0ZSh6KSAgICAgICB6ICAgICB4XHJcbiAgICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgVDIgIHggICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAgLyBcXFxyXG4gICAgICAgIFQzIFQ0XHJcbiAgXHJcbiAgICBSaWdodC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgIFQxICB5ICAgUmlnaHQgUm90YXRlICh5KSAgICAgVDEgIHggICAgICBMZWZ0IFJvdGF0ZSh6KSAgIHogICAgIHlcclxuICAgICAgICAvIFxcICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggIFQ0ICAgICAgICAgICAgICAgICAgICAgICAgVDIgIHkgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICBUMyBUNFxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgUmlnaHQtUmlnaHQgY2FzZSBhbmQgUmlnaHQtTGVmdCBjYXNlIGluIHJlYmFsYW5jaW5nIEFWTCB0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBwYXJlbnQucmlnaHQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiByaWdodCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50UmlnaHRIaWdoID0gcmlnaHQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAocmlnaHQubGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmlnaHQubGVmdCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSB0aGlzUGFyZW50UmlnaHRIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocmlnaHQubGVmdC5tYXgsIHJpZ2h0LnJpZ2h0Lm1heCksIHRoaXNQYXJlbnRSaWdodEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCByaWdodC5tYXgpLCBwYXJlbnQuZ2V0Tm9kZUhpZ2goKSk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX2xlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJpZ2h0Q2hpbGQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50LnJpZ2h0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHRDaGlsZC5sZWZ0O1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByaWdodENoaWxkLmxlZnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWZ0Q2hpbGQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgbGVmdENoaWxkLnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnRDaGlsZC5yaWdodDtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlZnRDaGlsZC5yaWdodCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICBsZWZ0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmViYWxhbmNlcyB0aGUgdHJlZSBpZiB0aGUgaGVpZ2h0IHZhbHVlIGJldHdlZW4gdHdvIG5vZGVzIG9mIHRoZSBzYW1lIHBhcmVudCBpcyBncmVhdGVyIHRoYW5cclxuICAgIC8vIHR3by4gVGhlcmUgYXJlIDQgY2FzZXMgdGhhdCBjYW4gaGFwcGVuIHdoaWNoIGFyZSBvdXRsaW5lZCBpbiB0aGUgZ3JhcGhpY3MgYWJvdmVcclxuICAgIE5vZGUucHJvdG90eXBlLl9yZWJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGhlaWdodCh0aGlzLmxlZnQpID49IDIgKyBoZWlnaHQodGhpcy5yaWdodCkpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQobGVmdC5sZWZ0KSA+PSBoZWlnaHQobGVmdC5yaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIExlZnQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICBsZWZ0Ll9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCh0aGlzLnJpZ2h0KSA+PSAyICsgaGVpZ2h0KHRoaXMubGVmdCkpIHtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChyaWdodC5yaWdodCkgPj0gaGVpZ2h0KHJpZ2h0LmxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LUxlZnQgY2FzZVxyXG4gICAgICAgICAgICAgICAgcmlnaHQuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byBsZWZ0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byByaWdodCBzdWJ0cmVlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXggdmFsdWUgb2YgdGhpcyBhbmNlc3RvciBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodGhpcy5tYXggPCByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgaGVpZ2h0IG9mIGVhY2ggbm9kZVxyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgLy8gUmViYWxhbmNlIHRoZSB0cmVlIHRvIGVuc3VyZSBhbGwgb3BlcmF0aW9ucyBhcmUgZXhlY3V0ZWQgaW4gTyhsb2duKSB0aW1lLiBUaGlzIGlzIGVzcGVjaWFsbHlcclxuICAgICAgICAvLyBpbXBvcnRhbnQgaW4gc2VhcmNoaW5nLCBhcyB0aGUgdHJlZSBoYXMgYSBoaWdoIGNoYW5jZSBvZiBkZWdlbmVyYXRpbmcgd2l0aG91dCB0aGUgcmViYWxhbmNpbmdcclxuICAgICAgICB0aGlzLl9yZWJhbGFuY2UoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlLCBsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAoY3VycmVudE5vZGUua2V5IDw9IGhpZ2ggJiYgbG93IDw9IGN1cnJlbnROb2RlLmdldE5vZGVIaWdoKCkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZXMgYXJlIG92ZXJsYXBwaW5nLCBjaGVjayBpZiBpbmRpdmlkdWFsIHJlY29yZHMgaW4gdGhlIG5vZGUgYXJlIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgIHZhciB0ZW1wUmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldLmhpZ2ggPj0gbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdHMucHVzaChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVtcFJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc2VhcmNoIG5vZGVzIHRoYXQgZG9uJ3QgZXhpc3RcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlZnRTZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgb3duU2VhcmNoID0gW107XHJcbiAgICAgICAgdmFyIHJpZ2h0U2VhcmNoID0gW107XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgcG9pbnQgb2YgYW55IGludGVydmFsIGluIHRoaXMgbm9kZSBhbmQgYWxsIGl0c1xyXG4gICAgICAgIC8vIGNoaWxkcmVuLCB0aGVyZSB3b24ndCBiZSBhbnkgbWF0Y2hlc1xyXG4gICAgICAgIGlmIChsb3cgPiB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNlYXJjaCBsZWZ0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGVmdC5tYXggPj0gbG93KSB7XHJcbiAgICAgICAgICAgIGxlZnRTZWFyY2ggPSB0aGlzLmxlZnQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIHRoaXMgbm9kZVxyXG4gICAgICAgIG93blNlYXJjaCA9IHRoaXMuX2dldE92ZXJsYXBwaW5nUmVjb3Jkcyh0aGlzLCBsb3csIGhpZ2gpO1xyXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBzdGFydCBvZiB0aGlzIGludGVydmFsLCB0aGVuIGl0IGNhbid0IGJlIGluIGFueSBjaGlsZCB0b1xyXG4gICAgICAgIC8vIHRoZSByaWdodFxyXG4gICAgICAgIGlmIChoaWdoIDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTZWFyY2guY29uY2F0KG93blNlYXJjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2VhcmNoIHJpZ2h0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodFNlYXJjaCA9IHRoaXMucmlnaHQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybiBhY2N1bXVsYXRlZCByZXN1bHRzLCBpZiBhbnlcclxuICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoLCByaWdodFNlYXJjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2VhcmNoZXMgZm9yIGEgbm9kZSBieSBhIGBrZXlgIHZhbHVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2hFeGlzdGluZyA9IGZ1bmN0aW9uIChsb3cpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmtleSA9PT0gbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIHNtYWxsZXN0IG5vZGUgb2YgdGhlIHN1YnRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl9taW5WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Ll9taW5WYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAobm9kZS5rZXkgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlIHRvIGJlIHJlbW92ZWQgaXMgb24gdGhlIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLmtleSA+IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIGhhcyB0d28gY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIHZhciBtaW5WYWx1ZSA9IHRoaXMucmlnaHQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleSA9IG1pblZhbHVlLmtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkcyA9IG1pblZhbHVlLnJlY29yZHM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcclxuZXhwb3J0cy5Ob2RlID0gTm9kZTtcclxudmFyIEludGVydmFsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubG93ID4gcmVjb3JkLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93YCB2YWx1ZSBtdXN0IGJlIGxvd2VyIG9yIGVxdWFsIHRvIGBoaWdoYCB2YWx1ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gQmFzZSBjYXNlOiBUcmVlIGlzIGVtcHR5LCBuZXcgbm9kZSBiZWNvbWVzIHJvb3RcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IE5vZGUodGhpcywgcmVjb3JkKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlY29yZHMgaW4gdGhpcyBub2RlIGlmIHRoZXJlIGFscmVhZHkgaXMgdGhlIG9uZSB3aXRoIHNhbWUgbG93LCBoaWdoLCBkYXRhXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVjb3JkIGlzIHNhbWUgYXMgdGhlIG9uZSB3ZSdyZSB0cnlpbmcgdG8gaW5zZXJ0OyByZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBoYXMgYmVlbiBpbnNlcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByZWNvcmQgdG8gdGhlIG5vZGVcclxuICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoZSBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaGlnaCA+IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgZG9lc24ndCBhbHJlYWR5IGV4aXN0LiBDYWxsIGluc2VydCBmdW5jdGlvbiBvbiByb290J3Mgbm9kZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyZWUgaXMgZW1wdHk7IHJldHVybiBlbXB0eSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgbm90aGluZyB0byByZW1vdmVcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3Quc2VhcmNoRXhpc3RpbmcocmVjb3JkLmxvdyk7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRSZWNvcmQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIDIgb3IgbW9yZSByZWNvcmRzLiBGaW5kIHRoZSBvbmUgd2UgbmVlZCBhbmQgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRSZWNvcmQgPSBub2RlLnJlY29yZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoYXQgbm9kZSBhbmQgaXRzIHBhcmVudHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID09PSBub2RlLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUhpZ2ggPSBub2RlLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZS5yaWdodC5tYXgpLCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KG5vZGUubGVmdC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgPT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5yaWdodC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gbm9kZUhpZ2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5yZWNvcmRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGhhcyBvbmx5IDEgcmVjb3JkLiBDaGVjayBpZiB0aGUgcmVtYWluaW5nIHJlY29yZCBpbiB0aGlzIG5vZGUgaXNcclxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcclxuICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzWzBdLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyByZWNvcmQgaXMgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZS4gUmVtb3ZlIHRoZSB3aG9sZSBub2RlIGZyb20gdGhlIHRyZWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290LmtleSA9PT0gbm9kZS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgcmVtb3ZpbmcgdGhlIHJvb3QgZWxlbWVudC4gQ3JlYXRlIGEgZHVtbXkgbm9kZSB0aGF0IHdpbGwgdGVtcG9yYXJpbHkgdGFrZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb290J3MgcGFyZW50IHJvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RQYXJlbnQgPSBuZXcgTm9kZSh0aGlzLCB7IGxvdzogcmVjb3JkLmxvdywgaGlnaDogcmVjb3JkLmxvdyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFBhcmVudC5sZWZ0ID0gdGhpcy5yb290O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gcm9vdFBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlID0gdGhpcy5yb290LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdFBhcmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyBub3QgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHJlY29yZHMgYXQgYWxsIGluIHRoaXMgbm9kZT8hIFNob3VsZG4ndCBoYXBwZW5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbk9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZU9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVydmFsVHJlZTtcclxufSgpKTtcclxuZXhwb3J0cy5JbnRlcnZhbFRyZWUgPSBJbnRlcnZhbFRyZWU7XHJcbnZhciBEYXRhSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0YUludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XHJcbiAgICB9XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pbnNlcnQoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5yZW1vdmUoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5zZWFyY2gobG93LCBoaWdoKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuZGF0YTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnByZU9yZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLCBcImNvdW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5jb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEYXRhSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRhSW50ZXJ2YWxUcmVlO1xyXG52YXIgSW5PcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2goc3RhcnROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWRcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNaWdodCBwb3AgdGhlIGxhc3QgYW5kIHNldCB0aGlzLmN1cnJlbnROb2RlID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5jdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLmN1cnJlbnROb2RlLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbk9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkluT3JkZXIgPSBJbk9yZGVyO1xyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxudmFyIFByZU9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJlT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgIH1cclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWQsXHJcbiAgICAgICAgLy8gd2hpY2ggb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHJpZ2h0IG5vZGUgKGkuZSB3ZSBhcmUgZG9uZSlcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZU9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlByZU9yZGVyID0gUHJlT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qKlxuICogTm9GaWx0ZXIgc3RyZWFtLiAgQ2FuIGJlIHVzZWQgdG8gc2luayBvciBzb3VyY2UgZGF0YSB0byBhbmQgZnJvbVxuICogb3RoZXIgbm9kZSBzdHJlYW1zLiAgSW1wbGVtZW50ZWQgYXMgdGhlIFwiaWRlbnRpdHlcIiBUcmFuc2Zvcm0gc3RyZWFtXG4gKiAoaGVuY2UgdGhlIG5hbWUpLCBidXQgYWxsb3dzIGZvciBpbnNwZWN0aW5nIGRhdGEgdGhhdCBpcyBpbi1mbGlnaHQuXG4gKlxuICogQWxsb3dzIHBhc3NpbmcgaW4gc291cmNlIGRhdGEgKGlucHV0LCBpbnB1dEVuY29kaW5nKSBhdCBjcmVhdGlvblxuICogdGltZS4gIFNvdXJjZSBkYXRhIGNhbiBhbHNvIGJlIHBhc3NlZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+c291cmNlPC9jYXB0aW9uPlxuICogY29uc3QgbiA9IG5ldyBOb0ZpbHRlcignWm05dicsICdiYXNlNjQnKTtcbiAqIG4ucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+c2luazwvY2FwdGlvbj5cbiAqIGNvbnN0IG4gPSBuZXcgTm9maWx0ZXIoKTtcbiAqIC8vIE5PVEU6ICdmaW5pc2gnIGZpcmVzIHdoZW4gdGhlIGlucHV0IGlzIGRvbmUgd3JpdGluZ1xuICogbi5vbignZmluaXNoJywgZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKG4udG9TdHJpbmcoJ2Jhc2U2NCcpKTsgfSk7XG4gKiBwcm9jZXNzLnN0ZGluLnBpcGUobik7XG4gKi9cbmNsYXNzIE5vRmlsdGVyIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTm9GaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gW2lucHV0XSAtIFNvdXJjZSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXRFbmNvZGluZz1udWxsXSAtIEVuY29kaW5nIG5hbWUgZm9yIGlucHV0LFxuICAgKiAgIGlnbm9yZWQgaWYgaW5wdXQgaXMgbm90IGEgU3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPdGhlciBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gW29wdGlvbnMuaW5wdXQ9bnVsbF0gLSBJbnB1dCBzb3VyY2UgZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5wdXRFbmNvZGluZz1udWxsXSAtIEVuY29kaW5nIG5hbWUgZm9yIGlucHV0LFxuICAgKiAgIGlnbm9yZWQgaWYgaW5wdXQgaXMgbm90IGEgU3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oaWdoV2F0ZXJNYXJrPTE2Mzg0XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlc1xuICAgKiAgIHRvIHN0b3JlIGluIHRoZSBpbnRlcm5hbCBidWZmZXIgYmVmb3JlIGNlYXNpbmcgdG8gcmVhZCBmcm9tIHRoZVxuICAgKiAgIHVuZGVybHlpbmcgcmVzb3VyY2UuIERlZmF1bHQ9MTZrYiwgb3IgMTYgZm9yIG9iamVjdE1vZGUgc3RyZWFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gLSBJZiBzcGVjaWZpZWQsIHRoZW4gYnVmZmVycyB3aWxsXG4gICAqICAgYmUgZGVjb2RlZCB0byBzdHJpbmdzIHVzaW5nIHRoZSBzcGVjaWZpZWQgZW5jb2RpbmdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vYmplY3RNb2RlPWZhbHNlXSAtIFdoZXRoZXIgdGhpcyBzdHJlYW0gc2hvdWxkXG4gICAqICAgYmVoYXZlIGFzIGEgc3RyZWFtIG9mIG9iamVjdHMuIE1lYW5pbmcgdGhhdCBzdHJlYW0ucmVhZChuKSByZXR1cm5zIGFcbiAgICogICBzaW5nbGUgdmFsdWUgaW5zdGVhZCBvZiBhIEJ1ZmZlciBvZiBzaXplIG5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWNvZGVTdHJpbmdzPXRydWVdIC0gV2hldGhlciBvciBub3QgdG8gZGVjb2RlXG4gICAqICAgc3RyaW5ncyBpbnRvIEJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBfd3JpdGUoKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndhdGNoUGlwZT10cnVlXSAtIFdoZXRoZXIgdG8gd2F0Y2ggZm9yICdwaXBlJ1xuICAgKiAgIGV2ZW50cywgc2V0dGluZyB0aGlzIHN0cmVhbSdzIG9iamVjdE1vZGUgYmFzZWQgb24gdGhlIG9iamVjdE1vZGUgb2YgdGhlXG4gICAqICAgaW5wdXQgc3RyZWFtXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVhZEVycm9yPWZhbHNlXSAtIElmIHRydWUsIHdoZW4gYSByZWFkKClcbiAgICogICB1bmRlcmZsb3dzLCB0aHJvdyBhbiBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlucHV0LCBpbnB1dEVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICAgIGxldCBpbnBcbiAgICBsZXQgaW5wRVxuICAgIHN3aXRjaCAodHlwZW9mKGlucHV0KSkge1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgICBpbnAgPSBpbnB1dFxuICAgICAgICAgIGlmICgoaW5wdXRFbmNvZGluZyAhPSBudWxsKSAmJiAodHlwZW9mKGlucHV0RW5jb2RpbmcpID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnB1dEVuY29kaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBpbnB1dFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpbnAgPSBpbnB1dFxuICAgICAgICBpZiAoKGlucHV0RW5jb2RpbmcgIT0gbnVsbCkgJiYgKHR5cGVvZihpbnB1dEVuY29kaW5nKSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGlucHV0RW5jb2RpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnBFID0gaW5wdXRFbmNvZGluZ1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKChvcHRpb25zID09IG51bGwpKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gICAgaWYgKGlucCA9PSBudWxsKSB7XG4gICAgICBpbnAgPSBvcHRpb25zLmlucHV0XG4gICAgfVxuICAgIGlmIChpbnBFID09IG51bGwpIHtcbiAgICAgIGlucEUgPSBvcHRpb25zLmlucHV0RW5jb2RpbmdcbiAgICB9XG4gICAgZGVsZXRlIG9wdGlvbnMuaW5wdXRcbiAgICBkZWxldGUgb3B0aW9ucy5pbnB1dEVuY29kaW5nXG4gICAgY29uc3Qgd2F0Y2hQaXBlID0gb3B0aW9ucy53YXRjaFBpcGUgIT0gbnVsbCA/IG9wdGlvbnMud2F0Y2hQaXBlIDogdHJ1ZVxuICAgIGRlbGV0ZSBvcHRpb25zLndhdGNoUGlwZVxuICAgIGNvbnN0IHJlYWRFcnJvciA9ICEhIG9wdGlvbnMucmVhZEVycm9yXG4gICAgZGVsZXRlIG9wdGlvbnMucmVhZEVycm9yXG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMucmVhZEVycm9yID0gcmVhZEVycm9yXG5cbiAgICBpZiAod2F0Y2hQaXBlKSB7XG4gICAgICB0aGlzLm9uKCdwaXBlJywgcmVhZGFibGUgPT4ge1xuICAgICAgICBjb25zdCBvbSA9IHJlYWRhYmxlLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGVcbiAgICAgICAgaWYgKCh0aGlzLmxlbmd0aCA+IDApICYmIChvbSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdEbyBub3Qgc3dpdGNoIG9iamVjdE1vZGUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc3RyZWFtJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IG9tXG4gICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLm9iamVjdE1vZGUgPSBvbVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoaW5wICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZW5kKGlucCwgaW5wRSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIG9iamVjdCBhIHtOb0ZpbHRlcn0/XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBvYmogaXMgYSBOb0ZpbHRlclxuICAgKi9cbiAgc3RhdGljIGlzTm9GaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc2FtZSBhcyBuZjEuY29tcGFyZShuZjIpLiBVc2VmdWwgZm9yIHNvcnRpbmcgYW4gQXJyYXkgb2YgTm9GaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge05vRmlsdGVyfSBuZjEgLSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmVcbiAgICogQHBhcmFtIHtOb0ZpbHRlcn0gbmYyIC0gVGhlIHNlY29uZCBvYmplY3QgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSwgMCwgMSBmb3IgbGVzcywgZXF1YWwsIGdyZWF0ZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXJyID0gW25ldyBOb0ZpbHRlcignMTIzNCcpLCBuZXcgTm9GaWx0ZXIoJzAxMjMnKV07XG4gICAqIGFyci5zb3J0KE5vRmlsdGVyLmNvbXBhcmUpO1xuICAgKi9cbiAgc3RhdGljIGNvbXBhcmUobmYxLCBuZjIpIHtcbiAgICBpZiAoIShuZjEgaW5zdGFuY2VvZiB0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgTm9GaWx0ZXJzJylcbiAgICB9XG4gICAgaWYgKG5mMSA9PT0gbmYyKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmYxLmNvbXBhcmUobmYyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYnVmZmVyIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyBhbGwgdGhlXG4gICAqIE5vRmlsdGVycyBpbiB0aGUgbGlzdCB0b2dldGhlci4gSWYgdGhlIGxpc3QgaGFzIG5vIGl0ZW1zLCBvciBpZlxuICAgKiB0aGUgdG90YWxMZW5ndGggaXMgMCwgdGhlbiBpdCByZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyLlxuICAgKlxuICAgKiBJZiBsZW5ndGggaXMgbm90IHByb3ZpZGVkLCBpdCBpcyByZWFkIGZyb20gdGhlIGJ1ZmZlcnMgaW4gdGhlXG4gICAqIGxpc3QuIEhvd2V2ZXIsIHRoaXMgYWRkcyBhbiBhZGRpdGlvbmFsIGxvb3AgdG8gdGhlIGZ1bmN0aW9uLCBzb1xuICAgKiBpdCBpcyBmYXN0ZXIgdG8gcHJvdmlkZSB0aGUgbGVuZ3RoIGV4cGxpY2l0bHkgaWYgeW91IGFscmVhZHkga25vdyBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxOb0ZpbHRlcj59IGxpc3QgSW5wdXRzLiAgTXVzdCBub3QgYmUgYWxsIGVpdGhlciBpbiBvYmplY3RcbiAgICogICBtb2RlLCBvciBhbGwgbm90IGluIG9iamVjdCBtb2RlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1udWxsXSBOdW1iZXIgb2YgYnl0ZXMgb3Igb2JqZWN0cyB0byByZWFkXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ8QXJyYXl9IFRoZSBjb25jYXRlbmF0ZWQgdmFsdWVzIGFzIGFuIGFycmF5IGlmIGluIG9iamVjdFxuICAgKiAgIG1vZGUsIG90aGVyd2lzZSBhIEJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIGNvbmNhdChsaXN0LCBsZW5ndGgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBOb0ZpbHRlcnMnKVxuICAgIH1cbiAgICBpZiAoKGxpc3QubGVuZ3RoID09PSAwKSB8fCAobGVuZ3RoID09PSAwKSkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICAgIH1cbiAgICBpZiAoKGxlbmd0aCA9PSBudWxsKSkge1xuICAgICAgbGVuZ3RoID0gbGlzdC5yZWR1Y2UoKHRvdCwgbmYpID0+IHtcbiAgICAgICAgaWYgKCEobmYgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgTm9GaWx0ZXJzJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90ICsgbmYubGVuZ3RoXG4gICAgICB9LCAwKVxuICAgIH1cbiAgICBsZXQgYWxsQnVmcyA9IHRydWVcbiAgICBsZXQgYWxsT2JqcyA9IHRydWVcbiAgICBjb25zdCBidWZzID0gbGlzdC5tYXAobmYgPT4ge1xuICAgICAgaWYgKCEobmYgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIE5vRmlsdGVycycpXG4gICAgICB9XG4gICAgICBjb25zdCBidWYgPSBuZi5zbGljZSgpXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgYWxsT2JqcyA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxCdWZzID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZcbiAgICB9KVxuICAgIGlmIChhbGxCdWZzKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZzLCBsZW5ndGgpXG4gICAgfVxuICAgIGlmIChhbGxPYmpzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLmJ1ZnMpLnNsaWNlKDAsIGxlbmd0aClcbiAgICB9XG4gICAgLy8gVE9ETzogbWF5YmUgY29hbGVzY2UgYnVmZmVycywgY291bnRpbmcgYnl0ZXMsIGFuZCBmbGF0dGVuIGluIGFycmF5c1xuICAgIC8vIGNvdW50aW5nIG9iamVjdHM/ICBJIGNhbid0IGltYWdpbmUgd2h5IHRoYXQgd291bGQgYmUgdXNlZnVsLlxuICAgIHRocm93IG5ldyBFcnJvcignQ29uY2F0ZW5hdGluZyBtaXhlZCBvYmplY3QgYW5kIGJ5dGUgc3RyZWFtcyBub3Qgc3VwcG9ydGVkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cbiAgICB0aGlzLnB1c2goY2h1bmspXG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVmQXJyYXkoKSB7XG4gICAgbGV0IGJ1ZnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlclxuICAgIC8vIEhBQ0s6IHJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgZWxzZSBvbmUgZGF5LiAgVGhpcyBpcyB3aGF0IEkgZ2V0IGZvclxuICAgIC8vIHJlbHlpbmcgb24gaW50ZXJuYWxzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheShidWZzKSkge1xuICAgICAgbGV0IGIgPSBidWZzLmhlYWRcbiAgICAgIGJ1ZnMgPSBbXVxuICAgICAgd2hpbGUgKGIgIT0gbnVsbCkge1xuICAgICAgICBidWZzLnB1c2goYi5kYXRhKVxuICAgICAgICBiID0gYi5uZXh0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZzXG4gIH1cblxuICAvKipcbiAgICogUHVsbHMgc29tZSBkYXRhIG91dCBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFuZCByZXR1cm5zIGl0LlxuICAgKiBJZiB0aGVyZSBpcyBubyBkYXRhIGF2YWlsYWJsZSwgdGhlbiBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBJZiB5b3UgcGFzcyBpbiBhIHNpemUgYXJndW1lbnQsIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhhdCBtYW55IGJ5dGVzLiBJZlxuICAgKiBzaXplIGJ5dGVzIGFyZSBub3QgYXZhaWxhYmxlLCB0aGVuIGl0IHdpbGwgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZVxuICAgKiBlbmRlZCwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIHJldHVybiB0aGUgZGF0YSByZW1haW5pbmcgaW4gdGhlIGJ1ZmZlci5cbiAgICpcbiAgICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGEgc2l6ZSBhcmd1bWVudCwgdGhlbiBpdCB3aWxsIHJldHVybiBhbGwgdGhlIGRhdGEgaW5cbiAgICogdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPW51bGxdIC0gTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8QnVmZmVyfG51bGx9IElmIG5vIGRhdGEgb3Igbm90IGVub3VnaCBkYXRhLCBudWxsLiAgSWZcbiAgICogICBkZWNvZGluZyBvdXRwdXQgYSBzdHJpbmcsIG90aGVyd2lzZSBhIEJ1ZmZlclxuICAgKiBAdGhyb3dzIEVycm9yIC0gaWYgcmVhZEVycm9yIGlzIHRydWUgYW5kIHRoZXJlIHdhcyB1bmRlcmZsb3dcbiAgICogQGZpcmVzIE5vRmlsdGVyI3JlYWRcbiAgICovXG4gIHJlYWQoc2l6ZSkge1xuICAgIGNvbnN0IGJ1ZiA9IHN1cGVyLnJlYWQoc2l6ZSlcbiAgICBpZiAoYnVmICE9IG51bGwpIHtcbiAgICAgIC8qXG4gICAgICAgKiBSZWFkIGV2ZW50LiBGaXJlZCB3aGVuZXZlciBhbnl0aGluZyBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgTm9GaWx0ZXIjcmVhZFxuICAgICAgICogQHR5cGUge0J1ZmZlcnxzdHJpbmd8T2JqZWN0fVxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbWl0KCdyZWFkJywgYnVmKVxuICAgICAgaWYgKHRoaXMucmVhZEVycm9yICYmIChidWYubGVuZ3RoIDwgc2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFkICR7YnVmLmxlbmd0aH0sIHdhbnRlZCAke3NpemV9YClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucmVhZEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRhdGEgYXZhaWxhYmxlLCB3YW50ZWQgJHtzaXplfWApXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSBmdWxsIGNvbnRlbnRzLCBhZnRlciB0aGUgJ2ZpbmlzaCdcbiAgICogZXZlbnQgZmlyZXMuICBFcnJvcnMgb24gdGhlIHN0cmVhbSBjYXVzZSB0aGUgcHJvbWlzZSB0byBiZSByZWplY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NiPW51bGxdIC0gZmluaXNoZWQvZXJyb3IgY2FsbGJhY2sgdXNlZCBpbiAqYWRkaXRpb24qXG4gICAqICAgdG8gdGhlIHByb21pc2VcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyfFN0cmluZz59IGZ1bGZpbGxlZCB3aGVuIGNvbXBsZXRlXG4gICAqL1xuICBwcm9taXNlKGNiKSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlYWQoKVxuICAgICAgICBpZiAoKGNiICE9IG51bGwpICYmICFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgICBjYihudWxsLCBkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdlcnJvcicsIChlcikgPT4ge1xuICAgICAgICBpZiAoKGNiICE9IG51bGwpICYmICFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgICBjYihlcilcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBjb21lcyBiZWZvcmUgb3IgYWZ0ZXIgb3IgaXMgdGhlXG4gICAqIHNhbWUgYXMgdGhlIG90aGVyIE5vRmlsdGVyIGluIHNvcnQgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9GaWx0ZXJ9IG90aGVyIC0gVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0xLCAwLCAxIGZvciBsZXNzLCBlcXVhbCwgZ3JlYXRlclxuICAgKi9cbiAgY29tcGFyZShvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgTm9GaWx0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBOb0ZpbHRlcnMnKVxuICAgIH1cbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ1ZjEgPSB0aGlzLnNsaWNlKClcbiAgICAgIGNvbnN0IGJ1ZjIgPSBvdGhlci5zbGljZSgpXG4gICAgICAvLyB0aGVzZSB3aWxsIGJvdGggYmUgYnVmZmVycyBiZWNhdXNlIG9mIHRoZSBjaGVjayBhYm92ZS5cbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmMSkgJiYgQnVmZmVyLmlzQnVmZmVyKGJ1ZjIpKSB7XG4gICAgICAgIHJldHVybiBidWYxLmNvbXBhcmUoYnVmMilcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBhcmUgc3RyZWFtcyBpbiBvYmplY3QgbW9kZScpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvIHRoZXNlIE5vRmlsdGVyJ3MgY29udGFpbiB0aGUgc2FtZSBieXRlcz8gIERvZXNuJ3Qgd29yayBpZiBlaXRoZXIgaXNcbiAgICogaW4gb2JqZWN0IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9GaWx0ZXJ9IG90aGVyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBFcXVhbD9cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpID09PSAwXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBieXRlcyBvciBvYmplY3RzIHdpdGhvdXQgY29uc3VtaW5nIHRoZW0uICBVc2VmdWwgZm9yIGRpYWdub3N0aWNzLlxuICAgKiBOb3RlOiBhcyBhIHNpZGUtZWZmZWN0LCBjb25jYXRlbmF0ZXMgbXVsdGlwbGUgd3JpdGVzIHRvZ2V0aGVyIGludG8gd2hhdFxuICAgKiBsb29rcyBsaWtlIGEgc2luZ2xlIHdyaXRlLCBzbyB0aGF0IHRoaXMgY29uY2F0IGRvZXNuJ3QgaGF2ZSB0byBoYXBwZW5cbiAgICogbXVsdGlwbGUgdGltZXMgd2hlbiB5b3UncmUgZnV0emluZyB3aXRoIHRoZSBzYW1lIE5vRmlsdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0PTBdIC0gYmVnaW5uaW5nIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZD1sZW5ndGhdIC0gZW5kaW5nIG9mZnNldFxuICAgKiBAcmV0dXJucyB7QnVmZmVyfEFycmF5fSBpZiBpbiBvYmplY3QgbW9kZSwgYW4gYXJyYXkgb2Ygb2JqZWN0cy4gIE90aGVyd2lzZSxcbiAgICogICBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgY29udGVudHMuXG4gICAqL1xuICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZkFycmF5KCkuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICB9XG4gICAgY29uc3QgYnVmcyA9IHRoaXMuX2J1ZkFycmF5KClcbiAgICBzd2l0Y2ggKGJ1ZnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgICAgIGNhc2UgMTogcmV0dXJuIGJ1ZnNbMF0uc2xpY2Uoc3RhcnQsIGVuZClcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IGIgPSBCdWZmZXIuY29uY2F0KGJ1ZnMpXG4gICAgICAgIC8vIFRPRE86IHN0b3JlIHRoZSBjb25jYXRlbnRlZCBidWZzIGJhY2tcbiAgICAgICAgLy8gQF9yZWFkYWJsZVN0YXRlLmJ1ZmZlciA9IFtiXVxuICAgICAgICByZXR1cm4gYi5zbGljZShzdGFydCwgZW5kKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICogR2V0IGEgYnl0ZSBieSBvZmZzZXQuICBJIGRpZG4ndCB3YW50IHRvIGdldCBpbnRvIG1ldGFwcm9ncmFtbWluZ1xuICAgICogdG8gZ2l2ZSB5b3UgdGhlIGBOb0ZpbHRlclswXWAgc3ludGF4LlxuICAgICpcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBieXRlIHRvIHJldHJpZXZlXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfSAwLTI1NVxuICAgICovXG4gIGdldChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKClbaW5kZXhdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCBjb21wYXRpYmxlIHdpdGggQnVmZmVyJ3MgdG9KU09OIGltcGxlbWVudGF0aW9uLCBzb1xuICAgKiB0aGF0IHJvdW5kLXRyaXBwaW5nIHdpbGwgcHJvZHVjZSBhIEJ1ZmZlci5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICpcbiAgICogQGV4YW1wbGUgb3V0cHV0IGZvciAnZm9vJ1xuICAgKiAgIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsgMTAyLCAxMTEsIDExMSBdIH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBiID0gdGhpcy5zbGljZSgpXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGIudG9KU09OKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyBhbmQgcmV0dXJucyBhIHN0cmluZyBmcm9tIGJ1ZmZlciBkYXRhIGVuY29kZWQgdXNpbmcgdGhlIHNwZWNpZmllZFxuICAgKiBjaGFyYWN0ZXIgc2V0IGVuY29kaW5nLiBJZiBlbmNvZGluZyBpcyB1bmRlZmluZWQgb3IgbnVsbCwgdGhlbiBlbmNvZGluZ1xuICAgKiBkZWZhdWx0cyB0byAndXRmOCcuIFRoZSBzdGFydCBhbmQgZW5kIHBhcmFtZXRlcnMgZGVmYXVsdCB0byAwIGFuZFxuICAgKiBOb0ZpbHRlci5sZW5ndGggd2hlbiB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSAtIFdoaWNoIHRvIHVzZSBmb3IgZGVjb2Rpbmc/XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gLSBTdGFydCBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmQ9bGVuZ3RoXSAtIEVuZCBvZmZzZXRcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy5zbGljZShzdGFydCwgZW5kKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShidWYpXG4gICAgfVxuICAgIGlmICgoIWVuY29kaW5nIHx8IChlbmNvZGluZyA9PT0gJ3V0ZjgnKSkgJiYgdXRpbC5UZXh0RGVjb2Rlcikge1xuICAgICAgY29uc3QgdGQgPSBuZXcgdXRpbC5UZXh0RGVjb2RlcigndXRmOCcsIHtcbiAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgIGlnbm9yZUJPTTogdHJ1ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0ZC5kZWNvZGUoYnVmKVxuICAgIH1cbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbC5pbnNwZWN0LmN1c3RvbV0oZGVwdGgsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXShkZXB0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1ZnMgPSB0aGlzLl9idWZBcnJheSgpXG4gICAgY29uc3QgaGV4ID0gYnVmcy5tYXAoKGIpID0+IHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgICAgaWYgKChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnN0eWxpemUgOiB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZShiLnRvU3RyaW5nKCdoZXgnKSwgJ3N0cmluZycpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGIudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1dGlsLmluc3BlY3QoYiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9KS5qb2luKCcsICcpXG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gWyR7aGV4fV1gXG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCByZWFkYWJsZSBsZW5ndGgsIGluIGJ5dGVzLlxuICAgKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIEphdmFTY3JpcHQgQmlnSW50IHRvIHRoZSBzdHJlYW0uICBOZWdhdGl2ZSBudW1iZXJzIHdpbGwgYmVcbiAgICogd3JpdHRlbiBhcyB0aGVpciAyJ3MgY29tcGxlbWVudCB2ZXJzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2JpZ2ludH0gdmFsIC0gVGhlIHZhbHVlIHRvIHdyaXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlQmlnSW50KHZhbCkge1xuICAgIGxldCBzdHIgPSB2YWwudG9TdHJpbmcoMTYpXG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgIC8vIHR3bydzIGNvbXBsZW1lbnRcbiAgICAgIC8vIE5vdGU6IHN0ciBhbHdheXMgc3RhcnRzIHdpdGggJy0nIGhlcmUuXG4gICAgICBjb25zdCBzeiA9IEJpZ0ludChNYXRoLmZsb29yKHN0ci5sZW5ndGggLyAyKSlcbiAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMSkgPDwgKHN6ICogQmlnSW50KDgpKVxuICAgICAgdmFsID0gbWFzayArIHZhbFxuICAgICAgc3RyID0gdmFsLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgICBpZiAoc3RyLmxlbmd0aCAlIDIpIHtcbiAgICAgIHN0ciA9ICcwJyArIHN0clxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wdXNoKEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSB2YXJpYWJsZS1zaXplZCBKYXZhU2NyaXB0IHVuc2lnbmVkIEJpZ0ludCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgW2xlbj1udWxsXSAtIG51bWJlciBvZiBieXRlcyB0byByZWFkIG9yIGFsbCByZW1haW5pbmdcbiAgICogICBpZiBudWxsXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAqL1xuICByZWFkVUJpZ0ludChsZW4pIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKGxlbilcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludCgnMHgnICsgYi50b1N0cmluZygnaGV4JykpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHZhcmlhYmxlLXNpemVkIEphdmFTY3JpcHQgc2lnbmVkIEJpZ0ludCBmcm9tIHRoZSBzdHJlYW0gaW4gMidzXG4gICAqIGNvbXBsZW1lbnQgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbj1udWxsXSAtIG51bWJlciBvZiBieXRlcyB0byByZWFkIG9yIGFsbCByZW1haW5pbmdcbiAgICogICBpZiBudWxsXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAqL1xuICByZWFkQmlnSW50KGxlbikge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQobGVuKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBsZXQgcmV0ID0gQmlnSW50KCcweCcgKyBiLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAvLyBuZWdhdGl2ZT9cbiAgICBpZiAoYlswXSAmIDB4ODApIHtcbiAgICAgIC8vIHR3bydzIGNvbXBsZW1lbnRcbiAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMSkgPDwgKEJpZ0ludChiLmxlbmd0aCkgKiBCaWdJbnQoOCkpXG4gICAgICByZXQgPSByZXQgLSBtYXNrXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRoIC0gbWV0aG9kIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gLSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZWFkX2dlbihtZXRoLCBsZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQobGVuKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYlttZXRoXS5jYWxsKGIsIDAsIHRydWUpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aCAtIG1ldGhvZCB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIC0gbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfd3JpdGVfZ2VuKG1ldGgsIGxlbikge1xuICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYyhsZW4pXG4gICAgYlttZXRoXS5jYWxsKGIsIHZhbCwgMCwgdHJ1ZSlcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihOb0ZpbHRlci5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFdyaXRlIGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgMSBieXRlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVVSW50OFxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIDAtMjU1XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDg6IF93cml0ZV9nZW4oJ3dyaXRlVUludDgnLCAxKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDE2TEU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDE2TEUnLCAyKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBiaWctZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDE2QkU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDE2QkUnLCAyKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDMyTEU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBiaWctZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDMyQkU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDMyQkUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBzaWduZWQgOC1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyAxIGJ5dGUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUludDhcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVJbnQ4OiBfd3JpdGVfZ2VuKCd3cml0ZUludDgnLCAxKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBzaWduZWQgbGl0dGxlLWVuZGlhbiAxNi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlSW50MTZMRTogX3dyaXRlX2dlbignd3JpdGVJbnQxNkxFJywgMiksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2lnbmVkIGJpZy1lbmRpYW4gMTYtYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgMiBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlSW50MTZCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZUludDE2QkU6IF93cml0ZV9nZW4oJ3dyaXRlSW50MTZCRScsIDIpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCBsaXR0bGUtZW5kaWFuIDMyLWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUludDMyTEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVJbnQzMkxFOiBfd3JpdGVfZ2VuKCd3cml0ZUludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBzaWduZWQgYmlnLWVuZGlhbiAzMi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlSW50MzJCRTogX3dyaXRlX2dlbignd3JpdGVJbnQzMkJFJywgNCksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgbGl0dGxlLWVuZGlhbiAzMi1iaXQgZmxvYXQgdG8gdGhlIHN0cmVhbS4gIEFkZHMgNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlRmxvYXRMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZUZsb2F0TEU6IF93cml0ZV9nZW4oJ3dyaXRlRmxvYXRMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGJpZy1lbmRpYW4gMzItYml0IGZsb2F0IHRvIHRoZSBzdHJlYW0uICBBZGRzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUZsb2F0QkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVGbG9hdEJFOiBfd3JpdGVfZ2VuKCd3cml0ZUZsb2F0QkUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDY0LWJpdCBmbG9hdCB0byB0aGUgc3RyZWFtLiAgQWRkcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVEb3VibGVMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZURvdWJsZUxFOiBfd3JpdGVfZ2VuKCd3cml0ZURvdWJsZUxFJywgOCksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgYmlnLWVuZGlhbiA2NC1iaXQgZmxvYXQgdG8gdGhlIHN0cmVhbS4gIEFkZHMgOCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlRG91YmxlQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVEb3VibGVCRTogX3dyaXRlX2dlbignd3JpdGVEb3VibGVCRScsIDgpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGFuIHVuc2lnbmVkIDgtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLiAgQ29uc3VtZXMgMSBieXRlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQ4XG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50ODogX3JlYWRfZ2VuKCdyZWFkVUludDgnLCAxKSxcblxuICAvKipcbiAgICogUmVhZCBhIGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MTZMRTogX3JlYWRfZ2VuKCdyZWFkVUludDE2TEUnLCAyKSxcblxuICAvKipcbiAgICogUmVhZCBhIGJpZy1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQxNkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MTZCRTogX3JlYWRfZ2VuKCdyZWFkVUludDE2QkUnLCAyKSxcblxuICAvKipcbiAgICogUmVhZCBhIGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQzMkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MzJMRTogX3JlYWRfZ2VuKCdyZWFkVUludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIGJpZy1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MzJCRTogX3JlYWRfZ2VuKCdyZWFkVUludDMyQkUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIHNpZ25lZCA4LWJpdCBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgMSBieXRlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEludDhcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEludDg6IF9yZWFkX2dlbigncmVhZEludDgnLCAxKSxcblxuICAvKipcbiAgICogUmVhZCBhIHNpZ25lZCAxNi1iaXQgbGl0dGxlLWVuZGlhbiBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgMiBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWRJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRJbnQxNkxFOiBfcmVhZF9nZW4oJ3JlYWRJbnQxNkxFJywgMiksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzaWduZWQgMTYtYml0IGJpZy1lbmRpYW4gaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkSW50MTZCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkSW50MTZCRTogX3JlYWRfZ2VuKCdyZWFkSW50MTZCRScsIDIpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2lnbmVkIDMyLWJpdCBsaXR0bGUtZW5kaWFuIGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEludDMyTEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEludDMyTEU6IF9yZWFkX2dlbigncmVhZEludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIHNpZ25lZCAzMi1iaXQgYmlnLWVuZGlhbiBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWRJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRJbnQzMkJFOiBfcmVhZF9nZW4oJ3JlYWRJbnQzMkJFJywgNCksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSAzMi1iaXQgbGl0dGxlLWVuZGlhbiBmbG9hdCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkRmxvYXRMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkRmxvYXRMRTogX3JlYWRfZ2VuKCdyZWFkRmxvYXRMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgMzItYml0IGJpZy1lbmRpYW4gZmxvYXQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEZsb2F0QkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEZsb2F0QkU6IF9yZWFkX2dlbigncmVhZEZsb2F0QkUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIDY0LWJpdCBsaXR0bGUtZW5kaWFuIGZsb2F0IGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgOCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWREb3VibGVMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkRG91YmxlTEU6IF9yZWFkX2dlbigncmVhZERvdWJsZUxFJywgOCksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSA2NC1iaXQgYmlnLWVuZGlhbiBmbG9hdCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDggYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkRG91YmxlQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZERvdWJsZUJFOiBfcmVhZF9nZW4oJ3JlYWREb3VibGVCRScsIDgpXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vRmlsdGVyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuXG5leHBvcnRzLmhvbWVkaXIgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAnLydcbn07XG4iLCJ2YXIgbm9DYXNlID0gcmVxdWlyZSgnbm8tY2FzZScpXG5cbi8qKlxuICogUGFyYW0gY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtsb2NhbGVdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5vQ2FzZSh2YWx1ZSwgbG9jYWxlLCAnLScpXG59XG4iLCJ2YXIgY2FtZWxDYXNlID0gcmVxdWlyZSgnY2FtZWwtY2FzZScpXG52YXIgdXBwZXJDYXNlRmlyc3QgPSByZXF1aXJlKCd1cHBlci1jYXNlLWZpcnN0JylcblxuLyoqXG4gKiBQYXNjYWwgY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSAgW2xvY2FsZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFttZXJnZU51bWJlcnNdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBsb2NhbGUsIG1lcmdlTnVtYmVycykge1xuICByZXR1cm4gdXBwZXJDYXNlRmlyc3QoY2FtZWxDYXNlKHZhbHVlLCBsb2NhbGUsIG1lcmdlTnVtYmVycyksIGxvY2FsZSlcbn1cbiIsInZhciBub0Nhc2UgPSByZXF1aXJlKCduby1jYXNlJylcblxuLyoqXG4gKiBQYXRoIGNhc2UgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBbbG9jYWxlXVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbG9jYWxlKSB7XG4gIHJldHVybiBub0Nhc2UodmFsdWUsIGxvY2FsZSwgJy8nKVxufVxuIiwidmFyIGlzYXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW11cbiAgdmFyIGtleSA9IDBcbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgcGF0aCA9ICcnXG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLydcbiAgdmFyIHJlc1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG4gICAgdmFyIHByZWZpeCA9IHJlc1syXVxuICAgIHZhciBuYW1lID0gcmVzWzNdXG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF1cbiAgICB2YXIgZ3JvdXAgPSByZXNbNV1cbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl1cbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN11cblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gICAgICBwYXRoID0gJydcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXhcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwXG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pXG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpXG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aClcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKVxuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2VcbiAgdmFyIHJvdXRlID0gJydcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJ1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonXG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSdcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKVxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlclxuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nXG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnXG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJ1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTUuMFxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5Qb3BwZXIgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xudmFyIHRpbWVvdXREdXJhdGlvbiA9IDA7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICB0aW1lb3V0RHVyYXRpb24gPSAxO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBwYXJzZUludChodG1sWydvZmZzZXQnICsgYXhpc10pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldKSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcyhkb2N1bWVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5ib3R0b20gLSByZXN1bHQudG9wO1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIGlzSUUxMCA9IGlzSUUoMTApO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoLCAxMCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgsIDEwKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCwgMTApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIHZhciBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcic7XG4gIGJvdW5kYXJpZXMubGVmdCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5sZWZ0IHx8IDA7XG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIHZhciBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChvcHRpb25zLnBsYWNlbWVudCwgcmVmZXJlbmNlT2Zmc2V0cywgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIG5vUm91bmQgPSBmdW5jdGlvbiBub1JvdW5kKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB2YXIgcmVmZXJlbmNlV2lkdGggPSByb3VuZChyZWZlcmVuY2Uud2lkdGgpO1xuICB2YXIgcG9wcGVyV2lkdGggPSByb3VuZChwb3BwZXIud2lkdGgpO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICB2YXIgc2FtZVdpZHRoUGFyaXR5ID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSBwb3BwZXJXaWR0aCAlIDI7XG4gIHZhciBib3RoT2RkV2lkdGggPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyV2lkdGggJSAyID09PSAxO1xuXG4gIHZhciBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoUGFyaXR5ID8gcm91bmQgOiBmbG9vcjtcbiAgdmFyIHZlcnRpY2FsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IHJvdW5kO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogaG9yaXpvbnRhbFRvSW50ZWdlcihib3RoT2RkV2lkdGggJiYgIWlzVmFyaWF0aW9uICYmIHNob3VsZFJvdW5kID8gcG9wcGVyLmxlZnQgLSAxIDogcG9wcGVyLmxlZnQpLFxuICAgIHRvcDogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogaG9yaXpvbnRhbFRvSW50ZWdlcihwb3BwZXIucmlnaHQpXG4gIH07XG59XG5cbnZhciBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIgJiYgL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveCk7XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgLy8gd2hlbiBvZmZzZXRQYXJlbnQgaXMgPGh0bWw+IHRoZSBwb3NpdGlvbmluZyBpcyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gKGV4Y2x1ZGluZyB0aGUgc2Nyb2xsYmFyKVxuICAgIC8vIGFuZCBub3QgdGhlIGJvdHRvbSBvZiB0aGUgaHRtbCBlbGVtZW50XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudC5jbGllbnRXaWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVuY3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdLCAxMCk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSwgMTApO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1lbmRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeVJlZiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0xlZnQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCk7XG5cbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgLyBYTUwgZWxlbWVudCB1c2VkIGFzIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiB1cGRhdGUuIEl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIFBvcHBlcjtcbn0oKTtcblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxucmV0dXJuIFBvcHBlcjtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgK1xuICAgICAgICAgICAgICAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbldpdGhSZXNldCgpIHt9XG5lbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LnJlc2V0V2FybmluZ0NhY2hlID0gZW1wdHlGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJpZ2ludDogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBlbGVtZW50VHlwZTogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltLFxuXG4gICAgY2hlY2tQcm9wVHlwZXM6IGVtcHR5RnVuY3Rpb25XaXRoUmVzZXQsXG4gICAgcmVzZXRXYXJuaW5nQ2FjaGU6IGVtcHR5RnVuY3Rpb25cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYmlnaW50OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYmlnaW50JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YToge307XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXCIpO1xuZnVuY3Rpb24gdW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICBpZiAocm5nICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFsoMCwgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKShmcm9tLCB0bywgbmV4dFJuZyksIG5leHRSbmddO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHJuZykge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gWygwLCBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24pKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfTtcbn1cbmV4cG9ydHMudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25cIik7XG5mdW5jdGlvbiB1bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICBpZiAocm5nICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFsoMCwgVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24pKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbKDAsIFVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKShmcm9tLCB0bywgbmV4dFJuZyksIG5leHRSbmddO1xuICAgIH07XG59XG5leHBvcnRzLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSB1bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bmlmb3JtSW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25cIik7XG5mdW5jdGlvbiB1bmlmb3JtSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICBpZiAocm5nICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFsoMCwgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24pKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbKDAsIFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKShmcm9tLCB0bywgbmV4dFJuZyksIG5leHRSbmddO1xuICAgIH07XG59XG5leHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB1bmlmb3JtSW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgQXJyYXlJbnRfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9BcnJheUludFwiKTtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXCIpO1xuZnVuY3Rpb24gdW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplID0gKDAsIEFycmF5SW50XzEudHJpbUFycmF5SW50SW5wbGFjZSkoKDAsIEFycmF5SW50XzEuYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50KSgoMCwgQXJyYXlJbnRfMS5zdWJzdHJhY3RBcnJheUludFRvTmV3KSh0bywgZnJvbSkpKTtcbiAgICB2YXIgZW1wdHlBcnJheUludERhdGEgPSByYW5nZVNpemUuZGF0YS5zbGljZSgwKTtcbiAgICB2YXIgZyA9ICgwLCBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsKShlbXB0eUFycmF5SW50RGF0YSwgcmFuZ2VTaXplLmRhdGEsIHJuZyk7XG4gICAgcmV0dXJuICgwLCBBcnJheUludF8xLnRyaW1BcnJheUludElucGxhY2UpKCgwLCBBcnJheUludF8xLmFkZEFycmF5SW50VG9OZXcpKHsgc2lnbjogMSwgZGF0YTogZyB9LCBmcm9tKSk7XG59XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IHVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBTQmlnSW50ID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCcgPyBCaWdJbnQgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgZGlmZiA9IHRvIC0gZnJvbSArIFNCaWdJbnQoMSk7XG4gICAgdmFyIE1pblJuZyA9IFNCaWdJbnQocm5nLm1pbigpKTtcbiAgICB2YXIgTnVtVmFsdWVzID0gU0JpZ0ludChybmcubWF4KCkgLSBybmcubWluKCkgKyAxKTtcbiAgICB2YXIgRmluYWxOdW1WYWx1ZXMgPSBOdW1WYWx1ZXM7XG4gICAgdmFyIE51bUl0ZXJhdGlvbnMgPSBTQmlnSW50KDEpO1xuICAgIHdoaWxlIChGaW5hbE51bVZhbHVlcyA8IGRpZmYpIHtcbiAgICAgICAgRmluYWxOdW1WYWx1ZXMgKj0gTnVtVmFsdWVzO1xuICAgICAgICArK051bUl0ZXJhdGlvbnM7XG4gICAgfVxuICAgIHZhciBNYXhBY2NlcHRlZFJhbmRvbSA9IEZpbmFsTnVtVmFsdWVzIC0gKEZpbmFsTnVtVmFsdWVzICUgZGlmZik7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gU0JpZ0ludCgwKTtcbiAgICAgICAgZm9yICh2YXIgbnVtID0gU0JpZ0ludCgwKTsgbnVtICE9PSBOdW1JdGVyYXRpb25zOyArK251bSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bVZhbHVlcyAqIHZhbHVlICsgKFNCaWdJbnQob3V0KSAtIE1pblJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgTWF4QWNjZXB0ZWRSYW5kb20pIHtcbiAgICAgICAgICAgIHZhciBpbkRpZmYgPSB2YWx1ZSAlIGRpZmY7XG4gICAgICAgICAgICByZXR1cm4gaW5EaWZmICsgZnJvbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IHVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbHMvVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXCIpO1xudmFyIEFycmF5SW50XzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbHMvQXJyYXlJbnRcIik7XG52YXIgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbFwiKTtcbnZhciBzYWZlTnVtYmVyTWF4U2FmZUludGVnZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbnZhciBzaGFyZWRBID0geyBzaWduOiAxLCBkYXRhOiBbMCwgMF0gfTtcbnZhciBzaGFyZWRCID0geyBzaWduOiAxLCBkYXRhOiBbMCwgMF0gfTtcbnZhciBzaGFyZWRDID0geyBzaWduOiAxLCBkYXRhOiBbMCwgMF0gfTtcbnZhciBzaGFyZWREYXRhID0gWzAsIDBdO1xuZnVuY3Rpb24gdW5pZm9ybUxhcmdlSW50SW50ZXJuYWwoZnJvbSwgdG8sIHJhbmdlU2l6ZSwgcm5nKSB7XG4gICAgdmFyIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUgPSByYW5nZVNpemUgPD0gc2FmZU51bWJlck1heFNhZmVJbnRlZ2VyXG4gICAgICAgID8gKDAsIEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NCkoc2hhcmVkQywgcmFuZ2VTaXplKVxuICAgICAgICA6ICgwLCBBcnJheUludF8xLnN1YnN0cmFjdEFycmF5SW50NjQpKHNoYXJlZEMsICgwLCBBcnJheUludF8xLmZyb21OdW1iZXJUb0FycmF5SW50NjQpKHNoYXJlZEEsIHRvKSwgKDAsIEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NCkoc2hhcmVkQiwgZnJvbSkpO1xuICAgIGlmIChyYW5nZVNpemVBcnJheUludFZhbHVlLmRhdGFbMV0gPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhWzBdICs9IDE7XG4gICAgICAgIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVsxXSA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByYW5nZVNpemVBcnJheUludFZhbHVlLmRhdGFbMV0gKz0gMTtcbiAgICB9XG4gICAgKDAsIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwpKHNoYXJlZERhdGEsIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YSwgcm5nKTtcbiAgICByZXR1cm4gc2hhcmVkRGF0YVswXSAqIDB4MTAwMDAwMDAwICsgc2hhcmVkRGF0YVsxXSArIGZyb207XG59XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplID0gdG8gLSBmcm9tO1xuICAgIGlmIChyYW5nZVNpemUgPD0gMHhmZmZmZmZmZikge1xuICAgICAgICB2YXIgZyA9ICgwLCBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWwpKHJhbmdlU2l6ZSArIDEsIHJuZyk7XG4gICAgICAgIHJldHVybiBnICsgZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaWZvcm1MYXJnZUludEludGVybmFsKGZyb20sIHRvLCByYW5nZVNpemUsIHJuZyk7XG59XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB1bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zdWJzdHJhY3RBcnJheUludDY0ID0gZXhwb3J0cy5mcm9tTnVtYmVyVG9BcnJheUludDY0ID0gZXhwb3J0cy50cmltQXJyYXlJbnRJbnBsYWNlID0gZXhwb3J0cy5zdWJzdHJhY3RBcnJheUludFRvTmV3ID0gZXhwb3J0cy5hZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQgPSBleHBvcnRzLmFkZEFycmF5SW50VG9OZXcgPSB2b2lkIDA7XG5mdW5jdGlvbiBhZGRBcnJheUludFRvTmV3KGFycmF5SW50QSwgYXJyYXlJbnRCKSB7XG4gICAgaWYgKGFycmF5SW50QS5zaWduICE9PSBhcnJheUludEIuc2lnbikge1xuICAgICAgICByZXR1cm4gc3Vic3RyYWN0QXJyYXlJbnRUb05ldyhhcnJheUludEEsIHsgc2lnbjogLWFycmF5SW50Qi5zaWduLCBkYXRhOiBhcnJheUludEIuZGF0YSB9KTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgcmVtaW5kZXIgPSAwO1xuICAgIHZhciBkYXRhQSA9IGFycmF5SW50QS5kYXRhO1xuICAgIHZhciBkYXRhQiA9IGFycmF5SW50Qi5kYXRhO1xuICAgIGZvciAodmFyIGluZGV4QSA9IGRhdGFBLmxlbmd0aCAtIDEsIGluZGV4QiA9IGRhdGFCLmxlbmd0aCAtIDE7IGluZGV4QSA+PSAwIHx8IGluZGV4QiA+PSAwOyAtLWluZGV4QSwgLS1pbmRleEIpIHtcbiAgICAgICAgdmFyIHZBID0gaW5kZXhBID49IDAgPyBkYXRhQVtpbmRleEFdIDogMDtcbiAgICAgICAgdmFyIHZCID0gaW5kZXhCID49IDAgPyBkYXRhQltpbmRleEJdIDogMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB2QSArIHZCICsgcmVtaW5kZXI7XG4gICAgICAgIGRhdGEucHVzaChjdXJyZW50ID4+PiAwKTtcbiAgICAgICAgcmVtaW5kZXIgPSB+fihjdXJyZW50IC8gMHgxMDAwMDAwMDApO1xuICAgIH1cbiAgICBpZiAocmVtaW5kZXIgIT09IDApIHtcbiAgICAgICAgZGF0YS5wdXNoKHJlbWluZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnbjogYXJyYXlJbnRBLnNpZ24sIGRhdGE6IGRhdGEucmV2ZXJzZSgpIH07XG59XG5leHBvcnRzLmFkZEFycmF5SW50VG9OZXcgPSBhZGRBcnJheUludFRvTmV3O1xuZnVuY3Rpb24gYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50KGFycmF5SW50KSB7XG4gICAgYXJyYXlJbnQuc2lnbiA9IDE7XG4gICAgdmFyIGRhdGEgPSBhcnJheUludC5kYXRhO1xuICAgIGZvciAodmFyIGluZGV4ID0gZGF0YS5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyAtLWluZGV4KSB7XG4gICAgICAgIGlmIChkYXRhW2luZGV4XSA9PT0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheUludDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkYXRhLnVuc2hpZnQoMSk7XG4gICAgcmV0dXJuIGFycmF5SW50O1xufVxuZXhwb3J0cy5hZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQgPSBhZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQ7XG5mdW5jdGlvbiBpc1N0cmljdGx5U21hbGxlcihkYXRhQSwgZGF0YUIpIHtcbiAgICB2YXIgbWF4TGVuZ3RoID0gTWF0aC5tYXgoZGF0YUEubGVuZ3RoLCBkYXRhQi5sZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBtYXhMZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4QSA9IGluZGV4ICsgZGF0YUEubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXhCID0gaW5kZXggKyBkYXRhQi5sZW5ndGggLSBtYXhMZW5ndGg7XG4gICAgICAgIHZhciB2QSA9IGluZGV4QSA+PSAwID8gZGF0YUFbaW5kZXhBXSA6IDA7XG4gICAgICAgIHZhciB2QiA9IGluZGV4QiA+PSAwID8gZGF0YUJbaW5kZXhCXSA6IDA7XG4gICAgICAgIGlmICh2QSA8IHZCKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh2QSA+IHZCKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdWJzdHJhY3RBcnJheUludFRvTmV3KGFycmF5SW50QSwgYXJyYXlJbnRCKSB7XG4gICAgaWYgKGFycmF5SW50QS5zaWduICE9PSBhcnJheUludEIuc2lnbikge1xuICAgICAgICByZXR1cm4gYWRkQXJyYXlJbnRUb05ldyhhcnJheUludEEsIHsgc2lnbjogLWFycmF5SW50Qi5zaWduLCBkYXRhOiBhcnJheUludEIuZGF0YSB9KTtcbiAgICB9XG4gICAgdmFyIGRhdGFBID0gYXJyYXlJbnRBLmRhdGE7XG4gICAgdmFyIGRhdGFCID0gYXJyYXlJbnRCLmRhdGE7XG4gICAgaWYgKGlzU3RyaWN0bHlTbWFsbGVyKGRhdGFBLCBkYXRhQikpIHtcbiAgICAgICAgdmFyIG91dCA9IHN1YnN0cmFjdEFycmF5SW50VG9OZXcoYXJyYXlJbnRCLCBhcnJheUludEEpO1xuICAgICAgICBvdXQuc2lnbiA9IC1vdXQuc2lnbjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgcmVtaW5kZXIgPSAwO1xuICAgIGZvciAodmFyIGluZGV4QSA9IGRhdGFBLmxlbmd0aCAtIDEsIGluZGV4QiA9IGRhdGFCLmxlbmd0aCAtIDE7IGluZGV4QSA+PSAwIHx8IGluZGV4QiA+PSAwOyAtLWluZGV4QSwgLS1pbmRleEIpIHtcbiAgICAgICAgdmFyIHZBID0gaW5kZXhBID49IDAgPyBkYXRhQVtpbmRleEFdIDogMDtcbiAgICAgICAgdmFyIHZCID0gaW5kZXhCID49IDAgPyBkYXRhQltpbmRleEJdIDogMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB2QSAtIHZCIC0gcmVtaW5kZXI7XG4gICAgICAgIGRhdGEucHVzaChjdXJyZW50ID4+PiAwKTtcbiAgICAgICAgcmVtaW5kZXIgPSBjdXJyZW50IDwgMCA/IDEgOiAwO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWduOiBhcnJheUludEEuc2lnbiwgZGF0YTogZGF0YS5yZXZlcnNlKCkgfTtcbn1cbmV4cG9ydHMuc3Vic3RyYWN0QXJyYXlJbnRUb05ldyA9IHN1YnN0cmFjdEFycmF5SW50VG9OZXc7XG5mdW5jdGlvbiB0cmltQXJyYXlJbnRJbnBsYWNlKGFycmF5SW50KSB7XG4gICAgdmFyIGRhdGEgPSBhcnJheUludC5kYXRhO1xuICAgIHZhciBmaXJzdE5vblplcm8gPSAwO1xuICAgIGZvciAoOyBmaXJzdE5vblplcm8gIT09IGRhdGEubGVuZ3RoICYmIGRhdGFbZmlyc3ROb25aZXJvXSA9PT0gMDsgKytmaXJzdE5vblplcm8pIHsgfVxuICAgIGlmIChmaXJzdE5vblplcm8gPT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGFycmF5SW50LnNpZ24gPSAxO1xuICAgICAgICBhcnJheUludC5kYXRhID0gWzBdO1xuICAgICAgICByZXR1cm4gYXJyYXlJbnQ7XG4gICAgfVxuICAgIGRhdGEuc3BsaWNlKDAsIGZpcnN0Tm9uWmVybyk7XG4gICAgcmV0dXJuIGFycmF5SW50O1xufVxuZXhwb3J0cy50cmltQXJyYXlJbnRJbnBsYWNlID0gdHJpbUFycmF5SW50SW5wbGFjZTtcbmZ1bmN0aW9uIGZyb21OdW1iZXJUb0FycmF5SW50NjQob3V0LCBuKSB7XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHZhciBwb3NOID0gLW47XG4gICAgICAgIG91dC5zaWduID0gLTE7XG4gICAgICAgIG91dC5kYXRhWzBdID0gfn4ocG9zTiAvIDB4MTAwMDAwMDAwKTtcbiAgICAgICAgb3V0LmRhdGFbMV0gPSBwb3NOID4+PiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0LnNpZ24gPSAxO1xuICAgICAgICBvdXQuZGF0YVswXSA9IH5+KG4gLyAweDEwMDAwMDAwMCk7XG4gICAgICAgIG91dC5kYXRhWzFdID0gbiA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMuZnJvbU51bWJlclRvQXJyYXlJbnQ2NCA9IGZyb21OdW1iZXJUb0FycmF5SW50NjQ7XG5mdW5jdGlvbiBzdWJzdHJhY3RBcnJheUludDY0KG91dCwgYXJyYXlJbnRBLCBhcnJheUludEIpIHtcbiAgICB2YXIgbG93QSA9IGFycmF5SW50QS5kYXRhWzFdO1xuICAgIHZhciBoaWdoQSA9IGFycmF5SW50QS5kYXRhWzBdO1xuICAgIHZhciBzaWduQSA9IGFycmF5SW50QS5zaWduO1xuICAgIHZhciBsb3dCID0gYXJyYXlJbnRCLmRhdGFbMV07XG4gICAgdmFyIGhpZ2hCID0gYXJyYXlJbnRCLmRhdGFbMF07XG4gICAgdmFyIHNpZ25CID0gYXJyYXlJbnRCLnNpZ247XG4gICAgb3V0LnNpZ24gPSAxO1xuICAgIGlmIChzaWduQSA9PT0gMSAmJiBzaWduQiA9PT0gLTEpIHtcbiAgICAgICAgdmFyIGxvd18xID0gbG93QSArIGxvd0I7XG4gICAgICAgIHZhciBoaWdoID0gaGlnaEEgKyBoaWdoQiArIChsb3dfMSA+IDB4ZmZmZmZmZmYgPyAxIDogMCk7XG4gICAgICAgIG91dC5kYXRhWzBdID0gaGlnaCA+Pj4gMDtcbiAgICAgICAgb3V0LmRhdGFbMV0gPSBsb3dfMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdmFyIGxvd0ZpcnN0ID0gbG93QTtcbiAgICB2YXIgaGlnaEZpcnN0ID0gaGlnaEE7XG4gICAgdmFyIGxvd1NlY29uZCA9IGxvd0I7XG4gICAgdmFyIGhpZ2hTZWNvbmQgPSBoaWdoQjtcbiAgICBpZiAoc2lnbkEgPT09IC0xKSB7XG4gICAgICAgIGxvd0ZpcnN0ID0gbG93QjtcbiAgICAgICAgaGlnaEZpcnN0ID0gaGlnaEI7XG4gICAgICAgIGxvd1NlY29uZCA9IGxvd0E7XG4gICAgICAgIGhpZ2hTZWNvbmQgPSBoaWdoQTtcbiAgICB9XG4gICAgdmFyIHJlbWluZGVyTG93ID0gMDtcbiAgICB2YXIgbG93ID0gbG93Rmlyc3QgLSBsb3dTZWNvbmQ7XG4gICAgaWYgKGxvdyA8IDApIHtcbiAgICAgICAgcmVtaW5kZXJMb3cgPSAxO1xuICAgICAgICBsb3cgPSBsb3cgPj4+IDA7XG4gICAgfVxuICAgIG91dC5kYXRhWzBdID0gaGlnaEZpcnN0IC0gaGlnaFNlY29uZCAtIHJlbWluZGVyTG93O1xuICAgIG91dC5kYXRhWzFdID0gbG93O1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnN1YnN0cmFjdEFycmF5SW50NjQgPSBzdWJzdHJhY3RBcnJheUludDY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbCA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbFwiKTtcbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsKG91dCwgcmFuZ2VTaXplLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VMZW5ndGggPSByYW5nZVNpemUubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggIT09IHJhbmdlTGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhSYW5nZVNpemUgPSBpbmRleCA9PT0gMCA/IHJhbmdlU2l6ZVswXSArIDEgOiAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgIHZhciBnID0gKDAsIFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbCkoaW5kZXhSYW5nZVNpemUsIHJuZyk7XG4gICAgICAgICAgICBvdXRbaW5kZXhdID0gZztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4ICE9PSByYW5nZUxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBvdXRbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRJblJhbmdlID0gcmFuZ2VTaXplW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50IDwgY3VycmVudEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA+IGN1cnJlbnRJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbCA9IHZvaWQgMDtcbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbChyYW5nZVNpemUsIHJuZykge1xuICAgIHZhciBNaW5SbmcgPSBybmcubWluKCk7XG4gICAgdmFyIE51bVZhbHVlcyA9IHJuZy5tYXgoKSAtIHJuZy5taW4oKSArIDE7XG4gICAgaWYgKHJhbmdlU2l6ZSA8PSBOdW1WYWx1ZXMpIHtcbiAgICAgICAgdmFyIG5ybmdfMSA9IHJuZztcbiAgICAgICAgdmFyIE1heEFsbG93ZWQgPSBOdW1WYWx1ZXMgLSAoTnVtVmFsdWVzICUgcmFuZ2VTaXplKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBucm5nXzEudW5zYWZlTmV4dCgpO1xuICAgICAgICAgICAgdmFyIGRlbHRhViA9IG91dCAtIE1pblJuZztcbiAgICAgICAgICAgIGlmIChkZWx0YVYgPCBNYXhBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbHRhViAlIHJhbmdlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgRmluYWxOdW1WYWx1ZXMgPSBOdW1WYWx1ZXMgKiBOdW1WYWx1ZXM7XG4gICAgdmFyIE51bUl0ZXJhdGlvbnMgPSAyO1xuICAgIHdoaWxlIChGaW5hbE51bVZhbHVlcyA8IHJhbmdlU2l6ZSkge1xuICAgICAgICBGaW5hbE51bVZhbHVlcyAqPSBOdW1WYWx1ZXM7XG4gICAgICAgICsrTnVtSXRlcmF0aW9ucztcbiAgICB9XG4gICAgdmFyIE1heEFjY2VwdGVkUmFuZG9tID0gcmFuZ2VTaXplICogTWF0aC5mbG9vcigoMSAqIEZpbmFsTnVtVmFsdWVzKSAvIHJhbmdlU2l6ZSk7XG4gICAgdmFyIG5ybmcgPSBybmc7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcbiAgICAgICAgZm9yICh2YXIgbnVtID0gMDsgbnVtICE9PSBOdW1JdGVyYXRpb25zOyArK251bSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ybmcudW5zYWZlTmV4dCgpO1xuICAgICAgICAgICAgdmFsdWUgPSBOdW1WYWx1ZXMgKiB2YWx1ZSArIChvdXQgLSBNaW5SbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IE1heEFjY2VwdGVkUmFuZG9tKSB7XG4gICAgICAgICAgICB2YXIgaW5EaWZmID0gdmFsdWUgLSByYW5nZVNpemUgKiBNYXRoLmZsb29yKCgxICogdmFsdWUpIC8gcmFuZ2VTaXplKTtcbiAgICAgICAgICAgIHJldHVybiBpbkRpZmY7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbCA9IHVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29uZ3J1ZW50aWFsMzIgPSBleHBvcnRzLmNvbmdydWVudGlhbCA9IHZvaWQgMDtcbnZhciBNVUxUSVBMSUVSID0gMHgwMDAzNDNmZDtcbnZhciBJTkNSRU1FTlQgPSAweDAwMjY5ZWMzO1xudmFyIE1BU0sgPSAweGZmZmZmZmZmO1xudmFyIE1BU0tfMiA9ICgxIDw8IDMxKSAtIDE7XG52YXIgY29tcHV0ZU5leHRTZWVkID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICByZXR1cm4gKHNlZWQgKiBNVUxUSVBMSUVSICsgSU5DUkVNRU5UKSAmIE1BU0s7XG59O1xudmFyIGNvbXB1dGVWYWx1ZUZyb21OZXh0U2VlZCA9IGZ1bmN0aW9uIChuZXh0c2VlZCkge1xuICAgIHJldHVybiAobmV4dHNlZWQgJiBNQVNLXzIpID4+IDE2O1xufTtcbnZhciBMaW5lYXJDb25ncnVlbnRpYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVhckNvbmdydWVudGlhbChzZWVkKSB7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgfVxuICAgIExpbmVhckNvbmdydWVudGlhbC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsLm1pbjtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsLm1heDtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsKHRoaXMuc2VlZCk7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gbmV3IExpbmVhckNvbmdydWVudGlhbCh0aGlzLnNlZWQpO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbC5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gY29tcHV0ZU5leHRTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlVmFsdWVGcm9tTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbC5taW4gPSAwO1xuICAgIExpbmVhckNvbmdydWVudGlhbC5tYXggPSBNYXRoLnBvdygyLCAxNSkgLSAxO1xuICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWw7XG59KCkpO1xudmFyIExpbmVhckNvbmdydWVudGlhbDMyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5lYXJDb25ncnVlbnRpYWwzMihzZWVkKSB7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgfVxuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwzMi5taW47XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsMzIubWF4O1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVhckNvbmdydWVudGlhbDMyKHRoaXMuc2VlZCk7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsMzIodGhpcy5zZWVkKTtcbiAgICAgICAgdmFyIG91dCA9IG5leHRSbmcudW5zYWZlTmV4dCgpO1xuICAgICAgICByZXR1cm4gW291dCwgbmV4dFJuZ107XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHMxID0gY29tcHV0ZU5leHRTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciB2MSA9IGNvbXB1dGVWYWx1ZUZyb21OZXh0U2VlZChzMSk7XG4gICAgICAgIHZhciBzMiA9IGNvbXB1dGVOZXh0U2VlZChzMSk7XG4gICAgICAgIHZhciB2MiA9IGNvbXB1dGVWYWx1ZUZyb21OZXh0U2VlZChzMik7XG4gICAgICAgIHRoaXMuc2VlZCA9IGNvbXB1dGVOZXh0U2VlZChzMik7XG4gICAgICAgIHZhciB2MyA9IGNvbXB1dGVWYWx1ZUZyb21OZXh0U2VlZCh0aGlzLnNlZWQpO1xuICAgICAgICB2YXIgdm5leHQgPSB2MyArICgodjIgKyAodjEgPDwgMTUpKSA8PCAxNSk7XG4gICAgICAgIHJldHVybiAoKHZuZXh0ICsgMHg4MDAwMDAwMCkgfCAwKSArIDB4ODAwMDAwMDA7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5taW4gPSAwO1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLm1heCA9IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDMyO1xufSgpKTtcbnZhciBjb25ncnVlbnRpYWwgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsKHNlZWQpO1xufTtcbmV4cG9ydHMuY29uZ3J1ZW50aWFsID0gY29uZ3J1ZW50aWFsO1xudmFyIGNvbmdydWVudGlhbDMyID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhckNvbmdydWVudGlhbDMyKHNlZWQpO1xufTtcbmV4cG9ydHMuY29uZ3J1ZW50aWFsMzIgPSBjb25ncnVlbnRpYWwzMjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBNZXJzZW5uZVR3aXN0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcnNlbm5lVHdpc3RlcihzdGF0ZXMsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIE1lcnNlbm5lVHdpc3Rlci50d2lzdCA9IGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICAgIHZhciBtdCA9IHByZXYuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4ICE9PSBNZXJzZW5uZVR3aXN0ZXIuTiAtIE1lcnNlbm5lVHdpc3Rlci5NOyArK2lkeCkge1xuICAgICAgICAgICAgdmFyIHlfMSA9IChtdFtpZHhdICYgTWVyc2VubmVUd2lzdGVyLk1BU0tfVVBQRVIpICsgKG10W2lkeCArIDFdICYgTWVyc2VubmVUd2lzdGVyLk1BU0tfTE9XRVIpO1xuICAgICAgICAgICAgbXRbaWR4XSA9IG10W2lkeCArIE1lcnNlbm5lVHdpc3Rlci5NXSBeICh5XzEgPj4+IDEpIF4gKC0oeV8xICYgMSkgJiBNZXJzZW5uZVR3aXN0ZXIuQSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaWR4ID0gTWVyc2VubmVUd2lzdGVyLk4gLSBNZXJzZW5uZVR3aXN0ZXIuTTsgaWR4ICE9PSBNZXJzZW5uZVR3aXN0ZXIuTiAtIDE7ICsraWR4KSB7XG4gICAgICAgICAgICB2YXIgeV8yID0gKG10W2lkeF0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUikgKyAobXRbaWR4ICsgMV0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19MT1dFUik7XG4gICAgICAgICAgICBtdFtpZHhdID0gbXRbaWR4ICsgTWVyc2VubmVUd2lzdGVyLk0gLSBNZXJzZW5uZVR3aXN0ZXIuTl0gXiAoeV8yID4+PiAxKSBeICgtKHlfMiAmIDEpICYgTWVyc2VubmVUd2lzdGVyLkEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gKG10W01lcnNlbm5lVHdpc3Rlci5OIC0gMV0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUikgKyAobXRbMF0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19MT1dFUik7XG4gICAgICAgIG10W01lcnNlbm5lVHdpc3Rlci5OIC0gMV0gPSBtdFtNZXJzZW5uZVR3aXN0ZXIuTSAtIDFdIF4gKHkgPj4+IDEpIF4gKC0oeSAmIDEpICYgTWVyc2VubmVUd2lzdGVyLkEpO1xuICAgICAgICByZXR1cm4gbXQ7XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuc2VlZGVkID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgdmFyIG91dCA9IEFycmF5KE1lcnNlbm5lVHdpc3Rlci5OKTtcbiAgICAgICAgb3V0WzBdID0gc2VlZDtcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMTsgaWR4ICE9PSBNZXJzZW5uZVR3aXN0ZXIuTjsgKytpZHgpIHtcbiAgICAgICAgICAgIHZhciB4b3JlZCA9IG91dFtpZHggLSAxXSBeIChvdXRbaWR4IC0gMV0gPj4+IDMwKTtcbiAgICAgICAgICAgIG91dFtpZHhdID0gKE1hdGguaW11bChNZXJzZW5uZVR3aXN0ZXIuRiwgeG9yZWQpICsgaWR4KSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5mcm9tID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXJzZW5uZVR3aXN0ZXIoTWVyc2VubmVUd2lzdGVyLnR3aXN0KE1lcnNlbm5lVHdpc3Rlci5zZWVkZWQoc2VlZCkpLCAwKTtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWVyc2VubmVUd2lzdGVyLm1pbjtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWVyc2VubmVUd2lzdGVyLm1heDtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVyc2VubmVUd2lzdGVyKHRoaXMuc3RhdGVzLCB0aGlzLmluZGV4KTtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgTWVyc2VubmVUd2lzdGVyKHRoaXMuc3RhdGVzLCB0aGlzLmluZGV4KTtcbiAgICAgICAgdmFyIG91dCA9IG5leHRSbmcudW5zYWZlTmV4dCgpO1xuICAgICAgICByZXR1cm4gW291dCwgbmV4dFJuZ107XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnVuc2FmZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy5zdGF0ZXNbdGhpcy5pbmRleF07XG4gICAgICAgIHkgXj0gdGhpcy5zdGF0ZXNbdGhpcy5pbmRleF0gPj4+IE1lcnNlbm5lVHdpc3Rlci5VO1xuICAgICAgICB5IF49ICh5IDw8IE1lcnNlbm5lVHdpc3Rlci5TKSAmIE1lcnNlbm5lVHdpc3Rlci5CO1xuICAgICAgICB5IF49ICh5IDw8IE1lcnNlbm5lVHdpc3Rlci5UKSAmIE1lcnNlbm5lVHdpc3Rlci5DO1xuICAgICAgICB5IF49IHkgPj4+IE1lcnNlbm5lVHdpc3Rlci5MO1xuICAgICAgICBpZiAoKyt0aGlzLmluZGV4ID49IE1lcnNlbm5lVHdpc3Rlci5OKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcyA9IE1lcnNlbm5lVHdpc3Rlci50d2lzdCh0aGlzLnN0YXRlcyk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geSA+Pj4gMDtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5taW4gPSAwO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5tYXggPSAweGZmZmZmZmZmO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5OID0gNjI0O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5NID0gMzk3O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5SID0gMzE7XG4gICAgTWVyc2VubmVUd2lzdGVyLkEgPSAweDk5MDhiMGRmO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5GID0gMTgxMjQzMzI1MztcbiAgICBNZXJzZW5uZVR3aXN0ZXIuVSA9IDExO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5TID0gNztcbiAgICBNZXJzZW5uZVR3aXN0ZXIuQiA9IDB4OWQyYzU2ODA7XG4gICAgTWVyc2VubmVUd2lzdGVyLlQgPSAxNTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuQyA9IDB4ZWZjNjAwMDA7XG4gICAgTWVyc2VubmVUd2lzdGVyLkwgPSAxODtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTUFTS19MT1dFUiA9IE1hdGgucG93KDIsIE1lcnNlbm5lVHdpc3Rlci5SKSAtIDE7XG4gICAgTWVyc2VubmVUd2lzdGVyLk1BU0tfVVBQRVIgPSBNYXRoLnBvdygyLCBNZXJzZW5uZVR3aXN0ZXIuUik7XG4gICAgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlcjtcbn0oKSk7XG5mdW5jdGlvbiBkZWZhdWx0XzEoc2VlZCkge1xuICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXIuZnJvbShzZWVkKTtcbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZGVmYXVsdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5za2lwTiA9IGV4cG9ydHMudW5zYWZlU2tpcE4gPSBleHBvcnRzLmdlbmVyYXRlTiA9IGV4cG9ydHMudW5zYWZlR2VuZXJhdGVOID0gdm9pZCAwO1xuZnVuY3Rpb24gdW5zYWZlR2VuZXJhdGVOKHJuZywgbnVtKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCAhPSBudW07ICsraWR4KSB7XG4gICAgICAgIG91dC5wdXNoKHJuZy51bnNhZmVOZXh0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy51bnNhZmVHZW5lcmF0ZU4gPSB1bnNhZmVHZW5lcmF0ZU47XG5mdW5jdGlvbiBnZW5lcmF0ZU4ocm5nLCBudW0pIHtcbiAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgIHZhciBvdXQgPSB1bnNhZmVHZW5lcmF0ZU4obmV4dFJuZywgbnVtKTtcbiAgICByZXR1cm4gW291dCwgbmV4dFJuZ107XG59XG5leHBvcnRzLmdlbmVyYXRlTiA9IGdlbmVyYXRlTjtcbmZ1bmN0aW9uIHVuc2FmZVNraXBOKHJuZywgbnVtKSB7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4ICE9IG51bTsgKytpZHgpIHtcbiAgICAgICAgcm5nLnVuc2FmZU5leHQoKTtcbiAgICB9XG59XG5leHBvcnRzLnVuc2FmZVNraXBOID0gdW5zYWZlU2tpcE47XG5mdW5jdGlvbiBza2lwTihybmcsIG51bSkge1xuICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgdW5zYWZlU2tpcE4obmV4dFJuZywgbnVtKTtcbiAgICByZXR1cm4gbmV4dFJuZztcbn1cbmV4cG9ydHMuc2tpcE4gPSBza2lwTjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0gdm9pZCAwO1xudmFyIFhvclNoaWZ0MTI4UGx1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG9yU2hpZnQxMjhQbHVzKHMwMSwgczAwLCBzMTEsIHMxMCkge1xuICAgICAgICB0aGlzLnMwMSA9IHMwMTtcbiAgICAgICAgdGhpcy5zMDAgPSBzMDA7XG4gICAgICAgIHRoaXMuczExID0gczExO1xuICAgICAgICB0aGlzLnMxMCA9IHMxMDtcbiAgICB9XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAtMHg4MDAwMDAwMDtcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMHg3ZmZmZmZmZjtcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWG9yU2hpZnQxMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgWG9yU2hpZnQxMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICAgICAgdmFyIG91dCA9IG5leHRSbmcudW5zYWZlTmV4dCgpO1xuICAgICAgICByZXR1cm4gW291dCwgbmV4dFJuZ107XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLnVuc2FmZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhMCA9IHRoaXMuczAwIF4gKHRoaXMuczAwIDw8IDIzKTtcbiAgICAgICAgdmFyIGExID0gdGhpcy5zMDEgXiAoKHRoaXMuczAxIDw8IDIzKSB8ICh0aGlzLnMwMCA+Pj4gOSkpO1xuICAgICAgICB2YXIgYjAgPSBhMCBeIHRoaXMuczEwIF4gKChhMCA+Pj4gMTgpIHwgKGExIDw8IDE0KSkgXiAoKHRoaXMuczEwID4+PiA1KSB8ICh0aGlzLnMxMSA8PCAyNykpO1xuICAgICAgICB2YXIgYjEgPSBhMSBeIHRoaXMuczExIF4gKGExID4+PiAxOCkgXiAodGhpcy5zMTEgPj4+IDUpO1xuICAgICAgICB2YXIgb3V0ID0gKHRoaXMuczAwICsgdGhpcy5zMTApIHwgMDtcbiAgICAgICAgdGhpcy5zMDEgPSB0aGlzLnMxMTtcbiAgICAgICAgdGhpcy5zMDAgPSB0aGlzLnMxMDtcbiAgICAgICAgdGhpcy5zMTEgPSBiMTtcbiAgICAgICAgdGhpcy5zMTAgPSBiMDtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUuanVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgWG9yU2hpZnQxMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICAgICAgbmV4dFJuZy51bnNhZmVKdW1wKCk7XG4gICAgICAgIHJldHVybiBuZXh0Um5nO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS51bnNhZmVKdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnMwMSA9IDA7XG4gICAgICAgIHZhciBuczAwID0gMDtcbiAgICAgICAgdmFyIG5zMTEgPSAwO1xuICAgICAgICB2YXIgbnMxMCA9IDA7XG4gICAgICAgIHZhciBqdW1wID0gWzB4NjM1ZDJkZmYsIDB4OGE1Y2Q3ODksIDB4NWM0NzJmOTYsIDB4MTIxZmQyMTVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gNDsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBtYXNrID0gMTsgbWFzazsgbWFzayA8PD0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChqdW1wW2ldICYgbWFzaykge1xuICAgICAgICAgICAgICAgICAgICBuczAxIF49IHRoaXMuczAxO1xuICAgICAgICAgICAgICAgICAgICBuczAwIF49IHRoaXMuczAwO1xuICAgICAgICAgICAgICAgICAgICBuczExIF49IHRoaXMuczExO1xuICAgICAgICAgICAgICAgICAgICBuczEwIF49IHRoaXMuczEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVuc2FmZU5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnMwMSA9IG5zMDE7XG4gICAgICAgIHRoaXMuczAwID0gbnMwMDtcbiAgICAgICAgdGhpcy5zMTEgPSBuczExO1xuICAgICAgICB0aGlzLnMxMCA9IG5zMTA7XG4gICAgfTtcbiAgICByZXR1cm4gWG9yU2hpZnQxMjhQbHVzO1xufSgpKTtcbnZhciB4b3JzaGlmdDEyOHBsdXMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgWG9yU2hpZnQxMjhQbHVzKC0xLCB+c2VlZCwgc2VlZCB8IDAsIDApO1xufTtcbmV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0geG9yc2hpZnQxMjhwbHVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy54b3Jvc2hpcm8xMjhwbHVzID0gdm9pZCAwO1xudmFyIFhvcm9TaGlybzEyOFBsdXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhvcm9TaGlybzEyOFBsdXMoczAxLCBzMDAsIHMxMSwgczEwKSB7XG4gICAgICAgIHRoaXMuczAxID0gczAxO1xuICAgICAgICB0aGlzLnMwMCA9IHMwMDtcbiAgICAgICAgdGhpcy5zMTEgPSBzMTE7XG4gICAgICAgIHRoaXMuczEwID0gczEwO1xuICAgIH1cbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAtMHg4MDAwMDAwMDtcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDB4N2ZmZmZmZmY7XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYb3JvU2hpcm8xMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gbmV3IFhvcm9TaGlybzEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLnVuc2FmZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSAodGhpcy5zMDAgKyB0aGlzLnMxMCkgfCAwO1xuICAgICAgICB2YXIgYTAgPSB0aGlzLnMxMCBeIHRoaXMuczAwO1xuICAgICAgICB2YXIgYTEgPSB0aGlzLnMxMSBeIHRoaXMuczAxO1xuICAgICAgICB2YXIgczAwID0gdGhpcy5zMDA7XG4gICAgICAgIHZhciBzMDEgPSB0aGlzLnMwMTtcbiAgICAgICAgdGhpcy5zMDAgPSAoczAwIDw8IDI0KSBeIChzMDEgPj4+IDgpIF4gYTAgXiAoYTAgPDwgMTYpO1xuICAgICAgICB0aGlzLnMwMSA9IChzMDEgPDwgMjQpIF4gKHMwMCA+Pj4gOCkgXiBhMSBeICgoYTEgPDwgMTYpIHwgKGEwID4+PiAxNikpO1xuICAgICAgICB0aGlzLnMxMCA9IChhMSA8PCA1KSBeIChhMCA+Pj4gMjcpO1xuICAgICAgICB0aGlzLnMxMSA9IChhMCA8PCA1KSBeIChhMSA+Pj4gMjcpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUuanVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgWG9yb1NoaXJvMTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgICAgIG5leHRSbmcudW5zYWZlSnVtcCgpO1xuICAgICAgICByZXR1cm4gbmV4dFJuZztcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLnVuc2FmZUp1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuczAxID0gMDtcbiAgICAgICAgdmFyIG5zMDAgPSAwO1xuICAgICAgICB2YXIgbnMxMSA9IDA7XG4gICAgICAgIHZhciBuczEwID0gMDtcbiAgICAgICAgdmFyIGp1bXAgPSBbMHhkOGY1NTRhNSwgMHhkZjkwMDI5NCwgMHg0YjMyMDFmYywgMHgxNzA4NjVkZl07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA0OyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG1hc2sgPSAxOyBtYXNrOyBtYXNrIDw8PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBbaV0gJiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zMDEgXj0gdGhpcy5zMDE7XG4gICAgICAgICAgICAgICAgICAgIG5zMDAgXj0gdGhpcy5zMDA7XG4gICAgICAgICAgICAgICAgICAgIG5zMTEgXj0gdGhpcy5zMTE7XG4gICAgICAgICAgICAgICAgICAgIG5zMTAgXj0gdGhpcy5zMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5zYWZlTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuczAxID0gbnMwMTtcbiAgICAgICAgdGhpcy5zMDAgPSBuczAwO1xuICAgICAgICB0aGlzLnMxMSA9IG5zMTE7XG4gICAgICAgIHRoaXMuczEwID0gbnMxMDtcbiAgICB9O1xuICAgIHJldHVybiBYb3JvU2hpcm8xMjhQbHVzO1xufSgpKTtcbnZhciB4b3Jvc2hpcm8xMjhwbHVzID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICByZXR1cm4gbmV3IFhvcm9TaGlybzEyOFBsdXMoLTEsIH5zZWVkLCBzZWVkIHwgMCwgMCk7XG59O1xuZXhwb3J0cy54b3Jvc2hpcm8xMjhwbHVzID0geG9yb3NoaXJvMTI4cGx1cztcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bmlmb3JtSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSBleHBvcnRzLnhvcnNoaWZ0MTI4cGx1cyA9IGV4cG9ydHMubWVyc2VubmUgPSBleHBvcnRzLmNvbmdydWVudGlhbDMyID0gZXhwb3J0cy5jb25ncnVlbnRpYWwgPSBleHBvcnRzLnVuc2FmZVNraXBOID0gZXhwb3J0cy51bnNhZmVHZW5lcmF0ZU4gPSBleHBvcnRzLnNraXBOID0gZXhwb3J0cy5nZW5lcmF0ZU4gPSBleHBvcnRzLl9fY29tbWl0SGFzaCA9IGV4cG9ydHMuX192ZXJzaW9uID0gZXhwb3J0cy5fX3R5cGUgPSB2b2lkIDA7XG52YXIgUmFuZG9tR2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3IvUmFuZG9tR2VuZXJhdG9yXCIpO1xuZXhwb3J0cy5nZW5lcmF0ZU4gPSBSYW5kb21HZW5lcmF0b3JfMS5nZW5lcmF0ZU47XG5leHBvcnRzLnNraXBOID0gUmFuZG9tR2VuZXJhdG9yXzEuc2tpcE47XG5leHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IFJhbmRvbUdlbmVyYXRvcl8xLnVuc2FmZUdlbmVyYXRlTjtcbmV4cG9ydHMudW5zYWZlU2tpcE4gPSBSYW5kb21HZW5lcmF0b3JfMS51bnNhZmVTa2lwTjtcbnZhciBMaW5lYXJDb25ncnVlbnRpYWxfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9MaW5lYXJDb25ncnVlbnRpYWxcIik7XG5leHBvcnRzLmNvbmdydWVudGlhbCA9IExpbmVhckNvbmdydWVudGlhbF8xLmNvbmdydWVudGlhbDtcbmV4cG9ydHMuY29uZ3J1ZW50aWFsMzIgPSBMaW5lYXJDb25ncnVlbnRpYWxfMS5jb25ncnVlbnRpYWwzMjtcbnZhciBNZXJzZW5uZVR3aXN0ZXJfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9NZXJzZW5uZVR3aXN0ZXJcIik7XG5leHBvcnRzLm1lcnNlbm5lID0gTWVyc2VubmVUd2lzdGVyXzFbXCJkZWZhdWx0XCJdO1xudmFyIFhvclNoaWZ0XzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3IvWG9yU2hpZnRcIik7XG5leHBvcnRzLnhvcnNoaWZ0MTI4cGx1cyA9IFhvclNoaWZ0XzEueG9yc2hpZnQxMjhwbHVzO1xudmFyIFhvcm9TaGlyb18xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL1hvcm9TaGlyb1wiKTtcbmV4cG9ydHMueG9yb3NoaXJvMTI4cGx1cyA9IFhvcm9TaGlyb18xLnhvcm9zaGlybzEyOHBsdXM7XG52YXIgVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG52YXIgVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1VuaWZvcm1CaWdJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbnZhciBVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5pZm9ybUludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IFVuaWZvcm1JbnREaXN0cmlidXRpb25fMS51bmlmb3JtSW50RGlzdHJpYnV0aW9uO1xudmFyIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uO1xudmFyIFVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb247XG52YXIgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24gPSBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbjtcbnZhciBfX3R5cGUgPSAnY29tbW9uanMnO1xuZXhwb3J0cy5fX3R5cGUgPSBfX3R5cGU7XG52YXIgX192ZXJzaW9uID0gJzUuMC41JztcbmV4cG9ydHMuX192ZXJzaW9uID0gX192ZXJzaW9uO1xudmFyIF9fY29tbWl0SGFzaCA9ICc4YjgxMmQ5NjUxYjRhMThlOTExNWFhMTNkODRmZTFiNWViOWIwNjhkJztcbmV4cG9ydHMuX19jb21taXRIYXNoID0gX19jb21taXRIYXNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcHJhbmQgPSByZXF1aXJlKFwiLi9wdXJlLXJhbmQtZGVmYXVsdFwiKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcHJhbmQ7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHVyZS1yYW5kLWRlZmF1bHRcIiksIGV4cG9ydHMpO1xuIiwidmFyIG1vZGUgPSByZXF1aXJlKCcuL21vZGUnKTtcblxuZnVuY3Rpb24gUVI4Yml0Qnl0ZShkYXRhKSB7XG5cdHRoaXMubW9kZSA9IG1vZGUuTU9ERV84QklUX0JZVEU7XG5cdHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cblFSOGJpdEJ5dGUucHJvdG90eXBlID0ge1xuXG5cdGdldExlbmd0aCA6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXHRcdHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xuXHR9LFxuXHRcblx0d3JpdGUgOiBmdW5jdGlvbihidWZmZXIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Ly8gbm90IEpJUyAuLi5cblx0XHRcdGJ1ZmZlci5wdXQodGhpcy5kYXRhLmNoYXJDb2RlQXQoaSksIDgpO1xuXHRcdH1cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRUjhiaXRCeXRlO1xuXG4iLCJmdW5jdGlvbiBRUkJpdEJ1ZmZlcigpIHtcblx0dGhpcy5idWZmZXIgPSBuZXcgQXJyYXkoKTtcblx0dGhpcy5sZW5ndGggPSAwO1xufVxuXG5RUkJpdEJ1ZmZlci5wcm90b3R5cGUgPSB7XG5cblx0Z2V0IDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gOCk7XG5cdFx0cmV0dXJuICggKHRoaXMuYnVmZmVyW2J1ZkluZGV4XSA+Pj4gKDcgLSBpbmRleCAlIDgpICkgJiAxKSA9PSAxO1xuXHR9LFxuXHRcblx0cHV0IDogZnVuY3Rpb24obnVtLCBsZW5ndGgpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnB1dEJpdCggKCAobnVtID4+PiAobGVuZ3RoIC0gaSAtIDEpICkgJiAxKSA9PSAxKTtcblx0XHR9XG5cdH0sXG5cdFxuXHRnZXRMZW5ndGhJbkJpdHMgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH0sXG5cdFxuXHRwdXRCaXQgOiBmdW5jdGlvbihiaXQpIHtcblx0XG5cdFx0dmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmxlbmd0aCAvIDgpO1xuXHRcdGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPD0gYnVmSW5kZXgpIHtcblx0XHRcdHRoaXMuYnVmZmVyLnB1c2goMCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoYml0KSB7XG5cdFx0XHR0aGlzLmJ1ZmZlcltidWZJbmRleF0gfD0gKDB4ODAgPj4+ICh0aGlzLmxlbmd0aCAlIDgpICk7XG5cdFx0fVxuXHRcblx0XHR0aGlzLmxlbmd0aCsrO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFFSQml0QnVmZmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdEwgOiAxLFxuXHRNIDogMCxcblx0USA6IDMsXG5cdEggOiAyXG59O1xuXG4iLCJ2YXIgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuXG5mdW5jdGlvbiBRUlBvbHlub21pYWwobnVtLCBzaGlmdCkge1xuXG5cdGlmIChudW0ubGVuZ3RoID09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihudW0ubGVuZ3RoICsgXCIvXCIgKyBzaGlmdCk7XG5cdH1cblxuXHR2YXIgb2Zmc2V0ID0gMDtcblxuXHR3aGlsZSAob2Zmc2V0IDwgbnVtLmxlbmd0aCAmJiBudW1bb2Zmc2V0XSA9PSAwKSB7XG5cdFx0b2Zmc2V0Kys7XG5cdH1cblxuXHR0aGlzLm51bSA9IG5ldyBBcnJheShudW0ubGVuZ3RoIC0gb2Zmc2V0ICsgc2hpZnQpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGggLSBvZmZzZXQ7IGkrKykge1xuXHRcdHRoaXMubnVtW2ldID0gbnVtW2kgKyBvZmZzZXRdO1xuXHR9XG59XG5cblFSUG9seW5vbWlhbC5wcm90b3R5cGUgPSB7XG5cblx0Z2V0IDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1baW5kZXhdO1xuXHR9LFxuXHRcblx0Z2V0TGVuZ3RoIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtLmxlbmd0aDtcblx0fSxcblx0XG5cdG11bHRpcGx5IDogZnVuY3Rpb24oZSkge1xuXHRcblx0XHR2YXIgbnVtID0gbmV3IEFycmF5KHRoaXMuZ2V0TGVuZ3RoKCkgKyBlLmdldExlbmd0aCgpIC0gMSk7XG5cdFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXRMZW5ndGgoKTsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGUuZ2V0TGVuZ3RoKCk7IGorKykge1xuXHRcdFx0XHRudW1baSArIGpdIF49IG1hdGguZ2V4cChtYXRoLmdsb2codGhpcy5nZXQoaSkgKSArIG1hdGguZ2xvZyhlLmdldChqKSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbmV3IFFSUG9seW5vbWlhbChudW0sIDApO1xuXHR9LFxuXHRcblx0bW9kIDogZnVuY3Rpb24oZSkge1xuXHRcblx0XHRpZiAodGhpcy5nZXRMZW5ndGgoKSAtIGUuZ2V0TGVuZ3RoKCkgPCAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFxuXHRcdHZhciByYXRpbyA9IG1hdGguZ2xvZyh0aGlzLmdldCgwKSApIC0gbWF0aC5nbG9nKGUuZ2V0KDApICk7XG5cdFxuXHRcdHZhciBudW0gPSBuZXcgQXJyYXkodGhpcy5nZXRMZW5ndGgoKSApO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXRMZW5ndGgoKTsgaSsrKSB7XG5cdFx0XHRudW1baV0gPSB0aGlzLmdldChpKTtcblx0XHR9XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlLmdldExlbmd0aCgpOyBpKyspIHtcblx0XHRcdG51bVtpXSBePSBtYXRoLmdleHAobWF0aC5nbG9nKGUuZ2V0KGkpICkgKyByYXRpbyk7XG5cdFx0fVxuXHRcblx0XHQvLyByZWN1cnNpdmUgY2FsbFxuXHRcdHJldHVybiBuZXcgUVJQb2x5bm9taWFsKG51bSwgMCkubW9kKGUpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFFSUG9seW5vbWlhbDtcbiIsInZhciBCaXRCeXRlID0gcmVxdWlyZSgnLi84Qml0Qnl0ZScpO1xudmFyIFJTQmxvY2sgPSByZXF1aXJlKCcuL1JTQmxvY2snKTtcbnZhciBCaXRCdWZmZXIgPSByZXF1aXJlKCcuL0JpdEJ1ZmZlcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBQb2x5bm9taWFsID0gcmVxdWlyZSgnLi9Qb2x5bm9taWFsJyk7XG5cbmZ1bmN0aW9uIFFSQ29kZSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCkge1xuXHR0aGlzLnR5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuXHR0aGlzLmVycm9yQ29ycmVjdExldmVsID0gZXJyb3JDb3JyZWN0TGV2ZWw7XG5cdHRoaXMubW9kdWxlcyA9IG51bGw7XG5cdHRoaXMubW9kdWxlQ291bnQgPSAwO1xuXHR0aGlzLmRhdGFDYWNoZSA9IG51bGw7XG5cdHRoaXMuZGF0YUxpc3QgPSBbXTtcbn1cblxuLy8gZm9yIGNsaWVudCBzaWRlIG1pbmlmaWNhdGlvblxudmFyIHByb3RvID0gUVJDb2RlLnByb3RvdHlwZTtcblxucHJvdG8uYWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0dmFyIG5ld0RhdGEgPSBuZXcgQml0Qnl0ZShkYXRhKTtcblx0dGhpcy5kYXRhTGlzdC5wdXNoKG5ld0RhdGEpO1xuXHR0aGlzLmRhdGFDYWNoZSA9IG51bGw7XG59O1xuXG5wcm90by5pc0RhcmsgPSBmdW5jdGlvbihyb3csIGNvbCkge1xuXHRpZiAocm93IDwgMCB8fCB0aGlzLm1vZHVsZUNvdW50IDw9IHJvdyB8fCBjb2wgPCAwIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gY29sKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKHJvdyArIFwiLFwiICsgY29sKTtcblx0fVxuXHRyZXR1cm4gdGhpcy5tb2R1bGVzW3Jvd11bY29sXTtcbn07XG5cbnByb3RvLmdldE1vZHVsZUNvdW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLm1vZHVsZUNvdW50O1xufTtcblxucHJvdG8ubWFrZSA9IGZ1bmN0aW9uKCkge1xuXHQvLyBDYWxjdWxhdGUgYXV0b21hdGljYWxseSB0eXBlTnVtYmVyIGlmIHByb3ZpZGVkIGlzIDwgMVxuXHRpZiAodGhpcy50eXBlTnVtYmVyIDwgMSApe1xuXHRcdHZhciB0eXBlTnVtYmVyID0gMTtcblx0XHRmb3IgKHR5cGVOdW1iZXIgPSAxOyB0eXBlTnVtYmVyIDwgNDA7IHR5cGVOdW1iZXIrKykge1xuXHRcdFx0dmFyIHJzQmxvY2tzID0gUlNCbG9jay5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyLCB0aGlzLmVycm9yQ29ycmVjdExldmVsKTtcblxuXHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBCaXRCdWZmZXIoKTtcblx0XHRcdHZhciB0b3RhbERhdGFDb3VudCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2ldLmRhdGFDb3VudDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gdGhpcy5kYXRhTGlzdFtpXTtcblx0XHRcdFx0YnVmZmVyLnB1dChkYXRhLm1vZGUsIDQpO1xuXHRcdFx0XHRidWZmZXIucHV0KGRhdGEuZ2V0TGVuZ3RoKCksIHV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEubW9kZSwgdHlwZU51bWJlcikgKTtcblx0XHRcdFx0ZGF0YS53cml0ZShidWZmZXIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA8PSB0b3RhbERhdGFDb3VudCAqIDgpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLnR5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuXHR9XG5cdHRoaXMubWFrZUltcGwoZmFsc2UsIHRoaXMuZ2V0QmVzdE1hc2tQYXR0ZXJuKCkgKTtcbn07XG5cbnByb3RvLm1ha2VJbXBsID0gZnVuY3Rpb24odGVzdCwgbWFza1BhdHRlcm4pIHtcblx0XG5cdHRoaXMubW9kdWxlQ291bnQgPSB0aGlzLnR5cGVOdW1iZXIgKiA0ICsgMTc7XG5cdHRoaXMubW9kdWxlcyA9IG5ldyBBcnJheSh0aGlzLm1vZHVsZUNvdW50KTtcblx0XG5cdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMubW9kdWxlQ291bnQ7IHJvdysrKSB7XG5cdFx0XG5cdFx0dGhpcy5tb2R1bGVzW3Jvd10gPSBuZXcgQXJyYXkodGhpcy5tb2R1bGVDb3VudCk7XG5cdFx0XG5cdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5tb2R1bGVDb3VudDsgY29sKyspIHtcblx0XHRcdHRoaXMubW9kdWxlc1tyb3ddW2NvbF0gPSBudWxsOy8vKGNvbCArIHJvdykgJSAzO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMuc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybigwLCAwKTtcblx0dGhpcy5zZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKHRoaXMubW9kdWxlQ291bnQgLSA3LCAwKTtcblx0dGhpcy5zZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIHRoaXMubW9kdWxlQ291bnQgLSA3KTtcblx0dGhpcy5zZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpO1xuXHR0aGlzLnNldHVwVGltaW5nUGF0dGVybigpO1xuXHR0aGlzLnNldHVwVHlwZUluZm8odGVzdCwgbWFza1BhdHRlcm4pO1xuXHRcblx0aWYgKHRoaXMudHlwZU51bWJlciA+PSA3KSB7XG5cdFx0dGhpcy5zZXR1cFR5cGVOdW1iZXIodGVzdCk7XG5cdH1cblxuXHRpZiAodGhpcy5kYXRhQ2FjaGUgPT0gbnVsbCkge1xuXHRcdHRoaXMuZGF0YUNhY2hlID0gUVJDb2RlLmNyZWF0ZURhdGEodGhpcy50eXBlTnVtYmVyLCB0aGlzLmVycm9yQ29ycmVjdExldmVsLCB0aGlzLmRhdGFMaXN0KTtcblx0fVxuXG5cdHRoaXMubWFwRGF0YSh0aGlzLmRhdGFDYWNoZSwgbWFza1BhdHRlcm4pO1xufTtcblxucHJvdG8uc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybiA9IGZ1bmN0aW9uKHJvdywgY29sKSAge1xuXHRcblx0Zm9yICh2YXIgciA9IC0xOyByIDw9IDc7IHIrKykge1xuXHRcdFxuXHRcdGlmIChyb3cgKyByIDw9IC0xIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gcm93ICsgcikgY29udGludWU7XG5cdFx0XG5cdFx0Zm9yICh2YXIgYyA9IC0xOyBjIDw9IDc7IGMrKykge1xuXHRcdFx0XG5cdFx0XHRpZiAoY29sICsgYyA8PSAtMSB8fCB0aGlzLm1vZHVsZUNvdW50IDw9IGNvbCArIGMpIGNvbnRpbnVlO1xuXHRcdFx0XG5cdFx0XHRpZiAoICgwIDw9IHIgJiYgciA8PSA2ICYmIChjID09IDAgfHwgYyA9PSA2KSApXG5cdFx0XHRcdFx0fHwgKDAgPD0gYyAmJiBjIDw9IDYgJiYgKHIgPT0gMCB8fCByID09IDYpIClcblx0XHRcdFx0XHR8fCAoMiA8PSByICYmIHIgPD0gNCAmJiAyIDw9IGMgJiYgYyA8PSA0KSApIHtcblx0XHRcdFx0dGhpcy5tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cdFx0XG5cdH1cdFx0XG59O1xuXG5wcm90by5nZXRCZXN0TWFza1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgbWluTG9zdFBvaW50ID0gMDtcblx0dmFyIHBhdHRlcm4gPSAwO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XG5cdFx0dGhpcy5tYWtlSW1wbCh0cnVlLCBpKTtcblxuXHRcdHZhciBsb3N0UG9pbnQgPSB1dGlsLmdldExvc3RQb2ludCh0aGlzKTtcblxuXHRcdGlmIChpID09IDAgfHwgbWluTG9zdFBvaW50ID4gIGxvc3RQb2ludCkge1xuXHRcdFx0bWluTG9zdFBvaW50ID0gbG9zdFBvaW50O1xuXHRcdFx0cGF0dGVybiA9IGk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHBhdHRlcm47XG59O1xuXG5wcm90by5jcmVhdGVNb3ZpZUNsaXAgPSBmdW5jdGlvbih0YXJnZXRfbWMsIGluc3RhbmNlX25hbWUsIGRlcHRoKSB7XG5cblx0dmFyIHFyX21jID0gdGFyZ2V0X21jLmNyZWF0ZUVtcHR5TW92aWVDbGlwKGluc3RhbmNlX25hbWUsIGRlcHRoKTtcblx0dmFyIGNzID0gMTtcblxuXHR0aGlzLm1ha2UoKTtcblxuXHRmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLm1vZHVsZXMubGVuZ3RoOyByb3crKykge1xuXHRcdFxuXHRcdHZhciB5ID0gcm93ICogY3M7XG5cdFx0XG5cdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5tb2R1bGVzW3Jvd10ubGVuZ3RoOyBjb2wrKykge1xuXG5cdFx0XHR2YXIgeCA9IGNvbCAqIGNzO1xuXHRcdFx0dmFyIGRhcmsgPSB0aGlzLm1vZHVsZXNbcm93XVtjb2xdO1xuXHRcdFxuXHRcdFx0aWYgKGRhcmspIHtcblx0XHRcdFx0cXJfbWMuYmVnaW5GaWxsKDAsIDEwMCk7XG5cdFx0XHRcdHFyX21jLm1vdmVUbyh4LCB5KTtcblx0XHRcdFx0cXJfbWMubGluZVRvKHggKyBjcywgeSk7XG5cdFx0XHRcdHFyX21jLmxpbmVUbyh4ICsgY3MsIHkgKyBjcyk7XG5cdFx0XHRcdHFyX21jLmxpbmVUbyh4LCB5ICsgY3MpO1xuXHRcdFx0XHRxcl9tYy5lbmRGaWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gcXJfbWM7XG59O1xuXG5wcm90by5zZXR1cFRpbWluZ1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcblx0XG5cdGZvciAodmFyIHIgPSA4OyByIDwgdGhpcy5tb2R1bGVDb3VudCAtIDg7IHIrKykge1xuXHRcdGlmICh0aGlzLm1vZHVsZXNbcl1bNl0gIT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdHRoaXMubW9kdWxlc1tyXVs2XSA9IChyICUgMiA9PSAwKTtcblx0fVxuXG5cdGZvciAodmFyIGMgPSA4OyBjIDwgdGhpcy5tb2R1bGVDb3VudCAtIDg7IGMrKykge1xuXHRcdGlmICh0aGlzLm1vZHVsZXNbNl1bY10gIT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdHRoaXMubW9kdWxlc1s2XVtjXSA9IChjICUgMiA9PSAwKTtcblx0fVxufTtcblxucHJvdG8uc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4gPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgcG9zID0gdXRpbC5nZXRQYXR0ZXJuUG9zaXRpb24odGhpcy50eXBlTnVtYmVyKTtcblx0XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSsrKSB7XG5cdFxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgcG9zLmxlbmd0aDsgaisrKSB7XG5cdFx0XG5cdFx0XHR2YXIgcm93ID0gcG9zW2ldO1xuXHRcdFx0dmFyIGNvbCA9IHBvc1tqXTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubW9kdWxlc1tyb3ddW2NvbF0gIT0gbnVsbCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgciA9IC0yOyByIDw9IDI7IHIrKykge1xuXHRcdFx0XG5cdFx0XHRcdGZvciAodmFyIGMgPSAtMjsgYyA8PSAyOyBjKyspIHtcblx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHIgPT0gLTIgfHwgciA9PSAyIHx8IGMgPT0gLTIgfHwgYyA9PSAyXG5cdFx0XHRcdFx0XHRcdHx8IChyID09IDAgJiYgYyA9PSAwKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMubW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxucHJvdG8uc2V0dXBUeXBlTnVtYmVyID0gZnVuY3Rpb24odGVzdCkge1xuXG5cdHZhciBiaXRzID0gdXRpbC5nZXRCQ0hUeXBlTnVtYmVyKHRoaXMudHlwZU51bWJlcik7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG5cdFx0dmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG5cdFx0dGhpcy5tb2R1bGVzW01hdGguZmxvb3IoaSAvIDMpXVtpICUgMyArIHRoaXMubW9kdWxlQ291bnQgLSA4IC0gM10gPSBtb2Q7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDE4OyBpKyspIHtcblx0XHR2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblx0XHR0aGlzLm1vZHVsZXNbaSAlIDMgKyB0aGlzLm1vZHVsZUNvdW50IC0gOCAtIDNdW01hdGguZmxvb3IoaSAvIDMpXSA9IG1vZDtcblx0fVxufTtcblxucHJvdG8uc2V0dXBUeXBlSW5mbyA9IGZ1bmN0aW9uKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG5cblx0dmFyIGRhdGEgPSAodGhpcy5lcnJvckNvcnJlY3RMZXZlbCA8PCAzKSB8IG1hc2tQYXR0ZXJuO1xuXHR2YXIgYml0cyA9IHV0aWwuZ2V0QkNIVHlwZUluZm8oZGF0YSk7XG5cblx0Ly8gdmVydGljYWxcdFx0XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuXG5cdFx0dmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG5cblx0XHRpZiAoaSA8IDYpIHtcblx0XHRcdHRoaXMubW9kdWxlc1tpXVs4XSA9IG1vZDtcblx0XHR9IGVsc2UgaWYgKGkgPCA4KSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbaSArIDFdWzhdID0gbW9kO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbdGhpcy5tb2R1bGVDb3VudCAtIDE1ICsgaV1bOF0gPSBtb2Q7XG5cdFx0fVxuXHR9XG5cblx0Ly8gaG9yaXpvbnRhbFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyspIHtcblxuXHRcdHZhciBtb2QgPSAoIXRlc3QgJiYgKCAoYml0cyA+PiBpKSAmIDEpID09IDEpO1xuXHRcdFxuXHRcdGlmIChpIDwgOCkge1xuXHRcdFx0dGhpcy5tb2R1bGVzWzhdW3RoaXMubW9kdWxlQ291bnQgLSBpIC0gMV0gPSBtb2Q7XG5cdFx0fSBlbHNlIGlmIChpIDwgOSkge1xuXHRcdFx0dGhpcy5tb2R1bGVzWzhdWzE1IC0gaSAtIDEgKyAxXSA9IG1vZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tb2R1bGVzWzhdWzE1IC0gaSAtIDFdID0gbW9kO1xuXHRcdH1cblx0fVxuXG5cdC8vIGZpeGVkIG1vZHVsZVxuXHR0aGlzLm1vZHVsZXNbdGhpcy5tb2R1bGVDb3VudCAtIDhdWzhdID0gKCF0ZXN0KTtcbn07XG5cbnByb3RvLm1hcERhdGEgPSBmdW5jdGlvbihkYXRhLCBtYXNrUGF0dGVybikge1xuXHRcblx0dmFyIGluYyA9IC0xO1xuXHR2YXIgcm93ID0gdGhpcy5tb2R1bGVDb3VudCAtIDE7XG5cdHZhciBiaXRJbmRleCA9IDc7XG5cdHZhciBieXRlSW5kZXggPSAwO1xuXHRcblx0Zm9yICh2YXIgY29sID0gdGhpcy5tb2R1bGVDb3VudCAtIDE7IGNvbCA+IDA7IGNvbCAtPSAyKSB7XG5cblx0XHRpZiAoY29sID09IDYpIGNvbC0tO1xuXG5cdFx0d2hpbGUgKHRydWUpIHtcblxuXHRcdFx0Zm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjKyspIHtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLm1vZHVsZXNbcm93XVtjb2wgLSBjXSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGRhcmsgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0ZGFyayA9ICggKCAoZGF0YVtieXRlSW5kZXhdID4+PiBiaXRJbmRleCkgJiAxKSA9PSAxKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgbWFzayA9IHV0aWwuZ2V0TWFzayhtYXNrUGF0dGVybiwgcm93LCBjb2wgLSBjKTtcblxuXHRcdFx0XHRcdGlmIChtYXNrKSB7XG5cdFx0XHRcdFx0XHRkYXJrID0gIWRhcms7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMubW9kdWxlc1tyb3ddW2NvbCAtIGNdID0gZGFyaztcblx0XHRcdFx0XHRiaXRJbmRleC0tO1xuXG5cdFx0XHRcdFx0aWYgKGJpdEluZGV4ID09IC0xKSB7XG5cdFx0XHRcdFx0XHRieXRlSW5kZXgrKztcblx0XHRcdFx0XHRcdGJpdEluZGV4ID0gNztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRyb3cgKz0gaW5jO1xuXG5cdFx0XHRpZiAocm93IDwgMCB8fCB0aGlzLm1vZHVsZUNvdW50IDw9IHJvdykge1xuXHRcdFx0XHRyb3cgLT0gaW5jO1xuXHRcdFx0XHRpbmMgPSAtaW5jO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cblFSQ29kZS5QQUQwID0gMHhFQztcblFSQ29kZS5QQUQxID0gMHgxMTtcblxuUVJDb2RlLmNyZWF0ZURhdGEgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCwgZGF0YUxpc3QpIHtcblx0XG5cdHZhciByc0Jsb2NrcyA9IFJTQmxvY2suZ2V0UlNCbG9ja3ModHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpO1xuXHRcblx0dmFyIGJ1ZmZlciA9IG5ldyBCaXRCdWZmZXIoKTtcblx0XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZGF0YSA9IGRhdGFMaXN0W2ldO1xuXHRcdGJ1ZmZlci5wdXQoZGF0YS5tb2RlLCA0KTtcblx0XHRidWZmZXIucHV0KGRhdGEuZ2V0TGVuZ3RoKCksIHV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEubW9kZSwgdHlwZU51bWJlcikgKTtcblx0XHRkYXRhLndyaXRlKGJ1ZmZlcik7XG5cdH1cblxuXHQvLyBjYWxjIG51bSBtYXggZGF0YS5cblx0dmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByc0Jsb2Nrcy5sZW5ndGg7IGkrKykge1xuXHRcdHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2ldLmRhdGFDb3VudDtcblx0fVxuXG5cdGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPiB0b3RhbERhdGFDb3VudCAqIDgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjb2RlIGxlbmd0aCBvdmVyZmxvdy4gKFwiXG5cdFx0XHQrIGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKVxuXHRcdFx0KyBcIj5cIlxuXHRcdFx0KyAgdG90YWxEYXRhQ291bnQgKiA4XG5cdFx0XHQrIFwiKVwiKTtcblx0fVxuXG5cdC8vIGVuZCBjb2RlXG5cdGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuXHRcdGJ1ZmZlci5wdXQoMCwgNCk7XG5cdH1cblxuXHQvLyBwYWRkaW5nXG5cdHdoaWxlIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgJSA4ICE9IDApIHtcblx0XHRidWZmZXIucHV0Qml0KGZhbHNlKTtcblx0fVxuXG5cdC8vIHBhZGRpbmdcblx0d2hpbGUgKHRydWUpIHtcblx0XHRcblx0XHRpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGJ1ZmZlci5wdXQoUVJDb2RlLlBBRDAsIDgpO1xuXHRcdFxuXHRcdGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0YnVmZmVyLnB1dChRUkNvZGUuUEFEMSwgOCk7XG5cdH1cblxuXHRyZXR1cm4gUVJDb2RlLmNyZWF0ZUJ5dGVzKGJ1ZmZlciwgcnNCbG9ja3MpO1xufTtcblxuUVJDb2RlLmNyZWF0ZUJ5dGVzID0gZnVuY3Rpb24oYnVmZmVyLCByc0Jsb2Nrcykge1xuXG5cdHZhciBvZmZzZXQgPSAwO1xuXHRcblx0dmFyIG1heERjQ291bnQgPSAwO1xuXHR2YXIgbWF4RWNDb3VudCA9IDA7XG5cdFxuXHR2YXIgZGNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG5cdHZhciBlY2RhdGEgPSBuZXcgQXJyYXkocnNCbG9ja3MubGVuZ3RoKTtcblx0XG5cdGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByKyspIHtcblxuXHRcdHZhciBkY0NvdW50ID0gcnNCbG9ja3Nbcl0uZGF0YUNvdW50O1xuXHRcdHZhciBlY0NvdW50ID0gcnNCbG9ja3Nbcl0udG90YWxDb3VudCAtIGRjQ291bnQ7XG5cblx0XHRtYXhEY0NvdW50ID0gTWF0aC5tYXgobWF4RGNDb3VudCwgZGNDb3VudCk7XG5cdFx0bWF4RWNDb3VudCA9IE1hdGgubWF4KG1heEVjQ291bnQsIGVjQ291bnQpO1xuXHRcdFxuXHRcdGRjZGF0YVtyXSA9IG5ldyBBcnJheShkY0NvdW50KTtcblx0XHRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRjZGF0YVtyXS5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZGNkYXRhW3JdW2ldID0gMHhmZiAmIGJ1ZmZlci5idWZmZXJbaSArIG9mZnNldF07XG5cdFx0fVxuXHRcdG9mZnNldCArPSBkY0NvdW50O1xuXHRcdFxuXHRcdHZhciByc1BvbHkgPSB1dGlsLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwoZWNDb3VudCk7XG5cdFx0dmFyIHJhd1BvbHkgPSBuZXcgUG9seW5vbWlhbChkY2RhdGFbcl0sIHJzUG9seS5nZXRMZW5ndGgoKSAtIDEpO1xuXG5cdFx0dmFyIG1vZFBvbHkgPSByYXdQb2x5Lm1vZChyc1BvbHkpO1xuXHRcdGVjZGF0YVtyXSA9IG5ldyBBcnJheShyc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVjZGF0YVtyXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1vZEluZGV4ID0gaSArIG1vZFBvbHkuZ2V0TGVuZ3RoKCkgLSBlY2RhdGFbcl0ubGVuZ3RoO1xuXHRcdFx0ZWNkYXRhW3JdW2ldID0gKG1vZEluZGV4ID49IDApPyBtb2RQb2x5LmdldChtb2RJbmRleCkgOiAwO1xuXHRcdH1cblxuXHR9XG5cdFxuXHR2YXIgdG90YWxDb2RlQ291bnQgPSAwO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dG90YWxDb2RlQ291bnQgKz0gcnNCbG9ja3NbaV0udG90YWxDb3VudDtcblx0fVxuXG5cdHZhciBkYXRhID0gbmV3IEFycmF5KHRvdGFsQ29kZUNvdW50KTtcblx0dmFyIGluZGV4ID0gMDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG1heERjQ291bnQ7IGkrKykge1xuXHRcdGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByKyspIHtcblx0XHRcdGlmIChpIDwgZGNkYXRhW3JdLmxlbmd0aCkge1xuXHRcdFx0XHRkYXRhW2luZGV4KytdID0gZGNkYXRhW3JdW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RWNDb3VudDsgaSsrKSB7XG5cdFx0Zm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIrKykge1xuXHRcdFx0aWYgKGkgPCBlY2RhdGFbcl0ubGVuZ3RoKSB7XG5cdFx0XHRcdGRhdGFbaW5kZXgrK10gPSBlY2RhdGFbcl1baV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFFSQ29kZTtcblxuIiwiLy8gRXJyb3JDb3JyZWN0TGV2ZWxcbnZhciBFQ0wgPSByZXF1aXJlKCcuL0Vycm9yQ29ycmVjdExldmVsJyk7XG5cbmZ1bmN0aW9uIFFSUlNCbG9jayh0b3RhbENvdW50LCBkYXRhQ291bnQpIHtcblx0dGhpcy50b3RhbENvdW50ID0gdG90YWxDb3VudDtcblx0dGhpcy5kYXRhQ291bnQgID0gZGF0YUNvdW50O1xufVxuXG5RUlJTQmxvY2suUlNfQkxPQ0tfVEFCTEUgPSBbXG5cblx0Ly8gTFxuXHQvLyBNXG5cdC8vIFFcblx0Ly8gSFxuXG5cdC8vIDFcblx0WzEsIDI2LCAxOV0sXG5cdFsxLCAyNiwgMTZdLFxuXHRbMSwgMjYsIDEzXSxcblx0WzEsIDI2LCA5XSxcblx0XG5cdC8vIDJcblx0WzEsIDQ0LCAzNF0sXG5cdFsxLCA0NCwgMjhdLFxuXHRbMSwgNDQsIDIyXSxcblx0WzEsIDQ0LCAxNl0sXG5cblx0Ly8gM1xuXHRbMSwgNzAsIDU1XSxcblx0WzEsIDcwLCA0NF0sXG5cdFsyLCAzNSwgMTddLFxuXHRbMiwgMzUsIDEzXSxcblxuXHQvLyA0XHRcdFxuXHRbMSwgMTAwLCA4MF0sXG5cdFsyLCA1MCwgMzJdLFxuXHRbMiwgNTAsIDI0XSxcblx0WzQsIDI1LCA5XSxcblx0XG5cdC8vIDVcblx0WzEsIDEzNCwgMTA4XSxcblx0WzIsIDY3LCA0M10sXG5cdFsyLCAzMywgMTUsIDIsIDM0LCAxNl0sXG5cdFsyLCAzMywgMTEsIDIsIDM0LCAxMl0sXG5cdFxuXHQvLyA2XG5cdFsyLCA4NiwgNjhdLFxuXHRbNCwgNDMsIDI3XSxcblx0WzQsIDQzLCAxOV0sXG5cdFs0LCA0MywgMTVdLFxuXHRcblx0Ly8gN1x0XHRcblx0WzIsIDk4LCA3OF0sXG5cdFs0LCA0OSwgMzFdLFxuXHRbMiwgMzIsIDE0LCA0LCAzMywgMTVdLFxuXHRbNCwgMzksIDEzLCAxLCA0MCwgMTRdLFxuXHRcblx0Ly8gOFxuXHRbMiwgMTIxLCA5N10sXG5cdFsyLCA2MCwgMzgsIDIsIDYxLCAzOV0sXG5cdFs0LCA0MCwgMTgsIDIsIDQxLCAxOV0sXG5cdFs0LCA0MCwgMTQsIDIsIDQxLCAxNV0sXG5cdFxuXHQvLyA5XG5cdFsyLCAxNDYsIDExNl0sXG5cdFszLCA1OCwgMzYsIDIsIDU5LCAzN10sXG5cdFs0LCAzNiwgMTYsIDQsIDM3LCAxN10sXG5cdFs0LCAzNiwgMTIsIDQsIDM3LCAxM10sXG5cdFxuXHQvLyAxMFx0XHRcblx0WzIsIDg2LCA2OCwgMiwgODcsIDY5XSxcblx0WzQsIDY5LCA0MywgMSwgNzAsIDQ0XSxcblx0WzYsIDQzLCAxOSwgMiwgNDQsIDIwXSxcblx0WzYsIDQzLCAxNSwgMiwgNDQsIDE2XSxcblxuXHQvLyAxMVxuXHRbNCwgMTAxLCA4MV0sXG5cdFsxLCA4MCwgNTAsIDQsIDgxLCA1MV0sXG5cdFs0LCA1MCwgMjIsIDQsIDUxLCAyM10sXG5cdFszLCAzNiwgMTIsIDgsIDM3LCAxM10sXG5cblx0Ly8gMTJcblx0WzIsIDExNiwgOTIsIDIsIDExNywgOTNdLFxuXHRbNiwgNTgsIDM2LCAyLCA1OSwgMzddLFxuXHRbNCwgNDYsIDIwLCA2LCA0NywgMjFdLFxuXHRbNywgNDIsIDE0LCA0LCA0MywgMTVdLFxuXG5cdC8vIDEzXG5cdFs0LCAxMzMsIDEwN10sXG5cdFs4LCA1OSwgMzcsIDEsIDYwLCAzOF0sXG5cdFs4LCA0NCwgMjAsIDQsIDQ1LCAyMV0sXG5cdFsxMiwgMzMsIDExLCA0LCAzNCwgMTJdLFxuXG5cdC8vIDE0XG5cdFszLCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLFxuXHRbNCwgNjQsIDQwLCA1LCA2NSwgNDFdLFxuXHRbMTEsIDM2LCAxNiwgNSwgMzcsIDE3XSxcblx0WzExLCAzNiwgMTIsIDUsIDM3LCAxM10sXG5cblx0Ly8gMTVcblx0WzUsIDEwOSwgODcsIDEsIDExMCwgODhdLFxuXHRbNSwgNjUsIDQxLCA1LCA2NiwgNDJdLFxuXHRbNSwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuXHRbMTEsIDM2LCAxMl0sXG5cblx0Ly8gMTZcblx0WzUsIDEyMiwgOTgsIDEsIDEyMywgOTldLFxuXHRbNywgNzMsIDQ1LCAzLCA3NCwgNDZdLFxuXHRbMTUsIDQzLCAxOSwgMiwgNDQsIDIwXSxcblx0WzMsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sXG5cblx0Ly8gMTdcblx0WzEsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sXG5cdFsxMCwgNzQsIDQ2LCAxLCA3NSwgNDddLFxuXHRbMSwgNTAsIDIyLCAxNSwgNTEsIDIzXSxcblx0WzIsIDQyLCAxNCwgMTcsIDQzLCAxNV0sXG5cblx0Ly8gMThcblx0WzUsIDE1MCwgMTIwLCAxLCAxNTEsIDEyMV0sXG5cdFs5LCA2OSwgNDMsIDQsIDcwLCA0NF0sXG5cdFsxNywgNTAsIDIyLCAxLCA1MSwgMjNdLFxuXHRbMiwgNDIsIDE0LCAxOSwgNDMsIDE1XSxcblxuXHQvLyAxOVxuXHRbMywgMTQxLCAxMTMsIDQsIDE0MiwgMTE0XSxcblx0WzMsIDcwLCA0NCwgMTEsIDcxLCA0NV0sXG5cdFsxNywgNDcsIDIxLCA0LCA0OCwgMjJdLFxuXHRbOSwgMzksIDEzLCAxNiwgNDAsIDE0XSxcblxuXHQvLyAyMFxuXHRbMywgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcblx0WzMsIDY3LCA0MSwgMTMsIDY4LCA0Ml0sXG5cdFsxNSwgNTQsIDI0LCA1LCA1NSwgMjVdLFxuXHRbMTUsIDQzLCAxNSwgMTAsIDQ0LCAxNl0sXG5cblx0Ly8gMjFcblx0WzQsIDE0NCwgMTE2LCA0LCAxNDUsIDExN10sXG5cdFsxNywgNjgsIDQyXSxcblx0WzE3LCA1MCwgMjIsIDYsIDUxLCAyM10sXG5cdFsxOSwgNDYsIDE2LCA2LCA0NywgMTddLFxuXG5cdC8vIDIyXG5cdFsyLCAxMzksIDExMSwgNywgMTQwLCAxMTJdLFxuXHRbMTcsIDc0LCA0Nl0sXG5cdFs3LCA1NCwgMjQsIDE2LCA1NSwgMjVdLFxuXHRbMzQsIDM3LCAxM10sXG5cblx0Ly8gMjNcblx0WzQsIDE1MSwgMTIxLCA1LCAxNTIsIDEyMl0sXG5cdFs0LCA3NSwgNDcsIDE0LCA3NiwgNDhdLFxuXHRbMTEsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG5cdFsxNiwgNDUsIDE1LCAxNCwgNDYsIDE2XSxcblxuXHQvLyAyNFxuXHRbNiwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcblx0WzYsIDczLCA0NSwgMTQsIDc0LCA0Nl0sXG5cdFsxMSwgNTQsIDI0LCAxNiwgNTUsIDI1XSxcblx0WzMwLCA0NiwgMTYsIDIsIDQ3LCAxN10sXG5cblx0Ly8gMjVcblx0WzgsIDEzMiwgMTA2LCA0LCAxMzMsIDEwN10sXG5cdFs4LCA3NSwgNDcsIDEzLCA3NiwgNDhdLFxuXHRbNywgNTQsIDI0LCAyMiwgNTUsIDI1XSxcblx0WzIyLCA0NSwgMTUsIDEzLCA0NiwgMTZdLFxuXG5cdC8vIDI2XG5cdFsxMCwgMTQyLCAxMTQsIDIsIDE0MywgMTE1XSxcblx0WzE5LCA3NCwgNDYsIDQsIDc1LCA0N10sXG5cdFsyOCwgNTAsIDIyLCA2LCA1MSwgMjNdLFxuXHRbMzMsIDQ2LCAxNiwgNCwgNDcsIDE3XSxcblxuXHQvLyAyN1xuXHRbOCwgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcblx0WzIyLCA3MywgNDUsIDMsIDc0LCA0Nl0sXG5cdFs4LCA1MywgMjMsIDI2LCA1NCwgMjRdLFxuXHRbMTIsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sXG5cblx0Ly8gMjhcblx0WzMsIDE0NywgMTE3LCAxMCwgMTQ4LCAxMThdLFxuXHRbMywgNzMsIDQ1LCAyMywgNzQsIDQ2XSxcblx0WzQsIDU0LCAyNCwgMzEsIDU1LCAyNV0sXG5cdFsxMSwgNDUsIDE1LCAzMSwgNDYsIDE2XSxcblxuXHQvLyAyOVxuXHRbNywgMTQ2LCAxMTYsIDcsIDE0NywgMTE3XSxcblx0WzIxLCA3MywgNDUsIDcsIDc0LCA0Nl0sXG5cdFsxLCA1MywgMjMsIDM3LCA1NCwgMjRdLFxuXHRbMTksIDQ1LCAxNSwgMjYsIDQ2LCAxNl0sXG5cblx0Ly8gMzBcblx0WzUsIDE0NSwgMTE1LCAxMCwgMTQ2LCAxMTZdLFxuXHRbMTksIDc1LCA0NywgMTAsIDc2LCA0OF0sXG5cdFsxNSwgNTQsIDI0LCAyNSwgNTUsIDI1XSxcblx0WzIzLCA0NSwgMTUsIDI1LCA0NiwgMTZdLFxuXG5cdC8vIDMxXG5cdFsxMywgMTQ1LCAxMTUsIDMsIDE0NiwgMTE2XSxcblx0WzIsIDc0LCA0NiwgMjksIDc1LCA0N10sXG5cdFs0MiwgNTQsIDI0LCAxLCA1NSwgMjVdLFxuXHRbMjMsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sXG5cblx0Ly8gMzJcblx0WzE3LCAxNDUsIDExNV0sXG5cdFsxMCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSxcblx0WzEwLCA1NCwgMjQsIDM1LCA1NSwgMjVdLFxuXHRbMTksIDQ1LCAxNSwgMzUsIDQ2LCAxNl0sXG5cblx0Ly8gMzNcblx0WzE3LCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLFxuXHRbMTQsIDc0LCA0NiwgMjEsIDc1LCA0N10sXG5cdFsyOSwgNTQsIDI0LCAxOSwgNTUsIDI1XSxcblx0WzExLCA0NSwgMTUsIDQ2LCA0NiwgMTZdLFxuXG5cdC8vIDM0XG5cdFsxMywgMTQ1LCAxMTUsIDYsIDE0NiwgMTE2XSxcblx0WzE0LCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuXHRbNDQsIDU0LCAyNCwgNywgNTUsIDI1XSxcblx0WzU5LCA0NiwgMTYsIDEsIDQ3LCAxN10sXG5cblx0Ly8gMzVcblx0WzEyLCAxNTEsIDEyMSwgNywgMTUyLCAxMjJdLFxuXHRbMTIsIDc1LCA0NywgMjYsIDc2LCA0OF0sXG5cdFszOSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcblx0WzIyLCA0NSwgMTUsIDQxLCA0NiwgMTZdLFxuXG5cdC8vIDM2XG5cdFs2LCAxNTEsIDEyMSwgMTQsIDE1MiwgMTIyXSxcblx0WzYsIDc1LCA0NywgMzQsIDc2LCA0OF0sXG5cdFs0NiwgNTQsIDI0LCAxMCwgNTUsIDI1XSxcblx0WzIsIDQ1LCAxNSwgNjQsIDQ2LCAxNl0sXG5cblx0Ly8gMzdcblx0WzE3LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLFxuXHRbMjksIDc0LCA0NiwgMTQsIDc1LCA0N10sXG5cdFs0OSwgNTQsIDI0LCAxMCwgNTUsIDI1XSxcblx0WzI0LCA0NSwgMTUsIDQ2LCA0NiwgMTZdLFxuXG5cdC8vIDM4XG5cdFs0LCAxNTIsIDEyMiwgMTgsIDE1MywgMTIzXSxcblx0WzEzLCA3NCwgNDYsIDMyLCA3NSwgNDddLFxuXHRbNDgsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG5cdFs0MiwgNDUsIDE1LCAzMiwgNDYsIDE2XSxcblxuXHQvLyAzOVxuXHRbMjAsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sXG5cdFs0MCwgNzUsIDQ3LCA3LCA3NiwgNDhdLFxuXHRbNDMsIDU0LCAyNCwgMjIsIDU1LCAyNV0sXG5cdFsxMCwgNDUsIDE1LCA2NywgNDYsIDE2XSxcblxuXHQvLyA0MFxuXHRbMTksIDE0OCwgMTE4LCA2LCAxNDksIDExOV0sXG5cdFsxOCwgNzUsIDQ3LCAzMSwgNzYsIDQ4XSxcblx0WzM0LCA1NCwgMjQsIDM0LCA1NSwgMjVdLFxuXHRbMjAsIDQ1LCAxNSwgNjEsIDQ2LCAxNl1cbl07XG5cblFSUlNCbG9jay5nZXRSU0Jsb2NrcyA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKSB7XG5cdFxuXHR2YXIgcnNCbG9jayA9IFFSUlNCbG9jay5nZXRSc0Jsb2NrVGFibGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpO1xuXHRcblx0aWYgKHJzQmxvY2sgPT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiYmFkIHJzIGJsb2NrIEAgdHlwZU51bWJlcjpcIiArIHR5cGVOdW1iZXIgKyBcIi9lcnJvckNvcnJlY3RMZXZlbDpcIiArIGVycm9yQ29ycmVjdExldmVsKTtcblx0fVxuXG5cdHZhciBsZW5ndGggPSByc0Jsb2NrLmxlbmd0aCAvIDM7XG5cdFxuXHR2YXIgbGlzdCA9IG5ldyBBcnJheSgpO1xuXHRcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG5cdFx0dmFyIGNvdW50ID0gcnNCbG9ja1tpICogMyArIDBdO1xuXHRcdHZhciB0b3RhbENvdW50ID0gcnNCbG9ja1tpICogMyArIDFdO1xuXHRcdHZhciBkYXRhQ291bnQgID0gcnNCbG9ja1tpICogMyArIDJdO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG5cdFx0XHRsaXN0LnB1c2gobmV3IFFSUlNCbG9jayh0b3RhbENvdW50LCBkYXRhQ291bnQpICk7XHRcblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiBsaXN0O1xufVxuXG5RUlJTQmxvY2suZ2V0UnNCbG9ja1RhYmxlID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcblxuXHRzd2l0Y2goZXJyb3JDb3JyZWN0TGV2ZWwpIHtcblx0Y2FzZSBFQ0wuTCA6XG5cdFx0cmV0dXJuIFFSUlNCbG9jay5SU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDBdO1xuXHRjYXNlIEVDTC5NIDpcblx0XHRyZXR1cm4gUVJSU0Jsb2NrLlJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMV07XG5cdGNhc2UgRUNMLlEgOlxuXHRcdHJldHVybiBRUlJTQmxvY2suUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAyXTtcblx0Y2FzZSBFQ0wuSCA6XG5cdFx0cmV0dXJuIFFSUlNCbG9jay5SU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDNdO1xuXHRkZWZhdWx0IDpcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUVJSU0Jsb2NrO1xuIiwidmFyIFFSTWF0aCA9IHtcblxuXHRnbG9nIDogZnVuY3Rpb24obikge1xuXHRcblx0XHRpZiAobiA8IDEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImdsb2coXCIgKyBuICsgXCIpXCIpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gUVJNYXRoLkxPR19UQUJMRVtuXTtcblx0fSxcblx0XG5cdGdleHAgOiBmdW5jdGlvbihuKSB7XG5cdFxuXHRcdHdoaWxlIChuIDwgMCkge1xuXHRcdFx0biArPSAyNTU7XG5cdFx0fVxuXHRcblx0XHR3aGlsZSAobiA+PSAyNTYpIHtcblx0XHRcdG4gLT0gMjU1O1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIFFSTWF0aC5FWFBfVEFCTEVbbl07XG5cdH0sXG5cdFxuXHRFWFBfVEFCTEUgOiBuZXcgQXJyYXkoMjU2KSxcblx0XG5cdExPR19UQUJMRSA6IG5ldyBBcnJheSgyNTYpXG5cbn07XG5cdFxuZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0UVJNYXRoLkVYUF9UQUJMRVtpXSA9IDEgPDwgaTtcbn1cbmZvciAodmFyIGkgPSA4OyBpIDwgMjU2OyBpKyspIHtcblx0UVJNYXRoLkVYUF9UQUJMRVtpXSA9IFFSTWF0aC5FWFBfVEFCTEVbaSAtIDRdXG5cdFx0XiBRUk1hdGguRVhQX1RBQkxFW2kgLSA1XVxuXHRcdF4gUVJNYXRoLkVYUF9UQUJMRVtpIC0gNl1cblx0XHReIFFSTWF0aC5FWFBfVEFCTEVbaSAtIDhdO1xufVxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTU7IGkrKykge1xuXHRRUk1hdGguTE9HX1RBQkxFW1FSTWF0aC5FWFBfVEFCTEVbaV0gXSA9IGk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUVJNYXRoO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdE1PREVfTlVNQkVSIDpcdFx0MSA8PCAwLFxuXHRNT0RFX0FMUEhBX05VTSA6IFx0MSA8PCAxLFxuXHRNT0RFXzhCSVRfQllURSA6IFx0MSA8PCAyLFxuXHRNT0RFX0tBTkpJIDpcdFx0MSA8PCAzXG59O1xuIiwidmFyIE1vZGUgPSByZXF1aXJlKCcuL21vZGUnKTtcbnZhciBQb2x5bm9taWFsID0gcmVxdWlyZSgnLi9Qb2x5bm9taWFsJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuXG52YXIgUVJNYXNrUGF0dGVybiA9IHtcblx0UEFUVEVSTjAwMCA6IDAsXG5cdFBBVFRFUk4wMDEgOiAxLFxuXHRQQVRURVJOMDEwIDogMixcblx0UEFUVEVSTjAxMSA6IDMsXG5cdFBBVFRFUk4xMDAgOiA0LFxuXHRQQVRURVJOMTAxIDogNSxcblx0UEFUVEVSTjExMCA6IDYsXG5cdFBBVFRFUk4xMTEgOiA3XG59O1xuXG52YXIgUVJVdGlsID0ge1xuXG4gICAgUEFUVEVSTl9QT1NJVElPTl9UQUJMRSA6IFtcblx0ICAgIFtdLFxuXHQgICAgWzYsIDE4XSxcblx0ICAgIFs2LCAyMl0sXG5cdCAgICBbNiwgMjZdLFxuXHQgICAgWzYsIDMwXSxcblx0ICAgIFs2LCAzNF0sXG5cdCAgICBbNiwgMjIsIDM4XSxcblx0ICAgIFs2LCAyNCwgNDJdLFxuXHQgICAgWzYsIDI2LCA0Nl0sXG5cdCAgICBbNiwgMjgsIDUwXSxcblx0ICAgIFs2LCAzMCwgNTRdLFx0XHRcblx0ICAgIFs2LCAzMiwgNThdLFxuXHQgICAgWzYsIDM0LCA2Ml0sXG5cdCAgICBbNiwgMjYsIDQ2LCA2Nl0sXG5cdCAgICBbNiwgMjYsIDQ4LCA3MF0sXG5cdCAgICBbNiwgMjYsIDUwLCA3NF0sXG5cdCAgICBbNiwgMzAsIDU0LCA3OF0sXG5cdCAgICBbNiwgMzAsIDU2LCA4Ml0sXG5cdCAgICBbNiwgMzAsIDU4LCA4Nl0sXG5cdCAgICBbNiwgMzQsIDYyLCA5MF0sXG5cdCAgICBbNiwgMjgsIDUwLCA3MiwgOTRdLFxuXHQgICAgWzYsIDI2LCA1MCwgNzQsIDk4XSxcblx0ICAgIFs2LCAzMCwgNTQsIDc4LCAxMDJdLFxuXHQgICAgWzYsIDI4LCA1NCwgODAsIDEwNl0sXG5cdCAgICBbNiwgMzIsIDU4LCA4NCwgMTEwXSxcblx0ICAgIFs2LCAzMCwgNTgsIDg2LCAxMTRdLFxuXHQgICAgWzYsIDM0LCA2MiwgOTAsIDExOF0sXG5cdCAgICBbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0sXG5cdCAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjZdLFxuXHQgICAgWzYsIDI2LCA1MiwgNzgsIDEwNCwgMTMwXSxcblx0ICAgIFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0sXG5cdCAgICBbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdLFxuXHQgICAgWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyXSxcblx0ICAgIFs2LCAzNCwgNjIsIDkwLCAxMTgsIDE0Nl0sXG5cdCAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0sXG5cdCAgICBbNiwgMjQsIDUwLCA3NiwgMTAyLCAxMjgsIDE1NF0sXG5cdCAgICBbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0sXG5cdCAgICBbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0sXG5cdCAgICBbNiwgMjYsIDU0LCA4MiwgMTEwLCAxMzgsIDE2Nl0sXG5cdCAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF1cbiAgICBdLFxuXG4gICAgRzE1IDogKDEgPDwgMTApIHwgKDEgPDwgOCkgfCAoMSA8PCA1KSB8ICgxIDw8IDQpIHwgKDEgPDwgMikgfCAoMSA8PCAxKSB8ICgxIDw8IDApLFxuICAgIEcxOCA6ICgxIDw8IDEyKSB8ICgxIDw8IDExKSB8ICgxIDw8IDEwKSB8ICgxIDw8IDkpIHwgKDEgPDwgOCkgfCAoMSA8PCA1KSB8ICgxIDw8IDIpIHwgKDEgPDwgMCksXG4gICAgRzE1X01BU0sgOiAoMSA8PCAxNCkgfCAoMSA8PCAxMikgfCAoMSA8PCAxMClcdHwgKDEgPDwgNCkgfCAoMSA8PCAxKSxcblxuICAgIGdldEJDSFR5cGVJbmZvIDogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgdmFyIGQgPSBkYXRhIDw8IDEwO1xuXHQgICAgd2hpbGUgKFFSVXRpbC5nZXRCQ0hEaWdpdChkKSAtIFFSVXRpbC5nZXRCQ0hEaWdpdChRUlV0aWwuRzE1KSA+PSAwKSB7XG5cdFx0ICAgIGQgXj0gKFFSVXRpbC5HMTUgPDwgKFFSVXRpbC5nZXRCQ0hEaWdpdChkKSAtIFFSVXRpbC5nZXRCQ0hEaWdpdChRUlV0aWwuRzE1KSApICk7IFx0XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKCAoZGF0YSA8PCAxMCkgfCBkKSBeIFFSVXRpbC5HMTVfTUFTSztcbiAgICB9LFxuXG4gICAgZ2V0QkNIVHlwZU51bWJlciA6IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgIHZhciBkID0gZGF0YSA8PCAxMjtcblx0ICAgIHdoaWxlIChRUlV0aWwuZ2V0QkNIRGlnaXQoZCkgLSBRUlV0aWwuZ2V0QkNIRGlnaXQoUVJVdGlsLkcxOCkgPj0gMCkge1xuXHRcdCAgICBkIF49IChRUlV0aWwuRzE4IDw8IChRUlV0aWwuZ2V0QkNIRGlnaXQoZCkgLSBRUlV0aWwuZ2V0QkNIRGlnaXQoUVJVdGlsLkcxOCkgKSApOyBcdFxuXHQgICAgfVxuXHQgICAgcmV0dXJuIChkYXRhIDw8IDEyKSB8IGQ7XG4gICAgfSxcblxuICAgIGdldEJDSERpZ2l0IDogZnVuY3Rpb24oZGF0YSkge1xuXG5cdCAgICB2YXIgZGlnaXQgPSAwO1xuXG5cdCAgICB3aGlsZSAoZGF0YSAhPSAwKSB7XG5cdFx0ICAgIGRpZ2l0Kys7XG5cdFx0ICAgIGRhdGEgPj4+PSAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGlnaXQ7XG4gICAgfSxcblxuICAgIGdldFBhdHRlcm5Qb3NpdGlvbiA6IGZ1bmN0aW9uKHR5cGVOdW1iZXIpIHtcblx0ICAgIHJldHVybiBRUlV0aWwuUEFUVEVSTl9QT1NJVElPTl9UQUJMRVt0eXBlTnVtYmVyIC0gMV07XG4gICAgfSxcblxuICAgIGdldE1hc2sgOiBmdW5jdGlvbihtYXNrUGF0dGVybiwgaSwgaikge1xuXHQgICAgXG5cdCAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG5cdFx0ICAgIFxuXHQgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMDAgOiByZXR1cm4gKGkgKyBqKSAlIDIgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAxIDogcmV0dXJuIGkgJSAyID09IDA7XG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMCA6IHJldHVybiBqICUgMyA9PSAwO1xuXHQgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMTEgOiByZXR1cm4gKGkgKyBqKSAlIDMgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAwIDogcmV0dXJuIChNYXRoLmZsb29yKGkgLyAyKSArIE1hdGguZmxvb3IoaiAvIDMpICkgJSAyID09IDA7XG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMSA6IHJldHVybiAoaSAqIGopICUgMiArIChpICogaikgJSAzID09IDA7XG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMCA6IHJldHVybiAoIChpICogaikgJSAyICsgKGkgKiBqKSAlIDMpICUgMiA9PSAwO1xuXHQgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTEgOiByZXR1cm4gKCAoaSAqIGopICUgMyArIChpICsgaikgJSAyKSAlIDIgPT0gMDtcblxuXHQgICAgZGVmYXVsdCA6XG5cdFx0ICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBtYXNrUGF0dGVybjpcIiArIG1hc2tQYXR0ZXJuKTtcblx0ICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbCA6IGZ1bmN0aW9uKGVycm9yQ29ycmVjdExlbmd0aCkge1xuXG5cdCAgICB2YXIgYSA9IG5ldyBQb2x5bm9taWFsKFsxXSwgMCk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JDb3JyZWN0TGVuZ3RoOyBpKyspIHtcblx0XHQgICAgYSA9IGEubXVsdGlwbHkobmV3IFBvbHlub21pYWwoWzEsIG1hdGguZ2V4cChpKV0sIDApICk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhO1xuICAgIH0sXG5cbiAgICBnZXRMZW5ndGhJbkJpdHMgOiBmdW5jdGlvbihtb2RlLCB0eXBlKSB7XG5cblx0ICAgIGlmICgxIDw9IHR5cGUgJiYgdHlwZSA8IDEwKSB7XG5cblx0XHQgICAgLy8gMSAtIDlcblxuXHRcdCAgICBzd2l0Y2gobW9kZSkge1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9OVU1CRVIgXHQ6IHJldHVybiAxMDtcblx0XHQgICAgY2FzZSBNb2RlLk1PREVfQUxQSEFfTlVNIFx0OiByZXR1cm4gOTtcblx0XHQgICAgY2FzZSBNb2RlLk1PREVfOEJJVF9CWVRFXHQ6IHJldHVybiA4O1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9LQU5KSSAgXHQ6IHJldHVybiA4O1xuXHRcdCAgICBkZWZhdWx0IDpcblx0XHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2RlOlwiICsgbW9kZSk7XG5cdFx0ICAgIH1cblxuXHQgICAgfSBlbHNlIGlmICh0eXBlIDwgMjcpIHtcblxuXHRcdCAgICAvLyAxMCAtIDI2XG5cblx0XHQgICAgc3dpdGNoKG1vZGUpIHtcblx0XHQgICAgY2FzZSBNb2RlLk1PREVfTlVNQkVSIFx0OiByZXR1cm4gMTI7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0FMUEhBX05VTSBcdDogcmV0dXJuIDExO1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV84QklUX0JZVEVcdDogcmV0dXJuIDE2O1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9LQU5KSSAgXHQ6IHJldHVybiAxMDtcblx0XHQgICAgZGVmYXVsdCA6XG5cdFx0XHQgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZTpcIiArIG1vZGUpO1xuXHRcdCAgICB9XG5cblx0ICAgIH0gZWxzZSBpZiAodHlwZSA8IDQxKSB7XG5cblx0XHQgICAgLy8gMjcgLSA0MFxuXG5cdFx0ICAgIHN3aXRjaChtb2RlKSB7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX05VTUJFUiBcdDogcmV0dXJuIDE0O1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9BTFBIQV9OVU1cdDogcmV0dXJuIDEzO1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV84QklUX0JZVEVcdDogcmV0dXJuIDE2O1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9LQU5KSSAgXHQ6IHJldHVybiAxMjtcblx0XHQgICAgZGVmYXVsdCA6XG5cdFx0XHQgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZTpcIiArIG1vZGUpO1xuXHRcdCAgICB9XG5cblx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgIHRocm93IG5ldyBFcnJvcihcInR5cGU6XCIgKyB0eXBlKTtcblx0ICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TG9zdFBvaW50IDogZnVuY3Rpb24ocXJDb2RlKSB7XG5cdCAgICBcblx0ICAgIHZhciBtb2R1bGVDb3VudCA9IHFyQ29kZS5nZXRNb2R1bGVDb3VudCgpO1xuXHQgICAgXG5cdCAgICB2YXIgbG9zdFBvaW50ID0gMDtcblx0ICAgIFxuXHQgICAgLy8gTEVWRUwxXG5cdCAgICBcblx0ICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3crKykge1xuXG5cdFx0ICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wrKykge1xuXG5cdFx0XHQgICAgdmFyIHNhbWVDb3VudCA9IDA7XG5cdFx0XHQgICAgdmFyIGRhcmsgPSBxckNvZGUuaXNEYXJrKHJvdywgY29sKTtcblxuXHRcdFx0XHRmb3IgKHZhciByID0gLTE7IHIgPD0gMTsgcisrKSB7XG5cblx0XHRcdFx0ICAgIGlmIChyb3cgKyByIDwgMCB8fCBtb2R1bGVDb3VudCA8PSByb3cgKyByKSB7XG5cdFx0XHRcdFx0ICAgIGNvbnRpbnVlO1xuXHRcdFx0XHQgICAgfVxuXG5cdFx0XHRcdCAgICBmb3IgKHZhciBjID0gLTE7IGMgPD0gMTsgYysrKSB7XG5cblx0XHRcdFx0XHQgICAgaWYgKGNvbCArIGMgPCAwIHx8IG1vZHVsZUNvdW50IDw9IGNvbCArIGMpIHtcblx0XHRcdFx0XHRcdCAgICBjb250aW51ZTtcblx0XHRcdFx0XHQgICAgfVxuXG5cdFx0XHRcdFx0ICAgIGlmIChyID09IDAgJiYgYyA9PSAwKSB7XG5cdFx0XHRcdFx0XHQgICAgY29udGludWU7XG5cdFx0XHRcdFx0ICAgIH1cblxuXHRcdFx0XHRcdCAgICBpZiAoZGFyayA9PSBxckNvZGUuaXNEYXJrKHJvdyArIHIsIGNvbCArIGMpICkge1xuXHRcdFx0XHRcdFx0ICAgIHNhbWVDb3VudCsrO1xuXHRcdFx0XHRcdCAgICB9XG5cdFx0XHRcdCAgICB9XG5cdFx0XHQgICAgfVxuXG5cdFx0XHQgICAgaWYgKHNhbWVDb3VudCA+IDUpIHtcblx0XHRcdFx0ICAgIGxvc3RQb2ludCArPSAoMyArIHNhbWVDb3VudCAtIDUpO1xuXHRcdFx0ICAgIH1cblx0XHQgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBMRVZFTDJcblxuXHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSAxOyByb3crKykge1xuXHRcdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDE7IGNvbCsrKSB7XG5cdFx0XHQgICAgdmFyIGNvdW50ID0gMDtcblx0XHRcdCAgICBpZiAocXJDb2RlLmlzRGFyayhyb3csICAgICBjb2wgICAgKSApIGNvdW50Kys7XG5cdFx0XHQgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93ICsgMSwgY29sICAgICkgKSBjb3VudCsrO1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgICAgIGNvbCArIDEpICkgY291bnQrKztcblx0XHRcdCAgICBpZiAocXJDb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wgKyAxKSApIGNvdW50Kys7XG5cdFx0XHQgICAgaWYgKGNvdW50ID09IDAgfHwgY291bnQgPT0gNCkge1xuXHRcdFx0XHQgICAgbG9zdFBvaW50ICs9IDM7XG5cdFx0XHQgICAgfVxuXHRcdCAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIExFVkVMM1xuXG5cdCAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93KyspIHtcblx0XHQgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQgLSA2OyBjb2wrKykge1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgY29sKVxuXHRcdFx0XHRcdCAgICAmJiAhcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDEpXG5cdFx0XHRcdFx0ICAgICYmICBxckNvZGUuaXNEYXJrKHJvdywgY29sICsgMilcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyAzKVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDQpXG5cdFx0XHRcdFx0ICAgICYmICFxckNvZGUuaXNEYXJrKHJvdywgY29sICsgNSlcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyA2KSApIHtcblx0XHRcdFx0ICAgIGxvc3RQb2ludCArPSA0MDtcblx0XHRcdCAgICB9XG5cdFx0ICAgIH1cblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCsrKSB7XG5cdFx0ICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50IC0gNjsgcm93KyspIHtcblx0XHRcdCAgICBpZiAocXJDb2RlLmlzRGFyayhyb3csIGNvbClcblx0XHRcdFx0XHQgICAgJiYgIXFyQ29kZS5pc0Rhcmsocm93ICsgMSwgY29sKVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3cgKyAyLCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICBxckNvZGUuaXNEYXJrKHJvdyArIDMsIGNvbClcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93ICsgNCwgY29sKVxuXHRcdFx0XHRcdCAgICAmJiAhcXJDb2RlLmlzRGFyayhyb3cgKyA1LCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICBxckNvZGUuaXNEYXJrKHJvdyArIDYsIGNvbCkgKSB7XG5cdFx0XHRcdCAgICBsb3N0UG9pbnQgKz0gNDA7XG5cdFx0XHQgICAgfVxuXHRcdCAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIExFVkVMNFxuXHQgICAgXG5cdCAgICB2YXIgZGFya0NvdW50ID0gMDtcblxuXHQgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCsrKSB7XG5cdFx0ICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3crKykge1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgY29sKSApIHtcblx0XHRcdFx0ICAgIGRhcmtDb3VudCsrO1xuXHRcdFx0ICAgIH1cblx0XHQgICAgfVxuXHQgICAgfVxuXHQgICAgXG5cdCAgICB2YXIgcmF0aW8gPSBNYXRoLmFicygxMDAgKiBkYXJrQ291bnQgLyBtb2R1bGVDb3VudCAvIG1vZHVsZUNvdW50IC0gNTApIC8gNTtcblx0ICAgIGxvc3RQb2ludCArPSByYXRpbyAqIDEwO1xuXG5cdCAgICByZXR1cm4gbG9zdFBvaW50O1x0XHRcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFFSVXRpbDtcbiIsIi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gUVIgQ29kZSBHZW5lcmF0b3IgZm9yIEphdmFTY3JpcHRcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgS2F6dWhpa28gQXJhc2Vcbi8vXG4vLyBVUkw6IGh0dHA6Ly93d3cuZC1wcm9qZWN0LmNvbS9cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4vLyAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbi8vXG4vLyBUaGUgd29yZCAnUVIgQ29kZScgaXMgcmVnaXN0ZXJlZCB0cmFkZW1hcmsgb2Zcbi8vIERFTlNPIFdBVkUgSU5DT1JQT1JBVEVEXG4vLyAgaHR0cDovL3d3dy5kZW5zby13YXZlLmNvbS9xcmNvZGUvZmFxcGF0ZW50LWUuaHRtbFxuLy9cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBxcmNvZGUgPSBmdW5jdGlvbigpIHtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcmNvZGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogcXJjb2RlXG4gICAqIEBwYXJhbSB0eXBlTnVtYmVyIDEgdG8gNDBcbiAgICogQHBhcmFtIGVycm9yQ29ycmVjdGlvbkxldmVsICdMJywnTScsJ1EnLCdIJ1xuICAgKi9cbiAgdmFyIHFyY29kZSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG5cbiAgICB2YXIgUEFEMCA9IDB4RUM7XG4gICAgdmFyIFBBRDEgPSAweDExO1xuXG4gICAgdmFyIF90eXBlTnVtYmVyID0gdHlwZU51bWJlcjtcbiAgICB2YXIgX2Vycm9yQ29ycmVjdGlvbkxldmVsID0gUVJFcnJvckNvcnJlY3Rpb25MZXZlbFtlcnJvckNvcnJlY3Rpb25MZXZlbF07XG4gICAgdmFyIF9tb2R1bGVzID0gbnVsbDtcbiAgICB2YXIgX21vZHVsZUNvdW50ID0gMDtcbiAgICB2YXIgX2RhdGFDYWNoZSA9IG51bGw7XG4gICAgdmFyIF9kYXRhTGlzdCA9IFtdO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICB2YXIgbWFrZUltcGwgPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuXG4gICAgICBfbW9kdWxlQ291bnQgPSBfdHlwZU51bWJlciAqIDQgKyAxNztcbiAgICAgIF9tb2R1bGVzID0gZnVuY3Rpb24obW9kdWxlQ291bnQpIHtcbiAgICAgICAgdmFyIG1vZHVsZXMgPSBuZXcgQXJyYXkobW9kdWxlQ291bnQpO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICBtb2R1bGVzW3Jvd10gPSBuZXcgQXJyYXkobW9kdWxlQ291bnQpO1xuICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgbW9kdWxlc1tyb3ddW2NvbF0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlcztcbiAgICAgIH0oX21vZHVsZUNvdW50KTtcblxuICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybigwLCAwKTtcbiAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oX21vZHVsZUNvdW50IC0gNywgMCk7XG4gICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIF9tb2R1bGVDb3VudCAtIDcpO1xuICAgICAgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4oKTtcbiAgICAgIHNldHVwVGltaW5nUGF0dGVybigpO1xuICAgICAgc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybik7XG5cbiAgICAgIGlmIChfdHlwZU51bWJlciA+PSA3KSB7XG4gICAgICAgIHNldHVwVHlwZU51bWJlcih0ZXN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9kYXRhQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgICBfZGF0YUNhY2hlID0gY3JlYXRlRGF0YShfdHlwZU51bWJlciwgX2Vycm9yQ29ycmVjdGlvbkxldmVsLCBfZGF0YUxpc3QpO1xuICAgICAgfVxuXG4gICAgICBtYXBEYXRhKF9kYXRhQ2FjaGUsIG1hc2tQYXR0ZXJuKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4gPSBmdW5jdGlvbihyb3csIGNvbCkge1xuXG4gICAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gNzsgciArPSAxKSB7XG5cbiAgICAgICAgaWYgKHJvdyArIHIgPD0gLTEgfHwgX21vZHVsZUNvdW50IDw9IHJvdyArIHIpIGNvbnRpbnVlO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSA3OyBjICs9IDEpIHtcblxuICAgICAgICAgIGlmIChjb2wgKyBjIDw9IC0xIHx8IF9tb2R1bGVDb3VudCA8PSBjb2wgKyBjKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmICggKDAgPD0gciAmJiByIDw9IDYgJiYgKGMgPT0gMCB8fCBjID09IDYpIClcbiAgICAgICAgICAgICAgfHwgKDAgPD0gYyAmJiBjIDw9IDYgJiYgKHIgPT0gMCB8fCByID09IDYpIClcbiAgICAgICAgICAgICAgfHwgKDIgPD0gciAmJiByIDw9IDQgJiYgMiA8PSBjICYmIGMgPD0gNCkgKSB7XG4gICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRCZXN0TWFza1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIG1pbkxvc3RQb2ludCA9IDA7XG4gICAgICB2YXIgcGF0dGVybiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG5cbiAgICAgICAgbWFrZUltcGwodHJ1ZSwgaSk7XG5cbiAgICAgICAgdmFyIGxvc3RQb2ludCA9IFFSVXRpbC5nZXRMb3N0UG9pbnQoX3RoaXMpO1xuXG4gICAgICAgIGlmIChpID09IDAgfHwgbWluTG9zdFBvaW50ID4gbG9zdFBvaW50KSB7XG4gICAgICAgICAgbWluTG9zdFBvaW50ID0gbG9zdFBvaW50O1xuICAgICAgICAgIHBhdHRlcm4gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dXBUaW1pbmdQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIGZvciAodmFyIHIgPSA4OyByIDwgX21vZHVsZUNvdW50IC0gODsgciArPSAxKSB7XG4gICAgICAgIGlmIChfbW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgX21vZHVsZXNbcl1bNl0gPSAociAlIDIgPT0gMCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGMgPSA4OyBjIDwgX21vZHVsZUNvdW50IC0gODsgYyArPSAxKSB7XG4gICAgICAgIGlmIChfbW9kdWxlc1s2XVtjXSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgX21vZHVsZXNbNl1bY10gPSAoYyAlIDIgPT0gMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcG9zID0gUVJVdGlsLmdldFBhdHRlcm5Qb3NpdGlvbihfdHlwZU51bWJlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSArPSAxKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqICs9IDEpIHtcblxuICAgICAgICAgIHZhciByb3cgPSBwb3NbaV07XG4gICAgICAgICAgdmFyIGNvbCA9IHBvc1tqXTtcblxuICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgciA9IC0yOyByIDw9IDI7IHIgKz0gMSkge1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gLTI7IGMgPD0gMjsgYyArPSAxKSB7XG5cbiAgICAgICAgICAgICAgaWYgKHIgPT0gLTIgfHwgciA9PSAyIHx8IGMgPT0gLTIgfHwgYyA9PSAyXG4gICAgICAgICAgICAgICAgICB8fCAociA9PSAwICYmIGMgPT0gMCkgKSB7XG4gICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldHVwVHlwZU51bWJlciA9IGZ1bmN0aW9uKHRlc3QpIHtcblxuICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZU51bWJlcihfdHlwZU51bWJlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcbiAgICAgICAgX21vZHVsZXNbTWF0aC5mbG9vcihpIC8gMyldW2kgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdID0gbW9kO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE4OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG4gICAgICAgIF9tb2R1bGVzW2kgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdW01hdGguZmxvb3IoaSAvIDMpXSA9IG1vZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldHVwVHlwZUluZm8gPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuXG4gICAgICB2YXIgZGF0YSA9IChfZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPDwgMykgfCBtYXNrUGF0dGVybjtcbiAgICAgIHZhciBiaXRzID0gUVJVdGlsLmdldEJDSFR5cGVJbmZvKGRhdGEpO1xuXG4gICAgICAvLyB2ZXJ0aWNhbFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSArPSAxKSB7XG5cbiAgICAgICAgdmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG5cbiAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgX21vZHVsZXNbaV1bOF0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IDgpIHtcbiAgICAgICAgICBfbW9kdWxlc1tpICsgMV1bOF0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vZHVsZXNbX21vZHVsZUNvdW50IC0gMTUgKyBpXVs4XSA9IG1vZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBob3Jpem9udGFsXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpICs9IDEpIHtcblxuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblxuICAgICAgICBpZiAoaSA8IDgpIHtcbiAgICAgICAgICBfbW9kdWxlc1s4XVtfbW9kdWxlQ291bnQgLSBpIC0gMV0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IDkpIHtcbiAgICAgICAgICBfbW9kdWxlc1s4XVsxNSAtIGkgLSAxICsgMV0gPSBtb2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vZHVsZXNbOF1bMTUgLSBpIC0gMV0gPSBtb2Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZml4ZWQgbW9kdWxlXG4gICAgICBfbW9kdWxlc1tfbW9kdWxlQ291bnQgLSA4XVs4XSA9ICghdGVzdCk7XG4gICAgfTtcblxuICAgIHZhciBtYXBEYXRhID0gZnVuY3Rpb24oZGF0YSwgbWFza1BhdHRlcm4pIHtcblxuICAgICAgdmFyIGluYyA9IC0xO1xuICAgICAgdmFyIHJvdyA9IF9tb2R1bGVDb3VudCAtIDE7XG4gICAgICB2YXIgYml0SW5kZXggPSA3O1xuICAgICAgdmFyIGJ5dGVJbmRleCA9IDA7XG4gICAgICB2YXIgbWFza0Z1bmMgPSBRUlV0aWwuZ2V0TWFza0Z1bmN0aW9uKG1hc2tQYXR0ZXJuKTtcblxuICAgICAgZm9yICh2YXIgY29sID0gX21vZHVsZUNvdW50IC0gMTsgY29sID4gMDsgY29sIC09IDIpIHtcblxuICAgICAgICBpZiAoY29sID09IDYpIGNvbCAtPSAxO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDI7IGMgKz0gMSkge1xuXG4gICAgICAgICAgICBpZiAoX21vZHVsZXNbcm93XVtjb2wgLSBjXSA9PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgdmFyIGRhcmsgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoYnl0ZUluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkYXJrID0gKCAoIChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4KSAmIDEpID09IDEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG1hc2sgPSBtYXNrRnVuYyhyb3csIGNvbCAtIGMpO1xuXG4gICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgZGFyayA9ICFkYXJrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX21vZHVsZXNbcm93XVtjb2wgLSBjXSA9IGRhcms7XG4gICAgICAgICAgICAgIGJpdEluZGV4IC09IDE7XG5cbiAgICAgICAgICAgICAgaWYgKGJpdEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnl0ZUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgYml0SW5kZXggPSA3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ICs9IGluYztcblxuICAgICAgICAgIGlmIChyb3cgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgIHJvdyAtPSBpbmM7XG4gICAgICAgICAgICBpbmMgPSAtaW5jO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVCeXRlcyA9IGZ1bmN0aW9uKGJ1ZmZlciwgcnNCbG9ja3MpIHtcblxuICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgIHZhciBtYXhEY0NvdW50ID0gMDtcbiAgICAgIHZhciBtYXhFY0NvdW50ID0gMDtcblxuICAgICAgdmFyIGRjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuICAgICAgdmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG5cbiAgICAgICAgdmFyIGRjQ291bnQgPSByc0Jsb2Nrc1tyXS5kYXRhQ291bnQ7XG4gICAgICAgIHZhciBlY0NvdW50ID0gcnNCbG9ja3Nbcl0udG90YWxDb3VudCAtIGRjQ291bnQ7XG5cbiAgICAgICAgbWF4RGNDb3VudCA9IE1hdGgubWF4KG1heERjQ291bnQsIGRjQ291bnQpO1xuICAgICAgICBtYXhFY0NvdW50ID0gTWF0aC5tYXgobWF4RWNDb3VudCwgZWNDb3VudCk7XG5cbiAgICAgICAgZGNkYXRhW3JdID0gbmV3IEFycmF5KGRjQ291bnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGNkYXRhW3JdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgZGNkYXRhW3JdW2ldID0gMHhmZiAmIGJ1ZmZlci5nZXRCdWZmZXIoKVtpICsgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gZGNDb3VudDtcblxuICAgICAgICB2YXIgcnNQb2x5ID0gUVJVdGlsLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwoZWNDb3VudCk7XG4gICAgICAgIHZhciByYXdQb2x5ID0gcXJQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG5cbiAgICAgICAgdmFyIG1vZFBvbHkgPSByYXdQb2x5Lm1vZChyc1BvbHkpO1xuICAgICAgICBlY2RhdGFbcl0gPSBuZXcgQXJyYXkocnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWNkYXRhW3JdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIG1vZEluZGV4ID0gaSArIG1vZFBvbHkuZ2V0TGVuZ3RoKCkgLSBlY2RhdGFbcl0ubGVuZ3RoO1xuICAgICAgICAgIGVjZGF0YVtyXVtpXSA9IChtb2RJbmRleCA+PSAwKT8gbW9kUG9seS5nZXRBdChtb2RJbmRleCkgOiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbENvZGVDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRvdGFsQ29kZUNvdW50ICs9IHJzQmxvY2tzW2ldLnRvdGFsQ291bnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gbmV3IEFycmF5KHRvdGFsQ29kZUNvdW50KTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGNDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA8IGRjZGF0YVtyXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZGNkYXRhW3JdW2ldO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhFY0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIGlmIChpIDwgZWNkYXRhW3JdLmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBlY2RhdGFbcl1baV07XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURhdGEgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgZGF0YUxpc3QpIHtcblxuICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcblxuICAgICAgdmFyIGJ1ZmZlciA9IHFyQml0QnVmZmVyKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtpXTtcbiAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldE1vZGUoKSwgNCk7XG4gICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgUVJVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLmdldE1vZGUoKSwgdHlwZU51bWJlcikgKTtcbiAgICAgICAgZGF0YS53cml0ZShidWZmZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxjIG51bSBtYXggZGF0YS5cbiAgICAgIHZhciB0b3RhbERhdGFDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2ldLmRhdGFDb3VudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICB0aHJvdyAnY29kZSBsZW5ndGggb3ZlcmZsb3cuICgnXG4gICAgICAgICAgKyBidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKClcbiAgICAgICAgICArICc+J1xuICAgICAgICAgICsgdG90YWxEYXRhQ291bnQgKiA4XG4gICAgICAgICAgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIC8vIGVuZCBjb2RlXG4gICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICsgNCA8PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgYnVmZmVyLnB1dCgwLCA0KTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFkZGluZ1xuICAgICAgd2hpbGUgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSAlIDggIT0gMCkge1xuICAgICAgICBidWZmZXIucHV0Qml0KGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFkZGluZ1xuICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXQoUEFEMCwgOCk7XG5cbiAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHV0KFBBRDEsIDgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlQnl0ZXMoYnVmZmVyLCByc0Jsb2Nrcyk7XG4gICAgfTtcblxuICAgIF90aGlzLmFkZERhdGEgPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7XG5cbiAgICAgIG1vZGUgPSBtb2RlIHx8ICdCeXRlJztcblxuICAgICAgdmFyIG5ld0RhdGEgPSBudWxsO1xuXG4gICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgY2FzZSAnTnVtZXJpYycgOlxuICAgICAgICBuZXdEYXRhID0gcXJOdW1iZXIoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQWxwaGFudW1lcmljJyA6XG4gICAgICAgIG5ld0RhdGEgPSBxckFscGhhTnVtKGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0J5dGUnIDpcbiAgICAgICAgbmV3RGF0YSA9IHFyOEJpdEJ5dGUoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnS2FuamknIDpcbiAgICAgICAgbmV3RGF0YSA9IHFyS2FuamkoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdCA6XG4gICAgICAgIHRocm93ICdtb2RlOicgKyBtb2RlO1xuICAgICAgfVxuXG4gICAgICBfZGF0YUxpc3QucHVzaChuZXdEYXRhKTtcbiAgICAgIF9kYXRhQ2FjaGUgPSBudWxsO1xuICAgIH07XG5cbiAgICBfdGhpcy5pc0RhcmsgPSBmdW5jdGlvbihyb3csIGNvbCkge1xuICAgICAgaWYgKHJvdyA8IDAgfHwgX21vZHVsZUNvdW50IDw9IHJvdyB8fCBjb2wgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSBjb2wpIHtcbiAgICAgICAgdGhyb3cgcm93ICsgJywnICsgY29sO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9tb2R1bGVzW3Jvd11bY29sXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TW9kdWxlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kdWxlQ291bnQ7XG4gICAgfTtcblxuICAgIF90aGlzLm1ha2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfdHlwZU51bWJlciA8IDEpIHtcbiAgICAgICAgdmFyIHR5cGVOdW1iZXIgPSAxO1xuXG4gICAgICAgIGZvciAoOyB0eXBlTnVtYmVyIDwgNDA7IHR5cGVOdW1iZXIrKykge1xuICAgICAgICAgIHZhciByc0Jsb2NrcyA9IFFSUlNCbG9jay5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyLCBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgICAgICAgIHZhciBidWZmZXIgPSBxckJpdEJ1ZmZlcigpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfZGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gX2RhdGFMaXN0W2ldO1xuICAgICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldE1vZGUoKSwgNCk7XG4gICAgICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TGVuZ3RoKCksIFFSVXRpbC5nZXRMZW5ndGhJbkJpdHMoZGF0YS5nZXRNb2RlKCksIHR5cGVOdW1iZXIpICk7XG4gICAgICAgICAgICBkYXRhLndyaXRlKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbERhdGFDb3VudCArPSByc0Jsb2Nrc1tpXS5kYXRhQ291bnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA8PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90eXBlTnVtYmVyID0gdHlwZU51bWJlcjtcbiAgICAgIH1cblxuICAgICAgbWFrZUltcGwoZmFsc2UsIGdldEJlc3RNYXNrUGF0dGVybigpICk7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZVRhYmxlVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbikge1xuXG4gICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICBtYXJnaW4gPSAodHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyk/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcblxuICAgICAgdmFyIHFySHRtbCA9ICcnO1xuXG4gICAgICBxckh0bWwgKz0gJzx0YWJsZSBzdHlsZT1cIic7XG4gICAgICBxckh0bWwgKz0gJyBib3JkZXItd2lkdGg6IDBweDsgYm9yZGVyLXN0eWxlOiBub25lOyc7XG4gICAgICBxckh0bWwgKz0gJyBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyc7XG4gICAgICBxckh0bWwgKz0gJyBwYWRkaW5nOiAwcHg7IG1hcmdpbjogJyArIG1hcmdpbiArICdweDsnO1xuICAgICAgcXJIdG1sICs9ICdcIj4nO1xuICAgICAgcXJIdG1sICs9ICc8dGJvZHk+JztcblxuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyByICs9IDEpIHtcblxuICAgICAgICBxckh0bWwgKz0gJzx0cj4nO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgYyArPSAxKSB7XG4gICAgICAgICAgcXJIdG1sICs9ICc8dGQgc3R5bGU9XCInO1xuICAgICAgICAgIHFySHRtbCArPSAnIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7JztcbiAgICAgICAgICBxckh0bWwgKz0gJyBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgcGFkZGluZzogMHB4OyBtYXJnaW46IDBweDsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIHdpZHRoOiAnICsgY2VsbFNpemUgKyAncHg7JztcbiAgICAgICAgICBxckh0bWwgKz0gJyBoZWlnaHQ6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIGJhY2tncm91bmQtY29sb3I6ICc7XG4gICAgICAgICAgcXJIdG1sICs9IF90aGlzLmlzRGFyayhyLCBjKT8gJyMwMDAwMDAnIDogJyNmZmZmZmYnO1xuICAgICAgICAgIHFySHRtbCArPSAnOyc7XG4gICAgICAgICAgcXJIdG1sICs9ICdcIi8+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHFySHRtbCArPSAnPC90cj4nO1xuICAgICAgfVxuXG4gICAgICBxckh0bWwgKz0gJzwvdGJvZHk+JztcbiAgICAgIHFySHRtbCArPSAnPC90YWJsZT4nO1xuXG4gICAgICByZXR1cm4gcXJIdG1sO1xuICAgIH07XG5cbiAgICBfdGhpcy5jcmVhdGVTdmdUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuICAgICAgdmFyIGMsIG1jLCByLCBtciwgcXJTdmc9JycsIHJlY3Q7XG5cbiAgICAgIHJlY3QgPSAnbCcgKyBjZWxsU2l6ZSArICcsMCAwLCcgKyBjZWxsU2l6ZSArXG4gICAgICAgICcgLScgKyBjZWxsU2l6ZSArICcsMCAwLC0nICsgY2VsbFNpemUgKyAneiAnO1xuXG4gICAgICBxclN2ZyArPSAnPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJztcbiAgICAgIHFyU3ZnICs9ICcgd2lkdGg9XCInICsgc2l6ZSArICdweFwiJztcbiAgICAgIHFyU3ZnICs9ICcgaGVpZ2h0PVwiJyArIHNpemUgKyAncHhcIic7XG4gICAgICBxclN2ZyArPSAnIHZpZXdCb3g9XCIwIDAgJyArIHNpemUgKyAnICcgKyBzaXplICsgJ1wiICc7XG4gICAgICBxclN2ZyArPSAnIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWluWU1pbiBtZWV0XCI+JztcbiAgICAgIHFyU3ZnICs9ICc8cmVjdCB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgZmlsbD1cIndoaXRlXCIgY3g9XCIwXCIgY3k9XCIwXCIvPic7XG4gICAgICBxclN2ZyArPSAnPHBhdGggZD1cIic7XG5cbiAgICAgIGZvciAociA9IDA7IHIgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyByICs9IDEpIHtcbiAgICAgICAgbXIgPSByICogY2VsbFNpemUgKyBtYXJnaW47XG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjICs9IDEpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaXNEYXJrKHIsIGMpICkge1xuICAgICAgICAgICAgbWMgPSBjKmNlbGxTaXplK21hcmdpbjtcbiAgICAgICAgICAgIHFyU3ZnICs9ICdNJyArIG1jICsgJywnICsgbXIgKyByZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxclN2ZyArPSAnXCIgc3Ryb2tlPVwidHJhbnNwYXJlbnRcIiBmaWxsPVwiYmxhY2tcIi8+JztcbiAgICAgIHFyU3ZnICs9ICc8L3N2Zz4nO1xuXG4gICAgICByZXR1cm4gcXJTdmc7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZURhdGFVUkwgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICB2YXIgbWluID0gbWFyZ2luO1xuICAgICAgdmFyIG1heCA9IHNpemUgLSBtYXJnaW47XG5cbiAgICAgIHJldHVybiBjcmVhdGVEYXRhVVJMKHNpemUsIHNpemUsIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKG1pbiA8PSB4ICYmIHggPCBtYXggJiYgbWluIDw9IHkgJiYgeSA8IG1heCkge1xuICAgICAgICAgIHZhciBjID0gTWF0aC5mbG9vciggKHggLSBtaW4pIC8gY2VsbFNpemUpO1xuICAgICAgICAgIHZhciByID0gTWF0aC5mbG9vciggKHkgLSBtaW4pIC8gY2VsbFNpemUpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5pc0RhcmsociwgYyk/IDAgOiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZUltZ1RhZyA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4sIGFsdCkge1xuXG4gICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICBtYXJnaW4gPSAodHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyk/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcblxuICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuXG4gICAgICB2YXIgaW1nID0gJyc7XG4gICAgICBpbWcgKz0gJzxpbWcnO1xuICAgICAgaW1nICs9ICdcXHUwMDIwc3JjPVwiJztcbiAgICAgIGltZyArPSBfdGhpcy5jcmVhdGVEYXRhVVJMKGNlbGxTaXplLCBtYXJnaW4pO1xuICAgICAgaW1nICs9ICdcIic7XG4gICAgICBpbWcgKz0gJ1xcdTAwMjB3aWR0aD1cIic7XG4gICAgICBpbWcgKz0gc2l6ZTtcbiAgICAgIGltZyArPSAnXCInO1xuICAgICAgaW1nICs9ICdcXHUwMDIwaGVpZ2h0PVwiJztcbiAgICAgIGltZyArPSBzaXplO1xuICAgICAgaW1nICs9ICdcIic7XG4gICAgICBpZiAoYWx0KSB7XG4gICAgICAgIGltZyArPSAnXFx1MDAyMGFsdD1cIic7XG4gICAgICAgIGltZyArPSBhbHQ7XG4gICAgICAgIGltZyArPSAnXCInO1xuICAgICAgfVxuICAgICAgaW1nICs9ICcvPic7XG5cbiAgICAgIHJldHVybiBpbWc7XG4gICAgfTtcblxuICAgIHZhciBfY3JlYXRlSGFsZkFTQ0lJID0gZnVuY3Rpb24obWFyZ2luKSB7XG4gICAgICB2YXIgY2VsbFNpemUgPSAxO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDIgOiBtYXJnaW47XG5cbiAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBtaW4gPSBtYXJnaW47XG4gICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblxuICAgICAgdmFyIHksIHgsIHIxLCByMiwgcDtcblxuICAgICAgdmFyIGJsb2NrcyA9IHtcbiAgICAgICAgJ+KWiOKWiCc6ICfilognLFxuICAgICAgICAn4paIICc6ICfiloAnLFxuICAgICAgICAnIOKWiCc6ICfiloQnLFxuICAgICAgICAnICAnOiAnICdcbiAgICAgIH07XG5cbiAgICAgIHZhciBhc2NpaSA9ICcnO1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHNpemU7IHkgKz0gMikge1xuICAgICAgICByMSA9IE1hdGguZmxvb3IoKHkgLSBtaW4pIC8gY2VsbFNpemUpO1xuICAgICAgICByMiA9IE1hdGguZmxvb3IoKHkgKyAxIC0gbWluKSAvIGNlbGxTaXplKTtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHNpemU7IHggKz0gMSkge1xuICAgICAgICAgIHAgPSAn4paIJztcblxuICAgICAgICAgIGlmIChtaW4gPD0geCAmJiB4IDwgbWF4ICYmIG1pbiA8PSB5ICYmIHkgPCBtYXggJiYgX3RoaXMuaXNEYXJrKHIxLCBNYXRoLmZsb29yKCh4IC0gbWluKSAvIGNlbGxTaXplKSkpIHtcbiAgICAgICAgICAgIHAgPSAnICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pbiA8PSB4ICYmIHggPCBtYXggJiYgbWluIDw9IHkrMSAmJiB5KzEgPCBtYXggJiYgX3RoaXMuaXNEYXJrKHIyLCBNYXRoLmZsb29yKCh4IC0gbWluKSAvIGNlbGxTaXplKSkpIHtcbiAgICAgICAgICAgIHAgKz0gJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gJ+KWiCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3V0cHV0IDIgY2hhcmFjdGVycyBwZXIgcGl4ZWwsIHRvIGNyZWF0ZSBmdWxsIHNxdWFyZS4gMSBjaGFyYWN0ZXIgcGVyIHBpeGVscyBnaXZlcyBvbmx5IGhhbGYgd2lkdGggb2Ygc3F1YXJlLlxuICAgICAgICAgIGFzY2lpICs9IGJsb2Nrc1twXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzY2lpICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSAlIDIpIHtcbiAgICAgICAgcmV0dXJuIGFzY2lpLnN1YnN0cmluZygwLCBhc2NpaS5sZW5ndGggLSBzaXplIC0gMSkgKyBBcnJheShzaXplKzEpLmpvaW4oJ+KWgCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aC0xKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlQVNDSUkgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG4gICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDE7XG5cbiAgICAgIGlmIChjZWxsU2l6ZSA8IDIpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVIYWxmQVNDSUkobWFyZ2luKTtcbiAgICAgIH1cblxuICAgICAgY2VsbFNpemUgLT0gMTtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiAyIDogbWFyZ2luO1xuXG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICB2YXIgbWluID0gbWFyZ2luO1xuICAgICAgdmFyIG1heCA9IHNpemUgLSBtYXJnaW47XG5cbiAgICAgIHZhciB5LCB4LCByLCBwO1xuXG4gICAgICB2YXIgd2hpdGUgPSBBcnJheShjZWxsU2l6ZSsxKS5qb2luKCfilojilognKTtcbiAgICAgIHZhciBibGFjayA9IEFycmF5KGNlbGxTaXplKzEpLmpvaW4oJyAgJyk7XG5cbiAgICAgIHZhciBhc2NpaSA9ICcnO1xuICAgICAgdmFyIGxpbmUgPSAnJztcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzaXplOyB5ICs9IDEpIHtcbiAgICAgICAgciA9IE1hdGguZmxvb3IoICh5IC0gbWluKSAvIGNlbGxTaXplKTtcbiAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgc2l6ZTsgeCArPSAxKSB7XG4gICAgICAgICAgcCA9IDE7XG5cbiAgICAgICAgICBpZiAobWluIDw9IHggJiYgeCA8IG1heCAmJiBtaW4gPD0geSAmJiB5IDwgbWF4ICYmIF90aGlzLmlzRGFyayhyLCBNYXRoLmZsb29yKCh4IC0gbWluKSAvIGNlbGxTaXplKSkpIHtcbiAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE91dHB1dCAyIGNoYXJhY3RlcnMgcGVyIHBpeGVsLCB0byBjcmVhdGUgZnVsbCBzcXVhcmUuIDEgY2hhcmFjdGVyIHBlciBwaXhlbHMgZ2l2ZXMgb25seSBoYWxmIHdpZHRoIG9mIHNxdWFyZS5cbiAgICAgICAgICBsaW5lICs9IHAgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChyID0gMDsgciA8IGNlbGxTaXplOyByICs9IDEpIHtcbiAgICAgICAgICBhc2NpaSArPSBsaW5lICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzY2lpLnN1YnN0cmluZygwLCBhc2NpaS5sZW5ndGgtMSk7XG4gICAgfTtcblxuICAgIF90aGlzLnJlbmRlclRvMmRDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgY2VsbFNpemUpIHtcbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIHZhciBsZW5ndGggPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpO1xuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbGVuZ3RoOyByb3crKykge1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBsZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBfdGhpcy5pc0Rhcmsocm93LCBjb2wpID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdChyb3cgKiBjZWxsU2l6ZSwgY29sICogY2VsbFNpemUsIGNlbGxTaXplLCBjZWxsU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJjb2RlLnN0cmluZ1RvQnl0ZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBxcmNvZGUuc3RyaW5nVG9CeXRlc0Z1bmNzID0ge1xuICAgICdkZWZhdWx0JyA6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBieXRlcy5wdXNoKGMgJiAweGZmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH07XG5cbiAgcXJjb2RlLnN0cmluZ1RvQnl0ZXMgPSBxcmNvZGUuc3RyaW5nVG9CeXRlc0Z1bmNzWydkZWZhdWx0J107XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJjb2RlLmNyZWF0ZVN0cmluZ1RvQnl0ZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQHBhcmFtIHVuaWNvZGVEYXRhIGJhc2U2NCBzdHJpbmcgb2YgYnl0ZSBhcnJheS5cbiAgICogWzE2Yml0IFVuaWNvZGVdLFsxNmJpdCBCeXRlc10sIC4uLlxuICAgKiBAcGFyYW0gbnVtQ2hhcnNcbiAgICovXG4gIHFyY29kZS5jcmVhdGVTdHJpbmdUb0J5dGVzID0gZnVuY3Rpb24odW5pY29kZURhdGEsIG51bUNoYXJzKSB7XG5cbiAgICAvLyBjcmVhdGUgY29udmVyc2lvbiBtYXAuXG5cbiAgICB2YXIgdW5pY29kZU1hcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYmluID0gYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0odW5pY29kZURhdGEpO1xuICAgICAgdmFyIHJlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGIgPSBiaW4ucmVhZCgpO1xuICAgICAgICBpZiAoYiA9PSAtMSkgdGhyb3cgJ2VvZic7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHZhciB1bmljb2RlTWFwID0ge307XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgYjAgPSBiaW4ucmVhZCgpO1xuICAgICAgICBpZiAoYjAgPT0gLTEpIGJyZWFrO1xuICAgICAgICB2YXIgYjEgPSByZWFkKCk7XG4gICAgICAgIHZhciBiMiA9IHJlYWQoKTtcbiAgICAgICAgdmFyIGIzID0gcmVhZCgpO1xuICAgICAgICB2YXIgayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoIChiMCA8PCA4KSB8IGIxKTtcbiAgICAgICAgdmFyIHYgPSAoYjIgPDwgOCkgfCBiMztcbiAgICAgICAgdW5pY29kZU1hcFtrXSA9IHY7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgIT0gbnVtQ2hhcnMpIHtcbiAgICAgICAgdGhyb3cgY291bnQgKyAnICE9ICcgKyBudW1DaGFycztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuaWNvZGVNYXA7XG4gICAgfSgpO1xuXG4gICAgdmFyIHVua25vd25DaGFyID0gJz8nLmNoYXJDb2RlQXQoMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgYnl0ZXMucHVzaChjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYiA9IHVuaWNvZGVNYXBbcy5jaGFyQXQoaSldO1xuICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKCAoYiAmIDB4ZmYpID09IGIpIHtcbiAgICAgICAgICAgICAgLy8gMWJ5dGVcbiAgICAgICAgICAgICAgYnl0ZXMucHVzaChiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIDJieXRlc1xuICAgICAgICAgICAgICBieXRlcy5wdXNoKGIgPj4+IDgpO1xuICAgICAgICAgICAgICBieXRlcy5wdXNoKGIgJiAweGZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCh1bmtub3duQ2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUk1vZGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgUVJNb2RlID0ge1xuICAgIE1PREVfTlVNQkVSIDogICAgMSA8PCAwLFxuICAgIE1PREVfQUxQSEFfTlVNIDogMSA8PCAxLFxuICAgIE1PREVfOEJJVF9CWVRFIDogMSA8PCAyLFxuICAgIE1PREVfS0FOSkkgOiAgICAgMSA8PCAzXG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUVJFcnJvckNvcnJlY3Rpb25MZXZlbFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUkVycm9yQ29ycmVjdGlvbkxldmVsID0ge1xuICAgIEwgOiAxLFxuICAgIE0gOiAwLFxuICAgIFEgOiAzLFxuICAgIEggOiAyXG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUVJNYXNrUGF0dGVyblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUk1hc2tQYXR0ZXJuID0ge1xuICAgIFBBVFRFUk4wMDAgOiAwLFxuICAgIFBBVFRFUk4wMDEgOiAxLFxuICAgIFBBVFRFUk4wMTAgOiAyLFxuICAgIFBBVFRFUk4wMTEgOiAzLFxuICAgIFBBVFRFUk4xMDAgOiA0LFxuICAgIFBBVFRFUk4xMDEgOiA1LFxuICAgIFBBVFRFUk4xMTAgOiA2LFxuICAgIFBBVFRFUk4xMTEgOiA3XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUVJVdGlsXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSVXRpbCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIFBBVFRFUk5fUE9TSVRJT05fVEFCTEUgPSBbXG4gICAgICBbXSxcbiAgICAgIFs2LCAxOF0sXG4gICAgICBbNiwgMjJdLFxuICAgICAgWzYsIDI2XSxcbiAgICAgIFs2LCAzMF0sXG4gICAgICBbNiwgMzRdLFxuICAgICAgWzYsIDIyLCAzOF0sXG4gICAgICBbNiwgMjQsIDQyXSxcbiAgICAgIFs2LCAyNiwgNDZdLFxuICAgICAgWzYsIDI4LCA1MF0sXG4gICAgICBbNiwgMzAsIDU0XSxcbiAgICAgIFs2LCAzMiwgNThdLFxuICAgICAgWzYsIDM0LCA2Ml0sXG4gICAgICBbNiwgMjYsIDQ2LCA2Nl0sXG4gICAgICBbNiwgMjYsIDQ4LCA3MF0sXG4gICAgICBbNiwgMjYsIDUwLCA3NF0sXG4gICAgICBbNiwgMzAsIDU0LCA3OF0sXG4gICAgICBbNiwgMzAsIDU2LCA4Ml0sXG4gICAgICBbNiwgMzAsIDU4LCA4Nl0sXG4gICAgICBbNiwgMzQsIDYyLCA5MF0sXG4gICAgICBbNiwgMjgsIDUwLCA3MiwgOTRdLFxuICAgICAgWzYsIDI2LCA1MCwgNzQsIDk4XSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDJdLFxuICAgICAgWzYsIDI4LCA1NCwgODAsIDEwNl0sXG4gICAgICBbNiwgMzIsIDU4LCA4NCwgMTEwXSxcbiAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTRdLFxuICAgICAgWzYsIDM0LCA2MiwgOTAsIDExOF0sXG4gICAgICBbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0sXG4gICAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjZdLFxuICAgICAgWzYsIDI2LCA1MiwgNzgsIDEwNCwgMTMwXSxcbiAgICAgIFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0sXG4gICAgICBbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdLFxuICAgICAgWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyXSxcbiAgICAgIFs2LCAzNCwgNjIsIDkwLCAxMTgsIDE0Nl0sXG4gICAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0sXG4gICAgICBbNiwgMjQsIDUwLCA3NiwgMTAyLCAxMjgsIDE1NF0sXG4gICAgICBbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0sXG4gICAgICBbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0sXG4gICAgICBbNiwgMjYsIDU0LCA4MiwgMTEwLCAxMzgsIDE2Nl0sXG4gICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF1cbiAgICBdO1xuICAgIHZhciBHMTUgPSAoMSA8PCAxMCkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgNCkgfCAoMSA8PCAyKSB8ICgxIDw8IDEpIHwgKDEgPDwgMCk7XG4gICAgdmFyIEcxOCA9ICgxIDw8IDEyKSB8ICgxIDw8IDExKSB8ICgxIDw8IDEwKSB8ICgxIDw8IDkpIHwgKDEgPDwgOCkgfCAoMSA8PCA1KSB8ICgxIDw8IDIpIHwgKDEgPDwgMCk7XG4gICAgdmFyIEcxNV9NQVNLID0gKDEgPDwgMTQpIHwgKDEgPDwgMTIpIHwgKDEgPDwgMTApIHwgKDEgPDwgNCkgfCAoMSA8PCAxKTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgdmFyIGdldEJDSERpZ2l0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGRpZ2l0ID0gMDtcbiAgICAgIHdoaWxlIChkYXRhICE9IDApIHtcbiAgICAgICAgZGlnaXQgKz0gMTtcbiAgICAgICAgZGF0YSA+Pj49IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlnaXQ7XG4gICAgfTtcblxuICAgIF90aGlzLmdldEJDSFR5cGVJbmZvID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGQgPSBkYXRhIDw8IDEwO1xuICAgICAgd2hpbGUgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE1KSA+PSAwKSB7XG4gICAgICAgIGQgXj0gKEcxNSA8PCAoZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTUpICkgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoIChkYXRhIDw8IDEwKSB8IGQpIF4gRzE1X01BU0s7XG4gICAgfTtcblxuICAgIF90aGlzLmdldEJDSFR5cGVOdW1iZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgZCA9IGRhdGEgPDwgMTI7XG4gICAgICB3aGlsZSAoZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTgpID49IDApIHtcbiAgICAgICAgZCBePSAoRzE4IDw8IChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxOCkgKSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChkYXRhIDw8IDEyKSB8IGQ7XG4gICAgfTtcblxuICAgIF90aGlzLmdldFBhdHRlcm5Qb3NpdGlvbiA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIpIHtcbiAgICAgIHJldHVybiBQQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TWFza0Z1bmN0aW9uID0gZnVuY3Rpb24obWFza1BhdHRlcm4pIHtcblxuICAgICAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuXG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMCA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoaSArIGopICUgMiA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMDEgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gaSAlIDIgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDEwIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIGogJSAzID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMSA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoaSArIGopICUgMyA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDAgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gKE1hdGguZmxvb3IoaSAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykgKSAlIDIgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAxIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIChpICogaikgJSAyICsgKGkgKiBqKSAlIDMgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTEwIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuICggKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMykgJSAyID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMSA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoIChpICogaikgJSAzICsgKGkgKyBqKSAlIDIpICUgMiA9PSAwOyB9O1xuXG4gICAgICBkZWZhdWx0IDpcbiAgICAgICAgdGhyb3cgJ2JhZCBtYXNrUGF0dGVybjonICsgbWFza1BhdHRlcm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwgPSBmdW5jdGlvbihlcnJvckNvcnJlY3RMZW5ndGgpIHtcbiAgICAgIHZhciBhID0gcXJQb2x5bm9taWFsKFsxXSwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9yQ29ycmVjdExlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGEgPSBhLm11bHRpcGx5KHFyUG9seW5vbWlhbChbMSwgUVJNYXRoLmdleHAoaSldLCAwKSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIF90aGlzLmdldExlbmd0aEluQml0cyA9IGZ1bmN0aW9uKG1vZGUsIHR5cGUpIHtcblxuICAgICAgaWYgKDEgPD0gdHlwZSAmJiB0eXBlIDwgMTApIHtcblxuICAgICAgICAvLyAxIC0gOVxuXG4gICAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSICAgIDogcmV0dXJuIDEwO1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTSA6IHJldHVybiA5O1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURSA6IHJldHVybiA4O1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJICAgICA6IHJldHVybiA4O1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICB0aHJvdyAnbW9kZTonICsgbW9kZTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPCAyNykge1xuXG4gICAgICAgIC8vIDEwIC0gMjZcblxuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUiAgICA6IHJldHVybiAxMjtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU0gOiByZXR1cm4gMTE7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFIDogcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJICAgICA6IHJldHVybiAxMDtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgJ21vZGU6JyArIG1vZGU7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICh0eXBlIDwgNDEpIHtcblxuICAgICAgICAvLyAyNyAtIDQwXG5cbiAgICAgICAgc3dpdGNoKG1vZGUpIHtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVIgICAgOiByZXR1cm4gMTQ7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNIDogcmV0dXJuIDEzO1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURSA6IHJldHVybiAxNjtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9LQU5KSSAgICAgOiByZXR1cm4gMTI7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgIHRocm93ICdtb2RlOicgKyBtb2RlO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICd0eXBlOicgKyB0eXBlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMb3N0UG9pbnQgPSBmdW5jdGlvbihxcmNvZGUpIHtcblxuICAgICAgdmFyIG1vZHVsZUNvdW50ID0gcXJjb2RlLmdldE1vZHVsZUNvdW50KCk7XG5cbiAgICAgIHZhciBsb3N0UG9pbnQgPSAwO1xuXG4gICAgICAvLyBMRVZFTDFcblxuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuXG4gICAgICAgICAgdmFyIHNhbWVDb3VudCA9IDA7XG4gICAgICAgICAgdmFyIGRhcmsgPSBxcmNvZGUuaXNEYXJrKHJvdywgY29sKTtcblxuICAgICAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSAxOyByICs9IDEpIHtcblxuICAgICAgICAgICAgaWYgKHJvdyArIHIgPCAwIHx8IG1vZHVsZUNvdW50IDw9IHJvdyArIHIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSAxOyBjICs9IDEpIHtcblxuICAgICAgICAgICAgICBpZiAoY29sICsgYyA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sICsgYykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHIgPT0gMCAmJiBjID09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkYXJrID09IHFyY29kZS5pc0Rhcmsocm93ICsgciwgY29sICsgYykgKSB7XG4gICAgICAgICAgICAgICAgc2FtZUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2FtZUNvdW50ID4gNSkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9ICgzICsgc2FtZUNvdW50IC0gNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBMRVZFTDJcblxuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSAxOyByb3cgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDE7IGNvbCArPSAxKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMSkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCArIDEpICkgY291bnQgKz0gMTtcbiAgICAgICAgICBpZiAoY291bnQgPT0gMCB8fCBjb3VudCA9PSA0KSB7XG4gICAgICAgICAgICBsb3N0UG9pbnQgKz0gMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTEVWRUwzXG5cbiAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDY7IGNvbCArPSAxKSB7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpXG4gICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMSlcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAyKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDMpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNClcbiAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyA1KVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDYpICkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9IDQwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSA2OyByb3cgKz0gMSkge1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKVxuICAgICAgICAgICAgICAmJiAhcXJjb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdyArIDIsIGNvbClcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgMywgY29sKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3cgKyA0LCBjb2wpXG4gICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdyArIDUsIGNvbClcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgNiwgY29sKSApIHtcbiAgICAgICAgICAgIGxvc3RQb2ludCArPSA0MDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTEVWRUw0XG5cbiAgICAgIHZhciBkYXJrQ291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpICkge1xuICAgICAgICAgICAgZGFya0NvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByYXRpbyA9IE1hdGguYWJzKDEwMCAqIGRhcmtDb3VudCAvIG1vZHVsZUNvdW50IC8gbW9kdWxlQ291bnQgLSA1MCkgLyA1O1xuICAgICAgbG9zdFBvaW50ICs9IHJhdGlvICogMTA7XG5cbiAgICAgIHJldHVybiBsb3N0UG9pbnQ7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSgpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSTWF0aFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUk1hdGggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBFWFBfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICB2YXIgTE9HX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbiAgICAvLyBpbml0aWFsaXplIHRhYmxlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgICBFWFBfVEFCTEVbaV0gPSAxIDw8IGk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSA4OyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgICAgIEVYUF9UQUJMRVtpXSA9IEVYUF9UQUJMRVtpIC0gNF1cbiAgICAgICAgXiBFWFBfVEFCTEVbaSAtIDVdXG4gICAgICAgIF4gRVhQX1RBQkxFW2kgLSA2XVxuICAgICAgICBeIEVYUF9UQUJMRVtpIC0gOF07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU1OyBpICs9IDEpIHtcbiAgICAgIExPR19UQUJMRVtFWFBfVEFCTEVbaV0gXSA9IGk7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5nbG9nID0gZnVuY3Rpb24obikge1xuXG4gICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgdGhyb3cgJ2dsb2coJyArIG4gKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBMT0dfVEFCTEVbbl07XG4gICAgfTtcblxuICAgIF90aGlzLmdleHAgPSBmdW5jdGlvbihuKSB7XG5cbiAgICAgIHdoaWxlIChuIDwgMCkge1xuICAgICAgICBuICs9IDI1NTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG4gPj0gMjU2KSB7XG4gICAgICAgIG4gLT0gMjU1O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRVhQX1RBQkxFW25dO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0oKTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxclBvbHlub21pYWxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBmdW5jdGlvbiBxclBvbHlub21pYWwobnVtLCBzaGlmdCkge1xuXG4gICAgaWYgKHR5cGVvZiBudW0ubGVuZ3RoID09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBudW0ubGVuZ3RoICsgJy8nICsgc2hpZnQ7XG4gICAgfVxuXG4gICAgdmFyIF9udW0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IG51bS5sZW5ndGggJiYgbnVtW29mZnNldF0gPT0gMCkge1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBfbnVtID0gbmV3IEFycmF5KG51bS5sZW5ndGggLSBvZmZzZXQgKyBzaGlmdCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGggLSBvZmZzZXQ7IGkgKz0gMSkge1xuICAgICAgICBfbnVtW2ldID0gbnVtW2kgKyBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9udW07XG4gICAgfSgpO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5nZXRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gX251bVtpbmRleF07XG4gICAgfTtcblxuICAgIF90aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9udW0ubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy5tdWx0aXBseSA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyIG51bSA9IG5ldyBBcnJheShfdGhpcy5nZXRMZW5ndGgoKSArIGUuZ2V0TGVuZ3RoKCkgLSAxKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZS5nZXRMZW5ndGgoKTsgaiArPSAxKSB7XG4gICAgICAgICAgbnVtW2kgKyBqXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdChpKSApICsgUVJNYXRoLmdsb2coZS5nZXRBdChqKSApICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHFyUG9seW5vbWlhbChudW0sIDApO1xuICAgIH07XG5cbiAgICBfdGhpcy5tb2QgPSBmdW5jdGlvbihlKSB7XG5cbiAgICAgIGlmIChfdGhpcy5nZXRMZW5ndGgoKSAtIGUuZ2V0TGVuZ3RoKCkgPCAwKSB7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHJhdGlvID0gUVJNYXRoLmdsb2coX3RoaXMuZ2V0QXQoMCkgKSAtIFFSTWF0aC5nbG9nKGUuZ2V0QXQoMCkgKTtcblxuICAgICAgdmFyIG51bSA9IG5ldyBBcnJheShfdGhpcy5nZXRMZW5ndGgoKSApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XG4gICAgICAgIG51bVtpXSA9IF90aGlzLmdldEF0KGkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUuZ2V0TGVuZ3RoKCk7IGkgKz0gMSkge1xuICAgICAgICBudW1baV0gXj0gUVJNYXRoLmdleHAoUVJNYXRoLmdsb2coZS5nZXRBdChpKSApICsgcmF0aW8pO1xuICAgICAgfVxuXG4gICAgICAvLyByZWN1cnNpdmUgY2FsbFxuICAgICAgcmV0dXJuIHFyUG9seW5vbWlhbChudW0sIDApLm1vZChlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSUlNCbG9ja1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUlJTQmxvY2sgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBSU19CTE9DS19UQUJMRSA9IFtcblxuICAgICAgLy8gTFxuICAgICAgLy8gTVxuICAgICAgLy8gUVxuICAgICAgLy8gSFxuXG4gICAgICAvLyAxXG4gICAgICBbMSwgMjYsIDE5XSxcbiAgICAgIFsxLCAyNiwgMTZdLFxuICAgICAgWzEsIDI2LCAxM10sXG4gICAgICBbMSwgMjYsIDldLFxuXG4gICAgICAvLyAyXG4gICAgICBbMSwgNDQsIDM0XSxcbiAgICAgIFsxLCA0NCwgMjhdLFxuICAgICAgWzEsIDQ0LCAyMl0sXG4gICAgICBbMSwgNDQsIDE2XSxcblxuICAgICAgLy8gM1xuICAgICAgWzEsIDcwLCA1NV0sXG4gICAgICBbMSwgNzAsIDQ0XSxcbiAgICAgIFsyLCAzNSwgMTddLFxuICAgICAgWzIsIDM1LCAxM10sXG5cbiAgICAgIC8vIDRcbiAgICAgIFsxLCAxMDAsIDgwXSxcbiAgICAgIFsyLCA1MCwgMzJdLFxuICAgICAgWzIsIDUwLCAyNF0sXG4gICAgICBbNCwgMjUsIDldLFxuXG4gICAgICAvLyA1XG4gICAgICBbMSwgMTM0LCAxMDhdLFxuICAgICAgWzIsIDY3LCA0M10sXG4gICAgICBbMiwgMzMsIDE1LCAyLCAzNCwgMTZdLFxuICAgICAgWzIsIDMzLCAxMSwgMiwgMzQsIDEyXSxcblxuICAgICAgLy8gNlxuICAgICAgWzIsIDg2LCA2OF0sXG4gICAgICBbNCwgNDMsIDI3XSxcbiAgICAgIFs0LCA0MywgMTldLFxuICAgICAgWzQsIDQzLCAxNV0sXG5cbiAgICAgIC8vIDdcbiAgICAgIFsyLCA5OCwgNzhdLFxuICAgICAgWzQsIDQ5LCAzMV0sXG4gICAgICBbMiwgMzIsIDE0LCA0LCAzMywgMTVdLFxuICAgICAgWzQsIDM5LCAxMywgMSwgNDAsIDE0XSxcblxuICAgICAgLy8gOFxuICAgICAgWzIsIDEyMSwgOTddLFxuICAgICAgWzIsIDYwLCAzOCwgMiwgNjEsIDM5XSxcbiAgICAgIFs0LCA0MCwgMTgsIDIsIDQxLCAxOV0sXG4gICAgICBbNCwgNDAsIDE0LCAyLCA0MSwgMTVdLFxuXG4gICAgICAvLyA5XG4gICAgICBbMiwgMTQ2LCAxMTZdLFxuICAgICAgWzMsIDU4LCAzNiwgMiwgNTksIDM3XSxcbiAgICAgIFs0LCAzNiwgMTYsIDQsIDM3LCAxN10sXG4gICAgICBbNCwgMzYsIDEyLCA0LCAzNywgMTNdLFxuXG4gICAgICAvLyAxMFxuICAgICAgWzIsIDg2LCA2OCwgMiwgODcsIDY5XSxcbiAgICAgIFs0LCA2OSwgNDMsIDEsIDcwLCA0NF0sXG4gICAgICBbNiwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuICAgICAgWzYsIDQzLCAxNSwgMiwgNDQsIDE2XSxcblxuICAgICAgLy8gMTFcbiAgICAgIFs0LCAxMDEsIDgxXSxcbiAgICAgIFsxLCA4MCwgNTAsIDQsIDgxLCA1MV0sXG4gICAgICBbNCwgNTAsIDIyLCA0LCA1MSwgMjNdLFxuICAgICAgWzMsIDM2LCAxMiwgOCwgMzcsIDEzXSxcblxuICAgICAgLy8gMTJcbiAgICAgIFsyLCAxMTYsIDkyLCAyLCAxMTcsIDkzXSxcbiAgICAgIFs2LCA1OCwgMzYsIDIsIDU5LCAzN10sXG4gICAgICBbNCwgNDYsIDIwLCA2LCA0NywgMjFdLFxuICAgICAgWzcsIDQyLCAxNCwgNCwgNDMsIDE1XSxcblxuICAgICAgLy8gMTNcbiAgICAgIFs0LCAxMzMsIDEwN10sXG4gICAgICBbOCwgNTksIDM3LCAxLCA2MCwgMzhdLFxuICAgICAgWzgsIDQ0LCAyMCwgNCwgNDUsIDIxXSxcbiAgICAgIFsxMiwgMzMsIDExLCA0LCAzNCwgMTJdLFxuXG4gICAgICAvLyAxNFxuICAgICAgWzMsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG4gICAgICBbNCwgNjQsIDQwLCA1LCA2NSwgNDFdLFxuICAgICAgWzExLCAzNiwgMTYsIDUsIDM3LCAxN10sXG4gICAgICBbMTEsIDM2LCAxMiwgNSwgMzcsIDEzXSxcblxuICAgICAgLy8gMTVcbiAgICAgIFs1LCAxMDksIDg3LCAxLCAxMTAsIDg4XSxcbiAgICAgIFs1LCA2NSwgNDEsIDUsIDY2LCA0Ml0sXG4gICAgICBbNSwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuICAgICAgWzExLCAzNiwgMTIsIDcsIDM3LCAxM10sXG5cbiAgICAgIC8vIDE2XG4gICAgICBbNSwgMTIyLCA5OCwgMSwgMTIzLCA5OV0sXG4gICAgICBbNywgNzMsIDQ1LCAzLCA3NCwgNDZdLFxuICAgICAgWzE1LCA0MywgMTksIDIsIDQ0LCAyMF0sXG4gICAgICBbMywgNDUsIDE1LCAxMywgNDYsIDE2XSxcblxuICAgICAgLy8gMTdcbiAgICAgIFsxLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLFxuICAgICAgWzEwLCA3NCwgNDYsIDEsIDc1LCA0N10sXG4gICAgICBbMSwgNTAsIDIyLCAxNSwgNTEsIDIzXSxcbiAgICAgIFsyLCA0MiwgMTQsIDE3LCA0MywgMTVdLFxuXG4gICAgICAvLyAxOFxuICAgICAgWzUsIDE1MCwgMTIwLCAxLCAxNTEsIDEyMV0sXG4gICAgICBbOSwgNjksIDQzLCA0LCA3MCwgNDRdLFxuICAgICAgWzE3LCA1MCwgMjIsIDEsIDUxLCAyM10sXG4gICAgICBbMiwgNDIsIDE0LCAxOSwgNDMsIDE1XSxcblxuICAgICAgLy8gMTlcbiAgICAgIFszLCAxNDEsIDExMywgNCwgMTQyLCAxMTRdLFxuICAgICAgWzMsIDcwLCA0NCwgMTEsIDcxLCA0NV0sXG4gICAgICBbMTcsIDQ3LCAyMSwgNCwgNDgsIDIyXSxcbiAgICAgIFs5LCAzOSwgMTMsIDE2LCA0MCwgMTRdLFxuXG4gICAgICAvLyAyMFxuICAgICAgWzMsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sXG4gICAgICBbMywgNjcsIDQxLCAxMywgNjgsIDQyXSxcbiAgICAgIFsxNSwgNTQsIDI0LCA1LCA1NSwgMjVdLFxuICAgICAgWzE1LCA0MywgMTUsIDEwLCA0NCwgMTZdLFxuXG4gICAgICAvLyAyMVxuICAgICAgWzQsIDE0NCwgMTE2LCA0LCAxNDUsIDExN10sXG4gICAgICBbMTcsIDY4LCA0Ml0sXG4gICAgICBbMTcsIDUwLCAyMiwgNiwgNTEsIDIzXSxcbiAgICAgIFsxOSwgNDYsIDE2LCA2LCA0NywgMTddLFxuXG4gICAgICAvLyAyMlxuICAgICAgWzIsIDEzOSwgMTExLCA3LCAxNDAsIDExMl0sXG4gICAgICBbMTcsIDc0LCA0Nl0sXG4gICAgICBbNywgNTQsIDI0LCAxNiwgNTUsIDI1XSxcbiAgICAgIFszNCwgMzcsIDEzXSxcblxuICAgICAgLy8gMjNcbiAgICAgIFs0LCAxNTEsIDEyMSwgNSwgMTUyLCAxMjJdLFxuICAgICAgWzQsIDc1LCA0NywgMTQsIDc2LCA0OF0sXG4gICAgICBbMTEsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICBbMTYsIDQ1LCAxNSwgMTQsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDI0XG4gICAgICBbNiwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcbiAgICAgIFs2LCA3MywgNDUsIDE0LCA3NCwgNDZdLFxuICAgICAgWzExLCA1NCwgMjQsIDE2LCA1NSwgMjVdLFxuICAgICAgWzMwLCA0NiwgMTYsIDIsIDQ3LCAxN10sXG5cbiAgICAgIC8vIDI1XG4gICAgICBbOCwgMTMyLCAxMDYsIDQsIDEzMywgMTA3XSxcbiAgICAgIFs4LCA3NSwgNDcsIDEzLCA3NiwgNDhdLFxuICAgICAgWzcsIDU0LCAyNCwgMjIsIDU1LCAyNV0sXG4gICAgICBbMjIsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDI2XG4gICAgICBbMTAsIDE0MiwgMTE0LCAyLCAxNDMsIDExNV0sXG4gICAgICBbMTksIDc0LCA0NiwgNCwgNzUsIDQ3XSxcbiAgICAgIFsyOCwgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgWzMzLCA0NiwgMTYsIDQsIDQ3LCAxN10sXG5cbiAgICAgIC8vIDI3XG4gICAgICBbOCwgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcbiAgICAgIFsyMiwgNzMsIDQ1LCAzLCA3NCwgNDZdLFxuICAgICAgWzgsIDUzLCAyMywgMjYsIDU0LCAyNF0sXG4gICAgICBbMTIsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDI4XG4gICAgICBbMywgMTQ3LCAxMTcsIDEwLCAxNDgsIDExOF0sXG4gICAgICBbMywgNzMsIDQ1LCAyMywgNzQsIDQ2XSxcbiAgICAgIFs0LCA1NCwgMjQsIDMxLCA1NSwgMjVdLFxuICAgICAgWzExLCA0NSwgMTUsIDMxLCA0NiwgMTZdLFxuXG4gICAgICAvLyAyOVxuICAgICAgWzcsIDE0NiwgMTE2LCA3LCAxNDcsIDExN10sXG4gICAgICBbMjEsIDczLCA0NSwgNywgNzQsIDQ2XSxcbiAgICAgIFsxLCA1MywgMjMsIDM3LCA1NCwgMjRdLFxuICAgICAgWzE5LCA0NSwgMTUsIDI2LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzMFxuICAgICAgWzUsIDE0NSwgMTE1LCAxMCwgMTQ2LCAxMTZdLFxuICAgICAgWzE5LCA3NSwgNDcsIDEwLCA3NiwgNDhdLFxuICAgICAgWzE1LCA1NCwgMjQsIDI1LCA1NSwgMjVdLFxuICAgICAgWzIzLCA0NSwgMTUsIDI1LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzMVxuICAgICAgWzEzLCAxNDUsIDExNSwgMywgMTQ2LCAxMTZdLFxuICAgICAgWzIsIDc0LCA0NiwgMjksIDc1LCA0N10sXG4gICAgICBbNDIsIDU0LCAyNCwgMSwgNTUsIDI1XSxcbiAgICAgIFsyMywgNDUsIDE1LCAyOCwgNDYsIDE2XSxcblxuICAgICAgLy8gMzJcbiAgICAgIFsxNywgMTQ1LCAxMTVdLFxuICAgICAgWzEwLCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuICAgICAgWzEwLCA1NCwgMjQsIDM1LCA1NSwgMjVdLFxuICAgICAgWzE5LCA0NSwgMTUsIDM1LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzM1xuICAgICAgWzE3LCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLFxuICAgICAgWzE0LCA3NCwgNDYsIDIxLCA3NSwgNDddLFxuICAgICAgWzI5LCA1NCwgMjQsIDE5LCA1NSwgMjVdLFxuICAgICAgWzExLCA0NSwgMTUsIDQ2LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzNFxuICAgICAgWzEzLCAxNDUsIDExNSwgNiwgMTQ2LCAxMTZdLFxuICAgICAgWzE0LCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuICAgICAgWzQ0LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG4gICAgICBbNTksIDQ2LCAxNiwgMSwgNDcsIDE3XSxcblxuICAgICAgLy8gMzVcbiAgICAgIFsxMiwgMTUxLCAxMjEsIDcsIDE1MiwgMTIyXSxcbiAgICAgIFsxMiwgNzUsIDQ3LCAyNiwgNzYsIDQ4XSxcbiAgICAgIFszOSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgIFsyMiwgNDUsIDE1LCA0MSwgNDYsIDE2XSxcblxuICAgICAgLy8gMzZcbiAgICAgIFs2LCAxNTEsIDEyMSwgMTQsIDE1MiwgMTIyXSxcbiAgICAgIFs2LCA3NSwgNDcsIDM0LCA3NiwgNDhdLFxuICAgICAgWzQ2LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuICAgICAgWzIsIDQ1LCAxNSwgNjQsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDM3XG4gICAgICBbMTcsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sXG4gICAgICBbMjksIDc0LCA0NiwgMTQsIDc1LCA0N10sXG4gICAgICBbNDksIDU0LCAyNCwgMTAsIDU1LCAyNV0sXG4gICAgICBbMjQsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDM4XG4gICAgICBbNCwgMTUyLCAxMjIsIDE4LCAxNTMsIDEyM10sXG4gICAgICBbMTMsIDc0LCA0NiwgMzIsIDc1LCA0N10sXG4gICAgICBbNDgsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICBbNDIsIDQ1LCAxNSwgMzIsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDM5XG4gICAgICBbMjAsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sXG4gICAgICBbNDAsIDc1LCA0NywgNywgNzYsIDQ4XSxcbiAgICAgIFs0MywgNTQsIDI0LCAyMiwgNTUsIDI1XSxcbiAgICAgIFsxMCwgNDUsIDE1LCA2NywgNDYsIDE2XSxcblxuICAgICAgLy8gNDBcbiAgICAgIFsxOSwgMTQ4LCAxMTgsIDYsIDE0OSwgMTE5XSxcbiAgICAgIFsxOCwgNzUsIDQ3LCAzMSwgNzYsIDQ4XSxcbiAgICAgIFszNCwgNTQsIDI0LCAzNCwgNTUsIDI1XSxcbiAgICAgIFsyMCwgNDUsIDE1LCA2MSwgNDYsIDE2XVxuICAgIF07XG5cbiAgICB2YXIgcXJSU0Jsb2NrID0gZnVuY3Rpb24odG90YWxDb3VudCwgZGF0YUNvdW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgIF90aGlzLnRvdGFsQ291bnQgPSB0b3RhbENvdW50O1xuICAgICAgX3RoaXMuZGF0YUNvdW50ID0gZGF0YUNvdW50O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIHZhciBnZXRSc0Jsb2NrVGFibGUgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuXG4gICAgICBzd2l0Y2goZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcbiAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5MIDpcbiAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMF07XG4gICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTSA6XG4gICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDFdO1xuICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLlEgOlxuICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAyXTtcbiAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5IIDpcbiAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgM107XG4gICAgICBkZWZhdWx0IDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0UlNCbG9ja3MgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuXG4gICAgICB2YXIgcnNCbG9jayA9IGdldFJzQmxvY2tUYWJsZSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG5cbiAgICAgIGlmICh0eXBlb2YgcnNCbG9jayA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyAnYmFkIHJzIGJsb2NrIEAgdHlwZU51bWJlcjonICsgdHlwZU51bWJlciArXG4gICAgICAgICAgICAnL2Vycm9yQ29ycmVjdGlvbkxldmVsOicgKyBlcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcblxuICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXG4gICAgICAgIHZhciBjb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAwXTtcbiAgICAgICAgdmFyIHRvdGFsQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMV07XG4gICAgICAgIHZhciBkYXRhQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMl07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKHFyUlNCbG9jayh0b3RhbENvdW50LCBkYXRhQ291bnQpICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSgpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyQml0QnVmZmVyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyQml0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX2J1ZmZlciA9IFtdO1xuICAgIHZhciBfbGVuZ3RoID0gMDtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2J1ZmZlcjtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgcmV0dXJuICggKF9idWZmZXJbYnVmSW5kZXhdID4+PiAoNyAtIGluZGV4ICUgOCkgKSAmIDEpID09IDE7XG4gICAgfTtcblxuICAgIF90aGlzLnB1dCA9IGZ1bmN0aW9uKG51bSwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIF90aGlzLnB1dEJpdCggKCAobnVtID4+PiAobGVuZ3RoIC0gaSAtIDEpICkgJiAxKSA9PSAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2xlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMucHV0Qml0ID0gZnVuY3Rpb24oYml0KSB7XG5cbiAgICAgIHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoX2xlbmd0aCAvIDgpO1xuICAgICAgaWYgKF9idWZmZXIubGVuZ3RoIDw9IGJ1ZkluZGV4KSB7XG4gICAgICAgIF9idWZmZXIucHVzaCgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdCkge1xuICAgICAgICBfYnVmZmVyW2J1ZkluZGV4XSB8PSAoMHg4MCA+Pj4gKF9sZW5ndGggJSA4KSApO1xuICAgICAgfVxuXG4gICAgICBfbGVuZ3RoICs9IDE7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxck51bWJlclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBxck51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFX05VTUJFUjtcbiAgICB2YXIgX2RhdGEgPSBkYXRhO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX21vZGU7XG4gICAgfTtcblxuICAgIF90aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIF9kYXRhLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcblxuICAgICAgdmFyIGRhdGEgPSBfZGF0YTtcblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSArIDIgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICBidWZmZXIucHV0KHN0clRvTnVtKGRhdGEuc3Vic3RyaW5nKGksIGkgKyAzKSApLCAxMCk7XG4gICAgICAgIGkgKz0gMztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggLSBpID09IDEpIHtcbiAgICAgICAgICBidWZmZXIucHV0KHN0clRvTnVtKGRhdGEuc3Vic3RyaW5nKGksIGkgKyAxKSApLCA0KTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCAtIGkgPT0gMikge1xuICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YS5zdWJzdHJpbmcoaSwgaSArIDIpICksIDcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdHJUb051bSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBudW0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIG51bSA9IG51bSAqIDEwICsgY2hhdFRvTnVtKHMuY2hhckF0KGkpICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH07XG5cbiAgICB2YXIgY2hhdFRvTnVtID0gZnVuY3Rpb24oYykge1xuICAgICAgaWYgKCcwJyA8PSBjICYmIGMgPD0gJzknKSB7XG4gICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cbiAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgOicgKyBjO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJBbHBoYU51bVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBxckFscGhhTnVtID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfQUxQSEFfTlVNO1xuICAgIHZhciBfZGF0YSA9IGRhdGE7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gX2RhdGEubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXG4gICAgICB2YXIgcyA9IF9kYXRhO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpICsgMSA8IHMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoXG4gICAgICAgICAgZ2V0Q29kZShzLmNoYXJBdChpKSApICogNDUgK1xuICAgICAgICAgIGdldENvZGUocy5jaGFyQXQoaSArIDEpICksIDExKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IHMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoZ2V0Q29kZShzLmNoYXJBdChpKSApLCA2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldENvZGUgPSBmdW5jdGlvbihjKSB7XG5cbiAgICAgIGlmICgnMCcgPD0gYyAmJiBjIDw9ICc5Jykge1xuICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICB9IGVsc2UgaWYgKCdBJyA8PSBjICYmIGMgPD0gJ1onKSB7XG4gICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSAnQScuY2hhckNvZGVBdCgwKSArIDEwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJyAnIDogcmV0dXJuIDM2O1xuICAgICAgICBjYXNlICckJyA6IHJldHVybiAzNztcbiAgICAgICAgY2FzZSAnJScgOiByZXR1cm4gMzg7XG4gICAgICAgIGNhc2UgJyonIDogcmV0dXJuIDM5O1xuICAgICAgICBjYXNlICcrJyA6IHJldHVybiA0MDtcbiAgICAgICAgY2FzZSAnLScgOiByZXR1cm4gNDE7XG4gICAgICAgIGNhc2UgJy4nIDogcmV0dXJuIDQyO1xuICAgICAgICBjYXNlICcvJyA6IHJldHVybiA0MztcbiAgICAgICAgY2FzZSAnOicgOiByZXR1cm4gNDQ7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgOicgKyBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcjhCaXRCeXRlXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyOEJpdEJ5dGUgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV84QklUX0JZVEU7XG4gICAgdmFyIF9kYXRhID0gZGF0YTtcbiAgICB2YXIgX2J5dGVzID0gcXJjb2RlLnN0cmluZ1RvQnl0ZXMoZGF0YSk7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gX2J5dGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2J5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoX2J5dGVzW2ldLCA4KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyS2FuamlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgcXJLYW5qaSA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFX0tBTkpJO1xuICAgIHZhciBfZGF0YSA9IGRhdGE7XG5cbiAgICB2YXIgc3RyaW5nVG9CeXRlcyA9IHFyY29kZS5zdHJpbmdUb0J5dGVzRnVuY3NbJ1NKSVMnXTtcbiAgICBpZiAoIXN0cmluZ1RvQnl0ZXMpIHtcbiAgICAgIHRocm93ICdzamlzIG5vdCBzdXBwb3J0ZWQuJztcbiAgICB9XG4gICAgIWZ1bmN0aW9uKGMsIGNvZGUpIHtcbiAgICAgIC8vIHNlbGYgdGVzdCBmb3Igc2ppcyBzdXBwb3J0LlxuICAgICAgdmFyIHRlc3QgPSBzdHJpbmdUb0J5dGVzKGMpO1xuICAgICAgaWYgKHRlc3QubGVuZ3RoICE9IDIgfHwgKCAodGVzdFswXSA8PCA4KSB8IHRlc3RbMV0pICE9IGNvZGUpIHtcbiAgICAgICAgdGhyb3cgJ3NqaXMgbm90IHN1cHBvcnRlZC4nO1xuICAgICAgfVxuICAgIH0oJ1xcdTUzY2InLCAweDk3NDYpO1xuXG4gICAgdmFyIF9ieXRlcyA9IHN0cmluZ1RvQnl0ZXMoZGF0YSk7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gfn4oX2J5dGVzLmxlbmd0aCAvIDIpO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXG4gICAgICB2YXIgZGF0YSA9IF9ieXRlcztcblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSArIDEgPCBkYXRhLmxlbmd0aCkge1xuXG4gICAgICAgIHZhciBjID0gKCAoMHhmZiAmIGRhdGFbaV0pIDw8IDgpIHwgKDB4ZmYgJiBkYXRhW2kgKyAxXSk7XG5cbiAgICAgICAgaWYgKDB4ODE0MCA8PSBjICYmIGMgPD0gMHg5RkZDKSB7XG4gICAgICAgICAgYyAtPSAweDgxNDA7XG4gICAgICAgIH0gZWxzZSBpZiAoMHhFMDQwIDw9IGMgJiYgYyA8PSAweEVCQkYpIHtcbiAgICAgICAgICBjIC09IDB4QzE0MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyAnaWxsZWdhbCBjaGFyIGF0ICcgKyAoaSArIDEpICsgJy8nICsgYztcbiAgICAgICAgfVxuXG4gICAgICAgIGMgPSAoIChjID4+PiA4KSAmIDB4ZmYpICogMHhDMCArIChjICYgMHhmZik7XG5cbiAgICAgICAgYnVmZmVyLnB1dChjLCAxMyk7XG5cbiAgICAgICAgaSArPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgYXQgJyArIChpICsgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBHSUYgU3VwcG9ydCBldGMuXG4gIC8vXG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gYnl0ZUFycmF5T3V0cHV0U3RyZWFtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGJ5dGVBcnJheU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9ieXRlcyA9IFtdO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gICAgICBfYnl0ZXMucHVzaChiICYgMHhmZik7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlU2hvcnQgPSBmdW5jdGlvbihpKSB7XG4gICAgICBfdGhpcy53cml0ZUJ5dGUoaSk7XG4gICAgICBfdGhpcy53cml0ZUJ5dGUoaSA+Pj4gOCk7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlQnl0ZXMgPSBmdW5jdGlvbihiLCBvZmYsIGxlbikge1xuICAgICAgb2ZmID0gb2ZmIHx8IDA7XG4gICAgICBsZW4gPSBsZW4gfHwgYi5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIF90aGlzLndyaXRlQnl0ZShiW2kgKyBvZmZdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVTdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgX3RoaXMud3JpdGVCeXRlKHMuY2hhckNvZGVBdChpKSApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9ieXRlcztcbiAgICB9O1xuXG4gICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICBzICs9ICdbJztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2J5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHMgKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gX2J5dGVzW2ldO1xuICAgICAgfVxuICAgICAgcyArPSAnXSc7XG4gICAgICByZXR1cm4gcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfYnVmZmVyID0gMDtcbiAgICB2YXIgX2J1ZmxlbiA9IDA7XG4gICAgdmFyIF9sZW5ndGggPSAwO1xuICAgIHZhciBfYmFzZTY0ID0gJyc7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIHZhciB3cml0ZUVuY29kZWQgPSBmdW5jdGlvbihiKSB7XG4gICAgICBfYmFzZTY0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZW5jb2RlKGIgJiAweDNmKSApO1xuICAgIH07XG5cbiAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24obikge1xuICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIC8vIGVycm9yLlxuICAgICAgfSBlbHNlIGlmIChuIDwgMjYpIHtcbiAgICAgICAgcmV0dXJuIDB4NDEgKyBuO1xuICAgICAgfSBlbHNlIGlmIChuIDwgNTIpIHtcbiAgICAgICAgcmV0dXJuIDB4NjEgKyAobiAtIDI2KTtcbiAgICAgIH0gZWxzZSBpZiAobiA8IDYyKSB7XG4gICAgICAgIHJldHVybiAweDMwICsgKG4gLSA1Mik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT0gNjIpIHtcbiAgICAgICAgcmV0dXJuIDB4MmI7XG4gICAgICB9IGVsc2UgaWYgKG4gPT0gNjMpIHtcbiAgICAgICAgcmV0dXJuIDB4MmY7XG4gICAgICB9XG4gICAgICB0aHJvdyAnbjonICsgbjtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVCeXRlID0gZnVuY3Rpb24obikge1xuXG4gICAgICBfYnVmZmVyID0gKF9idWZmZXIgPDwgOCkgfCAobiAmIDB4ZmYpO1xuICAgICAgX2J1ZmxlbiArPSA4O1xuICAgICAgX2xlbmd0aCArPSAxO1xuXG4gICAgICB3aGlsZSAoX2J1ZmxlbiA+PSA2KSB7XG4gICAgICAgIHdyaXRlRW5jb2RlZChfYnVmZmVyID4+PiAoX2J1ZmxlbiAtIDYpICk7XG4gICAgICAgIF9idWZsZW4gLT0gNjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKF9idWZsZW4gPiAwKSB7XG4gICAgICAgIHdyaXRlRW5jb2RlZChfYnVmZmVyIDw8ICg2IC0gX2J1ZmxlbikgKTtcbiAgICAgICAgX2J1ZmZlciA9IDA7XG4gICAgICAgIF9idWZsZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2xlbmd0aCAlIDMgIT0gMCkge1xuICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgIHZhciBwYWRsZW4gPSAzIC0gX2xlbmd0aCAlIDM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBfYmFzZTY0ICs9ICc9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9iYXNlNjQ7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKHN0cikge1xuXG4gICAgdmFyIF9zdHIgPSBzdHI7XG4gICAgdmFyIF9wb3MgPSAwO1xuICAgIHZhciBfYnVmZmVyID0gMDtcbiAgICB2YXIgX2J1ZmxlbiA9IDA7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLnJlYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgd2hpbGUgKF9idWZsZW4gPCA4KSB7XG5cbiAgICAgICAgaWYgKF9wb3MgPj0gX3N0ci5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoX2J1ZmxlbiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIGVuZCBvZiBmaWxlLi8nICsgX2J1ZmxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gX3N0ci5jaGFyQXQoX3Bvcyk7XG4gICAgICAgIF9wb3MgKz0gMTtcblxuICAgICAgICBpZiAoYyA9PSAnPScpIHtcbiAgICAgICAgICBfYnVmbGVuID0gMDtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5tYXRjaCgvXlxccyQvKSApIHtcbiAgICAgICAgICAvLyBpZ25vcmUgaWYgd2hpdGVzcGFjZS5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9idWZmZXIgPSAoX2J1ZmZlciA8PCA2KSB8IGRlY29kZShjLmNoYXJDb2RlQXQoMCkgKTtcbiAgICAgICAgX2J1ZmxlbiArPSA2O1xuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IChfYnVmZmVyID4+PiAoX2J1ZmxlbiAtIDgpICkgJiAweGZmO1xuICAgICAgX2J1ZmxlbiAtPSA4O1xuICAgICAgcmV0dXJuIG47XG4gICAgfTtcblxuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoMHg0MSA8PSBjICYmIGMgPD0gMHg1YSkge1xuICAgICAgICByZXR1cm4gYyAtIDB4NDE7XG4gICAgICB9IGVsc2UgaWYgKDB4NjEgPD0gYyAmJiBjIDw9IDB4N2EpIHtcbiAgICAgICAgcmV0dXJuIGMgLSAweDYxICsgMjY7XG4gICAgICB9IGVsc2UgaWYgKDB4MzAgPD0gYyAmJiBjIDw9IDB4MzkpIHtcbiAgICAgICAgcmV0dXJuIGMgLSAweDMwICsgNTI7XG4gICAgICB9IGVsc2UgaWYgKGMgPT0gMHgyYikge1xuICAgICAgICByZXR1cm4gNjI7XG4gICAgICB9IGVsc2UgaWYgKGMgPT0gMHgyZikge1xuICAgICAgICByZXR1cm4gNjM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAnYzonICsgYztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGdpZkltYWdlIChCL1cpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGdpZkltYWdlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXG4gICAgdmFyIF93aWR0aCA9IHdpZHRoO1xuICAgIHZhciBfaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHZhciBfZGF0YSA9IG5ldyBBcnJheSh3aWR0aCAqIGhlaWdodCk7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLnNldFBpeGVsID0gZnVuY3Rpb24oeCwgeSwgcGl4ZWwpIHtcbiAgICAgIF9kYXRhW3kgKiBfd2lkdGggKyB4XSA9IHBpeGVsO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKG91dCkge1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gR0lGIFNpZ25hdHVyZVxuXG4gICAgICBvdXQud3JpdGVTdHJpbmcoJ0dJRjg3YScpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2NyZWVuIERlc2NyaXB0b3JcblxuICAgICAgb3V0LndyaXRlU2hvcnQoX3dpZHRoKTtcbiAgICAgIG91dC53cml0ZVNob3J0KF9oZWlnaHQpO1xuXG4gICAgICBvdXQud3JpdGVCeXRlKDB4ODApOyAvLyAyYml0XG4gICAgICBvdXQud3JpdGVCeXRlKDApO1xuICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIEdsb2JhbCBDb2xvciBNYXBcblxuICAgICAgLy8gYmxhY2tcbiAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuICAgICAgb3V0LndyaXRlQnl0ZSgweDAwKTtcblxuICAgICAgLy8gd2hpdGVcbiAgICAgIG91dC53cml0ZUJ5dGUoMHhmZik7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4ZmYpO1xuICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIEltYWdlIERlc2NyaXB0b3JcblxuICAgICAgb3V0LndyaXRlU3RyaW5nKCcsJyk7XG4gICAgICBvdXQud3JpdGVTaG9ydCgwKTtcbiAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgb3V0LndyaXRlU2hvcnQoX3dpZHRoKTtcbiAgICAgIG91dC53cml0ZVNob3J0KF9oZWlnaHQpO1xuICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIExvY2FsIENvbG9yIE1hcFxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gUmFzdGVyIERhdGFcblxuICAgICAgdmFyIGx6d01pbkNvZGVTaXplID0gMjtcbiAgICAgIHZhciByYXN0ZXIgPSBnZXRMWldSYXN0ZXIobHp3TWluQ29kZVNpemUpO1xuXG4gICAgICBvdXQud3JpdGVCeXRlKGx6d01pbkNvZGVTaXplKTtcblxuICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgIHdoaWxlIChyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0ID4gMjU1KSB7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMjU1KTtcbiAgICAgICAgb3V0LndyaXRlQnl0ZXMocmFzdGVyLCBvZmZzZXQsIDI1NSk7XG4gICAgICAgIG9mZnNldCArPSAyNTU7XG4gICAgICB9XG5cbiAgICAgIG91dC53cml0ZUJ5dGUocmFzdGVyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICBvdXQud3JpdGVCeXRlcyhyYXN0ZXIsIG9mZnNldCwgcmFzdGVyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gR0lGIFRlcm1pbmF0b3JcbiAgICAgIG91dC53cml0ZVN0cmluZygnOycpO1xuICAgIH07XG5cbiAgICB2YXIgYml0T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24ob3V0KSB7XG5cbiAgICAgIHZhciBfb3V0ID0gb3V0O1xuICAgICAgdmFyIF9iaXRMZW5ndGggPSAwO1xuICAgICAgdmFyIF9iaXRCdWZmZXIgPSAwO1xuXG4gICAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihkYXRhLCBsZW5ndGgpIHtcblxuICAgICAgICBpZiAoIChkYXRhID4+PiBsZW5ndGgpICE9IDApIHtcbiAgICAgICAgICB0aHJvdyAnbGVuZ3RoIG92ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKF9iaXRMZW5ndGggKyBsZW5ndGggPj0gOCkge1xuICAgICAgICAgIF9vdXQud3JpdGVCeXRlKDB4ZmYgJiAoIChkYXRhIDw8IF9iaXRMZW5ndGgpIHwgX2JpdEJ1ZmZlcikgKTtcbiAgICAgICAgICBsZW5ndGggLT0gKDggLSBfYml0TGVuZ3RoKTtcbiAgICAgICAgICBkYXRhID4+Pj0gKDggLSBfYml0TGVuZ3RoKTtcbiAgICAgICAgICBfYml0QnVmZmVyID0gMDtcbiAgICAgICAgICBfYml0TGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9iaXRCdWZmZXIgPSAoZGF0YSA8PCBfYml0TGVuZ3RoKSB8IF9iaXRCdWZmZXI7XG4gICAgICAgIF9iaXRMZW5ndGggPSBfYml0TGVuZ3RoICsgbGVuZ3RoO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF9iaXRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgX291dC53cml0ZUJ5dGUoX2JpdEJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIGdldExaV1Jhc3RlciA9IGZ1bmN0aW9uKGx6d01pbkNvZGVTaXplKSB7XG5cbiAgICAgIHZhciBjbGVhckNvZGUgPSAxIDw8IGx6d01pbkNvZGVTaXplO1xuICAgICAgdmFyIGVuZENvZGUgPSAoMSA8PCBsendNaW5Db2RlU2l6ZSkgKyAxO1xuICAgICAgdmFyIGJpdExlbmd0aCA9IGx6d01pbkNvZGVTaXplICsgMTtcblxuICAgICAgLy8gU2V0dXAgTFpXVGFibGVcbiAgICAgIHZhciB0YWJsZSA9IGx6d1RhYmxlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlYXJDb2RlOyBpICs9IDEpIHtcbiAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgICAgIH1cbiAgICAgIHRhYmxlLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNsZWFyQ29kZSkgKTtcbiAgICAgIHRhYmxlLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZENvZGUpICk7XG5cbiAgICAgIHZhciBieXRlT3V0ID0gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgICB2YXIgYml0T3V0ID0gYml0T3V0cHV0U3RyZWFtKGJ5dGVPdXQpO1xuXG4gICAgICAvLyBjbGVhciBjb2RlXG4gICAgICBiaXRPdXQud3JpdGUoY2xlYXJDb2RlLCBiaXRMZW5ndGgpO1xuXG4gICAgICB2YXIgZGF0YUluZGV4ID0gMDtcblxuICAgICAgdmFyIHMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKF9kYXRhW2RhdGFJbmRleF0pO1xuICAgICAgZGF0YUluZGV4ICs9IDE7XG5cbiAgICAgIHdoaWxlIChkYXRhSW5kZXggPCBfZGF0YS5sZW5ndGgpIHtcblxuICAgICAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2RhdGFbZGF0YUluZGV4XSk7XG4gICAgICAgIGRhdGFJbmRleCArPSAxO1xuXG4gICAgICAgIGlmICh0YWJsZS5jb250YWlucyhzICsgYykgKSB7XG5cbiAgICAgICAgICBzID0gcyArIGM7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGJpdE91dC53cml0ZSh0YWJsZS5pbmRleE9mKHMpLCBiaXRMZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKHRhYmxlLnNpemUoKSA8IDB4ZmZmKSB7XG5cbiAgICAgICAgICAgIGlmICh0YWJsZS5zaXplKCkgPT0gKDEgPDwgYml0TGVuZ3RoKSApIHtcbiAgICAgICAgICAgICAgYml0TGVuZ3RoICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhYmxlLmFkZChzICsgYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcyA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYml0T3V0LndyaXRlKHRhYmxlLmluZGV4T2YocyksIGJpdExlbmd0aCk7XG5cbiAgICAgIC8vIGVuZCBjb2RlXG4gICAgICBiaXRPdXQud3JpdGUoZW5kQ29kZSwgYml0TGVuZ3RoKTtcblxuICAgICAgYml0T3V0LmZsdXNoKCk7XG5cbiAgICAgIHJldHVybiBieXRlT3V0LnRvQnl0ZUFycmF5KCk7XG4gICAgfTtcblxuICAgIHZhciBsendUYWJsZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgX21hcCA9IHt9O1xuICAgICAgdmFyIF9zaXplID0gMDtcblxuICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgIF90aGlzLmFkZCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoX3RoaXMuY29udGFpbnMoa2V5KSApIHtcbiAgICAgICAgICB0aHJvdyAnZHVwIGtleTonICsga2V5O1xuICAgICAgICB9XG4gICAgICAgIF9tYXBba2V5XSA9IF9zaXplO1xuICAgICAgICBfc2l6ZSArPSAxO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5pbmRleE9mID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfbWFwW2tleV07XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5jb250YWlucyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIF9tYXBba2V5XSAhPSAndW5kZWZpbmVkJztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIHZhciBjcmVhdGVEYXRhVVJMID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgZ2V0UGl4ZWwpIHtcbiAgICB2YXIgZ2lmID0gZ2lmSW1hZ2Uod2lkdGgsIGhlaWdodCk7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gMSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCArPSAxKSB7XG4gICAgICAgIGdpZi5zZXRQaXhlbCh4LCB5LCBnZXRQaXhlbCh4LCB5KSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiID0gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgZ2lmLndyaXRlKGIpO1xuXG4gICAgdmFyIGJhc2U2NCA9IGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSgpO1xuICAgIHZhciBieXRlcyA9IGIudG9CeXRlQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBiYXNlNjQud3JpdGVCeXRlKGJ5dGVzW2ldKTtcbiAgICB9XG4gICAgYmFzZTY0LmZsdXNoKCk7XG5cbiAgICByZXR1cm4gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCwnICsgYmFzZTY0O1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHJldHVybnMgcXJjb2RlIGZ1bmN0aW9uLlxuXG4gIHJldHVybiBxcmNvZGU7XG59KCk7XG5cbi8vIG11bHRpYnl0ZSBzdXBwb3J0XG4hZnVuY3Rpb24oKSB7XG5cbiAgcXJjb2RlLnN0cmluZ1RvQnl0ZXNGdW5jc1snVVRGLTgnXSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcbiAgICBmdW5jdGlvbiB0b1VURjhBcnJheShzdHIpIHtcbiAgICAgIHZhciB1dGY4ID0gW107XG4gICAgICBmb3IgKHZhciBpPTA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSk7XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICB1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcbiAgICAgICAgICAgICAgMHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA8IDB4ZDgwMCB8fCBjaGFyY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICB1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG4gICAgICAgICAgICAgIDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICAvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG4gICAgICAgICAgLy8gc3VidHJhY3RpbmcgMHgxMDAwMCBhbmQgc3BsaXR0aW5nIHRoZVxuICAgICAgICAgIC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG4gICAgICAgICAgY2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuICAgICAgICAgICAgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuICAgICAgICAgIHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuICAgICAgICAgICAgICAweDgwIHwgKChjaGFyY29kZT4+MTIpICYgMHgzZiksXG4gICAgICAgICAgICAgIDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRmODtcbiAgICB9XG4gICAgcmV0dXJuIHRvVVRGOEFycmF5KHMpO1xuICB9O1xuXG59KCk7XG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH1cbn0oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBxcmNvZGU7XG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpOyAvLyBxci5qcyBkb2Vzbid0IGhhbmRsZSBlcnJvciBsZXZlbCBvZiB6ZXJvIChNKSBzbyB3ZSBuZWVkIHRvIGRvIGl0IHJpZ2h0LFxuLy8gdGh1cyB0aGUgZGVlcCByZXF1aXJlLlxuXG5cbnZhciBRUkNvZGVJbXBsID0gcmVxdWlyZSgncXIuanMvbGliL1FSQ29kZScpO1xuXG52YXIgRXJyb3JDb3JyZWN0TGV2ZWwgPSByZXF1aXJlKCdxci5qcy9saWIvRXJyb3JDb3JyZWN0TGV2ZWwnKTsgLy8gVE9ETzogcHVsbCB0aGlzIG9mZiBvZiB0aGUgUVJDb2RlIGNsYXNzIHR5cGUgc28gaXQgbWF0Y2hlcy5cblxuXG4vLyBDb252ZXJ0IGZyb20gVVRGLTE2LCBmb3JjaW5nIHRoZSB1c2Ugb2YgYnl0ZS1tb2RlIGVuY29kaW5nIGluIG91ciBRUiBDb2RlLlxuLy8gVGhpcyBhbGxvd3MgdXMgdG8gZW5jb2RlIEhhbmppLCBLYW5qaSwgZW1vamksIGV0Yy4gSWRlYWxseSB3ZSdkIGRvIG1vcmVcbi8vIGRldGVjdGlvbiBhbmQgbm90IHJlc29ydCB0byBieXRlLW1vZGUgaWYgcG9zc2libGUsIGJ1dCB3ZSdyZSB0cmFkaW5nIG9mZlxuLy8gYSBzbWFsbGVyIGxpYnJhcnkgZm9yIGEgc21hbGxlciBhbW91bnQgb2YgZGF0YSB3ZSBjYW4gcG90ZW50aWFsbHkgZW5jb2RlLlxuLy8gQmFzZWQgb24gaHR0cDovL2pvbmlzYWxvbmVuLmNvbS8yMDEyL2Zyb20tdXRmLTE2LXRvLXV0Zi04LWluLWphdmFzY3JpcHQvXG5mdW5jdGlvbiBjb252ZXJ0U3RyKHN0cikge1xuICB2YXIgb3V0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChjaGFyY29kZSA8IDB4MDA4MCkge1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcmNvZGUpO1xuICAgIH0gZWxzZSBpZiAoY2hhcmNvZGUgPCAweDA4MDApIHtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCBjaGFyY29kZSA+PiA2KTtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCBjaGFyY29kZSAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgY2hhcmNvZGUgPj4gMTIpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlID4+IDYgJiAweDNmKTtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCBjaGFyY29kZSAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3Vycm9nYXRlIHBhaXIsIHNvIHdlJ2xsIHJlY29uc2l0dXRlIHRoZSBwaWVjZXMgYW5kIHdvcmtcbiAgICAgIC8vIGZyb20gdGhhdFxuICAgICAgaSsrO1xuICAgICAgY2hhcmNvZGUgPSAweDEwMDAwICsgKChjaGFyY29kZSAmIDB4M2ZmKSA8PCAxMCB8IHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzZmYpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IGNoYXJjb2RlID4+IDE4KTtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCBjaGFyY29kZSA+PiAxMiAmIDB4M2YpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlID4+IDYgJiAweDNmKTtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCBjaGFyY29kZSAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbnZhciBERUZBVUxUX1BST1BTID0ge1xuICBzaXplOiAxMjgsXG4gIGxldmVsOiAnTCcsXG4gIGJnQ29sb3I6ICcjRkZGRkZGJyxcbiAgZmdDb2xvcjogJyMwMDAwMDAnLFxuICBpbmNsdWRlTWFyZ2luOiBmYWxzZVxufTtcbnZhciBQUk9QX1RZUEVTID0gXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgPyB7XG4gIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxldmVsOiBQcm9wVHlwZXMub25lT2YoWydMJywgJ00nLCAnUScsICdIJ10pLFxuICBiZ0NvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmZ0NvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBpbmNsdWRlTWFyZ2luOiBQcm9wVHlwZXMuYm9vbCxcbiAgaW1hZ2VTZXR0aW5nczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGV4Y2F2YXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHk6IFByb3BUeXBlcy5udW1iZXJcbiAgfSlcbn0gOiB7fTtcbnZhciBNQVJHSU5fU0laRSA9IDQ7IC8vIFRoaXMgaXMgKnZlcnkqIHJvdWdoIGVzdGltYXRlIG9mIG1heCBhbW91bnQgb2YgUVJDb2RlIGFsbG93ZWQgdG8gYmUgY292ZXJlZC5cbi8vIEl0IGlzIFwid3JvbmdcIiBpbiBhIGxvdCBvZiB3YXlzIChhcmVhIGlzIGEgdGVycmlibGUgd2F5IHRvIGVzdGltYXRlLCBpdFxuLy8gcmVhbGx5IHNob3VsZCBiZSBudW1iZXIgb2YgbW9kdWxlcyBjb3ZlcmVkKSwgYnV0IGlmIGZvciBzb21lIHJlYXNvbiB3ZSBkb24ndFxuLy8gZ2V0IGFuIGV4cGxpY2l0IGhlaWdodCBvciB3aWR0aCwgSSdkIHJhdGhlciBkZWZhdWx0IHRvIHNvbWV0aGluZyB0aGFuIHRocm93LlxuXG52YXIgREVGQVVMVF9JTUdfU0NBTEUgPSAwLjE7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChtb2R1bGVzKSB7XG4gIHZhciBtYXJnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBvcHMgPSBbXTtcbiAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIHkpIHtcbiAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsLCB4KSB7XG4gICAgICBpZiAoIWNlbGwgJiYgc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTTAgMGg3djFIMHogaW5qZWN0cyB0aGUgc3BhY2Ugd2l0aCB0aGUgbW92ZSBhbmQgZHJvcHMgdGhlIGNvbW1hLFxuICAgICAgICAvLyBzYXZpbmcgYSBjaGFyIHBlciBvcGVyYXRpb25cbiAgICAgICAgb3BzLnB1c2goXCJNXCIuY29uY2F0KHN0YXJ0ICsgbWFyZ2luLCBcIiBcIikuY29uY2F0KHkgKyBtYXJnaW4sIFwiaFwiKS5jb25jYXQoeCAtIHN0YXJ0LCBcInYxSFwiKS5jb25jYXQoc3RhcnQgKyBtYXJnaW4sIFwielwiKSk7XG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBlbmQgb2Ygcm93LCBjbGVhbiB1cCBvciBza2lwXG5cblxuICAgICAgaWYgKHggPT09IHJvdy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIC8vIFdlIHdvdWxkIGhhdmUgY2xvc2VkIHRoZSBvcCBhYm92ZSBhbHJlYWR5IHNvIHRoaXMgY2FuIG9ubHkgbWVhblxuICAgICAgICAgIC8vIDIrIGxpZ2h0IG1vZHVsZXMgaW4gYSByb3cuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSnVzdCBhIHNpbmdsZSBkYXJrIG1vZHVsZS5cbiAgICAgICAgICBvcHMucHVzaChcIk1cIi5jb25jYXQoeCArIG1hcmdpbiwgXCIsXCIpLmNvbmNhdCh5ICsgbWFyZ2luLCBcIiBoMXYxSFwiKS5jb25jYXQoeCArIG1hcmdpbiwgXCJ6XCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgZmluaXNoIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgICAgb3BzLnB1c2goXCJNXCIuY29uY2F0KHN0YXJ0ICsgbWFyZ2luLCBcIixcIikuY29uY2F0KHkgKyBtYXJnaW4sIFwiIGhcIikuY29uY2F0KHggKyAxIC0gc3RhcnQsIFwidjFIXCIpLmNvbmNhdChzdGFydCArIG1hcmdpbiwgXCJ6XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNlbGwgJiYgc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSB4O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9wcy5qb2luKCcnKTtcbn0gLy8gV2UgY291bGQganVzdCBkbyB0aGlzIGluIGdlbmVyYXRlUGF0aCwgZXhjZXB0IHRoYXQgd2Ugd2FudCB0byBzdXBwb3J0XG4vLyBub24tUGF0aDJEIGNhbnZhcywgc28gd2UgbmVlZCB0byBrZWVwIGl0IGFuIGV4cGxpY2l0IHN0ZXAuXG5cblxuZnVuY3Rpb24gZXhjYXZhdGVNb2R1bGVzKG1vZHVsZXMsIGV4Y2F2YXRpb24pIHtcbiAgcmV0dXJuIG1vZHVsZXMuc2xpY2UoKS5tYXAoZnVuY3Rpb24gKHJvdywgeSkge1xuICAgIGlmICh5IDwgZXhjYXZhdGlvbi55IHx8IHkgPj0gZXhjYXZhdGlvbi55ICsgZXhjYXZhdGlvbi5oKSB7XG4gICAgICByZXR1cm4gcm93O1xuICAgIH1cblxuICAgIHJldHVybiByb3cubWFwKGZ1bmN0aW9uIChjZWxsLCB4KSB7XG4gICAgICBpZiAoeCA8IGV4Y2F2YXRpb24ueCB8fCB4ID49IGV4Y2F2YXRpb24ueCArIGV4Y2F2YXRpb24udykge1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VTZXR0aW5ncyhwcm9wcywgY2VsbHMpIHtcbiAgdmFyIGltYWdlU2V0dGluZ3MgPSBwcm9wcy5pbWFnZVNldHRpbmdzLFxuICAgICAgc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBpbmNsdWRlTWFyZ2luID0gcHJvcHMuaW5jbHVkZU1hcmdpbjtcblxuICBpZiAoaW1hZ2VTZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgdmFyIG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgdmFyIGRlZmF1bHRTaXplID0gTWF0aC5mbG9vcihzaXplICogREVGQVVMVF9JTUdfU0NBTEUpO1xuICB2YXIgc2NhbGUgPSBudW1DZWxscyAvIHNpemU7XG4gIHZhciB3ID0gKGltYWdlU2V0dGluZ3Mud2lkdGggfHwgZGVmYXVsdFNpemUpICogc2NhbGU7XG4gIHZhciBoID0gKGltYWdlU2V0dGluZ3MuaGVpZ2h0IHx8IGRlZmF1bHRTaXplKSAqIHNjYWxlO1xuICB2YXIgeCA9IGltYWdlU2V0dGluZ3MueCA9PSBudWxsID8gY2VsbHMubGVuZ3RoIC8gMiAtIHcgLyAyIDogaW1hZ2VTZXR0aW5ncy54ICogc2NhbGU7XG4gIHZhciB5ID0gaW1hZ2VTZXR0aW5ncy55ID09IG51bGwgPyBjZWxscy5sZW5ndGggLyAyIC0gaCAvIDIgOiBpbWFnZVNldHRpbmdzLnkgKiBzY2FsZTtcbiAgdmFyIGV4Y2F2YXRpb24gPSBudWxsO1xuXG4gIGlmIChpbWFnZVNldHRpbmdzLmV4Y2F2YXRlKSB7XG4gICAgdmFyIGZsb29yWCA9IE1hdGguZmxvb3IoeCk7XG4gICAgdmFyIGZsb29yWSA9IE1hdGguZmxvb3IoeSk7XG4gICAgdmFyIGNlaWxXID0gTWF0aC5jZWlsKHcgKyB4IC0gZmxvb3JYKTtcbiAgICB2YXIgY2VpbEggPSBNYXRoLmNlaWwoaCArIHkgLSBmbG9vclkpO1xuICAgIGV4Y2F2YXRpb24gPSB7XG4gICAgICB4OiBmbG9vclgsXG4gICAgICB5OiBmbG9vclksXG4gICAgICB3OiBjZWlsVyxcbiAgICAgIGg6IGNlaWxIXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIGg6IGgsXG4gICAgdzogdyxcbiAgICBleGNhdmF0aW9uOiBleGNhdmF0aW9uXG4gIH07XG59IC8vIEZvciBjYW52YXMgd2UncmUgZ29pbmcgdG8gc3dpdGNoIG91ciBkcmF3aW5nIG1vZGUgYmFzZWQgb24gd2hldGhlciBvciBub3Rcbi8vIHRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyBQYXRoMkQuIFdlIG9ubHkgbmVlZCB0aGUgY29uc3RydWN0b3IgdG8gYmVcbi8vIHN1cHBvcnRlZCwgYnV0IEVkZ2UgZG9lc24ndCBhY3R1YWxseSBzdXBwb3J0IHRoZSBwYXRoIChzdHJpbmcpIHR5cGVcbi8vIGFyZ3VtZW50LiBMdWNraWx5IGl0IGFsc28gZG9lc24ndCBzdXBwb3J0IHRoZSBhZGRQYXRoKCkgbWV0aG9kLiBXZSBjYW5cbi8vIHRyZWF0IHRoYXQgYXMgdGhlIHNhbWUgdGhpbmcuXG5cblxudmFyIFNVUFBPUlRTX1BBVEgyRCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBuZXcgUGF0aDJEKCkuYWRkUGF0aChuZXcgUGF0aDJEKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59KCk7XG5cbnZhciBRUkNvZGVDYW52YXMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhRUkNvZGVDYW52YXMsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBRUkNvZGVDYW52YXMoKSB7XG4gICAgdmFyIF9nZXRQcm90b3R5cGVPZjI7XG5cbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUVJDb2RlQ2FudmFzKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfZ2V0UHJvdG90eXBlT2YyID0gX2dldFByb3RvdHlwZU9mKFFSQ29kZUNhbnZhcykpLmNhbGwuYXBwbHkoX2dldFByb3RvdHlwZU9mMiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9jYW52YXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfaW1hZ2VcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGF0ZVwiLCB7XG4gICAgICBpbWdMb2FkZWQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlSW1hZ2VMb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW1nTG9hZGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRUkNvZGVDYW52YXMsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSW1hZ2VMb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRpbWFnZVNldHQsIF9uZXh0UHJvcHMkaW1hZ2VTZXR0aTtcblxuICAgICAgdmFyIGN1cnJlbnRTcmMgPSAoX3RoaXMkcHJvcHMkaW1hZ2VTZXR0ID0gdGhpcy5wcm9wcy5pbWFnZVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRpbWFnZVNldHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJGltYWdlU2V0dC5zcmM7XG4gICAgICB2YXIgbmV4dFNyYyA9IChfbmV4dFByb3BzJGltYWdlU2V0dGkgPSBuZXh0UHJvcHMuaW1hZ2VTZXR0aW5ncykgPT09IG51bGwgfHwgX25leHRQcm9wcyRpbWFnZVNldHRpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmV4dFByb3BzJGltYWdlU2V0dGkuc3JjO1xuXG4gICAgICBpZiAoY3VycmVudFNyYyAhPT0gbmV4dFNyYykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbWdMb2FkZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgdmFsdWUgPSBfdGhpcyRwcm9wcy52YWx1ZSxcbiAgICAgICAgICBzaXplID0gX3RoaXMkcHJvcHMuc2l6ZSxcbiAgICAgICAgICBsZXZlbCA9IF90aGlzJHByb3BzLmxldmVsLFxuICAgICAgICAgIGJnQ29sb3IgPSBfdGhpcyRwcm9wcy5iZ0NvbG9yLFxuICAgICAgICAgIGZnQ29sb3IgPSBfdGhpcyRwcm9wcy5mZ0NvbG9yLFxuICAgICAgICAgIGluY2x1ZGVNYXJnaW4gPSBfdGhpcyRwcm9wcy5pbmNsdWRlTWFyZ2luLFxuICAgICAgICAgIGltYWdlU2V0dGluZ3MgPSBfdGhpcyRwcm9wcy5pbWFnZVNldHRpbmdzOyAvLyBXZSdsbCB1c2UgdHlwZT09PS0xIHRvIGZvcmNlIFFSQ29kZSB0byBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGJlc3QgdHlwZVxuXG4gICAgICB2YXIgcXJjb2RlID0gbmV3IFFSQ29kZUltcGwoLTEsIEVycm9yQ29ycmVjdExldmVsW2xldmVsXSk7XG4gICAgICBxcmNvZGUuYWRkRGF0YShjb252ZXJ0U3RyKHZhbHVlKSk7XG4gICAgICBxcmNvZGUubWFrZSgpO1xuXG4gICAgICBpZiAodGhpcy5fY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbGxzID0gcXJjb2RlLm1vZHVsZXM7XG5cbiAgICAgICAgaWYgKGNlbGxzID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcmdpbiA9IGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fU0laRSA6IDA7XG4gICAgICAgIHZhciBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gICAgICAgIHZhciBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyA9IGdldEltYWdlU2V0dGluZ3ModGhpcy5wcm9wcywgY2VsbHMpO1xuXG4gICAgICAgIGlmIChpbWFnZVNldHRpbmdzICE9IG51bGwgJiYgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNlbGxzID0gZXhjYXZhdGVNb2R1bGVzKGNlbGxzLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gV2UncmUgZ29pbmcgdG8gc2NhbGUgdGhpcyBzbyB0aGF0IHRoZSBudW1iZXIgb2YgZHJhd2FibGUgdW5pdHNcbiAgICAgICAgLy8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIGNlbGxzLiBUaGlzIGF2b2lkcyByb3VuZGluZyBpc3N1ZXMsIGJ1dCBkb2VzXG4gICAgICAgIC8vIHJlc3VsdCBpbiBzb21lIHBvdGVudGlhbGx5IHVud2FudGVkIHNpbmdsZSBwaXhlbCBpc3N1ZXMgYmV0d2VlblxuICAgICAgICAvLyBibG9ja3MsIG9ubHkgaW4gZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBQYXRoMkQuXG5cblxuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggPSBzaXplICogcGl4ZWxSYXRpbztcbiAgICAgICAgdmFyIHNjYWxlID0gc2l6ZSAvIG51bUNlbGxzICogcGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7IC8vIERyYXcgc29saWQgYmFja2dyb3VuZCwgb25seSBwYWludCBkYXJrIG1vZHVsZXMuXG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBudW1DZWxscywgbnVtQ2VsbHMpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmdDb2xvcjtcblxuICAgICAgICBpZiAoU1VQUE9SVFNfUEFUSDJEKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogUGF0aDJEIGMndG9yIGRvZXNuJ3Qgc3VwcG9ydCBhcmdzIHlldC5cbiAgICAgICAgICBjdHguZmlsbChuZXcgUGF0aDJEKGdlbmVyYXRlUGF0aChjZWxscywgbWFyZ2luKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgcmR4KSB7XG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCwgY2R4KSB7XG4gICAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNkeCArIG1hcmdpbiwgcmR4ICsgbWFyZ2luLCAxLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbWdMb2FkZWQgJiYgdGhpcy5faW1hZ2UgJiYgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnggKyBtYXJnaW4sIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnkgKyBtYXJnaW4sIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLncsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgdmFsdWUgPSBfdGhpcyRwcm9wczIudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IF90aGlzJHByb3BzMi5zaXplLFxuICAgICAgICAgIGxldmVsID0gX3RoaXMkcHJvcHMyLmxldmVsLFxuICAgICAgICAgIGJnQ29sb3IgPSBfdGhpcyRwcm9wczIuYmdDb2xvcixcbiAgICAgICAgICBmZ0NvbG9yID0gX3RoaXMkcHJvcHMyLmZnQ29sb3IsXG4gICAgICAgICAgc3R5bGUgPSBfdGhpcyRwcm9wczIuc3R5bGUsXG4gICAgICAgICAgaW5jbHVkZU1hcmdpbiA9IF90aGlzJHByb3BzMi5pbmNsdWRlTWFyZ2luLFxuICAgICAgICAgIGltYWdlU2V0dGluZ3MgPSBfdGhpcyRwcm9wczIuaW1hZ2VTZXR0aW5ncyxcbiAgICAgICAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMiwgW1widmFsdWVcIiwgXCJzaXplXCIsIFwibGV2ZWxcIiwgXCJiZ0NvbG9yXCIsIFwiZmdDb2xvclwiLCBcInN0eWxlXCIsIFwiaW5jbHVkZU1hcmdpblwiLCBcImltYWdlU2V0dGluZ3NcIl0pO1xuXG4gICAgICB2YXIgY2FudmFzU3R5bGUgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICB3aWR0aDogc2l6ZVxuICAgICAgfSwgc3R5bGUpO1xuXG4gICAgICB2YXIgaW1nID0gbnVsbDtcbiAgICAgIHZhciBpbWdTcmMgPSBpbWFnZVNldHRpbmdzICYmIGltYWdlU2V0dGluZ3Muc3JjO1xuXG4gICAgICBpZiAoaW1hZ2VTZXR0aW5ncyAhPSBudWxsICYmIGltZ1NyYyAhPSBudWxsKSB7XG4gICAgICAgIGltZyA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgICAgIHNyYzogaW1nU3JjLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTG9hZDogdGhpcy5oYW5kbGVJbWFnZUxvYWQsXG4gICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoX3JlZikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5faW1hZ2UgPSBfcmVmO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIF9leHRlbmRzKHtcbiAgICAgICAgc3R5bGU6IGNhbnZhc1N0eWxlLFxuICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmMikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX2NhbnZhcyA9IF9yZWYyO1xuICAgICAgICB9XG4gICAgICB9LCBvdGhlclByb3BzKSksIGltZyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFFSQ29kZUNhbnZhcztcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShRUkNvZGVDYW52YXMsIFwiZGVmYXVsdFByb3BzXCIsIERFRkFVTFRfUFJPUFMpO1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUVJDb2RlQ2FudmFzLnByb3BUeXBlcyA9IFBST1BfVFlQRVM7XG59XG5cbnZhciBRUkNvZGVTVkcgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50Mikge1xuICBfaW5oZXJpdHMoUVJDb2RlU1ZHLCBfUmVhY3QkUHVyZUNvbXBvbmVudDIpO1xuXG4gIGZ1bmN0aW9uIFFSQ29kZVNWRygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUVJDb2RlU1ZHKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUVJDb2RlU1ZHKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRUkNvZGVTVkcsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzMy52YWx1ZSxcbiAgICAgICAgICBzaXplID0gX3RoaXMkcHJvcHMzLnNpemUsXG4gICAgICAgICAgbGV2ZWwgPSBfdGhpcyRwcm9wczMubGV2ZWwsXG4gICAgICAgICAgYmdDb2xvciA9IF90aGlzJHByb3BzMy5iZ0NvbG9yLFxuICAgICAgICAgIGZnQ29sb3IgPSBfdGhpcyRwcm9wczMuZmdDb2xvcixcbiAgICAgICAgICBpbmNsdWRlTWFyZ2luID0gX3RoaXMkcHJvcHMzLmluY2x1ZGVNYXJnaW4sXG4gICAgICAgICAgaW1hZ2VTZXR0aW5ncyA9IF90aGlzJHByb3BzMy5pbWFnZVNldHRpbmdzLFxuICAgICAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMzLCBbXCJ2YWx1ZVwiLCBcInNpemVcIiwgXCJsZXZlbFwiLCBcImJnQ29sb3JcIiwgXCJmZ0NvbG9yXCIsIFwiaW5jbHVkZU1hcmdpblwiLCBcImltYWdlU2V0dGluZ3NcIl0pOyAvLyBXZSdsbCB1c2UgdHlwZT09PS0xIHRvIGZvcmNlIFFSQ29kZSB0byBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGJlc3QgdHlwZVxuXG5cbiAgICAgIHZhciBxcmNvZGUgPSBuZXcgUVJDb2RlSW1wbCgtMSwgRXJyb3JDb3JyZWN0TGV2ZWxbbGV2ZWxdKTtcbiAgICAgIHFyY29kZS5hZGREYXRhKGNvbnZlcnRTdHIodmFsdWUpKTtcbiAgICAgIHFyY29kZS5tYWtlKCk7XG4gICAgICB2YXIgY2VsbHMgPSBxcmNvZGUubW9kdWxlcztcblxuICAgICAgaWYgKGNlbGxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgICAgIHZhciBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gICAgICB2YXIgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgPSBnZXRJbWFnZVNldHRpbmdzKHRoaXMucHJvcHMsIGNlbGxzKTtcbiAgICAgIHZhciBpbWFnZSA9IG51bGw7XG5cbiAgICAgIGlmIChpbWFnZVNldHRpbmdzICE9IG51bGwgJiYgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgY2VsbHMgPSBleGNhdmF0ZU1vZHVsZXMoY2VsbHMsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2UgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1hZ2VcIiwge1xuICAgICAgICAgIHhsaW5rSHJlZjogaW1hZ2VTZXR0aW5ncy5zcmMsXG4gICAgICAgICAgaGVpZ2h0OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5oLFxuICAgICAgICAgIHdpZHRoOiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy53LFxuICAgICAgICAgIHg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnggKyBtYXJnaW4sXG4gICAgICAgICAgeTogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueSArIG1hcmdpbixcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRHJhd2luZyBzdHJhdGVneTogaW5zdGVhZCBvZiBhIHJlY3QgcGVyIG1vZHVsZSwgd2UncmUgZ29pbmcgdG8gY3JlYXRlIGFcbiAgICAgIC8vIHNpbmdsZSBwYXRoIGZvciB0aGUgZGFyayBtb2R1bGVzIGFuZCBsYXllciB0aGF0IG9uIHRvcCBvZiBhIGxpZ2h0IHJlY3QsXG4gICAgICAvLyBmb3IgYSB0b3RhbCBvZiAyIERPTSBub2Rlcy4gV2UgcGF5IGEgYml0IG1vcmUgaW4gc3RyaW5nIGNvbmNhdCBidXQgdGhhdCdzXG4gICAgICAvLyB3YXkgZmFzdGVyIHRoYW4gRE9NIG9wcy5cbiAgICAgIC8vIEZvciBsZXZlbCAxLCA0NDEgbm9kZXMgLT4gMlxuICAgICAgLy8gRm9yIGxldmVsIDQwLCAzMTMyOSAtPiAyXG5cblxuICAgICAgdmFyIGZnUGF0aCA9IGdlbmVyYXRlUGF0aChjZWxscywgbWFyZ2luKTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHtcbiAgICAgICAgc2hhcGVSZW5kZXJpbmc6IFwiY3Jpc3BFZGdlc1wiLFxuICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICB2aWV3Qm94OiBcIjAgMCBcIi5jb25jYXQobnVtQ2VsbHMsIFwiIFwiKS5jb25jYXQobnVtQ2VsbHMpXG4gICAgICB9LCBvdGhlclByb3BzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICBmaWxsOiBiZ0NvbG9yLFxuICAgICAgICBkOiBcIk0wLDAgaFwiLmNvbmNhdChudW1DZWxscywgXCJ2XCIpLmNvbmNhdChudW1DZWxscywgXCJIMHpcIilcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGZpbGw6IGZnQ29sb3IsXG4gICAgICAgIGQ6IGZnUGF0aFxuICAgICAgfSksIGltYWdlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUVJDb2RlU1ZHO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KFFSQ29kZVNWRywgXCJkZWZhdWx0UHJvcHNcIiwgREVGQVVMVF9QUk9QUyk7XG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICBRUkNvZGVTVkcucHJvcFR5cGVzID0gUFJPUF9UWVBFUztcbn1cblxudmFyIFFSQ29kZSA9IGZ1bmN0aW9uIFFSQ29kZShwcm9wcykge1xuICB2YXIgcmVuZGVyQXMgPSBwcm9wcy5yZW5kZXJBcyxcbiAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcInJlbmRlckFzXCJdKTtcblxuICB2YXIgQ29tcG9uZW50ID0gcmVuZGVyQXMgPT09ICdzdmcnID8gUVJDb2RlU1ZHIDogUVJDb2RlQ2FudmFzO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG90aGVyUHJvcHMpO1xufTtcblxuUVJDb2RlLmRlZmF1bHRQcm9wcyA9IF9vYmplY3RTcHJlYWQoe1xuICByZW5kZXJBczogJ2NhbnZhcydcbn0sIERFRkFVTFRfUFJPUFMpO1xubW9kdWxlLmV4cG9ydHMgPSBRUkNvZGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIF9pbmhlcml0c0xvb3NlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZScpKTtcbnZhciBfZGVmaW5lUHJvcGVydHkgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eScpKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQoUmVhY3QpO1xuXG5mdW5jdGlvbiB3aXRoU2lkZUVmZmVjdChyZWR1Y2VQcm9wc1RvU3RhdGUsIGhhbmRsZVN0YXRlQ2hhbmdlT25DbGllbnQpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIHJlZHVjZVByb3BzVG9TdGF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZWR1Y2VQcm9wc1RvU3RhdGUgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZVN0YXRlQ2hhbmdlT25DbGllbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaGFuZGxlU3RhdGVDaGFuZ2VPbkNsaWVudCB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcChXcmFwcGVkQ29tcG9uZW50KSB7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgV3JhcHBlZENvbXBvbmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFdyYXBwZWRDb21wb25lbnQgdG8gYmUgYSBSZWFjdCBjb21wb25lbnQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1vdW50ZWRJbnN0YW5jZXMgPSBbXTtcbiAgICB2YXIgc3RhdGU7XG5cbiAgICBmdW5jdGlvbiBlbWl0Q2hhbmdlKCkge1xuICAgICAgc3RhdGUgPSByZWR1Y2VQcm9wc1RvU3RhdGUobW91bnRlZEluc3RhbmNlcy5tYXAoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcztcbiAgICAgIH0pKTtcbiAgICAgIGhhbmRsZVN0YXRlQ2hhbmdlT25DbGllbnQoc3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBTaWRlRWZmZWN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzTG9vc2UoU2lkZUVmZmVjdCwgX1B1cmVDb21wb25lbnQpO1xuXG4gICAgICBmdW5jdGlvbiBTaWRlRWZmZWN0KCkge1xuICAgICAgICByZXR1cm4gX1B1cmVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgdG8gdXNlIGRpc3BsYXlOYW1lIG9mIHdyYXBwZWQgY29tcG9uZW50XG4gICAgICBTaWRlRWZmZWN0LnBlZWsgPSBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgX3Byb3RvID0gU2lkZUVmZmVjdC5wcm90b3R5cGU7XG5cbiAgICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBtb3VudGVkSW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgICAgIGVtaXRDaGFuZ2UoKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGVtaXRDaGFuZ2UoKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgaW5kZXggPSBtb3VudGVkSW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIG1vdW50ZWRJbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgZW1pdENoYW5nZSgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHRoaXMucHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFNpZGVFZmZlY3Q7XG4gICAgfShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShTaWRlRWZmZWN0LCBcImRpc3BsYXlOYW1lXCIsIFwiU2lkZUVmZmVjdChcIiArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgXCIpXCIpO1xuXG4gICAgcmV0dXJuIFNpZGVFZmZlY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aFNpZGVFZmZlY3Q7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9iYWNrZW5kJyk7XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSZWFjdERldlRvb2xzQmFja2VuZFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSZWFjdERldlRvb2xzQmFja2VuZFwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyOCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgYWxwaGFTb3J0S2V5cyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRBbGxFbnVtZXJhYmxlS2V5czsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFdyYXBwZWREaXNwbGF5TmFtZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldERpc3BsYXlOYW1lOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0VUlEOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCB1dGZEZWNvZGVTdHJpbmcgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXRmRW5jb2RlU3RyaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJpbnRPcGVyYXRpb25zQXJyYXk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVyczsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZ2V0U2F2ZWRDb21wb25lbnRGaWx0ZXJzICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgc2V0U2F2ZWRDb21wb25lbnRGaWx0ZXJzICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhc3RCb29sOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FzdEJyb3dzZXJUaGVtZTsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZ2V0QXBwZW5kQ29tcG9uZW50U3RhY2sgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZXRCcmVha09uQ29uc29sZUVycm9ycyAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGdldEhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGdldFNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGdldERlZmF1bHRPcGVuSW5FZGl0b3JVUkwgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZXRPcGVuSW5FZGl0b3JVUkwgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBzZXBhcmF0ZURpc3BsYXlOYW1lQW5kSE9DcyAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IHNoYWxsb3dEaWZmZXJzICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEluT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVsZXRlUGF0aEluT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVuYW1lUGF0aEluT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0SW5PYmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREYXRhVHlwZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9ybWF0RGF0YUZvclByZXZpZXc7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGlzUGxhaW5PYmplY3QgKi9cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBscnVfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxydV9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxydV9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNoYXJlZF9SZWFjdFN5bWJvbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9oeWRyYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc0FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBjYWNoZWREaXNwbGF5TmFtZXMgPSBuZXcgV2Vha01hcCgpOyAvLyBPbiBsYXJnZSB0cmVlcywgZW5jb2RpbmcgdGFrZXMgc2lnbmlmaWNhbnQgdGltZS5cbi8vIFRyeSB0byByZXVzZSB0aGUgYWxyZWFkeSBlbmNvZGVkIHN0cmluZ3MuXG5cbnZhciBlbmNvZGVkU3RyaW5nQ2FjaGUgPSBuZXcgbHJ1X2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKHtcbiAgbWF4OiAxMDAwXG59KTtcbmZ1bmN0aW9uIGFscGhhU29ydEtleXMoYSwgYikge1xuICBpZiAoYS50b1N0cmluZygpID4gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYi50b1N0cmluZygpID4gYS50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBbGxFbnVtZXJhYmxlS2V5cyhvYmopIHtcbiAgdmFyIGtleXMgPSBuZXcgU2V0KCk7XG4gIHZhciBjdXJyZW50ID0gb2JqO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBjdXJyZW50S2V5cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmtleXMoY3VycmVudCkpLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhjdXJyZW50KSkpO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGN1cnJlbnQpO1xuICAgIGN1cnJlbnRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IGtleSBjYW4gYmUgYSBTeW1ib2wgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgaWYgKGRlc2NyaXB0b3JzW2tleV0uZW51bWVyYWJsZSkge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudCk7XG4gIH07XG5cbiAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgIF9sb29wKCk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn0gLy8gTWlycm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzdjMjFiZjcyYWNlNzcwOTRmZDE5MTBjYzM1MGE1NDgyODdlZjgzNTAvcGFja2FnZXMvc2hhcmVkL2dldENvbXBvbmVudE5hbWUuanMjTDI3LUwzN1xuXG5mdW5jdGlvbiBnZXRXcmFwcGVkRGlzcGxheU5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lLCBmYWxsYmFja05hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuICByZXR1cm4gZGlzcGxheU5hbWUgfHwgXCJcIi5jb25jYXQod3JhcHBlck5hbWUsIFwiKFwiKS5jb25jYXQoZ2V0RGlzcGxheU5hbWUoaW5uZXJUeXBlLCBmYWxsYmFja05hbWUpLCBcIilcIik7XG59XG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZSh0eXBlKSB7XG4gIHZhciBmYWxsYmFja05hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdBbm9ueW1vdXMnO1xuICB2YXIgbmFtZUZyb21DYWNoZSA9IGNhY2hlZERpc3BsYXlOYW1lcy5nZXQodHlwZSk7XG5cbiAgaWYgKG5hbWVGcm9tQ2FjaGUgIT0gbnVsbCkge1xuICAgIHJldHVybiBuYW1lRnJvbUNhY2hlO1xuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gZmFsbGJhY2tOYW1lOyAvLyBUaGUgZGlzcGxheU5hbWUgcHJvcGVydHkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYSBzdHJpbmcuXG4gIC8vIEl0J3Mgb25seSBzYWZlIHRvIHVzZSBmb3Igb3VyIHB1cnBvc2VzIGlmIGl0J3MgYSBzdHJpbmcuXG4gIC8vIGdpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtZGV2dG9vbHMvaXNzdWVzLzgwM1xuXG4gIGlmICh0eXBlb2YgdHlwZS5kaXNwbGF5TmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBkaXNwbGF5TmFtZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUubmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZS5uYW1lICE9PSAnJykge1xuICAgIGRpc3BsYXlOYW1lID0gdHlwZS5uYW1lO1xuICB9XG5cbiAgY2FjaGVkRGlzcGxheU5hbWVzLnNldCh0eXBlLCBkaXNwbGF5TmFtZSk7XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cbnZhciB1aWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGdldFVJRCgpIHtcbiAgcmV0dXJuICsrdWlkQ291bnRlcjtcbn1cbmZ1bmN0aW9uIHV0ZkRlY29kZVN0cmluZyhhcnJheSkge1xuICAvLyBBdm9pZCBzcHJlYWRpbmcgdGhlIGFycmF5IChlLmcuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmFycmF5KSlcbiAgLy8gRnVuY3Rpb25zIGFyZ3VtZW50cyBhcmUgZmlyc3QgcGxhY2VkIG9uIHRoZSBzdGFjayBiZWZvcmUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAvLyB3aGljaCB0aHJvd3MgYSBSYW5nZUVycm9yIGZvciBsYXJnZSBhcnJheXMuXG4gIC8vIFNlZSBnaXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMjI5M1xuICB2YXIgc3RyaW5nID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyID0gYXJyYXlbaV07XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZnVuY3Rpb24gc3Vycm9nYXRlUGFpclRvQ29kZVBvaW50KGNoYXJDb2RlMSwgY2hhckNvZGUyKSB7XG4gIHJldHVybiAoKGNoYXJDb2RlMSAmIDB4M2ZmKSA8PCAxMCkgKyAoY2hhckNvZGUyICYgMHgzZmYpICsgMHgxMDAwMDtcbn0gLy8gQ3JlZGl0IGZvciB0aGlzIGVuY29kaW5nIGFwcHJvYWNoIGdvZXMgdG8gVGltIERvd246XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODc3MzI2L2hvdy1jYW4taS10ZWxsLWlmLWEtc3RyaW5nLWNvbnRhaW5zLW11bHRpYnl0ZS1jaGFyYWN0ZXJzLWluLWphdmFzY3JpcHRcblxuXG5mdW5jdGlvbiB1dGZFbmNvZGVTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciBjYWNoZWQgPSBlbmNvZGVkU3RyaW5nQ2FjaGUuZ2V0KHN0cmluZyk7XG5cbiAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuXG4gIHZhciBlbmNvZGVkID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGNoYXJDb2RlO1xuXG4gIHdoaWxlIChpIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIGNoYXJDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7IC8vIEhhbmRsZSBtdWx0aWJ5dGUgdW5pY29kZSBjaGFyYWN0ZXJzIChsaWtlIGVtb2ppKS5cblxuICAgIGlmICgoY2hhckNvZGUgJiAweGY4MDApID09PSAweGQ4MDApIHtcbiAgICAgIGVuY29kZWQucHVzaChzdXJyb2dhdGVQYWlyVG9Db2RlUG9pbnQoY2hhckNvZGUsIHN0cmluZy5jaGFyQ29kZUF0KCsraSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RlZC5wdXNoKGNoYXJDb2RlKTtcbiAgICB9XG5cbiAgICArK2k7XG4gIH1cblxuICBlbmNvZGVkU3RyaW5nQ2FjaGUuc2V0KHN0cmluZywgZW5jb2RlZCk7XG4gIHJldHVybiBlbmNvZGVkO1xufVxuZnVuY3Rpb24gcHJpbnRPcGVyYXRpb25zQXJyYXkob3BlcmF0aW9ucykge1xuICAvLyBUaGUgZmlyc3QgdHdvIHZhbHVlcyBhcmUgYWx3YXlzIHJlbmRlcmVySUQgYW5kIHJvb3RJRFxuICB2YXIgcmVuZGVyZXJJRCA9IG9wZXJhdGlvbnNbMF07XG4gIHZhciByb290SUQgPSBvcGVyYXRpb25zWzFdO1xuICB2YXIgbG9ncyA9IFtcIm9wZXJhdGlvbnMgZm9yIHJlbmRlcmVyOlwiLmNvbmNhdChyZW5kZXJlcklELCBcIiBhbmQgcm9vdDpcIikuY29uY2F0KHJvb3RJRCldO1xuICB2YXIgaSA9IDI7IC8vIFJlYXNzZW1ibGUgdGhlIHN0cmluZyB0YWJsZS5cblxuICB2YXIgc3RyaW5nVGFibGUgPSBbbnVsbCAvLyBJRCA9IDAgY29ycmVzcG9uZHMgdG8gdGhlIG51bGwgc3RyaW5nLlxuICBdO1xuICB2YXIgc3RyaW5nVGFibGVTaXplID0gb3BlcmF0aW9uc1tpKytdO1xuICB2YXIgc3RyaW5nVGFibGVFbmQgPSBpICsgc3RyaW5nVGFibGVTaXplO1xuXG4gIHdoaWxlIChpIDwgc3RyaW5nVGFibGVFbmQpIHtcbiAgICB2YXIgbmV4dExlbmd0aCA9IG9wZXJhdGlvbnNbaSsrXTtcbiAgICB2YXIgbmV4dFN0cmluZyA9IHV0ZkRlY29kZVN0cmluZyhvcGVyYXRpb25zLnNsaWNlKGksIGkgKyBuZXh0TGVuZ3RoKSk7XG4gICAgc3RyaW5nVGFibGUucHVzaChuZXh0U3RyaW5nKTtcbiAgICBpICs9IG5leHRMZW5ndGg7XG4gIH1cblxuICB3aGlsZSAoaSA8IG9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbaV07XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgY2FzZSBfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogVFJFRV9PUEVSQVRJT05fQUREICovIFwibFwiXTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaWQgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgICB2YXIgdHlwZSA9IG9wZXJhdGlvbnNbaSArIDJdO1xuICAgICAgICAgIGkgKz0gMztcblxuICAgICAgICAgIGlmICh0eXBlID09PSBfdHlwZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBFbGVtZW50VHlwZVJvb3QgKi8gXCJtXCJdKSB7XG4gICAgICAgICAgICBsb2dzLnB1c2goXCJBZGQgbmV3IHJvb3Qgbm9kZSBcIi5jb25jYXQoX2lkKSk7XG4gICAgICAgICAgICBpKys7IC8vIGlzU3RyaWN0TW9kZUNvbXBsaWFudFxuXG4gICAgICAgICAgICBpKys7IC8vIHN1cHBvcnRzUHJvZmlsaW5nXG5cbiAgICAgICAgICAgIGkrKzsgLy8gc3VwcG9ydHNTdHJpY3RNb2RlXG5cbiAgICAgICAgICAgIGkrKzsgLy8gaGFzT3duZXJNZXRhZGF0YVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50SUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaSsrOyAvLyBvd25lcklEXG5cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZVN0cmluZ0lEID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHN0cmluZ1RhYmxlW2Rpc3BsYXlOYW1lU3RyaW5nSURdO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaSsrOyAvLyBrZXlcblxuICAgICAgICAgICAgbG9ncy5wdXNoKFwiQWRkIG5vZGUgXCIuY29uY2F0KF9pZCwgXCIgKFwiKS5jb25jYXQoZGlzcGxheU5hbWUgfHwgJ251bGwnLCBcIikgYXMgY2hpbGQgb2YgXCIpLmNvbmNhdChwYXJlbnRJRCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIFRSRUVfT1BFUkFUSU9OX1JFTU9WRSAqLyBcIm1cIl06XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVtb3ZlTGVuZ3RoID0gb3BlcmF0aW9uc1tpICsgMV07XG4gICAgICAgICAgaSArPSAyO1xuXG4gICAgICAgICAgZm9yICh2YXIgcmVtb3ZlSW5kZXggPSAwOyByZW1vdmVJbmRleCA8IHJlbW92ZUxlbmd0aDsgcmVtb3ZlSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIF9pZDIgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgbG9ncy5wdXNoKFwiUmVtb3ZlIG5vZGUgXCIuY29uY2F0KF9pZDIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCAqLyBcIm5cIl06XG4gICAgICAgIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgbG9ncy5wdXNoKFwiUmVtb3ZlIHJvb3QgXCIuY29uY2F0KHJvb3RJRCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIFRSRUVfT1BFUkFUSU9OX1NFVF9TVUJUUkVFX01PREUgKi8gXCJwXCJdOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pZDMgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgICB2YXIgbW9kZSA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBsb2dzLnB1c2goXCJNb2RlIFwiLmNvbmNhdChtb2RlLCBcIiBzZXQgZm9yIHN1YnRyZWUgd2l0aCByb290IFwiKS5jb25jYXQoX2lkMykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4gKi8gXCJvXCJdOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pZDQgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgICB2YXIgbnVtQ2hpbGRyZW4gPSBvcGVyYXRpb25zW2kgKyAyXTtcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gb3BlcmF0aW9ucy5zbGljZShpLCBpICsgbnVtQ2hpbGRyZW4pO1xuICAgICAgICAgIGkgKz0gbnVtQ2hpbGRyZW47XG4gICAgICAgICAgbG9ncy5wdXNoKFwiUmUtb3JkZXIgbm9kZSBcIi5jb25jYXQoX2lkNCwgXCIgY2hpbGRyZW4gXCIpLmNvbmNhdChjaGlsZHJlbi5qb2luKCcsJykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OICovIFwiclwiXTpcbiAgICAgICAgLy8gQmFzZSBkdXJhdGlvbiB1cGRhdGVzIGFyZSBvbmx5IHNlbnQgd2hpbGUgcHJvZmlsaW5nIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAvLyBXZSBjYW4gaWdub3JlIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgICAgICAgLy8gVGhlIHByb2ZpbGVyIFVJIHVzZXMgdGhlbSBsYXppbHkgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIHRyZWUuXG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1MgKi8gXCJxXCJdOlxuICAgICAgICB2YXIgaWQgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgdmFyIG51bUVycm9ycyA9IG9wZXJhdGlvbnNbaSArIDJdO1xuICAgICAgICB2YXIgbnVtV2FybmluZ3MgPSBvcGVyYXRpb25zW2kgKyAzXTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgICBsb2dzLnB1c2goXCJOb2RlIFwiLmNvbmNhdChpZCwgXCIgaGFzIFwiKS5jb25jYXQobnVtRXJyb3JzLCBcIiBlcnJvcnMgYW5kIFwiKS5jb25jYXQobnVtV2FybmluZ3MsIFwiIHdhcm5pbmdzXCIpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgQnJpZGdlIG9wZXJhdGlvbiBcXFwiXCIuY29uY2F0KG9wZXJhdGlvbiwgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH1cblxuICBjb25zb2xlLmxvZyhsb2dzLmpvaW4oJ1xcbiAgJykpO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMoKSB7XG4gIHJldHVybiBbe1xuICAgIHR5cGU6IF90eXBlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIENvbXBvbmVudEZpbHRlckVsZW1lbnRUeXBlICovIFwiYlwiXSxcbiAgICB2YWx1ZTogX3R5cGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50ICovIFwiaVwiXSxcbiAgICBpc0VuYWJsZWQ6IHRydWVcbiAgfV07XG59XG5mdW5jdGlvbiBnZXRTYXZlZENvbXBvbmVudEZpbHRlcnMoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJhdyA9IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGxvY2FsU3RvcmFnZUdldEl0ZW0gKi8gXCJhXCJdKShfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogTE9DQUxfU1RPUkFHRV9DT01QT05FTlRfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWSAqLyBcImFcIl0pO1xuXG4gICAgaWYgKHJhdyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgcmV0dXJuIGdldERlZmF1bHRDb21wb25lbnRGaWx0ZXJzKCk7XG59XG5mdW5jdGlvbiBzZXRTYXZlZENvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycykge1xuICBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBsb2NhbFN0b3JhZ2VTZXRJdGVtICovIFwiYlwiXSkoX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIExPQ0FMX1NUT1JBR0VfQ09NUE9ORU5UX0ZJTFRFUl9QUkVGRVJFTkNFU19LRVkgKi8gXCJhXCJdLCBKU09OLnN0cmluZ2lmeShjb21wb25lbnRGaWx0ZXJzKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9vbChzKSB7XG4gIGlmIChzID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhc3RCb29sKHYpIHtcbiAgaWYgKHYgPT09IHRydWUgfHwgdiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuZnVuY3Rpb24gY2FzdEJyb3dzZXJUaGVtZSh2KSB7XG4gIGlmICh2ID09PSAnbGlnaHQnIHx8IHYgPT09ICdkYXJrJyB8fCB2ID09PSAnYXV0bycpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXBwZW5kQ29tcG9uZW50U3RhY2soKSB7XG4gIHZhciBfcGFyc2VCb29sO1xuXG4gIHZhciByYXcgPSBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBsb2NhbFN0b3JhZ2VHZXRJdGVtICovIFwiYVwiXSkoX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIExPQ0FMX1NUT1JBR0VfU0hPVUxEX0FQUEVORF9DT01QT05FTlRfU1RBQ0tfS0VZICovIFwiZFwiXSk7XG4gIHJldHVybiAoX3BhcnNlQm9vbCA9IHBhcnNlQm9vbChyYXcpKSAhPT0gbnVsbCAmJiBfcGFyc2VCb29sICE9PSB2b2lkIDAgPyBfcGFyc2VCb29sIDogdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEJyZWFrT25Db25zb2xlRXJyb3JzKCkge1xuICB2YXIgX3BhcnNlQm9vbDI7XG5cbiAgdmFyIHJhdyA9IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGxvY2FsU3RvcmFnZUdldEl0ZW0gKi8gXCJhXCJdKShfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogTE9DQUxfU1RPUkFHRV9TSE9VTERfQlJFQUtfT05fQ09OU09MRV9FUlJPUlMgKi8gXCJlXCJdKTtcbiAgcmV0dXJuIChfcGFyc2VCb29sMiA9IHBhcnNlQm9vbChyYXcpKSAhPT0gbnVsbCAmJiBfcGFyc2VCb29sMiAhPT0gdm9pZCAwID8gX3BhcnNlQm9vbDIgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSgpIHtcbiAgdmFyIF9wYXJzZUJvb2wzO1xuXG4gIHZhciByYXcgPSBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBsb2NhbFN0b3JhZ2VHZXRJdGVtICovIFwiYVwiXSkoX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIExPQ0FMX1NUT1JBR0VfSElERV9DT05TT0xFX0xPR1NfSU5fU1RSSUNUX01PREUgKi8gXCJiXCJdKTtcbiAgcmV0dXJuIChfcGFyc2VCb29sMyA9IHBhcnNlQm9vbChyYXcpKSAhPT0gbnVsbCAmJiBfcGFyc2VCb29sMyAhPT0gdm9pZCAwID8gX3BhcnNlQm9vbDMgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycygpIHtcbiAgdmFyIF9wYXJzZUJvb2w0O1xuXG4gIHZhciByYXcgPSBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBsb2NhbFN0b3JhZ2VHZXRJdGVtICovIFwiYVwiXSkoX2NvbnN0YW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIExPQ0FMX1NUT1JBR0VfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19LRVkgKi8gXCJmXCJdKTtcbiAgcmV0dXJuIChfcGFyc2VCb29sNCA9IHBhcnNlQm9vbChyYXcpKSAhPT0gbnVsbCAmJiBfcGFyc2VCb29sNCAhPT0gdm9pZCAwID8gX3BhcnNlQm9vbDQgOiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdE9wZW5JbkVkaXRvclVSTCgpIHtcbiAgcmV0dXJuIHR5cGVvZiBcIlwiID09PSAnc3RyaW5nJyA/IFwiXCIgOiAnJztcbn1cbmZ1bmN0aW9uIGdldE9wZW5JbkVkaXRvclVSTCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcmF3ID0gT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogbG9jYWxTdG9yYWdlR2V0SXRlbSAqLyBcImFcIl0pKF9jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBMT0NBTF9TVE9SQUdFX09QRU5fSU5fRURJVE9SX1VSTCAqLyBcImNcIl0pO1xuXG4gICAgaWYgKHJhdyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgcmV0dXJuIGdldERlZmF1bHRPcGVuSW5FZGl0b3JVUkwoKTtcbn1cbmZ1bmN0aW9uIHNlcGFyYXRlRGlzcGxheU5hbWVBbmRIT0NzKGRpc3BsYXlOYW1lLCB0eXBlKSB7XG4gIGlmIChkaXNwbGF5TmFtZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICB2YXIgaG9jRGlzcGxheU5hbWVzID0gbnVsbDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIF90eXBlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIEVsZW1lbnRUeXBlQ2xhc3MgKi8gXCJlXCJdOlxuICAgIGNhc2UgX3R5cGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogRWxlbWVudFR5cGVGb3J3YXJkUmVmICovIFwiZ1wiXTpcbiAgICBjYXNlIF90eXBlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi8gXCJoXCJdOlxuICAgIGNhc2UgX3R5cGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogRWxlbWVudFR5cGVNZW1vICovIFwialwiXTpcbiAgICAgIGlmIChkaXNwbGF5TmFtZS5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGRpc3BsYXlOYW1lLm1hdGNoKC9bXigpXSsvZyk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGRpc3BsYXlOYW1lID0gbWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgICBob2NEaXNwbGF5TmFtZXMgPSBtYXRjaGVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFtkaXNwbGF5TmFtZSwgaG9jRGlzcGxheU5hbWVzXTtcbn0gLy8gUHVsbGVkIGZyb20gcmVhY3QtY29tcGF0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC1jb21wYXQvYmxvYi83YzVkZTAwZTdjODVlMmZmZDAxMWJmM2FmMDI4OTliNjNmNjk5ZDNhL3NyYy9pbmRleC5qcyNMMzQ5XG5cbmZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKHByZXYsIG5leHQpIHtcbiAgZm9yICh2YXIgYXR0cmlidXRlIGluIHByZXYpIHtcbiAgICBpZiAoIShhdHRyaWJ1dGUgaW4gbmV4dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9hdHRyaWJ1dGUgaW4gbmV4dCkge1xuICAgIGlmIChwcmV2W19hdHRyaWJ1dGVdICE9PSBuZXh0W19hdHRyaWJ1dGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRJbk9iamVjdChvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChyZWR1Y2VkLCBhdHRyKSB7XG4gICAgaWYgKHJlZHVjZWQpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZHVjZWQsIGF0dHIpKSB7XG4gICAgICAgIHJldHVybiByZWR1Y2VkW2F0dHJdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlZHVjZWRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDb252ZXJ0IGl0ZXJhYmxlIHRvIGFycmF5IGFuZCByZXR1cm4gYXJyYXlbaW5kZXhdXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRSSUNLWVxuICAgICAgICAvLyBEb24ndCB1c2UgWy4uLnNwcmVhZF0gc3ludGF4IGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIC8vIFRoaXMgcHJvamVjdCB1c2VzIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXNwcmVhZCBpbiBcImxvb3NlXCIgbW9kZSB3aGljaCBvbmx5IHdvcmtzIHdpdGggQXJyYXkgdmFsdWVzLlxuICAgICAgICAvLyBPdGhlciB0eXBlcyAoZS5nLiB0eXBlZCBhcnJheXMsIFNldHMpIHdpbGwgbm90IHNwcmVhZCBjb3JyZWN0bHkuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJlZHVjZWQpW2F0dHJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LCBvYmplY3QpO1xufVxuZnVuY3Rpb24gZGVsZXRlUGF0aEluT2JqZWN0KG9iamVjdCwgcGF0aCkge1xuICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gIHZhciBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcblxuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICB2YXIgcGFyZW50ID0gZ2V0SW5PYmplY3Qob2JqZWN0LCBwYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChPYmplY3QoX2lzQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuc3BsaWNlKGxhc3QsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHBhcmVudFtsYXN0XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmFtZVBhdGhJbk9iamVjdChvYmplY3QsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgdmFyIGxlbmd0aCA9IG9sZFBhdGgubGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIG9sZFBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdmFyIGxhc3RPbGQgPSBvbGRQYXRoW2xlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROZXcgPSBuZXdQYXRoW2xlbmd0aCAtIDFdO1xuICAgICAgcGFyZW50W2xhc3ROZXddID0gcGFyZW50W2xhc3RPbGRdO1xuXG4gICAgICBpZiAoT2JqZWN0KF9pc0FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LnNwbGljZShsYXN0T2xkLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBwYXJlbnRbbGFzdE9sZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJbk9iamVjdChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgdmFyIGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuXG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50W2xhc3RdID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgZW5oYW5jZWQvYXJ0aWZpY2lhbCB0eXBlIHN0cmluZyBiYXNlZCBvbiB0aGUgb2JqZWN0IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERhdGFUeXBlKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmIChPYmplY3QocmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImlzRWxlbWVudFwiXSkoZGF0YSkpIHtcbiAgICByZXR1cm4gJ3JlYWN0X2VsZW1lbnQnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuICdodG1sX2VsZW1lbnQnO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdHlwZW9mKGRhdGEpO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICByZXR1cm4gJ2JpZ2ludCc7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAnYm9vbGVhbic7XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnbmFuJztcbiAgICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ2luZmluaXR5JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIH1cblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoT2JqZWN0KF9pc0FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YS5jb25zdHJ1Y3RvciwgJ0JZVEVTX1BFUl9FTEVNRU5UJykgPyAndHlwZWRfYXJyYXknIDogJ2RhdGFfdmlldyc7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgJiYgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInKSB7XG4gICAgICAgIC8vIEhBQ0sgVGhpcyBBcnJheUJ1ZmZlciBjaGVjayBpcyBncm9zczsgaXMgdGhlcmUgYSBiZXR0ZXIgd2F5P1xuICAgICAgICAvLyBXZSBjb3VsZCB0cnkgdG8gY3JlYXRlIGEgbmV3IERhdGFWaWV3IHdpdGggdGhlIHZhbHVlLlxuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IGVycm9yLCB3ZSBrbm93IGl0J3MgYW4gQXJyYXlCdWZmZXIsXG4gICAgICAgIC8vIGJ1dCB0aGlzIHNlZW1zIGtpbmQgb2YgYXdrd2FyZCBhbmQgZXhwZW5zaXZlLlxuICAgICAgICByZXR1cm4gJ2FycmF5X2J1ZmZlcic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG5cbiAgICAgICAgaWYgKCFpdGVyYXRvcikgey8vIFByb3hpZXMgbWlnaHQgYnJlYWsgYXNzdW1wdG9pbnMgYWJvdXQgaXRlcmF0b3JzLlxuICAgICAgICAgIC8vIFNlZSBnaXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMTY1NFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvciA9PT0gZGF0YSA/ICdvcGFxdWVfaXRlcmF0b3InIDogJ2l0ZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLmNvbnN0cnVjdG9yICYmIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICB2YXIgdG9TdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKTtcblxuICAgICAgICBpZiAodG9TdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZ1ZhbHVlID09PSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nKSB7XG4gICAgICAgICAgcmV0dXJuICdodG1sX2FsbF9jb2xsZWN0aW9uJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdjbGFzc19pbnN0YW5jZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGlmICggLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nKSB7XG4gICAgICAgIHJldHVybiAnaHRtbF9hbGxfY29sbGVjdGlvbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xuICB9XG59XG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHZhciBlbGVtZW50VHlwZSA9IE9iamVjdChyZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1widHlwZU9mXCJdKShlbGVtZW50KTtcblxuICBzd2l0Y2ggKGVsZW1lbnRUeXBlKSB7XG4gICAgY2FzZSByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ29udGV4dENvbnN1bWVyXCJdOlxuICAgICAgcmV0dXJuICdDb250ZXh0Q29uc3VtZXInO1xuXG4gICAgY2FzZSByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ29udGV4dFByb3ZpZGVyXCJdOlxuICAgICAgcmV0dXJuICdDb250ZXh0UHJvdmlkZXInO1xuXG4gICAgY2FzZSByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm9yd2FyZFJlZlwiXTpcbiAgICAgIHJldHVybiAnRm9yd2FyZFJlZic7XG5cbiAgICBjYXNlIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJGcmFnbWVudFwiXTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSByZWFjdF9pc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiTGF6eVwiXTpcbiAgICAgIHJldHVybiAnTGF6eSc7XG5cbiAgICBjYXNlIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJNZW1vXCJdOlxuICAgICAgcmV0dXJuICdNZW1vJztcblxuICAgIGNhc2UgcmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlBvcnRhbFwiXTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgcmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlByb2ZpbGVyXCJdOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIHJlYWN0X2lzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdHJpY3RNb2RlXCJdOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgcmVhY3RfaXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN1c3BlbnNlXCJdOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIHNoYXJlZF9SZWFjdFN5bWJvbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgKi8gXCJhXCJdOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBzaGFyZWRfUmVhY3RTeW1ib2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSAqLyBcImJcIl06XG4gICAgICByZXR1cm4gJ1RyYWNpbmdNYXJrZXInO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUodHlwZSwgJ0Fub255bW91cycpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdOb3RJbXBsZW1lbnRlZEluRGV2dG9vbHMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdFbGVtZW50JztcbiAgICAgIH1cblxuICB9XG59XG52YXIgTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCA9IDUwO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZUZvckRpc3BsYXkoc3RyaW5nKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE1BWF9QUkVWSUVXX1NUUklOR19MRU5HVEg7XG5cbiAgaWYgKHN0cmluZy5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxlbmd0aCkgKyAn4oCmJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59IC8vIEF0dGVtcHRzIHRvIG1pbWljIENocm9tZSdzIGlubGluZSBwcmV2aWV3IGZvciB2YWx1ZXMuXG4vLyBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB2YWx1ZS4uLlxuLy8gICB7XG4vLyAgICAgIGZvbzogMTIzLFxuLy8gICAgICBiYXI6IFwiYWJjXCIsXG4vLyAgICAgIGJhejogW3RydWUsIGZhbHNlXSxcbi8vICAgICAgcXV4OiB7IGFiOiAxLCBjZDogMiB9XG4vLyAgIH07XG4vL1xuLy8gV291bGQgc2hvdyBhIHByZXZpZXcgb2YuLi5cbi8vICAge2ZvbzogMTIzLCBiYXI6IFwiYWJjXCIsIGJhejogQXJyYXkoMiksIHF1eDoge+KApn19XG4vL1xuLy8gQW5kIHRoZSBmb2xsb3dpbmcgdmFsdWUuLi5cbi8vICAgW1xuLy8gICAgIDEyMyxcbi8vICAgICBcImFiY1wiLFxuLy8gICAgIFt0cnVlLCBmYWxzZV0sXG4vLyAgICAgeyBmb286IDEyMywgYmFyOiBcImFiY1wiIH1cbi8vICAgXTtcbi8vXG4vLyBXb3VsZCBzaG93IGEgcHJldmlldyBvZi4uLlxuLy8gICBbMTIzLCBcImFiY1wiLCBBcnJheSgyKSwge+KApn1dXG5cblxuZnVuY3Rpb24gZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gIGlmIChkYXRhICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBfaHlkcmF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogbWV0YSAqLyBcImJcIl0udHlwZSkpIHtcbiAgICByZXR1cm4gc2hvd0Zvcm1hdHRlZFZhbHVlID8gZGF0YVtfaHlkcmF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogbWV0YSAqLyBcImJcIl0ucHJldmlld19sb25nXSA6IGRhdGFbX2h5ZHJhdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIG1ldGEgKi8gXCJiXCJdLnByZXZpZXdfc2hvcnRdO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBnZXREYXRhVHlwZShkYXRhKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdodG1sX2VsZW1lbnQnOlxuICAgICAgcmV0dXJuIFwiPFwiLmNvbmNhdCh0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpLCBcIiAvPlwiKTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoXCJcXHUwMTkyIFwiLmNvbmNhdCh0eXBlb2YgZGF0YS5uYW1lID09PSAnZnVuY3Rpb24nID8gJycgOiBkYXRhLm5hbWUsIFwiKCkge31cIikpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoZGF0YSwgXCJcXFwiXCIpO1xuXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50b1N0cmluZygpICsgJ24nKTtcblxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KGRhdGEudG9TdHJpbmcoKSk7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShkYXRhLnRvU3RyaW5nKCkpO1xuXG4gICAgY2FzZSAncmVhY3RfZWxlbWVudCc6XG4gICAgICByZXR1cm4gXCI8XCIuY29uY2F0KHRydW5jYXRlRm9yRGlzcGxheShnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudChkYXRhKSB8fCAnVW5rbm93bicpLCBcIiAvPlwiKTtcblxuICAgIGNhc2UgJ2FycmF5X2J1ZmZlcic6XG4gICAgICByZXR1cm4gXCJBcnJheUJ1ZmZlcihcIi5jb25jYXQoZGF0YS5ieXRlTGVuZ3RoLCBcIilcIik7XG5cbiAgICBjYXNlICdkYXRhX3ZpZXcnOlxuICAgICAgcmV0dXJuIFwiRGF0YVZpZXcoXCIuY29uY2F0KGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGgsIFwiKVwiKTtcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9ybWF0dGVkICs9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGFbaV0sIGZhbHNlKTtcblxuICAgICAgICAgIGlmIChmb3JtYXR0ZWQubGVuZ3RoID4gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkb2luZyBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBpdGVyYXRpb24uLi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIltcIi5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KGZvcm1hdHRlZCksIFwiXVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIF9oeWRyYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBtZXRhICovIFwiYlwiXS5zaXplKSA/IGRhdGFbX2h5ZHJhdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIG1ldGEgKi8gXCJiXCJdLnNpemVdIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBcIkFycmF5KFwiLmNvbmNhdChsZW5ndGgsIFwiKVwiKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3R5cGVkX2FycmF5JzpcbiAgICAgIHZhciBzaG9ydE5hbWUgPSBcIlwiLmNvbmNhdChkYXRhLmNvbnN0cnVjdG9yLm5hbWUsIFwiKFwiKS5jb25jYXQoZGF0YS5sZW5ndGgsIFwiKVwiKTtcblxuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICB2YXIgX2Zvcm1hdHRlZCA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkYXRhLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGlmIChfaSA+IDApIHtcbiAgICAgICAgICAgIF9mb3JtYXR0ZWQgKz0gJywgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZm9ybWF0dGVkICs9IGRhdGFbX2ldO1xuXG4gICAgICAgICAgaWYgKF9mb3JtYXR0ZWQubGVuZ3RoID4gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkb2luZyBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBpdGVyYXRpb24uLi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzaG9ydE5hbWUsIFwiIFtcIikuY29uY2F0KHRydW5jYXRlRm9yRGlzcGxheShfZm9ybWF0dGVkKSwgXCJdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNob3J0TmFtZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2l0ZXJhdG9yJzpcbiAgICAgIHZhciBuYW1lID0gZGF0YS5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIC8vIFRSSUNLWVxuICAgICAgICAvLyBEb24ndCB1c2UgWy4uLnNwcmVhZF0gc3ludGF4IGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIC8vIFRoaXMgcHJvamVjdCB1c2VzIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXNwcmVhZCBpbiBcImxvb3NlXCIgbW9kZSB3aGljaCBvbmx5IHdvcmtzIHdpdGggQXJyYXkgdmFsdWVzLlxuICAgICAgICAvLyBPdGhlciB0eXBlcyAoZS5nLiB0eXBlZCBhcnJheXMsIFNldHMpIHdpbGwgbm90IHNwcmVhZCBjb3JyZWN0bHkuXG4gICAgICAgIHZhciBhcnJheSA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgICAgIHZhciBfZm9ybWF0dGVkMiA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGFycmF5Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgZW50cnlPckVudHJpZXMgPSBhcnJheVtfaTJdO1xuXG4gICAgICAgICAgaWYgKF9pMiA+IDApIHtcbiAgICAgICAgICAgIF9mb3JtYXR0ZWQyICs9ICcsICc7XG4gICAgICAgICAgfSAvLyBUUklDS1lcbiAgICAgICAgICAvLyBCcm93c2VycyBkaXNwbGF5IE1hcHMgYW5kIFNldHMgZGlmZmVyZW50bHkuXG4gICAgICAgICAgLy8gVG8gbWltaWMgdGhlaXIgYmVoYXZpb3IsIGRldGVjdCBpZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIGVudHJpZXMgdHVwbGUuXG4gICAgICAgICAgLy8gICBNYXAoMikge1wiYWJjXCIgPT4gMTIzLCBcImRlZlwiID0+IDEyM31cbiAgICAgICAgICAvLyAgIFNldCgyKSB7XCJhYmNcIiwgMTIzfVxuXG5cbiAgICAgICAgICBpZiAoT2JqZWN0KF9pc0FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGVudHJ5T3JFbnRyaWVzKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzWzFdLCBmYWxzZSk7XG4gICAgICAgICAgICBfZm9ybWF0dGVkMiArPSBcIlwiLmNvbmNhdChrZXksIFwiID0+IFwiKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfZm9ybWF0dGVkMiArPSBmb3JtYXREYXRhRm9yUHJldmlldyhlbnRyeU9yRW50cmllcywgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfZm9ybWF0dGVkMi5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG5hbWUsIFwiKFwiKS5jb25jYXQoZGF0YS5zaXplLCBcIikge1wiKS5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KF9mb3JtYXR0ZWQyKSwgXCJ9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG5hbWUsIFwiKFwiKS5jb25jYXQoZGF0YS5zaXplLCBcIilcIik7XG4gICAgICB9XG5cbiAgICBjYXNlICdvcGFxdWVfaXRlcmF0b3InOlxuICAgICAge1xuICAgICAgICByZXR1cm4gZGF0YVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuXG4gICAgY2FzZSAnY2xhc3NfaW5zdGFuY2UnOlxuICAgICAgcmV0dXJuIGRhdGEuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIHZhciBrZXlzID0gQXJyYXkuZnJvbShnZXRBbGxFbnVtZXJhYmxlS2V5cyhkYXRhKSkuc29ydChhbHBoYVNvcnRLZXlzKTtcbiAgICAgICAgdmFyIF9mb3JtYXR0ZWQzID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwga2V5cy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9rZXkgPSBrZXlzW19pM107XG5cbiAgICAgICAgICBpZiAoX2kzID4gMCkge1xuICAgICAgICAgICAgX2Zvcm1hdHRlZDMgKz0gJywgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZm9ybWF0dGVkMyArPSBcIlwiLmNvbmNhdChfa2V5LnRvU3RyaW5nKCksIFwiOiBcIikuY29uY2F0KGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGFbX2tleV0sIGZhbHNlKSk7XG5cbiAgICAgICAgICBpZiAoX2Zvcm1hdHRlZDMubGVuZ3RoID4gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkb2luZyBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBpdGVyYXRpb24uLi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIntcIi5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KF9mb3JtYXR0ZWQzKSwgXCJ9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICd74oCmfSc7XG4gICAgICB9XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ2luZmluaXR5JzpcbiAgICBjYXNlICduYW4nOlxuICAgIGNhc2UgJ251bGwnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gZGF0YTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KFN0cmluZyhkYXRhKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gJ3Vuc2VyaWFsaXphYmxlJztcbiAgICAgIH1cblxuICB9XG59IC8vIEJhc2ljYWxseSBjaGVja2luZyB0aGF0IHRoZSBvYmplY3Qgb25seSBoYXMgT2JqZWN0IGluIGl0cyBwcm90b3R5cGUgY2hhaW5cblxudmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iamVjdCkge1xuICB2YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIGlmICghb2JqZWN0UHJvdG90eXBlKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIG9iamVjdFBhcmVudFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3RQcm90b3R5cGUpO1xuICByZXR1cm4gIW9iamVjdFBhcmVudFByb3RvdHlwZTtcbn07XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxOSkpKVxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRUeXBlQ2xhc3M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZUNvbnRleHQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZUZ1bmN0aW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudFR5cGVGb3J3YXJkUmVmOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJqXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudFR5cGVNZW1vOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRUeXBlUHJvZmlsZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZVJvb3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZVN1c3BlbnNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRWxlbWVudFR5cGVTdXNwZW5zZUxpc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50VHlwZVRyYWNpbmdNYXJrZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENvbXBvbmVudEZpbHRlckRpc3BsYXlOYW1lOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ29tcG9uZW50RmlsdGVyTG9jYXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDb21wb25lbnRGaWx0ZXJIT0M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTdHJpY3RNb2RlOyB9KTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG4vKipcbiAqIFdBUk5JTkc6XG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdHlwZXMgdGhhdCBhcmUgZGVzaWduZWQgZm9yIFJlYWN0IERldlRvb2xzIFVJIGFuZCBob3cgaXQgaW50ZXJhY3RzIHdpdGggdGhlIGJhY2tlbmQuXG4gKiBUaGV5IG1pZ2h0IGJlIHVzZWQgaW4gZGlmZmVyZW50IHZlcnNpb25zIG9mIERldlRvb2xzIGJhY2tlbmRzLlxuICogQmUgbWluZGZ1bCBvZiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aGVuIG1ha2luZyBjaGFuZ2VzLlxuICovXG4vLyBXQVJOSU5HXG4vLyBUaGUgdmFsdWVzIGJlbG93IGFyZSByZWZlcmVuY2VkIGJ5IENvbXBvbmVudEZpbHRlcnMgKHdoaWNoIGFyZSBzYXZlZCB2aWEgbG9jYWxTdG9yYWdlKS5cbi8vIERvIG5vdCBjaGFuZ2UgdGhlbSBvciBpdCB3aWxsIGJyZWFrIHByZXZpb3VzbHkgc2F2ZWQgdXNlciBjdXN0b21pemF0aW9ucy5cbi8vIElmIG5ldyBlbGVtZW50IHR5cGVzIGFyZSBhZGRlZCwgdXNlIG5ldyBudW1iZXJzIHJhdGhlciB0aGFuIHJlLW9yZGVyaW5nIGV4aXN0aW5nIG9uZXMuXG4vL1xuLy8gQ2hhbmdpbmcgdGhlc2UgdHlwZXMgaXMgYWxzbyBhIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2UgZm9yIHRoZSBzdGFuZGFsb25lIHNoZWxsLFxuLy8gc2luY2UgdGhlIGZyb250ZW5kIGFuZCBiYWNrZW5kIG11c3Qgc2hhcmUgdGhlIHNhbWUgdmFsdWVzLVxuLy8gYW5kIHRoZSBiYWNrZW5kIGlzIGVtYmVkZGVkIGluIGNlcnRhaW4gZW52aXJvbm1lbnRzIChsaWtlIFJlYWN0IE5hdGl2ZSkuXG52YXIgRWxlbWVudFR5cGVDbGFzcyA9IDE7XG52YXIgRWxlbWVudFR5cGVDb250ZXh0ID0gMjtcbnZhciBFbGVtZW50VHlwZUZ1bmN0aW9uID0gNTtcbnZhciBFbGVtZW50VHlwZUZvcndhcmRSZWYgPSA2O1xudmFyIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCA9IDc7XG52YXIgRWxlbWVudFR5cGVNZW1vID0gODtcbnZhciBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duID0gOTtcbnZhciBFbGVtZW50VHlwZVByb2ZpbGVyID0gMTA7XG52YXIgRWxlbWVudFR5cGVSb290ID0gMTE7XG52YXIgRWxlbWVudFR5cGVTdXNwZW5zZSA9IDEyO1xudmFyIEVsZW1lbnRUeXBlU3VzcGVuc2VMaXN0ID0gMTM7XG52YXIgRWxlbWVudFR5cGVUcmFjaW5nTWFya2VyID0gMTQ7IC8vIERpZmZlcmVudCB0eXBlcyBvZiBlbGVtZW50cyBkaXNwbGF5ZWQgaW4gdGhlIEVsZW1lbnRzIHRyZWUuXG4vLyBUaGVzZSB0eXBlcyBtYXkgYmUgdXNlZCB0byB2aXN1YWxseSBkaXN0aW5ndWlzaCB0eXBlcyxcbi8vIG9yIHRvIGVuYWJsZS9kaXNhYmxlIGNlcnRhaW4gZnVuY3Rpb25hbGl0eS5cblxuLy8gV0FSTklOR1xuLy8gVGhlIHZhbHVlcyBiZWxvdyBhcmUgcmVmZXJlbmNlZCBieSBDb21wb25lbnRGaWx0ZXJzICh3aGljaCBhcmUgc2F2ZWQgdmlhIGxvY2FsU3RvcmFnZSkuXG4vLyBEbyBub3QgY2hhbmdlIHRoZW0gb3IgaXQgd2lsbCBicmVhayBwcmV2aW91c2x5IHNhdmVkIHVzZXIgY3VzdG9taXphdGlvbnMuXG4vLyBJZiBuZXcgZmlsdGVyIHR5cGVzIGFyZSBhZGRlZCwgdXNlIG5ldyBudW1iZXJzIHJhdGhlciB0aGFuIHJlLW9yZGVyaW5nIGV4aXN0aW5nIG9uZXMuXG52YXIgQ29tcG9uZW50RmlsdGVyRWxlbWVudFR5cGUgPSAxO1xudmFyIENvbXBvbmVudEZpbHRlckRpc3BsYXlOYW1lID0gMjtcbnZhciBDb21wb25lbnRGaWx0ZXJMb2NhdGlvbiA9IDM7XG52YXIgQ29tcG9uZW50RmlsdGVySE9DID0gNDtcbnZhciBTdHJpY3RNb2RlID0gMTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IENIUk9NRV9XRUJTVE9SRV9FWFRFTlNJT05fSUQgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBJTlRFUk5BTF9FWFRFTlNJT05fSUQgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBMT0NBTF9FWFRFTlNJT05fSUQgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19ERUJVR19fOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBfX1BFUkZPUk1BTkNFX1BST0ZJTEVfXyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUUkVFX09QRVJBVElPTl9BREQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUUkVFX09QRVJBVElPTl9SRU1PVkU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRSRUVfT1BFUkFUSU9OX1NFVF9TVUJUUkVFX01PREU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQUk9GSUxJTkdfRkxBR19CQVNJQ19TVVBQT1JUOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUFJPRklMSU5HX0ZMQUdfVElNRUxJTkVfU1VQUE9SVDsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgTE9DQUxfU1RPUkFHRV9ERUZBVUxUX1RBQl9LRVkgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTE9DQUxfU1RPUkFHRV9DT01QT05FTlRfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNFU1NJT05fU1RPUkFHRV9MQVNUX1NFTEVDVElPTl9LRVk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMT0NBTF9TVE9SQUdFX09QRU5fSU5fRURJVE9SX1VSTDsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgTE9DQUxfU1RPUkFHRV9QQVJTRV9IT09LX05BTUVTX0tFWSAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImpcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMT0NBTF9TVE9SQUdFX1NIT1VMRF9CUkVBS19PTl9DT05TT0xFX0VSUk9SUzsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgTE9DQUxfU1RPUkFHRV9CUk9XU0VSX1RIRU1FICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExPQ0FMX1NUT1JBR0VfU0hPVUxEX0FQUEVORF9DT01QT05FTlRfU1RBQ0tfS0VZOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTE9DQUxfU1RPUkFHRV9TSE9XX0lOTElORV9XQVJOSU5HU19BTkRfRVJST1JTX0tFWTsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgTE9DQUxfU1RPUkFHRV9UUkFDRV9VUERBVEVTX0VOQUJMRURfS0VZICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExPQ0FMX1NUT1JBR0VfSElERV9DT05TT0xFX0xPR1NfSU5fU1RSSUNUX01PREU7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFBST0ZJTEVSX0VYUE9SVF9WRVJTSU9OICovXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbnZhciBDSFJPTUVfV0VCU1RPUkVfRVhURU5TSU9OX0lEID0gJ2Zta2FkbWFwZ29mYWRvcGxqYmpma2FwZGtvaWVuaWhpJztcbnZhciBJTlRFUk5BTF9FWFRFTlNJT05fSUQgPSAnZG5qbmpnYmZpbGZwaG1vam5taGxpZWhvZ21vamhjbGMnO1xudmFyIExPQ0FMX0VYVEVOU0lPTl9JRCA9ICdpa2lhaG5hcGxkam1kbXBrbWZoamRqaWxvampoZ2NiZic7IC8vIEZsaXAgdGhpcyBmbGFnIHRvIHRydWUgdG8gZW5hYmxlIHZlcmJvc2UgY29uc29sZSBkZWJ1ZyBsb2dnaW5nLlxuXG52YXIgX19ERUJVR19fID0gZmFsc2U7IC8vIEZsaXAgdGhpcyBmbGFnIHRvIHRydWUgdG8gZW5hYmxlIHBlcmZvcm1hbmNlLm1hcmsoKSBhbmQgcGVyZm9ybWFuY2UubWVhc3VyZSgpIHRpbWluZ3MuXG5cbnZhciBfX1BFUkZPUk1BTkNFX1BST0ZJTEVfXyA9IGZhbHNlO1xudmFyIFRSRUVfT1BFUkFUSU9OX0FERCA9IDE7XG52YXIgVFJFRV9PUEVSQVRJT05fUkVNT1ZFID0gMjtcbnZhciBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOID0gMztcbnZhciBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OID0gNDtcbnZhciBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTID0gNTtcbnZhciBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCA9IDY7XG52YXIgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSA9IDc7XG52YXIgUFJPRklMSU5HX0ZMQUdfQkFTSUNfU1VQUE9SVCA9IDE7XG52YXIgUFJPRklMSU5HX0ZMQUdfVElNRUxJTkVfU1VQUE9SVCA9IDI7XG52YXIgTE9DQUxfU1RPUkFHRV9ERUZBVUxUX1RBQl9LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpkZWZhdWx0VGFiJztcbnZhciBMT0NBTF9TVE9SQUdFX0NPTVBPTkVOVF9GSUxURVJfUFJFRkVSRU5DRVNfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6Y29tcG9uZW50RmlsdGVycyc7XG52YXIgU0VTU0lPTl9TVE9SQUdFX0xBU1RfU0VMRUNUSU9OX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6Omxhc3RTZWxlY3Rpb24nO1xudmFyIExPQ0FMX1NUT1JBR0VfT1BFTl9JTl9FRElUT1JfVVJMID0gJ1JlYWN0OjpEZXZUb29sczo6b3BlbkluRWRpdG9yVXJsJztcbnZhciBMT0NBTF9TVE9SQUdFX1BBUlNFX0hPT0tfTkFNRVNfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6cGFyc2VIb29rTmFtZXMnO1xudmFyIFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMnO1xudmFyIFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6cmVsb2FkQW5kUHJvZmlsZSc7XG52YXIgTE9DQUxfU1RPUkFHRV9TSE9VTERfQlJFQUtfT05fQ09OU09MRV9FUlJPUlMgPSAnUmVhY3Q6OkRldlRvb2xzOjpicmVha09uQ29uc29sZUVycm9ycyc7XG52YXIgTE9DQUxfU1RPUkFHRV9CUk9XU0VSX1RIRU1FID0gJ1JlYWN0OjpEZXZUb29sczo6dGhlbWUnO1xudmFyIExPQ0FMX1NUT1JBR0VfU0hPVUxEX0FQUEVORF9DT01QT05FTlRfU1RBQ0tfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6YXBwZW5kQ29tcG9uZW50U3RhY2snO1xudmFyIExPQ0FMX1NUT1JBR0VfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMnO1xudmFyIExPQ0FMX1NUT1JBR0VfVFJBQ0VfVVBEQVRFU19FTkFCTEVEX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OnRyYWNlVXBkYXRlc0VuYWJsZWQnO1xudmFyIExPQ0FMX1NUT1JBR0VfSElERV9DT05TT0xFX0xPR1NfSU5fU1RSSUNUX01PREUgPSAnUmVhY3Q6OkRldlRvb2xzOjpoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUnO1xudmFyIFBST0ZJTEVSX0VYUE9SVF9WRVJTSU9OID0gNTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDT05DVVJSRU5UX01PREVfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDT05URVhUX05VTUJFUjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENPTlRFWFRfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNFUlZFUl9DT05URVhUX1NZTUJPTF9TVFJJTkc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORzsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgRUxFTUVOVF9OVU1CRVIgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBFTEVNRU5UX1NZTUJPTF9TVFJJTkcgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBERUJVR19UUkFDSU5HX01PREVfTlVNQkVSICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgREVCVUdfVFJBQ0lOR19NT0RFX1NZTUJPTF9TVFJJTkcgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRk9SV0FSRF9SRUZfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRk9SV0FSRF9SRUZfU1lNQk9MX1NUUklORzsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgRlJBR01FTlRfTlVNQkVSICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgRlJBR01FTlRfU1lNQk9MX1NUUklORyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMQVpZX05VTUJFUjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExBWllfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1FTU9fTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTUVNT19TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBQT1JUQUxfTlVNQkVSICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUE9SVEFMX1NZTUJPTF9TVFJJTkcgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUFJPRklMRVJfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUFJPRklMRVJfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBST1ZJREVSX05VTUJFUjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBST1ZJREVSX1NZTUJPTF9TVFJJTkc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTQ09QRV9OVU1CRVI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTQ09QRV9TWU1CT0xfU1RSSU5HOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU1RSSUNUX01PREVfTlVNQkVSOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU1RSSUNUX01PREVfU1lNQk9MX1NUUklORzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwid1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNVU1BFTlNFX05VTUJFUjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwieFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNVU1BFTlNFX1NZTUJPTF9TVFJJTkc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTVVNQRU5TRV9MSVNUX05VTUJFUjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNVU1BFTlNFX0xJU1RfU1lNQk9MX1NUUklORzsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEX1NZTUJPTF9TVFJJTkcgKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuLy8gVGhpcyBsaXN0IHNob3VsZCBiZSBrZXB0IHVwZGF0ZWQgdG8gcmVmbGVjdCBhZGRpdGlvbnMgdG8gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnLlxuLy8gRGV2VG9vbHMgY2FuJ3QgaW1wb3J0IHN5bWJvbHMgZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scycgZGlyZWN0bHkgZm9yIHR3byByZWFzb25zOlxuLy8gMS4gRGV2VG9vbHMgcmVxdWlyZXMgc3ltYm9scyB3aGljaCBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gbW9yZSByZWNlbnQgdmVyc2lvbnMgKGUuZy4gY29uY3VycmVudCBtb2RlKVxuLy8gMi4gRGV2VG9vbHMgbXVzdCBzdXBwb3J0IGJvdGggU3ltYm9sIGFuZCBudW1lcmljIGZvcm1zIG9mIGVhY2ggc3ltYm9sO1xuLy8gICAgU2luY2UgZS5nLiBzdGFuZGFsb25lIERldlRvb2xzIHJ1bnMgaW4gYSBzZXBhcmF0ZSBwcm9jZXNzLCBpdCBjYW4ndCByZWx5IG9uIGl0cyBvd24gRVMgY2FwYWJpbGl0aWVzLlxudmFyIENPTkNVUlJFTlRfTU9ERV9OVU1CRVIgPSAweGVhY2Y7XG52YXIgQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmNvbmN1cnJlbnRfbW9kZSknO1xudmFyIENPTlRFWFRfTlVNQkVSID0gMHhlYWNlO1xudmFyIENPTlRFWFRfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuY29udGV4dCknO1xudmFyIFNFUlZFUl9DT05URVhUX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnNlcnZlcl9jb250ZXh0KSc7XG52YXIgREVQUkVDQVRFRF9BU1lOQ19NT0RFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmFzeW5jX21vZGUpJztcbnZhciBFTEVNRU5UX05VTUJFUiA9IDB4ZWFjNztcbnZhciBFTEVNRU5UX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmVsZW1lbnQpJztcbnZhciBERUJVR19UUkFDSU5HX01PREVfTlVNQkVSID0gMHhlYWUxO1xudmFyIERFQlVHX1RSQUNJTkdfTU9ERV9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5kZWJ1Z190cmFjZV9tb2RlKSc7XG52YXIgRk9SV0FSRF9SRUZfTlVNQkVSID0gMHhlYWQwO1xudmFyIEZPUldBUkRfUkVGX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmZvcndhcmRfcmVmKSc7XG52YXIgRlJBR01FTlRfTlVNQkVSID0gMHhlYWNiO1xudmFyIEZSQUdNRU5UX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmZyYWdtZW50KSc7XG52YXIgTEFaWV9OVU1CRVIgPSAweGVhZDQ7XG52YXIgTEFaWV9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5sYXp5KSc7XG52YXIgTUVNT19OVU1CRVIgPSAweGVhZDM7XG52YXIgTUVNT19TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5tZW1vKSc7XG52YXIgUE9SVEFMX05VTUJFUiA9IDB4ZWFjYTtcbnZhciBQT1JUQUxfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QucG9ydGFsKSc7XG52YXIgUFJPRklMRVJfTlVNQkVSID0gMHhlYWQyO1xudmFyIFBST0ZJTEVSX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnByb2ZpbGVyKSc7XG52YXIgUFJPVklERVJfTlVNQkVSID0gMHhlYWNkO1xudmFyIFBST1ZJREVSX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnByb3ZpZGVyKSc7XG52YXIgU0NPUEVfTlVNQkVSID0gMHhlYWQ3O1xudmFyIFNDT1BFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnNjb3BlKSc7XG52YXIgU1RSSUNUX01PREVfTlVNQkVSID0gMHhlYWNjO1xudmFyIFNUUklDVF9NT0RFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnN0cmljdF9tb2RlKSc7XG52YXIgU1VTUEVOU0VfTlVNQkVSID0gMHhlYWQxO1xudmFyIFNVU1BFTlNFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnN1c3BlbnNlKSc7XG52YXIgU1VTUEVOU0VfTElTVF9OVU1CRVIgPSAweGVhZDg7XG52YXIgU1VTUEVOU0VfTElTVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5zdXNwZW5zZV9saXN0KSc7XG52YXIgU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnNlcnZlcl9jb250ZXh0LmRlZmF1bHRWYWx1ZSknO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImpcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGhhc0Fzc2lnbmVkQmFja2VuZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjbGVhbkZvckJyaWRnZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjb3B5V2l0aERlbGV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjb3B5V2l0aFJlbmFtZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjb3B5V2l0aFNldDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBnZXRFZmZlY3REdXJhdGlvbnM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gc2VyaWFsaXplVG9TdHJpbmc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZm9ybWF0V2l0aFN0eWxlczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBmb3JtYXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwia1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBndDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBndGU7IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAvVXNlcnMvaG94eS9yZXBvcy9yZWFjdC9ub2RlX21vZHVsZXMvY29tcGFyZS12ZXJzaW9ucy9saWIvZXNtL2luZGV4LmpzXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbi8qKlxuICogQ29tcGFyZSBbc2VtdmVyXShodHRwczovL3NlbXZlci5vcmcvKSB2ZXJzaW9uIHN0cmluZ3MgdG8gZmluZCBncmVhdGVyLCBlcXVhbCBvciBsZXNzZXIuXG4gKiBUaGlzIGxpYnJhcnkgc3VwcG9ydHMgdGhlIGZ1bGwgc2VtdmVyIHNwZWNpZmljYXRpb24sIGluY2x1ZGluZyBjb21wYXJpbmcgdmVyc2lvbnMgd2l0aCBkaWZmZXJlbnQgbnVtYmVyIG9mIGRpZ2l0cyBsaWtlIGAxLjAuMGAsIGAxLjBgLCBgMWAsIGFuZCBwcmUtcmVsZWFzZSB2ZXJzaW9ucyBsaWtlIGAxLjAuMC1hbHBoYWAuXG4gKiBAcGFyYW0gdjEgLSBGaXJzdCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB2MiAtIFNlY29uZCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIE51bWVyaWMgdmFsdWUgY29tcGF0aWJsZSB3aXRoIHRoZSBbQXJyYXkuc29ydChmbikgaW50ZXJmYWNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpLlxuICovXG52YXIgY29tcGFyZVZlcnNpb25zID0gZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKHYxLCB2Mikge1xuICAvLyB2YWxpZGF0ZSBpbnB1dCBhbmQgc3BsaXQgaW50byBzZWdtZW50c1xuICB2YXIgbjEgPSB2YWxpZGF0ZUFuZFBhcnNlKHYxKTtcbiAgdmFyIG4yID0gdmFsaWRhdGVBbmRQYXJzZSh2Mik7IC8vIHBvcCBvZmYgdGhlIHBhdGNoXG5cbiAgdmFyIHAxID0gbjEucG9wKCk7XG4gIHZhciBwMiA9IG4yLnBvcCgpOyAvLyB2YWxpZGF0ZSBudW1iZXJzXG5cbiAgdmFyIHIgPSBjb21wYXJlU2VnbWVudHMobjEsIG4yKTtcbiAgaWYgKHIgIT09IDApIHJldHVybiByOyAvLyB2YWxpZGF0ZSBwcmUtcmVsZWFzZVxuXG4gIGlmIChwMSAmJiBwMikge1xuICAgIHJldHVybiBjb21wYXJlU2VnbWVudHMocDEuc3BsaXQoJy4nKSwgcDIuc3BsaXQoJy4nKSk7XG4gIH0gZWxzZSBpZiAocDEgfHwgcDIpIHtcbiAgICByZXR1cm4gcDEgPyAtMSA6IDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn07XG4vKipcbiAqIFZhbGlkYXRlIFtzZW12ZXJdKGh0dHBzOi8vc2VtdmVyLm9yZy8pIHZlcnNpb24gc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIG51bWJlciB0byB2YWxpZGF0ZVxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIG51bWJlciBpcyBhIHZhbGlkIHNlbXZlciB2ZXJzaW9uIG51bWJlciwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogdmFsaWRhdGUoJzEuMC4wLXJjLjEnKTsgLy8gcmV0dXJuIHRydWVcbiAqIHZhbGlkYXRlKCcxLjAtcmMuMScpOyAvLyByZXR1cm4gZmFsc2VcbiAqIHZhbGlkYXRlKCdmb28nKTsgLy8gcmV0dXJuIGZhbHNlXG4gKiBgYGBcbiAqL1xuXG52YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSh2ZXJzaW9uKSB7XG4gIHJldHVybiB0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycgJiYgL15bdlxcZF0vLnRlc3QodmVyc2lvbikgJiYgc2VtdmVyLnRlc3QodmVyc2lvbik7XG59O1xuLyoqXG4gKiBDb21wYXJlIFtzZW12ZXJdKGh0dHBzOi8vc2VtdmVyLm9yZy8pIHZlcnNpb24gc3RyaW5ncyB1c2luZyB0aGUgc3BlY2lmaWVkIG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB2MSBGaXJzdCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB2MiBTZWNvbmQgdmVyc2lvbiB0byBjb21wYXJlXG4gKiBAcGFyYW0gb3BlcmF0b3IgQWxsb3dlZCBhcml0aG1ldGljIG9wZXJhdG9yIHRvIHVzZVxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb21wYXJpc29uIGJldHdlZW4gdGhlIGZpcnN0VmVyc2lvbiBhbmQgdGhlIHNlY29uZFZlcnNpb24gc2F0aXNmaWVzIHRoZSBvcGVyYXRvciwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29tcGFyZSgnMTAuMS44JywgJzEwLjAuNCcsICc+Jyk7IC8vIHJldHVybiB0cnVlXG4gKiBjb21wYXJlKCcxMC4wLjEnLCAnMTAuMC4xJywgJz0nKTsgLy8gcmV0dXJuIHRydWVcbiAqIGNvbXBhcmUoJzEwLjEuMScsICcxMC4yLjInLCAnPCcpOyAvLyByZXR1cm4gdHJ1ZVxuICogY29tcGFyZSgnMTAuMS4xJywgJzEwLjIuMicsICc8PScpOyAvLyByZXR1cm4gdHJ1ZVxuICogY29tcGFyZSgnMTAuMS4xJywgJzEwLjIuMicsICc+PScpOyAvLyByZXR1cm4gZmFsc2VcbiAqIGBgYFxuICovXG5cbnZhciBjb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSh2MSwgdjIsIG9wZXJhdG9yKSB7XG4gIC8vIHZhbGlkYXRlIGlucHV0IG9wZXJhdG9yXG4gIGFzc2VydFZhbGlkT3BlcmF0b3Iob3BlcmF0b3IpOyAvLyBzaW5jZSByZXN1bHQgb2YgY29tcGFyZVZlcnNpb25zIGNhbiBvbmx5IGJlIC0xIG9yIDAgb3IgMVxuICAvLyBhIHNpbXBsZSBtYXAgY2FuIGJlIHVzZWQgdG8gcmVwbGFjZSBzd2l0Y2hcblxuICB2YXIgcmVzID0gY29tcGFyZVZlcnNpb25zKHYxLCB2Mik7XG4gIHJldHVybiBvcGVyYXRvclJlc01hcFtvcGVyYXRvcl0uaW5jbHVkZXMocmVzKTtcbn07XG4vKipcbiAqIE1hdGNoIFtucG0gc2VtdmVyXShodHRwczovL2RvY3MubnBtanMuY29tL2NsaS92Ni91c2luZy1ucG0vc2VtdmVyKSB2ZXJzaW9uIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gbnVtYmVyIHRvIG1hdGNoXG4gKiBAcGFyYW0gcmFuZ2UgUmFuZ2UgcGF0dGVybiBmb3IgdmVyc2lvblxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIG51bWJlciBpcyB3aXRoaW4gdGhlIHJhbmdlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBzYXRpc2ZpZXMoJzEuMS4wJywgJ14xLjAuMCcpOyAvLyByZXR1cm4gdHJ1ZVxuICogc2F0aXNmaWVzKCcxLjEuMCcsICd+MS4wLjAnKTsgLy8gcmV0dXJuIGZhbHNlXG4gKiBgYGBcbiAqL1xuXG52YXIgc2F0aXNmaWVzID0gZnVuY3Rpb24gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlKSB7XG4gIC8vIGlmIG5vIHJhbmdlIG9wZXJhdG9yIHRoZW4gXCI9XCJcbiAgdmFyIG0gPSByYW5nZS5tYXRjaCgvXihbPD49fl5dKykvKTtcbiAgdmFyIG9wID0gbSA/IG1bMV0gOiAnPSc7IC8vIGlmIGd0L2x0L2VxIHRoZW4gb3BlcmF0b3IgY29tcGFyZVxuXG4gIGlmIChvcCAhPT0gJ14nICYmIG9wICE9PSAnficpIHJldHVybiBjb21wYXJlKHZlcnNpb24sIHJhbmdlLCBvcCk7IC8vIGVsc2UgcmFuZ2Ugb2YgZWl0aGVyIFwiflwiIG9yIFwiXlwiIGlzIGFzc3VtZWRcblxuICB2YXIgX3ZhbGlkYXRlQW5kUGFyc2UgPSB2YWxpZGF0ZUFuZFBhcnNlKHZlcnNpb24pLFxuICAgICAgX3ZhbGlkYXRlQW5kUGFyc2UyID0gX3NsaWNlZFRvQXJyYXkoX3ZhbGlkYXRlQW5kUGFyc2UsIDUpLFxuICAgICAgdjEgPSBfdmFsaWRhdGVBbmRQYXJzZTJbMF0sXG4gICAgICB2MiA9IF92YWxpZGF0ZUFuZFBhcnNlMlsxXSxcbiAgICAgIHYzID0gX3ZhbGlkYXRlQW5kUGFyc2UyWzJdLFxuICAgICAgdnAgPSBfdmFsaWRhdGVBbmRQYXJzZTJbNF07XG5cbiAgdmFyIF92YWxpZGF0ZUFuZFBhcnNlMyA9IHZhbGlkYXRlQW5kUGFyc2UocmFuZ2UpLFxuICAgICAgX3ZhbGlkYXRlQW5kUGFyc2U0ID0gX3NsaWNlZFRvQXJyYXkoX3ZhbGlkYXRlQW5kUGFyc2UzLCA1KSxcbiAgICAgIHIxID0gX3ZhbGlkYXRlQW5kUGFyc2U0WzBdLFxuICAgICAgcjIgPSBfdmFsaWRhdGVBbmRQYXJzZTRbMV0sXG4gICAgICByMyA9IF92YWxpZGF0ZUFuZFBhcnNlNFsyXSxcbiAgICAgIHJwID0gX3ZhbGlkYXRlQW5kUGFyc2U0WzRdO1xuXG4gIHZhciB2ID0gW3YxLCB2MiwgdjNdO1xuICB2YXIgciA9IFtyMSwgcjIgIT09IG51bGwgJiYgcjIgIT09IHZvaWQgMCA/IHIyIDogJ3gnLCByMyAhPT0gbnVsbCAmJiByMyAhPT0gdm9pZCAwID8gcjMgOiAneCddOyAvLyB2YWxpZGF0ZSBwcmUtcmVsZWFzZVxuXG4gIGlmIChycCkge1xuICAgIGlmICghdnApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29tcGFyZVNlZ21lbnRzKHYsIHIpICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNvbXBhcmVTZWdtZW50cyh2cC5zcGxpdCgnLicpLCBycC5zcGxpdCgnLicpKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgfSAvLyBmaXJzdCBub24temVybyBudW1iZXJcblxuXG4gIHZhciBub25aZXJvID0gci5maW5kSW5kZXgoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiAhPT0gJzAnO1xuICB9KSArIDE7IC8vIHBvaW50ZXIgdG8gd2hlcmUgc2VnbWVudHMgY2FuIGJlID49XG5cbiAgdmFyIGkgPSBvcCA9PT0gJ34nID8gMiA6IG5vblplcm8gPiAxID8gbm9uWmVybyA6IDE7IC8vIGJlZm9yZSBwb2ludGVyIG11c3QgYmUgZXF1YWxcblxuICBpZiAoY29tcGFyZVNlZ21lbnRzKHYuc2xpY2UoMCwgaSksIHIuc2xpY2UoMCwgaSkpICE9PSAwKSByZXR1cm4gZmFsc2U7IC8vIGFmdGVyIHBvaW50ZXIgbXVzdCBiZSA+PVxuXG4gIGlmIChjb21wYXJlU2VnbWVudHModi5zbGljZShpKSwgci5zbGljZShpKSkgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBzZW12ZXIgPSAvXlt2Xn48Pj1dKj8oXFxkKykoPzpcXC4oW3gqXXxcXGQrKSg/OlxcLihbeCpdfFxcZCspKD86XFwuKFt4Kl18XFxkKykpPyg/Oi0oW1xcZGEtelxcLV0rKD86XFwuW1xcZGEtelxcLV0rKSopKT8oPzpcXCtbXFxkYS16XFwtXSsoPzpcXC5bXFxkYS16XFwtXSspKik/KT8pPyQvaTtcblxudmFyIHZhbGlkYXRlQW5kUGFyc2UgPSBmdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlKHZlcnNpb24pIHtcbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgZXhwZWN0ZWQgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHNlbXZlcik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgbm90IHZhbGlkIHNlbXZlciAoJ1wiLmNvbmNhdCh2ZXJzaW9uLCBcIicgcmVjZWl2ZWQpXCIpKTtcbiAgfVxuXG4gIG1hdGNoLnNoaWZ0KCk7XG4gIHJldHVybiBtYXRjaDtcbn07XG5cbnZhciBpc1dpbGRjYXJkID0gZnVuY3Rpb24gaXNXaWxkY2FyZChzKSB7XG4gIHJldHVybiBzID09PSAnKicgfHwgcyA9PT0gJ3gnIHx8IHMgPT09ICdYJztcbn07XG5cbnZhciB0cnlQYXJzZSA9IGZ1bmN0aW9uIHRyeVBhcnNlKHYpIHtcbiAgdmFyIG4gPSBwYXJzZUludCh2LCAxMCk7XG4gIHJldHVybiBpc05hTihuKSA/IHYgOiBuO1xufTtcblxudmFyIGZvcmNlVHlwZSA9IGZ1bmN0aW9uIGZvcmNlVHlwZShhLCBiKSB7XG4gIHJldHVybiBfdHlwZW9mKGEpICE9PSBfdHlwZW9mKGIpID8gW1N0cmluZyhhKSwgU3RyaW5nKGIpXSA6IFthLCBiXTtcbn07XG5cbnZhciBjb21wYXJlU3RyaW5ncyA9IGZ1bmN0aW9uIGNvbXBhcmVTdHJpbmdzKGEsIGIpIHtcbiAgaWYgKGlzV2lsZGNhcmQoYSkgfHwgaXNXaWxkY2FyZChiKSkgcmV0dXJuIDA7XG5cbiAgdmFyIF9mb3JjZVR5cGUgPSBmb3JjZVR5cGUodHJ5UGFyc2UoYSksIHRyeVBhcnNlKGIpKSxcbiAgICAgIF9mb3JjZVR5cGUyID0gX3NsaWNlZFRvQXJyYXkoX2ZvcmNlVHlwZSwgMiksXG4gICAgICBhcCA9IF9mb3JjZVR5cGUyWzBdLFxuICAgICAgYnAgPSBfZm9yY2VUeXBlMlsxXTtcblxuICBpZiAoYXAgPiBicCkgcmV0dXJuIDE7XG4gIGlmIChhcCA8IGJwKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufTtcblxudmFyIGNvbXBhcmVTZWdtZW50cyA9IGZ1bmN0aW9uIGNvbXBhcmVTZWdtZW50cyhhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTsgaSsrKSB7XG4gICAgdmFyIHIgPSBjb21wYXJlU3RyaW5ncyhhW2ldIHx8ICcwJywgYltpXSB8fCAnMCcpO1xuICAgIGlmIChyICE9PSAwKSByZXR1cm4gcjtcbiAgfVxuXG4gIHJldHVybiAwO1xufTtcblxudmFyIG9wZXJhdG9yUmVzTWFwID0ge1xuICAnPic6IFsxXSxcbiAgJz49JzogWzAsIDFdLFxuICAnPSc6IFswXSxcbiAgJzw9JzogWy0xLCAwXSxcbiAgJzwnOiBbLTFdXG59O1xudmFyIGFsbG93ZWRPcGVyYXRvcnMgPSBPYmplY3Qua2V5cyhvcGVyYXRvclJlc01hcCk7XG5cbnZhciBhc3NlcnRWYWxpZE9wZXJhdG9yID0gZnVuY3Rpb24gYXNzZXJ0VmFsaWRPcGVyYXRvcihvcCkge1xuICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIG9wZXJhdG9yIHR5cGUsIGV4cGVjdGVkIHN0cmluZyBidXQgZ290IFwiLmNvbmNhdChfdHlwZW9mKG9wKSkpO1xuICB9XG5cbiAgaWYgKGFsbG93ZWRPcGVyYXRvcnMuaW5kZXhPZihvcCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRvciwgZXhwZWN0ZWQgb25lIG9mIFwiLmNvbmNhdChhbGxvd2VkT3BlcmF0b3JzLmpvaW4oJ3wnKSkpO1xuICB9XG59O1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2h5ZHJhdGlvbi5qc1xudmFyIGh5ZHJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3NoYXJlZC9pc0FycmF5LmpzXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC91dGlscy5qc1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHV0aWxzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiB1dGlsc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHV0aWxzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB1dGlsc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIHV0aWxzX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiB1dGlsc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiB1dGlsc190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHV0aWxzX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyB1dGlsc190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gdXRpbHNfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG4vLyBUT0RPOiB1cGRhdGUgdGhpcyB0byB0aGUgZmlyc3QgUmVhY3QgdmVyc2lvbiB0aGF0IGhhcyBhIGNvcnJlc3BvbmRpbmcgRGV2VG9vbHMgYmFja2VuZFxudmFyIEZJUlNUX0RFVlRPT0xTX0JBQ0tFTkRfTE9DS1NURVBfVkVSID0gJzk5OS45LjknO1xuZnVuY3Rpb24gaGFzQXNzaWduZWRCYWNrZW5kKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT0gbnVsbCB8fCB2ZXJzaW9uID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBndGUodmVyc2lvbiwgRklSU1RfREVWVE9PTFNfQkFDS0VORF9MT0NLU1RFUF9WRVIpO1xufVxuZnVuY3Rpb24gY2xlYW5Gb3JCcmlkZ2UoZGF0YSwgaXNQYXRoQWxsb3dlZCkge1xuICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG5cbiAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICB2YXIgY2xlYW5lZFBhdGhzID0gW107XG4gICAgdmFyIHVuc2VyaWFsaXphYmxlUGF0aHMgPSBbXTtcbiAgICB2YXIgY2xlYW5lZERhdGEgPSBPYmplY3QoaHlkcmF0aW9uW1wiYVwiIC8qIGRlaHlkcmF0ZSAqL10pKGRhdGEsIGNsZWFuZWRQYXRocywgdW5zZXJpYWxpemFibGVQYXRocywgcGF0aCwgaXNQYXRoQWxsb3dlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGNsZWFuZWREYXRhLFxuICAgICAgY2xlYW5lZDogY2xlYW5lZFBhdGhzLFxuICAgICAgdW5zZXJpYWxpemFibGU6IHVuc2VyaWFsaXphYmxlUGF0aHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5V2l0aERlbGV0ZShvYmosIHBhdGgpIHtcbiAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gIHZhciB1cGRhdGVkID0gT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKG9iaikgPyBvYmouc2xpY2UoKSA6IF9vYmplY3RTcHJlYWQoe30sIG9iaik7XG5cbiAgaWYgKGluZGV4ICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICBpZiAoT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZShrZXksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdXBkYXRlZFtrZXldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGUob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlZDtcbn0gLy8gVGhpcyBmdW5jdGlvbiBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGZpbmFsIHZhbHVlLlxuLy8gZS5nLiBbJ3BhdGgnLCAndG8nLCAnZm9vJ10gYW5kIFsncGF0aCcsICd0bycsICdiYXInXVxuXG5mdW5jdGlvbiBjb3B5V2l0aFJlbmFtZShvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gIHZhciB1cGRhdGVkID0gT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKG9iaikgPyBvYmouc2xpY2UoKSA6IF9vYmplY3RTcHJlYWQoe30sIG9iaik7XG5cbiAgaWYgKGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGgpIHtcbiAgICB2YXIgbmV3S2V5ID0gbmV3UGF0aFtpbmRleF07IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgIGlmIChPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkodXBkYXRlZCkpIHtcbiAgICAgIHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZShvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkO1xufVxuZnVuY3Rpb24gY29weVdpdGhTZXQob2JqLCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG5cbiAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICB2YXIgdXBkYXRlZCA9IE9iamVjdChpc0FycmF5W1wiYVwiIC8qIGRlZmF1bHQgKi9dKShvYmopID8gb2JqLnNsaWNlKCkgOiBfb2JqZWN0U3ByZWFkKHt9LCBvYmopOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXQob2JqW2tleV0sIHBhdGgsIHZhbHVlLCBpbmRleCArIDEpO1xuICByZXR1cm4gdXBkYXRlZDtcbn1cbmZ1bmN0aW9uIGdldEVmZmVjdER1cmF0aW9ucyhyb290KSB7XG4gIC8vIFByb2ZpbGluZyBkdXJhdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGZvciBjZXJ0YWluIGJ1aWxkcy5cbiAgLy8gSWYgYXZhaWxhYmxlLCB0aGV5J2xsIGJlIHN0b3JlZCBvbiB0aGUgSG9zdFJvb3QuXG4gIHZhciBlZmZlY3REdXJhdGlvbiA9IG51bGw7XG4gIHZhciBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBudWxsO1xuICB2YXIgaG9zdFJvb3QgPSByb290LmN1cnJlbnQ7XG5cbiAgaWYgKGhvc3RSb290ICE9IG51bGwpIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gaG9zdFJvb3Quc3RhdGVOb2RlO1xuXG4gICAgaWYgKHN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICBlZmZlY3REdXJhdGlvbiA9IHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiAhPSBudWxsID8gc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uIDogbnVsbDtcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gIT0gbnVsbCA/IHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gOiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZWZmZWN0RHVyYXRpb246IGVmZmVjdER1cmF0aW9uLFxuICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogcGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUb1N0cmluZyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICB2YXIgY2FjaGUgPSBuZXcgU2V0KCk7IC8vIFVzZSBhIGN1c3RvbSByZXBsYWNlciBmdW5jdGlvbiB0byBwcm90ZWN0IGFnYWluc3QgY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodXRpbHNfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjYWNoZS5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FjaGUuYWRkKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyAnbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LCAyKTtcbn0gLy8gRm9ybWF0cyBhbiBhcnJheSBvZiBhcmdzIHdpdGggYSBzdHlsZSBmb3IgY29uc29sZSBtZXRob2RzLCB1c2luZ1xuLy8gdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4vLyAgICAgMS4gVGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nIHRoYXQgY29udGFpbnMgJWNcbi8vICAgICAgICAgIC0gQmFpbCBvdXQgYW5kIHJldHVybiB0aGUgYXJncyB3aXRob3V0IG1vZGlmeWluZyB0aGUgc3R5bGVzLlxuLy8gICAgICAgICAgICBXZSBkb24ndCB3YW50IHRvIGFmZmVjdCBzdHlsZXMgdGhhdCB0aGUgZGV2ZWxvcGVyIGRlbGliZXJhdGVseSBzZXQuXG4vLyAgICAgMi4gVGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCBjb250YWluICVjIGJ1dCBjb250YWluc1xuLy8gICAgICAgIHN0cmluZyBmb3JtYXR0aW5nXG4vLyAgICAgICAgICAtIFtgJWMke2FyZ3NbMF19YCwgc3R5bGUsIC4uLmFyZ3Muc2xpY2UoMSldXG4vLyAgICAgICAgICAtIE5vdGU6IHdlIGFzc3VtZSB0aGF0IHRoZSBzdHJpbmcgZm9ybWF0dGluZyB0aGF0IHRoZSBkZXZlbG9wZXIgdXNlc1xuLy8gICAgICAgICAgICBpcyBjb3JyZWN0LlxuLy8gICAgIDMuIFRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZyB0aGF0IGRvZXNuJ3QgY29udGFpbiBzdHJpbmcgZm9ybWF0dGluZ1xuLy8gICAgICAgIE9SIGlzIG5vdCBhIHN0cmluZ1xuLy8gICAgICAgICAgLSBDcmVhdGUgYSBmb3JtYXR0aW5nIHN0cmluZyB3aGVyZTpcbi8vICAgICAgICAgICAgICAgICBib29sZWFuLCBzdHJpbmcsIHN5bWJvbCAtPiAlc1xuLy8gICAgICAgICAgICAgICAgIG51bWJlciAtPiAlZiBPUiAlaSBkZXBlbmRpbmcgb24gaWYgaXQncyBhbiBpbnQgb3IgZmxvYXRcbi8vICAgICAgICAgICAgICAgICBkZWZhdWx0IC0+ICVvXG5cbmZ1bmN0aW9uIGZvcm1hdFdpdGhTdHlsZXMoaW5wdXRBcmdzLCBzdHlsZSkge1xuICBpZiAoaW5wdXRBcmdzID09PSB1bmRlZmluZWQgfHwgaW5wdXRBcmdzID09PSBudWxsIHx8IGlucHV0QXJncy5sZW5ndGggPT09IDAgfHwgLy8gTWF0Y2hlcyBhbnkgb2YgJWMgYnV0IG5vdCAlJWNcbiAgdHlwZW9mIGlucHV0QXJnc1swXSA9PT0gJ3N0cmluZycgJiYgaW5wdXRBcmdzWzBdLm1hdGNoKC8oW14lXXxeKSglYykvZykgfHwgc3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBpbnB1dEFyZ3M7XG4gIH0gLy8gTWF0Y2hlcyBhbnkgb2YgJShvfE98ZHxpfHN8ZiksIGJ1dCBub3QgJSUob3xPfGR8aXxzfGYpXG5cblxuICB2YXIgUkVHRVhQID0gLyhbXiVdfF4pKCglJSkqKSglKFtvT2Rpc2ZdKSkvZztcblxuICBpZiAodHlwZW9mIGlucHV0QXJnc1swXSA9PT0gJ3N0cmluZycgJiYgaW5wdXRBcmdzWzBdLm1hdGNoKFJFR0VYUCkpIHtcbiAgICByZXR1cm4gW1wiJWNcIi5jb25jYXQoaW5wdXRBcmdzWzBdKSwgc3R5bGVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5wdXRBcmdzLnNsaWNlKDEpKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0QXJnID0gaW5wdXRBcmdzLnJlZHVjZShmdW5jdGlvbiAoZm9ybWF0U3RyLCBlbGVtLCBpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgZm9ybWF0U3RyICs9ICcgJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh1dGlsc190eXBlb2YoZWxlbSkpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFN0ciArPSAnJXMnO1xuXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgdmFyIGZvcm1hdHRpbmcgPSBOdW1iZXIuaXNJbnRlZ2VyKGVsZW0pID8gJyVpJyA6ICclZic7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFN0ciArPSBmb3JtYXR0aW5nO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFN0ciArPSAnJW8nO1xuICAgICAgfVxuICAgIH0sICclYycpO1xuICAgIHJldHVybiBbZmlyc3RBcmcsIHN0eWxlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGlucHV0QXJncykpO1xuICB9XG59IC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90bXBmcy9mb3JtYXQtdXRpbC9ibG9iLzBlNjJkNDMwZWZiMGExYzUxNDQ4NzA5YWJkM2UyNDA2YzE0ZDg0MDEvZm9ybWF0LmpzI0wxXG4vLyBiYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvY29uc29sZSNVc2luZ19zdHJpbmdfc3Vic3RpdHV0aW9uc1xuLy8gSW1wbGVtZW50cyBzLCBkLCBpIGFuZCBmIHBsYWNlaG9sZGVyc1xuLy8gTk9URTogS0VFUCBJTiBTWU5DIHdpdGggc3JjL2hvb2suanNcblxuZnVuY3Rpb24gZm9ybWF0KG1heWJlTWVzc2FnZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaW5wdXRBcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBpbnB1dEFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBpbnB1dEFyZ3Muc2xpY2UoKTtcbiAgdmFyIGZvcm1hdHRlZCA9IFN0cmluZyhtYXliZU1lc3NhZ2UpOyAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGNoZWNrIGZvciBzdWJzdGl0dXRpb25zLlxuXG4gIGlmICh0eXBlb2YgbWF5YmVNZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgdmFyIFJFR0VYUCA9IC8oJT8pKCUoW2pkc10pKS9nO1xuICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoUkVHRVhQLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIHB0biwgZmxhZykge1xuICAgICAgICB2YXIgYXJnID0gYXJncy5zaGlmdCgpO1xuXG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgYXJnICs9ICcnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgIGFyZyA9IHBhcnNlSW50KGFyZywgMTApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgYXJnID0gcGFyc2VGbG9hdChhcmcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLnVuc2hpZnQoYXJnKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIEFyZ3VtZW50cyB0aGF0IHJlbWFpbiBhZnRlciBmb3JtYXR0aW5nLlxuXG5cbiAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3JtYXR0ZWQgKz0gJyAnICsgU3RyaW5nKGFyZ3NbaV0pO1xuICAgIH1cbiAgfSAvLyBVcGRhdGUgZXNjYXBlZCAlJSB2YWx1ZXMuXG5cblxuICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZSgvJXsyLDJ9L2csICclJyk7XG4gIHJldHVybiBTdHJpbmcoZm9ybWF0dGVkKTtcbn1cbmZ1bmN0aW9uIGlzU3luY2hyb25vdXNYSFJTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAhISh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmZlYXR1cmVQb2xpY3kgJiYgd2luZG93LmRvY3VtZW50LmZlYXR1cmVQb2xpY3kuYWxsb3dzRmVhdHVyZSgnc3luYy14aHInKSk7XG59XG5mdW5jdGlvbiBndCgpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICB2YXIgYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYSwgYikgPT09IDE7XG59XG5mdW5jdGlvbiBndGUoKSB7XG4gIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgdmFyIGIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICByZXR1cm4gY29tcGFyZVZlcnNpb25zKGEsIGIpID4gLTE7XG59XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9jYWxTdG9yYWdlR2V0SXRlbTsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgbG9jYWxTdG9yYWdlUmVtb3ZlSXRlbSAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2NhbFN0b3JhZ2VTZXRJdGVtOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2Vzc2lvblN0b3JhZ2VHZXRJdGVtOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2Vzc2lvblN0b3JhZ2VTZXRJdGVtOyB9KTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yYWdlR2V0SXRlbShrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gbG9jYWxTdG9yYWdlUmVtb3ZlSXRlbShrZXkpIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cbmZ1bmN0aW9uIGxvY2FsU3RvcmFnZVNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG59XG5mdW5jdGlvbiBzZXNzaW9uU3RvcmFnZUdldEl0ZW0oa2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKGtleSkge1xuICB0cnkge1xuICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG59XG5mdW5jdGlvbiBzZXNzaW9uU3RvcmFnZVNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGlzQXJyYXkpO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuaWYgKHRydWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbn0gZWxzZSB7fVxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGlzU3RyaW5nQ29tcG9uZW50U3RhY2sgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBkYW5nZXJvdXNfc2V0VGFyZ2V0Q29uc29sZUZvclRlc3RpbmcgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVnaXN0ZXJSZW5kZXJlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhdGNoOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCB1bnBhdGNoICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhdGNoRm9yU3RyaWN0TW9kZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVucGF0Y2hGb3JTdHJpY3RNb2RlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZUNvbnNvbGVQYXRjaFNldHRpbmdzVG9XaW5kb3c7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbnN0YWxsQ29uc29sZUZ1bmN0aW9uc1RvV2luZG93OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlbmRlcmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9kZXZ0b29sc19mZWF0dXJlX2ZsYWdzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuXG5cbnZhciBPVkVSUklERV9DT05TT0xFX01FVEhPRFMgPSBbJ2Vycm9yJywgJ3RyYWNlJywgJ3dhcm4nXTtcbnZhciBESU1NRURfTk9ERV9DT05TT0xFX0NPTE9SID0gJ1xceDFiWzJtJXNcXHgxYlswbSc7IC8vIFJlYWN0J3MgY3VzdG9tIGJ1aWx0IGNvbXBvbmVudCBzdGFjayBzdHJpbmdzIG1hdGNoIFwiXFxzezR9aW5cIlxuLy8gQ2hyb21lJ3MgcHJlZml4IG1hdGNoZXMgXCJcXHN7NH1hdFwiXG5cbnZhciBQUkVGSVhfUkVHRVggPSAvXFxzezR9KGlufGF0KVxcc3sxfS87IC8vIEZpcmVmb3ggYW5kIFNhZmFyaSBoYXZlIG5vIHByZWZpeCAoXCJcIilcbi8vIGJ1dCB3ZSBjYW4gZmFsbGJhY2sgdG8gbG9va2luZyBmb3IgbG9jYXRpb24gaW5mbyAoZS5nLiBcImZvby5qczoxMjozNDVcIilcblxudmFyIFJPV19DT0xVTU5fTlVNQkVSX1JFR0VYID0gLzpcXGQrOlxcZCsoXFxufCQpLztcbmZ1bmN0aW9uIGlzU3RyaW5nQ29tcG9uZW50U3RhY2sodGV4dCkge1xuICByZXR1cm4gUFJFRklYX1JFR0VYLnRlc3QodGV4dCkgfHwgUk9XX0NPTFVNTl9OVU1CRVJfUkVHRVgudGVzdCh0ZXh0KTtcbn1cbnZhciBTVFlMRV9ESVJFQ1RJVkVfUkVHRVggPSAvXiVjLzsgLy8gVGhpcyBmdW5jdGlvbiB0ZWxscyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGZvciBhIGNvbnNvbGVcbi8vIG1ldGhvZCBoYXMgYmVlbiBvdmVycmlkZGVuIGJ5IHRoZSBwYXRjaEZvclN0cmljdE1vZGUgZnVuY3Rpb24uXG4vLyBJZiBpdCBoYXMgd2UnbGwgbmVlZCB0byBkbyBzb21lIHNwZWNpYWwgZm9ybWF0dGluZyBvZiB0aGUgYXJndW1lbnRzXG4vLyBzbyB0aGUgY29uc29sZSBjb2xvciBzdGF5cyBjb25zaXN0ZW50XG5cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZU92ZXJyaWRlKGFyZ3MsIG1ldGhvZCkge1xuICByZXR1cm4gYXJncy5sZW5ndGggPj0gMiAmJiBTVFlMRV9ESVJFQ1RJVkVfUkVHRVgudGVzdChhcmdzWzBdKSAmJiBhcmdzWzFdID09PSBcImNvbG9yOiBcIi5jb25jYXQoZ2V0Q29uc29sZUNvbG9yKG1ldGhvZCkgfHwgJycpO1xufVxuXG5mdW5jdGlvbiBnZXRDb25zb2xlQ29sb3IobWV0aG9kKSB7XG4gIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgY2FzZSAnd2Fybic6XG4gICAgICByZXR1cm4gY29uc29sZVNldHRpbmdzUmVmLmJyb3dzZXJUaGVtZSA9PT0gJ2xpZ2h0JyA/IFwicmdiYSgyNTAsIDE4MCwgNTAsIDAuNzUpXCIgOiBcInJnYmEoMjUwLCAxODAsIDUwLCAwLjUpXCI7XG5cbiAgICBjYXNlICdlcnJvcic6XG4gICAgICByZXR1cm4gY29uc29sZVNldHRpbmdzUmVmLmJyb3dzZXJUaGVtZSA9PT0gJ2xpZ2h0JyA/IFwicmdiYSgyNTAsIDEyMywgMTMwLCAwLjc1KVwiIDogXCJyZ2JhKDI1MCwgMTIzLCAxMzAsIDAuNSlcIjtcblxuICAgIGNhc2UgJ2xvZyc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb25zb2xlU2V0dGluZ3NSZWYuYnJvd3NlclRoZW1lID09PSAnbGlnaHQnID8gXCJyZ2JhKDEyNSwgMTI1LCAxMjUsIDAuNzUpXCIgOiBcInJnYmEoMTI1LCAxMjUsIDEyNSwgMC41KVwiO1xuICB9XG59XG5cbnZhciBpbmplY3RlZFJlbmRlcmVycyA9IG5ldyBNYXAoKTtcbnZhciB0YXJnZXRDb25zb2xlID0gY29uc29sZTtcbnZhciB0YXJnZXRDb25zb2xlTWV0aG9kcyA9IHt9O1xuXG5mb3IgKHZhciBtZXRob2QgaW4gY29uc29sZSkge1xuICB0YXJnZXRDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gY29uc29sZVttZXRob2RdO1xufVxuXG52YXIgdW5wYXRjaEZuID0gbnVsbDtcbnZhciBpc05vZGUgPSBmYWxzZTtcblxudHJ5IHtcbiAgaXNOb2RlID0gdW5kZWZpbmVkID09PSBnbG9iYWw7XG59IGNhdGNoIChlcnJvcikge30gLy8gRW5hYmxlcyBlLmcuIEplc3QgdGVzdHMgdG8gaW5qZWN0IGEgbW9jayBjb25zb2xlIG9iamVjdC5cblxuXG5mdW5jdGlvbiBkYW5nZXJvdXNfc2V0VGFyZ2V0Q29uc29sZUZvclRlc3RpbmcodGFyZ2V0Q29uc29sZUZvclRlc3RpbmcpIHtcbiAgdGFyZ2V0Q29uc29sZSA9IHRhcmdldENvbnNvbGVGb3JUZXN0aW5nO1xuICB0YXJnZXRDb25zb2xlTWV0aG9kcyA9IHt9O1xuXG4gIGZvciAodmFyIF9tZXRob2QgaW4gdGFyZ2V0Q29uc29sZSkge1xuICAgIHRhcmdldENvbnNvbGVNZXRob2RzW19tZXRob2RdID0gY29uc29sZVtfbWV0aG9kXTtcbiAgfVxufSAvLyB2MTYgcmVuZGVyZXJzIHNob3VsZCB1c2UgdGhpcyBtZXRob2QgdG8gaW5qZWN0IGludGVybmFscyBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgYSBjb21wb25lbnQgc3RhY2suXG4vLyBUaGVzZSBpbnRlcm5hbHMgd2lsbCBiZSB1c2VkIGlmIHRoZSBjb25zb2xlIGlzIHBhdGNoZWQuXG4vLyBJbmplY3RpbmcgdGhlbSBzZXBhcmF0ZWx5IGFsbG93cyB0aGUgY29uc29sZSB0byBlYXNpbHkgYmUgcGF0Y2hlZCBvciB1bi1wYXRjaGVkIGxhdGVyIChhdCBydW50aW1lKS5cblxuZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJlcihyZW5kZXJlciwgb25FcnJvck9yV2FybmluZykge1xuICB2YXIgY3VycmVudERpc3BhdGNoZXJSZWYgPSByZW5kZXJlci5jdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgIGdldEN1cnJlbnRGaWJlciA9IHJlbmRlcmVyLmdldEN1cnJlbnRGaWJlcixcbiAgICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gcmVuZGVyZXIuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UsXG4gICAgICB2ZXJzaW9uID0gcmVuZGVyZXIudmVyc2lvbjsgLy8gSWdub3JlIFJlYWN0IHYxNSBhbmQgb2xkZXIgYmVjYXVzZSB0aGV5IGRvbid0IGV4cG9zZSBhIGNvbXBvbmVudCBzdGFjayBhbnl3YXkuXG5cbiAgaWYgKHR5cGVvZiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfSAvLyBjdXJyZW50RGlzcGF0Y2hlclJlZiBnZXRzIGluamVjdGVkIGZvciB2MTYuOCsgdG8gc3VwcG9ydCBob29rcyBpbnNwZWN0aW9uLlxuICAvLyBnZXRDdXJyZW50RmliZXIgZ2V0cyBpbmplY3RlZCBmb3IgdjE2LjkrLlxuXG5cbiAgaWYgKGN1cnJlbnREaXNwYXRjaGVyUmVmICE9IG51bGwgJiYgdHlwZW9mIGdldEN1cnJlbnRGaWJlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBfZ2V0SW50ZXJuYWxSZWFjdENvbnMgPSBPYmplY3QoX3JlbmRlcmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZ2V0SW50ZXJuYWxSZWFjdENvbnN0YW50cyAqLyBcImJcIl0pKHZlcnNpb24pLFxuICAgICAgICBSZWFjdFR5cGVPZldvcmsgPSBfZ2V0SW50ZXJuYWxSZWFjdENvbnMuUmVhY3RUeXBlT2ZXb3JrO1xuXG4gICAgaW5qZWN0ZWRSZW5kZXJlcnMuc2V0KHJlbmRlcmVyLCB7XG4gICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICBnZXRDdXJyZW50RmliZXI6IGdldEN1cnJlbnRGaWJlcixcbiAgICAgIHdvcmtUYWdNYXA6IFJlYWN0VHlwZU9mV29yayxcbiAgICAgIG9uRXJyb3JPcldhcm5pbmc6IG9uRXJyb3JPcldhcm5pbmdcbiAgICB9KTtcbiAgfVxufVxudmFyIGNvbnNvbGVTZXR0aW5nc1JlZiA9IHtcbiAgYXBwZW5kQ29tcG9uZW50U3RhY2s6IGZhbHNlLFxuICBicmVha09uQ29uc29sZUVycm9yczogZmFsc2UsXG4gIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9yczogZmFsc2UsXG4gIGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZTogZmFsc2UsXG4gIGJyb3dzZXJUaGVtZTogJ2RhcmsnXG59OyAvLyBQYXRjaGVzIGNvbnNvbGUgbWV0aG9kcyB0byBhcHBlbmQgY29tcG9uZW50IHN0YWNrIGZvciB0aGUgY3VycmVudCBmaWJlci5cbi8vIENhbGwgdW5wYXRjaCgpIHRvIHJlbW92ZSB0aGUgaW5qZWN0ZWQgYmVoYXZpb3IuXG5cbmZ1bmN0aW9uIHBhdGNoKF9yZWYpIHtcbiAgdmFyIGFwcGVuZENvbXBvbmVudFN0YWNrID0gX3JlZi5hcHBlbmRDb21wb25lbnRTdGFjayxcbiAgICAgIGJyZWFrT25Db25zb2xlRXJyb3JzID0gX3JlZi5icmVha09uQ29uc29sZUVycm9ycyxcbiAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IF9yZWYuc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzLFxuICAgICAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlID0gX3JlZi5oaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUsXG4gICAgICBicm93c2VyVGhlbWUgPSBfcmVmLmJyb3dzZXJUaGVtZTtcbiAgLy8gU2V0dGluZ3MgbWF5IGNoYW5nZSBhZnRlciB3ZSd2ZSBwYXRjaGVkIHRoZSBjb25zb2xlLlxuICAvLyBVc2luZyBhIHNoYXJlZCByZWYgYWxsb3dzIHRoZSBwYXRjaCBmdW5jdGlvbiB0byByZWFkIHRoZSBsYXRlc3QgdmFsdWVzLlxuICBjb25zb2xlU2V0dGluZ3NSZWYuYXBwZW5kQ29tcG9uZW50U3RhY2sgPSBhcHBlbmRDb21wb25lbnRTdGFjaztcbiAgY29uc29sZVNldHRpbmdzUmVmLmJyZWFrT25Db25zb2xlRXJyb3JzID0gYnJlYWtPbkNvbnNvbGVFcnJvcnM7XG4gIGNvbnNvbGVTZXR0aW5nc1JlZi5zaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPSBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnM7XG4gIGNvbnNvbGVTZXR0aW5nc1JlZi5oaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUgPSBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGU7XG4gIGNvbnNvbGVTZXR0aW5nc1JlZi5icm93c2VyVGhlbWUgPSBicm93c2VyVGhlbWU7XG5cbiAgaWYgKGFwcGVuZENvbXBvbmVudFN0YWNrIHx8IGJyZWFrT25Db25zb2xlRXJyb3JzIHx8IHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycykge1xuICAgIGlmICh1bnBhdGNoRm4gIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IHBhdGNoIHR3aWNlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbENvbnNvbGVNZXRob2RzID0ge307XG5cbiAgICB1bnBhdGNoRm4gPSBmdW5jdGlvbiB1bnBhdGNoRm4oKSB7XG4gICAgICBmb3IgKHZhciBfbWV0aG9kMiBpbiBvcmlnaW5hbENvbnNvbGVNZXRob2RzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGFyZ2V0Q29uc29sZVtfbWV0aG9kMl0gPSBvcmlnaW5hbENvbnNvbGVNZXRob2RzW19tZXRob2QyXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9WRVJSSURFX0NPTlNPTEVfTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXSA9IHRhcmdldENvbnNvbGVbbWV0aG9kXS5fX1JFQUNUX0RFVlRPT0xTX09SSUdJTkFMX01FVEhPRF9fID8gdGFyZ2V0Q29uc29sZVttZXRob2RdLl9fUkVBQ1RfREVWVE9PTFNfT1JJR0lOQUxfTUVUSE9EX18gOiB0YXJnZXRDb25zb2xlW21ldGhvZF07IC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cblxuICAgICAgICB2YXIgb3ZlcnJpZGVNZXRob2QgPSBmdW5jdGlvbiBvdmVycmlkZU1ldGhvZCgpIHtcbiAgICAgICAgICB2YXIgc2hvdWxkQXBwZW5kV2FybmluZ1N0YWNrID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ2xvZycpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlU2V0dGluZ3NSZWYuYXBwZW5kQ29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgICAgICAgdmFyIGxhc3RBcmcgPSBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICB2YXIgYWxyZWFkeUhhc0NvbXBvbmVudFN0YWNrID0gdHlwZW9mIGxhc3RBcmcgPT09ICdzdHJpbmcnICYmIGlzU3RyaW5nQ29tcG9uZW50U3RhY2sobGFzdEFyZyk7IC8vIElmIHdlIGFyZSBldmVyIGNhbGxlZCB3aXRoIGEgc3RyaW5nIHRoYXQgYWxyZWFkeSBoYXMgYSBjb21wb25lbnQgc3RhY2ssXG4gICAgICAgICAgICAgIC8vIGUuZy4gYSBSZWFjdCBlcnJvci93YXJuaW5nLCBkb24ndCBhcHBlbmQgYSBzZWNvbmQgc3RhY2suXG5cbiAgICAgICAgICAgICAgc2hvdWxkQXBwZW5kV2FybmluZ1N0YWNrID0gIWFscmVhZHlIYXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2hvdWxkU2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzID0gY29uc29sZVNldHRpbmdzUmVmLnNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyAmJiAobWV0aG9kID09PSAnZXJyb3InIHx8IG1ldGhvZCA9PT0gJ3dhcm4nKTsgLy8gU2VhcmNoIGZvciB0aGUgZmlyc3QgcmVuZGVyZXIgdGhhdCBoYXMgYSBjdXJyZW50IEZpYmVyLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGhhbmRsZSB0aGUgZWRnZSBjYXNlIG9mIHN0YWNrcyBmb3IgbW9yZSB0aGFuIG9uZSAoZS5nLiBpbnRlcmxlYXZlZCByZW5kZXJlcnM/KVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG5cbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW5qZWN0ZWRSZW5kZXJlcnMudmFsdWVzKCkpLFxuICAgICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmID0gX3N0ZXAkdmFsdWUuY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICAgICAgICAgICAgICBnZXRDdXJyZW50RmliZXIgPSBfc3RlcCR2YWx1ZS5nZXRDdXJyZW50RmliZXIsXG4gICAgICAgICAgICAgICAgICBvbkVycm9yT3JXYXJuaW5nID0gX3N0ZXAkdmFsdWUub25FcnJvck9yV2FybmluZyxcbiAgICAgICAgICAgICAgICAgIHdvcmtUYWdNYXAgPSBfc3RlcCR2YWx1ZS53b3JrVGFnTWFwO1xuICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXRjaCgpIGlzIGNhbGxlZCBieSB0d28gcGxhY2VzOiAoMSkgdGhlIGhvb2sgYW5kICgyKSB0aGUgcmVuZGVyZXIgYmFja2VuZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJhY2tlbmQgaXMgd2hhdCBpbXBsZW1lbnRzIGEgbWVzc2FnZSBxdWV1ZSwgc28gaXQncyB0aGUgb25seSBvbmUgdGhhdCBpbmplY3RzIG9uRXJyb3JPcldhcm5pbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvck9yV2FybmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3JPcldhcm5pbmcoY3VycmVudCwgbWV0aG9kLCAvLyBDb3B5IGFyZ3MgYmVmb3JlIHdlIG11dGF0ZSB0aGVtIChlLmcuIGFkZGluZyB0aGUgY29tcG9uZW50IHN0YWNrKVxuICAgICAgICAgICAgICAgICAgICAgIGFyZ3Muc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZFdhcm5pbmdTdGFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBPYmplY3QoX0RldlRvb2xzRmliZXJDb21wb25lbnRTdGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCAqLyBcImJcIl0pKHdvcmtUYWdNYXAsIGN1cnJlbnQsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50U3RhY2sgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0TW9kZU92ZXJyaWRlKGFyZ3MsIG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiAlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIC8vIERvbid0IGxldCBhIERldlRvb2xzIG9yIFJlYWN0IGludGVybmFsIGVycm9yIGludGVyZmVyZSB3aXRoIGxvZ2dpbmcuXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb25zb2xlU2V0dGluZ3NSZWYuYnJlYWtPbkNvbnNvbGVFcnJvcnMpIHtcbiAgICAgICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyB3aXRoIFJlYWN0IERldlRvb2xzIC0tLVxuICAgICAgICAgICAgLy8gVGhpcyBkZWJ1Z2dlciBzdGF0ZW1lbnQgbWVhbnMgdGhhdCB5b3UndmUgZW5hYmxlZCB0aGUgXCJicmVhayBvbiB3YXJuaW5nc1wiIGZlYXR1cmUuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGJyb3dzZXIncyBDYWxsIFN0YWNrIHBhbmVsIHRvIHN0ZXAgb3V0IG9mIHRoaXMgb3ZlcnJpZGUgZnVuY3Rpb24tXG4gICAgICAgICAgICAvLyB0byB3aGVyZSB0aGUgb3JpZ2luYWwgd2FybmluZyBvciBlcnJvciB3YXMgbG9nZ2VkLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvcmlnaW5hbE1ldGhvZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG92ZXJyaWRlTWV0aG9kLl9fUkVBQ1RfREVWVE9PTFNfT1JJR0lOQUxfTUVUSE9EX18gPSBvcmlnaW5hbE1ldGhvZDtcbiAgICAgICAgb3JpZ2luYWxNZXRob2QuX19SRUFDVF9ERVZUT09MU19PVkVSUklERV9NRVRIT0RfXyA9IG92ZXJyaWRlTWV0aG9kO1xuICAgICAgICB0YXJnZXRDb25zb2xlW21ldGhvZF0gPSBvdmVycmlkZU1ldGhvZDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHVucGF0Y2goKTtcbiAgfVxufSAvLyBSZW1vdmVkIGNvbXBvbmVudCBzdGFjayBwYXRjaCBmcm9tIGNvbnNvbGUgbWV0aG9kcy5cblxuZnVuY3Rpb24gdW5wYXRjaCgpIHtcbiAgaWYgKHVucGF0Y2hGbiAhPT0gbnVsbCkge1xuICAgIHVucGF0Y2hGbigpO1xuICAgIHVucGF0Y2hGbiA9IG51bGw7XG4gIH1cbn1cbnZhciB1bnBhdGNoRm9yU3RyaWN0TW9kZUZuID0gbnVsbDsgLy8gTk9URTogS0VFUCBJTiBTWU5DIHdpdGggc3JjL2hvb2suanM6cGF0Y2hDb25zb2xlRm9ySW5pdGlhbFJlbmRlckluU3RyaWN0TW9kZVxuXG5mdW5jdGlvbiBwYXRjaEZvclN0cmljdE1vZGUoKSB7XG4gIGlmIChyZWFjdF9kZXZ0b29sc19mZWF0dXJlX2ZsYWdzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogY29uc29sZU1hbmFnZWRCeURldlRvb2xzRHVyaW5nU3RyaWN0TW9kZSAqLyBcImFcIl0pIHtcbiAgICB2YXIgb3ZlcnJpZGVDb25zb2xlTWV0aG9kcyA9IFsnZXJyb3InLCAnZ3JvdXAnLCAnZ3JvdXBDb2xsYXBzZWQnLCAnaW5mbycsICdsb2cnLCAndHJhY2UnLCAnd2FybiddO1xuXG4gICAgaWYgKHVucGF0Y2hGb3JTdHJpY3RNb2RlRm4gIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IHBhdGNoIHR3aWNlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbENvbnNvbGVNZXRob2RzID0ge307XG5cbiAgICB1bnBhdGNoRm9yU3RyaWN0TW9kZUZuID0gZnVuY3Rpb24gdW5wYXRjaEZvclN0cmljdE1vZGVGbigpIHtcbiAgICAgIGZvciAodmFyIF9tZXRob2QzIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXJnZXRDb25zb2xlW19tZXRob2QzXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbX21ldGhvZDNdO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgb3ZlcnJpZGVDb25zb2xlTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXSA9IHRhcmdldENvbnNvbGVbbWV0aG9kXS5fX1JFQUNUX0RFVlRPT0xTX1NUUklDVF9NT0RFX09SSUdJTkFMX01FVEhPRF9fID8gdGFyZ2V0Q29uc29sZVttZXRob2RdLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1JJR0lOQUxfTUVUSE9EX18gOiB0YXJnZXRDb25zb2xlW21ldGhvZF07IC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cblxuICAgICAgICB2YXIgb3ZlcnJpZGVNZXRob2QgPSBmdW5jdGlvbiBvdmVycmlkZU1ldGhvZCgpIHtcbiAgICAgICAgICBpZiAoIWNvbnNvbGVTZXR0aW5nc1JlZi5oaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpbSB0aGUgdGV4dCBjb2xvciBvZiB0aGUgZG91YmxlIGxvZ3MgaWYgd2UncmUgbm90XG4gICAgICAgICAgICAvLyBoaWRpbmcgdGhlbS5cbiAgICAgICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxNZXRob2QoRElNTUVEX05PREVfQ09OU09MRV9DT0xPUiwgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0ICovIFwiZVwiXS5hcHBseSh2b2lkIDAsIGFyZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBjb2xvciA9IGdldENvbnNvbGVDb2xvcihtZXRob2QpO1xuXG4gICAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXRXaXRoU3R5bGVzICovIFwiZlwiXSkoYXJncywgXCJjb2xvcjogXCIuY29uY2F0KGNvbG9yKSkpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ29uc29sZSBjb2xvciBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG92ZXJyaWRlTWV0aG9kLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1JJR0lOQUxfTUVUSE9EX18gPSBvcmlnaW5hbE1ldGhvZDtcbiAgICAgICAgb3JpZ2luYWxNZXRob2QuX19SRUFDVF9ERVZUT09MU19TVFJJQ1RfTU9ERV9PVkVSUklERV9NRVRIT0RfXyA9IG92ZXJyaWRlTWV0aG9kO1xuICAgICAgICB0YXJnZXRDb25zb2xlW21ldGhvZF0gPSBvdmVycmlkZU1ldGhvZDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH0pO1xuICB9XG59IC8vIE5PVEU6IEtFRVAgSU4gU1lOQyB3aXRoIHNyYy9ob29rLmpzOnVucGF0Y2hDb25zb2xlRm9ySW5pdGlhbFJlbmRlckluU3RyaWN0TW9kZVxuXG5mdW5jdGlvbiB1bnBhdGNoRm9yU3RyaWN0TW9kZSgpIHtcbiAgaWYgKHJlYWN0X2RldnRvb2xzX2ZlYXR1cmVfZmxhZ3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBjb25zb2xlTWFuYWdlZEJ5RGV2VG9vbHNEdXJpbmdTdHJpY3RNb2RlICovIFwiYVwiXSkge1xuICAgIGlmICh1bnBhdGNoRm9yU3RyaWN0TW9kZUZuICE9PSBudWxsKSB7XG4gICAgICB1bnBhdGNoRm9yU3RyaWN0TW9kZUZuKCk7XG4gICAgICB1bnBhdGNoRm9yU3RyaWN0TW9kZUZuID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoQ29uc29sZVVzaW5nV2luZG93VmFsdWVzKCkge1xuICB2YXIgX2Nhc3RCb29sLCBfY2FzdEJvb2wyLCBfY2FzdEJvb2wzLCBfY2FzdEJvb2w0LCBfY2FzdEJyb3dzZXJUaGVtZTtcblxuICB2YXIgYXBwZW5kQ29tcG9uZW50U3RhY2sgPSAoX2Nhc3RCb29sID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGNhc3RCb29sICovIFwiYVwiXSkod2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQVBQRU5EX0NPTVBPTkVOVF9TVEFDS19fKSkgIT09IG51bGwgJiYgX2Nhc3RCb29sICE9PSB2b2lkIDAgPyBfY2FzdEJvb2wgOiB0cnVlO1xuICB2YXIgYnJlYWtPbkNvbnNvbGVFcnJvcnMgPSAoX2Nhc3RCb29sMiA9IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBjYXN0Qm9vbCAqLyBcImFcIl0pKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0JSRUFLX09OX0NPTlNPTEVfRVJST1JTX18pKSAhPT0gbnVsbCAmJiBfY2FzdEJvb2wyICE9PSB2b2lkIDAgPyBfY2FzdEJvb2wyIDogZmFsc2U7XG4gIHZhciBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPSAoX2Nhc3RCb29sMyA9IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBjYXN0Qm9vbCAqLyBcImFcIl0pKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1NIT1dfSU5MSU5FX1dBUk5JTkdTX0FORF9FUlJPUlNfXykpICE9PSBudWxsICYmIF9jYXN0Qm9vbDMgIT09IHZvaWQgMCA/IF9jYXN0Qm9vbDMgOiB0cnVlO1xuICB2YXIgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlID0gKF9jYXN0Qm9vbDQgPSBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogY2FzdEJvb2wgKi8gXCJhXCJdKSh3aW5kb3cuX19SRUFDVF9ERVZUT09MU19ISURFX0NPTlNPTEVfTE9HU19JTl9TVFJJQ1RfTU9ERV9fKSkgIT09IG51bGwgJiYgX2Nhc3RCb29sNCAhPT0gdm9pZCAwID8gX2Nhc3RCb29sNCA6IGZhbHNlO1xuICB2YXIgYnJvd3NlclRoZW1lID0gKF9jYXN0QnJvd3NlclRoZW1lID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGNhc3RCcm93c2VyVGhlbWUgKi8gXCJiXCJdKSh3aW5kb3cuX19SRUFDVF9ERVZUT09MU19CUk9XU0VSX1RIRU1FX18pKSAhPT0gbnVsbCAmJiBfY2FzdEJyb3dzZXJUaGVtZSAhPT0gdm9pZCAwID8gX2Nhc3RCcm93c2VyVGhlbWUgOiAnZGFyayc7XG4gIHBhdGNoKHtcbiAgICBhcHBlbmRDb21wb25lbnRTdGFjazogYXBwZW5kQ29tcG9uZW50U3RhY2ssXG4gICAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IGJyZWFrT25Db25zb2xlRXJyb3JzLFxuICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9yczogc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzLFxuICAgIGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZTogaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlLFxuICAgIGJyb3dzZXJUaGVtZTogYnJvd3NlclRoZW1lXG4gIH0pO1xufSAvLyBBZnRlciByZWNlaXZpbmcgY2FjaGVkIGNvbnNvbGUgcGF0Y2ggc2V0dGluZ3MgZnJvbSBSZWFjdCBOYXRpdmUsIHdlIHNldCB0aGVtIG9uIHdpbmRvdy5cbi8vIFdoZW4gdGhlIGNvbnNvbGUgaXMgaW5pdGlhbGx5IHBhdGNoZWQgKGluIHJlbmRlcmVyLmpzIGFuZCBob29rLmpzKSwgdGhlc2UgdmFsdWVzIGFyZSByZWFkLlxuLy8gVGhlIGJyb3dzZXIgZXh0ZW5zaW9uIChldGMuKSBzZXRzIHRoZXNlIHZhbHVlcyBvbiB3aW5kb3csIGJ1dCB0aHJvdWdoIGFub3RoZXIgbWV0aG9kLlxuXG5mdW5jdGlvbiB3cml0ZUNvbnNvbGVQYXRjaFNldHRpbmdzVG9XaW5kb3coc2V0dGluZ3MpIHtcbiAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQVBQRU5EX0NPTVBPTkVOVF9TVEFDS19fID0gc2V0dGluZ3MuYXBwZW5kQ29tcG9uZW50U3RhY2s7XG4gIHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0JSRUFLX09OX0NPTlNPTEVfRVJST1JTX18gPSBzZXR0aW5ncy5icmVha09uQ29uc29sZUVycm9ycztcbiAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19fID0gc2V0dGluZ3Muc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzO1xuICB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19ISURFX0NPTlNPTEVfTE9HU19JTl9TVFJJQ1RfTU9ERV9fID0gc2V0dGluZ3MuaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlO1xuICB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19CUk9XU0VSX1RIRU1FX18gPSBzZXR0aW5ncy5icm93c2VyVGhlbWU7XG59XG5mdW5jdGlvbiBpbnN0YWxsQ29uc29sZUZ1bmN0aW9uc1RvV2luZG93KCkge1xuICB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19DT05TT0xFX0ZVTkNUSU9OU19fID0ge1xuICAgIHBhdGNoQ29uc29sZVVzaW5nV2luZG93VmFsdWVzOiBwYXRjaENvbnNvbGVVc2luZ1dpbmRvd1ZhbHVlcyxcbiAgICByZWdpc3RlclJlbmRlcmVyV2l0aENvbnNvbGU6IHJlZ2lzdGVyUmVuZGVyZXJcbiAgfTtcbn1cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSkpXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGlzQXJyYXkpO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRhOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVoeWRyYXRlOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBmaWxsSW5QYXRoICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgaHlkcmF0ZSAqL1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIG1ldGEgPSB7XG4gIGluc3BlY3RhYmxlOiBTeW1ib2woJ2luc3BlY3RhYmxlJyksXG4gIGluc3BlY3RlZDogU3ltYm9sKCdpbnNwZWN0ZWQnKSxcbiAgbmFtZTogU3ltYm9sKCduYW1lJyksXG4gIHByZXZpZXdfbG9uZzogU3ltYm9sKCdwcmV2aWV3X2xvbmcnKSxcbiAgcHJldmlld19zaG9ydDogU3ltYm9sKCdwcmV2aWV3X3Nob3J0JyksXG4gIHJlYWRvbmx5OiBTeW1ib2woJ3JlYWRvbmx5JyksXG4gIHNpemU6IFN5bWJvbCgnc2l6ZScpLFxuICB0eXBlOiBTeW1ib2woJ3R5cGUnKSxcbiAgdW5zZXJpYWxpemFibGU6IFN5bWJvbCgndW5zZXJpYWxpemFibGUnKVxufTtcbi8vIFRoaXMgdGhyZXNob2xkIGRldGVybWluZXMgdGhlIGRlcHRoIGF0IHdoaWNoIHRoZSBicmlkZ2UgXCJkZWh5ZHJhdGVzXCIgbmVzdGVkIGRhdGEuXG4vLyBEZWh5ZHJhdGlvbiBtZWFucyB0aGF0IHdlIGRvbid0IHNlcmlhbGl6ZSB0aGUgZGF0YSBmb3IgZS5nLiBwb3N0TWVzc2FnZSBvciBzdHJpbmdpZnksXG4vLyB1bmxlc3MgdGhlIGZyb250ZW5kIGV4cGxpY2l0bHkgcmVxdWVzdHMgaXQgKGUuZy4gYSB1c2VyIGNsaWNrcyB0byBleHBhbmQgYSBwcm9wcyBvYmplY3QpLlxuLy9cbi8vIFJlZHVjaW5nIHRoaXMgdGhyZXNob2xkIHdpbGwgaW1wcm92ZSB0aGUgc3BlZWQgb2YgaW5pdGlhbCBjb21wb25lbnQgaW5zcGVjdGlvbixcbi8vIGJ1dCBtYXkgZGVjcmVhc2UgdGhlIHJlc3BvbnNpdmVuZXNzIG9mIGV4cGFuZGluZyBvYmplY3RzL2FycmF5cyB0byBpbnNwZWN0IGZ1cnRoZXIuXG52YXIgTEVWRUxfVEhSRVNIT0xEID0gMjtcbi8qKlxuICogR2VuZXJhdGUgdGhlIGRlaHlkcmF0ZWQgbWV0YWRhdGEgZm9yIGNvbXBsZXggb2JqZWN0IGluc3RhbmNlc1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgaW5zcGVjdGFibGUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpIHtcbiAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICB2YXIgZGVoeWRyYXRlZCA9IHtcbiAgICBpbnNwZWN0YWJsZTogaW5zcGVjdGFibGUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICBuYW1lOiAhZGF0YS5jb25zdHJ1Y3RvciB8fCBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gJycgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWVcbiAgfTtcblxuICBpZiAodHlwZSA9PT0gJ2FycmF5JyB8fCB0eXBlID09PSAndHlwZWRfYXJyYXknKSB7XG4gICAgZGVoeWRyYXRlZC5zaXplID0gZGF0YS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkZWh5ZHJhdGVkLnNpemUgPSBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2l0ZXJhdG9yJyB8fCB0eXBlID09PSAndHlwZWRfYXJyYXknKSB7XG4gICAgZGVoeWRyYXRlZC5yZWFkb25seSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZGVoeWRyYXRlZDtcbn1cbi8qKlxuICogU3RyaXAgb3V0IGNvbXBsZXggZGF0YSAoaW5zdGFuY2VzLCBmdW5jdGlvbnMsIGFuZCBkYXRhIG5lc3RlZCA+IExFVkVMX1RIUkVTSE9MRCBsZXZlbHMgZGVlcCkuXG4gKiBUaGUgcGF0aHMgb2YgdGhlIHN0cmlwcGVkIG91dCBvYmplY3RzIGFyZSBhcHBlbmRlZCB0byB0aGUgYGNsZWFuZWRgIGxpc3QuXG4gKiBPbiB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgYmFycmllciwgdGhlIGNsZWFuZWQgbGlzdCBpcyB1c2VkIHRvIFwicmUtaHlkcmF0ZVwiIHRoZSBjbGVhbmVkIHJlcHJlc2VudGF0aW9uIGludG9cbiAqIGFuIG9iamVjdCB3aXRoIHN5bWJvbHMgYXMgYXR0cmlidXRlcywgc28gdGhhdCBhIHNhbml0aXplZCBvYmplY3QgY2FuIGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBhIG5vcm1hbCBvYmplY3QuXG4gKlxuICogSW5wdXQ6IHtcInNvbWVcIjoge1wiYXR0clwiOiBmbigpfSwgXCJvdGhlclwiOiBBbkluc3RhbmNlfVxuICogT3V0cHV0OiB7XG4gKiAgIFwic29tZVwiOiB7XG4gKiAgICAgXCJhdHRyXCI6IHtcIm5hbWVcIjogdGhlIGZuLm5hbWUsIHR5cGU6IFwiZnVuY3Rpb25cIn1cbiAqICAgfSxcbiAqICAgXCJvdGhlclwiOiB7XG4gKiAgICAgXCJuYW1lXCI6IFwiQW5JbnN0YW5jZVwiLFxuICogICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICogICB9LFxuICogfVxuICogYW5kIGNsZWFuZWQgPSBbW1wic29tZVwiLCBcImF0dHJcIl0sIFtcIm90aGVyXCJdXVxuICovXG5cblxuZnVuY3Rpb24gZGVoeWRyYXRlKGRhdGEsIGNsZWFuZWQsIHVuc2VyaWFsaXphYmxlLCBwYXRoLCBpc1BhdGhBbGxvd2VkKSB7XG4gIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgdmFyIHR5cGUgPSBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2V0RGF0YVR5cGUgKi8gXCJmXCJdKShkYXRhKTtcbiAgdmFyIGlzUGF0aEFsbG93ZWRDaGVjaztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdodG1sX2VsZW1lbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudGFnTmFtZSxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiB0eXBlb2YgZGF0YS5uYW1lID09PSAnZnVuY3Rpb24nIHx8ICFkYXRhLm5hbWUgPyAnZnVuY3Rpb24nIDogZGF0YS5uYW1lLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA9IGlzUGF0aEFsbG93ZWQocGF0aCk7XG5cbiAgICAgIGlmIChpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPD0gNTAwID8gZGF0YSA6IGRhdGEuc2xpY2UoMCwgNTAwKSArICcuLi4nO1xuICAgICAgfVxuXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhLnRvU3RyaW5nKCksXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICAvLyBSZWFjdCBFbGVtZW50cyBhcmVuJ3QgdmVyeSBpbnNwZWN0b3ItZnJpZW5kbHksXG4gICAgLy8gYW5kIG9mdGVuIGNvbnRhaW4gcHJpdmF0ZSBmaWVsZHMgb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICAgIGNhc2UgJ3JlYWN0X2VsZW1lbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudCAqLyBcImlcIl0pKGRhdGEpIHx8ICdVbmtub3duJyxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICAvLyBBcnJheUJ1ZmZlcnMgZXJyb3IgaWYgeW91IHRyeSB0byBpbnNwZWN0IHRoZW0uXG5cbiAgICBjYXNlICdhcnJheV9idWZmZXInOlxuICAgIGNhc2UgJ2RhdGFfdmlldyc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogdHlwZSA9PT0gJ2RhdGFfdmlldycgPyAnRGF0YVZpZXcnIDogJ0FycmF5QnVmZmVyJyxcbiAgICAgICAgc2l6ZTogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcblxuICAgICAgaWYgKGxldmVsID49IExFVkVMX1RIUkVTSE9MRCAmJiAhaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWh5ZHJhdGVkKHR5cGUsIHRydWUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgcmV0dXJuIGRlaHlkcmF0ZShpdGVtLCBjbGVhbmVkLCB1bnNlcmlhbGl6YWJsZSwgcGF0aC5jb25jYXQoW2ldKSwgaXNQYXRoQWxsb3dlZCwgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSk7XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2h0bWxfYWxsX2NvbGxlY3Rpb24nOlxuICAgIGNhc2UgJ3R5cGVkX2FycmF5JzpcbiAgICBjYXNlICdpdGVyYXRvcic6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdW5zZXJpYWxpemFibGVWYWx1ZSA9IHtcbiAgICAgICAgICB1bnNlcmlhbGl6YWJsZTogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgIHNpemU6IHR5cGUgPT09ICd0eXBlZF9hcnJheScgPyBkYXRhLmxlbmd0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgICBuYW1lOiAhZGF0YS5jb25zdHJ1Y3RvciB8fCBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gJycgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgfTsgLy8gVFJJQ0tZXG4gICAgICAgIC8vIERvbid0IHVzZSBbLi4uc3ByZWFkXSBzeW50YXggZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHVzZXMgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tc3ByZWFkIGluIFwibG9vc2VcIiBtb2RlIHdoaWNoIG9ubHkgd29ya3Mgd2l0aCBBcnJheSB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyIHR5cGVzIChlLmcuIHR5cGVkIGFycmF5cywgU2V0cykgd2lsbCBub3Qgc3ByZWFkIGNvcnJlY3RseS5cblxuICAgICAgICBBcnJheS5mcm9tKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICByZXR1cm4gdW5zZXJpYWxpemFibGVWYWx1ZVtpXSA9IGRlaHlkcmF0ZShpdGVtLCBjbGVhbmVkLCB1bnNlcmlhbGl6YWJsZSwgcGF0aC5jb25jYXQoW2ldKSwgaXNQYXRoQWxsb3dlZCwgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuICAgICAgICByZXR1cm4gdW5zZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ29wYXF1ZV9pdGVyYXRvcic6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YVtTeW1ib2wudG9TdHJpbmdUYWddLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBmb3JtYXREYXRhRm9yUHJldmlldyAqLyBcImRcIl0pKGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhLnRvU3RyaW5nKCksXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcblxuICAgICAgaWYgKGxldmVsID49IExFVkVMX1RIUkVTSE9MRCAmJiAhaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWh5ZHJhdGVkKHR5cGUsIHRydWUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2V0QWxsRW51bWVyYWJsZUtleXMgKi8gXCJlXCJdKShkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgIG9iamVjdFtuYW1lXSA9IGRlaHlkcmF0ZShkYXRhW2tleV0sIGNsZWFuZWQsIHVuc2VyaWFsaXphYmxlLCBwYXRoLmNvbmNhdChbbmFtZV0pLCBpc1BhdGhBbGxvd2VkLCBpc1BhdGhBbGxvd2VkQ2hlY2sgPyAxIDogbGV2ZWwgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICBjYXNlICdjbGFzc19pbnN0YW5jZSc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgdW5zZXJpYWxpemFibGU6IHRydWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZm9ybWF0RGF0YUZvclByZXZpZXcgKi8gXCJkXCJdKShkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGZvcm1hdERhdGFGb3JQcmV2aWV3ICovIFwiZFwiXSkoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEuY29uc3RydWN0b3IubmFtZVxuICAgICAgfTtcbiAgICAgIE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBnZXRBbGxFbnVtZXJhYmxlS2V5cyAqLyBcImVcIl0pKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIga2V5QXNTdHJpbmcgPSBrZXkudG9TdHJpbmcoKTtcbiAgICAgICAgdmFsdWVba2V5QXNTdHJpbmddID0gZGVoeWRyYXRlKGRhdGFba2V5XSwgY2xlYW5lZCwgdW5zZXJpYWxpemFibGUsIHBhdGguY29uY2F0KFtrZXlBc1N0cmluZ10pLCBpc1BhdGhBbGxvd2VkLCBpc1BhdGhBbGxvd2VkQ2hlY2sgPyAxIDogbGV2ZWwgKyAxKTtcbiAgICAgIH0pO1xuICAgICAgdW5zZXJpYWxpemFibGUucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGNhc2UgJ2luZmluaXR5JzpcbiAgICBjYXNlICduYW4nOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAvLyBTb21lIHZhbHVlcyBhcmUgbG9zc3kgd2hlbiBzZW50IHRocm91Z2ggYSBXZWJTb2NrZXQuXG4gICAgICAvLyBXZSBkZWh5ZHJhdGUrcmVoeWRyYXRlIHRoZW0gdG8gcHJlc2VydmUgdGhlaXIgdHlwZS5cbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbGxJblBhdGgob2JqZWN0LCBkYXRhLCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdldEluT2JqZWN0ICovIFwialwiXSkob2JqZWN0LCBwYXRoKTtcblxuICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICBpZiAoIXRhcmdldFttZXRhLnVuc2VyaWFsaXphYmxlXSkge1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLmluc3BlY3RhYmxlXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5pbnNwZWN0ZWRdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLm5hbWVdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnByZXZpZXdfbG9uZ107XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEucHJldmlld19zaG9ydF07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEucmVhZG9ubHldO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnNpemVdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBkYXRhLnVuc2VyaWFsaXphYmxlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdW5zZXJpYWxpemFibGVQYXRoID0gZGF0YS51bnNlcmlhbGl6YWJsZVswXTtcbiAgICB2YXIgaXNNYXRjaCA9IHVuc2VyaWFsaXphYmxlUGF0aC5sZW5ndGggPT09IHBhdGgubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSAhPT0gdW5zZXJpYWxpemFibGVQYXRoW2ldKSB7XG4gICAgICAgIGlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZSh2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBzZXRJbk9iamVjdCAqLyBcIm9cIl0pKG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZShvYmplY3QsIGNsZWFuZWQsIHVuc2VyaWFsaXphYmxlKSB7XG4gIGNsZWFuZWQuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgbGFzdCA9IHBhdGhbbGVuZ3RoIC0gMV07XG4gICAgdmFyIHBhcmVudCA9IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBnZXRJbk9iamVjdCAqLyBcImpcIl0pKG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lmhhc093blByb3BlcnR5KGxhc3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcGFyZW50W2xhc3RdO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gJ2luZmluaXR5Jykge1xuICAgICAgcGFyZW50W2xhc3RdID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnbmFuJykge1xuICAgICAgcGFyZW50W2xhc3RdID0gTmFOO1xuICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVwbGFjZSB0aGUgc3RyaW5nIGtleXMgd2l0aCBTeW1ib2xzIHNvIHRoZXkncmUgbm9uLWVudW1lcmFibGUuXG4gICAgICB2YXIgcmVwbGFjZWQgPSB7fTtcbiAgICAgIHJlcGxhY2VkW21ldGEuaW5zcGVjdGFibGVdID0gISF2YWx1ZS5pbnNwZWN0YWJsZTtcbiAgICAgIHJlcGxhY2VkW21ldGEuaW5zcGVjdGVkXSA9IGZhbHNlO1xuICAgICAgcmVwbGFjZWRbbWV0YS5uYW1lXSA9IHZhbHVlLm5hbWU7XG4gICAgICByZXBsYWNlZFttZXRhLnByZXZpZXdfbG9uZ10gPSB2YWx1ZS5wcmV2aWV3X2xvbmc7XG4gICAgICByZXBsYWNlZFttZXRhLnByZXZpZXdfc2hvcnRdID0gdmFsdWUucHJldmlld19zaG9ydDtcbiAgICAgIHJlcGxhY2VkW21ldGEuc2l6ZV0gPSB2YWx1ZS5zaXplO1xuICAgICAgcmVwbGFjZWRbbWV0YS5yZWFkb25seV0gPSAhIXZhbHVlLnJlYWRvbmx5O1xuICAgICAgcmVwbGFjZWRbbWV0YS50eXBlXSA9IHZhbHVlLnR5cGU7XG4gICAgICBwYXJlbnRbbGFzdF0gPSByZXBsYWNlZDtcbiAgICB9XG4gIH0pO1xuICB1bnNlcmlhbGl6YWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdldEluT2JqZWN0ICovIFwialwiXSkob2JqZWN0LCBwYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcblxuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQuaGFzT3duUHJvcGVydHkobGFzdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHBhcmVudFtsYXN0XTtcblxuICAgIHZhciByZXBsYWNlbWVudCA9IF9vYmplY3RTcHJlYWQoe30sIG5vZGUpO1xuXG4gICAgdXBncmFkZVVuc2VyaWFsaXphYmxlKHJlcGxhY2VtZW50LCBub2RlKTtcbiAgICBwYXJlbnRbbGFzdF0gPSByZXBsYWNlbWVudDtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIHZhciBfT2JqZWN0JGRlZmluZVByb3BlcnQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVzdGluYXRpb24sIChfT2JqZWN0JGRlZmluZVByb3BlcnQgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS5pbnNwZWN0ZWQsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6ICEhc291cmNlLmluc3BlY3RlZFxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS5uYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBzb3VyY2UubmFtZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS5wcmV2aWV3X2xvbmcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHNvdXJjZS5wcmV2aWV3X2xvbmdcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEucHJldmlld19zaG9ydCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogc291cmNlLnByZXZpZXdfc2hvcnRcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEuc2l6ZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogc291cmNlLnNpemVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEucmVhZG9ubHksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6ICEhc291cmNlLnJlYWRvbmx5XG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLnR5cGUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHNvdXJjZS50eXBlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLnVuc2VyaWFsaXphYmxlLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiAhIXNvdXJjZS51bnNlcmlhbGl6YWJsZVxuICB9KSwgX09iamVjdCRkZWZpbmVQcm9wZXJ0KSk7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5pbnNwZWN0ZWQ7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5uYW1lO1xuICBkZWxldGUgZGVzdGluYXRpb24ucHJldmlld19sb25nO1xuICBkZWxldGUgZGVzdGluYXRpb24ucHJldmlld19zaG9ydDtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnNpemU7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5yZWFkb25seTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnR5cGU7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi51bnNlcmlhbGl6YWJsZTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29uc29sZU1hbmFnZWRCeURldlRvb2xzRHVyaW5nU3RyaWN0TW9kZTsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZW5hYmxlTG9nZ2VyICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVuYWJsZVN0eWxlWEZlYXR1cmVzOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBpc0ludGVybmFsRmFjZWJvb2tCdWlsZCAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRoaXMgZmlsZSBpcyBmb3JrZWQgYmV0d2VlbiBkaWZmZXJlbnQgRGV2VG9vbHMgaW1wbGVtZW50YXRpb25zLlxuICogSXQgc2hvdWxkIG5ldmVyIGJlIGltcG9ydGVkIGRpcmVjdGx5IVxuICogSXQgc2hvdWxkIGFsd2F5cyBiZSBpbXBvcnRlZCBmcm9tIFwicmVhY3QtZGV2dG9vbHMtZmVhdHVyZS1mbGFnc1wiLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBjb25zb2xlTWFuYWdlZEJ5RGV2VG9vbHNEdXJpbmdTdHJpY3RNb2RlID0gZmFsc2U7XG52YXIgZW5hYmxlTG9nZ2VyID0gZmFsc2U7XG52YXIgZW5hYmxlU3R5bGVYRmVhdHVyZXMgPSBmYWxzZTtcbnZhciBpc0ludGVybmFsRmFjZWJvb2tCdWlsZCA9IGZhbHNlO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRG8gbm90IGVkaXQgdGhlIGNvZGUgYmVsb3cuXG4gKiBJdCBlbnN1cmVzIHRoaXMgZm9yayBleHBvcnRzIHRoZSBzYW1lIHR5cGVzIGFzIHRoZSBkZWZhdWx0IGZsYWdzIGZpbGUuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBGbG93IG1hZ2ljIHRvIHZlcmlmeSB0aGUgZXhwb3J0cyBvZiB0aGlzIGZpbGUgbWF0Y2ggdGhlIG9yaWdpbmFsIHZlcnNpb24uXG5udWxsO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXG52YXIgTkFOID0gMCAvIDA7XG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG5cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG5cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG5cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG5cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cblxudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblxudmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGdsb2JhbCkpID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cblxudmFyIGZyZWVTZWxmID0gKHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yoc2VsZikpID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG5cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblxudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xuXG52YXIgbm93ID0gZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5cblxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cblxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcblxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTsgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cblxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7IC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7IC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG5cbiAgICByZXR1cm4gbGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgdGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCB8fCB0aW1lU2luY2VMYXN0Q2FsbCA8IDAgfHwgbWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuXG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9IC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuXG5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkOyAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuXG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuXG5cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKHZhbHVlKTtcblxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgX3R5cGVvZih2YWx1ZSkgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxuXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gX3R5cGVvZih2YWx1ZSkgPT0gJ3N5bWJvbCcgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWc7XG59XG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyBvdGhlciArICcnIDogb3RoZXI7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cblxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiBpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpIDogcmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSkpXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGdldEludGVybmFsUmVhY3RDb25zdGFudHM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gYXR0YWNoOyB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3R5cGVzLmpzXG52YXIgdHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zdG9yYWdlLmpzXG52YXIgc3RvcmFnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzLmpzICsgMSBtb2R1bGVzXG52YXIgYmFja2VuZF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMuanNcbnZhciBjb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC9Vc2Vycy9ob3h5L3JlcG9zL3JlYWN0L2J1aWxkL29zcy1leHBlcmltZW50YWwvcmVhY3QtZGVidWctdG9vbHMvaW5kZXguanNcbnZhciByZWFjdF9kZWJ1Z190b29scyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9jb25zb2xlLmpzXG52YXIgYmFja2VuZF9jb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzLmpzXG52YXIgUmVhY3RTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2NvbmZpZy9EZXZUb29sc0ZlYXR1cmVGbGFncy5jb3JlLW9zcy5qc1xudmFyIERldlRvb2xzRmVhdHVyZUZsYWdzX2NvcmVfb3NzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3NoYXJlZC9vYmplY3RJcy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG50eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzaGFyZWRfb2JqZWN0SXMgPSAob2JqZWN0SXMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vc2hhcmVkL2hhc093blByb3BlcnR5LmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eV9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzaGFyZWRfaGFzT3duUHJvcGVydHkgPSAoaGFzT3duUHJvcGVydHlfaGFzT3duUHJvcGVydHkpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2lzQXJyYXkuanNcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1N0eWxlWC91dGlscy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBjYWNoZWRTdHlsZU5hbWVUb1ZhbHVlTWFwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0U3R5bGVYRGF0YShkYXRhKSB7XG4gIHZhciBzb3VyY2VzID0gbmV3IFNldCgpO1xuICB2YXIgcmVzb2x2ZWRTdHlsZXMgPSB7fTtcbiAgY3Jhd2xEYXRhKGRhdGEsIHNvdXJjZXMsIHJlc29sdmVkU3R5bGVzKTtcbiAgcmV0dXJuIHtcbiAgICBzb3VyY2VzOiBBcnJheS5mcm9tKHNvdXJjZXMpLnNvcnQoKSxcbiAgICByZXNvbHZlZFN0eWxlczogcmVzb2x2ZWRTdHlsZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyYXdsRGF0YShkYXRhLCBzb3VyY2VzLCByZXNvbHZlZFN0eWxlcykge1xuICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKE9iamVjdChpc0FycmF5W1wiYVwiIC8qIGRlZmF1bHQgKi9dKShkYXRhKSkge1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdChpc0FycmF5W1wiYVwiIC8qIGRlZmF1bHQgKi9dKShlbnRyeSkpIHtcbiAgICAgICAgY3Jhd2xEYXRhKGVudHJ5LCBzb3VyY2VzLCByZXNvbHZlZFN0eWxlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmF3bE9iamVjdFByb3BlcnRpZXMoZW50cnksIHNvdXJjZXMsIHJlc29sdmVkU3R5bGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjcmF3bE9iamVjdFByb3BlcnRpZXMoZGF0YSwgc291cmNlcywgcmVzb2x2ZWRTdHlsZXMpO1xuICB9XG5cbiAgcmVzb2x2ZWRTdHlsZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmVzb2x2ZWRTdHlsZXMpLnNvcnQoKSk7XG59XG5cbmZ1bmN0aW9uIGNyYXdsT2JqZWN0UHJvcGVydGllcyhlbnRyeSwgc291cmNlcywgcmVzb2x2ZWRTdHlsZXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnRyeSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gZW50cnlba2V5XTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoa2V5ID09PSB2YWx1ZSkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U7IHRoaXMga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBzdHlsZSdzIHNvdXJjZS9maWxlL21vZHVsZS5cbiAgICAgICAgc291cmNlcy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gZ2V0UHJvcGVydHlWYWx1ZUZvclN0eWxlTmFtZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc29sdmVkU3R5bGVzW2tleV0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXN0ZWRTdHlsZSA9IHt9O1xuICAgICAgcmVzb2x2ZWRTdHlsZXNba2V5XSA9IG5lc3RlZFN0eWxlO1xuICAgICAgY3Jhd2xEYXRhKFt2YWx1ZV0sIHNvdXJjZXMsIG5lc3RlZFN0eWxlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlRm9yU3R5bGVOYW1lKHN0eWxlTmFtZSkge1xuICBpZiAoY2FjaGVkU3R5bGVOYW1lVG9WYWx1ZU1hcC5oYXMoc3R5bGVOYW1lKSkge1xuICAgIHJldHVybiBjYWNoZWRTdHlsZU5hbWVUb1ZhbHVlTWFwLmdldChzdHlsZU5hbWUpO1xuICB9XG5cbiAgZm9yICh2YXIgc3R5bGVTaGVldEluZGV4ID0gMDsgc3R5bGVTaGVldEluZGV4IDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBzdHlsZVNoZWV0SW5kZXgrKykge1xuICAgIHZhciBzdHlsZVNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbc3R5bGVTaGVldEluZGV4XTtcbiAgICB2YXIgcnVsZXMgPSBudWxsOyAvLyB0aGlzIG1pZ2h0IHRocm93IGlmIENPUlMgcnVsZXMgYXJlIGVuZm9yY2VkIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3NvbS0xLyN0aGUtY3Nzc3R5bGVzaGVldC1pbnRlcmZhY2VcblxuICAgIHRyeSB7XG4gICAgICBydWxlcyA9IHN0eWxlU2hlZXQuY3NzUnVsZXM7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIHJ1bGVJbmRleCA9IDA7IHJ1bGVJbmRleCA8IHJ1bGVzLmxlbmd0aDsgcnVsZUluZGV4KyspIHtcbiAgICAgIGlmICghKHJ1bGVzW3J1bGVJbmRleF0gaW5zdGFuY2VvZiBDU1NTdHlsZVJ1bGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcnVsZSA9IHJ1bGVzW3J1bGVJbmRleF07XG4gICAgICB2YXIgY3NzVGV4dCA9IHJ1bGUuY3NzVGV4dCxcbiAgICAgICAgICBzZWxlY3RvclRleHQgPSBydWxlLnNlbGVjdG9yVGV4dCxcbiAgICAgICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG5cbiAgICAgIGlmIChzZWxlY3RvclRleHQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoc2VsZWN0b3JUZXh0LnN0YXJ0c1dpdGgoXCIuXCIuY29uY2F0KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gY3NzVGV4dC5tYXRjaCgveyAqKFthLXpcXC1dKyk6Lyk7XG5cbiAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgICAgICAgICBjYWNoZWRTdHlsZU5hbWVUb1ZhbHVlTWFwLnNldChzdHlsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3NoYXJlZC9pc0FycmF5LmpzXG52YXIgc2hhcmVkX2lzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL2NvbnN0YW50cy5qc1xudmFyIENIQU5HRV9MT0dfVVJMID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtZGV2dG9vbHMvQ0hBTkdFTE9HLm1kJztcbnZhciBVTlNVUFBPUlRFRF9WRVJTSU9OX1VSTCA9ICdodHRwczovL3JlYWN0anMub3JnL2Jsb2cvMjAxOS8wOC8xNS9uZXctcmVhY3QtZGV2dG9vbHMuaHRtbCNob3ctZG8taS1nZXQtdGhlLW9sZC12ZXJzaW9uLWJhY2snO1xudmFyIFJFQUNUX0RFVlRPT0xTX1dPUktQTEFDRV9VUkwgPSAnaHR0cHM6Ly9mYnVybC5jb20vcmVhY3QtZGV2dG9vbHMtd29ya3BsYWNlLWdyb3VwJztcbnZhciBUSEVNRV9TVFlMRVMgPSB7XG4gIGxpZ2h0OiB7XG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUnOiAnI2VmNjYzMicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUtbm90LWVkaXRhYmxlJzogJyMyMzI3MmYnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lLWludmVydGVkJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLXZhbHVlJzogJyMxYTFhYTYnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZS1pbnZlcnRlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtZWRpdGFibGUtdmFsdWUnOiAnIzFhMWFhNicsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWhvdmVyJzogJ3JnYmEoMCwgMTM2LCAyNTAsIDAuMSknLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaW5hY3RpdmUnOiAnI2U1ZTVlNScsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1pbnZhbGlkJzogJyNmZmYwZjAnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWJhY2tncm91bmQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYnV0dG9uLWJhY2tncm91bmQtZm9jdXMnOiAnI2VkZWRlZCcsXG4gICAgJy0tY29sb3ItYnV0dG9uJzogJyM1ZjY2NzMnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1kaXNhYmxlZCc6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci1idXR0b24tYWN0aXZlJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1mb2N1cyc6ICcjMjMyNzJmJyxcbiAgICAnLS1jb2xvci1idXR0b24taG92ZXInOiAnIzIzMjcyZicsXG4gICAgJy0tY29sb3ItYm9yZGVyJzogJyNlZWVlZWUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1maWxsJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1maWxsLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLXBhdHRlcm4nOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLXBhdHRlcm4tdGV4dCc6ICcjMzMzMzMzJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMCc6ICcjMzdhZmE5JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMSc6ICcjNjNiMTllJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMic6ICcjODBiMzkzJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMyc6ICcjOTdiNDg4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNCc6ICcjYWJiNjdkJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNSc6ICcjYmViNzcxJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNic6ICcjY2ZiOTY1JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNyc6ICcjZGZiYTU3JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtOCc6ICcjZWZiYjQ5JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtOSc6ICcjZmViYzM4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtbmFtZSc6ICcjNmE1MWIyJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtbmFtZS1pbnZlcnRlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtYmFja2dyb3VuZCc6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1iYWNrZ3JvdW5kLWludmVydGVkJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNSknLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1jb3VudCc6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtY291bnQtaW52ZXJ0ZWQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJhZGdlLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1iYWNrZ3JvdW5kJzogJyNmZmYwZjAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYm9yZGVyJzogJyNmZmQ2ZDYnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItaWNvbic6ICcjZWIzOTQxJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLXRleHQnOiAnI2ZlMmUzMScsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWJhZGdlLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWJhY2tncm91bmQnOiAnI2ZmZmJlNScsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWJvcmRlcic6ICcjZmZmNWMxJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctaWNvbic6ICcjZjRiZDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctdGV4dCc6ICcjNjQ0NjBjJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQnOiAncmdiYSgwLDAsMCwuOSknLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZC1ob3Zlcic6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSknLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZC1zZWxlY3RlZCc6ICcjMTc4ZmI5JyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJvcmRlcic6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0LXNlbGVjdGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWRpbSc6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci1kaW1tZXInOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItZGltbWVzdCc6ICcjZWZmMGYxJyxcbiAgICAnLS1jb2xvci1lcnJvci1iYWNrZ3JvdW5kJzogJ2hzbCgwLCAxMDAlLCA5NyUpJyxcbiAgICAnLS1jb2xvci1lcnJvci1ib3JkZXInOiAnaHNsKDAsIDEwMCUsIDkyJSknLFxuICAgICctLWNvbG9yLWVycm9yLXRleHQnOiAnI2ZmMDAwMCcsXG4gICAgJy0tY29sb3ItZXhwYW5kLWNvbGxhcHNlLXRvZ2dsZSc6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci1saW5rJzogJyMwMDAwZmYnLFxuICAgICctLWNvbG9yLW1vZGFsLWJhY2tncm91bmQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgJy0tY29sb3ItYnJpZGdlLXZlcnNpb24tbnBtLWJhY2tncm91bmQnOiAnI2VmZjBmMScsXG4gICAgJy0tY29sb3ItYnJpZGdlLXZlcnNpb24tbnBtLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItYnJpZGdlLXZlcnNpb24tbnVtYmVyJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLWJhY2tncm91bmQnOiAnI2U1ZTVlNScsXG4gICAgJy0tY29sb3ItcHJpbWl0aXZlLWhvb2stYmFkZ2UtdGV4dCc6ICcjNWY2NjczJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtYWN0aXZlJzogJyNmYzNhNGInLFxuICAgICctLWNvbG9yLXJlY29yZC1ob3Zlcic6ICcjMzU3OGU1JyxcbiAgICAnLS1jb2xvci1yZWNvcmQtaW5hY3RpdmUnOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWFjdGl2ZSc6ICcjZGNkY2RjJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWJvcmRlcic6ICcjZDFkMWQxJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWRvdCc6ICcjMzMzMzMzJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUnOiAnI2QxZDFkMScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlLWhvdmVyJzogJyNjOWM5YzknLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZS10ZXh0JzogJyM0NDQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5hdGl2ZS1ldmVudCc6ICcjY2NjJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uYXRpdmUtZXZlbnQtaG92ZXInOiAnI2FhYScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1wcmltYXJ5JzogJyNmY2YzZGMnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstcHJpbWFyeS1ob3Zlcic6ICcjZjBlN2QxJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXNlY29uZGFyeSc6ICcjZWZjNDU3JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXNlY29uZGFyeS1ob3Zlcic6ICcjZTNiYTUyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1wcmlvcml0eS1iYWNrZ3JvdW5kJzogJyNmNmY2ZjYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXByaW9yaXR5LWJvcmRlcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS11c2VyLXRpbWluZyc6ICcjYzljYWNkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS11c2VyLXRpbWluZy1ob3Zlcic6ICcjOTM5NTlhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1pZGxlJzogJyNkM2U1ZjYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWlkbGUtaG92ZXInOiAnI2MzZDllZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyJzogJyM5ZmMzZjMnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlci1ob3Zlcic6ICcjODNhZmU5JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXItdGV4dCc6ICcjMTEzNjVlJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQnOiAnI2M4OGZmMCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0LWhvdmVyJzogJyNiMjgxZDYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdC10ZXh0JzogJyMzZTJjNGEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWxheW91dC1lZmZlY3RzJzogJyNiMjgxZDYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWxheW91dC1lZmZlY3RzLWhvdmVyJzogJyM5ZDcxYmQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWxheW91dC1lZmZlY3RzLXRleHQnOiAnIzNlMmM0YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzJzogJyNiMjgxZDYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cy1ob3Zlcic6ICcjOWQ3MWJkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMtdGV4dCc6ICcjM2UyYzRhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zY2hlZHVsZSc6ICcjOWZjM2YzJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zY2hlZHVsZS1ob3Zlcic6ICcjMjY4M0UyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZWplY3RlZCc6ICcjZjFjYzE0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZWplY3RlZC1ob3Zlcic6ICcjZmZkZjM3JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZXNvbHZlZCc6ICcjYTZlNTlmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZXNvbHZlZC1ob3Zlcic6ICcjODlkMjgxJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS11bnJlc29sdmVkJzogJyNjOWNhY2QnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXVucmVzb2x2ZWQtaG92ZXInOiAnIzkzOTU5YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGhyb3duLWVycm9yJzogJyNlZTE2MzgnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRocm93bi1lcnJvci1ob3Zlcic6ICcjZGExMDMwJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10ZXh0LWNvbG9yJzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRleHQtZGltLWNvbG9yJzogJyNjY2MnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXdvcmstYm9yZGVyJzogJyNlZWVlZWUnLFxuICAgICctLWNvbG9yLXNlYXJjaC1tYXRjaCc6ICd5ZWxsb3cnLFxuICAgICctLWNvbG9yLXNlYXJjaC1tYXRjaC1jdXJyZW50JzogJyNmNzkyM2InLFxuICAgICctLWNvbG9yLXNlbGVjdGVkLXRyZWUtaGlnaGxpZ2h0LWFjdGl2ZSc6ICdyZ2JhKDAsIDEzNiwgMjUwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1zZWxlY3RlZC10cmVlLWhpZ2hsaWdodC1pbmFjdGl2ZSc6ICdyZ2JhKDAsIDAsIDAsIDAuMDUpJyxcbiAgICAnLS1jb2xvci1zY3JvbGwtY2FyZXQnOiAncmdiYSgxNTAsIDE1MCwgMTUwLCAwLjUpJyxcbiAgICAnLS1jb2xvci10YWItc2VsZWN0ZWQtYm9yZGVyJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItdGV4dC1pbnZhbGlkJzogJyNmZjAwMDAnLFxuICAgICctLWNvbG9yLXRleHQtc2VsZWN0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtaW52YWxpZCc6ICcjZmMzYTRiJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1vbic6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1vZmYnOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItdG9nZ2xlLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kJzogJyNmYjM2NTUnLFxuICAgICctLWNvbG9yLXdhcm5pbmctYmFja2dyb3VuZC1ob3Zlcic6ICcjZjgyMDQyJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLXRleHQtY29sb3InOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3Itd2FybmluZy10ZXh0LWNvbG9yLWludmVydGVkJzogJyNmZDRkNjknLFxuICAgIC8vIFRoZSBzdHlsZXMgYmVsb3cgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoICdyb290LmNzcydcbiAgICAvLyBUaGV5IGFyZSByZXBlYXRlZCB0aGVyZSBiZWNhdXNlIHRoZXkncmUgdXNlZCBieSBlLmcuIHRvb2x0aXBzIG9yIGNvbnRleHQgbWVudXNcbiAgICAvLyB3aGljaCBnZXQgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgRE9NIHN1YnRyZWUgKHdoZXJlIG5vcm1hbCB0aGVtZS9zdHlsZXMgYXJlIHdyaXR0ZW4pLlxuICAgICctLWNvbG9yLXNjcm9sbC10aHVtYic6ICcjYzJjMmMyJyxcbiAgICAnLS1jb2xvci1zY3JvbGwtdHJhY2snOiAnI2ZhZmFmYScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC45KScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC10ZXh0JzogJyNmZmZmZmYnXG4gIH0sXG4gIGRhcms6IHtcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZSc6ICcjOWQ4N2QyJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZS1ub3QtZWRpdGFibGUnOiAnI2VkZWRlZCcsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUtaW52ZXJ0ZWQnOiAnIzI4MjgyOCcsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLXZhbHVlJzogJyNjZWRhZTAnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZS1pbnZlcnRlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtZWRpdGFibGUtdmFsdWUnOiAneWVsbG93JyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaG92ZXInOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWluYWN0aXZlJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaW52YWxpZCc6ICcjNWMwMDAwJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLXNlbGVjdGVkJzogJyMxNzhmYjknLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kLWZvY3VzJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLWJ1dHRvbic6ICcjYWZiM2I5JyxcbiAgICAnLS1jb2xvci1idXR0b24tYWN0aXZlJzogJyM2MWRhZmInLFxuICAgICctLWNvbG9yLWJ1dHRvbi1kaXNhYmxlZCc6ICcjNGY1NzY2JyxcbiAgICAnLS1jb2xvci1idXR0b24tZm9jdXMnOiAnI2EyZTlmYycsXG4gICAgJy0tY29sb3ItYnV0dG9uLWhvdmVyJzogJyNlZGVkZWQnLFxuICAgICctLWNvbG9yLWJvcmRlcic6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbCc6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuJzogJyM2NjZjNzcnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTAnOiAnIzM3YWZhOScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTEnOiAnIzYzYjE5ZScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTInOiAnIzgwYjM5MycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTMnOiAnIzk3YjQ4OCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTQnOiAnI2FiYjY3ZCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTUnOiAnI2JlYjc3MScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTYnOiAnI2NmYjk2NScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTcnOiAnI2RmYmE1NycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTgnOiAnI2VmYmI0OScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTknOiAnI2ZlYmMzOCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUnOiAnIzYxZGFmYicsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUtaW52ZXJ0ZWQnOiAnIzI4MjgyOCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWJhY2tncm91bmQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KScsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWJhY2tncm91bmQtaW52ZXJ0ZWQnOiAncmdiYSgwLCAwLCAwLCAwLjI1KScsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWNvdW50JzogJyM4Zjk0OWQnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1jb3VudC1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFkZ2UtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJhY2tncm91bmQnOiAnIzI5MDAwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1ib3JkZXInOiAnIzVjMDAwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1pY29uJzogJyNlYjM5NDEnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItdGV4dCc6ICcjZmM3ZjdmJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYmFkZ2UtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYmFja2dyb3VuZCc6ICcjMzMyYjAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYm9yZGVyJzogJyM2NjU1MDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1pY29uJzogJyNmNGJkMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy10ZXh0JzogJyNmNWYyZWQnLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZCc6ICdyZ2JhKDI1NSwyNTUsMjU1LC45NSknLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZC1ob3Zlcic6ICdyZ2JhKDAsIDEzNiwgMjUwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItY29udGV4dC1ib3JkZXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnRleHQtdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1kaW0nOiAnIzhmOTQ5ZCcsXG4gICAgJy0tY29sb3ItZGltbWVyJzogJyM3NzdkODgnLFxuICAgICctLWNvbG9yLWRpbW1lc3QnOiAnIzRmNTc2NicsXG4gICAgJy0tY29sb3ItZXJyb3ItYmFja2dyb3VuZCc6ICcjMjAwJyxcbiAgICAnLS1jb2xvci1lcnJvci1ib3JkZXInOiAnIzkwMCcsXG4gICAgJy0tY29sb3ItZXJyb3ItdGV4dCc6ICcjZjU1JyxcbiAgICAnLS1jb2xvci1leHBhbmQtY29sbGFwc2UtdG9nZ2xlJzogJyM4Zjk0OWQnLFxuICAgICctLWNvbG9yLWxpbmsnOiAnIzYxZGFmYicsXG4gICAgJy0tY29sb3ItbW9kYWwtYmFja2dyb3VuZCc6ICdyZ2JhKDAsIDAsIDAsIDAuNzUpJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1ucG0tYmFja2dyb3VuZCc6ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1ucG0tdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1udW1iZXInOiAneWVsbG93JyxcbiAgICAnLS1jb2xvci1wcmltaXRpdmUtaG9vay1iYWRnZS1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLXRleHQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtYWN0aXZlJzogJyNmYzNhNGInLFxuICAgICctLWNvbG9yLXJlY29yZC1ob3Zlcic6ICcjYTJlOWZjJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtaW5hY3RpdmUnOiAnIzYxZGFmYicsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhcic6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWFjdGl2ZSc6ICcjMzEzNjNmJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWJvcmRlcic6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWRvdCc6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUnOiAnIzMwMzU0MicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlLWhvdmVyJzogJyMzNjNiNGEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZS10ZXh0JzogJyM3Zjg4OTknLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5hdGl2ZS1ldmVudCc6ICcjYjJiMmIyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uYXRpdmUtZXZlbnQtaG92ZXInOiAnIzk0OTQ5NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1wcmltYXJ5JzogJyNmY2YzZGMnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstcHJpbWFyeS1ob3Zlcic6ICcjZTNkYmM1JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXNlY29uZGFyeSc6ICcjZWZjNDU3JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXNlY29uZGFyeS1ob3Zlcic6ICcjZDZhZjRkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1wcmlvcml0eS1iYWNrZ3JvdW5kJzogJyMxZDIxMjknLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXByaW9yaXR5LWJvcmRlcic6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS11c2VyLXRpbWluZyc6ICcjYzljYWNkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS11c2VyLXRpbWluZy1ob3Zlcic6ICcjOTM5NTlhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1pZGxlJzogJyMzZDQ4NWInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWlkbGUtaG92ZXInOiAnIzQ2NTI2OScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyJzogJyMyNjgzRTInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlci1ob3Zlcic6ICcjMWE3NmQ0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXItdGV4dCc6ICcjMTEzNjVlJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQnOiAnIzczMWZhZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0LWhvdmVyJzogJyM2MTFiOTQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdC10ZXh0JzogJyNlNWMxZmYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWxheW91dC1lZmZlY3RzJzogJyM2MTFiOTQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWxheW91dC1lZmZlY3RzLWhvdmVyJzogJyM1MTE2N2EnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWxheW91dC1lZmZlY3RzLXRleHQnOiAnI2U1YzFmZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzJzogJyM2MTFiOTQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cy1ob3Zlcic6ICcjNTExNjdhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMtdGV4dCc6ICcjZTVjMWZmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zY2hlZHVsZSc6ICcjMjY4M0UyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zY2hlZHVsZS1ob3Zlcic6ICcjMWE3NmQ0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZWplY3RlZCc6ICcjZjFjYzE0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZWplY3RlZC1ob3Zlcic6ICcjZTRjMDBmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZXNvbHZlZCc6ICcjYTZlNTlmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS1yZXNvbHZlZC1ob3Zlcic6ICcjODlkMjgxJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS11bnJlc29sdmVkJzogJyNjOWNhY2QnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXVucmVzb2x2ZWQtaG92ZXInOiAnIzkzOTU5YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGhyb3duLWVycm9yJzogJyNmYjM2NTUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRocm93bi1lcnJvci1ob3Zlcic6ICcjZjgyMDQyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10ZXh0LWNvbG9yJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRleHQtZGltLWNvbG9yJzogJyM1NTViNjYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXdvcmstYm9yZGVyJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLXNlYXJjaC1tYXRjaCc6ICd5ZWxsb3cnLFxuICAgICctLWNvbG9yLXNlYXJjaC1tYXRjaC1jdXJyZW50JzogJyNmNzkyM2InLFxuICAgICctLWNvbG9yLXNlbGVjdGVkLXRyZWUtaGlnaGxpZ2h0LWFjdGl2ZSc6ICdyZ2JhKDIzLCAxNDMsIDE4NSwgMC4xNSknLFxuICAgICctLWNvbG9yLXNlbGVjdGVkLXRyZWUtaGlnaGxpZ2h0LWluYWN0aXZlJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSknLFxuICAgICctLWNvbG9yLXNjcm9sbC1jYXJldCc6ICcjNGY1NzY2JyxcbiAgICAnLS1jb2xvci1zaGFkb3cnOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICAnLS1jb2xvci10YWItc2VsZWN0ZWQtYm9yZGVyJzogJyMxNzhmYjknLFxuICAgICctLWNvbG9yLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItdGV4dC1pbnZhbGlkJzogJyNmZjgwODAnLFxuICAgICctLWNvbG9yLXRleHQtc2VsZWN0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtaW52YWxpZCc6ICcjZmMzYTRiJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1vbic6ICcjMTc4ZmI5JyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1vZmYnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItdG9nZ2xlLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kJzogJyNlZTE2MzgnLFxuICAgICctLWNvbG9yLXdhcm5pbmctYmFja2dyb3VuZC1ob3Zlcic6ICcjZGExMDMwJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLXRleHQtY29sb3InOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3Itd2FybmluZy10ZXh0LWNvbG9yLWludmVydGVkJzogJyNlZTE2MzgnLFxuICAgIC8vIFRoZSBzdHlsZXMgYmVsb3cgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoICdyb290LmNzcydcbiAgICAvLyBUaGV5IGFyZSByZXBlYXRlZCB0aGVyZSBiZWNhdXNlIHRoZXkncmUgdXNlZCBieSBlLmcuIHRvb2x0aXBzIG9yIGNvbnRleHQgbWVudXNcbiAgICAvLyB3aGljaCBnZXQgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgRE9NIHN1YnRyZWUgKHdoZXJlIG5vcm1hbCB0aGVtZS9zdHlsZXMgYXJlIHdyaXR0ZW4pLlxuICAgICctLWNvbG9yLXNjcm9sbC10aHVtYic6ICcjYWZiM2I5JyxcbiAgICAnLS1jb2xvci1zY3JvbGwtdHJhY2snOiAnIzMxMzY0MCcsXG4gICAgJy0tY29sb3ItdG9vbHRpcC1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSknLFxuICAgICctLWNvbG9yLXRvb2x0aXAtdGV4dCc6ICcjMDAwMDAwJ1xuICB9LFxuICBjb21wYWN0OiB7XG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1zbWFsbCc6ICc5cHgnLFxuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2Utbm9ybWFsJzogJzExcHgnLFxuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2UtbGFyZ2UnOiAnMTVweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtc21hbGwnOiAnMTBweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbm9ybWFsJzogJzEycHgnLFxuICAgICctLWZvbnQtc2l6ZS1zYW5zLWxhcmdlJzogJzE0cHgnLFxuICAgICctLWxpbmUtaGVpZ2h0LWRhdGEnOiAnMThweCdcbiAgfSxcbiAgY29tZm9ydGFibGU6IHtcbiAgICAnLS1mb250LXNpemUtbW9ub3NwYWNlLXNtYWxsJzogJzEwcHgnLFxuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2Utbm9ybWFsJzogJzEzcHgnLFxuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2UtbGFyZ2UnOiAnMTdweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtc21hbGwnOiAnMTJweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbm9ybWFsJzogJzE0cHgnLFxuICAgICctLWZvbnQtc2l6ZS1zYW5zLWxhcmdlJzogJzE2cHgnLFxuICAgICctLWxpbmUtaGVpZ2h0LWRhdGEnOiAnMjJweCdcbiAgfVxufTsgLy8gSEFDS1xuLy9cbi8vIFNvbWV0aW1lcyB0aGUgaW5saW5lIHRhcmdldCBpcyByZW5kZXJlZCBiZWZvcmUgcm9vdCBzdHlsZXMgYXJlIGFwcGxpZWQsXG4vLyB3aGljaCB3b3VsZCByZXN1bHQgaW4gZS5nLiBOYU4gaXRlbVNpemUgYmVpbmcgcGFzc2VkIHRvIHJlYWN0LXdpbmRvdyBsaXN0LlxuXG52YXIgQ09NRk9SVEFCTEVfTElORV9IRUlHSFQgPSBwYXJzZUludChUSEVNRV9TVFlMRVMuY29tZm9ydGFibGVbJy0tbGluZS1oZWlnaHQtZGF0YSddLCAxMCk7XG52YXIgQ09NUEFDVF9MSU5FX0hFSUdIVCA9IHBhcnNlSW50KFRIRU1FX1NUWUxFUy5jb21wYWN0WyctLWxpbmUtaGVpZ2h0LWRhdGEnXSwgMTApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy10aW1lbGluZS9zcmMvY29uc3RhbnRzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIFJFQUNUX1RPVEFMX05VTV9MQU5FUyA9IDMxOyAvLyBJbmNyZW1lbnQgdGhpcyBudW1iZXIgYW55IHRpbWUgYSBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIHByb2ZpbGVyIG1ldGFkYXRhLlxuXG52YXIgU0NIRURVTElOR19QUk9GSUxFUl9WRVJTSU9OID0gMTtcbnZhciBTTkFQU0hPVF9NQVhfSEVJR0hUID0gNjA7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9EZXZUb29sc0ZpYmVyQ29tcG9uZW50U3RhY2suanMgKyAyIG1vZHVsZXNcbnZhciBEZXZUb29sc0ZpYmVyQ29tcG9uZW50U3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3Byb2ZpbGluZ0hvb2tzLmpzXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cbiAvLyBBZGQgcGFkZGluZyB0byB0aGUgc3RhcnQvc3RvcCB0aW1lIG9mIHRoZSBwcm9maWxlLlxuLy8gVGhpcyBtYWtlcyB0aGUgVUkgbmljZXIgdG8gdXNlLlxuXG52YXIgVElNRV9PRkZTRVQgPSAxMDtcbnZhciBwZXJmb3JtYW5jZVRhcmdldCA9IG51bGw7IC8vIElmIHBlcmZvcm1hbmNlIGV4aXN0cyBhbmQgc3VwcG9ydHMgdGhlIHN1YnNldCBvZiB0aGUgVXNlciBUaW1pbmcgQVBJIHRoYXQgd2UgcmVxdWlyZS5cblxudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbic7XG52YXIgc3VwcG9ydHNVc2VyVGltaW5nVjMgPSBmYWxzZTtcblxuaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICB2YXIgQ0hFQ0tfVjNfTUFSSyA9ICdfX3YzJztcbiAgdmFyIG1hcmtPcHRpb25zID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXJrT3B0aW9ucywgJ3N0YXJ0VGltZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHN1cHBvcnRzVXNlclRpbWluZ1YzID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7fVxuICB9KTtcblxuICB0cnkge1xuICAgIC8vICRGbG93Rml4TWVbZXh0cmEtYXJnXTogRmxvdyBleHBlY3RzIHRoZSBVc2VyIFRpbWluZyBsZXZlbCAyIEFQSS5cbiAgICBwZXJmb3JtYW5jZS5tYXJrKENIRUNLX1YzX01BUkssIG1hcmtPcHRpb25zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBJZ25vcmVcbiAgfSBmaW5hbGx5IHtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKENIRUNLX1YzX01BUkspO1xuICB9XG59XG5cbmlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICBwZXJmb3JtYW5jZVRhcmdldCA9IHBlcmZvcm1hbmNlO1xufSAvLyBTb21lIGVudmlyb25tZW50cyAoZS5nLiBSZWFjdCBOYXRpdmUgLyBIZXJtZXMpIGRvbid0IHN1cHBvcnQgdGhlIHBlcmZvcm1hbmNlIEFQSSB5ZXQuXG5cblxudmFyIGdldEN1cnJlbnRUaW1lID0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHBlcmZvcm1hbmNlKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTsgLy8gTW9ja2luZyB0aGUgUGVyZm9ybWFuY2UgT2JqZWN0IChhbmQgVXNlciBUaW1pbmcgQVBJcykgZm9yIHRlc3RpbmcgaXMgZnJhZ2lsZS5cbi8vIFRoaXMgQVBJIGFsbG93cyB0ZXN0cyB0byBkaXJlY3RseSBvdmVycmlkZSB0aGUgVXNlciBUaW1pbmcgQVBJcy5cblxuZnVuY3Rpb24gc2V0UGVyZm9ybWFuY2VNb2NrX09OTFlfRk9SX1RFU1RJTkcocGVyZm9ybWFuY2VNb2NrKSB7XG4gIHBlcmZvcm1hbmNlVGFyZ2V0ID0gcGVyZm9ybWFuY2VNb2NrO1xuICBzdXBwb3J0c1VzZXJUaW1pbmcgPSBwZXJmb3JtYW5jZU1vY2sgIT09IG51bGw7XG4gIHN1cHBvcnRzVXNlclRpbWluZ1YzID0gcGVyZm9ybWFuY2VNb2NrICE9PSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZmlsaW5nSG9va3MoX3JlZikge1xuICB2YXIgZ2V0RGlzcGxheU5hbWVGb3JGaWJlciA9IF9yZWYuZ2V0RGlzcGxheU5hbWVGb3JGaWJlcixcbiAgICAgIGdldElzUHJvZmlsaW5nID0gX3JlZi5nZXRJc1Byb2ZpbGluZyxcbiAgICAgIGdldExhbmVMYWJlbE1hcCA9IF9yZWYuZ2V0TGFuZUxhYmVsTWFwLFxuICAgICAgd29ya1RhZ01hcCA9IF9yZWYud29ya1RhZ01hcCxcbiAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmID0gX3JlZi5jdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgIHJlYWN0VmVyc2lvbiA9IF9yZWYucmVhY3RWZXJzaW9uO1xuICB2YXIgY3VycmVudEJhdGNoVUlEID0gMDtcbiAgdmFyIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICB2YXIgY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjayA9IFtdO1xuICB2YXIgY3VycmVudFRpbWVsaW5lRGF0YSA9IG51bGw7XG4gIHZhciBjdXJyZW50RmliZXJTdGFja3MgPSBuZXcgTWFwKCk7XG4gIHZhciBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICB2YXIgbmV4dFJlbmRlclNob3VsZFN0YXJ0TmV3QmF0Y2ggPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnZXRSZWxhdGl2ZVRpbWUoKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YS5zdGFydFRpbWUgPT09IDApIHtcbiAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5zdGFydFRpbWUgPSBjdXJyZW50VGltZSAtIFRJTUVfT0ZGU0VUO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgLSBjdXJyZW50VGltZWxpbmVEYXRhLnN0YXJ0VGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEludGVybmFsTW9kdWxlUmFuZ2VzKCkge1xuICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5nZXRJbnRlcm5hbE1vZHVsZVJhbmdlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQXNrIHRoZSBEZXZUb29scyBob29rIGZvciBtb2R1bGUgcmFuZ2VzIHRoYXQgbWF5IGhhdmUgYmVlbiByZXBvcnRlZCBieSB0aGUgY3VycmVudCByZW5kZXJlcihzKS5cbiAgICAgIC8vIERvbid0IGRvIHRoaXMgZWFnZXJseSBsaWtlIHRoZSBsYW5lVG9MYWJlbE1hcCxcbiAgICAgIC8vIGJlY2F1c2Ugc29tZSBtb2R1bGVzIG1pZ2h0IG5vdCB5ZXQgaGF2ZSByZWdpc3RlcmVkIHRoZWlyIGJvdW5kYXJpZXMgd2hlbiB0aGUgcmVuZGVyZXIgaXMgaW5qZWN0ZWQuXG4gICAgICB2YXIgcmFuZ2VzID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmdldEludGVybmFsTW9kdWxlUmFuZ2VzKCk7IC8vIFRoaXMgY2hlY2sgd291bGQgbm90IGJlIHJlcXVpcmVkLFxuICAgICAgLy8gZXhjZXB0IHRoYXQgaXQncyBwb3NzaWJsZSBmb3IgdGhpbmdzIHRvIG92ZXJyaWRlIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5cblxuXG4gICAgICBpZiAoT2JqZWN0KHNoYXJlZF9pc0FycmF5W1wiYVwiIC8qIGRlZmF1bHQgKi9dKShyYW5nZXMpKSB7XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUaW1lbGluZURhdGEoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRUaW1lbGluZURhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBsYW5lVG9MYW5lc0FycmF5KGxhbmVzKSB7XG4gICAgdmFyIGxhbmVzQXJyYXkgPSBbXTtcbiAgICB2YXIgbGFuZSA9IDE7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgUkVBQ1RfVE9UQUxfTlVNX0xBTkVTOyBpbmRleCsrKSB7XG4gICAgICBpZiAobGFuZSAmIGxhbmVzKSB7XG4gICAgICAgIGxhbmVzQXJyYXkucHVzaChsYW5lKTtcbiAgICAgIH1cblxuICAgICAgbGFuZSAqPSAyO1xuICAgIH1cblxuICAgIHJldHVybiBsYW5lc0FycmF5O1xuICB9XG5cbiAgdmFyIGxhbmVUb0xhYmVsTWFwID0gdHlwZW9mIGdldExhbmVMYWJlbE1hcCA9PT0gJ2Z1bmN0aW9uJyA/IGdldExhbmVMYWJlbE1hcCgpIDogbnVsbDtcblxuICBmdW5jdGlvbiBtYXJrTWV0YWRhdGEoKSB7XG4gICAgbWFya0FuZENsZWFyKFwiLS1yZWFjdC12ZXJzaW9uLVwiLmNvbmNhdChyZWFjdFZlcnNpb24pKTtcbiAgICBtYXJrQW5kQ2xlYXIoXCItLXByb2ZpbGVyLXZlcnNpb24tXCIuY29uY2F0KFNDSEVEVUxJTkdfUFJPRklMRVJfVkVSU0lPTikpO1xuICAgIHZhciByYW5nZXMgPSBnZXRJbnRlcm5hbE1vZHVsZVJhbmdlcygpO1xuXG4gICAgaWYgKHJhbmdlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuXG4gICAgICAgIGlmIChPYmplY3Qoc2hhcmVkX2lzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKHJhbmdlKSAmJiByYW5nZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB2YXIgX3JhbmdlcyRpID0gX3NsaWNlZFRvQXJyYXkocmFuZ2VzW2ldLCAyKSxcbiAgICAgICAgICAgICAgc3RhcnRTdGFja0ZyYW1lID0gX3JhbmdlcyRpWzBdLFxuICAgICAgICAgICAgICBzdG9wU3RhY2tGcmFtZSA9IF9yYW5nZXMkaVsxXTtcblxuICAgICAgICAgIG1hcmtBbmRDbGVhcihcIi0tcmVhY3QtaW50ZXJuYWwtbW9kdWxlLXN0YXJ0LVwiLmNvbmNhdChzdGFydFN0YWNrRnJhbWUpKTtcbiAgICAgICAgICBtYXJrQW5kQ2xlYXIoXCItLXJlYWN0LWludGVybmFsLW1vZHVsZS1zdG9wLVwiLmNvbmNhdChzdG9wU3RhY2tGcmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhbmVUb0xhYmVsTWFwICE9IG51bGwpIHtcbiAgICAgIHZhciBsYWJlbHMgPSBBcnJheS5mcm9tKGxhbmVUb0xhYmVsTWFwLnZhbHVlcygpKS5qb2luKCcsJyk7XG4gICAgICBtYXJrQW5kQ2xlYXIoXCItLXJlYWN0LWxhbmUtbGFiZWxzLVwiLmNvbmNhdChsYWJlbHMpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQW5kQ2xlYXIobWFya05hbWUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCB3b24ndCBiZSBjYWxsZWQgdW5sZXNzIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZCwgc28gd2UgY2FuIHNraXAgdGhlIGV4dHJhIHR5cGVvZiBjaGVjay5cbiAgICBwZXJmb3JtYW5jZVRhcmdldC5tYXJrKG1hcmtOYW1lKTtcbiAgICBwZXJmb3JtYW5jZVRhcmdldC5jbGVhck1hcmtzKG1hcmtOYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQodHlwZSwgbGFuZXMpIHtcbiAgICAvLyBEZWNpZGUgd2hhdCBkZXB0aCB0aGkgd29yayBzaG91bGQgYmUgcmVuZGVyZWQgYXQsIGJhc2VkIG9uIHdoYXQncyBvbiB0aGUgdG9wIG9mIHRoZSBzdGFjay5cbiAgICAvLyBJdCdzIG9rYXkgdG8gcmVuZGVyIG92ZXIgdG9wIG9mIFwiaWRsZVwiIHdvcmsgYnV0IGV2ZXJ5dGhpbmcgZWxzZSBzaG91bGQgYmUgb24gaXRzIG93biByb3cuXG4gICAgdmFyIGRlcHRoID0gMDtcblxuICAgIGlmIChjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0b3AgPSBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrW2N1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBkZXB0aCA9IHRvcC50eXBlID09PSAncmVuZGVyLWlkbGUnID8gdG9wLmRlcHRoIDogdG9wLmRlcHRoICsgMTtcbiAgICB9XG5cbiAgICB2YXIgbGFuZXNBcnJheSA9IGxhbmVUb0xhbmVzQXJyYXkobGFuZXMpO1xuICAgIHZhciByZWFjdE1lYXN1cmUgPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgYmF0Y2hVSUQ6IGN1cnJlbnRCYXRjaFVJRCxcbiAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgIGxhbmVzOiBsYW5lc0FycmF5LFxuICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfTtcbiAgICBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrLnB1c2gocmVhY3RNZWFzdXJlKTtcblxuICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICB2YXIgX2N1cnJlbnRUaW1lbGluZURhdGEgPSBjdXJyZW50VGltZWxpbmVEYXRhLFxuICAgICAgICAgIGJhdGNoVUlEVG9NZWFzdXJlc01hcCA9IF9jdXJyZW50VGltZWxpbmVEYXRhLmJhdGNoVUlEVG9NZWFzdXJlc01hcCxcbiAgICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVNYXAgPSBfY3VycmVudFRpbWVsaW5lRGF0YS5sYW5lVG9SZWFjdE1lYXN1cmVNYXA7XG4gICAgICB2YXIgcmVhY3RNZWFzdXJlcyA9IGJhdGNoVUlEVG9NZWFzdXJlc01hcC5nZXQoY3VycmVudEJhdGNoVUlEKTtcblxuICAgICAgaWYgKHJlYWN0TWVhc3VyZXMgIT0gbnVsbCkge1xuICAgICAgICByZWFjdE1lYXN1cmVzLnB1c2gocmVhY3RNZWFzdXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoVUlEVG9NZWFzdXJlc01hcC5zZXQoY3VycmVudEJhdGNoVUlELCBbcmVhY3RNZWFzdXJlXSk7XG4gICAgICB9XG5cbiAgICAgIGxhbmVzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobGFuZSkge1xuICAgICAgICByZWFjdE1lYXN1cmVzID0gbGFuZVRvUmVhY3RNZWFzdXJlTWFwLmdldChsYW5lKTtcblxuICAgICAgICBpZiAocmVhY3RNZWFzdXJlcykge1xuICAgICAgICAgIHJlYWN0TWVhc3VyZXMucHVzaChyZWFjdE1lYXN1cmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRSZWFjdE1lYXN1cmVDb21wbGV0ZWQodHlwZSkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IGdldFJlbGF0aXZlVGltZSgpO1xuXG4gICAgaWYgKGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHR5cGUgXCIlc1wiIGNvbXBsZXRlZCBhdCAlc21zIHdoaWxlIGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2sgaXMgZW1wdHkuJywgdHlwZSwgY3VycmVudFRpbWUpOyAvLyBJZ25vcmUgd29yayBcImNvbXBsZXRpb25cIiB1c2VyIHRpbWluZyBtYXJrIHRoYXQgZG9lc24ndCBjb21wbGV0ZSBhbnl0aGluZ1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvcCA9IGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2sucG9wKCk7XG5cbiAgICBpZiAodG9wLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSBcIiVzXCIgY29tcGxldGVkIGF0ICVzbXMgYmVmb3JlIFwiJXNcIiBjb21wbGV0ZWQuJywgdHlwZSwgY3VycmVudFRpbWUsIHRvcC50eXBlKTtcbiAgICB9IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgd3JpdGFibGUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cbiAgICB0b3AuZHVyYXRpb24gPSBjdXJyZW50VGltZSAtIHRvcC50aW1lc3RhbXA7XG5cbiAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5kdXJhdGlvbiA9IGdldFJlbGF0aXZlVGltZSgpICsgVElNRV9PRkZTRVQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQoJ2NvbW1pdCcsIGxhbmVzKTsgLy8gVE9ETyAodGltZWxpbmUpIFJlLXRoaW5rIHRoaXMgYXBwcm9hY2ggdG8gXCJiYXRjaGluZ1wiOyBJIGRvbid0IHRoaW5rIGl0IHdvcmtzIGZvciBTdXNwZW5zZSBvciBwcmUtcmVuZGVyaW5nLlxuICAgICAgLy8gVGhpcyBpc3N1ZSBhcHBsaWVzIHRvIHRoZSBVc2VyIFRpbWluZyBkYXRhIGFsc28uXG5cbiAgICAgIG5leHRSZW5kZXJTaG91bGRTdGFydE5ld0JhdGNoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihcIi0tY29tbWl0LXN0YXJ0LVwiLmNvbmNhdChsYW5lcykpOyAvLyBTb21lIG1ldGFkYXRhIG9ubHkgbmVlZHMgdG8gYmUgbG9nZ2VkIG9uY2UgcGVyIHNlc3Npb24sXG4gICAgICAvLyBidXQgaWYgcHJvZmlsaW5nIGluZm9ybWF0aW9uIGlzIGJlaW5nIHJlY29yZGVkIHZpYSB0aGUgUGVyZm9ybWFuY2UgdGFiLFxuICAgICAgLy8gRGV2VG9vbHMgaGFzIG5vIHdheSBvZiBrbm93aW5nIHdoZW4gdGhlIHJlY29yZGluZyBzdGFydHMuXG4gICAgICAvLyBCZWNhdXNlIG9mIHRoYXQsIHdlIGxvZyB0aGllIHR5cGUgb2YgZGF0YSBwZXJpb2RpY2FsbHkgKG9uY2UgcGVyIGNvbW1pdCkuXG5cbiAgICAgIG1hcmtNZXRhZGF0YSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21taXRTdG9wcGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlQ29tcGxldGVkKCdjb21taXQnKTtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCgncmVuZGVyLWlkbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1jb21taXQtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nIHx8IHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZWNvcmQgYW5kIGNhY2hlIGNvbXBvbmVudCBzdGFja1xuICAgICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlID0ge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgICAgICAgIHR5cGU6ICdyZW5kZXInLFxuICAgICAgICAgICAgd2FybmluZzogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihcIi0tY29tcG9uZW50LXJlbmRlci1zdGFydC1cIi5jb25jYXQoY29tcG9uZW50TmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmNvbXBvbmVudE1lYXN1cmVzLnB1c2goY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSk7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLmR1cmF0aW9uID0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGdldFJlbGF0aXZlVGltZSgpIC0gY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS50aW1lc3RhbXA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbXBvbmVudC1yZW5kZXItc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ2xheW91dC1lZmZlY3QtbW91bnQnLFxuICAgICAgICAgICAgd2FybmluZzogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihcIi0tY29tcG9uZW50LWxheW91dC1lZmZlY3QtbW91bnQtc3RhcnQtXCIuY29uY2F0KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmNvbXBvbmVudE1lYXN1cmVzLnB1c2goY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSk7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLmR1cmF0aW9uID0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGdldFJlbGF0aXZlVGltZSgpIC0gY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS50aW1lc3RhbXA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbXBvbmVudC1sYXlvdXQtZWZmZWN0LW1vdW50LXN0b3AnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ2xheW91dC1lZmZlY3QtdW5tb3VudCcsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1jb21wb25lbnQtbGF5b3V0LWVmZmVjdC11bm1vdW50LXN0YXJ0LVwiLmNvbmNhdChjb21wb25lbnROYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmNvbXBvbmVudE1lYXN1cmVzLnB1c2goY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSk7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLmR1cmF0aW9uID0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGdldFJlbGF0aXZlVGltZSgpIC0gY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS50aW1lc3RhbXA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbXBvbmVudC1sYXlvdXQtZWZmZWN0LXVubW91bnQtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nIHx8IHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZWNvcmQgYW5kIGNhY2hlIGNvbXBvbmVudCBzdGFja1xuICAgICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlID0ge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgICAgICAgIHR5cGU6ICdwYXNzaXZlLWVmZmVjdC1tb3VudCcsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1jb21wb25lbnQtcGFzc2l2ZS1lZmZlY3QtbW91bnQtc3RhcnQtXCIuY29uY2F0KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlKSB7XG4gICAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5jb21wb25lbnRNZWFzdXJlcy5wdXNoKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS5kdXJhdGlvbiA9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBnZXRSZWxhdGl2ZVRpbWUoKSAtIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUudGltZXN0YW1wO1xuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1jb21wb25lbnQtcGFzc2l2ZS1lZmZlY3QtbW91bnQtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ3Bhc3NpdmUtZWZmZWN0LXVubW91bnQnLFxuICAgICAgICAgICAgd2FybmluZzogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihcIi0tY29tcG9uZW50LXBhc3NpdmUtZWZmZWN0LXVubW91bnQtc3RhcnQtXCIuY29uY2F0KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmNvbXBvbmVudE1lYXN1cmVzLnB1c2goY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSk7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLmR1cmF0aW9uID0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGdldFJlbGF0aXZlVGltZSgpIC0gY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS50aW1lc3RhbXA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbXBvbmVudC1wYXNzaXZlLWVmZmVjdC11bm1vdW50LXN0b3AnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50RXJyb3JlZChmaWJlciwgdGhyb3duVmFsdWUsIGxhbmVzKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nIHx8IHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICAgIHZhciBwaGFzZSA9IGZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJztcbiAgICAgIHZhciBtZXNzYWdlID0gJyc7XG5cbiAgICAgIGlmICh0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJiBfdHlwZW9mKHRocm93blZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm93blZhbHVlLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aHJvd25WYWx1ZS5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aHJvd25WYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZWNvcmQgYW5kIGNhY2hlIGNvbXBvbmVudCBzdGFja1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEudGhyb3duRXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBwaGFzZTogcGhhc2UsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ3Rocm93bi1lcnJvcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFwiLS1lcnJvci1cIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCItXCIpLmNvbmNhdChwaGFzZSwgXCItXCIpLmNvbmNhdChtZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgY2Fubm90IGhhbmRsZSBwb2x5bW9ycGhpYyBXZWFrTWFwc1xuXG4gIHZhciB3YWtlYWJsZUlEcyA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgdmFyIHdha2VhYmxlSUQgPSAwO1xuXG4gIGZ1bmN0aW9uIGdldFdha2VhYmxlSUQod2FrZWFibGUpIHtcbiAgICBpZiAoIXdha2VhYmxlSURzLmhhcyh3YWtlYWJsZSkpIHtcbiAgICAgIHdha2VhYmxlSURzLnNldCh3YWtlYWJsZSwgd2FrZWFibGVJRCsrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2FrZWFibGVJRHMuZ2V0KHdha2VhYmxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcykge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IHdha2VhYmxlSURzLmhhcyh3YWtlYWJsZSkgPyAncmVzdXNwZW5kJyA6ICdzdXNwZW5kJztcbiAgICAgIHZhciBpZCA9IGdldFdha2VhYmxlSUQod2FrZWFibGUpO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgICB2YXIgcGhhc2UgPSBmaWJlci5hbHRlcm5hdGUgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7IC8vIEZvbGxvd2luZyB0aGUgbm9uLXN0YW5kYXJkIGZuLmRpc3BsYXlOYW1lIGNvbnZlbnRpb24sXG4gICAgICAvLyBmcmFtZXdvcmtzIGxpa2UgUmVsYXkgbWF5IGFsc28gYW5ub3RhdGUgUHJvbWlzZXMgd2l0aCBhIGRpc3BsYXlOYW1lLFxuICAgICAgLy8gZGVzY3JpYmluZyB3aGF0IG9wZXJhdGlvbi9kYXRhIHRoZSB0aHJvd24gUHJvbWlzZSBpcyByZWxhdGVkIHRvLlxuICAgICAgLy8gV2hlbiB0aGlzIGlzIGF2YWlsYWJsZSB3ZSBzaG91bGQgcGFzcyBpdCBhbG9uZyB0byB0aGUgVGltZWxpbmUuXG5cbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHdha2VhYmxlLmRpc3BsYXlOYW1lIHx8ICcnO1xuICAgICAgdmFyIHN1c3BlbnNlRXZlbnQgPSBudWxsO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIHN1c3BlbnNlRXZlbnQgPSB7XG4gICAgICAgICAgY29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSxcbiAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICBpZDogXCJcIi5jb25jYXQoaWQpLFxuICAgICAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgICAgICBwcm9taXNlTmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgICAgcmVzb2x1dGlvbjogJ3VucmVzb2x2ZWQnLFxuICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgdHlwZTogJ3N1c3BlbnNlJyxcbiAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnN1c3BlbnNlRXZlbnRzLnB1c2goc3VzcGVuc2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihcIi0tc3VzcGVuc2UtXCIuY29uY2F0KGV2ZW50VHlwZSwgXCItXCIpLmNvbmNhdChpZCwgXCItXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcIi1cIikuY29uY2F0KHBoYXNlLCBcIi1cIikuY29uY2F0KGxhbmVzLCBcIi1cIikuY29uY2F0KGRpc3BsYXlOYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIHdha2VhYmxlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc3VzcGVuc2VFdmVudCkge1xuICAgICAgICAgIHN1c3BlbnNlRXZlbnQuZHVyYXRpb24gPSBnZXRSZWxhdGl2ZVRpbWUoKSAtIHN1c3BlbnNlRXZlbnQudGltZXN0YW1wO1xuICAgICAgICAgIHN1c3BlbnNlRXZlbnQucmVzb2x1dGlvbiA9ICdyZXNvbHZlZCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgICBtYXJrQW5kQ2xlYXIoXCItLXN1c3BlbnNlLXJlc29sdmVkLVwiLmNvbmNhdChpZCwgXCItXCIpLmNvbmNhdChjb21wb25lbnROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHN1c3BlbnNlRXZlbnQpIHtcbiAgICAgICAgICBzdXNwZW5zZUV2ZW50LmR1cmF0aW9uID0gZ2V0UmVsYXRpdmVUaW1lKCkgLSBzdXNwZW5zZUV2ZW50LnRpbWVzdGFtcDtcbiAgICAgICAgICBzdXNwZW5zZUV2ZW50LnJlc29sdXRpb24gPSAncmVqZWN0ZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgICAgbWFya0FuZENsZWFyKFwiLS1zdXNwZW5zZS1yZWplY3RlZC1cIi5jb25jYXQoaWQsIFwiLVwiKS5jb25jYXQoY29tcG9uZW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQoJ2xheW91dC1lZmZlY3RzJywgbGFuZXMpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKFwiLS1sYXlvdXQtZWZmZWN0cy1zdGFydC1cIi5jb25jYXQobGFuZXMpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVDb21wbGV0ZWQoJ2xheW91dC1lZmZlY3RzJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tbGF5b3V0LWVmZmVjdHMtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQoJ3Bhc3NpdmUtZWZmZWN0cycsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihcIi0tcGFzc2l2ZS1lZmZlY3RzLXN0YXJ0LVwiLmNvbmNhdChsYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVDb21wbGV0ZWQoJ3Bhc3NpdmUtZWZmZWN0cycpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLXBhc3NpdmUtZWZmZWN0cy1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGlmIChuZXh0UmVuZGVyU2hvdWxkU3RhcnROZXdCYXRjaCkge1xuICAgICAgICBuZXh0UmVuZGVyU2hvdWxkU3RhcnROZXdCYXRjaCA9IGZhbHNlO1xuICAgICAgICBjdXJyZW50QmF0Y2hVSUQrKztcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIG5ldyBiYXRjaCBvZiB3b3JrLCB3cmFwIGFuIFwiaWRsZVwiIG1lYXN1cmUgYXJvdW5kIGl0LlxuICAgICAgLy8gTG9nIGl0IGJlZm9yZSB0aGUgXCJyZW5kZXJcIiBtZWFzdXJlIHRvIHByZXNlcnZlIHRoZSBzdGFjayBvcmRlcmluZy5cblxuXG4gICAgICBpZiAoY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjay5sZW5ndGggPT09IDAgfHwgY3VycmVudFJlYWN0TWVhc3VyZXNTdGFja1tjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrLmxlbmd0aCAtIDFdLnR5cGUgIT09ICdyZW5kZXItaWRsZScpIHtcbiAgICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlU3RhcnRlZCgncmVuZGVyLWlkbGUnLCBsYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQoJ3JlbmRlcicsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihcIi0tcmVuZGVyLXN0YXJ0LVwiLmNvbmNhdChsYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZW5kZXJZaWVsZGVkKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlQ29tcGxldGVkKCdyZW5kZXInKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1yZW5kZXIteWllbGQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCgncmVuZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tcmVuZGVyLXN0b3AnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuc2NoZWR1bGluZ0V2ZW50cy5wdXNoKHtcbiAgICAgICAgICBsYW5lczogbGFuZVRvTGFuZXNBcnJheShsYW5lKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgIHR5cGU6ICdzY2hlZHVsZS1yZW5kZXInLFxuICAgICAgICAgIHdhcm5pbmc6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoXCItLXNjaGVkdWxlLXJlbmRlci1cIi5jb25jYXQobGFuZSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnNjaGVkdWxpbmdFdmVudHMucHVzaCh7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lOiBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgbGFuZXM6IGxhbmVUb0xhbmVzQXJyYXkobGFuZSksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ3NjaGVkdWxlLWZvcmNlLXVwZGF0ZScsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihcIi0tc2NoZWR1bGUtZm9yY2VkLXVwZGF0ZS1cIi5jb25jYXQobGFuZSwgXCItXCIpLmNvbmNhdChjb21wb25lbnROYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50RmliZXJzKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgcGFyZW50ID0gZmliZXI7XG5cbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZTogY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBwYXJlbnQgZmliZXJzIHNvIHdlIGNhbiBwb3N0IHByb2Nlc3NcbiAgICAgICAgICAgIC8vIHRoZW0gYWZ0ZXIgd2UgZmluaXNoIHByb2ZpbGluZ1xuICAgICAgICAgICAgbGFuZXM6IGxhbmVUb0xhbmVzQXJyYXkobGFuZSksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ3NjaGVkdWxlLXN0YXRlLXVwZGF0ZScsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdXJyZW50RmliZXJTdGFja3Muc2V0KGV2ZW50LCBnZXRQYXJlbnRGaWJlcnMoZmliZXIpKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnNjaGVkdWxpbmdFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihcIi0tc2NoZWR1bGUtc3RhdGUtdXBkYXRlLVwiLmNvbmNhdChsYW5lLCBcIi1cIikuY29uY2F0KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVQcm9maWxpbmdTdGF0dXModmFsdWUpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgIT09IHZhbHVlKSB7XG4gICAgICBpc1Byb2ZpbGluZyA9IHZhbHVlO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgdmFyIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgICAgdmFyIHJhbmdlcyA9IGdldEludGVybmFsTW9kdWxlUmFuZ2VzKCk7XG5cbiAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG5cbiAgICAgICAgICAgICAgaWYgKE9iamVjdChzaGFyZWRfaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkocmFuZ2UpICYmIHJhbmdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBfcmFuZ2VzJGkyID0gX3NsaWNlZFRvQXJyYXkocmFuZ2VzW2ldLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRTdGFja0ZyYW1lID0gX3JhbmdlcyRpMlswXSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFN0YWNrRnJhbWUgPSBfcmFuZ2VzJGkyWzFdO1xuXG4gICAgICAgICAgICAgICAgbWFya0FuZENsZWFyKFwiLS1yZWFjdC1pbnRlcm5hbC1tb2R1bGUtc3RhcnQtXCIuY29uY2F0KHN0YXJ0U3RhY2tGcmFtZSkpO1xuICAgICAgICAgICAgICAgIG1hcmtBbmRDbGVhcihcIi0tcmVhY3QtaW50ZXJuYWwtbW9kdWxlLXN0b3AtXCIuY29uY2F0KHN0b3BTdGFja0ZyYW1lKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFuZVRvUmVhY3RNZWFzdXJlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgbGFuZSA9IDE7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IFJFQUNUX1RPVEFMX05VTV9MQU5FUzsgaW5kZXgrKykge1xuICAgICAgICAgIGxhbmVUb1JlYWN0TWVhc3VyZU1hcC5zZXQobGFuZSwgW10pO1xuICAgICAgICAgIGxhbmUgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRCYXRjaFVJRCA9IDA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgICBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrID0gW107XG4gICAgICAgIGN1cnJlbnRGaWJlclN0YWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YSA9IHtcbiAgICAgICAgICAvLyBTZXNzaW9uIHdpZGUgbWV0YWRhdGE7IG9ubHkgY29sbGVjdGVkIG9uY2UuXG4gICAgICAgICAgaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1JhbmdlczogaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1JhbmdlcyxcbiAgICAgICAgICBsYW5lVG9MYWJlbE1hcDogbGFuZVRvTGFiZWxNYXAgfHwgbmV3IE1hcCgpLFxuICAgICAgICAgIHJlYWN0VmVyc2lvbjogcmVhY3RWZXJzaW9uLFxuICAgICAgICAgIC8vIERhdGEgbG9nZ2VkIGJ5IFJlYWN0IGR1cmluZyBwcm9maWxpbmcgc2Vzc2lvbi5cbiAgICAgICAgICBjb21wb25lbnRNZWFzdXJlczogW10sXG4gICAgICAgICAgc2NoZWR1bGluZ0V2ZW50czogW10sXG4gICAgICAgICAgc3VzcGVuc2VFdmVudHM6IFtdLFxuICAgICAgICAgIHRocm93bkVycm9yczogW10sXG4gICAgICAgICAgLy8gRGF0YSBpbmZlcnJlZCBiYXNlZCBvbiB3aGF0IFJlYWN0IGxvZ3MuXG4gICAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwOiBuZXcgTWFwKCksXG4gICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgbGFuZVRvUmVhY3RNZWFzdXJlTWFwOiBsYW5lVG9SZWFjdE1lYXN1cmVNYXAsXG4gICAgICAgICAgc3RhcnRUaW1lOiAwLFxuICAgICAgICAgIC8vIERhdGEgb25seSBhdmFpbGFibGUgaW4gQ2hyb21lIHByb2ZpbGVzLlxuICAgICAgICAgIGZsYW1lY2hhcnQ6IFtdLFxuICAgICAgICAgIG5hdGl2ZUV2ZW50czogW10sXG4gICAgICAgICAgbmV0d29ya01lYXN1cmVzOiBbXSxcbiAgICAgICAgICBvdGhlclVzZXJUaW1pbmdNYXJrczogW10sXG4gICAgICAgICAgc25hcHNob3RzOiBbXSxcbiAgICAgICAgICBzbmFwc2hvdEhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgICBuZXh0UmVuZGVyU2hvdWxkU3RhcnROZXdCYXRjaCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQb3N0cHJvY2VzcyBQcm9maWxlIGRhdGFcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnNjaGVkdWxpbmdFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnc2NoZWR1bGUtc3RhdGUtdXBkYXRlJykge1xuICAgICAgICAgICAgICAvLyBUT0RPKGx1bmEpOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBjcmVhdGluZyBhIG1hcCBvZlxuICAgICAgICAgICAgICAvLyBmaWJlciB0byBjb21wb25lbnQgc3RhY2sgaW5zdGVhZCBvZiBnZW5lcmF0aW5nIHRoZSBzdGFja1xuICAgICAgICAgICAgICAvLyBmb3IgZXZlcnkgZmliZXIgZXZlcnkgdGltZVxuICAgICAgICAgICAgICB2YXIgZmliZXJTdGFjayA9IGN1cnJlbnRGaWJlclN0YWNrcy5nZXQoZXZlbnQpO1xuXG4gICAgICAgICAgICAgIGlmIChmaWJlclN0YWNrICYmIGN1cnJlbnREaXNwYXRjaGVyUmVmICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBldmVudC5jb21wb25lbnRTdGFjayA9IGZpYmVyU3RhY2sucmVkdWNlKGZ1bmN0aW9uICh0cmFjZSwgZmliZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZSArIE9iamVjdChEZXZUb29sc0ZpYmVyQ29tcG9uZW50U3RhY2tbXCJhXCIgLyogZGVzY3JpYmVGaWJlciAqL10pKHdvcmtUYWdNYXAsIGZpYmVyLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG4gICAgICAgICAgICAgICAgfSwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gQ2xlYXIgdGhlIGN1cnJlbnQgZmliZXIgc3RhY2tzIHNvIHdlIGRvbid0IGhvbGQgb250byB0aGUgZmliZXJzXG4gICAgICAgIC8vIGluIG1lbW9yeSBhZnRlciBwcm9maWxpbmcgZmluaXNoZXNcblxuXG4gICAgICAgIGN1cnJlbnRGaWJlclN0YWNrcy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0VGltZWxpbmVEYXRhOiBnZXRUaW1lbGluZURhdGEsXG4gICAgcHJvZmlsaW5nSG9va3M6IHtcbiAgICAgIG1hcmtDb21taXRTdGFydGVkOiBtYXJrQ29tbWl0U3RhcnRlZCxcbiAgICAgIG1hcmtDb21taXRTdG9wcGVkOiBtYXJrQ29tbWl0U3RvcHBlZCxcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkOiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkOiBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCxcbiAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkOiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkOiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCxcbiAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQ6IG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQsXG4gICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkOiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkLFxuICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZDogbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQ6IG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQsXG4gICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQ6IG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZDogbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkLFxuICAgICAgbWFya0NvbXBvbmVudEVycm9yZWQ6IG1hcmtDb21wb25lbnRFcnJvcmVkLFxuICAgICAgbWFya0NvbXBvbmVudFN1c3BlbmRlZDogbWFya0NvbXBvbmVudFN1c3BlbmRlZCxcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZDogbWFya0xheW91dEVmZmVjdHNTdGFydGVkLFxuICAgICAgbWFya0xheW91dEVmZmVjdHNTdG9wcGVkOiBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQsXG4gICAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkOiBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkLFxuICAgICAgbWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZDogbWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCxcbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkOiBtYXJrUmVuZGVyU3RhcnRlZCxcbiAgICAgIG1hcmtSZW5kZXJZaWVsZGVkOiBtYXJrUmVuZGVyWWllbGRlZCxcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkOiBtYXJrUmVuZGVyU3RvcHBlZCxcbiAgICAgIG1hcmtSZW5kZXJTY2hlZHVsZWQ6IG1hcmtSZW5kZXJTY2hlZHVsZWQsXG4gICAgICBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQ6IG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCxcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZDogbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkXG4gICAgfSxcbiAgICB0b2dnbGVQcm9maWxpbmdTdGF0dXM6IHRvZ2dsZVByb2ZpbGluZ1N0YXR1c1xuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3JlbmRlcmVyLmpzXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gcmVuZGVyZXJfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIHJlbmRlcmVyX2FycmF5V2l0aEhvbGVzKGFycikgfHwgcmVuZGVyZXJfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCByZW5kZXJlcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IHJlbmRlcmVyX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgcmVuZGVyZXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiByZW5kZXJlcl9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSByZW5kZXJlcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IHRocm93IF9lMjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gcmVuZGVyZXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHJlbmRlcmVyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHJlbmRlcmVyX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyByZW5kZXJlcl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gcmVuZGVyZXJfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldEZpYmVyRmxhZ3MoZmliZXIpIHtcbiAgLy8gVGhlIG5hbWUgb2YgdGhpcyBmaWVsZCBjaGFuZ2VkIGZyb20gXCJlZmZlY3RUYWdcIiB0byBcImZsYWdzXCJcbiAgcmV0dXJuIGZpYmVyLmZsYWdzICE9PSB1bmRlZmluZWQgPyBmaWJlci5mbGFncyA6IGZpYmVyLmVmZmVjdFRhZztcbn0gLy8gU29tZSBlbnZpcm9ubWVudHMgKGUuZy4gUmVhY3QgTmF0aXZlIC8gSGVybWVzKSBkb24ndCBzdXBwb3J0IHRoZSBwZXJmb3JtYW5jZSBBUEkgeWV0LlxuXG5cbnZhciByZW5kZXJlcl9nZXRDdXJyZW50VGltZSA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbih0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogcmVuZGVyZXJfdHlwZW9mKHBlcmZvcm1hbmNlKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbmZ1bmN0aW9uIGdldEludGVybmFsUmVhY3RDb25zdGFudHModmVyc2lvbikge1xuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIFRoZSBzZWN0aW9uIGJlbG93IGlzIGNvcGllZCBmcm9tIGZpbGVzIGluIFJlYWN0IHJlcG8uXG4gIC8vIEtlZXAgaXQgaW4gc3luYywgYW5kIGFkZCB2ZXJzaW9uIGd1YXJkcyBpZiBpdCBjaGFuZ2VzLlxuICAvL1xuICAvLyBUZWNobmljYWxseSB0aGVzZSBwcmlvcml0eSBsZXZlbHMgYXJlIGludmFsaWQgZm9yIHZlcnNpb25zIGJlZm9yZSAxNi45LFxuICAvLyBidXQgMTYuOSBpcyB0aGUgZmlyc3QgdmVyc2lvbiB0byByZXBvcnQgcHJpb3JpdHkgbGV2ZWwgdG8gRGV2VG9vbHMsXG4gIC8vIHNvIHdlIGNhbiBhdm9pZCBjaGVja2luZyBmb3IgZWFybGllciB2ZXJzaW9ucyBhbmQgc3VwcG9ydCBwcmUtMTYuOSBjYW5hcnkgcmVsZWFzZXMgaW4gdGhlIHByb2Nlc3MuXG4gIHZhciBSZWFjdFByaW9yaXR5TGV2ZWxzID0ge1xuICAgIEltbWVkaWF0ZVByaW9yaXR5OiA5OSxcbiAgICBVc2VyQmxvY2tpbmdQcmlvcml0eTogOTgsXG4gICAgTm9ybWFsUHJpb3JpdHk6IDk3LFxuICAgIExvd1ByaW9yaXR5OiA5NixcbiAgICBJZGxlUHJpb3JpdHk6IDk1LFxuICAgIE5vUHJpb3JpdHk6IDkwXG4gIH07XG5cbiAgaWYgKE9iamVjdChiYWNrZW5kX3V0aWxzW1wiaFwiIC8qIGd0ICovXSkodmVyc2lvbiwgJzE3LjAuMicpKSB7XG4gICAgUmVhY3RQcmlvcml0eUxldmVscyA9IHtcbiAgICAgIEltbWVkaWF0ZVByaW9yaXR5OiAxLFxuICAgICAgVXNlckJsb2NraW5nUHJpb3JpdHk6IDIsXG4gICAgICBOb3JtYWxQcmlvcml0eTogMyxcbiAgICAgIExvd1ByaW9yaXR5OiA0LFxuICAgICAgSWRsZVByaW9yaXR5OiA1LFxuICAgICAgTm9Qcmlvcml0eTogMFxuICAgIH07XG4gIH1cblxuICB2YXIgU3RyaWN0TW9kZUJpdHMgPSAwO1xuXG4gIGlmIChPYmplY3QoYmFja2VuZF91dGlsc1tcImlcIiAvKiBndGUgKi9dKSh2ZXJzaW9uLCAnMTguMC4wLWFscGhhJykpIHtcbiAgICAvLyAxOCtcbiAgICBTdHJpY3RNb2RlQml0cyA9IDI0O1xuICB9IGVsc2UgaWYgKE9iamVjdChiYWNrZW5kX3V0aWxzW1wiaVwiIC8qIGd0ZSAqL10pKHZlcnNpb24sICcxNi45LjAnKSkge1xuICAgIC8vIDE2LjkgLSAxN1xuICAgIFN0cmljdE1vZGVCaXRzID0gMTtcbiAgfSBlbHNlIGlmIChPYmplY3QoYmFja2VuZF91dGlsc1tcImlcIiAvKiBndGUgKi9dKSh2ZXJzaW9uLCAnMTYuMy4wJykpIHtcbiAgICAvLyAxNi4zIC0gMTYuOFxuICAgIFN0cmljdE1vZGVCaXRzID0gMjtcbiAgfVxuXG4gIHZhciBSZWFjdFR5cGVPZldvcmsgPSBudWxsOyAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIFRoZSBzZWN0aW9uIGJlbG93IGlzIGNvcGllZCBmcm9tIGZpbGVzIGluIFJlYWN0IHJlcG8uXG4gIC8vIEtlZXAgaXQgaW4gc3luYywgYW5kIGFkZCB2ZXJzaW9uIGd1YXJkcyBpZiBpdCBjaGFuZ2VzLlxuICAvL1xuICAvLyBUT0RPIFVwZGF0ZSB0aGUgZ3QoKSBjaGVjayBiZWxvdyB0byBiZSBndGUoKSB3aGljaGV2ZXIgdGhlIG5leHQgdmVyc2lvbiBudW1iZXIgaXMuXG4gIC8vIEN1cnJlbnRseSB0aGUgdmVyc2lvbiBpbiBHaXQgaXMgMTcuMC4yIChidXQgdGhhdCB2ZXJzaW9uIGhhcyBub3QgYmVlbi9tYXkgbm90IGVuZCB1cCBiZWluZyByZWxlYXNlZCkuXG5cbiAgaWYgKE9iamVjdChiYWNrZW5kX3V0aWxzW1wiaFwiIC8qIGd0ICovXSkodmVyc2lvbiwgJzE3LjAuMScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IDI0LFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBDbGFzc0NvbXBvbmVudDogMSxcbiAgICAgIENvbnRleHRDb25zdW1lcjogOSxcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTAsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDogMTgsXG4gICAgICAvLyBCZWhpbmQgYSBmbGFnXG4gICAgICBGb3J3YXJkUmVmOiAxMSxcbiAgICAgIEZyYWdtZW50OiA3LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA1LFxuICAgICAgSG9zdFBvcnRhbDogNCxcbiAgICAgIEhvc3RSb290OiAzLFxuICAgICAgSG9zdEhvaXN0YWJsZTogMjYsXG4gICAgICAvLyBJbiByZWFsaXR5LCAxOC4yKy4gQnV0IGRvZXNuJ3QgaHVydCB0byBpbmNsdWRlIGl0IGhlcmVcbiAgICAgIEhvc3RTaW5nbGV0b246IDI3LFxuICAgICAgLy8gU2FtZSBhcyBhYm92ZVxuICAgICAgSG9zdFRleHQ6IDYsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IDE3LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDogMixcbiAgICAgIExhenlDb21wb25lbnQ6IDE2LFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAyMyxcbiAgICAgIE1lbW9Db21wb25lbnQ6IDE0LFxuICAgICAgTW9kZTogOCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogMjIsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFByb2ZpbGVyOiAxMixcbiAgICAgIFNjb3BlQ29tcG9uZW50OiAyMSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgU2ltcGxlTWVtb0NvbXBvbmVudDogMTUsXG4gICAgICBTdXNwZW5zZUNvbXBvbmVudDogMTMsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQ6IDE5LFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBUcmFjaW5nTWFya2VyQ29tcG9uZW50OiAyNSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbCAtIFRoaXMgaXMgdGVjaG5pY2FsbHkgaW4gMTggYnV0IHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGZvcmsgYWdhaW4gc28gd2UncmUgYWRkaW5nIGl0IGhlcmUgaW5zdGVhZFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xIC8vIFJlbW92ZWRcblxuICAgIH07XG4gIH0gZWxzZSBpZiAoT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJpXCIgLyogZ3RlICovXSkodmVyc2lvbiwgJzE3LjAuMC1hbHBoYScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIENsYXNzQ29tcG9uZW50OiAxLFxuICAgICAgQ29udGV4dENvbnN1bWVyOiA5LFxuICAgICAgQ29udGV4dFByb3ZpZGVyOiAxMCxcbiAgICAgIENvcm91dGluZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAxOCxcbiAgICAgIC8vIEJlaGluZCBhIGZsYWdcbiAgICAgIEZvcndhcmRSZWY6IDExLFxuICAgICAgRnJhZ21lbnQ6IDcsXG4gICAgICBGdW5jdGlvbkNvbXBvbmVudDogMCxcbiAgICAgIEhvc3RDb21wb25lbnQ6IDUsXG4gICAgICBIb3N0UG9ydGFsOiA0LFxuICAgICAgSG9zdFJvb3Q6IDMsXG4gICAgICBIb3N0SG9pc3RhYmxlOiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBIb3N0U2luZ2xldG9uOiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBIb3N0VGV4dDogNixcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDogMTcsXG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAyLFxuICAgICAgTGF6eUNvbXBvbmVudDogMTYsXG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IDI0LFxuICAgICAgTWVtb0NvbXBvbmVudDogMTQsXG4gICAgICBNb2RlOiA4LFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAyMyxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDEyLFxuICAgICAgU2NvcGVDb21wb25lbnQ6IDIxLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAxNSxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50OiAxMyxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudDogMTksXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFlpZWxkQ29tcG9uZW50OiAtMSAvLyBSZW1vdmVkXG5cbiAgICB9O1xuICB9IGVsc2UgaWYgKE9iamVjdChiYWNrZW5kX3V0aWxzW1wiaVwiIC8qIGd0ZSAqL10pKHZlcnNpb24sICcxNi42LjAtYmV0YS4wJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDEsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDksXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEwLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIENvcm91dGluZUhhbmRsZXJQaGFzZTogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IDE4LFxuICAgICAgLy8gQmVoaW5kIGEgZmxhZ1xuICAgICAgRm9yd2FyZFJlZjogMTEsXG4gICAgICBGcmFnbWVudDogNyxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RIb2lzdGFibGU6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RTaW5nbGV0b246IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAxNyxcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDIsXG4gICAgICBMYXp5Q29tcG9uZW50OiAxNixcbiAgICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudDogLTEsXG4gICAgICBNZW1vQ29tcG9uZW50OiAxNCxcbiAgICAgIE1vZGU6IDgsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBQcm9maWxlcjogMTIsXG4gICAgICBTY29wZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgVHJhY2luZ01hcmtlckNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xIC8vIFJlbW92ZWRcblxuICAgIH07XG4gIH0gZWxzZSBpZiAoT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJpXCIgLyogZ3RlICovXSkodmVyc2lvbiwgJzE2LjQuMy1hbHBoYScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIENsYXNzQ29tcG9uZW50OiAyLFxuICAgICAgQ29udGV4dENvbnN1bWVyOiAxMSxcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTIsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgRm9yd2FyZFJlZjogMTMsXG4gICAgICBGcmFnbWVudDogOSxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNyxcbiAgICAgIEhvc3RQb3J0YWw6IDYsXG4gICAgICBIb3N0Um9vdDogNSxcbiAgICAgIEhvc3RIb2lzdGFibGU6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RTaW5nbGV0b246IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RUZXh0OiA4LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiA0LFxuICAgICAgTGF6eUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAtMSxcbiAgICAgIE1lbW9Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIE1vZGU6IDEwLFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDE1LFxuICAgICAgU2NvcGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBTdXNwZW5zZUNvbXBvbmVudDogMTYsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFlpZWxkQ29tcG9uZW50OiAtMSAvLyBSZW1vdmVkXG5cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIFJlYWN0VHlwZU9mV29yayA9IHtcbiAgICAgIENhY2hlQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBDbGFzc0NvbXBvbmVudDogMixcbiAgICAgIENvbnRleHRDb25zdW1lcjogMTIsXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEzLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiA3LFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiA4LFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBGb3J3YXJkUmVmOiAxNCxcbiAgICAgIEZyYWdtZW50OiAxMCxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAxLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RIb2lzdGFibGU6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RTaW5nbGV0b246IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAwLFxuICAgICAgTGF6eUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAtMSxcbiAgICAgIE1lbW9Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIE1vZGU6IDExLFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDE1LFxuICAgICAgU2NvcGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBTdXNwZW5zZUNvbXBvbmVudDogMTYsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFlpZWxkQ29tcG9uZW50OiA5XG4gICAgfTtcbiAgfSAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIEVuZCBvZiBjb3BpZWQgY29kZS5cbiAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cbiAgZnVuY3Rpb24gZ2V0VHlwZVN5bWJvbCh0eXBlKSB7XG4gICAgdmFyIHN5bWJvbE9yTnVtYmVyID0gcmVuZGVyZXJfdHlwZW9mKHR5cGUpID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsID8gdHlwZS4kJHR5cGVvZiA6IHR5cGU7XG4gICAgcmV0dXJuIHJlbmRlcmVyX3R5cGVvZihzeW1ib2xPck51bWJlcikgPT09ICdzeW1ib2wnID8gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBgdG9TdHJpbmcoKWAgZG9lc24ndCBtYXRjaCB0aGUgdHlwZSBzaWduYXR1cmU/XG4gICAgc3ltYm9sT3JOdW1iZXIudG9TdHJpbmcoKSA6IHN5bWJvbE9yTnVtYmVyO1xuICB9XG5cbiAgdmFyIF9SZWFjdFR5cGVPZldvcmsgPSBSZWFjdFR5cGVPZldvcmssXG4gICAgICBDYWNoZUNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuQ2FjaGVDb21wb25lbnQsXG4gICAgICBDbGFzc0NvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuQ2xhc3NDb21wb25lbnQsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkluY29tcGxldGVDbGFzc0NvbXBvbmVudCxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5GdW5jdGlvbkNvbXBvbmVudCxcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gICAgICBGb3J3YXJkUmVmID0gX1JlYWN0VHlwZU9mV29yay5Gb3J3YXJkUmVmLFxuICAgICAgSG9zdFJvb3QgPSBfUmVhY3RUeXBlT2ZXb3JrLkhvc3RSb290LFxuICAgICAgSG9zdEhvaXN0YWJsZSA9IF9SZWFjdFR5cGVPZldvcmsuSG9zdEhvaXN0YWJsZSxcbiAgICAgIEhvc3RTaW5nbGV0b24gPSBfUmVhY3RUeXBlT2ZXb3JrLkhvc3RTaW5nbGV0b24sXG4gICAgICBIb3N0Q29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5Ib3N0Q29tcG9uZW50LFxuICAgICAgSG9zdFBvcnRhbCA9IF9SZWFjdFR5cGVPZldvcmsuSG9zdFBvcnRhbCxcbiAgICAgIEhvc3RUZXh0ID0gX1JlYWN0VHlwZU9mV29yay5Ib3N0VGV4dCxcbiAgICAgIEZyYWdtZW50ID0gX1JlYWN0VHlwZU9mV29yay5GcmFnbWVudCxcbiAgICAgIExhenlDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkxhenlDb21wb25lbnQsXG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkxlZ2FjeUhpZGRlbkNvbXBvbmVudCxcbiAgICAgIE1lbW9Db21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLk1lbW9Db21wb25lbnQsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLk9mZnNjcmVlbkNvbXBvbmVudCxcbiAgICAgIFByb2ZpbGVyID0gX1JlYWN0VHlwZU9mV29yay5Qcm9maWxlcixcbiAgICAgIFNjb3BlQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5TY29wZUNvbXBvbmVudCxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLlNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgICBTdXNwZW5zZUNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuU3VzcGVuc2VDb21wb25lbnQsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlTGlzdENvbXBvbmVudCxcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLlRyYWNpbmdNYXJrZXJDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUZpYmVyVHlwZSh0eXBlKSB7XG4gICAgdmFyIHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuXG4gICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImpcIiAvKiBNRU1PX05VTUJFUiAqL106XG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImtcIiAvKiBNRU1PX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAvLyByZWN1cnNpdmVseSByZXNvbHZpbmcgbWVtbyB0eXBlIGluIGNhc2Ugb2YgbWVtbyhmb3J3YXJkUmVmKENvbXBvbmVudCkpXG4gICAgICAgIHJldHVybiByZXNvbHZlRmliZXJUeXBlKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiZlwiIC8qIEZPUldBUkRfUkVGX05VTUJFUiAqL106XG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImdcIiAvKiBGT1JXQVJEX1JFRl9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgcmV0dXJuIHR5cGUucmVuZGVyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH0gLy8gTk9USUNFIEtlZXAgaW4gc3luYyB3aXRoIHNob3VsZEZpbHRlckZpYmVyKCkgYW5kIG90aGVyIGdldCpGb3JGaWJlciBtZXRob2RzXG5cblxuICBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZmliZXIuZWxlbWVudFR5cGUsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlLFxuICAgICAgICB0YWcgPSBmaWJlci50YWc7XG4gICAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocmVuZGVyZXJfdHlwZW9mKHR5cGUpID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRmliZXJUeXBlKHR5cGUpO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZENvbnRleHQgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBPYmplY3QodXRpbHNbXCJoXCIgLyogZ2V0RGlzcGxheU5hbWUgKi9dKShyZXNvbHZlZFR5cGUpO1xuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gT2JqZWN0KHV0aWxzW1wiaFwiIC8qIGdldERpc3BsYXlOYW1lICovXSkocmVzb2x2ZWRUeXBlKTtcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gT2JqZWN0KHV0aWxzW1wibFwiIC8qIGdldFdyYXBwZWREaXNwbGF5TmFtZSAqL10pKGVsZW1lbnRUeXBlLCByZXNvbHZlZFR5cGUsICdGb3J3YXJkUmVmJywgJ0Fub255bW91cycpO1xuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB2YXIgZmliZXJSb290ID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QgIT0gbnVsbCAmJiBmaWJlclJvb3QuX2RlYnVnUm9vdFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmliZXJSb290Ll9kZWJ1Z1Jvb3RUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgICAvLyBUaGlzIGRpc3BsYXkgbmFtZSB3aWxsIG5vdCBiZSB1c2VyIHZpc2libGUuXG4gICAgICAgIC8vIE9uY2UgYSBMYXp5IGNvbXBvbmVudCBsb2FkcyBpdHMgaW5uZXIgY29tcG9uZW50LCBSZWFjdCByZXBsYWNlcyB0aGUgdGFnIGFuZCB0eXBlLlxuICAgICAgICAvLyBUaGlzIGRpc3BsYXkgbmFtZSB3aWxsIG9ubHkgc2hvdyB1cCBpbiBjb25zb2xlIGxvZ3Mgd2hlbiBEZXZUb29scyBERUJVRyBtb2RlIGlzIG9uLlxuICAgICAgICByZXR1cm4gJ0xhenknO1xuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIC8vIERpc3BsYXkgbmFtZSBpbiBSZWFjdCBkb2VzIG5vdCB1c2UgYE1lbW9gIGFzIGEgd3JhcHBlciBidXQgZmFsbGJhY2sgbmFtZS5cbiAgICAgICAgcmV0dXJuIE9iamVjdCh1dGlsc1tcImxcIiAvKiBnZXRXcmFwcGVkRGlzcGxheU5hbWUgKi9dKShlbGVtZW50VHlwZSwgcmVzb2x2ZWRUeXBlLCAnTWVtbycsICdBbm9ueW1vdXMnKTtcblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ0xlZ2FjeUhpZGRlbic7XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG5cbiAgICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnU2NvcGUnO1xuXG4gICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ1RyYWNpbmdNYXJrZXInO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJhXCIgLyogQ09OQ1VSUkVOVF9NT0RFX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJiXCIgLyogQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiZVwiIC8qIERFUFJFQ0FURURfQVNZTkNfTU9ERV9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJuXCIgLyogUFJPVklERVJfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcIm9cIiAvKiBQUk9WSURFUl9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIC8vIDE2LjMuMCBleHBvc2VkIHRoZSBjb250ZXh0IG9iamVjdCBhcyBcImNvbnRleHRcIlxuICAgICAgICAgICAgLy8gUFIgIzEyNTAxIGNoYW5nZWQgaXQgdG8gXCJfY29udGV4dFwiIGZvciAxNi4zLjErXG4gICAgICAgICAgICAvLyBOT1RFIEtlZXAgaW4gc3luYyB3aXRoIGluc3BlY3RFbGVtZW50UmF3KClcbiAgICAgICAgICAgIHJlc29sdmVkQ29udGV4dCA9IGZpYmVyLnR5cGUuX2NvbnRleHQgfHwgZmliZXIudHlwZS5jb250ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHJlc29sdmVkQ29udGV4dC5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCcsIFwiLlByb3ZpZGVyXCIpO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJjXCIgLyogQ09OVEVYVF9OVU1CRVIgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiZFwiIC8qIENPTlRFWFRfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJyXCIgLyogU0VSVkVSX0NPTlRFWFRfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgICAvLyAxNi4zLTE2LjUgcmVhZCBmcm9tIFwidHlwZVwiIGJlY2F1c2UgdGhlIENvbnN1bWVyIGlzIHRoZSBhY3R1YWwgY29udGV4dCBvYmplY3QuXG4gICAgICAgICAgICAvLyAxNi42KyBzaG91bGQgcmVhZCBmcm9tIFwidHlwZS5fY29udGV4dFwiIGJlY2F1c2UgQ29uc3VtZXIgY2FuIGJlIGRpZmZlcmVudCAoaW4gREVWKS5cbiAgICAgICAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggaW5zcGVjdEVsZW1lbnRSYXcoKVxuICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gZmliZXIudHlwZS5fY29udGV4dCB8fCBmaWJlci50eXBlOyAvLyBOT1RFOiBUcmFjZVVwZGF0ZXNCYWNrZW5kTWFuYWdlciBkZXBlbmRzIG9uIHRoZSBuYW1lIGVuZGluZyBpbiAnLkNvbnN1bWVyJ1xuICAgICAgICAgICAgLy8gSWYgeW91IGNoYW5nZSB0aGUgbmFtZSwgZmlndXJlIG91dCBhIG1vcmUgcmVzaWxpZW50IHdheSB0byBkZXRlY3QgaXQuXG5cbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZXNvbHZlZENvbnRleHQuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnLCBcIi5Db25zdW1lclwiKTtcblxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wic1wiIC8qIFNUUklDVF9NT0RFX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJ0XCIgLyogU1RSSUNUX01PREVfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wibFwiIC8qIFBST0ZJTEVSX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJtXCIgLyogUFJPRklMRVJfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgICByZXR1cm4gXCJQcm9maWxlcihcIi5jb25jYXQoZmliZXIubWVtb2l6ZWRQcm9wcy5pZCwgXCIpXCIpO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJwXCIgLyogU0NPUEVfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcInFcIiAvKiBTQ09QRV9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiAnU2NvcGUnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFVua25vd24gZWxlbWVudCB0eXBlLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbWVhbiBhIG5ldyBlbGVtZW50IHR5cGUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIERldlRvb2xzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlcjogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcixcbiAgICBnZXRUeXBlU3ltYm9sOiBnZXRUeXBlU3ltYm9sLFxuICAgIFJlYWN0UHJpb3JpdHlMZXZlbHM6IFJlYWN0UHJpb3JpdHlMZXZlbHMsXG4gICAgUmVhY3RUeXBlT2ZXb3JrOiBSZWFjdFR5cGVPZldvcmssXG4gICAgU3RyaWN0TW9kZUJpdHM6IFN0cmljdE1vZGVCaXRzXG4gIH07XG59IC8vIE1hcCBvZiBvbmUgb3IgbW9yZSBGaWJlcnMgaW4gYSBwYWlyIHRvIHRoZWlyIHVuaXF1ZSBpZCBudW1iZXIuXG4vLyBXZSB0cmFjayBib3RoIEZpYmVycyB0byBzdXBwb3J0IEZhc3QgUmVmcmVzaCxcbi8vIHdoaWNoIG1heSBmb3JjZWZ1bGx5IHJlcGxhY2Ugb25lIG9mIHRoZSBwYWlyIGFzIHBhcnQgb2YgaG90IHJlbG9hZGluZy5cbi8vIEluIHRoYXQgY2FzZSBpdCdzIHN0aWxsIGltcG9ydGFudCB0byBiZSBhYmxlIHRvIGxvY2F0ZSB0aGUgcHJldmlvdXMgSUQgZHVyaW5nIHN1YnNlcXVlbnQgcmVuZGVycy5cblxudmFyIGZpYmVyVG9JRE1hcCA9IG5ldyBNYXAoKTsgLy8gTWFwIG9mIGlkIHRvIG9uZSAoYXJiaXRyYXJ5KSBGaWJlciBpbiBhIHBhaXIuXG4vLyBUaGlzIE1hcCBpcyB1c2VkIHRvIGUuZy4gZ2V0IHRoZSBkaXNwbGF5IG5hbWUgZm9yIGEgRmliZXIgb3Igc2NoZWR1bGUgYW4gdXBkYXRlLFxuLy8gb3BlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSB0aGUgc2FtZSB3aGV0aGVyIHRoZSBjdXJyZW50IGFuZCB3b3JrLWluLXByb2dyZXNzIEZpYmVyIGlzIHVzZWQuXG5cbnZhciBpZFRvQXJiaXRyYXJ5RmliZXJNYXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBhdHRhY2goaG9vaywgcmVuZGVyZXJJRCwgcmVuZGVyZXIsIGdsb2JhbCkge1xuICAvLyBOZXdlciB2ZXJzaW9ucyBvZiB0aGUgcmVjb25jaWxlciBwYWNrYWdlIGFsc28gc3BlY2lmaWMgcmVjb25jaWxlciB2ZXJzaW9uLlxuICAvLyBJZiB0aGF0IHZlcnNpb24gbnVtYmVyIGlzIHByZXNlbnQsIHVzZSBpdC5cbiAgLy8gVGhpcmQgcGFydHkgcmVuZGVyZXIgdmVyc2lvbnMgbWF5IG5vdCBtYXRjaCB0aGUgcmVjb25jaWxlciB2ZXJzaW9uLFxuICAvLyBhbmQgdGhlIGxhdHRlciBpcyB3aGF0J3MgaW1wb3J0YW50IGluIHRlcm1zIG9mIHRhZ3MgYW5kIHN5bWJvbHMuXG4gIHZhciB2ZXJzaW9uID0gcmVuZGVyZXIucmVjb25jaWxlclZlcnNpb24gfHwgcmVuZGVyZXIudmVyc2lvbjtcblxuICB2YXIgX2dldEludGVybmFsUmVhY3RDb25zID0gZ2V0SW50ZXJuYWxSZWFjdENvbnN0YW50cyh2ZXJzaW9uKSxcbiAgICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXIgPSBfZ2V0SW50ZXJuYWxSZWFjdENvbnMuZ2V0RGlzcGxheU5hbWVGb3JGaWJlcixcbiAgICAgIGdldFR5cGVTeW1ib2wgPSBfZ2V0SW50ZXJuYWxSZWFjdENvbnMuZ2V0VHlwZVN5bWJvbCxcbiAgICAgIFJlYWN0UHJpb3JpdHlMZXZlbHMgPSBfZ2V0SW50ZXJuYWxSZWFjdENvbnMuUmVhY3RQcmlvcml0eUxldmVscyxcbiAgICAgIFJlYWN0VHlwZU9mV29yayA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5SZWFjdFR5cGVPZldvcmssXG4gICAgICBTdHJpY3RNb2RlQml0cyA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5TdHJpY3RNb2RlQml0cztcblxuICB2YXIgQ2FjaGVDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuQ2FjaGVDb21wb25lbnQsXG4gICAgICBDbGFzc0NvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5DbGFzc0NvbXBvbmVudCxcbiAgICAgIENvbnRleHRDb25zdW1lciA9IFJlYWN0VHlwZU9mV29yay5Db250ZXh0Q29uc3VtZXIsXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50LFxuICAgICAgRm9yd2FyZFJlZiA9IFJlYWN0VHlwZU9mV29yay5Gb3J3YXJkUmVmLFxuICAgICAgRnJhZ21lbnQgPSBSZWFjdFR5cGVPZldvcmsuRnJhZ21lbnQsXG4gICAgICBGdW5jdGlvbkNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5GdW5jdGlvbkNvbXBvbmVudCxcbiAgICAgIEhvc3RSb290ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RSb290LFxuICAgICAgSG9zdEhvaXN0YWJsZSA9IFJlYWN0VHlwZU9mV29yay5Ib3N0SG9pc3RhYmxlLFxuICAgICAgSG9zdFNpbmdsZXRvbiA9IFJlYWN0VHlwZU9mV29yay5Ib3N0U2luZ2xldG9uLFxuICAgICAgSG9zdFBvcnRhbCA9IFJlYWN0VHlwZU9mV29yay5Ib3N0UG9ydGFsLFxuICAgICAgSG9zdENvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5Ib3N0Q29tcG9uZW50LFxuICAgICAgSG9zdFRleHQgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFRleHQsXG4gICAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5JbmRldGVybWluYXRlQ29tcG9uZW50LFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkxlZ2FjeUhpZGRlbkNvbXBvbmVudCxcbiAgICAgIE1lbW9Db21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuTWVtb0NvbXBvbmVudCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5PZmZzY3JlZW5Db21wb25lbnQsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLlNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgICBTdXNwZW5zZUNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5TdXNwZW5zZUNvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5TdXNwZW5zZUxpc3RDb21wb25lbnQsXG4gICAgICBUcmFjaW5nTWFya2VyQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLlRyYWNpbmdNYXJrZXJDb21wb25lbnQ7XG4gIHZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuSW1tZWRpYXRlUHJpb3JpdHksXG4gICAgICBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgICBOb3JtYWxQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuTm9ybWFsUHJpb3JpdHksXG4gICAgICBMb3dQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuTG93UHJpb3JpdHksXG4gICAgICBJZGxlUHJpb3JpdHkgPSBSZWFjdFByaW9yaXR5TGV2ZWxzLklkbGVQcmlvcml0eSxcbiAgICAgIE5vUHJpb3JpdHkgPSBSZWFjdFByaW9yaXR5TGV2ZWxzLk5vUHJpb3JpdHk7XG4gIHZhciBnZXRMYW5lTGFiZWxNYXAgPSByZW5kZXJlci5nZXRMYW5lTGFiZWxNYXAsXG4gICAgICBpbmplY3RQcm9maWxpbmdIb29rcyA9IHJlbmRlcmVyLmluamVjdFByb2ZpbGluZ0hvb2tzLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGUgPSByZW5kZXJlci5vdmVycmlkZUhvb2tTdGF0ZSxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IHJlbmRlcmVyLm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IHJlbmRlcmVyLm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCxcbiAgICAgIG92ZXJyaWRlUHJvcHMgPSByZW5kZXJlci5vdmVycmlkZVByb3BzLFxuICAgICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSByZW5kZXJlci5vdmVycmlkZVByb3BzRGVsZXRlUGF0aCxcbiAgICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gcmVuZGVyZXIub3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG4gICAgICBzY2hlZHVsZVJlZnJlc2ggPSByZW5kZXJlci5zY2hlZHVsZVJlZnJlc2gsXG4gICAgICBzZXRFcnJvckhhbmRsZXIgPSByZW5kZXJlci5zZXRFcnJvckhhbmRsZXIsXG4gICAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSByZW5kZXJlci5zZXRTdXNwZW5zZUhhbmRsZXIsXG4gICAgICBzY2hlZHVsZVVwZGF0ZSA9IHJlbmRlcmVyLnNjaGVkdWxlVXBkYXRlO1xuICB2YXIgc3VwcG9ydHNUb2dnbGluZ0Vycm9yID0gdHlwZW9mIHNldEVycm9ySGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2NoZWR1bGVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG4gIHZhciBzdXBwb3J0c1RvZ2dsaW5nU3VzcGVuc2UgPSB0eXBlb2Ygc2V0U3VzcGVuc2VIYW5kbGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzY2hlZHVsZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAodHlwZW9mIHNjaGVkdWxlUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFdoZW4gRmFzdCBSZWZyZXNoIHVwZGF0ZXMgYSBjb21wb25lbnQsIHRoZSBmcm9udGVuZCBtYXkgbmVlZCB0byBwdXJnZSBjYWNoZWQgaW5mb3JtYXRpb24uXG4gICAgLy8gRm9yIGV4YW1wbGUsIEFTVHMgY2FjaGVkIGZvciB0aGUgY29tcG9uZW50IChmb3IgbmFtZWQgaG9va3MpIG1heSBubyBsb25nZXIgYmUgdmFsaWQuXG4gICAgLy8gU2VuZCBhIHNpZ25hbCB0byB0aGUgZnJvbnRlbmQgdG8gcHVyZ2UgdGhpcyBjYWNoZWQgaW5mb3JtYXRpb24uXG4gICAgLy8gVGhlIFwiZmFzdFJlZnJlc2hTY2hlZHVsZWRcIiBkaXNwYXRjaGVkIGlzIGdsb2JhbCAobm90IEZpYmVyIG9yIGV2ZW4gUmVuZGVyZXIgc3BlY2lmaWMpLlxuICAgIC8vIFRoaXMgaXMgbGVzcyBlZmZlY2llbnQgc2luY2UgaXQgbWVhbnMgdGhlIGZyb250LWVuZCB3aWxsIG5lZWQgdG8gcHVyZ2UgdGhlIGVudGlyZSBjYWNoZSxcbiAgICAvLyBidXQgdGhpcyBpcyBwcm9iYWJseSBhbiBva2F5IHRyYWRlIG9mZiBpbiBvcmRlciB0byByZWR1Y2UgY291cGxpbmcgYmV0d2VlbiB0aGUgRGV2VG9vbHMgYW5kIEZhc3QgUmVmcmVzaC5cbiAgICByZW5kZXJlci5zY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBob29rLmVtaXQoJ2Zhc3RSZWZyZXNoU2NoZWR1bGVkJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVSZWZyZXNoLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGdldFRpbWVsaW5lRGF0YSA9IG51bGw7XG4gIHZhciB0b2dnbGVQcm9maWxpbmdTdGF0dXMgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YgaW5qZWN0UHJvZmlsaW5nSG9va3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBjcmVhdGVQcm9maWxpbmdIb29rcyh7XG4gICAgICBnZXREaXNwbGF5TmFtZUZvckZpYmVyOiBnZXREaXNwbGF5TmFtZUZvckZpYmVyLFxuICAgICAgZ2V0SXNQcm9maWxpbmc6IGZ1bmN0aW9uIGdldElzUHJvZmlsaW5nKCkge1xuICAgICAgICByZXR1cm4gaXNQcm9maWxpbmc7XG4gICAgICB9LFxuICAgICAgZ2V0TGFuZUxhYmVsTWFwOiBnZXRMYW5lTGFiZWxNYXAsXG4gICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogcmVuZGVyZXIuY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICB3b3JrVGFnTWFwOiBSZWFjdFR5cGVPZldvcmssXG4gICAgICByZWFjdFZlcnNpb246IHZlcnNpb25cbiAgICB9KTsgLy8gUGFzcyB0aGUgUHJvZmlsaW5nIGhvb2tzIHRvIHRoZSByZWNvbmNpbGVyIGZvciBpdCB0byBjYWxsIGR1cmluZyByZW5kZXIuXG5cbiAgICBpbmplY3RQcm9maWxpbmdIb29rcyhyZXNwb25zZS5wcm9maWxpbmdIb29rcyk7IC8vIEhhbmcgb250byB0aGlzIHRvZ2dsZSBzbyB3ZSBjYW4gbm90aWZ5IHRoZSBleHRlcm5hbCBtZXRob2RzIG9mIHByb2ZpbGluZyBzdGF0dXMgY2hhbmdlcy5cblxuICAgIGdldFRpbWVsaW5lRGF0YSA9IHJlc3BvbnNlLmdldFRpbWVsaW5lRGF0YTtcbiAgICB0b2dnbGVQcm9maWxpbmdTdGF0dXMgPSByZXNwb25zZS50b2dnbGVQcm9maWxpbmdTdGF0dXM7XG4gIH0gLy8gVHJhY2tzIEZpYmVycyB3aXRoIHJlY2VudGx5IGNoYW5nZWQgbnVtYmVyIG9mIGVycm9yL3dhcm5pbmcgbWVzc2FnZXMuXG4gIC8vIFRoZXNlIGNvbGxlY3Rpb25zIHN0b3JlIHRoZSBGaWJlciByYXRoZXIgdGhhbiB0aGUgSUQsXG4gIC8vIGluIG9yZGVyIHRvIGF2b2lkIGdlbmVyYXRpbmcgYW4gSUQgZm9yIEZpYmVycyB0aGF0IG5ldmVyIGdldCBtb3VudGVkXG4gIC8vIChkdWUgdG8gZS5nLiBTdXNwZW5zZSBvciBlcnJvciBib3VuZGFyaWVzKS5cbiAgLy8gb25FcnJvck9yV2FybmluZygpIGFkZHMgRmliZXJzIGFuZCByZWNvcmRQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3MoKSBsYXRlciBjbGVhcnMgdGhlbS5cblxuXG4gIHZhciBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzID0gbmV3IFNldCgpO1xuICB2YXIgcGVuZGluZ0ZpYmVyVG9FcnJvcnNNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwID0gbmV3IE1hcCgpOyAvLyBNYXBwaW5nIG9mIGZpYmVyIElEcyB0byBlcnJvci93YXJuaW5nIG1lc3NhZ2VzIGFuZCBjb3VudHMuXG5cbiAgdmFyIGZpYmVySURUb0Vycm9yc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIGZpYmVySURUb1dhcm5pbmdzTWFwID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3JzQW5kV2FybmluZ3MoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmliZXJJRFRvRXJyb3JzTWFwLmtleXMoKSksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBpZCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIHZhciBfZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoX2ZpYmVyICE9IG51bGwpIHtcbiAgICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChfZmliZXIpO1xuICAgICAgICAgIHVwZGF0ZU1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRJZk5lY2Vzc2FyeShpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcblxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpYmVySURUb1dhcm5pbmdzTWFwLmtleXMoKSksXG4gICAgICAgIF9zdGVwMjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX2lkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgIHZhciBfZmliZXIyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChfaWQpO1xuXG4gICAgICAgIGlmIChfZmliZXIyICE9IG51bGwpIHtcbiAgICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChfZmliZXIyKTtcbiAgICAgICAgICB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cblxuICAgIGZpYmVySURUb0Vycm9yc01hcC5jbGVhcigpO1xuICAgIGZpYmVySURUb1dhcm5pbmdzTWFwLmNsZWFyKCk7XG4gICAgZmx1c2hQZW5kaW5nRXZlbnRzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lc3NhZ2VDb3VudEhlbHBlcihmaWJlcklELCBwZW5kaW5nRmliZXJUb01lc3NhZ2VDb3VudE1hcCwgZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwKSB7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChmaWJlcklEKTtcblxuICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAvLyBUaHJvdyBvdXQgYW55IHBlbmRpbmcgY2hhbmdlcy5cbiAgICAgIHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwLmRlbGV0ZShmaWJlcik7XG5cbiAgICAgIGlmIChmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuaGFzKGZpYmVySUQpKSB7XG4gICAgICAgIGZpYmVySURUb01lc3NhZ2VDb3VudE1hcC5kZWxldGUoZmliZXJJRCk7IC8vIElmIHByZXZpb3VzIGZsdXNoZWQgY291bnRzIGhhdmUgY2hhbmdlZCwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvby5cblxuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChmaWJlcik7XG4gICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cygpO1xuICAgICAgICB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoZmliZXJJRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmRlbGV0ZShmaWJlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnNGb3JGaWJlcklEKGZpYmVySUQpIHtcbiAgICBjbGVhck1lc3NhZ2VDb3VudEhlbHBlcihmaWJlcklELCBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCwgZmliZXJJRFRvRXJyb3JzTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyV2FybmluZ3NGb3JGaWJlcklEKGZpYmVySUQpIHtcbiAgICBjbGVhck1lc3NhZ2VDb3VudEhlbHBlcihmaWJlcklELCBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwLCBmaWJlcklEVG9XYXJuaW5nc01hcCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoZmliZXJJRCkge1xuICAgIGlmIChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQuaWQgPT09IGZpYmVySUQpIHtcbiAgICAgIGhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gLy8gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb3Igd2FybmluZyBpcyBsb2dnZWQgZHVyaW5nIHJlbmRlciwgY29tbWl0LCBvciBwYXNzaXZlIChpbmNsdWRpbmcgdW5tb3VudCBmdW5jdGlvbnMpLlxuXG5cbiAgZnVuY3Rpb24gb25FcnJvck9yV2FybmluZyhmaWJlciwgdHlwZSwgYXJncykge1xuICAgIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICB2YXIgbWF5YmVJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpOyAvLyBpZiB0aGlzIGlzIGFuIGVycm9yIHNpbXVsYXRlZCBieSB1cyB0byB0cmlnZ2VyIGVycm9yIGJvdW5kYXJ5LCBpZ25vcmVcblxuICAgICAgaWYgKG1heWJlSUQgIT0gbnVsbCAmJiBmb3JjZUVycm9yRm9yRmliZXJJRHMuZ2V0KG1heWJlSUQpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZSA9IGJhY2tlbmRfdXRpbHNbXCJlXCIgLyogZm9ybWF0ICovXS5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG5cbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIGRlYnVnKCdvbkVycm9yT3JXYXJuaW5nJywgZmliZXIsIG51bGwsIFwiXCIuY29uY2F0KHR5cGUsIFwiOiBcXFwiXCIpLmNvbmNhdChtZXNzYWdlLCBcIlxcXCJcIikpO1xuICAgIH0gLy8gTWFyayB0aGlzIEZpYmVyIGFzIG5lZWRlZCBpdHMgd2FybmluZy9lcnJvciBjb3VudCB1cGRhdGVkIGR1cmluZyB0aGUgbmV4dCBmbHVzaC5cblxuXG4gICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5hZGQoZmliZXIpOyAvLyBUcmFjayB0aGUgd2FybmluZy9lcnJvciBmb3IgbGF0ZXIuXG5cbiAgICB2YXIgZmliZXJNYXAgPSB0eXBlID09PSAnZXJyb3InID8gcGVuZGluZ0ZpYmVyVG9FcnJvcnNNYXAgOiBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwO1xuICAgIHZhciBtZXNzYWdlTWFwID0gZmliZXJNYXAuZ2V0KGZpYmVyKTtcblxuICAgIGlmIChtZXNzYWdlTWFwICE9IG51bGwpIHtcbiAgICAgIHZhciBjb3VudCA9IG1lc3NhZ2VNYXAuZ2V0KG1lc3NhZ2UpIHx8IDA7XG4gICAgICBtZXNzYWdlTWFwLnNldChtZXNzYWdlLCBjb3VudCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWJlck1hcC5zZXQoZmliZXIsIG5ldyBNYXAoW1ttZXNzYWdlLCAxXV0pKTtcbiAgICB9IC8vIFBhc3NpdmUgZWZmZWN0cyBtYXkgdHJpZ2dlciBlcnJvcnMgb3Igd2FybmluZ3MgdG9vO1xuICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugc2hvdWxkIHdhaXQgdW50aWwgdGhlIHJlc3Qgb2YgdGhlIHBhc3NpdmUgZWZmZWN0cyBoYXZlIHJ1bixcbiAgICAvLyBidXQgd2Ugc2hvdWxkbid0IHdhaXQgdW50aWwgdGhlIG5leHQgY29tbWl0IGJlY2F1c2UgdGhhdCBtaWdodCBiZSBhIGxvbmcgdGltZS5cbiAgICAvLyBUaGlzIHdvdWxkIGFsc28gY2F1c2UgXCJ0ZWFyaW5nXCIgYmV0d2VlbiBhbiBpbnNwZWN0ZWQgQ29tcG9uZW50IGFuZCB0aGUgdHJlZSB2aWV3LlxuICAgIC8vIFRoZW4gYWdhaW4gd2UgZG9uJ3Qgd2FudCB0byBmbHVzaCB0b28gc29vbiBiZWNhdXNlIHRoaXMgY291bGQgYmUgYW4gZXJyb3IgZHVyaW5nIGFzeW5jIHJlbmRlcmluZy5cbiAgICAvLyBVc2UgYSBkZWJvdW5jZSB0ZWNobmlxdWUgdG8gZW5zdXJlIHRoYXQgd2UnbGwgZXZlbnR1YWxseSBmbHVzaC5cblxuXG4gICAgZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCk7XG4gIH0gLy8gUGF0Y2hpbmcgdGhlIGNvbnNvbGUgZW5hYmxlcyBEZXZUb29scyB0byBkbyBhIGZldyB1c2VmdWwgdGhpbmdzOlxuICAvLyAqIEFwcGVuZCBjb21wb25lbnQgc3RhY2tzIHRvIHdhcm5pbmdzIGFuZCBlcnJvciBtZXNzYWdlc1xuICAvLyAqIERpc2FibGUgbG9nZ2luZyBkdXJpbmcgcmUtcmVuZGVycyB0byBpbnNwZWN0IGhvb2tzIChzZWUgaW5zcGVjdEhvb2tzT2ZGaWJlcilcblxuXG4gIE9iamVjdChiYWNrZW5kX2NvbnNvbGVbXCJlXCIgLyogcmVnaXN0ZXJSZW5kZXJlciAqL10pKHJlbmRlcmVyLCBvbkVycm9yT3JXYXJuaW5nKTsgLy8gVGhlIHJlbmRlcmVyIGludGVyZmFjZSBjYW4ndCByZWFkIHRoZXNlIHByZWZlcmVuY2VzIGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIGl0IGlzIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2Ugd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBleHRlbnNpb24uXG4gIC8vIEl0IHJlbGllcyBvbiB0aGUgZXh0ZW5zaW9uIHRvIHBhc3MgdGhlIHByZWZlcmVuY2UgdGhyb3VnaCB2aWEgdGhlIGdsb2JhbC5cblxuICBPYmplY3QoYmFja2VuZF9jb25zb2xlW1wiY1wiIC8qIHBhdGNoQ29uc29sZVVzaW5nV2luZG93VmFsdWVzICovXSkoKTtcblxuICB2YXIgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZyhuYW1lLCBmaWJlciwgcGFyZW50RmliZXIpIHtcbiAgICB2YXIgZXh0cmFTdHJpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcnO1xuXG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBmaWJlci50YWcgKyAnOicgKyAoZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ251bGwnKTtcbiAgICAgIHZhciBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcikgfHwgJzxubyBpZD4nO1xuICAgICAgdmFyIHBhcmVudERpc3BsYXlOYW1lID0gcGFyZW50RmliZXIgPyBwYXJlbnRGaWJlci50YWcgKyAnOicgKyAoZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihwYXJlbnRGaWJlcikgfHwgJ251bGwnKSA6ICcnO1xuICAgICAgdmFyIG1heWJlUGFyZW50SUQgPSBwYXJlbnRGaWJlciA/IGdldEZpYmVySURVbnNhZmUocGFyZW50RmliZXIpIHx8ICc8bm8taWQ+JyA6ICcnO1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIltyZW5kZXJlcl0gJWNcIi5jb25jYXQobmFtZSwgXCIgJWNcIikuY29uY2F0KGRpc3BsYXlOYW1lLCBcIiAoXCIpLmNvbmNhdChtYXliZUlELCBcIikgJWNcIikuY29uY2F0KHBhcmVudEZpYmVyID8gXCJcIi5jb25jYXQocGFyZW50RGlzcGxheU5hbWUsIFwiIChcIikuY29uY2F0KG1heWJlUGFyZW50SUQsIFwiKVwiKSA6ICcnLCBcIiAlY1wiKS5jb25jYXQoZXh0cmFTdHJpbmcpLCAnY29sb3I6IHJlZDsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2NvbG9yOiBibHVlOycsICdjb2xvcjogcHVycGxlOycsICdjb2xvcjogYmxhY2s7Jyk7XG4gICAgICBjb25zb2xlLmxvZyhuZXcgRXJyb3IoKS5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJykpO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfTsgLy8gQ29uZmlndXJhYmxlIENvbXBvbmVudHMgdHJlZSBmaWx0ZXJzLlxuXG5cbiAgdmFyIGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBoaWRlRWxlbWVudHNXaXRoUGF0aHMgPSBuZXcgU2V0KCk7XG4gIHZhciBoaWRlRWxlbWVudHNXaXRoVHlwZXMgPSBuZXcgU2V0KCk7IC8vIEhpZ2hsaWdodCB1cGRhdGVzXG5cbiAgdmFyIHRyYWNlVXBkYXRlc0VuYWJsZWQgPSBmYWxzZTtcbiAgdmFyIHRyYWNlVXBkYXRlc0Zvck5vZGVzID0gbmV3IFNldCgpO1xuXG4gIGZ1bmN0aW9uIGFwcGx5Q29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKSB7XG4gICAgaGlkZUVsZW1lbnRzV2l0aFR5cGVzLmNsZWFyKCk7XG4gICAgaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcy5jbGVhcigpO1xuICAgIGhpZGVFbGVtZW50c1dpdGhQYXRocy5jbGVhcigpO1xuICAgIGNvbXBvbmVudEZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50RmlsdGVyKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudEZpbHRlci5pc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudEZpbHRlci50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXNbXCJhXCIgLyogQ29tcG9uZW50RmlsdGVyRGlzcGxheU5hbWUgKi9dOlxuICAgICAgICAgIGlmIChjb21wb25lbnRGaWx0ZXIuaXNWYWxpZCAmJiBjb21wb25lbnRGaWx0ZXIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLmFkZChuZXcgUmVnRXhwKGNvbXBvbmVudEZpbHRlci52YWx1ZSwgJ2knKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0eXBlc1tcImJcIiAvKiBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZSAqL106XG4gICAgICAgICAgaGlkZUVsZW1lbnRzV2l0aFR5cGVzLmFkZChjb21wb25lbnRGaWx0ZXIudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdHlwZXNbXCJkXCIgLyogQ29tcG9uZW50RmlsdGVyTG9jYXRpb24gKi9dOlxuICAgICAgICAgIGlmIChjb21wb25lbnRGaWx0ZXIuaXNWYWxpZCAmJiBjb21wb25lbnRGaWx0ZXIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoUGF0aHMuYWRkKG5ldyBSZWdFeHAoY29tcG9uZW50RmlsdGVyLnZhbHVlLCAnaScpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHR5cGVzW1wiY1wiIC8qIENvbXBvbmVudEZpbHRlckhPQyAqL106XG4gICAgICAgICAgaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcy5hZGQobmV3IFJlZ0V4cCgnXFxcXCgnKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIGNvbXBvbmVudCBmaWx0ZXIgdHlwZSBcXFwiXCIuY29uY2F0KGNvbXBvbmVudEZpbHRlci50eXBlLCBcIlxcXCJcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIFRoZSByZW5kZXJlciBpbnRlcmZhY2UgY2FuJ3QgcmVhZCBzYXZlZCBjb21wb25lbnQgZmlsdGVycyBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB0aGV5IGFyZSBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZXh0ZW5zaW9uLlxuICAvLyBJbnN0ZWFkIGl0IHJlbGllcyBvbiB0aGUgZXh0ZW5zaW9uIHRvIHBhc3MgZmlsdGVycyB0aHJvdWdoLlxuXG5cbiAgaWYgKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTVBPTkVOVF9GSUxURVJTX18gIT0gbnVsbCkge1xuICAgIGFwcGx5Q29tcG9uZW50RmlsdGVycyh3aW5kb3cuX19SRUFDVF9ERVZUT09MU19DT01QT05FTlRfRklMVEVSU19fKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgZmVhdHVyZSBpcyBub3QgZXhwZWN0ZWQgdG8gd29yayBmb3IgUmVhY3QgTmF0aXZlIGZvciBub3cuXG4gICAgLy8gSXQgd291bGQgYmUgYW5ub3lpbmcgZm9yIHVzIHRvIHNwYW0gWWVsbG93Qm94IHdhcm5pbmdzIHdpdGggdW5hY3Rpb25hYmxlIHN0dWZmLFxuICAgIC8vIHNvIGZvciBub3cganVzdCBza2lwIHRoaXMgbWVzc2FnZS4uLlxuICAgIC8vY29uc29sZS53YXJuKCfimpvvuI8gRGV2VG9vbHM6IENvdWxkIG5vdCBsb2NhdGUgc2F2ZWQgY29tcG9uZW50IGZpbHRlcnMnKTtcbiAgICAvLyBGYWxsYmFjayB0byBhc3N1bWluZyB0aGUgZGVmYXVsdCBmaWx0ZXJzIGluIHRoaXMgY2FzZS5cbiAgICBhcHBseUNvbXBvbmVudEZpbHRlcnMoT2JqZWN0KHV0aWxzW1wiZ1wiIC8qIGdldERlZmF1bHRDb21wb25lbnRGaWx0ZXJzICovXSkoKSk7XG4gIH0gLy8gSWYgbmVjZXNzYXJ5LCB3ZSBjYW4gcmV2aXNpdCBvcHRpbWl6aW5nIHRoaXMgb3BlcmF0aW9uLlxuICAvLyBGb3IgZXhhbXBsZSwgd2UgY291bGQgYWRkIGEgbmV3IHJlY3Vyc2l2ZSB1bm1vdW50IHRyZWUgb3BlcmF0aW9uLlxuICAvLyBUaGUgdW5tb3VudCBvcGVyYXRpb25zIGFyZSBhbHJlYWR5IHNpZ25pZmljYW50bHkgc21hbGxlciB0aGFuIG1vdW50IG9wZXJhdGlvbnMgdGhvdWdoLlxuICAvLyBUaGlzIGlzIHNvbWV0aGluZyB0byBrZWVwIGluIG1pbmQgZm9yIGxhdGVyLlxuXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAvLyBSZS1tb3VudGluZyBhIHRyZWUgd2hpbGUgcHJvZmlsaW5nIGlzIGluIHByb2dyZXNzIG1pZ2h0IGJyZWFrIGEgbG90IG9mIGFzc3VtcHRpb25zLlxuICAgICAgLy8gSWYgbmVjZXNzYXJ5LCB3ZSBjb3VsZCBzdXBwb3J0IHRoaXMtIGJ1dCBpdCBkb2Vzbid0IHNlZW0gbGlrZSBhIG5lY2Vzc2FyeSB1c2UgY2FzZS5cbiAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgbW9kaWZ5IGZpbHRlciBwcmVmZXJlbmNlcyB3aGlsZSBwcm9maWxpbmcnKTtcbiAgICB9IC8vIFJlY3Vyc2l2ZWx5IHVubW91bnQgYWxsIHJvb3RzLlxuXG5cbiAgICBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCkuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgY3VycmVudFJvb3RJRCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKHJvb3QuY3VycmVudCk7IC8vIFRoZSBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCBvcGVyYXRpb24gc2VydmVzIHR3byBwdXJwb3NlczpcbiAgICAgIC8vIDEuIEl0IGF2b2lkcyBzZW5kaW5nIHVubmVjZXNzYXJ5IGJyaWRnZSB0cmFmZmljIHRvIGNsZWFyIGEgcm9vdC5cbiAgICAgIC8vIDIuIEl0IHByZXNlcnZlcyBGaWJlciBJRHMgd2hlbiByZW1vdW50aW5nIChiZWxvdykgd2hpY2ggaW4gdHVybiBJRCB0byBlcnJvci93YXJuaW5nIG1hcHBpbmcuXG5cbiAgICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wiblwiIC8qIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UICovXSk7XG4gICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG4gICAgICBjdXJyZW50Um9vdElEID0gLTE7XG4gICAgfSk7XG4gICAgYXBwbHlDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnMpOyAvLyBSZXNldCBwc2V1ZG8gY291bnRlcnMgc28gdGhhdCBuZXcgcGF0aCBzZWxlY3Rpb25zIHdpbGwgYmUgcGVyc2lzdGVkLlxuXG4gICAgcm9vdERpc3BsYXlOYW1lQ291bnRlci5jbGVhcigpOyAvLyBSZWN1cnNpdmVseSByZS1tb3VudCBhbGwgcm9vdHMgd2l0aCBuZXcgZmlsdGVyIGNyaXRlcmlhIGFwcGxpZWQuXG5cbiAgICBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCkuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgY3VycmVudFJvb3RJRCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKHJvb3QuY3VycmVudCk7XG4gICAgICBzZXRSb290UHNldWRvS2V5KGN1cnJlbnRSb290SUQsIHJvb3QuY3VycmVudCk7XG4gICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3QpO1xuICAgICAgY3VycmVudFJvb3RJRCA9IC0xO1xuICAgIH0pOyAvLyBBbHNvIHJlLWV2YWx1YXRlIGFsbCBlcnJvciBhbmQgd2FybmluZyBjb3VudHMgZ2l2ZW4gdGhlIG5ldyBmaWx0ZXJzLlxuXG4gICAgcmVldmFsdWF0ZUVycm9yc0FuZFdhcm5pbmdzKCk7XG4gICAgZmx1c2hQZW5kaW5nRXZlbnRzKCk7XG4gIH0gLy8gTk9USUNFIEtlZXAgaW4gc3luYyB3aXRoIGdldCpGb3JGaWJlciBtZXRob2RzXG5cblxuICBmdW5jdGlvbiBzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikge1xuICAgIHZhciBfZGVidWdTb3VyY2UgPSBmaWJlci5fZGVidWdTb3VyY2UsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGUsXG4gICAgICAgIGtleSA9IGZpYmVyLmtleTtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgLy8gVE9ETzogaWRlYWxseSB3ZSB3b3VsZCBzaG93IGRlaHlkcmF0ZWQgU3VzcGVuc2UgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGl0IGhhcyBzb21lIHNwZWNpYWwgYmVoYXZpb3IgKGxpa2UgZGlzY29ubmVjdGluZ1xuICAgICAgICAvLyBhbiBhbHRlcm5hdGUgYW5kIHR1cm5pbmcgaW50byByZWFsIFN1c3BlbnNlKSB3aGljaCBicmVha3MgRGV2VG9vbHMuXG4gICAgICAgIC8vIEZvciBub3csIGlnbm9yZSBpdCwgYW5kIG9ubHkgc2hvdyBpdCBvbmNlIGl0IGdldHMgaHlkcmF0ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9idmF1Z2huL3JlYWN0LWRldnRvb2xzLWV4cGVyaW1lbnRhbC9pc3N1ZXMvMTk3XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIC8vIEl0IGlzIG5ldmVyIHZhbGlkIHRvIGZpbHRlciB0aGUgcm9vdCBlbGVtZW50LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBrZXkgPT09IG51bGw7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImFcIiAvKiBDT05DVVJSRU5UX01PREVfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImJcIiAvKiBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJlXCIgLyogREVQUkVDQVRFRF9BU1lOQ19NT0RFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wic1wiIC8qIFNUUklDVF9NT0RFX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJ0XCIgLyogU1RSSUNUX01PREVfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoaGlkZUVsZW1lbnRzV2l0aFR5cGVzLmhhcyhlbGVtZW50VHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKTtcblxuICAgICAgaWYgKGRpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzKSxcbiAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZGlzcGxheU5hbWVSZWdFeHAgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChkaXNwbGF5TmFtZVJlZ0V4cC50ZXN0KGRpc3BsYXlOYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9kZWJ1Z1NvdXJjZSAhPSBudWxsICYmIGhpZGVFbGVtZW50c1dpdGhQYXRocy5zaXplID4gMCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gX2RlYnVnU291cmNlLmZpbGVOYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGhpZGVFbGVtZW50c1dpdGhQYXRocyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwYXRoUmVnRXhwID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHBhdGhSZWdFeHAudGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIE5PVElDRSBLZWVwIGluIHN5bmMgd2l0aCBzaG91bGRGaWx0ZXJGaWJlcigpIGFuZCBvdGhlciBnZXQqRm9yRmliZXIgbWV0aG9kc1xuXG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcikge1xuICAgIHZhciB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAgdGFnID0gZmliZXIudGFnO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dO1xuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL107XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wiZ1wiIC8qIEVsZW1lbnRUeXBlRm9yd2FyZFJlZiAqL107XG5cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB0eXBlc1tcIm1cIiAvKiBFbGVtZW50VHlwZVJvb3QgKi9dO1xuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICAgIHJldHVybiB0eXBlc1tcImlcIiAvKiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQgKi9dO1xuXG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dO1xuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiB0eXBlc1tcImpcIiAvKiBFbGVtZW50VHlwZU1lbW8gKi9dO1xuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdHlwZXNbXCJuXCIgLyogRWxlbWVudFR5cGVTdXNwZW5zZSAqL107XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdHlwZXNbXCJvXCIgLyogRWxlbWVudFR5cGVTdXNwZW5zZUxpc3QgKi9dO1xuXG4gICAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB0eXBlc1tcInBcIiAvKiBFbGVtZW50VHlwZVRyYWNpbmdNYXJrZXIgKi9dO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJhXCIgLyogQ09OQ1VSUkVOVF9NT0RFX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJiXCIgLyogQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiZVwiIC8qIERFUFJFQ0FURURfQVNZTkNfTU9ERV9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlc1tcImtcIiAvKiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duICovXTtcblxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiblwiIC8qIFBST1ZJREVSX05VTUJFUiAqL106XG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJvXCIgLyogUFJPVklERVJfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgICAgICByZXR1cm4gdHlwZXNbXCJmXCIgLyogRWxlbWVudFR5cGVDb250ZXh0ICovXTtcblxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wiY1wiIC8qIENPTlRFWFRfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImRcIiAvKiBDT05URVhUX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzW1wiZlwiIC8qIEVsZW1lbnRUeXBlQ29udGV4dCAqL107XG5cbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcInNcIiAvKiBTVFJJQ1RfTU9ERV9OVU1CRVIgKi9dOlxuICAgICAgICAgIGNhc2UgUmVhY3RTeW1ib2xzW1widFwiIC8qIFNUUklDVF9NT0RFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dO1xuXG4gICAgICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJsXCIgLyogUFJPRklMRVJfTlVNQkVSICovXTpcbiAgICAgICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcIm1cIiAvKiBQUk9GSUxFUl9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlc1tcImxcIiAvKiBFbGVtZW50VHlwZVByb2ZpbGVyICovXTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL107XG4gICAgICAgIH1cblxuICAgIH1cbiAgfSAvLyBXaGVuIHByb2ZpbGluZyBpcyBzdXBwb3J0ZWQsIHdlIHN0b3JlIHRoZSBsYXRlc3QgdHJlZSBiYXNlIGR1cmF0aW9ucyBmb3IgZWFjaCBGaWJlci5cbiAgLy8gVGhpcyBpcyBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IGNhcHR1cmUgYSBzbmFwc2hvdCBvZiB0aG9zZSB2YWx1ZXMgaWYgcHJvZmlsaW5nIHN0YXJ0cy5cbiAgLy8gSWYgd2UgZGlkbid0IHN0b3JlIHRoZXNlIHZhbHVlcywgd2UnZCBoYXZlIHRvIGNyYXdsIHRoZSB0cmVlIHdoZW4gcHJvZmlsaW5nIHN0YXJ0ZWQsXG4gIC8vIGFuZCB1c2UgYSBzbG93IHBhdGggdG8gZmluZCBlYWNoIG9mIHRoZSBjdXJyZW50IEZpYmVycy5cblxuXG4gIHZhciBpZFRvVHJlZUJhc2VEdXJhdGlvbk1hcCA9IG5ldyBNYXAoKTsgLy8gV2hlbiBwcm9maWxpbmcgaXMgc3VwcG9ydGVkLCB3ZSBzdG9yZSB0aGUgbGF0ZXN0IHRyZWUgYmFzZSBkdXJhdGlvbnMgZm9yIGVhY2ggRmliZXIuXG4gIC8vIFRoaXMgbWFwIGVuYWJsZXMgdXMgdG8gZmlsdGVyIHRoZXNlIHRpbWVzIGJ5IHJvb3Qgd2hlbiBzZW5kaW5nIHRoZW0gdG8gdGhlIGZyb250ZW5kLlxuXG4gIHZhciBpZFRvUm9vdE1hcCA9IG5ldyBNYXAoKTsgLy8gV2hlbiBhIG1vdW50IG9yIHVwZGF0ZSBpcyBpbiBwcm9ncmVzcywgdGhpcyB2YWx1ZSB0cmFja3MgdGhlIHJvb3QgdGhhdCBpcyBiZWluZyBvcGVyYXRlZCBvbi5cblxuICB2YXIgY3VycmVudFJvb3RJRCA9IC0xOyAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgZm9yIGEgRmliZXIgb3IgZ2VuZXJhdGVzIGFuZCBjYWNoZXMgYSBuZXcgb25lIGlmIHRoZSBGaWJlciBoYXNuJ3QgYmVlbiBzZWVuIGJlZm9yZS5cbiAgLy8gT25jZSB0aGlzIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQgZm9yIGEgRmliZXIsIHVudHJhY2tGaWJlcklEKCkgc2hvdWxkIGFsd2F5cyBiZSBjYWxsZWQgbGF0ZXIgdG8gYXZvaWQgbGVha2luZy5cblxuICBmdW5jdGlvbiBnZXRPckdlbmVyYXRlRmliZXJJRChmaWJlcikge1xuICAgIHZhciBpZCA9IG51bGw7XG5cbiAgICBpZiAoZmliZXJUb0lETWFwLmhhcyhmaWJlcikpIHtcbiAgICAgIGlkID0gZmliZXJUb0lETWFwLmdldChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBmaWJlclRvSURNYXAuaGFzKF9hbHRlcm5hdGUpKSB7XG4gICAgICAgIGlkID0gZmliZXJUb0lETWFwLmdldChfYWx0ZXJuYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlkR2VuZXJhdGVJRCA9IGZhbHNlO1xuXG4gICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICBkaWRHZW5lcmF0ZUlEID0gdHJ1ZTtcbiAgICAgIGlkID0gT2JqZWN0KHV0aWxzW1wia1wiIC8qIGdldFVJRCAqL10pKCk7XG4gICAgfSAvLyBUaGlzIHJlZmluZW1lbnQgaXMgZm9yIEZsb3cgcHVycG9zZXMgb25seS5cblxuXG4gICAgdmFyIHJlZmluZWRJRCA9IGlkOyAvLyBNYWtlIHN1cmUgd2UncmUgdHJhY2tpbmcgdGhpcyBGaWJlclxuICAgIC8vIGUuZy4gaWYgaXQganVzdCBtb3VudGVkIG9yIGFuIGVycm9yIHdhcyBsb2dnZWQgZHVyaW5nIGluaXRpYWwgcmVuZGVyLlxuXG4gICAgaWYgKCFmaWJlclRvSURNYXAuaGFzKGZpYmVyKSkge1xuICAgICAgZmliZXJUb0lETWFwLnNldChmaWJlciwgcmVmaW5lZElEKTtcbiAgICAgIGlkVG9BcmJpdHJhcnlGaWJlck1hcC5zZXQocmVmaW5lZElELCBmaWJlcik7XG4gICAgfSAvLyBBbHNvIG1ha2Ugc3VyZSB3ZSdyZSB0cmFja2luZyBpdHMgYWx0ZXJuYXRlLFxuICAgIC8vIGUuZy4gaW4gY2FzZSB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgYWZ0ZXIgbW91bnQuXG5cblxuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWZpYmVyVG9JRE1hcC5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBmaWJlclRvSURNYXAuc2V0KGFsdGVybmF0ZSwgcmVmaW5lZElEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIGlmIChkaWRHZW5lcmF0ZUlEKSB7XG4gICAgICAgIGRlYnVnKCdnZXRPckdlbmVyYXRlRmliZXJJRCgpJywgZmliZXIsIGZpYmVyLnJldHVybiwgJ0dlbmVyYXRlZCBhIG5ldyBVSUQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVmaW5lZElEO1xuICB9IC8vIFJldHVybnMgYW4gSUQgaWYgb25lIGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkIGZvciB0aGUgRmliZXIgb3IgdGhyb3dzLlxuXG5cbiAgZnVuY3Rpb24gZ2V0RmliZXJJRFRocm93cyhmaWJlcikge1xuICAgIHZhciBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG5cbiAgICBpZiAobWF5YmVJRCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1heWJlSUQ7XG4gICAgfVxuXG4gICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBJRCBmb3IgRmliZXIgXFxcIlwiLmNvbmNhdChnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnJywgXCJcXFwiXCIpKTtcbiAgfSAvLyBSZXR1cm5zIGFuIElEIGlmIG9uZSBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZCBmb3IgdGhlIEZpYmVyIG9yIG51bGwgaWYgb25lIGhhcyBub3QgYmVlbiBnZW5lcmF0ZWQuXG4gIC8vIFVzZSB0aGlzIG1ldGhvZCB3aGlsZSBlLmcuIGxvZ2dpbmcgdG8gYXZvaWQgb3Zlci1yZXRhaW5pbmcgRmliZXJzLlxuXG5cbiAgZnVuY3Rpb24gZ2V0RmliZXJJRFVuc2FmZShmaWJlcikge1xuICAgIGlmIChmaWJlclRvSURNYXAuaGFzKGZpYmVyKSkge1xuICAgICAgcmV0dXJuIGZpYmVyVG9JRE1hcC5nZXQoZmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGZpYmVyVG9JRE1hcC5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICByZXR1cm4gZmliZXJUb0lETWFwLmdldChhbHRlcm5hdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFJlbW92ZXMgYSBGaWJlciAoYW5kIGl0cyBhbHRlcm5hdGUpIGZyb20gdGhlIE1hcHMgdXNlZCB0byB0cmFjayB0aGVpciBpZC5cbiAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIGFsd2F5cyBiZSBjYWxsZWQgd2hlbiBhIEZpYmVyIGlzIHVubW91bnRpbmcuXG5cblxuICBmdW5jdGlvbiB1bnRyYWNrRmliZXJJRChmaWJlcikge1xuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgZGVidWcoJ3VudHJhY2tGaWJlcklEKCknLCBmaWJlciwgZmliZXIucmV0dXJuLCAnc2NoZWR1bGUgYWZ0ZXIgZGVsYXknKTtcbiAgICB9IC8vIFVudHJhY2sgRmliZXJzIGFmdGVyIGEgc2xpZ2h0IGRlbGF5IGluIG9yZGVyIHRvIHN1cHBvcnQgYSBGYXN0IFJlZnJlc2ggZWRnZSBjYXNlOlxuICAgIC8vIDEuIENvbXBvbmVudCB0eXBlIGlzIHVwZGF0ZWQgYW5kIEZhc3QgUmVmcmVzaCBzY2hlZHVsZXMgYW4gdXBkYXRlK3JlbW91bnQuXG4gICAgLy8gMi4gZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCkgcnVucywgc2VlcyB0aGUgb2xkIEZpYmVyIGlzIG5vIGxvbmdlciBtb3VudGVkXG4gICAgLy8gICAgKGl0J3MgYmVlbiBkaXNjb25uZWN0ZWQgYnkgRmFzdCBSZWZyZXNoKSwgYW5kIGNhbGxzIHVudHJhY2tGaWJlcklEKCkgdG8gY2xlYXIgaXQgZnJvbSB0aGUgTWFwLlxuICAgIC8vIDMuIFJlYWN0IGZsdXNoZXMgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGl0IHJ1bnMgdGhlIG5leHQgcmVuZGVyLFxuICAgIC8vICAgIHdoaWNoIGxvZ3MgYW4gZXJyb3Igb3Igd2FybmluZywgd2hpY2ggY2F1c2VzIGEgbmV3IElEIHRvIGJlIGdlbmVyYXRlZCBmb3IgdGhpcyBGaWJlci5cbiAgICAvLyA0LiBEZXZUb29scyBub3cgdHJpZXMgdG8gdW5tb3VudCB0aGUgb2xkIENvbXBvbmVudCB3aXRoIHRoZSBuZXcgSUQuXG4gICAgLy9cbiAgICAvLyBUaGUgdW5kZXJseWluZyBwcm9ibGVtIGhlcmUgaXMgdGhlIHByZW1hdHVyZSBjbGVhcmluZyBvZiB0aGUgRmliZXIgSUQsXG4gICAgLy8gYnV0IERldlRvb2xzIGhhcyBubyB3YXkgdG8gZGV0ZWN0IHRoYXQgYSBnaXZlbiBGaWJlciBoYXMgYmVlbiBzY2hlZHVsZWQgZm9yIEZhc3QgUmVmcmVzaC5cbiAgICAvLyAoVGhlIFwiX2RlYnVnTmVlZHNSZW1vdW50XCIgZmxhZyB3b24ndCBuZWNlc3NhcmlseSBiZSBzZXQuKVxuICAgIC8vXG4gICAgLy8gVGhlIGJlc3Qgd2UgY2FuIGRvIGlzIHRvIGRlbGF5IHVudHJhY2tpbmcgYnkgYSBzbWFsbCBhbW91bnQsXG4gICAgLy8gYW5kIGdpdmUgUmVhY3QgdGltZSB0byBwcm9jZXNzIHRoZSBGYXN0IFJlZnJlc2ggZGVsYXkuXG5cblxuICAgIHVudHJhY2tGaWJlcnNTZXQuYWRkKGZpYmVyKTsgLy8gUmVhY3QgbWF5IGRldGFjaCBhbHRlcm5hdGUgcG9pbnRlcnMgZHVyaW5nIHVubW91bnQ7XG4gICAgLy8gU2luY2Ugb3VyIHVudHJhY2tpbmcgY29kZSBpcyBhc3luYywgd2Ugc2hvdWxkIGV4cGxpY2lseSB0cmFjayB0aGUgcGVuZGluZyBhbHRlcm5hdGUgaGVyZSBhcyB3ZWxsLlxuXG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIHVudHJhY2tGaWJlcnNTZXQuYWRkKGFsdGVybmF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHVudHJhY2tGaWJlcnNUaW1lb3V0SUQgPT09IG51bGwpIHtcbiAgICAgIHVudHJhY2tGaWJlcnNUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHVudHJhY2tGaWJlcnMsIDEwMDApO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bnRyYWNrRmliZXJzU2V0ID0gbmV3IFNldCgpO1xuICB2YXIgdW50cmFja0ZpYmVyc1RpbWVvdXRJRCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdW50cmFja0ZpYmVycygpIHtcbiAgICBpZiAodW50cmFja0ZpYmVyc1RpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHVudHJhY2tGaWJlcnNUaW1lb3V0SUQpO1xuICAgICAgdW50cmFja0ZpYmVyc1RpbWVvdXRJRCA9IG51bGw7XG4gICAgfVxuXG4gICAgdW50cmFja0ZpYmVyc1NldC5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIGZpYmVySUQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcblxuICAgICAgaWYgKGZpYmVySUQgIT09IG51bGwpIHtcbiAgICAgICAgaWRUb0FyYml0cmFyeUZpYmVyTWFwLmRlbGV0ZShmaWJlcklEKTsgLy8gQWxzbyBjbGVhciBhbnkgZXJyb3JzL3dhcm5pbmdzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpYmVyLlxuXG4gICAgICAgIGNsZWFyRXJyb3JzRm9yRmliZXJJRChmaWJlcklEKTtcbiAgICAgICAgY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQoZmliZXJJRCk7XG4gICAgICB9XG5cbiAgICAgIGZpYmVyVG9JRE1hcC5kZWxldGUoZmliZXIpO1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBmaWJlclRvSURNYXAuZGVsZXRlKGFsdGVybmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJJRHMuaGFzKGZpYmVySUQpKSB7XG4gICAgICAgIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5kZWxldGUoZmliZXJJRCk7XG5cbiAgICAgICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcklEcy5zaXplID09PSAwICYmIHNldEVycm9ySGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0RXJyb3JIYW5kbGVyKHNob3VsZEVycm9yRmliZXJBbHdheXNOdWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHVudHJhY2tGaWJlcnNTZXQuY2xlYXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoYW5nZURlc2NyaXB0aW9uKHByZXZGaWJlciwgbmV4dEZpYmVyKSB7XG4gICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZUZvckZpYmVyKG5leHRGaWJlcikpIHtcbiAgICAgIGNhc2UgdHlwZXNbXCJlXCIgLyogRWxlbWVudFR5cGVDbGFzcyAqL106XG4gICAgICBjYXNlIHR5cGVzW1wiaFwiIC8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi9dOlxuICAgICAgY2FzZSB0eXBlc1tcImpcIiAvKiBFbGVtZW50VHlwZU1lbW8gKi9dOlxuICAgICAgY2FzZSB0eXBlc1tcImdcIiAvKiBFbGVtZW50VHlwZUZvcndhcmRSZWYgKi9dOlxuICAgICAgICBpZiAocHJldkZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICBkaWRIb29rc0NoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBpc0ZpcnN0TW91bnQ6IHRydWUsXG4gICAgICAgICAgICBwcm9wczogbnVsbCxcbiAgICAgICAgICAgIHN0YXRlOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGdldENvbnRleHRDaGFuZ2VkS2V5cyhuZXh0RmliZXIpLFxuICAgICAgICAgICAgZGlkSG9va3NDaGFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgaXNGaXJzdE1vdW50OiBmYWxzZSxcbiAgICAgICAgICAgIHByb3BzOiBnZXRDaGFuZ2VkS2V5cyhwcmV2RmliZXIubWVtb2l6ZWRQcm9wcywgbmV4dEZpYmVyLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgc3RhdGU6IGdldENoYW5nZWRLZXlzKHByZXZGaWJlci5tZW1vaXplZFN0YXRlLCBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSlcbiAgICAgICAgICB9OyAvLyBPbmx5IHRyYXZlcnNlIHRoZSBob29rcyBsaXN0IG9uY2UsIGRlcGVuZGluZyBvbiB3aGF0IGluZm8gd2UncmUgcmV0dXJuaW5nLlxuXG4gICAgICAgICAgdmFyIGluZGljZXMgPSBnZXRDaGFuZ2VkSG9va3NJbmRpY2VzKHByZXZGaWJlci5tZW1vaXplZFN0YXRlLCBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSk7XG4gICAgICAgICAgZGF0YS5ob29rcyA9IGluZGljZXM7XG4gICAgICAgICAgZGF0YS5kaWRIb29rc0NoYW5nZSA9IGluZGljZXMgIT09IG51bGwgJiYgaW5kaWNlcy5sZW5ndGggPiAwO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRzRm9yRmliZXIoZmliZXIpIHtcbiAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpKSB7XG4gICAgICBjYXNlIHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dOlxuICAgICAgY2FzZSB0eXBlc1tcImdcIiAvKiBFbGVtZW50VHlwZUZvcndhcmRSZWYgKi9dOlxuICAgICAgY2FzZSB0eXBlc1tcImhcIiAvKiBFbGVtZW50VHlwZUZ1bmN0aW9uICovXTpcbiAgICAgIGNhc2UgdHlwZXNbXCJqXCIgLyogRWxlbWVudFR5cGVNZW1vICovXTpcbiAgICAgICAgaWYgKGlkVG9Db250ZXh0c01hcCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpZCA9IGdldEZpYmVySURUaHJvd3MoZmliZXIpO1xuICAgICAgICAgIHZhciBjb250ZXh0cyA9IGdldENvbnRleHRzRm9yRmliZXIoZmliZXIpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICAgIGlkVG9Db250ZXh0c01hcC5zZXQoaWQsIGNvbnRleHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIERpZmZlcmVudGlhdGVzIGJldHdlZW4gYSBudWxsIGNvbnRleHQgdmFsdWUgYW5kIG5vIGNvbnRleHQuXG5cblxuICB2YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRzRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgbGVnYWN5Q29udGV4dCA9IE5PX0NPTlRFWFQ7XG4gICAgdmFyIG1vZGVybkNvbnRleHQgPSBOT19DT05URVhUO1xuXG4gICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKSkge1xuICAgICAgY2FzZSB0eXBlc1tcImVcIiAvKiBFbGVtZW50VHlwZUNsYXNzICovXTpcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLmNvbnN0cnVjdG9yICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLmNvbnRleHRUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1vZGVybkNvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdhY3lDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcblxuICAgICAgICAgICAgaWYgKGxlZ2FjeUNvbnRleHQgJiYgT2JqZWN0LmtleXMobGVnYWN5Q29udGV4dCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGxlZ2FjeUNvbnRleHQgPSBOT19DT05URVhUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGVnYWN5Q29udGV4dCwgbW9kZXJuQ29udGV4dF07XG5cbiAgICAgIGNhc2UgdHlwZXNbXCJnXCIgLyogRWxlbWVudFR5cGVGb3J3YXJkUmVmICovXTpcbiAgICAgIGNhc2UgdHlwZXNbXCJoXCIgLyogRWxlbWVudFR5cGVGdW5jdGlvbiAqL106XG4gICAgICBjYXNlIHR5cGVzW1wialwiIC8qIEVsZW1lbnRUeXBlTWVtbyAqL106XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG5cbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyAmJiBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0KSB7XG4gICAgICAgICAgbW9kZXJuQ29udGV4dCA9IGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xlZ2FjeUNvbnRleHQsIG1vZGVybkNvbnRleHRdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gUmVjb3JkIGFsbCBjb250ZXh0cyBhdCB0aGUgdGltZSBwcm9maWxpbmcgaXMgc3RhcnRlZC5cbiAgLy8gRmliZXJzIG9ubHkgc3RvcmUgdGhlIGN1cnJlbnQgY29udGV4dCB2YWx1ZSxcbiAgLy8gc28gd2UgbmVlZCB0byB0cmFjayB0aGVtIHNlcGFyYXRlbHkgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGNoYW5nZWQga2V5cy5cblxuXG4gIGZ1bmN0aW9uIGNyYXdsVG9Jbml0aWFsaXplQ29udGV4dHNNYXAoZmliZXIpIHtcbiAgICB2YXIgaWQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTsgLy8gTm90IGFsbCBGaWJlcnMgaW4gdGhlIHN1YnRyZWUgaGF2ZSBtb3VudGVkIHlldC5cbiAgICAvLyBGb3IgZXhhbXBsZSwgT2Zmc2NyZWVuIChoaWRkZW4pIG9yIFN1c3BlbnNlIChzdXNwZW5kZWQpIHN1YnRyZWVzIHdvbid0IHlldCBiZSB0cmFja2VkLlxuICAgIC8vIFdlIGNhbiBzYWZlbHkgc2tpcCB0aGVzZSBzdWJ0cmVlcy5cblxuICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlQ29udGV4dHNGb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBjcmF3bFRvSW5pdGlhbGl6ZUNvbnRleHRzTWFwKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRDaGFuZ2VkS2V5cyhmaWJlcikge1xuICAgIGlmIChpZFRvQ29udGV4dHNNYXAgIT09IG51bGwpIHtcbiAgICAgIHZhciBpZCA9IGdldEZpYmVySURUaHJvd3MoZmliZXIpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgdmFyIHByZXZDb250ZXh0cyA9IGlkVG9Db250ZXh0c01hcC5oYXMoaWQpID8gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBpZFRvQ29udGV4dHNNYXAuZ2V0KGlkKSA6IG51bGw7XG4gICAgICB2YXIgbmV4dENvbnRleHRzID0gZ2V0Q29udGV4dHNGb3JGaWJlcihmaWJlcik7XG5cbiAgICAgIGlmIChwcmV2Q29udGV4dHMgPT0gbnVsbCB8fCBuZXh0Q29udGV4dHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcmV2Q29udGV4dHMgPSByZW5kZXJlcl9zbGljZWRUb0FycmF5KHByZXZDb250ZXh0cywgMiksXG4gICAgICAgICAgcHJldkxlZ2FjeUNvbnRleHQgPSBfcHJldkNvbnRleHRzWzBdLFxuICAgICAgICAgIHByZXZNb2Rlcm5Db250ZXh0ID0gX3ByZXZDb250ZXh0c1sxXTtcblxuICAgICAgdmFyIF9uZXh0Q29udGV4dHMgPSByZW5kZXJlcl9zbGljZWRUb0FycmF5KG5leHRDb250ZXh0cywgMiksXG4gICAgICAgICAgbmV4dExlZ2FjeUNvbnRleHQgPSBfbmV4dENvbnRleHRzWzBdLFxuICAgICAgICAgIG5leHRNb2Rlcm5Db250ZXh0ID0gX25leHRDb250ZXh0c1sxXTtcblxuICAgICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKSkge1xuICAgICAgICBjYXNlIHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dOlxuICAgICAgICAgIGlmIChwcmV2Q29udGV4dHMgJiYgbmV4dENvbnRleHRzKSB7XG4gICAgICAgICAgICBpZiAobmV4dExlZ2FjeUNvbnRleHQgIT09IE5PX0NPTlRFWFQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5nZWRLZXlzKHByZXZMZWdhY3lDb250ZXh0LCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRNb2Rlcm5Db250ZXh0ICE9PSBOT19DT05URVhUKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2TW9kZXJuQ29udGV4dCAhPT0gbmV4dE1vZGVybkNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0eXBlc1tcImdcIiAvKiBFbGVtZW50VHlwZUZvcndhcmRSZWYgKi9dOlxuICAgICAgICBjYXNlIHR5cGVzW1wiaFwiIC8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi9dOlxuICAgICAgICBjYXNlIHR5cGVzW1wialwiIC8qIEVsZW1lbnRUeXBlTWVtbyAqL106XG4gICAgICAgICAgaWYgKG5leHRNb2Rlcm5Db250ZXh0ICE9PSBOT19DT05URVhUKSB7XG4gICAgICAgICAgICB2YXIgcHJldkNvbnRleHQgPSBwcmV2TW9kZXJuQ29udGV4dDtcbiAgICAgICAgICAgIHZhciBuZXh0Q29udGV4dCA9IG5leHRNb2Rlcm5Db250ZXh0O1xuXG4gICAgICAgICAgICB3aGlsZSAocHJldkNvbnRleHQgJiYgbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgICAgLy8gTm90ZSB0aGlzIG9ubHkgd29ya3MgZm9yIHZlcnNpb25zIG9mIFJlYWN0IHRoYXQgc3VwcG9ydCB0aGlzIGtleSAoZS52LiAxOCspXG4gICAgICAgICAgICAgIC8vIEZvciBvbGRlciB2ZXJzaW9ucywgdGhlcmUncyBubyBnb29kIHdheSB0byByZWFkIHRoZSBjdXJyZW50IGNvbnRleHQgdmFsdWUgYWZ0ZXIgcmVuZGVyIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBSZWFjdCBtYWludGFpbnMgYSBzdGFjayBvZiBjb250ZXh0IHZhbHVlcyBkdXJpbmcgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBidXQgYnkgdGhlIHRpbWUgRGV2VG9vbHMgaXMgY2FsbGVkLCByZW5kZXIgaGFzIGZpbmlzaGVkIGFuZCB0aGUgc3RhY2sgaXMgZW1wdHkuXG4gICAgICAgICAgICAgIGlmICghc2hhcmVkX29iamVjdElzKHByZXZDb250ZXh0Lm1lbW9pemVkVmFsdWUsIG5leHRDb250ZXh0Lm1lbW9pemVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcmV2Q29udGV4dCA9IHByZXZDb250ZXh0Lm5leHQ7XG4gICAgICAgICAgICAgIG5leHRDb250ZXh0ID0gbmV4dENvbnRleHQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvb2tUaGF0Q2FuU2NoZWR1bGVVcGRhdGUoaG9va09iamVjdCkge1xuICAgIHZhciBxdWV1ZSA9IGhvb2tPYmplY3QucXVldWU7XG5cbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kSGFzT3duUHJvcGVydHkgPSBzaGFyZWRfaGFzT3duUHJvcGVydHkuYmluZChxdWV1ZSk7IC8vIERldGVjdCB0aGUgc2hhcGUgb2YgdXNlU3RhdGUoKSBvciB1c2VSZWR1Y2VyKClcbiAgICAvLyB1c2luZyB0aGUgYXR0cmlidXRlcyB0aGF0IGFyZSB1bmlxdWUgdG8gdGhlc2UgaG9va3NcbiAgICAvLyBidXQgYWxzbyBzdGFibGUgKGUuZy4gbm90IHRpZWQgdG8gY3VycmVudCBMYW5lcyBpbXBsZW1lbnRhdGlvbilcblxuICAgIHZhciBpc1N0YXRlT3JSZWR1Y2VyID0gYm91bmRIYXNPd25Qcm9wZXJ0eSgncGVuZGluZycpICYmIGJvdW5kSGFzT3duUHJvcGVydHkoJ2Rpc3BhdGNoJykgJiYgdHlwZW9mIHF1ZXVlLmRpc3BhdGNoID09PSAnZnVuY3Rpb24nOyAvLyBEZXRlY3QgdXNlU3luY0V4dGVybmFsU3RvcmUoKVxuXG4gICAgdmFyIGlzU3luY0V4dGVybmFsU3RvcmUgPSBib3VuZEhhc093blByb3BlcnR5KCd2YWx1ZScpICYmIGJvdW5kSGFzT3duUHJvcGVydHkoJ2dldFNuYXBzaG90JykgJiYgdHlwZW9mIHF1ZXVlLmdldFNuYXBzaG90ID09PSAnZnVuY3Rpb24nOyAvLyBUaGVzZSBhcmUgdGhlIG9ubHkgdHlwZXMgb2YgaG9va3MgdGhhdCBjYW4gc2NoZWR1bGUgYW4gdXBkYXRlLlxuXG4gICAgcmV0dXJuIGlzU3RhdGVPclJlZHVjZXIgfHwgaXNTeW5jRXh0ZXJuYWxTdG9yZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZFN0YXRlZnVsSG9va0NoYW5nZShwcmV2LCBuZXh0KSB7XG4gICAgdmFyIHByZXZNZW1vaXplZFN0YXRlID0gcHJldi5tZW1vaXplZFN0YXRlO1xuICAgIHZhciBuZXh0TWVtb2l6ZWRTdGF0ZSA9IG5leHQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChpc0hvb2tUaGF0Q2FuU2NoZWR1bGVVcGRhdGUocHJldikpIHtcbiAgICAgIHJldHVybiBwcmV2TWVtb2l6ZWRTdGF0ZSAhPT0gbmV4dE1lbW9pemVkU3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2hhbmdlZEhvb2tzSW5kaWNlcyhwcmV2LCBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcblxuICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KCdiYXNlU3RhdGUnKSAmJiBuZXh0Lmhhc093blByb3BlcnR5KCdtZW1vaXplZFN0YXRlJykgJiYgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbmV4dCcpICYmIG5leHQuaGFzT3duUHJvcGVydHkoJ3F1ZXVlJykpIHtcbiAgICAgIHdoaWxlIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChkaWRTdGF0ZWZ1bEhvb2tDaGFuZ2UocHJldiwgbmV4dCkpIHtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgcHJldiA9IHByZXYubmV4dDtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoYW5nZWRLZXlzKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBXZSBjYW4ndCByZXBvcnQgYW55dGhpbmcgbWVhbmluZ2Z1bCBmb3IgaG9va3MgY2hhbmdlcy5cblxuXG4gICAgaWYgKG5leHQuaGFzT3duUHJvcGVydHkoJ2Jhc2VTdGF0ZScpICYmIG5leHQuaGFzT3duUHJvcGVydHkoJ21lbW9pemVkU3RhdGUnKSAmJiBuZXh0Lmhhc093blByb3BlcnR5KCduZXh0JykgJiYgbmV4dC5oYXNPd25Qcm9wZXJ0eSgncXVldWUnKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmtleXMocHJldikpLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmtleXMobmV4dCkpKSk7XG4gICAgdmFyIGNoYW5nZWRLZXlzID0gW107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG5cbiAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGtleXMpLFxuICAgICAgICBfc3RlcDU7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGtleSA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgICBpZiAocHJldltrZXldICE9PSBuZXh0W2tleV0pIHtcbiAgICAgICAgICBjaGFuZ2VkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZEtleXM7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICBmdW5jdGlvbiBkaWRGaWJlclJlbmRlcihwcmV2RmliZXIsIG5leHRGaWJlcikge1xuICAgIHN3aXRjaCAobmV4dEZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgLy8gRm9yIHR5cGVzIHRoYXQgZXhlY3V0ZSB1c2VyIGNvZGUsIHdlIGNoZWNrIFBlcmZvcm1lZFdvcmsgZWZmZWN0LlxuICAgICAgICAvLyBXZSBkb24ndCByZWZsZWN0IGJhaWxvdXRzIChlaXRoZXIgcmVmZXJlbnRpYWwgb3Igc0NVKSBpbiBEZXZUb29scy5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBmbGFnIGlzIGEgbGVha2VkIGltcGxlbWVudGF0aW9uIGRldGFpbC4gT25jZSB3ZSBzdGFydFxuICAgICAgICAvLyByZWxlYXNpbmcgRGV2VG9vbHMgaW4gbG9ja3N0ZXAgd2l0aCBSZWFjdCwgd2Ugc2hvdWxkIGltcG9ydCBhXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZyb20gdGhlIHJlY29uY2lsZXIgaW5zdGVhZC5cbiAgICAgICAgdmFyIFBlcmZvcm1lZFdvcmsgPSAxO1xuICAgICAgICByZXR1cm4gKGdldEZpYmVyRmxhZ3MobmV4dEZpYmVyKSAmIFBlcmZvcm1lZFdvcmspID09PSBQZXJmb3JtZWRXb3JrO1xuICAgICAgLy8gTm90ZTogQ29udGV4dENvbnN1bWVyIG9ubHkgZ2V0cyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpbiAxNi4zLjMrXG4gICAgICAvLyBzbyBpdCB3b24ndCBnZXQgaGlnaGxpZ2h0ZWQgd2l0aCBSZWFjdCAxNi4zLjAgdG8gMTYuMy4yLlxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGb3IgaG9zdCBjb21wb25lbnRzIGFuZCBvdGhlciB0eXBlcywgd2UgY29tcGFyZSBpbnB1dHNcbiAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgc29tZXRoaW5nIGlzIGFuIHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuIHByZXZGaWJlci5tZW1vaXplZFByb3BzICE9PSBuZXh0RmliZXIubWVtb2l6ZWRQcm9wcyB8fCBwcmV2RmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbmV4dEZpYmVyLm1lbW9pemVkU3RhdGUgfHwgcHJldkZpYmVyLnJlZiAhPT0gbmV4dEZpYmVyLnJlZjtcbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ09wZXJhdGlvbnMgPSBbXTtcbiAgdmFyIHBlbmRpbmdSZWFsVW5tb3VudGVkSURzID0gW107XG4gIHZhciBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzID0gW107XG4gIHZhciBwZW5kaW5nT3BlcmF0aW9uc1F1ZXVlID0gW107XG4gIHZhciBwZW5kaW5nU3RyaW5nVGFibGUgPSBuZXcgTWFwKCk7XG4gIHZhciBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggPSAwO1xuICB2YXIgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCkge1xuICAgIGlmIChmYWxzZSkge31cblxuICAgIHBlbmRpbmdPcGVyYXRpb25zLnB1c2gob3ApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQmFpbG91dFdpdGhQZW5kaW5nT3BlcmF0aW9ucygpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgIT0gbnVsbCAmJiBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEuZHVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoID09PSAwICYmIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMubGVuZ3RoID09PSAwICYmIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPT09IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaE9yUXVldWVPcGVyYXRpb25zKG9wZXJhdGlvbnMpIHtcbiAgICBpZiAoc2hvdWxkQmFpbG91dFdpdGhQZW5kaW5nT3BlcmF0aW9ucygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdPcGVyYXRpb25zUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHBlbmRpbmdPcGVyYXRpb25zUXVldWUucHVzaChvcGVyYXRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9vay5lbWl0KCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2xlYXJQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCkge1xuICAgIGlmIChmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQpO1xuICAgICAgZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5VGltZW91dElEID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKSB7XG4gICAgY2xlYXJQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCk7XG4gICAgZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5VGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgPSBudWxsO1xuXG4gICAgICBpZiAocGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBPbiB0aGUgb2ZmIGNoYW5jZSB0aGF0IHNvbWV0aGluZyBlbHNlIGhhcyBwdXNoZWQgcGVuZGluZyBvcGVyYXRpb25zLFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmFpbCBvbiB3YXJuaW5nczsgaXQncyBwcm9iYWJseSBub3Qgc2FmZSB0byBwdXNoIG1pZHdheS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWNvcmRQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3MoKTtcblxuICAgICAgaWYgKHNob3VsZEJhaWxvdXRXaXRoUGVuZGluZ09wZXJhdGlvbnMoKSkge1xuICAgICAgICAvLyBObyB3YXJuaW5ncyBvciBlcnJvcnMgdG8gZmx1c2g7IHdlIGNhbiBiYWlsIG91dCBlYXJseSBoZXJlIHRvby5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBXZSBjYW4gY3JlYXRlIGEgc21hbGxlciBvcGVyYXRpb25zIGFycmF5IHRoYW4gZmx1c2hQZW5kaW5nRXZlbnRzKClcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugb25seSBuZWVkIHRvIGZsdXNoIHdhcm5pbmcgYW5kIGVycm9yIGNvdW50cy5cbiAgICAgIC8vIE9ubHkgYSBmZXcgcGllY2VzIG9mIGZpeGVkIGluZm9ybWF0aW9uIGFyZSByZXF1aXJlZCB1cCBmcm9udC5cblxuXG4gICAgICB2YXIgb3BlcmF0aW9ucyA9IG5ldyBBcnJheSgzICsgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoKTtcbiAgICAgIG9wZXJhdGlvbnNbMF0gPSByZW5kZXJlcklEO1xuICAgICAgb3BlcmF0aW9uc1sxXSA9IGN1cnJlbnRSb290SUQ7XG4gICAgICBvcGVyYXRpb25zWzJdID0gMDsgLy8gU3RyaW5nIHRhYmxlIHNpemVcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBvcGVyYXRpb25zWzMgKyBqXSA9IHBlbmRpbmdPcGVyYXRpb25zW2pdO1xuICAgICAgfVxuXG4gICAgICBmbHVzaE9yUXVldWVPcGVyYXRpb25zKG9wZXJhdGlvbnMpO1xuICAgICAgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9LCAxMDAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmNsZWFyKCk7XG4gICAgZmliZXJJRFRvRXJyb3JzTWFwLmZvckVhY2goZnVuY3Rpb24gKGNvdW50TWFwLCBmaWJlcklEKSB7XG4gICAgICB2YXIgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGZpYmVySUQpO1xuXG4gICAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChmaWJlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmliZXJJRFRvV2FybmluZ3NNYXAuZm9yRWFjaChmdW5jdGlvbiAoY291bnRNYXAsIGZpYmVySUQpIHtcbiAgICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoZmliZXJJRCk7XG5cbiAgICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKGZpYmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWNvcmRQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3MoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlTWFwc0FuZEdldENvdW50SGVscGVyKGZpYmVyLCBmaWJlcklELCBwZW5kaW5nRmliZXJUb01lc3NhZ2VDb3VudE1hcCwgZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwKSB7XG4gICAgdmFyIG5ld0NvdW50ID0gMDtcbiAgICB2YXIgbWVzc2FnZUNvdW50TWFwID0gZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwLmdldChmaWJlcklEKTtcbiAgICB2YXIgcGVuZGluZ01lc3NhZ2VDb3VudE1hcCA9IHBlbmRpbmdGaWJlclRvTWVzc2FnZUNvdW50TWFwLmdldChmaWJlcik7XG5cbiAgICBpZiAocGVuZGluZ01lc3NhZ2VDb3VudE1hcCAhPSBudWxsKSB7XG4gICAgICBpZiAobWVzc2FnZUNvdW50TWFwID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZUNvdW50TWFwID0gcGVuZGluZ01lc3NhZ2VDb3VudE1hcDtcbiAgICAgICAgZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwLnNldChmaWJlcklELCBwZW5kaW5nTWVzc2FnZUNvdW50TWFwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgRmxvdyByZWZpbmVtZW50IHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IGFuZCB5ZXQuLi5cbiAgICAgICAgdmFyIHJlZmluZWRNZXNzYWdlQ291bnRNYXAgPSBtZXNzYWdlQ291bnRNYXA7XG4gICAgICAgIHBlbmRpbmdNZXNzYWdlQ291bnRNYXAuZm9yRWFjaChmdW5jdGlvbiAocGVuZGluZ0NvdW50LCBtZXNzYWdlKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ291bnQgPSByZWZpbmVkTWVzc2FnZUNvdW50TWFwLmdldChtZXNzYWdlKSB8fCAwO1xuICAgICAgICAgIHJlZmluZWRNZXNzYWdlQ291bnRNYXAuc2V0KG1lc3NhZ2UsIHByZXZpb3VzQ291bnQgKyBwZW5kaW5nQ291bnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNob3VsZEZpbHRlckZpYmVyKGZpYmVyKSkge1xuICAgICAgaWYgKG1lc3NhZ2VDb3VudE1hcCAhPSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2VDb3VudE1hcC5mb3JFYWNoKGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgIG5ld0NvdW50ICs9IGNvdW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwZW5kaW5nRmliZXJUb01lc3NhZ2VDb3VudE1hcC5kZWxldGUoZmliZXIpO1xuICAgIHJldHVybiBuZXdDb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICBjbGVhclBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKTtcbiAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgZmliZXJJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpO1xuXG4gICAgICBpZiAoZmliZXJJRCA9PT0gbnVsbCkgey8vIERvbid0IHNlbmQgdXBkYXRlcyBmb3IgRmliZXJzIHRoYXQgZGlkbid0IG1vdW50IGR1ZSB0byBlLmcuIFN1c3BlbnNlIG9yIGFuIGVycm9yIGJvdW5kYXJ5LlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yQ291bnQgPSBtZXJnZU1hcHNBbmRHZXRDb3VudEhlbHBlcihmaWJlciwgZmliZXJJRCwgcGVuZGluZ0ZpYmVyVG9FcnJvcnNNYXAsIGZpYmVySURUb0Vycm9yc01hcCk7XG4gICAgICAgIHZhciB3YXJuaW5nQ291bnQgPSBtZXJnZU1hcHNBbmRHZXRDb3VudEhlbHBlcihmaWJlciwgZmliZXJJRCwgcGVuZGluZ0ZpYmVyVG9XYXJuaW5nc01hcCwgZmliZXJJRFRvV2FybmluZ3NNYXApO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKGNvbnN0YW50c1tcInFcIiAvKiBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTICovXSk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oZmliZXJJRCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oZXJyb3JDb3VudCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24od2FybmluZ0NvdW50KTtcbiAgICAgIH0gLy8gQWx3YXlzIGNsZWFuIHVwIHNvIHRoYXQgd2UgZG9uJ3QgbGVhay5cblxuXG4gICAgICBwZW5kaW5nRmliZXJUb0Vycm9yc01hcC5kZWxldGUoZmliZXIpO1xuICAgICAgcGVuZGluZ0ZpYmVyVG9XYXJuaW5nc01hcC5kZWxldGUoZmliZXIpO1xuICAgIH0pO1xuICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuY2xlYXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KSB7XG4gICAgLy8gQWRkIGFueSBwZW5kaW5nIGVycm9ycyBhbmQgd2FybmluZ3MgdG8gdGhlIG9wZXJhdGlvbnMgYXJyYXkuXG4gICAgLy8gV2UgZG8gdGhpcyBqdXN0IGJlZm9yZSBmbHVzaGluZywgc28gd2UgY2FuIGlnbm9yZSBlcnJvcnMgZm9yIG5vLWxvbmdlci1tb3VudGVkIEZpYmVycy5cbiAgICByZWNvcmRQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3MoKTtcblxuICAgIGlmIChzaG91bGRCYWlsb3V0V2l0aFBlbmRpbmdPcGVyYXRpb25zKCkpIHtcbiAgICAgIC8vIElmIHdlIGFyZW4ndCBwcm9maWxpbmcsIHdlIGNhbiBqdXN0IGJhaWwgb3V0IGhlcmUuXG4gICAgICAvLyBObyB1c2Ugc2VuZGluZyBhbiBlbXB0eSB1cGRhdGUgb3ZlciB0aGUgYnJpZGdlLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBQcm9maWxlciBzdG9yZXMgbWV0YWRhdGEgZm9yIGVhY2ggY29tbWl0IGFuZCByZWNvbnN0cnVjdHMgdGhlIGFwcCB0cmVlIHBlciBjb21taXQgdXNpbmc6XG4gICAgICAvLyAoMSkgYW4gaW5pdGlhbCB0cmVlIHNuYXBzaG90IGFuZFxuICAgICAgLy8gKDIpIHRoZSBvcGVyYXRpb25zIGFycmF5IGZvciBlYWNoIGNvbW1pdFxuICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzLCBpdCdzIGltcG9ydGFudCB0aGF0IHRoZSBvcGVyYXRpb25zIGFuZCBtZXRhZGF0YSBhcnJheXMgYWxpZ24sXG4gICAgICAvLyBTbyBpdCdzIGltcG9ydGFudCBub3QgdG8gb21pdCBldmVuIGVtcHR5IG9wZXJhdGlvbnMgd2hpbGUgcHJvZmlsaW5nIGlzIGFjdGl2ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbnVtVW5tb3VudElEcyA9IHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLmxlbmd0aCArIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMubGVuZ3RoICsgKHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPT09IG51bGwgPyAwIDogMSk7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSBuZXcgQXJyYXkoIC8vIElkZW50aWZ5IHdoaWNoIHJlbmRlcmVyIHRoaXMgdXBkYXRlIGlzIGNvbWluZyBmcm9tLlxuICAgIDIgKyAvLyBbcmVuZGVyZXJJRCwgcm9vdEZpYmVySURdXG4gICAgLy8gSG93IGJpZyBpcyB0aGUgc3RyaW5nIHRhYmxlP1xuICAgIDEgKyAvLyBbc3RyaW5nVGFibGVMZW5ndGhdXG4gICAgLy8gVGhlbiBnb2VzIHRoZSBhY3R1YWwgc3RyaW5nIHRhYmxlLlxuICAgIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCArICggLy8gQWxsIHVubW91bnRzIGFyZSBiYXRjaGVkIGluIGEgc2luZ2xlIG1lc3NhZ2UuXG4gICAgLy8gW1RSRUVfT1BFUkFUSU9OX1JFTU9WRSwgcmVtb3ZlZElETGVuZ3RoLCAuLi5pZHNdXG4gICAgbnVtVW5tb3VudElEcyA+IDAgPyAyICsgbnVtVW5tb3VudElEcyA6IDApICsgLy8gUmVndWxhciBvcGVyYXRpb25zXG4gICAgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoKTsgLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgLy8gVGhpcyBlbmFibGVzIHJvb3RzIHRvIGJlIG1hcHBlZCB0byByZW5kZXJlcnMsXG4gICAgLy8gV2hpY2ggaW4gdHVybiBlbmFibGVzIGZpYmVyIHByb3BzLCBzdGF0ZXMsIGFuZCBob29rcyB0byBiZSBpbnNwZWN0ZWQuXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgb3BlcmF0aW9uc1tpKytdID0gcmVuZGVyZXJJRDtcbiAgICBvcGVyYXRpb25zW2krK10gPSBjdXJyZW50Um9vdElEOyAvLyBOb3cgZmlsbCBpbiB0aGUgc3RyaW5nIHRhYmxlLlxuICAgIC8vIFtzdHJpbmdUYWJsZUxlbmd0aCwgc3RyMUxlbmd0aCwgLi4uc3RyMSwgc3RyMkxlbmd0aCwgLi4uc3RyMiwgLi4uXVxuXG4gICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgc3RyaW5nS2V5KSB7XG4gICAgICB2YXIgZW5jb2RlZFN0cmluZyA9IGVudHJ5LmVuY29kZWRTdHJpbmc7IC8vIERvbid0IHVzZSB0aGUgc3RyaW5nIGxlbmd0aC5cbiAgICAgIC8vIEl0IHdvbid0IHdvcmsgZm9yIG11bHRpYnl0ZSBjaGFyYWN0ZXJzIChsaWtlIGVtb2ppKS5cblxuICAgICAgdmFyIGxlbmd0aCA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICAgICAgb3BlcmF0aW9uc1tpKytdID0gbGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaSArIGpdID0gZW5jb2RlZFN0cmluZ1tqXTtcbiAgICAgIH1cblxuICAgICAgaSArPSBsZW5ndGg7XG4gICAgfSk7XG5cbiAgICBpZiAobnVtVW5tb3VudElEcyA+IDApIHtcbiAgICAgIC8vIEFsbCB1bm1vdW50cyBleGNlcHQgcm9vdHMgYXJlIGJhdGNoZWQgaW4gYSBzaW5nbGUgbWVzc2FnZS5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IGNvbnN0YW50c1tcIm1cIiAvKiBUUkVFX09QRVJBVElPTl9SRU1PVkUgKi9dOyAvLyBUaGUgZmlyc3QgbnVtYmVyIGlzIGhvdyBtYW55IHVubW91bnRlZCBJRHMgd2UncmUgZ29ubmEgc2VuZC5cblxuICAgICAgb3BlcmF0aW9uc1tpKytdID0gbnVtVW5tb3VudElEczsgLy8gRmlsbCBpbiB0aGUgcmVhbCB1bm1vdW50cyBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICAgIC8vIFRoZXkgd2VyZSBpbnNlcnRlZCBwYXJlbnRzLWZpcnN0IGJ5IFJlYWN0LCBidXQgd2Ugd2FudCBjaGlsZHJlbi1maXJzdC5cbiAgICAgIC8vIFNvIHdlIHRyYXZlcnNlIG91ciBhcnJheSBiYWNrd2FyZHMuXG5cbiAgICAgIGZvciAodmFyIGogPSBwZW5kaW5nUmVhbFVubW91bnRlZElEcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nUmVhbFVubW91bnRlZElEc1tqXTtcbiAgICAgIH0gLy8gRmlsbCBpbiB0aGUgc2ltdWxhdGVkIHVubW91bnRzIChoaWRkZW4gU3VzcGVuc2Ugc3VidHJlZXMpIGluIHRoZWlyIG9yZGVyLlxuICAgICAgLy8gKFdlIHdhbnQgY2hpbGRyZW4gdG8gZ28gYmVmb3JlIHBhcmVudHMuKVxuICAgICAgLy8gVGhleSBnbyAqYWZ0ZXIqIHRoZSByZWFsIHVubW91bnRzIGJlY2F1c2Ugd2Uga25vdyBmb3Igc3VyZSB0aGV5IHdvbid0IGJlXG4gICAgICAvLyBjaGlsZHJlbiBvZiBhbHJlYWR5IHB1c2hlZCBcInJlYWxcIiBJRHMuIElmIHRoZXkgd2VyZSwgd2Ugd291bGRuJ3QgYmUgYWJsZVxuICAgICAgLy8gdG8gZGlzY292ZXIgdGhlbSBkdXJpbmcgdGhlIHRyYXZlcnNhbCwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gZGVsZXRlZC5cblxuXG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpICsgX2pdID0gcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEc1tfal07XG4gICAgICB9XG5cbiAgICAgIGkgKz0gcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGg7IC8vIFRoZSByb290IElEIHNob3VsZCBhbHdheXMgYmUgdW5tb3VudGVkIGxhc3QuXG5cbiAgICAgIGlmIChwZW5kaW5nVW5tb3VudGVkUm9vdElEICE9PSBudWxsKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaV0gPSBwZW5kaW5nVW5tb3VudGVkUm9vdElEO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBvcGVyYXRpb25zLlxuXG5cbiAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGg7IF9qMisrKSB7XG4gICAgICBvcGVyYXRpb25zW2kgKyBfajJdID0gcGVuZGluZ09wZXJhdGlvbnNbX2oyXTtcbiAgICB9XG5cbiAgICBpICs9IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDsgLy8gTGV0IHRoZSBmcm9udGVuZCBrbm93IGFib3V0IHRyZWUgb3BlcmF0aW9ucy5cblxuICAgIGZsdXNoT3JRdWV1ZU9wZXJhdGlvbnMob3BlcmF0aW9ucyk7IC8vIFJlc2V0IGFsbCBvZiB0aGUgcGVuZGluZyBzdGF0ZSBub3cgdGhhdCB3ZSd2ZSB0b2xkIHRoZSBmcm9udGVuZCBhYm91dCBpdC5cblxuICAgIHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCA9IDA7XG4gICAgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgICBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gICAgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9IG51bGw7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmNsZWFyKCk7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0cmluZ0lEKHN0cmluZykge1xuICAgIGlmIChzdHJpbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBleGlzdGluZ0VudHJ5ID0gcGVuZGluZ1N0cmluZ1RhYmxlLmdldChzdHJpbmcpO1xuXG4gICAgaWYgKGV4aXN0aW5nRW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnkuaWQ7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gcGVuZGluZ1N0cmluZ1RhYmxlLnNpemUgKyAxO1xuICAgIHZhciBlbmNvZGVkU3RyaW5nID0gT2JqZWN0KHV0aWxzW1wicFwiIC8qIHV0ZkVuY29kZVN0cmluZyAqL10pKHN0cmluZyk7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLnNldChzdHJpbmcsIHtcbiAgICAgIGVuY29kZWRTdHJpbmc6IGVuY29kZWRTdHJpbmcsXG4gICAgICBpZDogaWRcbiAgICB9KTsgLy8gVGhlIHN0cmluZyB0YWJsZSB0b3RhbCBsZW5ndGggbmVlZHMgdG8gYWNjb3VudCBib3RoIGZvciB0aGUgc3RyaW5nIGxlbmd0aCxcbiAgICAvLyBhbmQgZm9yIHRoZSBhcnJheSBpdGVtIHRoYXQgY29udGFpbnMgdGhlIGxlbmd0aCBpdHNlbGYuXG4gICAgLy9cbiAgICAvLyBEb24ndCB1c2Ugc3RyaW5nIGxlbmd0aCBmb3IgdGhpcyB0YWJsZS5cbiAgICAvLyBJdCB3b24ndCB3b3JrIGZvciBtdWx0aWJ5dGUgY2hhcmFjdGVycyAobGlrZSBlbW9qaSkuXG5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKz0gZW5jb2RlZFN0cmluZy5sZW5ndGggKyAxO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZE1vdW50KGZpYmVyLCBwYXJlbnRGaWJlcikge1xuICAgIHZhciBpc1Jvb3QgPSBmaWJlci50YWcgPT09IEhvc3RSb290O1xuICAgIHZhciBpZCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKGZpYmVyKTtcblxuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgZGVidWcoJ3JlY29yZE1vdW50KCknLCBmaWJlciwgcGFyZW50RmliZXIpO1xuICAgIH1cblxuICAgIHZhciBoYXNPd25lck1ldGFkYXRhID0gZmliZXIuaGFzT3duUHJvcGVydHkoJ19kZWJ1Z093bmVyJyk7XG4gICAgdmFyIGlzUHJvZmlsaW5nU3VwcG9ydGVkID0gZmliZXIuaGFzT3duUHJvcGVydHkoJ3RyZWVCYXNlRHVyYXRpb24nKTsgLy8gQWRkaW5nIGEgbmV3IGZpZWxkIGhlcmUgd291bGQgcmVxdWlyZSBhIGJyaWRnZSBwcm90b2NvbCB2ZXJzaW9uIGJ1bXAgKGEgYmFja3dhZHMgYnJlYWtpbmcgY2hhbmdlKS5cbiAgICAvLyBJbnN0ZWFkIGxldCdzIHJlLXB1cnBvc2UgYSBwcmUtZXhpc3RpbmcgZmllbGQgdG8gY2FycnkgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgIHZhciBwcm9maWxpbmdGbGFncyA9IDA7XG5cbiAgICBpZiAoaXNQcm9maWxpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIHByb2ZpbGluZ0ZsYWdzID0gY29uc3RhbnRzW1wiZ1wiIC8qIFBST0ZJTElOR19GTEFHX0JBU0lDX1NVUFBPUlQgKi9dO1xuXG4gICAgICBpZiAodHlwZW9mIGluamVjdFByb2ZpbGluZ0hvb2tzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2ZpbGluZ0ZsYWdzIHw9IGNvbnN0YW50c1tcImhcIiAvKiBQUk9GSUxJTkdfRkxBR19USU1FTElORV9TVVBQT1JUICovXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBwdXNoT3BlcmF0aW9uKGNvbnN0YW50c1tcImxcIiAvKiBUUkVFX09QRVJBVElPTl9BREQgKi9dKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbih0eXBlc1tcIm1cIiAvKiBFbGVtZW50VHlwZVJvb3QgKi9dKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlQml0cykgIT09IDAgPyAxIDogMCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHByb2ZpbGluZ0ZsYWdzKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oU3RyaWN0TW9kZUJpdHMgIT09IDAgPyAxIDogMCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGhhc093bmVyTWV0YWRhdGEgPyAxIDogMCk7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICBpZiAoZGlzcGxheU5hbWVzQnlSb290SUQgIT09IG51bGwpIHtcbiAgICAgICAgICBkaXNwbGF5TmFtZXNCeVJvb3RJRC5zZXQoaWQsIGdldERpc3BsYXlOYW1lRm9yUm9vdChmaWJlcikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBmaWJlci5rZXk7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIF9kZWJ1Z093bmVyID0gZmliZXIuX2RlYnVnT3duZXI7IC8vIElkZWFsbHkgd2Ugc2hvdWxkIGNhbGwgZ2V0RmliZXJJRFRocm93cygpIGZvciBfZGVidWdPd25lcixcbiAgICAgIC8vIHNpbmNlIG93bmVycyBhcmUgYWxtb3N0IGFsd2F5cyBoaWdoZXIgaW4gdGhlIHRyZWUgKGFuZCBzbyBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQpLFxuICAgICAgLy8gYnV0IGluIHNvbWUgKHJhcmUpIGluc3RhbmNlcyByZXBvcnRlZCBpbiBvcGVuIHNvdXJjZSwgYSBkZXNjZW5kYW50IG1vdW50cyBiZWZvcmUgYW4gb3duZXIuXG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgREVWIG9ubHkgZmllbGQgaXQncyBwcm9iYWJseSBva2F5IHRvIGFsc28ganVzdCBsYXppbHkgZ2VuZXJhdGUgYW5kIElEIGhlcmUgaWYgbmVlZGVkLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjE0NDVcblxuICAgICAgdmFyIG93bmVySUQgPSBfZGVidWdPd25lciAhPSBudWxsID8gZ2V0T3JHZW5lcmF0ZUZpYmVySUQoX2RlYnVnT3duZXIpIDogMDtcbiAgICAgIHZhciBwYXJlbnRJRCA9IHBhcmVudEZpYmVyID8gZ2V0RmliZXJJRFRocm93cyhwYXJlbnRGaWJlcikgOiAwO1xuICAgICAgdmFyIGRpc3BsYXlOYW1lU3RyaW5nSUQgPSBnZXRTdHJpbmdJRChkaXNwbGF5TmFtZSk7IC8vIFRoaXMgY2hlY2sgaXMgYSBndWFyZCB0byBoYW5kbGUgYSBSZWFjdCBlbGVtZW50IHRoYXQgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAgIC8vIGluIHN1Y2ggYSB3YXkgYXMgdG8gYnlwYXNzIHRoZSBkZWZhdWx0IHN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgXCJrZXlcIiBwcm9wZXJ0eS5cblxuICAgICAgdmFyIGtleVN0cmluZyA9IGtleSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcoa2V5KTtcbiAgICAgIHZhciBrZXlTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGtleVN0cmluZyk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGNvbnN0YW50c1tcImxcIiAvKiBUUkVFX09QRVJBVElPTl9BREQgKi9dKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihlbGVtZW50VHlwZSk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHBhcmVudElEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24ob3duZXJJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGRpc3BsYXlOYW1lU3RyaW5nSUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihrZXlTdHJpbmdJRCk7IC8vIElmIHRoaXMgc3VidHJlZSBoYXMgYSBuZXcgbW9kZSwgbGV0IHRoZSBmcm9udGVuZCBrbm93LlxuXG4gICAgICBpZiAoKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlQml0cykgIT09IDAgJiYgKHBhcmVudEZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlQml0cykgPT09IDApIHtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihjb25zdGFudHNbXCJwXCIgLyogVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSAqL10pO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbih0eXBlc1tcInFcIiAvKiBTdHJpY3RNb2RlICovXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZFRvUm9vdE1hcC5zZXQoaWQsIGN1cnJlbnRSb290SUQpO1xuICAgICAgcmVjb3JkUHJvZmlsaW5nRHVyYXRpb25zKGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRVbm1vdW50KGZpYmVyLCBpc1NpbXVsYXRlZCkge1xuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgZGVidWcoJ3JlY29yZFVubW91bnQoKScsIGZpYmVyLCBudWxsLCBpc1NpbXVsYXRlZCA/ICd1bm1vdW50IGlzIHNpbXVsYXRlZCcgOiAnJyk7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrZWRQYXRoTWF0Y2hGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgaW4gdGhlIHByb2Nlc3Mgb2YgdHJ5aW5nIHRvIHJlc3RvcmUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICAgICAgLy8gSWYgdGhpcyBmaWJlciBtYXRjaGVkIGJ1dCBpcyBiZWluZyB1bm1vdW50ZWQsIHRoZXJlJ3Mgbm8gdXNlIHRyeWluZy5cbiAgICAgIC8vIFJlc2V0IHRoZSBzdGF0ZSBzbyB3ZSBkb24ndCBrZWVwIGhvbGRpbmcgb250byBpdC5cbiAgICAgIGlmIChmaWJlciA9PT0gdHJhY2tlZFBhdGhNYXRjaEZpYmVyIHx8IGZpYmVyID09PSB0cmFja2VkUGF0aE1hdGNoRmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICAgIHNldFRyYWNrZWRQYXRoKG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bnNhZmVJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpO1xuXG4gICAgaWYgKHVuc2FmZUlEID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBuZXZlciBzZWVuIHRoaXMgRmliZXIsIGl0IG1pZ2h0IGJlIGluc2lkZSBvZiBhIGxlZ2FjeSByZW5kZXIgU3VzcGVuc2UgZnJhZ21lbnQgKHNvIHRoZSBzdG9yZSBpcyBub3QgZXZlbiBhd2FyZSBvZiBpdCkuXG4gICAgICAvLyBJbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgaWdub3JlIGl0IG9yIGl0IHdpbGwgY2F1c2UgZXJyb3JzIGxhdGVyIG9uLlxuICAgICAgLy8gT25lIGV4YW1wbGUgb2YgdGhpcyBpcyBhIExhenkgY29tcG9uZW50IHRoYXQgbmV2ZXIgcmVzb2x2ZXMgYmVmb3JlIGJlaW5nIHVubW91bnRlZC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gbWlnaHQgaW5kaWNhdGUgYSBGYXN0IFJlZnJlc2ggZm9yY2UtcmVtb3VudCBzY2VuYXJpby5cbiAgICAgIC8vXG4gICAgICAvLyBUT0RPOiBUaGlzIGlzIGZyYWdpbGUgYW5kIGNhbiBvYnNjdXJlIGFjdHVhbCBidWdzLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyByZWZpbmVtZW50LlxuXG5cbiAgICB2YXIgaWQgPSB1bnNhZmVJRDtcbiAgICB2YXIgaXNSb290ID0gZmliZXIudGFnID09PSBIb3N0Um9vdDtcblxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIC8vIFJvb3RzIG11c3QgYmUgcmVtb3ZlZCBvbmx5IGFmdGVyIGFsbCBjaGlsZHJlbiAocGVuZGluZyBhbmQgc2ltdWxhdGVkKSBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAgIC8vIFNvIHdlIHRyYWNrIGl0IHNlcGFyYXRlbHkuXG4gICAgICBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gaWQ7XG4gICAgfSBlbHNlIGlmICghc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpKSB7XG4gICAgICAvLyBUbyBtYWludGFpbiBjaGlsZC1maXJzdCBvcmRlcmluZyxcbiAgICAgIC8vIHdlJ2xsIHB1c2ggaXQgaW50byBvbmUgb2YgdGhlc2UgcXVldWVzLFxuICAgICAgLy8gYW5kIGxhdGVyIGFycmFuZ2UgdGhlbSBpbiB0aGUgY29ycmVjdCBvcmRlci5cbiAgICAgIGlmIChpc1NpbXVsYXRlZCkge1xuICAgICAgICBwZW5kaW5nU2ltdWxhdGVkVW5tb3VudGVkSURzLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMucHVzaChpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmaWJlci5fZGVidWdOZWVkc1JlbW91bnQpIHtcbiAgICAgIHVudHJhY2tGaWJlcklEKGZpYmVyKTtcbiAgICAgIHZhciBpc1Byb2ZpbGluZ1N1cHBvcnRlZCA9IGZpYmVyLmhhc093blByb3BlcnR5KCd0cmVlQmFzZUR1cmF0aW9uJyk7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgICBpZFRvUm9vdE1hcC5kZWxldGUoaWQpO1xuICAgICAgICBpZFRvVHJlZUJhc2VEdXJhdGlvbk1hcC5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50RmliZXJSZWN1cnNpdmVseShmaXJzdENoaWxkLCBwYXJlbnRGaWJlciwgdHJhdmVyc2VTaWJsaW5ncywgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBzaWJsaW5ncyByYXRoZXIgdGhhbiByZWN1cnNpbmcuXG4gICAgLy8gVGhpcyByZWR1Y2VzIHRoZSBjaGFuY2Ugb2Ygc3RhY2sgb3ZlcmZsb3cgZm9yIHdpZGUgdHJlZXMgKGUuZy4gbGlzdHMgd2l0aCBtYW55IGl0ZW1zKS5cbiAgICB2YXIgZmliZXIgPSBmaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhbiBJRCBldmVuIGZvciBmaWx0ZXJlZCBGaWJlcnMsIGluIGNhc2UgaXQncyBuZWVkZWQgbGF0ZXIgKGUuZy4gZm9yIFByb2ZpbGluZykuXG4gICAgICBnZXRPckdlbmVyYXRlRmliZXJJRChmaWJlcik7XG5cbiAgICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgICBkZWJ1ZygnbW91bnRGaWJlclJlY3Vyc2l2ZWx5KCknLCBmaWJlciwgcGFyZW50RmliZXIpO1xuICAgICAgfSAvLyBJZiB3ZSBoYXZlIHRoZSB0cmVlIHNlbGVjdGlvbiBmcm9tIHByZXZpb3VzIHJlbG9hZCwgdHJ5IHRvIG1hdGNoIHRoaXMgRmliZXIuXG4gICAgICAvLyBBbHNvIHJlbWVtYmVyIHdoZXRoZXIgdG8gZG8gdGhlIHNhbWUgZm9yIHNpYmxpbmdzLlxuXG5cbiAgICAgIHZhciBtaWdodFNpYmxpbmdzQmVPblRyYWNrZWRQYXRoID0gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KGZpYmVyKTtcbiAgICAgIHZhciBzaG91bGRJbmNsdWRlSW5UcmVlID0gIXNob3VsZEZpbHRlckZpYmVyKGZpYmVyKTtcblxuICAgICAgaWYgKHNob3VsZEluY2x1ZGVJblRyZWUpIHtcbiAgICAgICAgcmVjb3JkTW91bnQoZmliZXIsIHBhcmVudEZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKTsgLy8gSWYgYW4gYW5jZXN0b3IgdXBkYXRlZCwgd2Ugc2hvdWxkIG1hcmsgdGhlIG5lYXJlc3QgaG9zdCBub2RlcyBmb3IgaGlnaGxpZ2h0aW5nLlxuXG4gICAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSB0eXBlc1tcImlcIiAvKiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQgKi9dKSB7XG4gICAgICAgICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5hZGQoZmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gV2UgaW50ZW50aW9uYWxseSBkbyBub3QgcmUtZW5hYmxlIHRoZSB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlIGZsYWcgaW4gdGhpcyBicmFuY2gsXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBoaWdobGlnaHQgZXZlcnkgaG9zdCBub2RlIGluc2lkZSBvZiBhIG5ld2x5IG1vdW50ZWQgc3VidHJlZS5cblxuICAgICAgfVxuXG4gICAgICB2YXIgaXNTdXNwZW5zZSA9IGZpYmVyLnRhZyA9PT0gUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlQ29tcG9uZW50O1xuXG4gICAgICBpZiAoaXNTdXNwZW5zZSkge1xuICAgICAgICB2YXIgaXNUaW1lZE91dCA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzVGltZWRPdXQpIHtcbiAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIFN1c3BlbnNlIG1vdW50cyBpbiBhIHRpbWVkLW91dCBzdGF0ZSxcbiAgICAgICAgICAvLyBnZXQgdGhlIGZhbGxiYWNrIGNoaWxkIGZyb20gdGhlIGlubmVyIGZyYWdtZW50IGFuZCBtb3VudFxuICAgICAgICAgIC8vIGl0IGFzIGlmIGl0IHdhcyBvdXIgb3duIGNoaWxkLiBVcGRhdGVzIGhhbmRsZSB0aGlzIHRvby5cbiAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQgPyBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nIDogbnVsbDtcbiAgICAgICAgICB2YXIgZmFsbGJhY2tDaGlsZCA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA/IGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5jaGlsZCA6IG51bGw7XG5cbiAgICAgICAgICBpZiAoZmFsbGJhY2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGZhbGxiYWNrQ2hpbGQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBmaWJlciA6IHBhcmVudEZpYmVyLCB0cnVlLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZCA9IG51bGw7XG4gICAgICAgICAgdmFyIGFyZVN1c3BlbnNlQ2hpbGRyZW5Db25kaXRpb25hbGx5V3JhcHBlZCA9IE9mZnNjcmVlbkNvbXBvbmVudCA9PT0gLTE7XG5cbiAgICAgICAgICBpZiAoYXJlU3VzcGVuc2VDaGlsZHJlbkNvbmRpdGlvbmFsbHlXcmFwcGVkKSB7XG4gICAgICAgICAgICBwcmltYXJ5Q2hpbGQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpYmVyLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmltYXJ5Q2hpbGQgPSBmaWJlci5jaGlsZC5jaGlsZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkocHJpbWFyeUNoaWxkLCBzaG91bGRJbmNsdWRlSW5UcmVlID8gZmliZXIgOiBwYXJlbnRGaWJlciwgdHJ1ZSwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmliZXIuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkoZmliZXIuY2hpbGQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBmaWJlciA6IHBhcmVudEZpYmVyLCB0cnVlLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSdyZSBleGl0aW5nIHRoaXMgRmliZXIgbm93LCBhbmQgZW50ZXJpbmcgaXRzIHNpYmxpbmdzLlxuICAgICAgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gdG8gcmVzdG9yZSwgd2UgbWlnaHQgbmVlZCB0byByZS1hY3RpdmF0ZSB0cmFja2luZy5cblxuXG4gICAgICB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQWZ0ZXJNb3VudChtaWdodFNpYmxpbmdzQmVPblRyYWNrZWRQYXRoKTtcbiAgICAgIGZpYmVyID0gdHJhdmVyc2VTaWJsaW5ncyA/IGZpYmVyLnNpYmxpbmcgOiBudWxsO1xuICAgIH1cbiAgfSAvLyBXZSB1c2UgdGhpcyB0byBzaW11bGF0ZSB1bm1vdW50aW5nIGZvciBTdXNwZW5zZSB0cmVlc1xuICAvLyB3aGVuIHdlIHN3aXRjaCBmcm9tIHByaW1hcnkgdG8gZmFsbGJhY2suXG5cblxuICBmdW5jdGlvbiB1bm1vdW50RmliZXJDaGlsZHJlblJlY3Vyc2l2ZWx5KGZpYmVyKSB7XG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBkZWJ1ZygndW5tb3VudEZpYmVyQ2hpbGRyZW5SZWN1cnNpdmVseSgpJywgZmliZXIpO1xuICAgIH0gLy8gV2UgbWlnaHQgbWVldCBhIG5lc3RlZCBTdXNwZW5zZSBvbiBvdXIgd2F5LlxuXG5cbiAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gZmliZXIudGFnID09PSBSZWFjdFR5cGVPZldvcmsuU3VzcGVuc2VDb21wb25lbnQgJiYgZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgIC8vIElmIGl0J3Mgc2hvd2luZyBmYWxsYmFjayB0cmVlLCBsZXQncyB0cmF2ZXJzZSBpdCBpbnN0ZWFkLlxuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQgPyBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nIDogbnVsbDsgLy8gU2tpcCBvdmVyIHRvIHRoZSByZWFsIEZpYmVyIGNoaWxkLlxuXG4gICAgICBjaGlsZCA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA/IGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5jaGlsZCA6IG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBSZWNvcmQgc2ltdWxhdGVkIHVubW91bnRzIGNoaWxkcmVuLWZpcnN0LlxuICAgICAgLy8gV2Ugc2tpcCBub2RlcyB3aXRob3V0IHJldHVybiBiZWNhdXNlIHRob3NlIGFyZSByZWFsIHVubW91bnRzLlxuICAgICAgaWYgKGNoaWxkLnJldHVybiAhPT0gbnVsbCkge1xuICAgICAgICB1bm1vdW50RmliZXJDaGlsZHJlblJlY3Vyc2l2ZWx5KGNoaWxkKTtcbiAgICAgICAgcmVjb3JkVW5tb3VudChjaGlsZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMoZmliZXIpIHtcbiAgICB2YXIgaWQgPSBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKTtcbiAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBmaWJlci5hY3R1YWxEdXJhdGlvbixcbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiA9IGZpYmVyLnRyZWVCYXNlRHVyYXRpb247XG4gICAgaWRUb1RyZWVCYXNlRHVyYXRpb25NYXAuc2V0KGlkLCB0cmVlQmFzZUR1cmF0aW9uIHx8IDApO1xuXG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlOyAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdHJlZUJhc2VEdXJhdGlvbiBldmVuIGlmIHRoZSBjdXJyZW50IEZpYmVyIGRpZCBub3QgcmVuZGVyLFxuICAgICAgLy8gYmVjYXVzZSBpdCdzIHBvc3NpYmxlIHRoYXQgb25lIG9mIGl0cyBkZXNjZW5kYW50cyBkaWQuXG5cbiAgICAgIGlmIChhbHRlcm5hdGUgPT0gbnVsbCB8fCB0cmVlQmFzZUR1cmF0aW9uICE9PSBhbHRlcm5hdGUudHJlZUJhc2VEdXJhdGlvbikge1xuICAgICAgICAvLyBUcmVlIGJhc2UgZHVyYXRpb24gdXBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhlIG9wZXJhdGlvbnMgdHlwZWQgYXJyYXkuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gY29udmVydCB0aGVtIGZyb20gbWlsbGlzZWNvbmRzIHRvIG1pY3Jvc2Vjb25kcyBzbyB3ZSBjYW4gc2VuZCB0aGVtIGFzIGludHMuXG4gICAgICAgIHZhciBjb252ZXJ0ZWRUcmVlQmFzZUR1cmF0aW9uID0gTWF0aC5mbG9vcigodHJlZUJhc2VEdXJhdGlvbiB8fCAwKSAqIDEwMDApO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKGNvbnN0YW50c1tcInJcIiAvKiBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OICovXSk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKGNvbnZlcnRlZFRyZWVCYXNlRHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWx0ZXJuYXRlID09IG51bGwgfHwgZGlkRmliZXJSZW5kZXIoYWx0ZXJuYXRlLCBmaWJlcikpIHtcbiAgICAgICAgaWYgKGFjdHVhbER1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGUgYWN0dWFsIGR1cmF0aW9uIHJlcG9ydGVkIGJ5IFJlYWN0IGluY2x1ZGVzIHRpbWUgc3BlbnQgd29ya2luZyBvbiBjaGlsZHJlbi5cbiAgICAgICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBpbmZvcm1hdGlvbiwgYnV0IGl0J3MgYWxzbyB1c2VmdWwgdG8gYmUgYWJsZSB0byBleGNsdWRlIGNoaWxkIGR1cmF0aW9ucy5cbiAgICAgICAgICAvLyBUaGUgZnJvbnRlbmQgY2FuJ3QgY29tcHV0ZSB0aGlzLCBzaW5jZSB0aGUgaW1tZWRpYXRlIGNoaWxkcmVuIG1heSBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LlxuICAgICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gZG8gdGhpcyBvbiB0aGUgYmFja2VuZC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBjYWxjdWxhdGVkIHNlbGYgZHVyYXRpb24gaXMgbm90IHRoZSBzYW1lIHRoaW5nIGFzIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgIC8vIFRoZSB0d28gYXJlIGNhbGN1bGF0ZWQgZGlmZmVyZW50bHkgKHRyZWUgZHVyYXRpb24gZG9lcyBub3QgYWNjdW11bGF0ZSkuXG4gICAgICAgICAgdmFyIHNlbGZEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmRHVyYXRpb24gLT0gY2hpbGQuYWN0dWFsRHVyYXRpb24gfHwgMDtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgICB9IC8vIElmIHByb2ZpbGluZyBpcyBhY3RpdmUsIHN0b3JlIGR1cmF0aW9ucyBmb3IgZWxlbWVudHMgdGhhdCB3ZXJlIHJlbmRlcmVkIGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBzaG91bGQgZG8gdGhpcyBmb3IgYW55IGZpYmVyIHdlIHBlcmZvcm1lZCB3b3JrIG9uLCByZWdhcmRsZXNzIG9mIGl0cyBhY3R1YWxEdXJhdGlvbiB2YWx1ZS5cbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzIGFjdHVhbER1cmF0aW9uIG1pZ2h0IGJlIDAgZm9yIGZpYmVycyB3ZSB3b3JrZWQgb24gKHBhcnRpY3VsYXJseSBpZiB3ZSdyZSB1c2luZyBEYXRlLm5vdylcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcyAoZS5nLiBNZW1vKSBhY3R1YWxEdXJhdGlvbiBtaWdodCBiZSBncmVhdGVyIHRoYW4gMCBldmVuIGlmIHdlIFwiYmFpbGVkIG91dFwiLlxuXG5cbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGE7XG4gICAgICAgICAgbWV0YWRhdGEuZHVyYXRpb25zLnB1c2goaWQsIGFjdHVhbER1cmF0aW9uLCBzZWxmRHVyYXRpb24pO1xuICAgICAgICAgIG1ldGFkYXRhLm1heEFjdHVhbER1cmF0aW9uID0gTWF0aC5tYXgobWV0YWRhdGEubWF4QWN0dWFsRHVyYXRpb24sIGFjdHVhbER1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VEZXNjcmlwdGlvbiA9IGdldENoYW5nZURlc2NyaXB0aW9uKGFsdGVybmF0ZSwgZmliZXIpO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlRGVzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucy5zZXQoaWQsIGNoYW5nZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVDb250ZXh0c0ZvckZpYmVyKGZpYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRSZXNldENoaWxkcmVuKGZpYmVyLCBjaGlsZFNldCkge1xuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgZGVidWcoJ3JlY29yZFJlc2V0Q2hpbGRyZW4oKScsIGNoaWxkU2V0LCBmaWJlcik7XG4gICAgfSAvLyBUaGUgZnJvbnRlbmQgb25seSByZWFsbHkgY2FyZXMgYWJvdXQgdGhlIGRpc3BsYXlOYW1lLCBrZXksIGFuZCBjaGlsZHJlbi5cbiAgICAvLyBUaGUgZmlyc3QgdHdvIGRvbid0IHJlYWxseSBjaGFuZ2UsIHNvIHdlIGFyZSBvbmx5IGNvbmNlcm5lZCB3aXRoIHRoZSBvcmRlciBvZiBjaGlsZHJlbiBoZXJlLlxuICAgIC8vIFRoaXMgaXMgdHJpY2tpZXIgdGhhbiBhIHNpbXBsZSBjb21wYXJpc29uIHRob3VnaCwgc2luY2UgY2VydGFpbiB0eXBlcyBvZiBmaWJlcnMgYXJlIGZpbHRlcmVkLlxuXG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gW107IC8vIFRoaXMgaXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB0aGF0IHNoYWxsb3dseSByZWNvdXJzZXMgY2hpbGRyZW4uXG4gICAgLy8gV2UgbWlnaHQgd2FudCB0byByZXZpc2l0IHRoaXMgaWYgaXQgcHJvdmVzIHRvIGJlIHRvbyBpbmVmZmljaWVudC5cblxuICAgIHZhciBjaGlsZCA9IGNoaWxkU2V0O1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBmaW5kUmVvcmRlcmVkQ2hpbGRyZW5SZWN1cnNpdmVseShjaGlsZCwgbmV4dENoaWxkcmVuKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgbnVtQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgaWYgKG51bUNoaWxkcmVuIDwgMikge1xuICAgICAgLy8gTm8gbmVlZCB0byByZW9yZGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wib1wiIC8qIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4gKi9dKTtcbiAgICBwdXNoT3BlcmF0aW9uKGdldEZpYmVySURUaHJvd3MoZmliZXIpKTtcbiAgICBwdXNoT3BlcmF0aW9uKG51bUNoaWxkcmVuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwdXNoT3BlcmF0aW9uKG5leHRDaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFJlb3JkZXJlZENoaWxkcmVuUmVjdXJzaXZlbHkoZmliZXIsIG5leHRDaGlsZHJlbikge1xuICAgIGlmICghc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpKSB7XG4gICAgICBuZXh0Q2hpbGRyZW4ucHVzaChnZXRGaWJlcklEVGhyb3dzKGZpYmVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuICAgICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgaWYgKGlzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIFN1c3BlbnNlIG1vdW50cyBpbiBhIHRpbWVkLW91dCBzdGF0ZSxcbiAgICAgICAgLy8gZ2V0IHRoZSBmYWxsYmFjayBjaGlsZCBmcm9tIHRoZSBpbm5lciBmcmFnbWVudCxcbiAgICAgICAgLy8gYW5kIHNraXAgb3ZlciB0aGUgcHJpbWFyeSBjaGlsZC5cbiAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudCA/IHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgOiBudWxsO1xuICAgICAgICB2YXIgZmFsbGJhY2tDaGlsZCA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA/IGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5jaGlsZCA6IG51bGw7XG5cbiAgICAgICAgaWYgKGZhbGxiYWNrQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBjaGlsZCA9IGZhbGxiYWNrQ2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRSZW9yZGVyZWRDaGlsZHJlblJlY3Vyc2l2ZWx5KGNoaWxkLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJldHVybnMgd2hldGhlciBjbG9zZXN0IHVuZmlsdGVyZWQgZmliZXIgcGFyZW50IG5lZWRzIHRvIHJlc2V0IGl0cyBjaGlsZCBsaXN0LlxuXG5cbiAgZnVuY3Rpb24gdXBkYXRlRmliZXJSZWN1cnNpdmVseShuZXh0RmliZXIsIHByZXZGaWJlciwgcGFyZW50RmliZXIsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICB2YXIgaWQgPSBnZXRPckdlbmVyYXRlRmliZXJJRChuZXh0RmliZXIpO1xuXG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBkZWJ1ZygndXBkYXRlRmliZXJSZWN1cnNpdmVseSgpJywgbmV4dEZpYmVyLCBwYXJlbnRGaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIobmV4dEZpYmVyKTtcblxuICAgICAgaWYgKHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgLy8gSWYgYW4gYW5jZXN0b3IgdXBkYXRlZCwgd2Ugc2hvdWxkIG1hcmsgdGhlIG5lYXJlc3QgaG9zdCBub2RlcyBmb3IgaGlnaGxpZ2h0aW5nLlxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IHR5cGVzW1wiaVwiIC8qIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCAqL10pIHtcbiAgICAgICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5hZGQobmV4dEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IHR5cGVzW1wiaFwiIC8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi9dIHx8IGVsZW1lbnRUeXBlID09PSB0eXBlc1tcImVcIiAvKiBFbGVtZW50VHlwZUNsYXNzICovXSB8fCBlbGVtZW50VHlwZSA9PT0gdHlwZXNbXCJmXCIgLyogRWxlbWVudFR5cGVDb250ZXh0ICovXSB8fCBlbGVtZW50VHlwZSA9PT0gdHlwZXNbXCJqXCIgLyogRWxlbWVudFR5cGVNZW1vICovXSB8fCBlbGVtZW50VHlwZSA9PT0gdHlwZXNbXCJnXCIgLyogRWxlbWVudFR5cGVGb3J3YXJkUmVmICovXSkge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiB0aGlzIGlzIGEgdHJhY2VkIGFuY2VzdG9yLCBmbGFnIGZvciB0aGUgbmVhcmVzdCBob3N0IGRlc2NlbmRhbnQocykuXG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSA9IGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgbmV4dEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQuaWQgPT09IGlkICYmIGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgbmV4dEZpYmVyKSkge1xuICAgICAgLy8gSWYgdGhpcyBGaWJlciBoYXMgdXBkYXRlZCwgY2xlYXIgY2FjaGVkIGluc3BlY3RlZCBkYXRhLlxuICAgICAgLy8gSWYgaXQgaXMgaW5zcGVjdGVkIGFnYWluLCBpdCBtYXkgbmVlZCB0byBiZSByZS1ydW4gdG8gb2J0YWluIHVwZGF0ZWQgaG9va3MgdmFsdWVzLlxuICAgICAgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRJbmNsdWRlSW5UcmVlID0gIXNob3VsZEZpbHRlckZpYmVyKG5leHRGaWJlcik7XG4gICAgdmFyIGlzU3VzcGVuc2UgPSBuZXh0RmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudDtcbiAgICB2YXIgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IGZhbHNlOyAvLyBUaGUgYmVoYXZpb3Igb2YgdGltZWQtb3V0IFN1c3BlbnNlIHRyZWVzIGlzIHVuaXF1ZS5cbiAgICAvLyBSYXRoZXIgdGhhbiB1bm1vdW50IHRoZSB0aW1lZCBvdXQgY29udGVudCAoYW5kIHBvc3NpYmx5IGxvc2UgaW1wb3J0YW50IHN0YXRlKSxcbiAgICAvLyBSZWFjdCByZS1wYXJlbnRzIHRoaXMgY29udGVudCB3aXRoaW4gYSBoaWRkZW4gRnJhZ21lbnQgd2hpbGUgdGhlIGZhbGxiYWNrIGlzIHNob3dpbmcuXG4gICAgLy8gVGhpcyBiZWhhdmlvciBkb2Vzbid0IG5lZWQgdG8gYmUgb2JzZXJ2YWJsZSBpbiB0aGUgRGV2VG9vbHMgdGhvdWdoLlxuICAgIC8vIEl0IG1pZ2h0IGV2ZW4gcmVzdWx0IGluIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSBmb3IgZS5nLiBub2RlIHNlbGVjdGlvbiBpbiB0aGUgRWxlbWVudHMgcGFuZWwuXG4gICAgLy8gVGhlIGVhc2llc3QgZml4IGlzIHRvIHN0cmlwIG91dCB0aGUgaW50ZXJtZWRpYXRlIEZyYWdtZW50IGZpYmVycyxcbiAgICAvLyBzbyB0aGUgRWxlbWVudHMgcGFuZWwgYW5kIFByb2ZpbGVyIGRvbid0IG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoZW0uXG4gICAgLy8gU3VzcGVuc2UgY29tcG9uZW50cyBvbmx5IGhhdmUgYSBub24tbnVsbCBtZW1vaXplZFN0YXRlIGlmIHRoZXkncmUgdGltZWQtb3V0LlxuXG4gICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gaXNTdXNwZW5zZSAmJiBwcmV2RmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICB2YXIgbmV4dERpZFRpbWVPdXQgPSBpc1N1c3BlbnNlICYmIG5leHRGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsOyAvLyBUaGUgbG9naWMgYmVsb3cgaXMgaW5zcGlyZWQgYnkgdGhlIGNvZGUgcGF0aHMgaW4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoKVxuICAgIC8vIGluc2lkZSBSZWFjdEZpYmVyQmVnaW5Xb3JrIGluIHRoZSBSZWFjdCBzb3VyY2UgY29kZS5cblxuICAgIGlmIChwcmV2RGlkVGltZW91dCAmJiBuZXh0RGlkVGltZU91dCkge1xuICAgICAgLy8gRmFsbGJhY2sgLT4gRmFsbGJhY2s6XG4gICAgICAvLyAxLiBSZWNvbmNpbGUgZmFsbGJhY2sgc2V0LlxuICAgICAgdmFyIG5leHRGaWJlckNoaWxkID0gbmV4dEZpYmVyLmNoaWxkO1xuICAgICAgdmFyIG5leHRGYWxsYmFja0NoaWxkU2V0ID0gbmV4dEZpYmVyQ2hpbGQgPyBuZXh0RmliZXJDaGlsZC5zaWJsaW5nIDogbnVsbDsgLy8gTm90ZTogV2UgY2FuJ3QgdXNlIG5leHRGaWJlci5jaGlsZC5zaWJsaW5nLmFsdGVybmF0ZVxuICAgICAgLy8gYmVjYXVzZSB0aGUgc2V0IGlzIHNwZWNpYWwgYW5kIGFsdGVybmF0ZSBtYXkgbm90IGV4aXN0LlxuXG4gICAgICB2YXIgcHJldkZpYmVyQ2hpbGQgPSBwcmV2RmliZXIuY2hpbGQ7XG4gICAgICB2YXIgcHJldkZhbGxiYWNrQ2hpbGRTZXQgPSBwcmV2RmliZXJDaGlsZCA/IHByZXZGaWJlckNoaWxkLnNpYmxpbmcgOiBudWxsO1xuXG4gICAgICBpZiAobmV4dEZhbGxiYWNrQ2hpbGRTZXQgIT0gbnVsbCAmJiBwcmV2RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsICYmIHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkobmV4dEZhbGxiYWNrQ2hpbGRTZXQsIHByZXZGYWxsYmFja0NoaWxkU2V0LCBuZXh0RmliZXIsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpKSB7XG4gICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldkRpZFRpbWVvdXQgJiYgIW5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBGYWxsYmFjayAtPiBQcmltYXJ5OlxuICAgICAgLy8gMS4gVW5tb3VudCBmYWxsYmFjayBzZXRcbiAgICAgIC8vIE5vdGU6IGRvbid0IGVtdWxhdGUgZmFsbGJhY2sgdW5tb3VudCBiZWNhdXNlIFJlYWN0IGFjdHVhbGx5IGRpZCBpdC5cbiAgICAgIC8vIDIuIE1vdW50IHByaW1hcnkgc2V0XG4gICAgICB2YXIgbmV4dFByaW1hcnlDaGlsZFNldCA9IG5leHRGaWJlci5jaGlsZDtcblxuICAgICAgaWYgKG5leHRQcmltYXJ5Q2hpbGRTZXQgIT09IG51bGwpIHtcbiAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KG5leHRQcmltYXJ5Q2hpbGRTZXQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlciwgdHJ1ZSwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXByZXZEaWRUaW1lb3V0ICYmIG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBQcmltYXJ5IC0+IEZhbGxiYWNrOlxuICAgICAgLy8gMS4gSGlkZSBwcmltYXJ5IHNldFxuICAgICAgLy8gVGhpcyBpcyBub3QgYSByZWFsIHVubW91bnQsIHNvIGl0IHdvbid0IGdldCByZXBvcnRlZCBieSBSZWFjdC5cbiAgICAgIC8vIFdlIG5lZWQgdG8gbWFudWFsbHkgd2FsayB0aGUgcHJldmlvdXMgdHJlZSBhbmQgcmVjb3JkIHVubW91bnRzLlxuICAgICAgdW5tb3VudEZpYmVyQ2hpbGRyZW5SZWN1cnNpdmVseShwcmV2RmliZXIpOyAvLyAyLiBNb3VudCBmYWxsYmFjayBzZXRcblxuICAgICAgdmFyIF9uZXh0RmliZXJDaGlsZCA9IG5leHRGaWJlci5jaGlsZDtcblxuICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZFNldCA9IF9uZXh0RmliZXJDaGlsZCA/IF9uZXh0RmliZXJDaGlsZC5zaWJsaW5nIDogbnVsbDtcblxuICAgICAgaWYgKF9uZXh0RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsKSB7XG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShfbmV4dEZhbGxiYWNrQ2hpbGRTZXQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlciwgdHJ1ZSwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb21tb24gY2FzZTogUHJpbWFyeSAtPiBQcmltYXJ5LlxuICAgICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBjb2RlIHBhdGggYXMgZm9yIG5vbi1TdXNwZW5zZSBmaWJlcnMuXG4gICAgICBpZiAobmV4dEZpYmVyLmNoaWxkICE9PSBwcmV2RmliZXIuY2hpbGQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGNoaWxkIGlzIGRpZmZlcmVudCwgd2UgbmVlZCB0byB0cmF2ZXJzZSB0aGVtLlxuICAgICAgICAvLyBFYWNoIG5leHQgY2hpbGQgd2lsbCBiZSBlaXRoZXIgYSBuZXcgY2hpbGQgKG1vdW50KSBvciBhbiBhbHRlcm5hdGUgKHVwZGF0ZSkuXG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0RmliZXIuY2hpbGQ7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRBdFNhbWVJbmRleCA9IHByZXZGaWJlci5jaGlsZDtcblxuICAgICAgICB3aGlsZSAobmV4dENoaWxkKSB7XG4gICAgICAgICAgLy8gV2UgYWxyZWFkeSBrbm93IGNoaWxkcmVuIHdpbGwgYmUgcmVmZXJlbnRpYWxseSBkaWZmZXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZXkgYXJlIGVpdGhlciBuZXcgbW91bnRzIG9yIGFsdGVybmF0ZXMgb2YgcHJldmlvdXMgY2hpbGRyZW4uXG4gICAgICAgICAgLy8gU2NoZWR1bGUgdXBkYXRlcyBhbmQgbW91bnRzIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFsdGVybmF0ZXMgZXhpc3QuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgdHJhY2sgZGVsZXRpb25zIGhlcmUgYmVjYXVzZSB0aGV5IGFyZSByZXBvcnRlZCBzZXBhcmF0ZWx5LlxuICAgICAgICAgIGlmIChuZXh0Q2hpbGQuYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB2YXIgcHJldkNoaWxkID0gbmV4dENoaWxkLmFsdGVybmF0ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkobmV4dENoaWxkLCBwcmV2Q2hpbGQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlciwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYSBuZXN0ZWQgdHJlZSBjaGlsZCBvcmRlciBjaGFuZ2VkIGJ1dCBpdCBjYW4ndCBoYW5kbGUgaXRzIG93blxuICAgICAgICAgICAgICAvLyBjaGlsZCBvcmRlciBpbnZhbGlkYXRpb24gKGUuZy4gYmVjYXVzZSBpdCdzIGZpbHRlcmVkIG91dCBsaWtlIGhvc3Qgbm9kZXMpLFxuICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgdGhlIG5lZWQgdG8gcmVzZXQgY2hpbGQgb3JkZXIgdXB3YXJkcyB0byB0aGlzIEZpYmVyLlxuICAgICAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gLy8gSG93ZXZlciB3ZSBhbHNvIGtlZXAgdHJhY2sgaWYgdGhlIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBtYXRjaGVzXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgb3JkZXIuIFRoZXkgYXJlIGFsd2F5cyBkaWZmZXJlbnQgcmVmZXJlbnRpYWxseSwgYnV0XG4gICAgICAgICAgICAvLyBpZiB0aGUgaW5zdGFuY2VzIGxpbmUgdXAgY29uY2VwdHVhbGx5IHdlJ2xsIHdhbnQgdG8ga25vdyB0aGF0LlxuXG5cbiAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQgIT09IHByZXZDaGlsZEF0U2FtZUluZGV4KSB7XG4gICAgICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkobmV4dENoaWxkLCBzaG91bGRJbmNsdWRlSW5UcmVlID8gbmV4dEZpYmVyIDogcGFyZW50RmliZXIsIGZhbHNlLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKTtcbiAgICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgIH0gLy8gVHJ5IHRoZSBuZXh0IGNoaWxkLlxuXG5cbiAgICAgICAgICBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGQuc2libGluZzsgLy8gQWR2YW5jZSB0aGUgcG9pbnRlciBpbiB0aGUgcHJldmlvdXMgbGlzdCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgIC8vIGtlZXAgY29tcGFyaW5nIGlmIHRoZXkgbGluZSB1cC5cblxuICAgICAgICAgIGlmICghc2hvdWxkUmVzZXRDaGlsZHJlbiAmJiBwcmV2Q2hpbGRBdFNhbWVJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldkNoaWxkQXRTYW1lSW5kZXggPSBwcmV2Q2hpbGRBdFNhbWVJbmRleC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB3ZSBoYXZlIG5vIG1vcmUgY2hpbGRyZW4sIGJ1dCB1c2VkIHRvLCB0aGV5IGRvbid0IGxpbmUgdXAuXG5cblxuICAgICAgICBpZiAocHJldkNoaWxkQXRTYW1lSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSB0cmFjaW5nIHVwZGF0ZXMgYW5kIHdlJ3ZlIGJhaWxlZCBvdXQgYmVmb3JlIHJlYWNoaW5nIGEgaG9zdCBub2RlLFxuICAgICAgICAgIC8vIHdlIHNob3VsZCBmYWxsIGJhY2sgdG8gcmVjdXJzaXZlbHkgbWFya2luZyB0aGUgbmVhcmVzdCBob3N0IGRlc2NlbmRhbnRzIGZvciBoaWdobGlnaHQuXG4gICAgICAgICAgaWYgKHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBob3N0RmliZXJzID0gZmluZEFsbEN1cnJlbnRIb3N0RmliZXJzKGdldEZpYmVySURUaHJvd3MobmV4dEZpYmVyKSk7XG4gICAgICAgICAgICBob3N0RmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RGaWJlcikge1xuICAgICAgICAgICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5hZGQoaG9zdEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkSW5jbHVkZUluVHJlZSkge1xuICAgICAgdmFyIGlzUHJvZmlsaW5nU3VwcG9ydGVkID0gbmV4dEZpYmVyLmhhc093blByb3BlcnR5KCd0cmVlQmFzZUR1cmF0aW9uJyk7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMobmV4dEZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmVzZXRDaGlsZHJlbikge1xuICAgICAgLy8gV2UgbmVlZCB0byBjcmF3bCB0aGUgc3VidHJlZSBmb3IgY2xvc2VzdCBub24tZmlsdGVyZWQgRmliZXJzXG4gICAgICAvLyBzbyB0aGF0IHdlIGNhbiBkaXNwbGF5IHRoZW0gaW4gYSBmbGF0IGNoaWxkcmVuIHNldC5cbiAgICAgIGlmIChzaG91bGRJbmNsdWRlSW5UcmVlKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5LCBzZWFyY2ggZm9yIGNoaWxkcmVuIGZyb20gdGhlIHJlbmRlcmVkIGNoaWxkLlxuICAgICAgICB2YXIgbmV4dENoaWxkU2V0ID0gbmV4dEZpYmVyLmNoaWxkO1xuXG4gICAgICAgIGlmIChuZXh0RGlkVGltZU91dCkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogdGltZWQtb3V0IFN1c3BlbnNlIHJlbmRlcnMgdGhlIGZhbGxiYWNrIHNldC5cbiAgICAgICAgICB2YXIgX25leHRGaWJlckNoaWxkMiA9IG5leHRGaWJlci5jaGlsZDtcbiAgICAgICAgICBuZXh0Q2hpbGRTZXQgPSBfbmV4dEZpYmVyQ2hpbGQyID8gX25leHRGaWJlckNoaWxkMi5zaWJsaW5nIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0Q2hpbGRTZXQgIT0gbnVsbCkge1xuICAgICAgICAgIHJlY29yZFJlc2V0Q2hpbGRyZW4obmV4dEZpYmVyLCBuZXh0Q2hpbGRTZXQpO1xuICAgICAgICB9IC8vIFdlJ3ZlIGhhbmRsZWQgdGhlIGNoaWxkIG9yZGVyIGNoYW5nZSBmb3IgdGhpcyBGaWJlci5cbiAgICAgICAgLy8gU2luY2UgaXQncyBpbmNsdWRlZCwgdGhlcmUncyBubyBuZWVkIHRvIGludmFsaWRhdGUgcGFyZW50IGNoaWxkIG9yZGVyLlxuXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTGV0IHRoZSBjbG9zZXN0IHVuZmlsdGVyZWQgcGFyZW50IEZpYmVyIHJlc2V0IGl0cyBjaGlsZCBvcmRlciBpbnN0ZWFkLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7Ly8gV2UgZG9uJ3QgcGF0Y2ggYW55IG1ldGhvZHMgc28gdGhlcmUgaXMgbm8gY2xlYW51cC5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KSB7XG4gICAgaWYgKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgLy8gdjE2IGJ1aWxkcyBpbmNsdWRlIHRoaXMgZmllbGQgZm9yIHRoZSBzY2hlZHVsZXIvdHJhY2luZyBBUEkuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJvb3QuY3VycmVudCAhPSBudWxsICYmIHJvb3QuY3VycmVudC5oYXNPd25Qcm9wZXJ0eSgndHJlZUJhc2VEdXJhdGlvbicpKSB7XG4gICAgICAvLyBUaGUgc2NoZWR1bGVyL3RyYWNpbmcgQVBJIHdhcyByZW1vdmVkIGluIHYxNyB0aG91Z2hcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgYSBub24tcm9vdCBGaWJlci5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hJbml0aWFsT3BlcmF0aW9ucygpIHtcbiAgICB2YXIgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlID0gcGVuZGluZ09wZXJhdGlvbnNRdWV1ZTtcbiAgICBwZW5kaW5nT3BlcmF0aW9uc1F1ZXVlID0gbnVsbDtcblxuICAgIGlmIChsb2NhbFBlbmRpbmdPcGVyYXRpb25zUXVldWUgIT09IG51bGwgJiYgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFdlIG1heSBoYXZlIGFscmVhZHkgcXVldWVkIHVwIHNvbWUgb3BlcmF0aW9ucyBiZWZvcmUgdGhlIGZyb250ZW5kIGNvbm5lY3RlZFxuICAgICAgLy8gSWYgc28sIGxldCB0aGUgZnJvbnRlbmQga25vdyBhYm91dCB0aGVtLlxuICAgICAgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlLmZvckVhY2goZnVuY3Rpb24gKG9wZXJhdGlvbnMpIHtcbiAgICAgICAgaG9vay5lbWl0KCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmVmb3JlIHRoZSB0cmF2ZXJzYWxzLCByZW1lbWJlciB0byBzdGFydCB0cmFja2luZ1xuICAgICAgLy8gb3VyIHBhdGggaW4gY2FzZSB3ZSBoYXZlIHNlbGVjdGlvbiB0byByZXN0b3JlLlxuICAgICAgaWYgKHRyYWNrZWRQYXRoICE9PSBudWxsKSB7XG4gICAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gdHJ1ZTtcbiAgICAgIH0gLy8gSWYgd2UgaGF2ZSBub3QgYmVlbiBwcm9maWxpbmcsIHRoZW4gd2UgY2FuIGp1c3Qgd2FsayB0aGUgdHJlZSBhbmQgYnVpbGQgdXAgaXRzIGN1cnJlbnQgc3RhdGUgYXMtaXMuXG5cblxuICAgICAgaG9vay5nZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgY3VycmVudFJvb3RJRCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKHJvb3QuY3VycmVudCk7XG4gICAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3RJRCwgcm9vdC5jdXJyZW50KTsgLy8gSGFuZGxlIG11bHRpLXJlbmRlcmVyIGVkZ2UtY2FzZSB3aGVyZSBvbmx5IHNvbWUgdjE2IHJlbmRlcmVycyBzdXBwb3J0IHByb2ZpbGluZy5cblxuICAgICAgICBpZiAoaXNQcm9maWxpbmcgJiYgcm9vdFN1cHBvcnRzUHJvZmlsaW5nKHJvb3QpKSB7XG4gICAgICAgICAgLy8gSWYgcHJvZmlsaW5nIGlzIGFjdGl2ZSwgc3RvcmUgY29tbWl0IHRpbWUgYW5kIGR1cmF0aW9uLlxuICAgICAgICAgIC8vIFRoZSBmcm9udGVuZCBtYXkgcmVxdWVzdCB0aGlzIGluZm9ybWF0aW9uIGFmdGVyIHByb2ZpbGluZyBoYXMgc3RvcHBlZC5cbiAgICAgICAgICBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/IG5ldyBNYXAoKSA6IG51bGwsXG4gICAgICAgICAgICBkdXJhdGlvbnM6IFtdLFxuICAgICAgICAgICAgY29tbWl0VGltZTogcmVuZGVyZXJfZ2V0Q3VycmVudFRpbWUoKSAtIHByb2ZpbGluZ1N0YXJ0VGltZSxcbiAgICAgICAgICAgIG1heEFjdHVhbER1cmF0aW9uOiAwLFxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbDogbnVsbCxcbiAgICAgICAgICAgIHVwZGF0ZXJzOiBnZXRVcGRhdGVyc0xpc3Qocm9vdCksXG4gICAgICAgICAgICBlZmZlY3REdXJhdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG4gICAgICAgIGN1cnJlbnRSb290SUQgPSAtMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVwZGF0ZXJzTGlzdChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QubWVtb2l6ZWRVcGRhdGVycyAhPSBudWxsID8gQXJyYXkuZnJvbShyb290Lm1lbW9pemVkVXBkYXRlcnMpLmZpbHRlcihmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKSAhPT0gbnVsbDtcbiAgICB9KS5tYXAoZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb21taXRGaWJlclVubW91bnQoZmliZXIpIHtcbiAgICAvLyBJZiB0aGUgdW50cmFja0ZpYmVyU2V0IGFscmVhZHkgaGFzIHRoZSB1bm1vdW50ZWQgRmliZXIsIHRoaXMgbWVhbnMgd2UndmUgYWxyZWFkeVxuICAgIC8vIHJlY29yZGVkVW5tb3VudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBpdCBhZ2Fpbi4gSWYgd2UgZG9uJ3QgZG8gdGhpcywgd2UgbWlnaHRcbiAgICAvLyBlbmQgdXAgZG91YmxlLWRlbGV0aW5nIEZpYmVycyBpbiBzb21lIGNhc2VzIChsaWtlIExlZ2FjeSBTdXNwZW5zZSkuXG4gICAgaWYgKCF1bnRyYWNrRmliZXJzU2V0LmhhcyhmaWJlcikpIHtcbiAgICAgIC8vIFRoaXMgaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAgIC8vIFdlIGNhbid0IHRyYXZlcnNlIGZpYmVycyBhZnRlciB1bm1vdW50aW5nIHNvIGluc3RlYWRcbiAgICAgIC8vIHdlIHJlbHkgb24gUmVhY3QgdGVsbGluZyB1cyBhYm91dCBlYWNoIHVubW91bnQuXG4gICAgICByZWNvcmRVbm1vdW50KGZpYmVyLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdChyb290KSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nICYmIHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KSkge1xuICAgICAgaWYgKGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2dldEVmZmVjdER1cmF0aW9ucyA9IE9iamVjdChiYWNrZW5kX3V0aWxzW1wiZ1wiIC8qIGdldEVmZmVjdER1cmF0aW9ucyAqL10pKHJvb3QpLFxuICAgICAgICAgICAgZWZmZWN0RHVyYXRpb24gPSBfZ2V0RWZmZWN0RHVyYXRpb25zLmVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gX2dldEVmZmVjdER1cmF0aW9ucy5wYXNzaXZlRWZmZWN0RHVyYXRpb247IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhLmVmZmVjdER1cmF0aW9uID0gZWZmZWN0RHVyYXRpb247IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29tbWl0RmliZXJSb290KHJvb3QsIHByaW9yaXR5TGV2ZWwpIHtcbiAgICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7IC8vIEZsdXNoIGFueSBwZW5kaW5nIEZpYmVycyB0aGF0IHdlIGFyZSB1bnRyYWNraW5nIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSBuZXcgY29tbWl0LlxuICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIHdlIG1pZ2h0IGVuZCB1cCBkb3VibGUtZGVsZXRpbmcgRmliZXJzIGluIHNvbWUgY2FzZXMgKGxpa2UgTGVnYWN5IFN1c3BlbnNlKS5cblxuICAgIHVudHJhY2tGaWJlcnMoKTtcbiAgICBjdXJyZW50Um9vdElEID0gZ2V0T3JHZW5lcmF0ZUZpYmVySUQoY3VycmVudCk7IC8vIEJlZm9yZSB0aGUgdHJhdmVyc2FscywgcmVtZW1iZXIgdG8gc3RhcnQgdHJhY2tpbmdcbiAgICAvLyBvdXIgcGF0aCBpbiBjYXNlIHdlIGhhdmUgc2VsZWN0aW9uIHRvIHJlc3RvcmUuXG5cbiAgICBpZiAodHJhY2tlZFBhdGggIT09IG51bGwpIHtcbiAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgdHJhY2VVcGRhdGVzRm9yTm9kZXMuY2xlYXIoKTtcbiAgICB9IC8vIEhhbmRsZSBtdWx0aS1yZW5kZXJlciBlZGdlLWNhc2Ugd2hlcmUgb25seSBzb21lIHYxNiByZW5kZXJlcnMgc3VwcG9ydCBwcm9maWxpbmcuXG5cblxuICAgIHZhciBpc1Byb2ZpbGluZ1N1cHBvcnRlZCA9IHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KTtcblxuICAgIGlmIChpc1Byb2ZpbGluZyAmJiBpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgLy8gSWYgcHJvZmlsaW5nIGlzIGFjdGl2ZSwgc3RvcmUgY29tbWl0IHRpbWUgYW5kIGR1cmF0aW9uLlxuICAgICAgLy8gVGhlIGZyb250ZW5kIG1heSByZXF1ZXN0IHRoaXMgaW5mb3JtYXRpb24gYWZ0ZXIgcHJvZmlsaW5nIGhhcyBzdG9wcGVkLlxuICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/IG5ldyBNYXAoKSA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uczogW10sXG4gICAgICAgIGNvbW1pdFRpbWU6IHJlbmRlcmVyX2dldEN1cnJlbnRUaW1lKCkgLSBwcm9maWxpbmdTdGFydFRpbWUsXG4gICAgICAgIG1heEFjdHVhbER1cmF0aW9uOiAwLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsID09IG51bGwgPyBudWxsIDogZm9ybWF0UHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsKSxcbiAgICAgICAgdXBkYXRlcnM6IGdldFVwZGF0ZXJzTGlzdChyb290KSxcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byBudWxsOyBpZiBuZXcgZW5vdWdoIFJlYWN0IHZlcnNpb24gaXMgcnVubmluZyxcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHdpbGwgYmUgcmVhZCBkdXJpbmcgc2VwYXJhdGUgaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCgpIGNhbGwuXG4gICAgICAgIGVmZmVjdER1cmF0aW9uOiBudWxsLFxuICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGFsdGVybmF0ZSkge1xuICAgICAgLy8gVE9ETzogcmVseWluZyBvbiB0aGlzIHNlZW1zIGEgYml0IGZpc2h5LlxuICAgICAgdmFyIHdhc01vdW50ZWQgPSBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbCAmJiAvLyBBIGRlaHlkcmF0ZWQgcm9vdCBpcyBub3QgY29uc2lkZXJlZCBtb3VudGVkXG4gICAgICBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQgIT09IHRydWU7XG4gICAgICB2YXIgaXNNb3VudGVkID0gY3VycmVudC5tZW1vaXplZFN0YXRlICE9IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbCAmJiAvLyBBIGRlaHlkcmF0ZWQgcm9vdCBpcyBub3QgY29uc2lkZXJlZCBtb3VudGVkXG4gICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkICE9PSB0cnVlO1xuXG4gICAgICBpZiAoIXdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3RJRCwgY3VycmVudCk7XG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShjdXJyZW50LCBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xuICAgICAgICAvLyBVcGRhdGUgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgdXBkYXRlRmliZXJSZWN1cnNpdmVseShjdXJyZW50LCBhbHRlcm5hdGUsIG51bGwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAod2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIFVubW91bnQgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgcmVtb3ZlUm9vdFBzZXVkb0tleShjdXJyZW50Um9vdElEKTtcbiAgICAgICAgcmVjb3JkVW5tb3VudChjdXJyZW50LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICBzZXRSb290UHNldWRvS2V5KGN1cnJlbnRSb290SUQsIGN1cnJlbnQpO1xuICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGN1cnJlbnQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvZmlsaW5nICYmIGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoIXNob3VsZEJhaWxvdXRXaXRoUGVuZGluZ09wZXJhdGlvbnMoKSkge1xuICAgICAgICB2YXIgY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgPSByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcC5nZXQoY3VycmVudFJvb3RJRCk7XG5cbiAgICAgICAgaWYgKGNvbW1pdFByb2ZpbGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBjb21taXRQcm9maWxpbmdNZXRhZGF0YS5wdXNoKGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAuc2V0KGN1cnJlbnRSb290SUQsIFtjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2UncmUgZG9uZSBoZXJlLlxuXG5cbiAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG5cbiAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgaG9vay5lbWl0KCd0cmFjZVVwZGF0ZXMnLCB0cmFjZVVwZGF0ZXNGb3JOb2Rlcyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJvb3RJRCA9IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEFsbEN1cnJlbnRIb3N0RmliZXJzKGlkKSB7XG4gICAgdmFyIGZpYmVycyA9IFtdO1xuICAgIHZhciBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoQnlJZChpZCk7XG5cbiAgICBpZiAoIWZpYmVyKSB7XG4gICAgICByZXR1cm4gZmliZXJzO1xuICAgIH0gLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgYWxsIEhvc3RDb21wb25lbnQvVGV4dC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGZpYmVycy5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpYmVycztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgICAgaWYgKCFub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmliZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH0gLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXG5cbiAgICByZXR1cm4gZmliZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZE5hdGl2ZU5vZGVzRm9yRmliZXJJRChpZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX2ZpYmVyMyA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoQnlJZChpZCk7XG5cbiAgICAgIGlmIChfZmliZXIzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgdGltZWQtb3V0IFN1c3BlbnNlLlxuXG5cbiAgICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBfZmliZXIzLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgX2ZpYmVyMy5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgIC8vIEEgdGltZWQtb3V0IFN1c3BlbnNlJ3MgZmluZERPTU5vZGUgaXMgdXNlbGVzcy5cbiAgICAgICAgLy8gVHJ5IG91ciBiZXN0IHRvIGZpbmQgdGhlIGZhbGxiYWNrIGRpcmVjdGx5LlxuICAgICAgICB2YXIgbWF5YmVGYWxsYmFja0ZpYmVyID0gX2ZpYmVyMy5jaGlsZCAmJiBfZmliZXIzLmNoaWxkLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKG1heWJlRmFsbGJhY2tGaWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgX2ZpYmVyMyA9IG1heWJlRmFsbGJhY2tGaWJlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaG9zdEZpYmVycyA9IGZpbmRBbGxDdXJyZW50SG9zdEZpYmVycyhpZCk7XG4gICAgICByZXR1cm4gaG9zdEZpYmVycy5tYXAoZnVuY3Rpb24gKGhvc3RGaWJlcikge1xuICAgICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRoZSBmaWJlciBtaWdodCBoYXZlIHVubW91bnRlZCBieSBub3cuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZUZvckZpYmVySUQoaWQpIHtcbiAgICB2YXIgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcbiAgICByZXR1cm4gZmliZXIgIT0gbnVsbCA/IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpYmVyRm9yTmF0aXZlKGhvc3RJbnN0YW5jZSkge1xuICAgIHJldHVybiByZW5kZXJlci5maW5kRmliZXJCeUhvc3RJbnN0YW5jZShob3N0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmliZXJJREZvck5hdGl2ZShob3N0SW5zdGFuY2UpIHtcbiAgICB2YXIgZmluZE5lYXJlc3RVbmZpbHRlcmVkQW5jZXN0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBmaWJlciA9IHJlbmRlcmVyLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG5cbiAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKGZpbmROZWFyZXN0VW5maWx0ZXJlZEFuY2VzdG9yKSB7XG4gICAgICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCAmJiBzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0RmliZXJJRFRocm93cyhmaWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBmdW5jdGlvbiBpcyBjb3BpZWQgZnJvbSBSZWFjdCBhbmQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYzpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyVHJlZVJlZmxlY3Rpb24uanNcblxuXG4gIGZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAgIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIFJlYWN0IGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5qc1xuXG5cbiAgZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgICB2YXIgbmV4dE5vZGUgPSBub2RlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUgPSBuZXh0Tm9kZTsgLy8gVE9ETzogVGhpcyBmdW5jdGlvbiwgYW5kIHRoZXNlIGZsYWdzLCBhcmUgYSBsZWFrZWQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gZGV0YWlsLiBPbmNlIHdlIHN0YXJ0IHJlbGVhc2luZyBEZXZUb29scyBpbiBsb2Nrc3RlcCB3aXRoIFJlYWN0LCB3ZVxuICAgICAgICAvLyBzaG91bGQgaW1wb3J0IGEgZnVuY3Rpb24gZnJvbSB0aGUgcmVjb25jaWxlciBpbnN0ZWFkLlxuXG4gICAgICAgIHZhciBQbGFjZW1lbnQgPSAyO1xuICAgICAgICB2YXIgSHlkcmF0aW5nID0gNDA5NjtcblxuICAgICAgICBpZiAoKG5vZGUuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IDApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgICAvLyBpZiB0aGF0IG9uZSBpcyBzdGlsbCBtb3VudGVkLlxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgICBuZXh0Tm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAgIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIFJlYWN0IGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5qc1xuICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHdlIHVwZGF0ZWQgUmVhY3QgdG8gaW5qZWN0IHRoaXMgZnVuY3Rpb24gZGlyZWN0bHkgKHZzIGp1c3QgaW5kaXJlY3RseSB2aWEgZmluZERPTU5vZGUpLlxuICAvLyBCRUdJTiBjb3BpZWQgY29kZVxuXG5cbiAgZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKSB7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgRmliZXIgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuICAgICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gICAgdmFyIGEgPSBmaWJlcjtcbiAgICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG4gICAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuXG4gICAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgKyAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIiArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgICAvLyB1bm1vdW50ZWQuXG5cblxuICAgIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuICAgIHJldHVybiBhbHRlcm5hdGU7XG4gIH0gLy8gRU5EIGNvcGllZCBjb2RlXG5cblxuICBmdW5jdGlvbiBwcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZShpZCwgcGF0aCkge1xuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpKSB7XG4gICAgICB3aW5kb3cuJGF0dHJpYnV0ZSA9IE9iamVjdCh1dGlsc1tcImpcIiAvKiBnZXRJbk9iamVjdCAqL10pKG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVWaWV3RWxlbWVudFNvdXJjZShpZCkge1xuICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIEZpYmVyIHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudFR5cGUgPSBmaWJlci5lbGVtZW50VHlwZSxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHR5cGUgPSB0eXBlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBnbG9iYWwuJHR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiR0eXBlID0gZWxlbWVudFR5cGUgIT0gbnVsbCAmJiBlbGVtZW50VHlwZS50eXBlICE9IG51bGwgPyBlbGVtZW50VHlwZS50eXBlIDogdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGdsb2JhbC4kdHlwZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpYmVyVG9TZXJpYWxpemVkRWxlbWVudChmaWJlcikge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ0Fub255bW91cycsXG4gICAgICBpZDogZ2V0RmliZXJJRFRocm93cyhmaWJlciksXG4gICAgICBrZXk6IGZpYmVyLmtleSxcbiAgICAgIHR5cGU6IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE93bmVyc0xpc3QoaWQpIHtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfZGVidWdPd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIHZhciBvd25lcnMgPSBbZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KGZpYmVyKV07XG5cbiAgICBpZiAoX2RlYnVnT3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IF9kZWJ1Z093bmVyO1xuXG4gICAgICB3aGlsZSAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgb3duZXJzLnVuc2hpZnQoZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KG93bmVyKSk7XG4gICAgICAgIG93bmVyID0gb3duZXIuX2RlYnVnT3duZXIgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3duZXJzO1xuICB9IC8vIEZhc3QgcGF0aCBwcm9wcyBsb29rdXAgZm9yIFJlYWN0IE5hdGl2ZSBzdHlsZSBlZGl0b3IuXG4gIC8vIENvdWxkIHVzZSBpbnNwZWN0RWxlbWVudFJhdygpIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgc2hhbGxvdyByZW5kZXJpbmcgaG9va3MgY29tcG9uZW50cyxcbiAgLy8gYW5kIGNvdWxkIGFsc28gbWVzcyB3aXRoIG1lbW9pemF0aW9uLlxuXG5cbiAgZnVuY3Rpb24gZ2V0SW5zdGFuY2VBbmRTdHlsZShpZCkge1xuICAgIHZhciBpbnN0YW5jZSA9IG51bGw7XG4gICAgdmFyIHN0eWxlID0gbnVsbDtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKGZpYmVyLm1lbW9pemVkUHJvcHMgIT09IG51bGwpIHtcbiAgICAgICAgc3R5bGUgPSBmaWJlci5tZW1vaXplZFByb3BzLnN0eWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICBzdHlsZTogc3R5bGVcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcnJvckJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVhcmVzdEVycm9yQm91bmRhcnlJRChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNFcnJvckJvdW5kYXJ5KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEZpYmVySURVbnNhZmUocGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50UmF3KGlkKSB7XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX2RlYnVnT3duZXIgPSBmaWJlci5fZGVidWdPd25lcixcbiAgICAgICAgX2RlYnVnU291cmNlID0gZmliZXIuX2RlYnVnU291cmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBmaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgIGtleSA9IGZpYmVyLmtleSxcbiAgICAgICAgbWVtb2l6ZWRQcm9wcyA9IGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIG1lbW9pemVkU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBmaWJlci5kZXBlbmRlbmNpZXMsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcik7XG4gICAgdmFyIHVzZXNIb29rcyA9ICh0YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50IHx8IHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCB8fCB0YWcgPT09IEZvcndhcmRSZWYpICYmICghIW1lbW9pemVkU3RhdGUgfHwgISFkZXBlbmRlbmNpZXMpOyAvLyBUT0RPIFNob3cgY3VzdG9tIFVJIGZvciBDYWNoZSBsaWtlIHdlIGRvIGZvciBTdXNwZW5zZVxuICAgIC8vIEZvciBub3csIGp1c3QgaGlkZSBzdGF0ZSBkYXRhIGVudGlyZWx5IHNpbmNlIGl0J3Mgbm90IG1lYW50IHRvIGJlIGluc3BlY3RlZC5cblxuICAgIHZhciBzaG93U3RhdGUgPSAhdXNlc0hvb2tzICYmIHRhZyAhPT0gQ2FjaGVDb21wb25lbnQ7XG4gICAgdmFyIHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuICAgIHZhciBjYW5WaWV3U291cmNlID0gZmFsc2U7XG4gICAgdmFyIGNvbnRleHQgPSBudWxsO1xuXG4gICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgdGFnID09PSBGdW5jdGlvbkNvbXBvbmVudCB8fCB0YWcgPT09IEluY29tcGxldGVDbGFzc0NvbXBvbmVudCB8fCB0YWcgPT09IEluZGV0ZXJtaW5hdGVDb21wb25lbnQgfHwgdGFnID09PSBNZW1vQ29tcG9uZW50IHx8IHRhZyA9PT0gRm9yd2FyZFJlZiB8fCB0YWcgPT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgIGNhblZpZXdTb3VyY2UgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhdGVOb2RlICYmIHN0YXRlTm9kZS5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc2hvdyBhbiBlbXB0eSBjb250ZXh0IG9iamVjdCBmb3IgY2xhc3MgY29tcG9uZW50cyB0aGF0IGRvbid0IHVzZSB0aGUgY29udGV4dCBBUEkuXG4gICAgICAgIHZhciBzaG91bGRIaWRlQ29udGV4dCA9IGVsZW1lbnRUeXBlID09PSB0eXBlc1tcImVcIiAvKiBFbGVtZW50VHlwZUNsYXNzICovXSAmJiAhKHR5cGUuY29udGV4dFR5cGVzIHx8IHR5cGUuY29udGV4dFR5cGUpO1xuXG4gICAgICAgIGlmICghc2hvdWxkSGlkZUNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0ID0gc3RhdGVOb2RlLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVTeW1ib2wgPT09IFJlYWN0U3ltYm9sc1tcImNcIiAvKiBDT05URVhUX05VTUJFUiAqL10gfHwgdHlwZVN5bWJvbCA9PT0gUmVhY3RTeW1ib2xzW1wiZFwiIC8qIENPTlRFWFRfU1lNQk9MX1NUUklORyAqL10pIHtcbiAgICAgIC8vIDE2LjMtMTYuNSByZWFkIGZyb20gXCJ0eXBlXCIgYmVjYXVzZSB0aGUgQ29uc3VtZXIgaXMgdGhlIGFjdHVhbCBjb250ZXh0IG9iamVjdC5cbiAgICAgIC8vIDE2LjYrIHNob3VsZCByZWFkIGZyb20gXCJ0eXBlLl9jb250ZXh0XCIgYmVjYXVzZSBDb25zdW1lciBjYW4gYmUgZGlmZmVyZW50IChpbiBERVYpLlxuICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBnZXREaXNwbGF5TmFtZUZvckZpYmVyKClcbiAgICAgIHZhciBjb25zdW1lclJlc29sdmVkQ29udGV4dCA9IHR5cGUuX2NvbnRleHQgfHwgdHlwZTsgLy8gR2xvYmFsIGNvbnRleHQgdmFsdWUuXG5cbiAgICAgIGNvbnRleHQgPSBjb25zdW1lclJlc29sdmVkQ29udGV4dC5fY3VycmVudFZhbHVlIHx8IG51bGw7IC8vIExvb2sgZm9yIG92ZXJyaWRkZW4gdmFsdWUuXG5cbiAgICAgIHZhciBfY3VycmVudCA9IGZpYmVyLnJldHVybjtcblxuICAgICAgd2hpbGUgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjdXJyZW50VHlwZSA9IF9jdXJyZW50LnR5cGU7XG4gICAgICAgIHZhciBjdXJyZW50VHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2woY3VycmVudFR5cGUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50VHlwZVN5bWJvbCA9PT0gUmVhY3RTeW1ib2xzW1wiblwiIC8qIFBST1ZJREVSX05VTUJFUiAqL10gfHwgY3VycmVudFR5cGVTeW1ib2wgPT09IFJlYWN0U3ltYm9sc1tcIm9cIiAvKiBQUk9WSURFUl9TWU1CT0xfU1RSSU5HICovXSkge1xuICAgICAgICAgIC8vIDE2LjMuMCBleHBvc2VkIHRoZSBjb250ZXh0IG9iamVjdCBhcyBcImNvbnRleHRcIlxuICAgICAgICAgIC8vIFBSICMxMjUwMSBjaGFuZ2VkIGl0IHRvIFwiX2NvbnRleHRcIiBmb3IgMTYuMy4xK1xuICAgICAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggZ2V0RGlzcGxheU5hbWVGb3JGaWJlcigpXG4gICAgICAgICAgdmFyIHByb3ZpZGVyUmVzb2x2ZWRDb250ZXh0ID0gY3VycmVudFR5cGUuX2NvbnRleHQgfHwgY3VycmVudFR5cGUuY29udGV4dDtcblxuICAgICAgICAgIGlmIChwcm92aWRlclJlc29sdmVkQ29udGV4dCA9PT0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBfY3VycmVudC5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2N1cnJlbnQgPSBfY3VycmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0xlZ2FjeUNvbnRleHQgPSBmYWxzZTtcblxuICAgIGlmIChjb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICBoYXNMZWdhY3lDb250ZXh0ID0gISF0eXBlLmNvbnRleHRUeXBlczsgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IGxvZ2ljIGZvciBjb250ZXh0LCB3cmFwIGluIGEgdmFsdWUgb2JqZWN0LlxuICAgICAgLy8gT3RoZXJ3aXNlIHNpbXBsZSB2YWx1ZXMgKGUuZy4gc3RyaW5ncywgYm9vbGVhbnMpIGJlY29tZSBoYXJkZXIgdG8gaGFuZGxlLlxuXG4gICAgICBjb250ZXh0ID0ge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgb3duZXJzID0gbnVsbDtcblxuICAgIGlmIChfZGVidWdPd25lcikge1xuICAgICAgb3duZXJzID0gW107XG4gICAgICB2YXIgb3duZXIgPSBfZGVidWdPd25lcjtcblxuICAgICAgd2hpbGUgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIG93bmVycy5wdXNoKGZpYmVyVG9TZXJpYWxpemVkRWxlbWVudChvd25lcikpO1xuICAgICAgICBvd25lciA9IG93bmVyLl9kZWJ1Z093bmVyIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgbWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICB2YXIgaG9va3MgPSBudWxsO1xuXG4gICAgaWYgKHVzZXNIb29rcykge1xuICAgICAgdmFyIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTsgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZSBhbGwgY29uc29sZSBsb2dnaW5nIGJlZm9yZSByZS1ydW5uaW5nIHRoZSBob29rLlxuXG4gICAgICBmb3IgKHZhciBtZXRob2QgaW4gY29uc29sZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXSA9IGNvbnNvbGVbbWV0aG9kXTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgICAgICBjb25zb2xlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhvb2tzID0gT2JqZWN0KHJlYWN0X2RlYnVnX3Rvb2xzW1wiaW5zcGVjdEhvb2tzT2ZGaWJlclwiXSkoZmliZXIsIHJlbmRlcmVyLmN1cnJlbnREaXNwYXRjaGVyUmVmLCB0cnVlIC8vIEluY2x1ZGUgc291cmNlIGxvY2F0aW9uIGluZm8gZm9yIGhvb2tzXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbnNvbGUgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgZm9yICh2YXIgX21ldGhvZCBpbiBvcmlnaW5hbENvbnNvbGVNZXRob2RzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAgICAgY29uc29sZVtfbWV0aG9kXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbX21ldGhvZF07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcm9vdFR5cGUgPSBudWxsO1xuICAgIHZhciBjdXJyZW50ID0gZmliZXI7XG5cbiAgICB3aGlsZSAoY3VycmVudC5yZXR1cm4gIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmliZXJSb290ID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoZmliZXJSb290ICE9IG51bGwgJiYgZmliZXJSb290Ll9kZWJ1Z1Jvb3RUeXBlICE9PSBudWxsKSB7XG4gICAgICByb290VHlwZSA9IGZpYmVyUm9vdC5fZGVidWdSb290VHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3JzID0gZmliZXJJRFRvRXJyb3JzTWFwLmdldChpZCkgfHwgbmV3IE1hcCgpO1xuICAgIHZhciB3YXJuaW5ncyA9IGZpYmVySURUb1dhcm5pbmdzTWFwLmdldChpZCkgfHwgbmV3IE1hcCgpO1xuICAgIHZhciBpc0Vycm9yZWQgPSBmYWxzZTtcbiAgICB2YXIgdGFyZ2V0RXJyb3JCb3VuZGFyeUlEO1xuXG4gICAgaWYgKGlzRXJyb3JCb3VuZGFyeShmaWJlcikpIHtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGluc3BlY3RlZCBlbGVtZW50IGlzIGFuIGVycm9yIGJvdW5kYXJ5LFxuICAgICAgLy8gZWl0aGVyIHRoYXQgd2Ugd2FudCB0byB1c2UgaXQgdG8gdG9nZ2xlIG9mZiBlcnJvciBzdGF0ZVxuICAgICAgLy8gb3IgdGhhdCB3ZSBhbGxvdyB0byBmb3JjZSBlcnJvciBzdGF0ZSBvbiBpdCBpZiBpdCdzIHdpdGhpbiBhbm90aGVyXG4gICAgICAvLyBlcnJvciBib3VuZGFyeVxuICAgICAgLy9cbiAgICAgIC8vIFRPRE86IFRoaXMgZmxhZyBpcyBhIGxlYWtlZCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIE9uY2Ugd2Ugc3RhcnRcbiAgICAgIC8vIHJlbGVhc2luZyBEZXZUb29scyBpbiBsb2Nrc3RlcCB3aXRoIFJlYWN0LCB3ZSBzaG91bGQgaW1wb3J0IGEgZnVuY3Rpb25cbiAgICAgIC8vIGZyb20gdGhlIHJlY29uY2lsZXIgaW5zdGVhZC5cbiAgICAgIHZhciBEaWRDYXB0dXJlID0gMTI4O1xuICAgICAgaXNFcnJvcmVkID0gKGZpYmVyLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IDAgfHwgZm9yY2VFcnJvckZvckZpYmVySURzLmdldChpZCkgPT09IHRydWU7XG4gICAgICB0YXJnZXRFcnJvckJvdW5kYXJ5SUQgPSBpc0Vycm9yZWQgPyBpZCA6IGdldE5lYXJlc3RFcnJvckJvdW5kYXJ5SUQoZmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRFcnJvckJvdW5kYXJ5SUQgPSBnZXROZWFyZXN0RXJyb3JCb3VuZGFyeUlEKGZpYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2lucyA9IHtcbiAgICAgIHN0eWxleDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoRGV2VG9vbHNGZWF0dXJlRmxhZ3NfY29yZV9vc3NbXCJiXCIgLyogZW5hYmxlU3R5bGVYRmVhdHVyZXMgKi9dKSB7XG4gICAgICBpZiAobWVtb2l6ZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgneHN0eWxlJykpIHtcbiAgICAgICAgcGx1Z2lucy5zdHlsZXggPSBnZXRTdHlsZVhEYXRhKG1lbW9pemVkUHJvcHMueHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGVkaXRhYmxlIGhvb2tzIGFuZCBmdW5jdGlvbiBwcm9wcz9cbiAgICAgIGNhbkVkaXRIb29rczogdHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHM6IHR5cGVvZiBvdmVycmlkZVByb3BzID09PSAnZnVuY3Rpb24nLFxuICAgICAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGFkdmFuY2VkIGVkaXRpbmcgaW50ZXJmYWNlP1xuICAgICAgY2FuRWRpdEhvb2tzQW5kRGVsZXRlUGF0aHM6IHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPT09ICdmdW5jdGlvbicsXG4gICAgICBjYW5FZGl0SG9va3NBbmRSZW5hbWVQYXRoczogdHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzRGVsZXRlUGF0aHM6IHR5cGVvZiBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzUmVuYW1lUGF0aHM6IHR5cGVvZiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhblRvZ2dsZUVycm9yOiBzdXBwb3J0c1RvZ2dsaW5nRXJyb3IgJiYgdGFyZ2V0RXJyb3JCb3VuZGFyeUlEICE9IG51bGwsXG4gICAgICAvLyBJcyB0aGlzIGVycm9yIGJvdW5kYXJ5IGluIGVycm9yIHN0YXRlLlxuICAgICAgaXNFcnJvcmVkOiBpc0Vycm9yZWQsXG4gICAgICB0YXJnZXRFcnJvckJvdW5kYXJ5SUQ6IHRhcmdldEVycm9yQm91bmRhcnlJRCxcbiAgICAgIGNhblRvZ2dsZVN1c3BlbnNlOiBzdXBwb3J0c1RvZ2dsaW5nU3VzcGVuc2UgJiYgKCAvLyBJZiBpdCdzIHNob3dpbmcgdGhlIHJlYWwgY29udGVudCwgd2UgY2FuIGFsd2F5cyBmbGlwIGZhbGxiYWNrLlxuICAgICAgIWlzVGltZWRPdXRTdXNwZW5zZSB8fCAvLyBJZiBpdCdzIHNob3dpbmcgZmFsbGJhY2sgYmVjYXVzZSB3ZSBwcmV2aW91c2x5IGZvcmNlZCBpdCB0byxcbiAgICAgIC8vIGFsbG93IHRvZ2dsaW5nIGl0IGJhY2sgdG8gcmVtb3ZlIHRoZSBmYWxsYmFjayBvdmVycmlkZS5cbiAgICAgIGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5oYXMoaWQpKSxcbiAgICAgIC8vIENhbiB2aWV3IGNvbXBvbmVudCBzb3VyY2UgbG9jYXRpb24uXG4gICAgICBjYW5WaWV3U291cmNlOiBjYW5WaWV3U291cmNlLFxuICAgICAgLy8gRG9lcyB0aGUgY29tcG9uZW50IGhhdmUgbGVnYWN5IGNvbnRleHQgYXR0YWNoZWQgdG8gaXQuXG4gICAgICBoYXNMZWdhY3lDb250ZXh0OiBoYXNMZWdhY3lDb250ZXh0LFxuICAgICAga2V5OiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGwsXG4gICAgICBkaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlciksXG4gICAgICB0eXBlOiBlbGVtZW50VHlwZSxcbiAgICAgIC8vIEluc3BlY3RhYmxlIHByb3BlcnRpZXMuXG4gICAgICAvLyBUT0RPIFJldmlldyBzYW5pdGl6YXRpb24gYXBwcm9hY2ggZm9yIHRoZSBiZWxvdyBpbnNwZWN0YWJsZSB2YWx1ZXMuXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgaG9va3M6IGhvb2tzLFxuICAgICAgcHJvcHM6IG1lbW9pemVkUHJvcHMsXG4gICAgICBzdGF0ZTogc2hvd1N0YXRlID8gbWVtb2l6ZWRTdGF0ZSA6IG51bGwsXG4gICAgICBlcnJvcnM6IEFycmF5LmZyb20oZXJyb3JzLmVudHJpZXMoKSksXG4gICAgICB3YXJuaW5nczogQXJyYXkuZnJvbSh3YXJuaW5ncy5lbnRyaWVzKCkpLFxuICAgICAgLy8gTGlzdCBvZiBvd25lcnNcbiAgICAgIG93bmVyczogb3duZXJzLFxuICAgICAgLy8gTG9jYXRpb24gb2YgY29tcG9uZW50IGluIHNvdXJjZSBjb2RlLlxuICAgICAgc291cmNlOiBfZGVidWdTb3VyY2UgfHwgbnVsbCxcbiAgICAgIHJvb3RUeXBlOiByb290VHlwZSxcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IHJlbmRlcmVyLnJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgICByZW5kZXJlclZlcnNpb246IHJlbmRlcmVyLnZlcnNpb24sXG4gICAgICBwbHVnaW5zOiBwbHVnaW5zXG4gICAgfTtcbiAgfVxuXG4gIHZhciBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ID0gbnVsbDtcbiAgdmFyIGhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkID0gZmFsc2U7XG4gIHZhciBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkge1xuICAgIHJldHVybiBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQuaWQgPT09IGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50Q3VycmVudChpZCkge1xuICAgIHJldHVybiBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpICYmICFoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZDtcbiAgfSAvLyBUcmFjayB0aGUgaW50ZXJzZWN0aW9uIG9mIGN1cnJlbnRseSBpbnNwZWN0ZWQgcGF0aHMsXG4gIC8vIHNvIHRoYXQgd2UgY2FuIHNlbmQgdGhlaXIgZGF0YSBhbG9uZyBpZiB0aGUgZWxlbWVudCBpcyByZS1yZW5kZXJlZC5cblxuXG4gIGZ1bmN0aW9uIG1lcmdlSW5zcGVjdGVkUGF0aHMocGF0aCkge1xuICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5SW5zcGVjdGVkUGF0aHM7XG4gICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghY3VycmVudFtrZXldKSB7XG4gICAgICAgIGN1cnJlbnRba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSXNQYXRoQWxsb3dlZChrZXksIHNlY29uZGFyeUNhdGVnb3J5KSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoZWxwcyBwcmV2ZW50IHByZXZpb3VzbHktaW5zcGVjdGVkIHBhdGhzIGZyb20gYmVpbmcgZGVoeWRyYXRlZCBpbiB1cGRhdGVzLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIGF2b2lkIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSB3aGVyZSBleHBhbmRlZCB0b2dnbGVzIGNvbGxhcHNlIG9uIHVwZGF0ZS5cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXRoQWxsb3dlZChwYXRoKSB7XG4gICAgICBzd2l0Y2ggKHNlY29uZGFyeUNhdGVnb3J5KSB7XG4gICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIE5ldmVyIGRlaHlkcmF0ZSB0aGUgXCJob29rc1wiIG9iamVjdCBhdCB0aGUgdG9wIGxldmVscy5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMl0gPT09ICdob29rU291cmNlJyAmJiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdmaWxlTmFtZScpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHByZXNlcnZlIHRoZSBmdWxsIGZpbGUgbmFtZSAoVVJMKSBmb3IgaG9vayBzb3VyY2VzXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSB1c2VyIGhhcyBlbmFibGVkIHRoZSBuYW1lZCBob29rcyBmZWF0dXJlLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBmcm9udGVuZCBtYXkgZW5kIHVwIHdpdGggYSBwYXJ0aWFsIFVSTCB3aGljaCBpdCBjYW4ndCBsb2FkLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ3N1Ykhvb2tzJyB8fCBwYXRoW3BhdGgubGVuZ3RoIC0gMl0gPT09ICdzdWJIb29rcycpIHtcbiAgICAgICAgICAgIC8vIERlaHlkcmF0aW5nIHRoZSAnc3ViSG9va3MnIHByb3BlcnR5IG1ha2VzIHRoZSBIb29rc1RyZWUgVUkgYSBsb3QgbW9yZSBjb21wbGljYXRlZCxcbiAgICAgICAgICAgIC8vIHNvIGl0J3MgZWFzaWVzdCBmb3Igbm93IGlmIHdlIGp1c3QgZG9uJ3QgYnJlYWsgb24gdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBhbHdheXMgZGVoeWRyYXRlIGEgbGV2ZWwgZGVlcGVyIChpbiB0aGUgdmFsdWUgb2JqZWN0KS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0ga2V5ID09PSBudWxsID8gY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgOiBjdXJyZW50bHlJbnNwZWN0ZWRQYXRoc1trZXldO1xuXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aFtpXV07XG5cbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZEVsZW1lbnQoaW5zcGVjdGVkRWxlbWVudCkge1xuICAgIHZhciBob29rcyA9IGluc3BlY3RlZEVsZW1lbnQuaG9va3MsXG4gICAgICAgIGlkID0gaW5zcGVjdGVkRWxlbWVudC5pZCxcbiAgICAgICAgcHJvcHMgPSBpbnNwZWN0ZWRFbGVtZW50LnByb3BzO1xuICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIEZpYmVyIHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudFR5cGUgPSBmaWJlci5lbGVtZW50VHlwZSxcbiAgICAgICAgc3RhdGVOb2RlID0gZmliZXIuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiRyID0gc3RhdGVOb2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiRyID0ge1xuICAgICAgICAgIGhvb2tzOiBob29rcyxcbiAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgaG9va3M6IGhvb2tzLFxuICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICB0eXBlOiB0eXBlLnJlbmRlclxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgaG9va3M6IGhvb2tzLFxuICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICB0eXBlOiBlbGVtZW50VHlwZSAhPSBudWxsICYmIGVsZW1lbnRUeXBlLnR5cGUgIT0gbnVsbCA/IGVsZW1lbnRUeXBlLnR5cGUgOiB0eXBlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBnbG9iYWwuJHIgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9yZUFzR2xvYmFsKGlkLCBwYXRoLCBjb3VudCkge1xuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBPYmplY3QodXRpbHNbXCJqXCIgLyogZ2V0SW5PYmplY3QgKi9dKShtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LCBwYXRoKTtcbiAgICAgIHZhciBrZXkgPSBcIiRyZWFjdFRlbXBcIi5jb25jYXQoY291bnQpO1xuICAgICAgd2luZG93W2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VyaWFsaXplZEVsZW1lbnRWYWx1ZUJ5UGF0aChpZCwgcGF0aCkge1xuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpKSB7XG4gICAgICB2YXIgdmFsdWVUb0NvcHkgPSBPYmplY3QodXRpbHNbXCJqXCIgLyogZ2V0SW5PYmplY3QgKi9dKShtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LCBwYXRoKTtcbiAgICAgIHJldHVybiBPYmplY3QoYmFja2VuZF91dGlsc1tcImxcIiAvKiBzZXJpYWxpemVUb1N0cmluZyAqL10pKHZhbHVlVG9Db3B5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0RWxlbWVudChyZXF1ZXN0SUQsIGlkLCBwYXRoLCBmb3JjZUZ1bGxEYXRhKSB7XG4gICAgaWYgKHBhdGggIT09IG51bGwpIHtcbiAgICAgIG1lcmdlSW5zcGVjdGVkUGF0aHMocGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkgJiYgIWZvcmNlRnVsbERhdGEpIHtcbiAgICAgIGlmICghaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQpIHtcbiAgICAgICAgaWYgKHBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgc2Vjb25kYXJ5Q2F0ZWdvcnkgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKHBhdGhbMF0gPT09ICdob29rcycpIHtcbiAgICAgICAgICAgIHNlY29uZGFyeUNhdGVnb3J5ID0gJ2hvb2tzJztcbiAgICAgICAgICB9IC8vIElmIHRoaXMgZWxlbWVudCBoYXMgbm90IGJlZW4gdXBkYXRlZCBzaW5jZSBpdCB3YXMgbGFzdCBpbnNwZWN0ZWQsXG4gICAgICAgICAgLy8gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBzdWJzZXQgb2YgZGF0YSBpbiB0aGUgbmV3bHktaW5zcGVjdGVkIHBhdGguXG5cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgICAgICB0eXBlOiAnaHlkcmF0ZWQtcGF0aCcsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgdmFsdWU6IE9iamVjdChiYWNrZW5kX3V0aWxzW1wiYVwiIC8qIGNsZWFuRm9yQnJpZGdlICovXSkoT2JqZWN0KHV0aWxzW1wialwiIC8qIGdldEluT2JqZWN0ICovXSkobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCwgcGF0aCksIGNyZWF0ZUlzUGF0aEFsbG93ZWQobnVsbCwgc2Vjb25kYXJ5Q2F0ZWdvcnkpLCBwYXRoKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBub3QgYmVlbiB1cGRhdGVkIHNpbmNlIGl0IHdhcyBsYXN0IGluc3BlY3RlZCwgd2UgZG9uJ3QgbmVlZCB0byByZXR1cm4gaXQuXG4gICAgICAgICAgLy8gSW5zdGVhZCB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIElEIHRvIGluZGljYXRlIHRoYXQgaXQgaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgICAgICB0eXBlOiAnbm8tY2hhbmdlJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgPSB7fTtcbiAgICB9XG5cbiAgICBoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoZSBlcnJvciBuYW1lIGlzIHN5bmNlZCB3aXRoIFJlYWN0RGVidWdIb29rc1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdSZWFjdERlYnVnVG9vbHNSZW5kZXJFcnJvcicpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnRXJyb3IgcmVuZGVyaW5nIGluc3BlY3RlZCBlbGVtZW50Lic7XG4gICAgICAgIHZhciBzdGFjazsgLy8gTG9nIGVycm9yICYgY2F1c2UgZm9yIHVzZXIgdG8gZGVidWdcblxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UgKyAnXFxuXFxuJywgZXJyb3IpO1xuXG4gICAgICAgIGlmIChlcnJvci5jYXVzZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9maWJlcjQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfZmliZXI0ICE9IG51bGwgPyBnZXREaXNwbGF5TmFtZUZvckZpYmVyKF9maWJlcjQpIDogbnVsbDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gaW5zcGVjdCBob29rcy4gJyArICdUaGlzIGlzIG1vc3QgbGlrZWx5IGNhdXNlZCBieSBhbiBlcnJvciBpbiBjdXJyZW50IGluc3BlY3RlZCBjb21wb25lbnQnICsgKGNvbXBvbmVudE5hbWUgIT0gbnVsbCA/IFwiOiBcXFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiXFxcIi5cIikgOiAnLicpICsgJ1xcblRoZSBlcnJvciB0aHJvd24gaW4gdGhlIGNvbXBvbmVudCBpczogXFxuXFxuJywgZXJyb3IuY2F1c2UpO1xuXG4gICAgICAgICAgaWYgKGVycm9yLmNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZS5tZXNzYWdlIHx8IG1lc3NhZ2U7XG4gICAgICAgICAgICBzdGFjayA9IGVycm9yLmNhdXNlLnN0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvclR5cGU6ICd1c2VyJyxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgc3RhY2s6IHN0YWNrXG4gICAgICAgIH07XG4gICAgICB9IC8vIHRoZSBlcnJvciBuYW1lIGlzIHN5bmNlZCB3aXRoIFJlYWN0RGVidWdIb29rc1xuXG5cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnUmVhY3REZWJ1Z1Rvb2xzVW5zdXBwb3J0ZWRIb29rRXJyb3InKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvclR5cGU6ICd1bmtub3duLWhvb2snLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgICAgbWVzc2FnZTogJ1Vuc3VwcG9ydGVkIGhvb2sgaW4gdGhlIHJlYWN0LWRlYnVnLXRvb2xzIHBhY2thZ2U6ICcgKyBlcnJvci5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICB9IC8vIExvZyBVbmNhdWdodCBFcnJvclxuXG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluc3BlY3RpbmcgZWxlbWVudC5cXG5cXG4nLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBlcnJvclR5cGU6ICd1bmNhdWdodCcsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICB0eXBlOiAnbm90LWZvdW5kJ1xuICAgICAgfTtcbiAgICB9IC8vIEFueSB0aW1lIGFuIGluc3BlY3RlZCBlbGVtZW50IGhhcyBhbiB1cGRhdGUsXG4gICAgLy8gd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgJHIgdmFsdWUgYXMgd2VsLlxuICAgIC8vIERvIHRoaXMgYmVmb3JlIGRlaHlkcmF0aW9uIChjbGVhbkZvckJyaWRnZSkuXG5cblxuICAgIHVwZGF0ZVNlbGVjdGVkRWxlbWVudChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KTsgLy8gQ2xvbmUgYmVmb3JlIGNsZWFuaW5nIHNvIHRoYXQgd2UgcHJlc2VydmUgdGhlIGZ1bGwgZGF0YS5cbiAgICAvLyBUaGlzIHdpbGwgZW5hYmxlIHVzIHRvIHNlbmQgcGF0Y2hlcyB3aXRob3V0IHJlLWluc3BlY3RpbmcgaWYgaHlkcmF0ZWQgcGF0aHMgYXJlIHJlcXVlc3RlZC5cbiAgICAvLyAoUmVkdWNpbmcgaG93IG9mdGVuIHdlIHNoYWxsb3ctcmVuZGVyIGlzIGEgYmV0dGVyIERYIGZvciBmdW5jdGlvbiBjb21wb25lbnRzIHRoYXQgdXNlIGhvb2tzLilcblxuICAgIHZhciBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudCA9IF9vYmplY3RTcHJlYWQoe30sIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQpOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5jb250ZXh0ID0gT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJhXCIgLyogY2xlYW5Gb3JCcmlkZ2UgKi9dKShjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5jb250ZXh0LCBjcmVhdGVJc1BhdGhBbGxvd2VkKCdjb250ZXh0JywgbnVsbCkpOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuaG9va3MgPSBPYmplY3QoYmFja2VuZF91dGlsc1tcImFcIiAvKiBjbGVhbkZvckJyaWRnZSAqL10pKGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50Lmhvb2tzLCBjcmVhdGVJc1BhdGhBbGxvd2VkKCdob29rcycsICdob29rcycpKTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnByb3BzID0gT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJhXCIgLyogY2xlYW5Gb3JCcmlkZ2UgKi9dKShjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5wcm9wcywgY3JlYXRlSXNQYXRoQWxsb3dlZCgncHJvcHMnLCBudWxsKSk7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5zdGF0ZSA9IE9iamVjdChiYWNrZW5kX3V0aWxzW1wiYVwiIC8qIGNsZWFuRm9yQnJpZGdlICovXSkoY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuc3RhdGUsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ3N0YXRlJywgbnVsbCkpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogaWQsXG4gICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICB0eXBlOiAnZnVsbC1kYXRhJyxcbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICB2YWx1ZTogY2xlYW5lZEluc3BlY3RlZEVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nRWxlbWVudFRvQ29uc29sZShpZCkge1xuICAgIHZhciByZXN1bHQgPSBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRDdXJyZW50KGlkKSA/IG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgOiBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBGaWJlciB3aXRoIGlkIFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN1cHBvcnRzR3JvdXAgPSB0eXBlb2YgY29uc29sZS5ncm91cENvbGxhcHNlZCA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmIChzdXBwb3J0c0dyb3VwKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFwiW0NsaWNrIHRvIGV4cGFuZF0gJWM8XCIuY29uY2F0KHJlc3VsdC5kaXNwbGF5TmFtZSB8fCAnQ29tcG9uZW50JywgXCIgLz5cIiksIC8vIC0tZG9tLXRhZy1uYW1lLWNvbG9yIGlzIHRoZSBDU1MgdmFyaWFibGUgQ2hyb21lIHN0eWxlcyBIVE1MIGVsZW1lbnRzIHdpdGggaW4gdGhlIGNvbnNvbGUuXG4gICAgICAnY29sb3I6IHZhcigtLWRvbS10YWctbmFtZS1jb2xvcik7IGZvbnQtd2VpZ2h0OiBub3JtYWw7Jyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5wcm9wcyAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ1Byb3BzOicsIHJlc3VsdC5wcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5zdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ1N0YXRlOicsIHJlc3VsdC5zdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5ob29rcyAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ0hvb2tzOicsIHJlc3VsdC5ob29rcyk7XG4gICAgfVxuXG4gICAgdmFyIG5hdGl2ZU5vZGVzID0gZmluZE5hdGl2ZU5vZGVzRm9yRmliZXJJRChpZCk7XG5cbiAgICBpZiAobmF0aXZlTm9kZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdOb2RlczonLCBuYXRpdmVOb2Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdMb2NhdGlvbjonLCByZXN1bHQuc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LmNocm9tZSB8fCAvZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdSaWdodC1jbGljayBhbnkgdmFsdWUgdG8gc2F2ZSBpdCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBmb3IgZnVydGhlciBpbnNwZWN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c0dyb3VwKSB7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUGF0aCh0eXBlLCBpZCwgaG9va0lELCBwYXRoKSB7XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IG9mIHByaW1pdGl2ZSBjb250ZXh0IHZhbHVlcyAoZS5nLiBudW1iZXIsIHN0cmluZylcbiAgICAgICAgICAvLyB0aGUgaW5zcGVjdEVsZW1lbnQoKSBtZXRob2Qgd3JhcHMgY29udGV4dCBpbiBhIHt2YWx1ZTogLi4ufSBvYmplY3QuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhdGggKHRoZSBcInZhbHVlXCIpIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgey8vIFNpbXBsZSBjb250ZXh0IHZhbHVlIChub29wKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdCh1dGlsc1tcImNcIiAvKiBkZWxldGVQYXRoSW5PYmplY3QgKi9dKShpbnN0YW5jZS5jb250ZXh0LCBwYXRoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjb21wb25lbnRzIHVzaW5nIGxlZ2FjeSBjb250ZXh0IGFyZSBub3QgZWRpdGFibGVcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGluc3RhbmNlIG9uIHdoaWNoIHRvIGNyZWF0ZSBhIGNsb25lZCwgbXV0YXRlZCBjb250ZXh0LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aChmaWJlciwgaG9va0lELCBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoKGZpYmVyLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJiXCIgLyogY29weVdpdGhEZWxldGUgKi9dKShpbnN0YW5jZS5wcm9wcywgcGF0aCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICBPYmplY3QodXRpbHNbXCJjXCIgLyogZGVsZXRlUGF0aEluT2JqZWN0ICovXSkoaW5zdGFuY2Uuc3RhdGUsIHBhdGgpO1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuYW1lUGF0aCh0eXBlLCBpZCwgaG9va0lELCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IG9mIHByaW1pdGl2ZSBjb250ZXh0IHZhbHVlcyAoZS5nLiBudW1iZXIsIHN0cmluZylcbiAgICAgICAgICAvLyB0aGUgaW5zcGVjdEVsZW1lbnQoKSBtZXRob2Qgd3JhcHMgY29udGV4dCBpbiBhIHt2YWx1ZTogLi4ufSBvYmplY3QuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhdGggKHRoZSBcInZhbHVlXCIpIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgIG9sZFBhdGggPSBvbGRQYXRoLnNsaWNlKDEpO1xuICAgICAgICAgIG5ld1BhdGggPSBuZXdQYXRoLnNsaWNlKDEpO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGlmIChvbGRQYXRoLmxlbmd0aCA9PT0gMCkgey8vIFNpbXBsZSBjb250ZXh0IHZhbHVlIChub29wKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdCh1dGlsc1tcIm5cIiAvKiByZW5hbWVQYXRoSW5PYmplY3QgKi9dKShpbnN0YW5jZS5jb250ZXh0LCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjb21wb25lbnRzIHVzaW5nIGxlZ2FjeSBjb250ZXh0IGFyZSBub3QgZWRpdGFibGVcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGluc3RhbmNlIG9uIHdoaWNoIHRvIGNyZWF0ZSBhIGNsb25lZCwgbXV0YXRlZCBjb250ZXh0LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aChmaWJlciwgaG9va0lELCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gT2JqZWN0KGJhY2tlbmRfdXRpbHNbXCJjXCIgLyogY29weVdpdGhSZW5hbWUgKi9dKShpbnN0YW5jZS5wcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICBPYmplY3QodXRpbHNbXCJuXCIgLyogcmVuYW1lUGF0aEluT2JqZWN0ICovXSkoaW5zdGFuY2Uuc3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGVWYWx1ZUF0UGF0aCh0eXBlLCBpZCwgaG9va0lELCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoQnlJZChpZCk7XG5cbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgIC8vIFRvIHNpbXBsaWZ5IGh5ZHJhdGlvbiBhbmQgZGlzcGxheSBvZiBwcmltaXRpdmUgY29udGV4dCB2YWx1ZXMgKGUuZy4gbnVtYmVyLCBzdHJpbmcpXG4gICAgICAgICAgLy8gdGhlIGluc3BlY3RFbGVtZW50KCkgbWV0aG9kIHdyYXBzIGNvbnRleHQgaW4gYSB7dmFsdWU6IC4uLn0gb2JqZWN0LlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBwYXRoICh0aGUgXCJ2YWx1ZVwiKSBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgY29udGV4dCB2YWx1ZVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3QodXRpbHNbXCJvXCIgLyogc2V0SW5PYmplY3QgKi9dKShpbnN0YW5jZS5jb250ZXh0LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY29tcG9uZW50cyB1c2luZyBsZWdhY3kgY29udGV4dCBhcmUgbm90IGVkaXRhYmxlXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBpbnN0YW5jZSBvbiB3aGljaCB0byBjcmVhdGUgYSBjbG9uZWQsIG11dGF0ZWQgY29udGV4dC5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlSG9va1N0YXRlKGZpYmVyLCBob29rSUQsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IE9iamVjdChiYWNrZW5kX3V0aWxzW1wiZFwiIC8qIGNvcHlXaXRoU2V0ICovXSkoaW5zdGFuY2UucHJvcHMsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlUHJvcHMoZmliZXIsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgT2JqZWN0KHV0aWxzW1wib1wiIC8qIHNldEluT2JqZWN0ICovXSkoaW5zdGFuY2Uuc3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSA9IG51bGw7XG4gIHZhciBkaXNwbGF5TmFtZXNCeVJvb3RJRCA9IG51bGw7XG4gIHZhciBpZFRvQ29udGV4dHNNYXAgPSBudWxsO1xuICB2YXIgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zTWFwID0gbnVsbDtcbiAgdmFyIGluaXRpYWxJRFRvUm9vdE1hcCA9IG51bGw7XG4gIHZhciBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICB2YXIgcHJvZmlsaW5nU3RhcnRUaW1lID0gMDtcbiAgdmFyIHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA9IGZhbHNlO1xuICB2YXIgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGdldFByb2ZpbGluZ0RhdGEoKSB7XG4gICAgdmFyIGRhdGFGb3JSb290cyA9IFtdO1xuXG4gICAgaWYgKHJvb3RUb0NvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcignZ2V0UHJvZmlsaW5nRGF0YSgpIGNhbGxlZCBiZWZvcmUgYW55IHByb2ZpbGluZyBkYXRhIHdhcyByZWNvcmRlZCcpO1xuICAgIH1cblxuICAgIHJvb3RUb0NvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24gKGNvbW1pdFByb2ZpbGluZ01ldGFkYXRhLCByb290SUQpIHtcbiAgICAgIHZhciBjb21taXREYXRhID0gW107XG4gICAgICB2YXIgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zID0gW107XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZXNCeVJvb3RJRCAhPT0gbnVsbCAmJiBkaXNwbGF5TmFtZXNCeVJvb3RJRC5nZXQocm9vdElEKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXAgIT0gbnVsbCkge1xuICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXAuZm9yRWFjaChmdW5jdGlvbiAodHJlZUJhc2VEdXJhdGlvbiwgaWQpIHtcbiAgICAgICAgICBpZiAoaW5pdGlhbElEVG9Sb290TWFwICE9IG51bGwgJiYgaW5pdGlhbElEVG9Sb290TWFwLmdldChpZCkgPT09IHJvb3RJRCkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjb252ZXJ0IG1pbGxpc2Vjb25kcyB0byBtaWNyb3NlY29uZHMgaW4gdGhpcyBjYXNlLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgcHJvZmlsaW5nIHN1bW1hcnkgaXMgSlNPTiBzZXJpYWxpemVkLlxuICAgICAgICAgICAgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zLnB1c2goW2lkLCB0cmVlQmFzZUR1cmF0aW9uXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0UHJvZmlsaW5nRGF0YSwgY29tbWl0SW5kZXgpIHtcbiAgICAgICAgdmFyIGNoYW5nZURlc2NyaXB0aW9ucyA9IGNvbW1pdFByb2ZpbGluZ0RhdGEuY2hhbmdlRGVzY3JpcHRpb25zLFxuICAgICAgICAgICAgZHVyYXRpb25zID0gY29tbWl0UHJvZmlsaW5nRGF0YS5kdXJhdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3REdXJhdGlvbiA9IGNvbW1pdFByb2ZpbGluZ0RhdGEuZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBtYXhBY3R1YWxEdXJhdGlvbiA9IGNvbW1pdFByb2ZpbGluZ0RhdGEubWF4QWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBjb21taXRQcm9maWxpbmdEYXRhLnBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSBjb21taXRQcm9maWxpbmdEYXRhLnByaW9yaXR5TGV2ZWwsXG4gICAgICAgICAgICBjb21taXRUaW1lID0gY29tbWl0UHJvZmlsaW5nRGF0YS5jb21taXRUaW1lLFxuICAgICAgICAgICAgdXBkYXRlcnMgPSBjb21taXRQcm9maWxpbmdEYXRhLnVwZGF0ZXJzO1xuICAgICAgICB2YXIgZmliZXJBY3R1YWxEdXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIGZpYmVyU2VsZkR1cmF0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHVyYXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgdmFyIGZpYmVySUQgPSBkdXJhdGlvbnNbaV07XG4gICAgICAgICAgZmliZXJBY3R1YWxEdXJhdGlvbnMucHVzaChbZmliZXJJRCwgZHVyYXRpb25zW2kgKyAxXV0pO1xuICAgICAgICAgIGZpYmVyU2VsZkR1cmF0aW9ucy5wdXNoKFtmaWJlcklELCBkdXJhdGlvbnNbaSArIDJdXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21taXREYXRhLnB1c2goe1xuICAgICAgICAgIGNoYW5nZURlc2NyaXB0aW9uczogY2hhbmdlRGVzY3JpcHRpb25zICE9PSBudWxsID8gQXJyYXkuZnJvbShjaGFuZ2VEZXNjcmlwdGlvbnMuZW50cmllcygpKSA6IG51bGwsXG4gICAgICAgICAgZHVyYXRpb246IG1heEFjdHVhbER1cmF0aW9uLFxuICAgICAgICAgIGVmZmVjdER1cmF0aW9uOiBlZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBmaWJlckFjdHVhbER1cmF0aW9uczogZmliZXJBY3R1YWxEdXJhdGlvbnMsXG4gICAgICAgICAgZmliZXJTZWxmRHVyYXRpb25zOiBmaWJlclNlbGZEdXJhdGlvbnMsXG4gICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiBwYXNzaXZlRWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICB0aW1lc3RhbXA6IGNvbW1pdFRpbWUsXG4gICAgICAgICAgdXBkYXRlcnM6IHVwZGF0ZXJzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBkYXRhRm9yUm9vdHMucHVzaCh7XG4gICAgICAgIGNvbW1pdERhdGE6IGNvbW1pdERhdGEsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zOiBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMsXG4gICAgICAgIHJvb3RJRDogcm9vdElEXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdGltZWxpbmVEYXRhID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2YgZ2V0VGltZWxpbmVEYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWVsaW5lRGF0YSA9IGdldFRpbWVsaW5lRGF0YSgpO1xuXG4gICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICB2YXIgYmF0Y2hVSURUb01lYXN1cmVzTWFwID0gY3VycmVudFRpbWVsaW5lRGF0YS5iYXRjaFVJRFRvTWVhc3VyZXNNYXAsXG4gICAgICAgICAgICBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzID0gY3VycmVudFRpbWVsaW5lRGF0YS5pbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzLFxuICAgICAgICAgICAgbGFuZVRvTGFiZWxNYXAgPSBjdXJyZW50VGltZWxpbmVEYXRhLmxhbmVUb0xhYmVsTWFwLFxuICAgICAgICAgICAgbGFuZVRvUmVhY3RNZWFzdXJlTWFwID0gY3VycmVudFRpbWVsaW5lRGF0YS5sYW5lVG9SZWFjdE1lYXN1cmVNYXAsXG4gICAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGN1cnJlbnRUaW1lbGluZURhdGEsIFtcImJhdGNoVUlEVG9NZWFzdXJlc01hcFwiLCBcImludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXNcIiwgXCJsYW5lVG9MYWJlbE1hcFwiLCBcImxhbmVUb1JlYWN0TWVhc3VyZU1hcFwiXSk7XG5cbiAgICAgICAgdGltZWxpbmVEYXRhID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN0KSwge30sIHtcbiAgICAgICAgICAvLyBNb3N0IG9mIHRoZSBkYXRhIGlzIHNhZmUgdG8gcGFyc2UgYXMtaXMsXG4gICAgICAgICAgLy8gYnV0IHdlIG5lZWQgdG8gY29udmVydCB0aGUgbmVzdGVkIEFycmF5cyBiYWNrIHRvIE1hcHMuXG4gICAgICAgICAgLy8gTW9zdCBvZiB0aGUgZGF0YSBpcyBzYWZlIHRvIHNlcmlhbGl6ZSBhcy1pcyxcbiAgICAgICAgICAvLyBidXQgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBNYXBzIHRvIG5lc3RlZCBBcnJheXMuXG4gICAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzS2V5VmFsdWVBcnJheTogQXJyYXkuZnJvbShiYXRjaFVJRFRvTWVhc3VyZXNNYXAuZW50cmllcygpKSxcbiAgICAgICAgICBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzOiBBcnJheS5mcm9tKGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMuZW50cmllcygpKSxcbiAgICAgICAgICBsYW5lVG9MYWJlbEtleVZhbHVlQXJyYXk6IEFycmF5LmZyb20obGFuZVRvTGFiZWxNYXAuZW50cmllcygpKSxcbiAgICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVLZXlWYWx1ZUFycmF5OiBBcnJheS5mcm9tKGxhbmVUb1JlYWN0TWVhc3VyZU1hcC5lbnRyaWVzKCkpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhRm9yUm9vdHM6IGRhdGFGb3JSb290cyxcbiAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICB0aW1lbGluZURhdGE6IHRpbWVsaW5lRGF0YVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFByb2ZpbGluZyhzaG91bGRSZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPSBzaG91bGRSZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM7IC8vIENhcHR1cmUgaW5pdGlhbCB2YWx1ZXMgYXMgb2YgdGhlIHRpbWUgcHJvZmlsaW5nIHN0YXJ0cy5cbiAgICAvLyBJdCdzIGltcG9ydGFudCB3ZSBzbmFwc2hvdCBib3RoIHRoZSBkdXJhdGlvbnMgYW5kIHRoZSBpZC10by1yb290IG1hcCxcbiAgICAvLyBzaW5jZSBlaXRoZXIgb2YgdGhlc2UgbWF5IGNoYW5nZSBkdXJpbmcgdGhlIHByb2ZpbGluZyBzZXNzaW9uXG4gICAgLy8gKGUuZy4gd2hlbiBhIGZpYmVyIGlzIHJlLXJlbmRlcmVkIG9yIHdoZW4gYSBmaWJlciBnZXRzIHJlbW92ZWQpLlxuXG4gICAgZGlzcGxheU5hbWVzQnlSb290SUQgPSBuZXcgTWFwKCk7XG4gICAgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zTWFwID0gbmV3IE1hcChpZFRvVHJlZUJhc2VEdXJhdGlvbk1hcCk7XG4gICAgaW5pdGlhbElEVG9Sb290TWFwID0gbmV3IE1hcChpZFRvUm9vdE1hcCk7XG4gICAgaWRUb0NvbnRleHRzTWFwID0gbmV3IE1hcCgpO1xuICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICB2YXIgcm9vdElEID0gZ2V0RmliZXJJRFRocm93cyhyb290LmN1cnJlbnQpO1xuICAgICAgZGlzcGxheU5hbWVzQnlSb290SUQuc2V0KHJvb3RJRCwgZ2V0RGlzcGxheU5hbWVGb3JSb290KHJvb3QuY3VycmVudCkpO1xuXG4gICAgICBpZiAoc2hvdWxkUmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zKSB7XG4gICAgICAgIC8vIFJlY29yZCBhbGwgY29udGV4dHMgYXQgdGhlIHRpbWUgcHJvZmlsaW5nIGlzIHN0YXJ0ZWQuXG4gICAgICAgIC8vIEZpYmVycyBvbmx5IHN0b3JlIHRoZSBjdXJyZW50IGNvbnRleHQgdmFsdWUsXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gdHJhY2sgdGhlbSBzZXBhcmF0ZWx5IGluIG9yZGVyIHRvIGRldGVybWluZSBjaGFuZ2VkIGtleXMuXG4gICAgICAgIGNyYXdsVG9Jbml0aWFsaXplQ29udGV4dHNNYXAocm9vdC5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgcHJvZmlsaW5nU3RhcnRUaW1lID0gcmVuZGVyZXJfZ2V0Q3VycmVudFRpbWUoKTtcbiAgICByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGlmICh0b2dnbGVQcm9maWxpbmdTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wUHJvZmlsaW5nKCkge1xuICAgIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gZmFsc2U7XG5cbiAgICBpZiAodG9nZ2xlUHJvZmlsaW5nU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICB0b2dnbGVQcm9maWxpbmdTdGF0dXMoZmFsc2UpO1xuICAgIH1cbiAgfSAvLyBBdXRvbWF0aWNhbGx5IHN0YXJ0IHByb2ZpbGluZyBzbyB0aGF0IHdlIGRvbid0IG1pc3MgdGltaW5nIGluZm8gZnJvbSBpbml0aWFsIFwibW91bnRcIi5cblxuXG4gIGlmIChPYmplY3Qoc3RvcmFnZVtcImNcIiAvKiBzZXNzaW9uU3RvcmFnZUdldEl0ZW0gKi9dKShjb25zdGFudHNbXCJrXCIgLyogU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVkgKi9dKSA9PT0gJ3RydWUnKSB7XG4gICAgc3RhcnRQcm9maWxpbmcoT2JqZWN0KHN0b3JhZ2VbXCJjXCIgLyogc2Vzc2lvblN0b3JhZ2VHZXRJdGVtICovXSkoY29uc3RhbnRzW1wialwiIC8qIFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkgKi9dKSA9PT0gJ3RydWUnKTtcbiAgfSAvLyBSZWFjdCB3aWxsIHN3aXRjaCBiZXR3ZWVuIHRoZXNlIGltcGxlbWVudGF0aW9ucyBkZXBlbmRpbmcgb24gd2hldGhlclxuICAvLyB3ZSBoYXZlIGFueSBtYW51YWxseSBzdXNwZW5kZWQvZXJyb3JlZC1vdXQgRmliZXJzIG9yIG5vdC5cblxuXG4gIGZ1bmN0aW9uIHNob3VsZEVycm9yRmliZXJBbHdheXNOdWxsKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE1hcCBvZiBpZCBhbmQgaXRzIGZvcmNlIGVycm9yIHN0YXR1czogdHJ1ZSAoZXJyb3IpLCBmYWxzZSAodG9nZ2xlZCBvZmYpLFxuICAvLyBudWxsIChkbyBub3RoaW5nKVxuXG5cbiAgdmFyIGZvcmNlRXJyb3JGb3JGaWJlcklEcyA9IG5ldyBNYXAoKTtcblxuICBmdW5jdGlvbiBzaG91bGRFcnJvckZpYmVyQWNjb3JkaW5nVG9NYXAoZmliZXIpIHtcbiAgICBpZiAodHlwZW9mIHNldEVycm9ySGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBvdmVycmlkZUVycm9yKCkgdG8gbm90IGdldCBjYWxsZWQgZm9yIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG5cbiAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcklEcy5oYXMoaWQpKSB7XG4gICAgICBzdGF0dXMgPSBmb3JjZUVycm9yRm9yRmliZXJJRHMuZ2V0KGlkKTtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gVFJJQ0tZIG92ZXJyaWRlRXJyb3IgYWRkcyBlbnRyaWVzIHRvIHRoaXMgTWFwLFxuICAgICAgICAvLyBzbyBpZGVhbGx5IGl0IHdvdWxkIGJlIHRoZSBtZXRob2QgdGhhdCBjbGVhcnMgdGhlbSB0b28sXG4gICAgICAgIC8vIGJ1dCB0aGF0IHdvdWxkIGJyZWFrIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHRoZSBmZWF0dXJlLFxuICAgICAgICAvLyBzaW5jZSBEZXZUb29scyBuZWVkcyB0byB0ZWxsIFJlYWN0IHRvIGFjdCBkaWZmZXJlbnRseSB0aGFuIGl0IG5vcm1hbGx5IHdvdWxkXG4gICAgICAgIC8vIChkb24ndCBqdXN0IHJlLXJlbmRlciB0aGUgZmFpbGVkIGJvdW5kYXJ5LCBidXQgcmVzZXQgaXRzIGVycm9yZWQgc3RhdGUgdG9vKS5cbiAgICAgICAgLy8gU28gd2UgY2FuIG9ubHkgY2xlYXIgaXQgYWZ0ZXIgdGVsbGluZyBSZWFjdCB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgcHJlbWF0dXJlIGFuZCB3ZSBzaG91bGQgc2NoZWR1bGUgaXQgZm9yIGxhdGVyLFxuICAgICAgICAvLyBzaW5jZSB0aGUgcmVuZGVyIGNvdWxkIGFsd2F5cyBmYWlsIHdpdGhvdXQgY29tbWl0dGluZyB0aGUgdXBkYXRlZCBlcnJvciBib3VuZGFyeSxcbiAgICAgICAgLy8gYnV0IHNpbmNlIHRoaXMgaXMgYSBERVYtb25seSBmZWF0dXJlLCB0aGUgc2ltcGxpY2l0eSBpcyB3b3J0aCB0aGUgdHJhZGUgb2ZmLlxuICAgICAgICBmb3JjZUVycm9yRm9yRmliZXJJRHMuZGVsZXRlKGlkKTtcblxuICAgICAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVySURzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBMYXN0IG92ZXJyaWRlIGlzIGdvbmUuIFN3aXRjaCBSZWFjdCBiYWNrIHRvIGZhc3QgcGF0aC5cbiAgICAgICAgICBzZXRFcnJvckhhbmRsZXIoc2hvdWxkRXJyb3JGaWJlckFsd2F5c051bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlRXJyb3IoaWQsIGZvcmNlRXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIHNldEVycm9ySGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc2NoZWR1bGVVcGRhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb3ZlcnJpZGVFcnJvcigpIHRvIG5vdCBnZXQgY2FsbGVkIGZvciBlYXJsaWVyIFJlYWN0IHZlcnNpb25zLicpO1xuICAgIH1cblxuICAgIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5zZXQoaWQsIGZvcmNlRXJyb3IpO1xuXG4gICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcklEcy5zaXplID09PSAxKSB7XG4gICAgICAvLyBGaXJzdCBvdmVycmlkZSBpcyBhZGRlZC4gU3dpdGNoIFJlYWN0IHRvIHNsb3dlciBwYXRoLlxuICAgICAgc2V0RXJyb3JIYW5kbGVyKHNob3VsZEVycm9yRmliZXJBY2NvcmRpbmdUb01hcCk7XG4gICAgfVxuXG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGUoZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFN1c3BlbmRGaWJlckFsd2F5c0ZhbHNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMgPSBuZXcgU2V0KCk7XG5cbiAgZnVuY3Rpb24gc2hvdWxkU3VzcGVuZEZpYmVyQWNjb3JkaW5nVG9TZXQoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpO1xuICAgIHJldHVybiBtYXliZUlEICE9PSBudWxsICYmIGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5oYXMobWF5YmVJRCk7XG4gIH1cblxuICBmdW5jdGlvbiBvdmVycmlkZVN1c3BlbnNlKGlkLCBmb3JjZUZhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRTdXNwZW5zZUhhbmRsZXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHNjaGVkdWxlVXBkYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG92ZXJyaWRlU3VzcGVuc2UoKSB0byBub3QgZ2V0IGNhbGxlZCBmb3IgZWFybGllciBSZWFjdCB2ZXJzaW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2VGYWxsYmFjaykge1xuICAgICAgZm9yY2VGYWxsYmFja0ZvclN1c3BlbnNlSURzLmFkZChpZCk7XG5cbiAgICAgIGlmIChmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBvdmVycmlkZSBpcyBhZGRlZC4gU3dpdGNoIFJlYWN0IHRvIHNsb3dlciBwYXRoLlxuICAgICAgICBzZXRTdXNwZW5zZUhhbmRsZXIoc2hvdWxkU3VzcGVuZEZpYmVyQWNjb3JkaW5nVG9TZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuZGVsZXRlKGlkKTtcblxuICAgICAgaWYgKGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5zaXplID09PSAwKSB7XG4gICAgICAgIC8vIExhc3Qgb3ZlcnJpZGUgaXMgZ29uZS4gU3dpdGNoIFJlYWN0IGJhY2sgdG8gZmFzdCBwYXRoLlxuICAgICAgICBzZXRTdXNwZW5zZUhhbmRsZXIoc2hvdWxkU3VzcGVuZEZpYmVyQWx3YXlzRmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGZpYmVyICE9IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlKGZpYmVyKTtcbiAgICB9XG4gIH0gLy8gUmVtZW1iZXIgaWYgd2UncmUgdHJ5aW5nIHRvIHJlc3RvcmUgdGhlIHNlbGVjdGlvbiBhZnRlciByZWxvYWQuXG4gIC8vIEluIHRoYXQgY2FzZSwgd2UnbGwgZG8gc29tZSBleHRyYSBjaGVja3MgZm9yIG1hdGNoaW5nIG1vdW50cy5cblxuXG4gIHZhciB0cmFja2VkUGF0aCA9IG51bGw7XG4gIHZhciB0cmFja2VkUGF0aE1hdGNoRmliZXIgPSBudWxsO1xuICB2YXIgdHJhY2tlZFBhdGhNYXRjaERlcHRoID0gLTE7XG4gIHZhciBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldFRyYWNrZWRQYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gbnVsbCkge1xuICAgICAgdHJhY2tlZFBhdGhNYXRjaEZpYmVyID0gbnVsbDtcbiAgICAgIHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCA9IC0xO1xuICAgICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0cmFja2VkUGF0aCA9IHBhdGg7XG4gIH0gLy8gV2UgY2FsbCB0aGlzIGJlZm9yZSB0cmF2ZXJzaW5nIGEgbmV3IG1vdW50LlxuICAvLyBJdCByZW1lbWJlcnMgd2hldGhlciB0aGlzIEZpYmVyIGlzIHRoZSBuZXh0IGJlc3QgbWF0Y2ggZm9yIHRyYWNrZWQgcGF0aC5cbiAgLy8gVGhlIHJldHVybiB2YWx1ZSBzaWduYWxzIHdoZXRoZXIgd2Ugc2hvdWxkIGtlZXAgbWF0Y2hpbmcgc2libGluZ3Mgb3Igbm90LlxuXG5cbiAgZnVuY3Rpb24gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KGZpYmVyKSB7XG4gICAgaWYgKHRyYWNrZWRQYXRoID09PSBudWxsIHx8ICFtaWdodEJlT25UcmFja2VkUGF0aCkge1xuICAgICAgLy8gRmFzdCBwYXRoOiB0aGVyZSdzIG5vdGhpbmcgdG8gdHJhY2sgc28gZG8gbm90aGluZyBhbmQgaWdub3JlIHNpYmxpbmdzLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByZXR1cm5GaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICB2YXIgcmV0dXJuQWx0ZXJuYXRlID0gcmV0dXJuRmliZXIgIT09IG51bGwgPyByZXR1cm5GaWJlci5hbHRlcm5hdGUgOiBudWxsOyAvLyBCeSBub3cgd2Uga25vdyB0aGVyZSdzIHNvbWUgc2VsZWN0aW9uIHRvIHJlc3RvcmUsIGFuZCB0aGlzIGlzIGEgbmV3IEZpYmVyLlxuICAgIC8vIElzIHRoaXMgbmV3bHkgbW91bnRlZCBGaWJlciBhIGRpcmVjdCBjaGlsZCBvZiB0aGUgY3VycmVudCBiZXN0IG1hdGNoP1xuICAgIC8vIChUaGlzIHdpbGwgYWxzbyBiZSB0cnVlIGZvciBuZXcgcm9vdHMgaWYgd2UgaGF2ZW4ndCBtYXRjaGVkIGFueXRoaW5nIHlldC4pXG5cbiAgICBpZiAodHJhY2tlZFBhdGhNYXRjaEZpYmVyID09PSByZXR1cm5GaWJlciB8fCB0cmFja2VkUGF0aE1hdGNoRmliZXIgPT09IHJldHVybkFsdGVybmF0ZSAmJiByZXR1cm5BbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIElzIHRoaXMgdGhlIG5leHQgRmliZXIgd2Ugc2hvdWxkIHNlbGVjdD8gTGV0J3MgY29tcGFyZSB0aGUgZnJhbWVzLlxuICAgICAgdmFyIGFjdHVhbEZyYW1lID0gZ2V0UGF0aEZyYW1lKGZpYmVyKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgIHZhciBleHBlY3RlZEZyYW1lID0gdHJhY2tlZFBhdGhbdHJhY2tlZFBhdGhNYXRjaERlcHRoICsgMV07XG5cbiAgICAgIGlmIChleHBlY3RlZEZyYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBzZWUgYSBmcmFtZSBhdCB0aGUgbmV4dCBkZXB0aC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdHVhbEZyYW1lLmluZGV4ID09PSBleHBlY3RlZEZyYW1lLmluZGV4ICYmIGFjdHVhbEZyYW1lLmtleSA9PT0gZXhwZWN0ZWRGcmFtZS5rZXkgJiYgYWN0dWFsRnJhbWUuZGlzcGxheU5hbWUgPT09IGV4cGVjdGVkRnJhbWUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBvdXIgbmV4dCBtYXRjaC5cbiAgICAgICAgdHJhY2tlZFBhdGhNYXRjaEZpYmVyID0gZmliZXI7XG4gICAgICAgIHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCsrOyAvLyBBcmUgd2Ugb3V0IG9mIGZyYW1lcyB0byBtYXRjaD9cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgICAgaWYgKHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCA9PT0gdHJhY2tlZFBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm90aGluZyB0aGF0IGNhbiBwb3NzaWJseSBtYXRjaCBhZnRlcndhcmRzLlxuICAgICAgICAgIC8vIERvbid0IGNoZWNrIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENoZWNrIHRoZSBjaGlsZHJlbiwgYXMgdGhleSBtaWdodCByZXZlYWwgdGhlIG5leHQgbWF0Y2guXG4gICAgICAgICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSB0cnVlO1xuICAgICAgICB9IC8vIEluIGVpdGhlciBjYXNlLCBzaW5jZSB3ZSBoYXZlIGEgbWF0Y2gsIHdlIGRvbid0IG5lZWRcbiAgICAgICAgLy8gdG8gY2hlY2sgdGhlIHNpYmxpbmdzLiBUaGV5J2xsIG5ldmVyIG1hdGNoLlxuXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gLy8gVGhpcyBGaWJlcidzIHBhcmVudCBpcyBvbiB0aGUgcGF0aCwgYnV0IHRoaXMgRmliZXIgaXRzZWxmIGlzbid0LlxuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBpdHMgY2hpbGRyZW4tLXRoZXkgd29uJ3QgYmUgb24gdGhlIHBhdGggZWl0aGVyLlxuXG5cbiAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlOyAvLyBIb3dldmVyLCBvbmUgb2YgaXRzIHNpYmxpbmdzIG1heSBiZSBvbiB0aGUgcGF0aCBzbyBrZWVwIHNlYXJjaGluZy5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUFmdGVyTW91bnQobWlnaHRTaWJsaW5nc0JlT25UcmFja2VkUGF0aCkge1xuICAgIC8vIHVwZGF0ZVRyYWNrZWRQYXRoU3RhdGVCZWZvcmVNb3VudCgpIHRvbGQgdXMgd2hldGhlciB0byBtYXRjaCBzaWJsaW5ncy5cbiAgICAvLyBOb3cgdGhhdCB3ZSdyZSBlbnRlcmluZyBzaWJsaW5ncywgbGV0J3MgdXNlIHRoYXQgaW5mb3JtYXRpb24uXG4gICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSBtaWdodFNpYmxpbmdzQmVPblRyYWNrZWRQYXRoO1xuICB9IC8vIFJvb3RzIGRvbid0IGhhdmUgYSByZWFsIHBlcnNpc3RlbnQgaWRlbnRpdHkuXG4gIC8vIEEgcm9vdCdzIFwicHNldWRvIGtleVwiIGlzIFwiY2hpbGREaXNwbGF5TmFtZTppbmRleFdpdGhUaGF0TmFtZVwiLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJBcHA6MFwiIG9yLCBpbiBjYXNlIG9mIHNpbWlsYXIgcm9vdHMsIFwiU3Rvcnk6MFwiLCBcIlN0b3J5OjFcIiwgZXRjLlxuICAvLyBXZSB3aWxsIHVzZSB0aGlzIHRvIHRyeSB0byBkaXNhbWJpZ3VhdGUgcm9vdHMgd2hlbiByZXN0b3Jpbmcgc2VsZWN0aW9uIGJldHdlZW4gcmVsb2Fkcy5cblxuXG4gIHZhciByb290UHNldWRvS2V5cyA9IG5ldyBNYXAoKTtcbiAgdmFyIHJvb3REaXNwbGF5TmFtZUNvdW50ZXIgPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gc2V0Um9vdFBzZXVkb0tleShpZCwgZmliZXIpIHtcbiAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lRm9yUm9vdChmaWJlcik7XG4gICAgdmFyIGNvdW50ZXIgPSByb290RGlzcGxheU5hbWVDb3VudGVyLmdldChuYW1lKSB8fCAwO1xuICAgIHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuc2V0KG5hbWUsIGNvdW50ZXIgKyAxKTtcbiAgICB2YXIgcHNldWRvS2V5ID0gXCJcIi5jb25jYXQobmFtZSwgXCI6XCIpLmNvbmNhdChjb3VudGVyKTtcbiAgICByb290UHNldWRvS2V5cy5zZXQoaWQsIHBzZXVkb0tleSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVSb290UHNldWRvS2V5KGlkKSB7XG4gICAgdmFyIHBzZXVkb0tleSA9IHJvb3RQc2V1ZG9LZXlzLmdldChpZCk7XG5cbiAgICBpZiAocHNldWRvS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcm9vdCBwc2V1ZG8ga2V5IHRvIGJlIGtub3duLicpO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gcHNldWRvS2V5LnNsaWNlKDAsIHBzZXVkb0tleS5sYXN0SW5kZXhPZignOicpKTtcbiAgICB2YXIgY291bnRlciA9IHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKGNvdW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBjb3VudGVyIHRvIGJlIGtub3duLicpO1xuICAgIH1cblxuICAgIGlmIChjb3VudGVyID4gMSkge1xuICAgICAgcm9vdERpc3BsYXlOYW1lQ291bnRlci5zZXQobmFtZSwgY291bnRlciAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RGlzcGxheU5hbWVDb3VudGVyLmRlbGV0ZShuYW1lKTtcbiAgICB9XG5cbiAgICByb290UHNldWRvS2V5cy5kZWxldGUoaWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JSb290KGZpYmVyKSB7XG4gICAgdmFyIHByZWZlcnJlZERpc3BsYXlOYW1lID0gbnVsbDtcbiAgICB2YXIgZmFsbGJhY2tEaXNwbGF5TmFtZSA9IG51bGw7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IC8vIEdvIGF0IG1vc3QgdGhyZWUgbGV2ZWxzIGRlZXAgaW50byBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyB3aGlsZSBzZWFyY2hpbmcgZm9yIGEgY2hpbGQgdGhhdCBoYXMgYSBkaXNwbGF5TmFtZS5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoY2hpbGQpO1xuXG4gICAgICBpZiAoZGlzcGxheU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gUHJlZmVyIGRpc3BsYXkgbmFtZXMgdGhhdCB3ZSBnZXQgZnJvbSB1c2VyLWRlZmluZWQgY29tcG9uZW50cy5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBhdm9pZCB1c2luZyBlLmcuICdTdXNwZW5zZScgdW5sZXNzIHdlIGZpbmQgbm90aGluZyBlbHNlLlxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBUaGVyZSdzIGEgZmV3IHVzZXItZGVmaW5lZCB0YWdzLCBidXQgd2UnbGwgcHJlZmVyIHRoZSBvbmVzXG4gICAgICAgICAgLy8gdGhhdCBhcmUgdXN1YWxseSBleHBsaWNpdGx5IG5hbWVkIChmdW5jdGlvbiBvciBjbGFzcyBjb21wb25lbnRzKS5cbiAgICAgICAgICBwcmVmZXJyZWREaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrRGlzcGxheU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICBmYWxsYmFja0Rpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZWZlcnJlZERpc3BsYXlOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmZXJyZWREaXNwbGF5TmFtZSB8fCBmYWxsYmFja0Rpc3BsYXlOYW1lIHx8ICdBbm9ueW1vdXMnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGF0aEZyYW1lKGZpYmVyKSB7XG4gICAgdmFyIGtleSA9IGZpYmVyLmtleTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKTtcbiAgICB2YXIgaW5kZXggPSBmaWJlci5pbmRleDtcblxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAvLyBSb290cyBkb24ndCBoYXZlIGEgcmVhbCBkaXNwbGF5TmFtZSwgaW5kZXgsIG9yIGtleS5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UnbGwgdXNlIHRoZSBwc2V1ZG8ga2V5IChjaGlsZERpc3BsYXlOYW1lOmluZGV4V2l0aFRoYXROYW1lKS5cbiAgICAgICAgdmFyIGlkID0gZ2V0RmliZXJJRFRocm93cyhmaWJlcik7XG4gICAgICAgIHZhciBwc2V1ZG9LZXkgPSByb290UHNldWRvS2V5cy5nZXQoaWQpO1xuXG4gICAgICAgIGlmIChwc2V1ZG9LZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbW91bnRlZCByb290IHRvIGhhdmUga25vd24gcHNldWRvIGtleS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXlOYW1lID0gcHNldWRvS2V5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaXNwbGF5TmFtZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAga2V5OiBrZXksXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xuICB9IC8vIFByb2R1Y2VzIGEgc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIHRoYXQgZG9lcyBhIGJlc3QgZWZmb3J0XG4gIC8vIG9mIGlkZW50aWZ5aW5nIGEgcGFydGljdWxhciBGaWJlciBiZXR3ZWVuIHBhZ2UgcmVsb2Fkcy5cbiAgLy8gVGhlIHJldHVybiBwYXRoIHdpbGwgY29udGFpbiBGaWJlcnMgdGhhdCBhcmUgXCJpbnZpc2libGVcIiB0byB0aGUgc3RvcmVcbiAgLy8gYmVjYXVzZSB0aGVpciBrZXlzIGFuZCBpbmRleGVzIGFyZSBpbXBvcnRhbnQgdG8gcmVzdG9yaW5nIHRoZSBzZWxlY3Rpb24uXG5cblxuICBmdW5jdGlvbiBnZXRQYXRoRm9yRWxlbWVudChpZCkge1xuICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBrZXlQYXRoID0gW107XG5cbiAgICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGtleVBhdGgucHVzaChnZXRQYXRoRnJhbWUoZmliZXIpKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIH1cblxuICAgIGtleVBhdGgucmV2ZXJzZSgpO1xuICAgIHJldHVybiBrZXlQYXRoO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgoKSB7XG4gICAgaWYgKHRyYWNrZWRQYXRoID09PSBudWxsKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIG1hdGNoLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrZWRQYXRoTWF0Y2hGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UgZGlkbid0IGZpbmQgYW55dGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEZpbmQgdGhlIGNsb3Nlc3QgRmliZXIgc3RvcmUgaXMgYXdhcmUgb2YuXG5cblxuICAgIHZhciBmaWJlciA9IHRyYWNrZWRQYXRoTWF0Y2hGaWJlcjtcblxuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCAmJiBzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKSxcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgaXNGdWxsTWF0Y2g6IHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCA9PT0gdHJhY2tlZFBhdGgubGVuZ3RoIC0gMVxuICAgIH07XG4gIH1cblxuICB2YXIgZm9ybWF0UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uIGZvcm1hdFByaW9yaXR5TGV2ZWwocHJpb3JpdHlMZXZlbCkge1xuICAgIGlmIChwcmlvcml0eUxldmVsID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ0ltbWVkaWF0ZSc7XG5cbiAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnVXNlci1CbG9ja2luZyc7XG5cbiAgICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnTm9ybWFsJztcblxuICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdMb3cnO1xuXG4gICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdJZGxlJztcblxuICAgICAgY2FzZSBOb1ByaW9yaXR5OlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0VHJhY2VVcGRhdGVzRW5hYmxlZChpc0VuYWJsZWQpIHtcbiAgICB0cmFjZVVwZGF0ZXNFbmFibGVkID0gaXNFbmFibGVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgIGNsZWFyRXJyb3JzQW5kV2FybmluZ3M6IGNsZWFyRXJyb3JzQW5kV2FybmluZ3MsXG4gICAgY2xlYXJFcnJvcnNGb3JGaWJlcklEOiBjbGVhckVycm9yc0ZvckZpYmVySUQsXG4gICAgY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQ6IGNsZWFyV2FybmluZ3NGb3JGaWJlcklELFxuICAgIGdldFNlcmlhbGl6ZWRFbGVtZW50VmFsdWVCeVBhdGg6IGdldFNlcmlhbGl6ZWRFbGVtZW50VmFsdWVCeVBhdGgsXG4gICAgZGVsZXRlUGF0aDogZGVsZXRlUGF0aCxcbiAgICBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEOiBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklELFxuICAgIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnM6IGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMsXG4gICAgZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGg6IGdldEJlc3RNYXRjaEZvclRyYWNrZWRQYXRoLFxuICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXJJRDogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcklELFxuICAgIGdldEZpYmVyRm9yTmF0aXZlOiBnZXRGaWJlckZvck5hdGl2ZSxcbiAgICBnZXRGaWJlcklERm9yTmF0aXZlOiBnZXRGaWJlcklERm9yTmF0aXZlLFxuICAgIGdldEluc3RhbmNlQW5kU3R5bGU6IGdldEluc3RhbmNlQW5kU3R5bGUsXG4gICAgZ2V0T3duZXJzTGlzdDogZ2V0T3duZXJzTGlzdCxcbiAgICBnZXRQYXRoRm9yRWxlbWVudDogZ2V0UGF0aEZvckVsZW1lbnQsXG4gICAgZ2V0UHJvZmlsaW5nRGF0YTogZ2V0UHJvZmlsaW5nRGF0YSxcbiAgICBoYW5kbGVDb21taXRGaWJlclJvb3Q6IGhhbmRsZUNvbW1pdEZpYmVyUm9vdCxcbiAgICBoYW5kbGVDb21taXRGaWJlclVubW91bnQ6IGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudCxcbiAgICBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290OiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290LFxuICAgIGluc3BlY3RFbGVtZW50OiBpbnNwZWN0RWxlbWVudCxcbiAgICBsb2dFbGVtZW50VG9Db25zb2xlOiBsb2dFbGVtZW50VG9Db25zb2xlLFxuICAgIHBhdGNoQ29uc29sZUZvclN0cmljdE1vZGU6IGJhY2tlbmRfY29uc29sZVtcImRcIiAvKiBwYXRjaEZvclN0cmljdE1vZGUgKi9dLFxuICAgIHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlOiBwcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZSxcbiAgICBwcmVwYXJlVmlld0VsZW1lbnRTb3VyY2U6IHByZXBhcmVWaWV3RWxlbWVudFNvdXJjZSxcbiAgICBvdmVycmlkZUVycm9yOiBvdmVycmlkZUVycm9yLFxuICAgIG92ZXJyaWRlU3VzcGVuc2U6IG92ZXJyaWRlU3VzcGVuc2UsXG4gICAgb3ZlcnJpZGVWYWx1ZUF0UGF0aDogb3ZlcnJpZGVWYWx1ZUF0UGF0aCxcbiAgICByZW5hbWVQYXRoOiByZW5hbWVQYXRoLFxuICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkOiBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkLFxuICAgIHNldFRyYWNrZWRQYXRoOiBzZXRUcmFja2VkUGF0aCxcbiAgICBzdGFydFByb2ZpbGluZzogc3RhcnRQcm9maWxpbmcsXG4gICAgc3RvcFByb2ZpbGluZzogc3RvcFByb2ZpbGluZyxcbiAgICBzdG9yZUFzR2xvYmFsOiBzdG9yZUFzR2xvYmFsLFxuICAgIHVucGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZTogYmFja2VuZF9jb25zb2xlW1wiZlwiIC8qIHVucGF0Y2hGb3JTdHJpY3RNb2RlICovXSxcbiAgICB1cGRhdGVDb21wb25lbnRGaWx0ZXJzOiB1cGRhdGVDb21wb25lbnRGaWx0ZXJzXG4gIH07XG59XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGRlc2NyaWJlRmliZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kOyB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzLmpzXG52YXIgUmVhY3RTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzQ29uc29sZVBhdGNoaW5nLmpzXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBUaGlzIGlzIGEgRGV2VG9vbHMgZm9yayBvZiBzaGFyZWQvQ29uc29sZVBhdGNoaW5nRGV2LlxuLy8gVGhlIHNoYXJlZCBjb25zb2xlIHBhdGNoaW5nIGNvZGUgaXMgREVWLW9ubHkuXG4vLyBXZSBjYW4ndCB1c2UgaXQgc2luY2UgRGV2VG9vbHMgb25seSBzaGlwcyBwcm9kdWN0aW9uIGJ1aWxkcy5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgIHZhciBwcm9wcyA9IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgIGluZm86IHByb3BzLFxuICAgICAgbG9nOiBwcm9wcyxcbiAgICAgIHdhcm46IHByb3BzLFxuICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgfVxuXG4gIGRpc2FibGVkRGVwdGgrKztcbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgZGlzYWJsZWREZXB0aC0tO1xuXG4gIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgbG9nOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgIH0pLFxuICAgICAgaW5mbzogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgfSksXG4gICAgICB3YXJuOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICB9KSxcbiAgICAgIGVycm9yOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgfSksXG4gICAgICBncm91cDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgIH0pLFxuICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICB9KSxcbiAgICAgIGdyb3VwRW5kOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgfSlcbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICB9XG5cbiAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgY29uc29sZS5lcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9EZXZUb29sc0NvbXBvbmVudFN0YWNrRnJhbWUuanNcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBUaGlzIGlzIGEgRGV2VG9vbHMgZm9yayBvZiBSZWFjdENvbXBvbmVudFN0YWNrRnJhbWUuXG4vLyBUaGlzIGZvcmsgZW5hYmxlcyBEZXZUb29scyB0byB1c2UgdGhlIHNhbWUgXCJuYXRpdmVcIiBjb21wb25lbnQgc3RhY2sgZm9ybWF0LFxuLy8gd2hpbGUgc3RpbGwgbWFpbnRhaW5pbmcgc3VwcG9ydCBmb3IgbXVsdGlwbGUgcmVuZGVyZXIgdmVyc2lvbnNcbi8vICh3aGljaCB1c2UgZGlmZmVyZW50IHZhbHVlcyBmb3IgUmVhY3RUeXBlT2ZXb3JrKS5cbiAvLyBUaGUgc2hhcmVkIGNvbnNvbGUgcGF0Y2hpbmcgY29kZSBpcyBERVYtb25seS5cbi8vIFdlIGNhbid0IHVzZSBpdCBzaW5jZSBEZXZUb29scyBvbmx5IHNoaXBzIHByb2R1Y3Rpb24gYnVpbGRzLlxuXG5cbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBvd25lckZuKSB7XG4gIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgfVxuICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxuaWYgKGZhbHNlKSB7IHZhciBQb3NzaWJseVdlYWtNYXA7IH1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0LCBjdXJyZW50RGlzcGF0Y2hlclJlZikge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGZhbHNlKSB7IHZhciBmcmFtZTsgfVxuXG4gIHZhciBjb250cm9sO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHJlZW50cnkgPSB0cnVlOyAvLyBPdmVycmlkZSB0aGUgZGlzcGF0Y2hlciBzbyBlZmZlY3RzIHNjaGVkdWxlZCBieSB0aGlzIHNoYWxsb3cgcmVuZGVyIGFyZSB0aHJvd24gYXdheS5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHVubGlrZSB0aGUgY29kZSB0aGlzIHdhcyBmb3JrZWQgZnJvbSAoaW4gUmVhY3RDb21wb25lbnRTdGFja0ZyYW1lKVxuICAvLyBEZXZUb29scyBzaG91bGQgb3ZlcnJpZGUgdGhlIGRpc3BhdGNoZXIgZXZlbiB3aGVuIERldlRvb2xzIGlzIGNvbXBpbGVkIGluIHByb2R1Y3Rpb24gbW9kZSxcbiAgLy8gYmVjYXVzZSB0aGUgYXBwIGl0c2VsZiBtYXkgYmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSBhbmQgbG9nIGVycm9ycy93YXJuaW5ncy5cblxuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gY3VycmVudERpc3BhdGNoZXJSZWYuY3VycmVudDtcbiAgY3VycmVudERpc3BhdGNoZXJSZWYuY3VycmVudCA9IG51bGw7XG4gIGRpc2FibGVMb2dzKCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gRmFrZSgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmFsc2UpIHt9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZi5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgIHJlZW5hYmxlTG9ncygpO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIGlmIChmYWxzZSkge31cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgb3duZXJGbiwgY3VycmVudERpc3BhdGNoZXJSZWYpIHtcbiAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBvd25lckZuLCBjdXJyZW50RGlzcGF0Y2hlclJlZikge1xuICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBvd25lckZuLCBjdXJyZW50RGlzcGF0Y2hlclJlZikge1xuICBpZiAodHJ1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSksIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSwgb3duZXJGbik7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJlYWN0U3ltYm9sc1tcIndcIiAvKiBTVVNQRU5TRV9OVU1CRVIgKi9dOlxuICAgIGNhc2UgUmVhY3RTeW1ib2xzW1wieFwiIC8qIFNVU1BFTlNFX1NZTUJPTF9TVFJJTkcgKi9dOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScsIG93bmVyRm4pO1xuXG4gICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJ1XCIgLyogU1VTUEVOU0VfTElTVF9OVU1CRVIgKi9dOlxuICAgIGNhc2UgUmVhY3RTeW1ib2xzW1widlwiIC8qIFNVU1BFTlNFX0xJU1RfU1lNQk9MX1NUUklORyAqL106XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcsIG93bmVyRm4pO1xuICB9XG5cbiAgaWYgKF90eXBlb2YodHlwZSkgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJlYWN0U3ltYm9sc1tcImZcIiAvKiBGT1JXQVJEX1JFRl9OVU1CRVIgKi9dOlxuICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJnXCIgLyogRk9SV0FSRF9SRUZfU1lNQk9MX1NUUklORyAqL106XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsIG93bmVyRm4sIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcblxuICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJqXCIgLyogTUVNT19OVU1CRVIgKi9dOlxuICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJrXCIgLyogTUVNT19TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIG93bmVyRm4sIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcblxuICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJoXCIgLyogTEFaWV9OVU1CRVIgKi9dOlxuICAgICAgY2FzZSBSZWFjdFN5bWJvbHNbXCJpXCIgLyogTEFaWV9TWU1CT0xfU1RSSU5HICovXTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIG93bmVyRm4sIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzRmliZXJDb21wb25lbnRTdGFjay5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBUaGlzIGlzIGEgRGV2VG9vbHMgZm9yayBvZiBSZWFjdEZpYmVyQ29tcG9uZW50U3RhY2suXG4vLyBUaGlzIGZvcmsgZW5hYmxlcyBEZXZUb29scyB0byB1c2UgdGhlIHNhbWUgXCJuYXRpdmVcIiBjb21wb25lbnQgc3RhY2sgZm9ybWF0LFxuLy8gd2hpbGUgc3RpbGwgbWFpbnRhaW5pbmcgc3VwcG9ydCBmb3IgbXVsdGlwbGUgcmVuZGVyZXIgdmVyc2lvbnNcbi8vICh3aGljaCB1c2UgZGlmZmVyZW50IHZhbHVlcyBmb3IgUmVhY3RUeXBlT2ZXb3JrKS5cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcih3b3JrVGFnTWFwLCB3b3JrSW5Qcm9ncmVzcywgY3VycmVudERpc3BhdGNoZXJSZWYpIHtcbiAgdmFyIEhvc3RDb21wb25lbnQgPSB3b3JrVGFnTWFwLkhvc3RDb21wb25lbnQsXG4gICAgICBMYXp5Q29tcG9uZW50ID0gd29ya1RhZ01hcC5MYXp5Q29tcG9uZW50LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQgPSB3b3JrVGFnTWFwLlN1c3BlbnNlQ29tcG9uZW50LFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gd29ya1RhZ01hcC5TdXNwZW5zZUxpc3RDb21wb25lbnQsXG4gICAgICBGdW5jdGlvbkNvbXBvbmVudCA9IHdvcmtUYWdNYXAuRnVuY3Rpb25Db21wb25lbnQsXG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gd29ya1RhZ01hcC5JbmRldGVybWluYXRlQ29tcG9uZW50LFxuICAgICAgU2ltcGxlTWVtb0NvbXBvbmVudCA9IHdvcmtUYWdNYXAuU2ltcGxlTWVtb0NvbXBvbmVudCxcbiAgICAgIEZvcndhcmRSZWYgPSB3b3JrVGFnTWFwLkZvcndhcmRSZWYsXG4gICAgICBDbGFzc0NvbXBvbmVudCA9IHdvcmtUYWdNYXAuQ2xhc3NDb21wb25lbnQ7XG4gIHZhciBvd25lciA9ICBmYWxzZSA/IHVuZGVmaW5lZCA6IG51bGw7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUod29ya0luUHJvZ3Jlc3MudHlwZSwgb3duZXIpO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdMYXp5Jywgb3duZXIpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnLCBvd25lcik7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jywgb3duZXIpO1xuXG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlLCBvd25lciwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlLnJlbmRlciwgb3duZXIsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKHdvcmtJblByb2dyZXNzLnR5cGUsIG93bmVyLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya1RhZ01hcCwgd29ya0luUHJvZ3Jlc3MsIGN1cnJlbnREaXNwYXRjaGVyUmVmKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgZG8ge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKHdvcmtUYWdNYXAsIG5vZGUsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfRUxFTUVOVF9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfUE9SVEFMX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9GUkFHTUVOVF9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX1BST0ZJTEVSX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9QUk9WSURFUl9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfQ09OVEVYVF9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9TVVNQRU5TRV9UWVBFICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfTUVNT19UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfTEFaWV9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfU0NPUEVfVFlQRSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBSRUFDVF9DQUNIRV9UWVBFICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEU7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZXRJdGVyYXRvckZuICovXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnRyYWNpbmdfbWFya2VyJyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEID0gU3ltYm9sLmZvcigncmVhY3QuZGVmYXVsdF92YWx1ZScpO1xudmFyIFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IF90eXBlb2YobWF5YmVJdGVyYWJsZSkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBnOyAvLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuXG5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0oKTtcblxudHJ5IHtcbiAgLy8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG4gIGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG4gIC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufSAvLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbiAvLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFlhbGxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxudmFyIE1BWCA9IFN5bWJvbCgnbWF4Jyk7XG52YXIgTEVOR1RIID0gU3ltYm9sKCdsZW5ndGgnKTtcbnZhciBMRU5HVEhfQ0FMQ1VMQVRPUiA9IFN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpO1xudmFyIEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJyk7XG52YXIgTUFYX0FHRSA9IFN5bWJvbCgnbWF4QWdlJyk7XG52YXIgRElTUE9TRSA9IFN5bWJvbCgnZGlzcG9zZScpO1xudmFyIE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpO1xudmFyIExSVV9MSVNUID0gU3ltYm9sKCdscnVMaXN0Jyk7XG52YXIgQ0FDSEUgPSBTeW1ib2woJ2NhY2hlJyk7XG52YXIgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0Jyk7XG5cbnZhciBuYWl2ZUxlbmd0aCA9IGZ1bmN0aW9uIG5haXZlTGVuZ3RoKCkge1xuICByZXR1cm4gMTtcbn07IC8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuXG5cbnZhciBMUlVDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExSVUNhY2hlKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTFJVQ2FjaGUpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykgb3B0aW9ucyA9IHtcbiAgICAgIG1heDogb3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4IDwgMCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpOyAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG5cbiAgICB2YXIgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXggfHwgSW5maW5pdHk7XG4gICAgdmFyIGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGg7XG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSB0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicgPyBuYWl2ZUxlbmd0aCA6IGxjO1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMDtcbiAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlO1xuICAgIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZTtcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2U7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9IC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5cblxuICBfY3JlYXRlQ2xhc3MoTFJVQ2FjaGUsIFt7XG4gICAga2V5OiBcInJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJmb3JFYWNoKGZuLCB0aGlzcCkge1xuICAgICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuXG4gICAgICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXY7XG4gICAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKTtcbiAgICAgICAgd2Fsa2VyID0gcHJldjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGZuLCB0aGlzcCkge1xuICAgICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuXG4gICAgICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKTtcbiAgICAgICAgd2Fsa2VyID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsua2V5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gay52YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdICYmIHRoaXNbTFJVX0xJU1RdICYmIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpOyAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuXG4gICAgICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCk7IC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcblxuICAgICAgdGhpc1tMRU5HVEhdID0gMDsgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR1bXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVtcCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RhbGUoX3RoaXMyLCBoaXQpID8gZmFsc2UgOiB7XG4gICAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICAgIH07XG4gICAgICB9KS50b0FycmF5KCkuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR1bXBMcnVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVtcExydSgpIHtcbiAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdO1xuICAgICAgaWYgKG1heEFnZSAmJiB0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KTtcblxuICAgICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgICBfZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSk7XG4gICAgICAgIHZhciBpdGVtID0gbm9kZS52YWx1ZTsgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuXG4gICAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSkgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5ub3cgPSBub3c7XG4gICAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlO1xuICAgICAgICBpdGVtLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbS5sZW5ndGggPSBsZW47XG4gICAgICAgIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIHRyaW0odGhpcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpOyAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuXG4gICAgICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgICAgICBpZiAodGhpc1tESVNQT1NFXSkgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aDtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KTtcbiAgICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpO1xuICAgICAgdHJpbSh0aGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlO1xuICAgICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gX2dldCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwZWVrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlZWsoa2V5KSB7XG4gICAgICByZXR1cm4gX2dldCh0aGlzLCBrZXksIGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbDtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIF9kZWwodGhpcywgbm9kZSk7XG5cbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsKGtleSkge1xuICAgICAgX2RlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChhcnIpIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7IC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG5cbiAgICAgIGZvciAodmFyIGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgdmFyIGhpdCA9IGFycltsXTtcbiAgICAgICAgdmFyIGV4cGlyZXNBdCA9IGhpdC5lIHx8IDA7XG4gICAgICAgIGlmIChleHBpcmVzQXQgPT09IDApIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KTtlbHNlIHtcbiAgICAgICAgICB2YXIgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93OyAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcblxuICAgICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBydW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBydW5lKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoX3RoaXMzLCBrZXksIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChtTCkge1xuICAgICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5O1xuICAgICAgdHJpbSh0aGlzKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbTUFYXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWxsb3dTdGFsZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGFsbG93U3RhbGUpIHtcbiAgICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heEFnZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG1BKSB7XG4gICAgICBpZiAodHlwZW9mIG1BICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICB0aGlzW01BWF9BR0VdID0gbUE7XG4gICAgICB0cmltKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tNQVhfQUdFXTtcbiAgICB9IC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoQ2FsY3VsYXRvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxDKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJykgbEMgPSBuYWl2ZUxlbmd0aDtcblxuICAgICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDO1xuICAgICAgICB0aGlzW0xFTkdUSF0gPSAwO1xuICAgICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgICBoaXQubGVuZ3RoID0gX3RoaXM0W0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpO1xuICAgICAgICAgIF90aGlzNFtMRU5HVEhdICs9IGhpdC5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cmltKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbTEVOR1RIXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXRlbUNvdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMUlVDYWNoZTtcbn0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHNlbGYsIGtleSwgZG9Vc2UpIHtcbiAgdmFyIG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KTtcblxuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlO1xuXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgX2RlbChzZWxmLCBub2RlKTtcblxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIGlmIChzZWxmW1VQREFURV9BR0VfT05fR0VUXSkgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGl0LnZhbHVlO1xuICB9XG59O1xuXG52YXIgaXNTdGFsZSA9IGZ1bmN0aW9uIGlzU3RhbGUoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSByZXR1cm4gZmFsc2U7XG4gIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3c7XG4gIHJldHVybiBoaXQubWF4QWdlID8gZGlmZiA+IGhpdC5tYXhBZ2UgOiBzZWxmW01BWF9BR0VdICYmIGRpZmYgPiBzZWxmW01BWF9BR0VdO1xufTtcblxudmFyIHRyaW0gPSBmdW5jdGlvbiB0cmltKHNlbGYpIHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAodmFyIHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7IHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXY7XG5cbiAgICAgIF9kZWwoc2VsZiwgd2Fsa2VyKTtcblxuICAgICAgd2Fsa2VyID0gcHJldjtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfZGVsID0gZnVuY3Rpb24gX2RlbChzZWxmLCBub2RlKSB7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIGhpdCA9IG5vZGUudmFsdWU7XG4gICAgaWYgKHNlbGZbRElTUE9TRV0pIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKTtcbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aDtcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSk7XG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKTtcbiAgfVxufTtcblxudmFyIEVudHJ5ID0gZnVuY3Rpb24gRW50cnkoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW50cnkpO1xuXG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICB0aGlzLm5vdyA9IG5vdztcbiAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMDtcbn07XG5cbnZhciBmb3JFYWNoU3RlcCA9IGZ1bmN0aW9uIGZvckVhY2hTdGVwKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkge1xuICB2YXIgaGl0ID0gbm9kZS52YWx1ZTtcblxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgX2RlbChzZWxmLCBub2RlKTtcblxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIGhpdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChoaXQpIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG59IGVsc2Uge31cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTsgLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gIH1cblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgfVxufSkoKTtcblxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICB9IC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgfSAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgfVxuICB9XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkcmFpbmluZyA9IGZhbHNlO1xuXG4gIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgZHJhaW5RdWV1ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gIGlmIChkcmFpbmluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbikge1xuICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG5cbiAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG5cbiAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG5cbiAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICB9XG59OyAvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5cblxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gIHRoaXMuZnVuID0gZnVuO1xuICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIFtdO1xufTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnLyc7XG59O1xuXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdDtcbllhbGxpc3QuTm9kZSA9IE5vZGU7XG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3Q7XG5cbmZ1bmN0aW9uIFlhbGxpc3QobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KCk7XG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsO1xuICBzZWxmLmhlYWQgPSBudWxsO1xuICBzZWxmLmxlbmd0aCA9IDA7XG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpO1xuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2O1xuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXY7XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS07XG4gIG5vZGUubmV4dCA9IG51bGw7XG4gIG5vZGUucHJldiA9IG51bGw7XG4gIG5vZGUubGlzdCA9IG51bGw7XG4gIHJldHVybiBuZXh0O1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICB9XG5cbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWQ7XG4gIG5vZGUubGlzdCA9IHRoaXM7XG4gIG5vZGUubmV4dCA9IGhlYWQ7XG5cbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlO1xuICB9XG5cbiAgdGhpcy5oZWFkID0gbm9kZTtcblxuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLmxlbmd0aCsrO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWw7XG4gIG5vZGUubGlzdCA9IHRoaXM7XG4gIG5vZGUucHJldiA9IHRhaWw7XG5cbiAgaWYgKHRhaWwpIHtcbiAgICB0YWlsLm5leHQgPSBub2RlO1xuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZTtcblxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLmxlbmd0aCsrO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHVzaCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlO1xuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldjtcblxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gIH1cblxuICB0aGlzLmxlbmd0aC0tO1xuICByZXR1cm4gcmVzO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWU7XG4gIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuXG4gIGlmICh0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQucHJldiA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoLS07XG4gIHJldHVybiByZXM7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG5cbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpO1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpO1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG5cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZTtcbiAgfVxufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0UmV2ZXJzZSA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cblxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlO1xuICB9XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KCk7XG5cbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSk7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKTtcblxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjYztcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsO1xuICB9IGVsc2UgaWYgKHRoaXMuaGVhZCkge1xuICAgIHdhbGtlciA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuXG4gIHJldHVybiBhY2M7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2M7XG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbDtcbiAgfSBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWwucHJldjtcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuXG4gIHJldHVybiBhY2M7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZTtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWU7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aDtcblxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBmcm9tID0gZnJvbSB8fCAwO1xuXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKTtcblxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMDtcbiAgfVxuXG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cblxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2VSZXZlcnNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGg7XG5cbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgZnJvbSA9IGZyb20gfHwgMDtcblxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KCk7XG5cbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDA7XG4gIH1cblxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cblxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiBmcm9tOyBpLS0sIHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50XG4vKiwgLi4ubm9kZXMgKi9cbikge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG5cbiAgdmFyIHJldCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgJiYgaSA8IGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpO1xuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpO1xuICB9XG5cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbDtcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkO1xuICB2YXIgdGFpbCA9IHRoaXMudGFpbDtcblxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldjtcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0O1xuICAgIHdhbGtlci5uZXh0ID0gcDtcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IHRhaWw7XG4gIHRoaXMudGFpbCA9IGhlYWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gaW5zZXJ0KHNlbGYsIG5vZGUsIHZhbHVlKSB7XG4gIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYuaGVhZCA/IG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6IG5ldyBOb2RlKHZhbHVlLCBub2RlLCBub2RlLm5leHQsIHNlbGYpO1xuXG4gIGlmIChpbnNlcnRlZC5uZXh0ID09PSBudWxsKSB7XG4gICAgc2VsZi50YWlsID0gaW5zZXJ0ZWQ7XG4gIH1cblxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkO1xuICB9XG5cbiAgc2VsZi5sZW5ndGgrKztcbiAgcmV0dXJuIGluc2VydGVkO1xufVxuXG5mdW5jdGlvbiBwdXNoKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKTtcblxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbDtcbiAgfVxuXG4gIHNlbGYubGVuZ3RoKys7XG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpO1xuXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkO1xuICB9XG5cbiAgc2VsZi5sZW5ndGgrKztcbn1cblxuZnVuY3Rpb24gTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpO1xuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdDtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpcztcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXM7XG4gICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG59XG5cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKShZYWxsaXN0KTtcbn0gY2F0Y2ggKGVyKSB7fVxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFlhbGxpc3QpIHtcbiAgWWFsbGlzdC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciB3YWxrZXI7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgd2Fsa2VyID0gdGhpcy5oZWFkO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKCF3YWxrZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBiID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksXG4gICAgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICBlID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgIGYgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgICBoID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgayA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKSxcbiAgICBsID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgIG0gPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgIHAgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICBxID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jYWNoZVwiKSxcbiAgICB2ID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIik7XG5cbmZ1bmN0aW9uIHcoYSkge1xuICBpZiAoXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiBudWxsICE9PSBhKSB7XG4gICAgdmFyIHIgPSBhLiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoIChyKSB7XG4gICAgICBjYXNlIGI6XG4gICAgICAgIHN3aXRjaCAoYSA9IGEudHlwZSwgYSkge1xuICAgICAgICAgIGNhc2UgZDpcbiAgICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgY2FzZSBlOlxuICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICByZXR1cm4gYTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzd2l0Y2ggKGEgPSBhICYmIGEuJCR0eXBlb2YsIGEpIHtcbiAgICAgICAgICAgICAgY2FzZSBrOlxuICAgICAgICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgICAgY2FzZSBxOlxuICAgICAgICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBjOlxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBoO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBnO1xuZXhwb3J0cy5FbGVtZW50ID0gYjtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IGw7XG5leHBvcnRzLkZyYWdtZW50ID0gZDtcbmV4cG9ydHMuTGF6eSA9IHE7XG5leHBvcnRzLk1lbW8gPSBwO1xuZXhwb3J0cy5Qb3J0YWwgPSBjO1xuZXhwb3J0cy5Qcm9maWxlciA9IGY7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IG07XG5leHBvcnRzLlN1c3BlbnNlTGlzdCA9IG47XG5cbmV4cG9ydHMuaXNBc3luY01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhMTtcbn07XG5cbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICExO1xufTtcblxuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBoO1xufTtcblxuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBnO1xufTtcblxuZXhwb3J0cy5pc0VsZW1lbnQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiBudWxsICE9PSBhICYmIGEuJCR0eXBlb2YgPT09IGI7XG59O1xuXG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBsO1xufTtcblxuZXhwb3J0cy5pc0ZyYWdtZW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHcoYSkgPT09IGQ7XG59O1xuXG5leHBvcnRzLmlzTGF6eSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBxO1xufTtcblxuZXhwb3J0cy5pc01lbW8gPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gdyhhKSA9PT0gcDtcbn07XG5cbmV4cG9ydHMuaXNQb3J0YWwgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gdyhhKSA9PT0gYztcbn07XG5cbmV4cG9ydHMuaXNQcm9maWxlciA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBmO1xufTtcblxuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gdyhhKSA9PT0gZTtcbn07XG5cbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBtO1xufTtcblxuZXhwb3J0cy5pc1N1c3BlbnNlTGlzdCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB3KGEpID09PSBuO1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGEgfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYSB8fCBhID09PSBkIHx8IGEgPT09IGYgfHwgYSA9PT0gZSB8fCBhID09PSBtIHx8IGEgPT09IG4gfHwgYSA9PT0gdCB8fCBhID09PSB1IHx8IFwib2JqZWN0XCIgPT09IF90eXBlb2YoYSkgJiYgbnVsbCAhPT0gYSAmJiAoYS4kJHR5cGVvZiA9PT0gcSB8fCBhLiQkdHlwZW9mID09PSBwIHx8IGEuJCR0eXBlb2YgPT09IGcgfHwgYS4kJHR5cGVvZiA9PT0gaCB8fCBhLiQkdHlwZW9mID09PSBsIHx8IGEuJCR0eXBlb2YgPT09IHYgfHwgdm9pZCAwICE9PSBhLmdldE1vZHVsZUlkKSA/ICEwIDogITE7XG59O1xuXG5leHBvcnRzLnR5cGVPZiA9IHc7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kZWJ1Zy10b29scy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCksXG4gICAgcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpLFxuICAgIHEgPSBPYmplY3QuYXNzaWduLFxuICAgIHcgPSBwLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELFxuICAgIHggPSBbXSxcbiAgICB5ID0gbnVsbDtcblxuZnVuY3Rpb24geigpIHtcbiAgaWYgKG51bGwgPT09IHkpIHtcbiAgICB2YXIgYSA9IG5ldyBNYXAoKTtcblxuICAgIHRyeSB7XG4gICAgICBBLnVzZUNvbnRleHQoe1xuICAgICAgICBfY3VycmVudFZhbHVlOiBudWxsXG4gICAgICB9KSwgQS51c2VTdGF0ZShudWxsKSwgQS51c2VSZWR1Y2VyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSwgbnVsbCksIEEudXNlUmVmKG51bGwpLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBBLnVzZUNhY2hlUmVmcmVzaCAmJiBBLnVzZUNhY2hlUmVmcmVzaCgpLCBBLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7fSksIEEudXNlSW5zZXJ0aW9uRWZmZWN0KGZ1bmN0aW9uICgpIHt9KSwgQS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge30pLCBBLnVzZUltcGVyYXRpdmVIYW5kbGUodm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSksIEEudXNlRGVidWdWYWx1ZShudWxsKSwgQS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7fSksIEEudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHZhciBiID0geDtcbiAgICAgIHggPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IGIubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBnID0gYltlXTtcbiAgICAgIGEuc2V0KGcucHJpbWl0aXZlLCBoLnBhcnNlKGcuc3RhY2tFcnJvcikpO1xuICAgIH1cblxuICAgIHkgPSBhO1xuICB9XG5cbiAgcmV0dXJuIHk7XG59XG5cbnZhciBCID0gbnVsbDtcblxuZnVuY3Rpb24gQygpIHtcbiAgdmFyIGEgPSBCO1xuICBudWxsICE9PSBhICYmIChCID0gYS5uZXh0KTtcbiAgcmV0dXJuIGE7XG59XG5cbnZhciBBID0ge1xuICByZWFkQ29udGV4dDogZnVuY3Rpb24gcmVhZENvbnRleHQoYSkge1xuICAgIHJldHVybiBhLl9jdXJyZW50VmFsdWU7XG4gIH0sXG4gIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgIHZhciBhID0gQygpO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiQ2FjaGVSZWZyZXNoXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IG51bGwgIT09IGEgPyBhLm1lbW9pemVkU3RhdGUgOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgfSxcbiAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGEpIHtcbiAgICB2YXIgYiA9IEMoKTtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIkNhbGxiYWNrXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IG51bGwgIT09IGIgPyBiLm1lbW9pemVkU3RhdGVbMF0gOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIHVzZUNvbnRleHQoYSkge1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiQ29udGV4dFwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhLl9jdXJyZW50VmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gYS5fY3VycmVudFZhbHVlO1xuICB9LFxuICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIHVzZUVmZmVjdChhKSB7XG4gICAgQygpO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiRWZmZWN0XCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgfSxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShhKSB7XG4gICAgQygpO1xuICAgIHZhciBiID0gdm9pZCAwO1xuICAgIG51bGwgIT09IGEgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiAoYiA9IGEuY3VycmVudCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJJbXBlcmF0aXZlSGFuZGxlXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGJcbiAgICB9KTtcbiAgfSxcbiAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gdXNlRGVidWdWYWx1ZShhLCBiKSB7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJEZWJ1Z1ZhbHVlXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGIgPyBiKGEpIDogYVxuICAgIH0pO1xuICB9LFxuICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChhKSB7XG4gICAgQygpO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiTGF5b3V0RWZmZWN0XCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgfSxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiB1c2VJbnNlcnRpb25FZmZlY3QoYSkge1xuICAgIEMoKTtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIkluc2VydGlvbkVmZmVjdFwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhXG4gICAgfSk7XG4gIH0sXG4gIHVzZU1lbW86IGZ1bmN0aW9uIHVzZU1lbW8oYSkge1xuICAgIHZhciBiID0gQygpO1xuICAgIGEgPSBudWxsICE9PSBiID8gYi5tZW1vaXplZFN0YXRlWzBdIDogYSgpO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiTWVtb1wiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIHVzZVJlZHVjZXIoYSwgYiwgZSkge1xuICAgIGEgPSBDKCk7XG4gICAgYiA9IG51bGwgIT09IGEgPyBhLm1lbW9pemVkU3RhdGUgOiB2b2lkIDAgIT09IGUgPyBlKGIpIDogYjtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIlJlZHVjZXJcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYlxuICAgIH0pO1xuICAgIHJldHVybiBbYiwgZnVuY3Rpb24gKCkge31dO1xuICB9LFxuICB1c2VSZWY6IGZ1bmN0aW9uIHVzZVJlZihhKSB7XG4gICAgdmFyIGIgPSBDKCk7XG4gICAgYSA9IG51bGwgIT09IGIgPyBiLm1lbW9pemVkU3RhdGUgOiB7XG4gICAgICBjdXJyZW50OiBhXG4gICAgfTtcbiAgICB4LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIlJlZlwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhLmN1cnJlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgdXNlU3RhdGU6IGZ1bmN0aW9uIHVzZVN0YXRlKGEpIHtcbiAgICB2YXIgYiA9IEMoKTtcbiAgICBhID0gbnVsbCAhPT0gYiA/IGIubWVtb2l6ZWRTdGF0ZSA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGEgPyBhKCkgOiBhO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiU3RhdGVcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYVxuICAgIH0pO1xuICAgIHJldHVybiBbYSwgZnVuY3Rpb24gKCkge31dO1xuICB9LFxuICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICAgIEMoKTtcbiAgICBDKCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJUcmFuc2l0aW9uXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBbITEsIGZ1bmN0aW9uICgpIHt9XTtcbiAgfSxcbiAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gdXNlTXV0YWJsZVNvdXJjZShhLCBiKSB7XG4gICAgQygpO1xuICAgIEMoKTtcbiAgICBDKCk7XG4gICAgQygpO1xuICAgIGEgPSBiKGEuX3NvdXJjZSk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJNdXRhYmxlU291cmNlXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKGEsIGIpIHtcbiAgICBDKCk7XG4gICAgQygpO1xuICAgIGEgPSBiKCk7XG4gICAgeC5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJTeW5jRXh0ZXJuYWxTdG9yZVwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUoYSkge1xuICAgIHZhciBiID0gQygpO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiRGVmZXJyZWRWYWx1ZVwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBudWxsICE9PSBiID8gYi5tZW1vaXplZFN0YXRlIDogYVxuICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9LFxuICB1c2VJZDogZnVuY3Rpb24gdXNlSWQoKSB7XG4gICAgdmFyIGEgPSBDKCk7XG4gICAgYSA9IG51bGwgIT09IGEgPyBhLm1lbW9pemVkU3RhdGUgOiBcIlwiO1xuICAgIHgucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiSWRcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYVxuICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9XG59LFxuICAgIEQgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KGEsIGIpIHtcbiAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShiKSkgcmV0dXJuIGFbYl07XG4gICAgYSA9IEVycm9yKFwiTWlzc2luZyBtZXRob2QgaW4gRGlzcGF0Y2hlcjogXCIgKyBiKTtcbiAgICBhLm5hbWUgPSBcIlJlYWN0RGVidWdUb29sc1Vuc3VwcG9ydGVkSG9va0Vycm9yXCI7XG4gICAgdGhyb3cgYTtcbiAgfVxufSxcbiAgICBFID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIFByb3h5ID8gQSA6IG5ldyBQcm94eShBLCBEKSxcbiAgICBGID0gMDtcblxuZnVuY3Rpb24gRyhhLCBiLCBlKSB7XG4gIHZhciBnID0gYltlXS5zb3VyY2UsXG4gICAgICBjID0gMDtcblxuICBhOiBmb3IgKDsgYyA8IGEubGVuZ3RoOyBjKyspIHtcbiAgICBpZiAoYVtjXS5zb3VyY2UgPT09IGcpIHtcbiAgICAgIGZvciAodmFyIGsgPSBlICsgMSwgciA9IGMgKyAxOyBrIDwgYi5sZW5ndGggJiYgciA8IGEubGVuZ3RoOyBrKyssIHIrKykge1xuICAgICAgICBpZiAoYVtyXS5zb3VyY2UgIT09IGJba10uc291cmNlKSBjb250aW51ZSBhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIEgoYSwgYikge1xuICBpZiAoIWEpIHJldHVybiAhMTtcbiAgYiA9IFwidXNlXCIgKyBiO1xuICByZXR1cm4gYS5sZW5ndGggPCBiLmxlbmd0aCA/ICExIDogYS5sYXN0SW5kZXhPZihiKSA9PT0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gSShhLCBiLCBlKSB7XG4gIGZvciAodmFyIGcgPSBbXSwgYyA9IG51bGwsIGsgPSBnLCByID0gMCwgdCA9IFtdLCB2ID0gMDsgdiA8IGIubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgdSA9IGJbdl07XG4gICAgdmFyIGQgPSBhO1xuICAgIHZhciBsID0gaC5wYXJzZSh1LnN0YWNrRXJyb3IpO1xuXG4gICAgYjoge1xuICAgICAgdmFyIG0gPSBsLFxuICAgICAgICAgIG4gPSBHKG0sIGQsIEYpO1xuICAgICAgaWYgKC0xICE9PSBuKSBkID0gbjtlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCBkLmxlbmd0aCAmJiA1ID4gZjsgZisrKSB7XG4gICAgICAgICAgaWYgKG4gPSBHKG0sIGQsIGYpLCAtMSAhPT0gbikge1xuICAgICAgICAgICAgRiA9IGY7XG4gICAgICAgICAgICBkID0gbjtcbiAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZCA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGI6IHtcbiAgICAgIG0gPSBsO1xuICAgICAgbiA9IHooKS5nZXQodS5wcmltaXRpdmUpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gbikgZm9yIChmID0gMDsgZiA8IG4ubGVuZ3RoICYmIGYgPCBtLmxlbmd0aDsgZisrKSB7XG4gICAgICAgIGlmIChuW2ZdLnNvdXJjZSAhPT0gbVtmXS5zb3VyY2UpIHtcbiAgICAgICAgICBmIDwgbS5sZW5ndGggLSAxICYmIEgobVtmXS5mdW5jdGlvbk5hbWUsIHUucHJpbWl0aXZlKSAmJiBmKys7XG4gICAgICAgICAgZiA8IG0ubGVuZ3RoIC0gMSAmJiBIKG1bZl0uZnVuY3Rpb25OYW1lLCB1LnByaW1pdGl2ZSkgJiYgZisrO1xuICAgICAgICAgIG0gPSBmO1xuICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0gPSAtMTtcbiAgICB9XG5cbiAgICBsID0gLTEgPT09IGQgfHwgLTEgPT09IG0gfHwgMiA+IGQgLSBtID8gbnVsbCA6IGwuc2xpY2UobSwgZCAtIDEpO1xuXG4gICAgaWYgKG51bGwgIT09IGwpIHtcbiAgICAgIGQgPSAwO1xuXG4gICAgICBpZiAobnVsbCAhPT0gYykge1xuICAgICAgICBmb3IgKDsgZCA8IGwubGVuZ3RoICYmIGQgPCBjLmxlbmd0aCAmJiBsW2wubGVuZ3RoIC0gZCAtIDFdLnNvdXJjZSA9PT0gY1tjLmxlbmd0aCAtIGQgLSAxXS5zb3VyY2U7KSB7XG4gICAgICAgICAgZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjID0gYy5sZW5ndGggLSAxOyBjID4gZDsgYy0tKSB7XG4gICAgICAgICAgayA9IHQucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjID0gbC5sZW5ndGggLSBkIC0gMTsgMSA8PSBjOyBjLS0pIHtcbiAgICAgICAgZCA9IFtdLCBtID0gbFtjXSwgKG4gPSBsW2MgLSAxXS5mdW5jdGlvbk5hbWUpID8gKGYgPSBuLmxhc3RJbmRleE9mKFwiLlwiKSwgLTEgPT09IGYgJiYgKGYgPSAwKSwgXCJ1c2VcIiA9PT0gbi5zbGljZShmLCBmICsgMykgJiYgKGYgKz0gMyksIG4gPSBuLnNsaWNlKGYpKSA6IG4gPSBcIlwiLCBuID0ge1xuICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgIGlzU3RhdGVFZGl0YWJsZTogITEsXG4gICAgICAgICAgbmFtZTogbixcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgIHN1Ykhvb2tzOiBkXG4gICAgICAgIH0sIGUgJiYgKG4uaG9va1NvdXJjZSA9IHtcbiAgICAgICAgICBsaW5lTnVtYmVyOiBtLmxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uTnVtYmVyOiBtLmNvbHVtbk51bWJlcixcbiAgICAgICAgICBmdW5jdGlvbk5hbWU6IG0uZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGZpbGVOYW1lOiBtLmZpbGVOYW1lXG4gICAgICAgIH0pLCBrLnB1c2gobiksIHQucHVzaChrKSwgayA9IGQ7XG4gICAgICB9XG5cbiAgICAgIGMgPSBsO1xuICAgIH1cblxuICAgIGQgPSB1LnByaW1pdGl2ZTtcbiAgICB1ID0ge1xuICAgICAgaWQ6IFwiQ29udGV4dFwiID09PSBkIHx8IFwiRGVidWdWYWx1ZVwiID09PSBkID8gbnVsbCA6IHIrKyxcbiAgICAgIGlzU3RhdGVFZGl0YWJsZTogXCJSZWR1Y2VyXCIgPT09IGQgfHwgXCJTdGF0ZVwiID09PSBkLFxuICAgICAgbmFtZTogZCxcbiAgICAgIHZhbHVlOiB1LnZhbHVlLFxuICAgICAgc3ViSG9va3M6IFtdXG4gICAgfTtcbiAgICBlICYmIChkID0ge1xuICAgICAgbGluZU51bWJlcjogbnVsbCxcbiAgICAgIGZ1bmN0aW9uTmFtZTogbnVsbCxcbiAgICAgIGZpbGVOYW1lOiBudWxsLFxuICAgICAgY29sdW1uTnVtYmVyOiBudWxsXG4gICAgfSwgbCAmJiAxIDw9IGwubGVuZ3RoICYmIChsID0gbFswXSwgZC5saW5lTnVtYmVyID0gbC5saW5lTnVtYmVyLCBkLmZ1bmN0aW9uTmFtZSA9IGwuZnVuY3Rpb25OYW1lLCBkLmZpbGVOYW1lID0gbC5maWxlTmFtZSwgZC5jb2x1bW5OdW1iZXIgPSBsLmNvbHVtbk51bWJlciksIHUuaG9va1NvdXJjZSA9IGQpO1xuICAgIGsucHVzaCh1KTtcbiAgfVxuXG4gIEooZywgbnVsbCk7XG4gIHJldHVybiBnO1xufVxuXG5mdW5jdGlvbiBKKGEsIGIpIHtcbiAgZm9yICh2YXIgZSA9IFtdLCBnID0gMDsgZyA8IGEubGVuZ3RoOyBnKyspIHtcbiAgICB2YXIgYyA9IGFbZ107XG4gICAgXCJEZWJ1Z1ZhbHVlXCIgPT09IGMubmFtZSAmJiAwID09PSBjLnN1Ykhvb2tzLmxlbmd0aCA/IChhLnNwbGljZShnLCAxKSwgZy0tLCBlLnB1c2goYykpIDogSihjLnN1Ykhvb2tzLCBjKTtcbiAgfVxuXG4gIG51bGwgIT09IGIgJiYgKDEgPT09IGUubGVuZ3RoID8gYi52YWx1ZSA9IGVbMF0udmFsdWUgOiAxIDwgZS5sZW5ndGggJiYgKGIudmFsdWUgPSBlLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrLnZhbHVlO1xuICB9KSkpO1xufVxuXG5mdW5jdGlvbiBLKGEpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBFcnJvciAmJiBcIlJlYWN0RGVidWdUb29sc1Vuc3VwcG9ydGVkSG9va0Vycm9yXCIgPT09IGEubmFtZSkgdGhyb3cgYTtcbiAgdmFyIGIgPSBFcnJvcihcIkVycm9yIHJlbmRlcmluZyBpbnNwZWN0ZWQgY29tcG9uZW50XCIsIHtcbiAgICBjYXVzZTogYVxuICB9KTtcbiAgYi5uYW1lID0gXCJSZWFjdERlYnVnVG9vbHNSZW5kZXJFcnJvclwiO1xuICBiLmNhdXNlID0gYTtcbiAgdGhyb3cgYjtcbn1cblxuZnVuY3Rpb24gTChhLCBiLCBlKSB7XG4gIHZhciBnID0gMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiAhMTtcbiAgbnVsbCA9PSBlICYmIChlID0gdy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyKTtcbiAgdmFyIGMgPSBlLmN1cnJlbnQ7XG4gIGUuY3VycmVudCA9IEU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgayA9IEVycm9yKCk7XG4gICAgYShiKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIEsodCk7XG4gIH0gZmluYWxseSB7XG4gICAgdmFyIHIgPSB4O1xuICAgIHggPSBbXTtcbiAgICBlLmN1cnJlbnQgPSBjO1xuICB9XG5cbiAgYyA9IGgucGFyc2Uoayk7XG4gIHJldHVybiBJKGMsIHIsIGcpO1xufVxuXG5mdW5jdGlvbiBNKGEpIHtcbiAgYS5mb3JFYWNoKGZ1bmN0aW9uIChiLCBlKSB7XG4gICAgcmV0dXJuIGUuX2N1cnJlbnRWYWx1ZSA9IGI7XG4gIH0pO1xufVxuXG5leHBvcnRzLmluc3BlY3RIb29rcyA9IEw7XG5cbmV4cG9ydHMuaW5zcGVjdEhvb2tzT2ZGaWJlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBlID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAhMTtcbiAgbnVsbCA9PSBiICYmIChiID0gdy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyKTtcbiAgaWYgKDAgIT09IGEudGFnICYmIDE1ICE9PSBhLnRhZyAmJiAxMSAhPT0gYS50YWcpIHRocm93IEVycm9yKFwiVW5rbm93biBGaWJlci4gTmVlZHMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdG8gaW5zcGVjdCBob29rcy5cIik7XG4gIHooKTtcbiAgdmFyIGcgPSBhLnR5cGUsXG4gICAgICBjID0gYS5tZW1vaXplZFByb3BzO1xuXG4gIGlmIChnICE9PSBhLmVsZW1lbnRUeXBlICYmIGcgJiYgZy5kZWZhdWx0UHJvcHMpIHtcbiAgICBjID0gcSh7fSwgYyk7XG4gICAgdmFyIGsgPSBnLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAociBpbiBrKSB7XG4gICAgICB2b2lkIDAgPT09IGNbcl0gJiYgKGNbcl0gPSBrW3JdKTtcbiAgICB9XG4gIH1cblxuICBCID0gYS5tZW1vaXplZFN0YXRlO1xuICB2YXIgciA9IG5ldyBNYXAoKTtcblxuICB0cnkge1xuICAgIGZvciAoayA9IGE7IGs7KSB7XG4gICAgICBpZiAoMTAgPT09IGsudGFnKSB7XG4gICAgICAgIHZhciB0ID0gay50eXBlLl9jb250ZXh0O1xuICAgICAgICByLmhhcyh0KSB8fCAoci5zZXQodCwgdC5fY3VycmVudFZhbHVlKSwgdC5fY3VycmVudFZhbHVlID0gay5tZW1vaXplZFByb3BzLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgayA9IGsucmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgxMSA9PT0gYS50YWcpIHtcbiAgICAgIHZhciB2ID0gZy5yZW5kZXI7XG4gICAgICBnID0gYztcbiAgICAgIHZhciB1ID0gYS5yZWY7XG4gICAgICB0ID0gYjtcbiAgICAgIHZhciBkID0gdC5jdXJyZW50O1xuICAgICAgdC5jdXJyZW50ID0gRTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGwgPSBFcnJvcigpO1xuICAgICAgICB2KGcsIHUpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICBLKGYpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdmFyIG0gPSB4O1xuICAgICAgICB4ID0gW107XG4gICAgICAgIHQuY3VycmVudCA9IGQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gaC5wYXJzZShsKTtcbiAgICAgIHJldHVybiBJKG4sIG0sIGUpO1xuICAgIH1cblxuICAgIHJldHVybiBMKGcsIGMsIGIsIGUpO1xuICB9IGZpbmFsbHkge1xuICAgIEIgPSBudWxsLCBNKHIpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO2Z1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JzsgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygyNSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgfSBlbHNlIHt9XG59KSh0aGlzLCBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyKFN0YWNrRnJhbWUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrOlxcZCsvO1xuICB2YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG4gIHZhciBTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQID0gL14oZXZhbEApPyhcXFtuYXRpdmUgY29kZV0pPyQvO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IG9mIFN0YWNrRnJhbWVzXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVY4T3JJRShlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24odXJsTGlrZSkge1xuICAgICAgLy8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG4gICAgICBpZiAodXJsTGlrZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLztcbiAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCAnJykpO1xuICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xuICAgIH0sXG4gICAgcGFyc2VWOE9ySUU6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlVjhPcklFKGVycm9yKSB7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignKGV2YWwgJykgPiAtMSkge1xuICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9ldmFsIGNvZGUvZywgJ2V2YWwnKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfChcXCksLiokKS9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJyk7IC8vIGNhcHR1cmUgYW5kIHByZXNldmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gXCIoL2Zvby9teSBiYXIuanM6MTI6ODcpXCIgaW5cbiAgICAgICAgLy8gY2FzZSBpdCBoYXMgc3BhY2VzIGluIGl0LCBhcyB0aGUgc3RyaW5nIGlzIHNwbGl0IG9uIFxccysgbGF0ZXIgb25cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQpLyk7IC8vIHJlbW92ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBmcm9tIHRoZSBsaW5lLCBpZiBpdCB3YXMgbWF0Y2hlZFxuXG4gICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvbiA/IHNhbml0aXplZExpbmUucmVwbGFjZShsb2NhdGlvblswXSwgJycpIDogc2FuaXRpemVkTGluZTtcbiAgICAgICAgdmFyIHRva2VucyA9IHNhbml0aXplZExpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTsgLy8gaWYgYSBsb2NhdGlvbiB3YXMgbWF0Y2hlZCwgcGFzcyBpdCB0byBleHRyYWN0TG9jYXRpb24oKSBvdGhlcndpc2UgcG9wIHRoZSBsYXN0IHRva2VuXG5cbiAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsb2NhdGlvbiA/IGxvY2F0aW9uWzFdIDogdG9rZW5zLnBvcCgpKTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCcgJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBbJ2V2YWwnLCAnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWw6XFxkKzpcXGQrL2csICc6JDEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ0AnKSA9PT0gLTEgJiYgbGluZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG4gICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWVSZWdleCA9IC8oKC4qXCIuK1wiW15AXSopP1teQF0qKSg/OkApLztcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goZnVuY3Rpb25OYW1lUmVnZXgpO1xuICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obGluZS5yZXBsYWNlKGZ1bmN0aW9uTmFtZVJlZ2V4LCAnJykpO1xuICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEoZSkge1xuICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgZS5tZXNzYWdlLmluZGV4T2YoJ1xcbicpID4gLTEgJiYgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTEwKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTExKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2VPcGVyYTk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmE5KGUpIHtcbiAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xuICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hbMl0sXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbWF0Y2hbM10gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuICAgIHBhcnNlT3BlcmExMTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExKGVycm9yKSB7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQKSAmJiAhbGluZS5tYXRjaCgvXkVycm9yIGNyZWF0ZWQgYXQvKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgIHZhciBmdW5jdGlvbkNhbGwgPSB0b2tlbnMuc2hpZnQoKSB8fCAnJztcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uKDogKFxcdyspKT8+LywgJyQyJykucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFyZ3NSYXc7XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteKV0qKVxcKS8pKSB7XG4gICAgICAgICAgYXJnc1JhdyA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC9eW14oXStcXCgoW14pXSopXFwpJC8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nID8gdW5kZWZpbmVkIDogYXJnc1Jhdy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187ZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnOyAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBpZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgfSBlbHNlIHt9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gIH1cblxuICBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXR0ZXIocCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1twXTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICB2YXIgbnVtZXJpY1Byb3BzID0gWydjb2x1bW5OdW1iZXInLCAnbGluZU51bWJlciddO1xuICB2YXIgc3RyaW5nUHJvcHMgPSBbJ2ZpbGVOYW1lJywgJ2Z1bmN0aW9uTmFtZScsICdzb3VyY2UnXTtcbiAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcbiAgdmFyIHByb3BzID0gYm9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsIHN0cmluZ1Byb3BzLCBhcnJheVByb3BzKTtcblxuICBmdW5jdGlvbiBTdGFja0ZyYW1lKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqW3Byb3BzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNbJ3NldCcgKyBfY2FwaXRhbGl6ZShwcm9wc1tpXSldKG9ialtwcm9wc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFN0YWNrRnJhbWUucHJvdG90eXBlID0ge1xuICAgIGdldEFyZ3M6IGZ1bmN0aW9uIGdldEFyZ3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgIH0sXG4gICAgc2V0QXJnczogZnVuY3Rpb24gc2V0QXJncyh2KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3MgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFyZ3MgPSB2O1xuICAgIH0sXG4gICAgZ2V0RXZhbE9yaWdpbjogZnVuY3Rpb24gZ2V0RXZhbE9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2YWxPcmlnaW47XG4gICAgfSxcbiAgICBzZXRFdmFsT3JpZ2luOiBmdW5jdGlvbiBzZXRFdmFsT3JpZ2luKHYpIHtcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSkge1xuICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSB2O1xuICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IG5ldyBTdGFja0ZyYW1lKHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZhbCBPcmlnaW4gbXVzdCBiZSBhbiBPYmplY3Qgb3IgU3RhY2tGcmFtZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgpIHx8ICcnO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKSB8fCAnJztcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpIHx8ICcnO1xuICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRoaXMuZ2V0RnVuY3Rpb25OYW1lKCkgfHwgJyc7XG5cbiAgICAgIGlmICh0aGlzLmdldElzRXZhbCgpKSB7XG4gICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiAnW2V2YWxdICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbZXZhbF06JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSArICcgKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgfVxuICB9O1xuXG4gIFN0YWNrRnJhbWUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIFN0YWNrRnJhbWUkJGZyb21TdHJpbmcoc3RyKSB7XG4gICAgdmFyIGFyZ3NTdGFydEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgICB2YXIgYXJnc0VuZEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcpJyk7XG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgYXJnc1N0YXJ0SW5kZXgpO1xuICAgIHZhciBhcmdzID0gc3RyLnN1YnN0cmluZyhhcmdzU3RhcnRJbmRleCArIDEsIGFyZ3NFbmRJbmRleCkuc3BsaXQoJywnKTtcbiAgICB2YXIgbG9jYXRpb25TdHJpbmcgPSBzdHIuc3Vic3RyaW5nKGFyZ3NFbmRJbmRleCArIDEpO1xuXG4gICAgaWYgKGxvY2F0aW9uU3RyaW5nLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgdmFyIHBhcnRzID0gL0AoLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvLmV4ZWMobG9jYXRpb25TdHJpbmcsICcnKTtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHBhcnRzWzFdO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwYXJ0c1syXTtcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBwYXJ0c1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICBhcmdzOiBhcmdzIHx8IHVuZGVmaW5lZCxcbiAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgY29sdW1uTnVtYmVyOiBjb2x1bW5OdW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sZWFuUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gX2dldHRlcihib29sZWFuUHJvcHNbaV0pO1xuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpc1twXSA9IEJvb2xlYW4odik7XG4gICAgICB9O1xuICAgIH0oYm9vbGVhblByb3BzW2ldKTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgbnVtZXJpY1Byb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IF9nZXR0ZXIobnVtZXJpY1Byb3BzW2pdKTtcblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwICsgJyBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3BdID0gTnVtYmVyKHYpO1xuICAgICAgfTtcbiAgICB9KG51bWVyaWNQcm9wc1tqXSk7XG4gIH1cblxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cmluZ1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gX2dldHRlcihzdHJpbmdQcm9wc1trXSk7XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXNbcF0gPSBTdHJpbmcodik7XG4gICAgICB9O1xuICAgIH0oc3RyaW5nUHJvcHNba10pO1xuICB9XG5cbiAgcmV0dXJuIFN0YWNrRnJhbWU7XG59KTtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5pZiAodHJ1ZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xufSBlbHNlIHt9XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBsID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksXG4gICAgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgcCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICBxID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgICB1ID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgdiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKSxcbiAgICB3ID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgIHggPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgeSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgIHogPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICBBID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgYWEgPSBTeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKSxcbiAgICBiYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgY2EgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2FjaGVcIiksXG4gICAgQiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5kZWZhdWx0X3ZhbHVlXCIpLFxuICAgIEMgPSBTeW1ib2wuaXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGRhKGEpIHtcbiAgaWYgKG51bGwgPT09IGEgfHwgXCJvYmplY3RcIiAhPT0gX3R5cGVvZihhKSkgcmV0dXJuIG51bGw7XG4gIGEgPSBDICYmIGFbQ10gfHwgYVtcIkBAaXRlcmF0b3JcIl07XG4gIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhID8gYSA6IG51bGw7XG59XG5cbnZhciBEID0ge1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIGlzTW91bnRlZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKCkge30sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUoKSB7fSxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUoKSB7fVxufSxcbiAgICBFID0gT2JqZWN0LmFzc2lnbixcbiAgICBGID0ge307XG5cbmZ1bmN0aW9uIEcoYSwgYiwgYykge1xuICB0aGlzLnByb3BzID0gYTtcbiAgdGhpcy5jb250ZXh0ID0gYjtcbiAgdGhpcy5yZWZzID0gRjtcbiAgdGhpcy51cGRhdGVyID0gYyB8fCBEO1xufVxuXG5HLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbkcucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT09IF90eXBlb2YoYSkgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgYSAmJiBudWxsICE9IGEpIHRocm93IEVycm9yKFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIpO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIGEsIGIsIFwic2V0U3RhdGVcIik7XG59O1xuXG5HLnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgYSwgXCJmb3JjZVVwZGF0ZVwiKTtcbn07XG5cbmZ1bmN0aW9uIEgoKSB7fVxuXG5ILnByb3RvdHlwZSA9IEcucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBJKGEsIGIsIGMpIHtcbiAgdGhpcy5wcm9wcyA9IGE7XG4gIHRoaXMuY29udGV4dCA9IGI7XG4gIHRoaXMucmVmcyA9IEY7XG4gIHRoaXMudXBkYXRlciA9IGMgfHwgRDtcbn1cblxudmFyIEogPSBJLnByb3RvdHlwZSA9IG5ldyBIKCk7XG5KLmNvbnN0cnVjdG9yID0gSTtcbkUoSiwgRy5wcm90b3R5cGUpO1xuSi5pc1B1cmVSZWFjdENvbXBvbmVudCA9ICEwO1xudmFyIEsgPSBBcnJheS5pc0FycmF5LFxuICAgIEwgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgIE0gPSB7XG4gIGN1cnJlbnQ6IG51bGxcbn0sXG4gICAgTiA9IHtcbiAga2V5OiAhMCxcbiAgcmVmOiAhMCxcbiAgX19zZWxmOiAhMCxcbiAgX19zb3VyY2U6ICEwXG59O1xuXG5mdW5jdGlvbiBPKGEsIGIsIGMpIHtcbiAgdmFyIGQsXG4gICAgICBlID0ge30sXG4gICAgICBmID0gbnVsbCxcbiAgICAgIGcgPSBudWxsO1xuICBpZiAobnVsbCAhPSBiKSBmb3IgKGQgaW4gdm9pZCAwICE9PSBiLnJlZiAmJiAoZyA9IGIucmVmKSwgdm9pZCAwICE9PSBiLmtleSAmJiAoZiA9IFwiXCIgKyBiLmtleSksIGIpIHtcbiAgICBMLmNhbGwoYiwgZCkgJiYgIU4uaGFzT3duUHJvcGVydHkoZCkgJiYgKGVbZF0gPSBiW2RdKTtcbiAgfVxuICB2YXIgaCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoMSA9PT0gaCkgZS5jaGlsZHJlbiA9IGM7ZWxzZSBpZiAoMSA8IGgpIHtcbiAgICBmb3IgKHZhciBrID0gQXJyYXkoaCksIG0gPSAwOyBtIDwgaDsgbSsrKSB7XG4gICAgICBrW21dID0gYXJndW1lbnRzW20gKyAyXTtcbiAgICB9XG5cbiAgICBlLmNoaWxkcmVuID0gaztcbiAgfVxuICBpZiAoYSAmJiBhLmRlZmF1bHRQcm9wcykgZm9yIChkIGluIGggPSBhLmRlZmF1bHRQcm9wcywgaCkge1xuICAgIHZvaWQgMCA9PT0gZVtkXSAmJiAoZVtkXSA9IGhbZF0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IGwsXG4gICAgdHlwZTogYSxcbiAgICBrZXk6IGYsXG4gICAgcmVmOiBnLFxuICAgIHByb3BzOiBlLFxuICAgIF9vd25lcjogTS5jdXJyZW50XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVhKGEsIGIpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogbCxcbiAgICB0eXBlOiBhLnR5cGUsXG4gICAga2V5OiBiLFxuICAgIHJlZjogYS5yZWYsXG4gICAgcHJvcHM6IGEucHJvcHMsXG4gICAgX293bmVyOiBhLl9vd25lclxuICB9O1xufVxuXG5mdW5jdGlvbiBQKGEpIHtcbiAgcmV0dXJuIFwib2JqZWN0XCIgPT09IF90eXBlb2YoYSkgJiYgbnVsbCAhPT0gYSAmJiBhLiQkdHlwZW9mID09PSBsO1xufVxuXG5mdW5jdGlvbiBlc2NhcGUoYSkge1xuICB2YXIgYiA9IHtcbiAgICBcIj1cIjogXCI9MFwiLFxuICAgIFwiOlwiOiBcIj0yXCJcbiAgfTtcbiAgcmV0dXJuIFwiJFwiICsgYS5yZXBsYWNlKC9bPTpdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGJbY107XG4gIH0pO1xufVxuXG52YXIgUSA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIFIoYSwgYikge1xuICByZXR1cm4gXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiBudWxsICE9PSBhICYmIG51bGwgIT0gYS5rZXkgPyBlc2NhcGUoXCJcIiArIGEua2V5KSA6IGIudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBTKGEsIGIsIGMsIGQsIGUpIHtcbiAgdmFyIGYgPSBfdHlwZW9mKGEpO1xuXG4gIGlmIChcInVuZGVmaW5lZFwiID09PSBmIHx8IFwiYm9vbGVhblwiID09PSBmKSBhID0gbnVsbDtcbiAgdmFyIGcgPSAhMTtcbiAgaWYgKG51bGwgPT09IGEpIGcgPSAhMDtlbHNlIHN3aXRjaCAoZikge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBnID0gITA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHN3aXRjaCAoYS4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIGw6XG4gICAgICAgIGNhc2UgbjpcbiAgICAgICAgICBnID0gITA7XG4gICAgICB9XG5cbiAgfVxuICBpZiAoZykgcmV0dXJuIGcgPSBhLCBlID0gZShnKSwgYSA9IFwiXCIgPT09IGQgPyBcIi5cIiArIFIoZywgMCkgOiBkLCBLKGUpID8gKGMgPSBcIlwiLCBudWxsICE9IGEgJiYgKGMgPSBhLnJlcGxhY2UoUSwgXCIkJi9cIikgKyBcIi9cIiksIFMoZSwgYiwgYywgXCJcIiwgZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gbTtcbiAgfSkpIDogbnVsbCAhPSBlICYmIChQKGUpICYmIChlID0gZWEoZSwgYyArICghZS5rZXkgfHwgZyAmJiBnLmtleSA9PT0gZS5rZXkgPyBcIlwiIDogKFwiXCIgKyBlLmtleSkucmVwbGFjZShRLCBcIiQmL1wiKSArIFwiL1wiKSArIGEpKSwgYi5wdXNoKGUpKSwgMTtcbiAgZyA9IDA7XG4gIGQgPSBcIlwiID09PSBkID8gXCIuXCIgOiBkICsgXCI6XCI7XG4gIGlmIChLKGEpKSBmb3IgKHZhciBoID0gMDsgaCA8IGEubGVuZ3RoOyBoKyspIHtcbiAgICBmID0gYVtoXTtcbiAgICB2YXIgayA9IGQgKyBSKGYsIGgpO1xuICAgIGcgKz0gUyhmLCBiLCBjLCBrLCBlKTtcbiAgfSBlbHNlIGlmIChrID0gZGEoYSksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGspIGZvciAoYSA9IGsuY2FsbChhKSwgaCA9IDA7ICEoZiA9IGEubmV4dCgpKS5kb25lOykge1xuICAgIGYgPSBmLnZhbHVlLCBrID0gZCArIFIoZiwgaCsrKSwgZyArPSBTKGYsIGIsIGMsIGssIGUpO1xuICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IGYpIHRocm93IGIgPSBTdHJpbmcoYSksIEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBiID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKSArIFwifVwiIDogYikgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIik7XG4gIHJldHVybiBnO1xufVxuXG5mdW5jdGlvbiBUKGEsIGIsIGMpIHtcbiAgaWYgKG51bGwgPT0gYSkgcmV0dXJuIGE7XG4gIHZhciBkID0gW10sXG4gICAgICBlID0gMDtcbiAgUyhhLCBkLCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBiLmNhbGwoYywgZiwgZSsrKTtcbiAgfSk7XG4gIHJldHVybiBkO1xufVxuXG5mdW5jdGlvbiBmYShhKSB7XG4gIGlmICgtMSA9PT0gYS5fc3RhdHVzKSB7XG4gICAgdmFyIGIgPSBhLl9yZXN1bHQ7XG4gICAgYiA9IGIoKTtcbiAgICBiLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICgwID09PSBhLl9zdGF0dXMgfHwgLTEgPT09IGEuX3N0YXR1cykgYS5fc3RhdHVzID0gMSwgYS5fcmVzdWx0ID0gYztcbiAgICB9LCBmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKDAgPT09IGEuX3N0YXR1cyB8fCAtMSA9PT0gYS5fc3RhdHVzKSBhLl9zdGF0dXMgPSAyLCBhLl9yZXN1bHQgPSBjO1xuICAgIH0pO1xuICAgIC0xID09PSBhLl9zdGF0dXMgJiYgKGEuX3N0YXR1cyA9IDAsIGEuX3Jlc3VsdCA9IGIpO1xuICB9XG5cbiAgaWYgKDEgPT09IGEuX3N0YXR1cykgcmV0dXJuIGEuX3Jlc3VsdC5kZWZhdWx0O1xuICB0aHJvdyBhLl9yZXN1bHQ7XG59XG5cbnZhciBVID0ge1xuICBjdXJyZW50OiBudWxsXG59O1xuXG5mdW5jdGlvbiBoYSgpIHtcbiAgcmV0dXJuIG5ldyBXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIFYoKSB7XG4gIHJldHVybiB7XG4gICAgczogMCxcbiAgICB2OiB2b2lkIDAsXG4gICAgbzogbnVsbCxcbiAgICBwOiBudWxsXG4gIH07XG59XG5cbnZhciBXID0ge1xuICBjdXJyZW50OiBudWxsXG59LFxuICAgIFggPSB7XG4gIHRyYW5zaXRpb246IG51bGxcbn0sXG4gICAgWSA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogVyxcbiAgUmVhY3RDdXJyZW50Q2FjaGU6IFUsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBYLFxuICBSZWFjdEN1cnJlbnRPd25lcjogTSxcbiAgQ29udGV4dFJlZ2lzdHJ5OiB7fVxufSxcbiAgICBaID0gWS5Db250ZXh0UmVnaXN0cnk7XG5leHBvcnRzLkNoaWxkcmVuID0ge1xuICBtYXA6IFQsXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goYSwgYiwgYykge1xuICAgIFQoYSwgZnVuY3Rpb24gKCkge1xuICAgICAgYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGMpO1xuICB9LFxuICBjb3VudDogZnVuY3Rpb24gY291bnQoYSkge1xuICAgIHZhciBiID0gMDtcbiAgICBUKGEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGIrKztcbiAgICB9KTtcbiAgICByZXR1cm4gYjtcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShhKSB7XG4gICAgcmV0dXJuIFQoYSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0pIHx8IFtdO1xuICB9LFxuICBvbmx5OiBmdW5jdGlvbiBvbmx5KGEpIHtcbiAgICBpZiAoIVAoYSkpIHRocm93IEVycm9yKFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIpO1xuICAgIHJldHVybiBhO1xuICB9XG59O1xuZXhwb3J0cy5Db21wb25lbnQgPSBHO1xuZXhwb3J0cy5GcmFnbWVudCA9IHA7XG5leHBvcnRzLlByb2ZpbGVyID0gcjtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IEk7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBxO1xuZXhwb3J0cy5TdXNwZW5zZSA9IHg7XG5leHBvcnRzLlN1c3BlbnNlTGlzdCA9IHk7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gWTtcblxuZXhwb3J0cy5jYWNoZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGIgPSBVLmN1cnJlbnQ7XG4gICAgaWYgKCFiKSByZXR1cm4gYS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHZhciBjID0gYi5nZXRDYWNoZUZvclR5cGUoaGEpO1xuICAgIGIgPSBjLmdldChhKTtcbiAgICB2b2lkIDAgPT09IGIgJiYgKGIgPSBWKCksIGMuc2V0KGEsIGIpKTtcbiAgICBjID0gMDtcblxuICAgIGZvciAodmFyIGQgPSBhcmd1bWVudHMubGVuZ3RoOyBjIDwgZDsgYysrKSB7XG4gICAgICB2YXIgZSA9IGFyZ3VtZW50c1tjXTtcblxuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGUgfHwgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihlKSAmJiBudWxsICE9PSBlKSB7XG4gICAgICAgIHZhciBmID0gYi5vO1xuICAgICAgICBudWxsID09PSBmICYmIChiLm8gPSBmID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIGIgPSBmLmdldChlKTtcbiAgICAgICAgdm9pZCAwID09PSBiICYmIChiID0gVigpLCBmLnNldChlLCBiKSk7XG4gICAgICB9IGVsc2UgZiA9IGIucCwgbnVsbCA9PT0gZiAmJiAoYi5wID0gZiA9IG5ldyBNYXAoKSksIGIgPSBmLmdldChlKSwgdm9pZCAwID09PSBiICYmIChiID0gVigpLCBmLnNldChlLCBiKSk7XG4gICAgfVxuXG4gICAgaWYgKDEgPT09IGIucykgcmV0dXJuIGIudjtcbiAgICBpZiAoMiA9PT0gYi5zKSB0aHJvdyBiLnY7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGcgPSBhLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBjID0gYjtcbiAgICAgIGMucyA9IDE7XG4gICAgICByZXR1cm4gYy52ID0gZztcbiAgICB9IGNhdGNoIChoKSB7XG4gICAgICB0aHJvdyBnID0gYiwgZy5zID0gMiwgZy52ID0gaCwgaDtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gIGlmIChudWxsID09PSBhIHx8IHZvaWQgMCA9PT0gYSkgdGhyb3cgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGEgKyBcIi5cIik7XG4gIHZhciBkID0gRSh7fSwgYS5wcm9wcyksXG4gICAgICBlID0gYS5rZXksXG4gICAgICBmID0gYS5yZWYsXG4gICAgICBnID0gYS5fb3duZXI7XG5cbiAgaWYgKG51bGwgIT0gYikge1xuICAgIHZvaWQgMCAhPT0gYi5yZWYgJiYgKGYgPSBiLnJlZiwgZyA9IE0uY3VycmVudCk7XG4gICAgdm9pZCAwICE9PSBiLmtleSAmJiAoZSA9IFwiXCIgKyBiLmtleSk7XG4gICAgaWYgKGEudHlwZSAmJiBhLnR5cGUuZGVmYXVsdFByb3BzKSB2YXIgaCA9IGEudHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKGsgaW4gYikge1xuICAgICAgTC5jYWxsKGIsIGspICYmICFOLmhhc093blByb3BlcnR5KGspICYmIChkW2tdID0gdm9pZCAwID09PSBiW2tdICYmIHZvaWQgMCAhPT0gaCA/IGhba10gOiBiW2tdKTtcbiAgICB9XG4gIH1cblxuICB2YXIgayA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoMSA9PT0gaykgZC5jaGlsZHJlbiA9IGM7ZWxzZSBpZiAoMSA8IGspIHtcbiAgICBoID0gQXJyYXkoayk7XG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IGs7IG0rKykge1xuICAgICAgaFttXSA9IGFyZ3VtZW50c1ttICsgMl07XG4gICAgfVxuXG4gICAgZC5jaGlsZHJlbiA9IGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogbCxcbiAgICB0eXBlOiBhLnR5cGUsXG4gICAga2V5OiBlLFxuICAgIHJlZjogZixcbiAgICBwcm9wczogZCxcbiAgICBfb3duZXI6IGdcbiAgfTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSB7XG4gICAgJCR0eXBlb2Y6IHUsXG4gICAgX2N1cnJlbnRWYWx1ZTogYSxcbiAgICBfY3VycmVudFZhbHVlMjogYSxcbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGwsXG4gICAgX2RlZmF1bHRWYWx1ZTogbnVsbCxcbiAgICBfZ2xvYmFsTmFtZTogbnVsbFxuICB9O1xuICBhLlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiB0LFxuICAgIF9jb250ZXh0OiBhXG4gIH07XG4gIHJldHVybiBhLkNvbnN1bWVyID0gYTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IE87XG5cbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uIChhKSB7XG4gIHZhciBiID0gTy5iaW5kKG51bGwsIGEpO1xuICBiLnR5cGUgPSBhO1xuICByZXR1cm4gYjtcbn07XG5cbmV4cG9ydHMuY3JlYXRlUmVmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlU2VydmVyQ29udGV4dCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjID0gITA7XG5cbiAgaWYgKCFaW2FdKSB7XG4gICAgYyA9ICExO1xuICAgIHZhciBkID0ge1xuICAgICAgJCR0eXBlb2Y6IHYsXG4gICAgICBfY3VycmVudFZhbHVlOiBiLFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IGIsXG4gICAgICBfZGVmYXVsdFZhbHVlOiBiLFxuICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgIF9nbG9iYWxOYW1lOiBhXG4gICAgfTtcbiAgICBkLlByb3ZpZGVyID0ge1xuICAgICAgJCR0eXBlb2Y6IHQsXG4gICAgICBfY29udGV4dDogZFxuICAgIH07XG4gICAgWlthXSA9IGQ7XG4gIH1cblxuICBkID0gWlthXTtcbiAgaWYgKGQuX2RlZmF1bHRWYWx1ZSA9PT0gQikgZC5fZGVmYXVsdFZhbHVlID0gYiwgZC5fY3VycmVudFZhbHVlID09PSBCICYmIChkLl9jdXJyZW50VmFsdWUgPSBiKSwgZC5fY3VycmVudFZhbHVlMiA9PT0gQiAmJiAoZC5fY3VycmVudFZhbHVlMiA9IGIpO2Vsc2UgaWYgKGMpIHRocm93IEVycm9yKFwiU2VydmVyQ29udGV4dDogXCIgKyBhICsgXCIgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICByZXR1cm4gZDtcbn07XG5cbmV4cG9ydHMuZXhwZXJpbWVudGFsX3VzZUVmZmVjdEV2ZW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VFZmZlY3RFdmVudChhKTtcbn07XG5cbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IHcsXG4gICAgcmVuZGVyOiBhXG4gIH07XG59O1xuXG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gUDtcblxuZXhwb3J0cy5sYXp5ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogQSxcbiAgICBfcGF5bG9hZDoge1xuICAgICAgX3N0YXR1czogLTEsXG4gICAgICBfcmVzdWx0OiBhXG4gICAgfSxcbiAgICBfaW5pdDogZmFcbiAgfTtcbn07XG5cbmV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IHosXG4gICAgdHlwZTogYSxcbiAgICBjb21wYXJlOiB2b2lkIDAgPT09IGIgPyBudWxsIDogYlxuICB9O1xufTtcblxuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoYSkge1xuICB2YXIgYiA9IFgudHJhbnNpdGlvbjtcbiAgWC50cmFuc2l0aW9uID0ge307XG5cbiAgdHJ5IHtcbiAgICBhKCk7XG4gIH0gZmluYWxseSB7XG4gICAgWC50cmFuc2l0aW9uID0gYjtcbiAgfVxufTtcblxuZXhwb3J0cy51bnN0YWJsZV9DYWNoZSA9IGNhO1xuZXhwb3J0cy51bnN0YWJsZV9EZWJ1Z1RyYWNpbmdNb2RlID0gYWE7XG5leHBvcnRzLnVuc3RhYmxlX09mZnNjcmVlbiA9IGJhO1xuXG5leHBvcnRzLnVuc3RhYmxlX2FjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgRXJyb3IoXCJhY3QoLi4uKSBpcyBub3Qgc3VwcG9ydGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzIG9mIFJlYWN0LlwiKTtcbn07XG5cbmV4cG9ydHMudW5zdGFibGVfZ2V0Q2FjaGVGb3JUeXBlID0gZnVuY3Rpb24gKGEpIHtcbiAgdmFyIGIgPSBVLmN1cnJlbnQ7XG4gIHJldHVybiBiID8gYi5nZXRDYWNoZUZvclR5cGUoYSkgOiBhKCk7XG59O1xuXG5leHBvcnRzLnVuc3RhYmxlX2dldENhY2hlU2lnbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYSA9IFUuY3VycmVudDtcbiAgcmV0dXJuIGEgPyBhLmdldENhY2hlU2lnbmFsKCkgOiAoYSA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgYS5hYm9ydChFcnJvcihcIlRoaXMgQ2FjaGVTaWduYWwgd2FzIHJlcXVlc3RlZCBvdXRzaWRlIFJlYWN0IHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgaW1tZWRpYXRlbHkgYWJvcnRlZC5cIikpLCBhLnNpZ25hbCk7XG59O1xuXG5leHBvcnRzLnVuc3RhYmxlX3VzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VDYWNoZVJlZnJlc2goKTtcbn07XG5cbmV4cG9ydHMudW5zdGFibGVfdXNlTWVtb0NhY2hlID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VNZW1vQ2FjaGUoYSk7XG59O1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlKGEpO1xufTtcblxuZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlQ2FsbGJhY2soYSwgYik7XG59O1xuXG5leHBvcnRzLnVzZUNvbnRleHQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZUNvbnRleHQoYSk7XG59O1xuXG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuZXhwb3J0cy51c2VEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VEZWZlcnJlZFZhbHVlKGEpO1xufTtcblxuZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZUVmZmVjdChhLCBiKTtcbn07XG5cbmV4cG9ydHMudXNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlSWQoKTtcbn07XG5cbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlSW1wZXJhdGl2ZUhhbmRsZShhLCBiLCBjKTtcbn07XG5cbmV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VJbnNlcnRpb25FZmZlY3QoYSwgYik7XG59O1xuXG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlTGF5b3V0RWZmZWN0KGEsIGIpO1xufTtcblxuZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VNZW1vKGEsIGIpO1xufTtcblxuZXhwb3J0cy51c2VSZWR1Y2VyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgcmV0dXJuIFcuY3VycmVudC51c2VSZWR1Y2VyKGEsIGIsIGMpO1xufTtcblxuZXhwb3J0cy51c2VSZWYgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZVJlZihhKTtcbn07XG5cbmV4cG9ydHMudXNlU3RhdGUgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gVy5jdXJyZW50LnVzZVN0YXRlKGEpO1xufTtcblxuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlU3luY0V4dGVybmFsU3RvcmUoYSwgYiwgYyk7XG59O1xuXG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBXLmN1cnJlbnQudXNlVHJhbnNpdGlvbigpO1xufTtcblxuZXhwb3J0cy52ZXJzaW9uID0gXCIxOC4zLjAtZXhwZXJpbWVudGFsLTdmOGM1MDFmNi0yMDIzMDQyMFwiO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNvbm5lY3RUb0RldlRvb2xzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjb25uZWN0VG9EZXZUb29sczsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZXZlbnRzLmpzXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxpc3RlbmVyc01hcFwiLCBuZXcgTWFwKCkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50RW1pdHRlciwgW3tcbiAgICBrZXk6IFwiYWRkTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNNYXAuZ2V0KGV2ZW50KTtcblxuICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzTWFwLnNldChldmVudCwgW2xpc3RlbmVyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc01hcC5nZXQoZXZlbnQpO1xuXG4gICAgICBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBObyBuZWVkIHRvIGNsb25lIG9yIHRyeS9jYXRjaFxuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1swXTtcbiAgICAgICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGlkVGhyb3cgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgICAgIHZhciBjbG9uZWRMaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGxpc3RlbmVycyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9saXN0ZW5lciA9IGNsb25lZExpc3RlbmVyc1tpXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgX2xpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlkVGhyb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGlkVGhyb3cpIHtcbiAgICAgICAgICAgIHRocm93IGNhdWdodEVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBbGxMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNNYXAuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNNYXAuZ2V0KGV2ZW50KTtcblxuICAgICAgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKTtcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC9Vc2Vycy9ob3h5L3JlcG9zL3JlYWN0L25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanNcbnZhciBsb2Rhc2hfdGhyb3R0bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBsb2Rhc2hfdGhyb3R0bGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX3Rocm90dGxlKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2NvbnN0YW50cy5qc1xudmFyIGNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zdG9yYWdlLmpzXG52YXIgc3RvcmFnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC9Vc2Vycy9ob3h5L3JlcG9zL3JlYWN0L25vZGVfbW9kdWxlcy9tZW1vaXplLW9uZS9lc20vaW5kZXguanNcbnZhciBzaW1wbGVJc0VxdWFsID0gZnVuY3Rpb24gc2ltcGxlSXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXNtID0gKGZ1bmN0aW9uIChyZXN1bHRGbikge1xuICB2YXIgaXNFcXVhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc2ltcGxlSXNFcXVhbDtcbiAgdmFyIGxhc3RUaGlzID0gdm9pZCAwO1xuICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgdmFyIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG4gIHZhciBjYWxsZWRPbmNlID0gZmFsc2U7XG5cbiAgdmFyIGlzTmV3QXJnRXF1YWxUb0xhc3QgPSBmdW5jdGlvbiBpc05ld0FyZ0VxdWFsVG9MYXN0KG5ld0FyZywgaW5kZXgpIHtcbiAgICByZXR1cm4gaXNFcXVhbChuZXdBcmcsIGxhc3RBcmdzW2luZGV4XSk7XG4gIH07XG5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIHJlc3VsdCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbmV3QXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbmV3QXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBuZXdBcmdzLmxlbmd0aCA9PT0gbGFzdEFyZ3MubGVuZ3RoICYmIG5ld0FyZ3MuZXZlcnkoaXNOZXdBcmdFcXVhbFRvTGFzdCkpIHtcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cblxuICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG4gICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy91dGlscy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBHZXQgdGhlIHdpbmRvdyBvYmplY3QgZm9yIHRoZSBkb2N1bWVudCB0aGF0IGEgbm9kZSBiZWxvbmdzIHRvLFxuLy8gb3IgcmV0dXJuIG51bGwgaWYgaXQgY2Fubm90IGJlIGZvdW5kIChub2RlIG5vdCBhdHRhY2hlZCB0byBET00sXG4vLyBldGMpLlxuZnVuY3Rpb24gZ2V0T3duZXJXaW5kb3cobm9kZSkge1xuICBpZiAoIW5vZGUub3duZXJEb2N1bWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcbn0gLy8gR2V0IHRoZSBpZnJhbWUgY29udGFpbmluZyBhIG5vZGUsIG9yIHJldHVybiBudWxsIGlmIGl0IGNhbm5vdFxuLy8gYmUgZm91bmQgKG5vZGUgbm90IHdpdGhpbiBpZnJhbWUsIGV0YykuXG5cbmZ1bmN0aW9uIGdldE93bmVySWZyYW1lKG5vZGUpIHtcbiAgdmFyIG5vZGVXaW5kb3cgPSBnZXRPd25lcldpbmRvdyhub2RlKTtcblxuICBpZiAobm9kZVdpbmRvdykge1xuICAgIHJldHVybiBub2RlV2luZG93LmZyYW1lRWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXQgYSBib3VuZGluZyBjbGllbnQgcmVjdCBmb3IgYSBub2RlLCB3aXRoIGFuXG4vLyBvZmZzZXQgYWRkZWQgdG8gY29tcGVuc2F0ZSBmb3IgaXRzIGJvcmRlci5cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0V2l0aEJvcmRlck9mZnNldChub2RlKSB7XG4gIHZhciBkaW1lbnNpb25zID0gZ2V0RWxlbWVudERpbWVuc2lvbnMobm9kZSk7XG4gIHJldHVybiBtZXJnZVJlY3RPZmZzZXRzKFtub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB7XG4gICAgdG9wOiBkaW1lbnNpb25zLmJvcmRlclRvcCxcbiAgICBsZWZ0OiBkaW1lbnNpb25zLmJvcmRlckxlZnQsXG4gICAgYm90dG9tOiBkaW1lbnNpb25zLmJvcmRlckJvdHRvbSxcbiAgICByaWdodDogZGltZW5zaW9ucy5ib3JkZXJSaWdodCxcbiAgICAvLyBUaGlzIHdpZHRoIGFuZCBoZWlnaHQgd29uJ3QgZ2V0IHVzZWQgYnkgbWVyZ2VSZWN0T2Zmc2V0cyAoc2luY2UgdGhpc1xuICAgIC8vIGlzIG5vdCB0aGUgZmlyc3QgcmVjdCBpbiB0aGUgYXJyYXkpLCBidXQgd2Ugc2V0IHRoZW0gc28gdGhhdCB0aGlzXG4gICAgLy8gb2JqZWN0IHR5cGUgY2hlY2tzIGFzIGEgQ2xpZW50UmVjdC5cbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfV0pO1xufSAvLyBBZGQgdG9nZXRoZXIgdGhlIHRvcCwgbGVmdCwgYm90dG9tLCBhbmQgcmlnaHQgcHJvcGVydGllcyBvZlxuLy8gZWFjaCBDbGllbnRSZWN0LCBidXQga2VlcCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZmlyc3Qgb25lLlxuXG5mdW5jdGlvbiBtZXJnZVJlY3RPZmZzZXRzKHJlY3RzKSB7XG4gIHJldHVybiByZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzUmVjdCwgcmVjdCkge1xuICAgIGlmIChwcmV2aW91c1JlY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcHJldmlvdXNSZWN0LnRvcCArIHJlY3QudG9wLFxuICAgICAgbGVmdDogcHJldmlvdXNSZWN0LmxlZnQgKyByZWN0LmxlZnQsXG4gICAgICB3aWR0aDogcHJldmlvdXNSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBwcmV2aW91c1JlY3QuaGVpZ2h0LFxuICAgICAgYm90dG9tOiBwcmV2aW91c1JlY3QuYm90dG9tICsgcmVjdC5ib3R0b20sXG4gICAgICByaWdodDogcHJldmlvdXNSZWN0LnJpZ2h0ICsgcmVjdC5yaWdodFxuICAgIH07XG4gIH0pO1xufSAvLyBDYWxjdWxhdGUgYSBib3VuZGluZ0NsaWVudFJlY3QgZm9yIGEgbm9kZSByZWxhdGl2ZSB0byBib3VuZGFyeVdpbmRvdyxcbi8vIHRha2luZyBpbnRvIGFjY291bnQgYW55IG9mZnNldHMgY2F1c2VkIGJ5IGludGVybWVkaWF0ZSBpZnJhbWVzLlxuXG5mdW5jdGlvbiBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSwgYm91bmRhcnlXaW5kb3cpIHtcbiAgdmFyIG93bmVySWZyYW1lID0gZ2V0T3duZXJJZnJhbWUobm9kZSk7XG5cbiAgaWYgKG93bmVySWZyYW1lICYmIG93bmVySWZyYW1lICE9PSBib3VuZGFyeVdpbmRvdykge1xuICAgIHZhciByZWN0cyA9IFtub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXTtcbiAgICB2YXIgY3VycmVudElmcmFtZSA9IG93bmVySWZyYW1lO1xuICAgIHZhciBvbmx5T25lTW9yZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRJZnJhbWUpIHtcbiAgICAgIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0V2l0aEJvcmRlck9mZnNldChjdXJyZW50SWZyYW1lKTtcbiAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICBjdXJyZW50SWZyYW1lID0gZ2V0T3duZXJJZnJhbWUoY3VycmVudElmcmFtZSk7XG5cbiAgICAgIGlmIChvbmx5T25lTW9yZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gV2UgZG9uJ3Qgd2FudCB0byBjYWxjdWxhdGUgaWZyYW1lIG9mZnNldHMgdXB3YXJkcyBiZXlvbmRcbiAgICAgIC8vIHRoZSBpZnJhbWUgY29udGFpbmluZyB0aGUgYm91bmRhcnlXaW5kb3csIGJ1dCB3ZVxuICAgICAgLy8gbmVlZCB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgYm91bmRhcnlXaW5kb3cuXG5cblxuICAgICAgaWYgKGN1cnJlbnRJZnJhbWUgJiYgZ2V0T3duZXJXaW5kb3coY3VycmVudElmcmFtZSkgPT09IGJvdW5kYXJ5V2luZG93KSB7XG4gICAgICAgIG9ubHlPbmVNb3JlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VSZWN0T2Zmc2V0cyhyZWN0cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnREaW1lbnNpb25zKGRvbUVsZW1lbnQpIHtcbiAgdmFyIGNhbGN1bGF0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIGJvcmRlckxlZnQ6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSxcbiAgICBib3JkZXJSaWdodDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgsIDEwKSxcbiAgICBib3JkZXJUb3A6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApLFxuICAgIGJvcmRlckJvdHRvbTogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCksXG4gICAgbWFyZ2luTGVmdDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLm1hcmdpbkxlZnQsIDEwKSxcbiAgICBtYXJnaW5SaWdodDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLm1hcmdpblJpZ2h0LCAxMCksXG4gICAgbWFyZ2luVG9wOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luVG9wLCAxMCksXG4gICAgbWFyZ2luQm90dG9tOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luQm90dG9tLCAxMCksXG4gICAgcGFkZGluZ0xlZnQ6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5wYWRkaW5nTGVmdCwgMTApLFxuICAgIHBhZGRpbmdSaWdodDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdSaWdodCwgMTApLFxuICAgIHBhZGRpbmdUb3A6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5wYWRkaW5nVG9wLCAxMCksXG4gICAgcGFkZGluZ0JvdHRvbTogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKVxuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL0hpZ2hsaWdodGVyL092ZXJsYXkuanNcbmZ1bmN0aW9uIE92ZXJsYXlfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBPdmVybGF5X2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBPdmVybGF5X2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgT3ZlcmxheV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgT3ZlcmxheV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIE92ZXJsYXlfYXNzaWduID0gT2JqZWN0LmFzc2lnbjsgLy8gTm90ZSB0aGF0IHRoZSBPdmVybGF5IGNvbXBvbmVudHMgYXJlIG5vdCBhZmZlY3RlZCBieSB0aGUgYWN0aXZlIFRoZW1lLFxuLy8gYmVjYXVzZSB0aGV5IGhpZ2hsaWdodCBlbGVtZW50cyBpbiB0aGUgbWFpbiBDaHJvbWUgd2luZG93IChvdXRzaWRlIG9mIGRldnRvb2xzKS5cbi8vIFRoZSBjb2xvcnMgYmVsb3cgd2VyZSBjaG9zZW4gdG8gcm91Z2hseSBtYXRjaCB0aG9zZSB1c2VkIGJ5IENocm9tZSBkZXZ0b29scy5cblxudmFyIE92ZXJsYXlSZWN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3ZlcmxheVJlY3QoZG9jLCBjb250YWluZXIpIHtcbiAgICBPdmVybGF5X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE92ZXJsYXlSZWN0KTtcblxuICAgIHRoaXMubm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmJvcmRlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5jb250ZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuYm9yZGVyLnN0eWxlLmJvcmRlckNvbG9yID0gb3ZlcmxheVN0eWxlcy5ib3JkZXI7XG4gICAgdGhpcy5wYWRkaW5nLnN0eWxlLmJvcmRlckNvbG9yID0gb3ZlcmxheVN0eWxlcy5wYWRkaW5nO1xuICAgIHRoaXMuY29udGVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvdmVybGF5U3R5bGVzLmJhY2tncm91bmQ7XG4gICAgT3ZlcmxheV9hc3NpZ24odGhpcy5ub2RlLnN0eWxlLCB7XG4gICAgICBib3JkZXJDb2xvcjogb3ZlcmxheVN0eWxlcy5tYXJnaW4sXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJ1xuICAgIH0pO1xuICAgIHRoaXMubm9kZS5zdHlsZS56SW5kZXggPSAnMTAwMDAwMDAnO1xuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmJvcmRlcik7XG4gICAgdGhpcy5ib3JkZXIuYXBwZW5kQ2hpbGQodGhpcy5wYWRkaW5nKTtcbiAgICB0aGlzLnBhZGRpbmcuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgfVxuXG4gIE92ZXJsYXlfY3JlYXRlQ2xhc3MoT3ZlcmxheVJlY3QsIFt7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAodGhpcy5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShib3gsIGRpbXMpIHtcbiAgICAgIGJveFdyYXAoZGltcywgJ21hcmdpbicsIHRoaXMubm9kZSk7XG4gICAgICBib3hXcmFwKGRpbXMsICdib3JkZXInLCB0aGlzLmJvcmRlcik7XG4gICAgICBib3hXcmFwKGRpbXMsICdwYWRkaW5nJywgdGhpcy5wYWRkaW5nKTtcbiAgICAgIE92ZXJsYXlfYXNzaWduKHRoaXMuY29udGVudC5zdHlsZSwge1xuICAgICAgICBoZWlnaHQ6IGJveC5oZWlnaHQgLSBkaW1zLmJvcmRlclRvcCAtIGRpbXMuYm9yZGVyQm90dG9tIC0gZGltcy5wYWRkaW5nVG9wIC0gZGltcy5wYWRkaW5nQm90dG9tICsgJ3B4JyxcbiAgICAgICAgd2lkdGg6IGJveC53aWR0aCAtIGRpbXMuYm9yZGVyTGVmdCAtIGRpbXMuYm9yZGVyUmlnaHQgLSBkaW1zLnBhZGRpbmdMZWZ0IC0gZGltcy5wYWRkaW5nUmlnaHQgKyAncHgnXG4gICAgICB9KTtcbiAgICAgIE92ZXJsYXlfYXNzaWduKHRoaXMubm9kZS5zdHlsZSwge1xuICAgICAgICB0b3A6IGJveC50b3AgLSBkaW1zLm1hcmdpblRvcCArICdweCcsXG4gICAgICAgIGxlZnQ6IGJveC5sZWZ0IC0gZGltcy5tYXJnaW5MZWZ0ICsgJ3B4J1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE92ZXJsYXlSZWN0O1xufSgpO1xuXG52YXIgT3ZlcmxheVRpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE92ZXJsYXlUaXAoZG9jLCBjb250YWluZXIpIHtcbiAgICBPdmVybGF5X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE92ZXJsYXlUaXApO1xuXG4gICAgdGhpcy50aXAgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgT3ZlcmxheV9hc3NpZ24odGhpcy50aXAuc3R5bGUsIHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhGbG93OiAncm93IG5vd3JhcCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzMzNzQwJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgICBmb250RmFtaWx5OiAnXCJTRk1vbm8tUmVndWxhclwiLCBDb25zb2xhcywgXCJMaWJlcmF0aW9uIE1vbm9cIiwgTWVubG8sIENvdXJpZXIsIG1vbm9zcGFjZScsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICBwYWRkaW5nOiAnM3B4IDVweCcsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICAgIH0pO1xuICAgIHRoaXMubmFtZVNwYW4gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRoaXMudGlwLmFwcGVuZENoaWxkKHRoaXMubmFtZVNwYW4pO1xuICAgIE92ZXJsYXlfYXNzaWduKHRoaXMubmFtZVNwYW4uc3R5bGUsIHtcbiAgICAgIGNvbG9yOiAnI2VlNzhlNicsXG4gICAgICBib3JkZXJSaWdodDogJzFweCBzb2xpZCAjYWFhYWFhJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJzAuNXJlbScsXG4gICAgICBtYXJnaW5SaWdodDogJzAuNXJlbSdcbiAgICB9KTtcbiAgICB0aGlzLmRpbVNwYW4gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRoaXMudGlwLmFwcGVuZENoaWxkKHRoaXMuZGltU3Bhbik7XG4gICAgT3ZlcmxheV9hc3NpZ24odGhpcy5kaW1TcGFuLnN0eWxlLCB7XG4gICAgICBjb2xvcjogJyNkN2Q3ZDcnXG4gICAgfSk7XG4gICAgdGhpcy50aXAuc3R5bGUuekluZGV4ID0gJzEwMDAwMDAwJztcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50aXApO1xuICB9XG5cbiAgT3ZlcmxheV9jcmVhdGVDbGFzcyhPdmVybGF5VGlwLCBbe1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgaWYgKHRoaXMudGlwLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy50aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnRpcCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGV4dChuYW1lLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLm5hbWVTcGFuLnRleHRDb250ZW50ID0gbmFtZTtcbiAgICAgIHRoaXMuZGltU3Bhbi50ZXh0Q29udGVudCA9IE1hdGgucm91bmQod2lkdGgpICsgJ3B4IMOXICcgKyBNYXRoLnJvdW5kKGhlaWdodCkgKyAncHgnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbihkaW1zLCBib3VuZHMpIHtcbiAgICAgIHZhciB0aXBSZWN0ID0gdGhpcy50aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgdGlwUG9zID0gZmluZFRpcFBvcyhkaW1zLCBib3VuZHMsIHtcbiAgICAgICAgd2lkdGg6IHRpcFJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGlwUmVjdC5oZWlnaHRcbiAgICAgIH0pO1xuICAgICAgT3ZlcmxheV9hc3NpZ24odGhpcy50aXAuc3R5bGUsIHRpcFBvcy5zdHlsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE92ZXJsYXlUaXA7XG59KCk7XG5cbnZhciBPdmVybGF5X092ZXJsYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPdmVybGF5KGFnZW50KSB7XG4gICAgT3ZlcmxheV9jbGFzc0NhbGxDaGVjayh0aGlzLCBPdmVybGF5KTtcblxuICAgIC8vIEZpbmQgdGhlIHJvb3Qgd2luZG93LCBiZWNhdXNlIG92ZXJsYXlzIGFyZSBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIGl0LlxuICAgIHZhciBjdXJyZW50V2luZG93ID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfVEFSR0VUX1dJTkRPV19fIHx8IHdpbmRvdztcbiAgICB0aGlzLndpbmRvdyA9IGN1cnJlbnRXaW5kb3c7IC8vIFdoZW4gb3BlbmVkIGluIHNoZWxscy9kZXYsIHRoZSB0b29sdGlwIHNob3VsZCBiZSBib3VuZCBieSB0aGUgYXBwIGlmcmFtZSwgbm90IGJ5IHRoZSB0b3Btb3N0IHdpbmRvdy5cblxuICAgIHZhciB0aXBCb3VuZHNXaW5kb3cgPSB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19UQVJHRVRfV0lORE9XX18gfHwgd2luZG93O1xuICAgIHRoaXMudGlwQm91bmRzV2luZG93ID0gdGlwQm91bmRzV2luZG93O1xuICAgIHZhciBkb2MgPSBjdXJyZW50V2luZG93LmRvY3VtZW50O1xuICAgIHRoaXMuY29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICcxMDAwMDAwMCc7XG4gICAgdGhpcy50aXAgPSBuZXcgT3ZlcmxheVRpcChkb2MsIHRoaXMuY29udGFpbmVyKTtcbiAgICB0aGlzLnJlY3RzID0gW107XG4gICAgdGhpcy5hZ2VudCA9IGFnZW50O1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgfVxuXG4gIE92ZXJsYXlfY3JlYXRlQ2xhc3MoT3ZlcmxheSwgW3tcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHRoaXMudGlwLnJlbW92ZSgpO1xuICAgICAgdGhpcy5yZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIHJlY3QucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVjdHMubGVuZ3RoID0gMDtcblxuICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc3BlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zcGVjdChub2RlcywgbmFtZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gV2UgY2FuJ3QgZ2V0IHRoZSBzaXplIG9mIHRleHQgbm9kZXMgb3IgY29tbWVudCBub2Rlcy4gUmVhY3QgYXMgb2YgdjE1XG4gICAgICAvLyBoZWF2aWx5IHVzZXMgY29tbWVudCBub2RlcyB0byBkZWxpbWl0IHRleHQuXG4gICAgICB2YXIgZWxlbWVudHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuICAgICAgfSk7XG5cbiAgICAgIHdoaWxlICh0aGlzLnJlY3RzLmxlbmd0aCA+IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucmVjdHMucG9wKCk7XG4gICAgICAgIHJlY3QucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpcy5yZWN0cy5sZW5ndGggPCBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZWN0cy5wdXNoKG5ldyBPdmVybGF5UmVjdCh0aGlzLndpbmRvdy5kb2N1bWVudCwgdGhpcy5jb250YWluZXIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dGVyQm94ID0ge1xuICAgICAgICB0b3A6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgcmlnaHQ6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgYm90dG9tOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIGxlZnQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBib3ggPSBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgX3RoaXMud2luZG93KTtcbiAgICAgICAgdmFyIGRpbXMgPSBnZXRFbGVtZW50RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICAgICAgb3V0ZXJCb3gudG9wID0gTWF0aC5taW4ob3V0ZXJCb3gudG9wLCBib3gudG9wIC0gZGltcy5tYXJnaW5Ub3ApO1xuICAgICAgICBvdXRlckJveC5yaWdodCA9IE1hdGgubWF4KG91dGVyQm94LnJpZ2h0LCBib3gubGVmdCArIGJveC53aWR0aCArIGRpbXMubWFyZ2luUmlnaHQpO1xuICAgICAgICBvdXRlckJveC5ib3R0b20gPSBNYXRoLm1heChvdXRlckJveC5ib3R0b20sIGJveC50b3AgKyBib3guaGVpZ2h0ICsgZGltcy5tYXJnaW5Cb3R0b20pO1xuICAgICAgICBvdXRlckJveC5sZWZ0ID0gTWF0aC5taW4ob3V0ZXJCb3gubGVmdCwgYm94LmxlZnQgLSBkaW1zLm1hcmdpbkxlZnQpO1xuICAgICAgICB2YXIgcmVjdCA9IF90aGlzLnJlY3RzW2luZGV4XTtcbiAgICAgICAgcmVjdC51cGRhdGUoYm94LCBkaW1zKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgbmFtZSA9IGVsZW1lbnRzWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBub2RlID0gZWxlbWVudHNbMF07XG4gICAgICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IHRoaXMuYWdlbnQuZ2V0QmVzdE1hdGNoaW5nUmVuZGVyZXJJbnRlcmZhY2Uobm9kZSk7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlKSB7XG4gICAgICAgICAgdmFyIGlkID0gcmVuZGVyZXJJbnRlcmZhY2UuZ2V0RmliZXJJREZvck5hdGl2ZShub2RlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IHJlbmRlcmVySW50ZXJmYWNlLmdldERpc3BsYXlOYW1lRm9yRmliZXJJRChpZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbmFtZSArPSAnIChpbiAnICsgb3duZXJOYW1lICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRpcC51cGRhdGVUZXh0KG5hbWUsIG91dGVyQm94LnJpZ2h0IC0gb3V0ZXJCb3gubGVmdCwgb3V0ZXJCb3guYm90dG9tIC0gb3V0ZXJCb3gudG9wKTtcbiAgICAgIHZhciB0aXBCb3VuZHMgPSBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy50aXBCb3VuZHNXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLndpbmRvdyk7XG4gICAgICB0aGlzLnRpcC51cGRhdGVQb3NpdGlvbih7XG4gICAgICAgIHRvcDogb3V0ZXJCb3gudG9wLFxuICAgICAgICBsZWZ0OiBvdXRlckJveC5sZWZ0LFxuICAgICAgICBoZWlnaHQ6IG91dGVyQm94LmJvdHRvbSAtIG91dGVyQm94LnRvcCxcbiAgICAgICAgd2lkdGg6IG91dGVyQm94LnJpZ2h0IC0gb3V0ZXJCb3gubGVmdFxuICAgICAgfSwge1xuICAgICAgICB0b3A6IHRpcEJvdW5kcy50b3AgKyB0aGlzLnRpcEJvdW5kc1dpbmRvdy5zY3JvbGxZLFxuICAgICAgICBsZWZ0OiB0aXBCb3VuZHMubGVmdCArIHRoaXMudGlwQm91bmRzV2luZG93LnNjcm9sbFgsXG4gICAgICAgIGhlaWdodDogdGhpcy50aXBCb3VuZHNXaW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgIHdpZHRoOiB0aGlzLnRpcEJvdW5kc1dpbmRvdy5pbm5lcldpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT3ZlcmxheTtcbn0oKTtcblxuXG5cbmZ1bmN0aW9uIGZpbmRUaXBQb3MoZGltcywgYm91bmRzLCB0aXBTaXplKSB7XG4gIHZhciB0aXBIZWlnaHQgPSBNYXRoLm1heCh0aXBTaXplLmhlaWdodCwgMjApO1xuICB2YXIgdGlwV2lkdGggPSBNYXRoLm1heCh0aXBTaXplLndpZHRoLCA2MCk7XG4gIHZhciBtYXJnaW4gPSA1O1xuICB2YXIgdG9wO1xuXG4gIGlmIChkaW1zLnRvcCArIGRpbXMuaGVpZ2h0ICsgdGlwSGVpZ2h0IDw9IGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KSB7XG4gICAgaWYgKGRpbXMudG9wICsgZGltcy5oZWlnaHQgPCBib3VuZHMudG9wICsgMCkge1xuICAgICAgdG9wID0gYm91bmRzLnRvcCArIG1hcmdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gZGltcy50b3AgKyBkaW1zLmhlaWdodCArIG1hcmdpbjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGltcy50b3AgLSB0aXBIZWlnaHQgPD0gYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQpIHtcbiAgICBpZiAoZGltcy50b3AgLSB0aXBIZWlnaHQgLSBtYXJnaW4gPCBib3VuZHMudG9wICsgbWFyZ2luKSB7XG4gICAgICB0b3AgPSBib3VuZHMudG9wICsgbWFyZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSBkaW1zLnRvcCAtIHRpcEhlaWdodCAtIG1hcmdpbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQgLSB0aXBIZWlnaHQgLSBtYXJnaW47XG4gIH1cblxuICB2YXIgbGVmdCA9IGRpbXMubGVmdCArIG1hcmdpbjtcblxuICBpZiAoZGltcy5sZWZ0IDwgYm91bmRzLmxlZnQpIHtcbiAgICBsZWZ0ID0gYm91bmRzLmxlZnQgKyBtYXJnaW47XG4gIH1cblxuICBpZiAoZGltcy5sZWZ0ICsgdGlwV2lkdGggPiBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCkge1xuICAgIGxlZnQgPSBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIHRpcFdpZHRoIC0gbWFyZ2luO1xuICB9XG5cbiAgdG9wICs9ICdweCc7XG4gIGxlZnQgKz0gJ3B4JztcbiAgcmV0dXJuIHtcbiAgICBzdHlsZToge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBib3hXcmFwKGRpbXMsIHdoYXQsIG5vZGUpIHtcbiAgT3ZlcmxheV9hc3NpZ24obm9kZS5zdHlsZSwge1xuICAgIGJvcmRlclRvcFdpZHRoOiBkaW1zW3doYXQgKyAnVG9wJ10gKyAncHgnLFxuICAgIGJvcmRlckxlZnRXaWR0aDogZGltc1t3aGF0ICsgJ0xlZnQnXSArICdweCcsXG4gICAgYm9yZGVyUmlnaHRXaWR0aDogZGltc1t3aGF0ICsgJ1JpZ2h0J10gKyAncHgnLFxuICAgIGJvcmRlckJvdHRvbVdpZHRoOiBkaW1zW3doYXQgKyAnQm90dG9tJ10gKyAncHgnLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnXG4gIH0pO1xufVxuXG52YXIgb3ZlcmxheVN0eWxlcyA9IHtcbiAgYmFja2dyb3VuZDogJ3JnYmEoMTIwLCAxNzAsIDIxMCwgMC43KScsXG4gIHBhZGRpbmc6ICdyZ2JhKDc3LCAyMDAsIDAsIDAuMyknLFxuICBtYXJnaW46ICdyZ2JhKDI1NSwgMTU1LCAwLCAwLjMpJyxcbiAgYm9yZGVyOiAncmdiYSgyNTUsIDIwMCwgNTAsIDAuMyknXG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL0hpZ2hsaWdodGVyL0hpZ2hsaWdodGVyLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIFNIT1dfRFVSQVRJT04gPSAyMDAwO1xudmFyIHRpbWVvdXRJRCA9IG51bGw7XG52YXIgb3ZlcmxheSA9IG51bGw7XG5mdW5jdGlvbiBoaWRlT3ZlcmxheShhZ2VudCkge1xuICBpZiAod2luZG93LmRvY3VtZW50ID09IG51bGwpIHtcbiAgICBhZ2VudC5lbWl0KCdoaWRlTmF0aXZlSGlnaGxpZ2h0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGltZW91dElEID0gbnVsbDtcblxuICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgIG92ZXJsYXkucmVtb3ZlKCk7XG4gICAgb3ZlcmxheSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dPdmVybGF5KGVsZW1lbnRzLCBjb21wb25lbnROYW1lLCBhZ2VudCwgaGlkZUFmdGVyVGltZW91dCkge1xuICBpZiAod2luZG93LmRvY3VtZW50ID09IG51bGwpIHtcbiAgICBpZiAoZWxlbWVudHMgIT0gbnVsbCAmJiBlbGVtZW50c1swXSAhPSBudWxsKSB7XG4gICAgICBhZ2VudC5lbWl0KCdzaG93TmF0aXZlSGlnaGxpZ2h0JywgZWxlbWVudHNbMF0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfVxuXG4gIGlmIChlbGVtZW50cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG92ZXJsYXkgPT09IG51bGwpIHtcbiAgICBvdmVybGF5ID0gbmV3IE92ZXJsYXlfT3ZlcmxheShhZ2VudCk7XG4gIH1cblxuICBvdmVybGF5Lmluc3BlY3QoZWxlbWVudHMsIGNvbXBvbmVudE5hbWUpO1xuXG4gIGlmIChoaWRlQWZ0ZXJUaW1lb3V0KSB7XG4gICAgdGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaGlkZU92ZXJsYXkoYWdlbnQpO1xuICAgIH0sIFNIT1dfRFVSQVRJT04pO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvSGlnaGxpZ2h0ZXIvaW5kZXguanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuXG4vLyBUaGlzIHBsdWctaW4gcHJvdmlkZXMgaW4tcGFnZSBoaWdobGlnaHRpbmcgb2YgdGhlIHNlbGVjdGVkIGVsZW1lbnQuXG4vLyBJdCBpcyB1c2VkIGJ5IHRoZSBicm93c2VyIGV4dGVuc2lvbiBhbmQgdGhlIHN0YW5kYWxvbmUgRGV2VG9vbHMgc2hlbGwgKHdoZW4gY29ubmVjdGVkIHRvIGEgYnJvd3NlcikuXG4vLyBJdCBpcyBub3QgY3VycmVudGx5IHRoZSBtZWNoYW5pc20gdXNlZCB0byBoaWdobGlnaHQgUmVhY3QgTmF0aXZlIHZpZXdzLlxuLy8gVGhhdCBpcyBkb25lIGJ5IHRoZSBSZWFjdCBOYXRpdmUgSW5zcGVjdG9yIGNvbXBvbmVudC5cbnZhciBpZnJhbWVzTGlzdGVuaW5nVG8gPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBzZXR1cEhpZ2hsaWdodGVyKGJyaWRnZSwgYWdlbnQpIHtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdjbGVhck5hdGl2ZUVsZW1lbnRIaWdobGlnaHQnLCBjbGVhck5hdGl2ZUVsZW1lbnRIaWdobGlnaHQpO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2hpZ2hsaWdodE5hdGl2ZUVsZW1lbnQnLCBoaWdobGlnaHROYXRpdmVFbGVtZW50KTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdzaHV0ZG93bicsIHN0b3BJbnNwZWN0aW5nTmF0aXZlKTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdzdGFydEluc3BlY3RpbmdOYXRpdmUnLCBzdGFydEluc3BlY3RpbmdOYXRpdmUpO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0b3BJbnNwZWN0aW5nTmF0aXZlJywgc3RvcEluc3BlY3RpbmdOYXRpdmUpO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0SW5zcGVjdGluZ05hdGl2ZSgpIHtcbiAgICByZWdpc3Rlckxpc3RlbmVyc09uV2luZG93KHdpbmRvdyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyc09uV2luZG93KHdpbmRvdykge1xuICAgIC8vIFRoaXMgcGx1Zy1pbiBtYXkgcnVuIGluIG5vbi1ET00gZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSkuXG4gICAgaWYgKHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgb25Qb2ludGVyT3ZlciwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2VudC5lbWl0KCdzdGFydEluc3BlY3RpbmdOYXRpdmUnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wSW5zcGVjdGluZ05hdGl2ZSgpIHtcbiAgICBoaWRlT3ZlcmxheShhZ2VudCk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzT25XaW5kb3cod2luZG93KTtcbiAgICBpZnJhbWVzTGlzdGVuaW5nVG8uZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyc09uV2luZG93KGZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBUaGlzIGNhbiBlcnJvciB3aGVuIHRoZSBpZnJhbWUgaXMgb24gYSBjcm9zcy1vcmlnaW4uXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWZyYW1lc0xpc3RlbmluZ1RvID0gbmV3IFNldCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzT25XaW5kb3cod2luZG93KSB7XG4gICAgLy8gVGhpcyBwbHVnLWluIG1heSBydW4gaW4gbm9uLURPTSBlbnZpcm9ubWVudHMgKGUuZy4gUmVhY3QgTmF0aXZlKS5cbiAgICBpZiAod2luZG93ICYmIHR5cGVvZiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1vdXNlRXZlbnQsIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlRXZlbnQsIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCBvblBvaW50ZXJPdmVyLCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFnZW50LmVtaXQoJ3N0b3BJbnNwZWN0aW5nTmF0aXZlJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJOYXRpdmVFbGVtZW50SGlnaGxpZ2h0KCkge1xuICAgIGhpZGVPdmVybGF5KGFnZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodE5hdGl2ZUVsZW1lbnQoX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWUsXG4gICAgICAgIGhpZGVBZnRlclRpbWVvdXQgPSBfcmVmLmhpZGVBZnRlclRpbWVvdXQsXG4gICAgICAgIGlkID0gX3JlZi5pZCxcbiAgICAgICAgb3Blbk5hdGl2ZUVsZW1lbnRzUGFuZWwgPSBfcmVmLm9wZW5OYXRpdmVFbGVtZW50c1BhbmVsLFxuICAgICAgICByZW5kZXJlcklEID0gX3JlZi5yZW5kZXJlcklELFxuICAgICAgICBzY3JvbGxJbnRvVmlldyA9IF9yZWYuc2Nyb2xsSW50b1ZpZXc7XG4gICAgdmFyIHJlbmRlcmVyID0gYWdlbnQucmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gbnVsbDtcblxuICAgIGlmIChyZW5kZXJlciAhPSBudWxsKSB7XG4gICAgICBub2RlcyA9IHJlbmRlcmVyLmZpbmROYXRpdmVOb2Rlc0ZvckZpYmVySUQoaWQpO1xuICAgIH1cblxuICAgIGlmIChub2RlcyAhPSBudWxsICYmIG5vZGVzWzBdICE9IG51bGwpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbMF07IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuICAgICAgaWYgKHNjcm9sbEludG9WaWV3ICYmIHR5cGVvZiBub2RlLnNjcm9sbEludG9WaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHRoZSBub2RlIGlzbid0IHZpc2libGUgc2hvdyBpdCBiZWZvcmUgaGlnaGxpZ2h0aW5nIGl0LlxuICAgICAgICAvLyBXZSBtYXkgd2FudCB0byByZWNvbnNpZGVyIHRoaXM7IGl0IG1pZ2h0IGJlIGEgbGl0dGxlIGRpc3J1cHRpdmUuXG4gICAgICAgIG5vZGUuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNob3dPdmVybGF5KG5vZGVzLCBkaXNwbGF5TmFtZSwgYWdlbnQsIGhpZGVBZnRlclRpbWVvdXQpO1xuXG4gICAgICBpZiAob3Blbk5hdGl2ZUVsZW1lbnRzUGFuZWwpIHtcbiAgICAgICAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy4kMCA9IG5vZGU7XG4gICAgICAgIGJyaWRnZS5zZW5kKCdzeW5jU2VsZWN0aW9uVG9OYXRpdmVFbGVtZW50c1BhbmVsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGVPdmVybGF5KGFnZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBzdG9wSW5zcGVjdGluZ05hdGl2ZSgpO1xuICAgIGJyaWRnZS5zZW5kKCdzdG9wSW5zcGVjdGluZ05hdGl2ZScsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUV2ZW50KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHNlbGVjdEZpYmVyRm9yTm9kZShldmVudC50YXJnZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qb2ludGVyT3ZlcihldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lGUkFNRScpIHtcbiAgICAgIHZhciBpZnJhbWUgPSB0YXJnZXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaWZyYW1lc0xpc3RlbmluZ1RvLmhhcyhpZnJhbWUpKSB7XG4gICAgICAgICAgdmFyIF93aW5kb3cgPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICAgICAgICByZWdpc3Rlckxpc3RlbmVyc09uV2luZG93KF93aW5kb3cpO1xuICAgICAgICAgIGlmcmFtZXNMaXN0ZW5pbmdUby5hZGQoaWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBUaGlzIGNhbiBlcnJvciB3aGVuIHRoZSBpZnJhbWUgaXMgb24gYSBjcm9zcy1vcmlnaW4uXG4gICAgICB9XG4gICAgfSAvLyBEb24ndCBwYXNzIHRoZSBuYW1lIGV4cGxpY2l0bHkuXG4gICAgLy8gSXQgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIERPTSB0YWcgYW5kIEZpYmVyIG93bmVyLlxuXG5cbiAgICBzaG93T3ZlcmxheShbdGFyZ2V0XSwgbnVsbCwgYWdlbnQsIGZhbHNlKTtcbiAgICBzZWxlY3RGaWJlckZvck5vZGUodGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RGaWJlckZvck5vZGUgPSBsb2Rhc2hfdGhyb3R0bGVfZGVmYXVsdCgpKGVzbShmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBpZCA9IGFnZW50LmdldElERm9yTm9kZShub2RlKTtcblxuICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgYnJpZGdlLnNlbmQoJ3NlbGVjdEZpYmVyJywgaWQpO1xuICAgIH1cbiAgfSksIDIwMCwgLy8gRG9uJ3QgY2hhbmdlIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHZlcnkgZmlyc3QgMjAwbXNcbiAgLy8gYmVjYXVzZSB0aG9zZSBhcmUgdXN1YWxseSB1bmludGVudGlvbmFsIGFzIHlvdSBsaWZ0IHRoZSBjdXJzb3IuXG4gIHtcbiAgICBsZWFkaW5nOiBmYWxzZVxuICB9KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy9UcmFjZVVwZGF0ZXMvY2FudmFzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbnZhciBPVVRMSU5FX0NPTE9SID0gJyNmMGYwZjAnOyAvLyBOb3RlIHRoZXNlIGNvbG9ycyBhcmUgaW4gc3luYyB3aXRoIERldlRvb2xzIFByb2ZpbGVyIGNoYXJ0IGNvbG9ycy5cblxudmFyIENPTE9SUyA9IFsnIzM3YWZhOScsICcjNjNiMTllJywgJyM4MGIzOTMnLCAnIzk3YjQ4OCcsICcjYWJiNjdkJywgJyNiZWI3NzEnLCAnI2NmYjk2NScsICcjZGZiYTU3JywgJyNlZmJiNDknLCAnI2ZlYmMzOCddO1xudmFyIGNhbnZhcyA9IG51bGw7XG5mdW5jdGlvbiBkcmF3KG5vZGVUb0RhdGEsIGFnZW50KSB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgIHZhciBub2Rlc1RvRHJhdyA9IFtdO1xuICAgIGl0ZXJhdGVOb2Rlcyhub2RlVG9EYXRhLCBmdW5jdGlvbiAoXywgY29sb3IsIG5vZGUpIHtcbiAgICAgIG5vZGVzVG9EcmF3LnB1c2goe1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFnZW50LmVtaXQoJ2RyYXdUcmFjZVVwZGF0ZXMnLCBub2Rlc1RvRHJhdyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNhbnZhcyA9PT0gbnVsbCkge1xuICAgIGluaXRpYWxpemUoKTtcbiAgfVxuXG4gIHZhciBjYW52YXNGbG93ID0gY2FudmFzO1xuICBjYW52YXNGbG93LndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGNhbnZhc0Zsb3cuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB2YXIgY29udGV4dCA9IGNhbnZhc0Zsb3cuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzRmxvdy53aWR0aCwgY2FudmFzRmxvdy5oZWlnaHQpO1xuICBpdGVyYXRlTm9kZXMobm9kZVRvRGF0YSwgZnVuY3Rpb24gKHJlY3QsIGNvbG9yKSB7XG4gICAgaWYgKHJlY3QgIT09IG51bGwpIHtcbiAgICAgIGRyYXdCb3JkZXIoY29udGV4dCwgcmVjdCwgY29sb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVOb2Rlcyhub2RlVG9EYXRhLCBleGVjdXRlKSB7XG4gIG5vZGVUb0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoX3JlZiwgbm9kZSkge1xuICAgIHZhciBjb3VudCA9IF9yZWYuY291bnQsXG4gICAgICAgIHJlY3QgPSBfcmVmLnJlY3Q7XG4gICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLm1pbihDT0xPUlMubGVuZ3RoIC0gMSwgY291bnQgLSAxKTtcbiAgICB2YXIgY29sb3IgPSBDT0xPUlNbY29sb3JJbmRleF07XG4gICAgZXhlY3V0ZShyZWN0LCBjb2xvciwgbm9kZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGNvbnRleHQsIHJlY3QsIGNvbG9yKSB7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodCxcbiAgICAgIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICB0b3AgPSByZWN0LnRvcCxcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aDsgLy8gb3V0bGluZVxuXG4gIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9IE9VVExJTkVfQ09MT1I7XG4gIGNvbnRleHQuc3Ryb2tlUmVjdChsZWZ0IC0gMSwgdG9wIC0gMSwgd2lkdGggKyAyLCBoZWlnaHQgKyAyKTsgLy8gaW5zZXRcblxuICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBPVVRMSU5FX0NPTE9SO1xuICBjb250ZXh0LnN0cm9rZVJlY3QobGVmdCArIDEsIHRvcCArIDEsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSk7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY29udGV4dC5zZXRMaW5lRGFzaChbMF0pOyAvLyBib3JkZXJcblxuICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gIGNvbnRleHQuc3Ryb2tlUmVjdChsZWZ0LCB0b3AsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSk7XG4gIGNvbnRleHQuc2V0TGluZURhc2goWzBdKTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveShhZ2VudCkge1xuICBpZiAod2luZG93LmRvY3VtZW50ID09IG51bGwpIHtcbiAgICBhZ2VudC5lbWl0KCdkaXNhYmxlVHJhY2VVcGRhdGVzJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNhbnZhcyAhPT0gbnVsbCkge1xuICAgIGlmIChjYW52YXMucGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgICBjYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgIH1cblxuICAgIGNhbnZhcyA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgY2FudmFzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMuc3R5bGUuY3NzVGV4dCA9IFwiXFxuICAgIHh4LWJhY2tncm91bmQtY29sb3I6IHJlZDtcXG4gICAgeHgtb3BhY2l0eTogMC41O1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIHotaW5kZXg6IDEwMDAwMDAwMDA7XFxuICBcIjtcbiAgdmFyIHJvb3QgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICByb290Lmluc2VydEJlZm9yZShjYW52YXMsIHJvb3QuZmlyc3RDaGlsZCk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvVHJhY2VVcGRhdGVzL2luZGV4LmpzXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuLy8gSG93IGxvbmcgdGhlIHJlY3Qgc2hvdWxkIGJlIHNob3duIGZvcj9cbnZhciBESVNQTEFZX0RVUkFUSU9OID0gMjUwOyAvLyBXaGF0J3MgdGhlIGxvbmdlc3Qgd2UgYXJlIHdpbGxpbmcgdG8gc2hvdyB0aGUgb3ZlcmxheSBmb3I/XG4vLyBUaGlzIGNhbiBiZSBpbXBvcnRhbnQgaWYgd2UncmUgZ2V0dGluZyBhIGZsdXJyeSBvZiBldmVudHMgKGUuZy4gc2Nyb2xsIHVwZGF0ZSkuXG5cbnZhciBNQVhfRElTUExBWV9EVVJBVElPTiA9IDMwMDA7IC8vIEhvdyBsb25nIHNob3VsZCBhIHJlY3QgYmUgY29uc2lkZXJlZCB2YWxpZCBmb3I/XG5cbnZhciBSRU1FQVNVUkVNRU5UX0FGVEVSX0RVUkFUSU9OID0gMjUwOyAvLyBTb21lIGVudmlyb25tZW50cyAoZS5nLiBSZWFjdCBOYXRpdmUgLyBIZXJtZXMpIGRvbid0IHN1cHBvcnQgdGhlIHBlcmZvcm1hbmNlIEFQSSB5ZXQuXG5cbnZhciBnZXRDdXJyZW50VGltZSA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbih0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihwZXJmb3JtYW5jZSkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG59IDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG52YXIgbm9kZVRvRGF0YSA9IG5ldyBNYXAoKTtcbnZhciBUcmFjZVVwZGF0ZXNfYWdlbnQgPSBudWxsO1xudmFyIGRyYXdBbmltYXRpb25GcmFtZUlEID0gbnVsbDtcbnZhciBpc0VuYWJsZWQgPSBmYWxzZTtcbnZhciByZWRyYXdUaW1lb3V0SUQgPSBudWxsO1xuZnVuY3Rpb24gVHJhY2VVcGRhdGVzX2luaXRpYWxpemUoaW5qZWN0ZWRBZ2VudCkge1xuICBUcmFjZVVwZGF0ZXNfYWdlbnQgPSBpbmplY3RlZEFnZW50O1xuICBUcmFjZVVwZGF0ZXNfYWdlbnQuYWRkTGlzdGVuZXIoJ3RyYWNlVXBkYXRlcycsIHRyYWNlVXBkYXRlcyk7XG59XG5mdW5jdGlvbiB0b2dnbGVFbmFibGVkKHZhbHVlKSB7XG4gIGlzRW5hYmxlZCA9IHZhbHVlO1xuXG4gIGlmICghaXNFbmFibGVkKSB7XG4gICAgbm9kZVRvRGF0YS5jbGVhcigpO1xuXG4gICAgaWYgKGRyYXdBbmltYXRpb25GcmFtZUlEICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShkcmF3QW5pbWF0aW9uRnJhbWVJRCk7XG4gICAgICBkcmF3QW5pbWF0aW9uRnJhbWVJRCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHJlZHJhd1RpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlZHJhd1RpbWVvdXRJRCk7XG4gICAgICByZWRyYXdUaW1lb3V0SUQgPSBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3koVHJhY2VVcGRhdGVzX2FnZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFjZVVwZGF0ZXMobm9kZXMpIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGRhdGEgPSBub2RlVG9EYXRhLmdldChub2RlKTtcbiAgICB2YXIgbm93ID0gZ2V0Q3VycmVudFRpbWUoKTtcbiAgICB2YXIgbGFzdE1lYXN1cmVkQXQgPSBkYXRhICE9IG51bGwgPyBkYXRhLmxhc3RNZWFzdXJlZEF0IDogMDtcbiAgICB2YXIgcmVjdCA9IGRhdGEgIT0gbnVsbCA/IGRhdGEucmVjdCA6IG51bGw7XG5cbiAgICBpZiAocmVjdCA9PT0gbnVsbCB8fCBsYXN0TWVhc3VyZWRBdCArIFJFTUVBU1VSRU1FTlRfQUZURVJfRFVSQVRJT04gPCBub3cpIHtcbiAgICAgIGxhc3RNZWFzdXJlZEF0ID0gbm93O1xuICAgICAgcmVjdCA9IG1lYXN1cmVOb2RlKG5vZGUpO1xuICAgIH1cblxuICAgIG5vZGVUb0RhdGEuc2V0KG5vZGUsIHtcbiAgICAgIGNvdW50OiBkYXRhICE9IG51bGwgPyBkYXRhLmNvdW50ICsgMSA6IDEsXG4gICAgICBleHBpcmF0aW9uVGltZTogZGF0YSAhPSBudWxsID8gTWF0aC5taW4obm93ICsgTUFYX0RJU1BMQVlfRFVSQVRJT04sIGRhdGEuZXhwaXJhdGlvblRpbWUgKyBESVNQTEFZX0RVUkFUSU9OKSA6IG5vdyArIERJU1BMQVlfRFVSQVRJT04sXG4gICAgICBsYXN0TWVhc3VyZWRBdDogbGFzdE1lYXN1cmVkQXQsXG4gICAgICByZWN0OiByZWN0XG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChyZWRyYXdUaW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICBjbGVhclRpbWVvdXQocmVkcmF3VGltZW91dElEKTtcbiAgICByZWRyYXdUaW1lb3V0SUQgPSBudWxsO1xuICB9XG5cbiAgaWYgKGRyYXdBbmltYXRpb25GcmFtZUlEID09PSBudWxsKSB7XG4gICAgZHJhd0FuaW1hdGlvbkZyYW1lSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocHJlcGFyZVRvRHJhdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvRHJhdygpIHtcbiAgZHJhd0FuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xuICByZWRyYXdUaW1lb3V0SUQgPSBudWxsO1xuICB2YXIgbm93ID0gZ2V0Q3VycmVudFRpbWUoKTtcbiAgdmFyIGVhcmxpZXN0RXhwaXJhdGlvbiA9IE51bWJlci5NQVhfVkFMVUU7IC8vIFJlbW92ZSBhbnkgaXRlbXMgdGhhdCBoYXZlIGFscmVhZHkgZXhwaXJlZC5cblxuICBub2RlVG9EYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEsIG5vZGUpIHtcbiAgICBpZiAoZGF0YS5leHBpcmF0aW9uVGltZSA8IG5vdykge1xuICAgICAgbm9kZVRvRGF0YS5kZWxldGUobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVhcmxpZXN0RXhwaXJhdGlvbiA9IE1hdGgubWluKGVhcmxpZXN0RXhwaXJhdGlvbiwgZGF0YS5leHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9KTtcbiAgZHJhdyhub2RlVG9EYXRhLCBUcmFjZVVwZGF0ZXNfYWdlbnQpO1xuXG4gIGlmIChlYXJsaWVzdEV4cGlyYXRpb24gIT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICByZWRyYXdUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHByZXBhcmVUb0RyYXcsIGVhcmxpZXN0RXhwaXJhdGlvbiAtIG5vdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVhc3VyZU5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY3VycmVudFdpbmRvdyA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1RBUkdFVF9XSU5ET1dfXyB8fCB3aW5kb3c7XG4gIHJldHVybiBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSwgY3VycmVudFdpbmRvdyk7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9jb25zb2xlLmpzXG52YXIgYmFja2VuZF9jb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UuanNcbmZ1bmN0aW9uIGJyaWRnZV90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IGJyaWRnZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgYnJpZGdlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBicmlkZ2VfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBicmlkZ2VfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBicmlkZ2VfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGJyaWRnZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgYnJpZGdlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGJyaWRnZV90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBicmlkZ2VfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIEJBVENIX0RVUkFUSU9OID0gMTAwOyAvLyBUaGlzIG1lc3NhZ2Ugc3BlY2lmaWVzIHRoZSB2ZXJzaW9uIG9mIHRoZSBEZXZUb29scyBwcm90b2NvbCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBiYWNrZW5kLFxuLy8gYXMgd2VsbCBhcyB0aGUgZWFybGllc3QgTlBNIHZlcnNpb24gKGUuZy4gXCI0LjEzLjBcIikgdGhhdCBwcm90b2NvbCBpcyBzdXBwb3J0ZWQgYnkgb24gdGhlIGZyb250ZW5kLlxuLy8gVGhpcyBlbmFibGVzIGFuIG9sZGVyIGZyb250ZW5kIHRvIGRpc3BsYXkgYW4gdXBncmFkZSBtZXNzYWdlIHRvIHVzZXJzIGZvciBhIG5ld2VyLCB1bnN1cHBvcnRlZCBiYWNrZW5kLlxuXG4vLyBCdW1wIHByb3RvY29sIHZlcnNpb24gd2hlbmV2ZXIgYSBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlIGlzIG1hZGVcbi8vIGluIHRoZSBtZXNzYWdlcyBzZW50IGJldHdlZW4gQmFja2VuZEJyaWRnZSBhbmQgRnJvbnRlbmRCcmlkZ2UuXG4vLyBUaGlzIG1hcHBpbmcgaXMgZW1iZWRkZWQgaW4gYm90aCBmcm9udGVuZCBhbmQgYmFja2VuZCBidWlsZHMuXG4vL1xuLy8gVGhlIGJhY2tlbmQgcHJvdG9jb2wgd2lsbCBhbHdheXMgYmUgdGhlIGxhdGVzdCBlbnRyeSBpbiB0aGUgQlJJREdFX1BST1RPQ09MIGFycmF5LlxuLy9cbi8vIFdoZW4gYW4gb2xkZXIgZnJvbnRlbmQgY29ubmVjdHMgdG8gYSBuZXdlciBiYWNrZW5kLFxuLy8gdGhlIGJhY2tlbmQgY2FuIHNlbmQgdGhlIG1pbk5wbVZlcnNpb24gYW5kIHRoZSBmcm9udGVuZCBjYW4gZGlzcGxheSBhbiBOUE0gdXBncmFkZSBwcm9tcHQuXG4vL1xuLy8gV2hlbiBhIG5ld2VyIGZyb250ZW5kIGNvbm5lY3RzIHdpdGggYW4gb2xkZXIgcHJvdG9jb2wgdmVyc2lvbixcbi8vIHRoZSBmcm9udGVuZCBjYW4gdXNlIHRoZSBlbWJlZGRlZCBtaW5OcG1WZXJzaW9uL21heE5wbVZlcnNpb24gdmFsdWVzIHRvIGRpc3BsYXkgYSBkb3duZ3JhZGUgcHJvbXB0LlxudmFyIEJSSURHRV9QUk9UT0NPTCA9IFsvLyBUaGlzIHZlcnNpb24gdGVjaG5pY2FsbHkgbmV2ZXIgZXhpc3RlZCxcbi8vIGJ1dCBhIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2Ugd2FzIGFkZGVkIGluIDQuMTEsXG4vLyBzbyB0aGUgc2FmZXN0IGd1ZXNzIHRvIGRvd25ncmFkZSB0aGUgZnJvbnRlbmQgd291bGQgYmUgdG8gdmVyc2lvbiA0LjEwLlxue1xuICB2ZXJzaW9uOiAwLFxuICBtaW5OcG1WZXJzaW9uOiAnXCI8NC4xMS4wXCInLFxuICBtYXhOcG1WZXJzaW9uOiAnXCI8NC4xMS4wXCInXG59LCAvLyBWZXJzaW9ucyA0LjExLngg4oCTIDQuMTIueCBjb250YWluZWQgdGhlIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2UsXG4vLyBidXQgd2UgZGlkbid0IGFkZCB0aGUgXCJmaXhcIiBvZiBjaGVja2luZyB0aGUgcHJvdG9jb2wgdmVyc2lvbiB1bnRpbCA0LjEzLFxuLy8gc28gd2UgZG9uJ3QgcmVjb21tZW5kIGRvd25ncmFkaW5nIHRvIDQuMTEgb3IgNC4xMi5cbntcbiAgdmVyc2lvbjogMSxcbiAgbWluTnBtVmVyc2lvbjogJzQuMTMuMCcsXG4gIG1heE5wbVZlcnNpb246ICc0LjIxLjAnXG59LCAvLyBWZXJzaW9uIDIgYWRkcyBhIFN0cmljdE1vZGUtZW5hYmxlZCBhbmQgc3VwcG9ydHMtU3RyaWN0TW9kZSBiaXRzIHRvIGFkZC1yb290IG9wZXJhdGlvbi5cbntcbiAgdmVyc2lvbjogMixcbiAgbWluTnBtVmVyc2lvbjogJzQuMjIuMCcsXG4gIG1heE5wbVZlcnNpb246IG51bGxcbn1dO1xudmFyIGN1cnJlbnRCcmlkZ2VQcm90b2NvbCA9IEJSSURHRV9QUk9UT0NPTFtCUklER0VfUFJPVE9DT0wubGVuZ3RoIC0gMV07XG5cbnZhciBCcmlkZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKEJyaWRnZSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCcmlkZ2UpO1xuXG4gIGZ1bmN0aW9uIEJyaWRnZSh3YWxsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgYnJpZGdlX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyaWRnZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgYnJpZGdlX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pc1NodXRkb3duXCIsIGZhbHNlKTtcblxuICAgIGJyaWRnZV9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfbWVzc2FnZVF1ZXVlXCIsIFtdKTtcblxuICAgIGJyaWRnZV9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfdGltZW91dElEXCIsIG51bGwpO1xuXG4gICAgYnJpZGdlX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl93YWxsVW5saXN0ZW5cIiwgbnVsbCk7XG5cbiAgICBicmlkZ2VfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2ZsdXNoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgYWZ0ZXIgdGhlIGJyaWRnZSBpcyBtYXJrZWQgYXMgZGVzdHJveWVkIGluIHNodXRkb3duIHNlcXVlbmNlLFxuICAgICAgLy8gc28gd2UgZG8gbm90IGJhaWwgb3V0IGlmIHRoZSBicmlkZ2UgbWFya2VkIGFzIGRlc3Ryb3llZC5cbiAgICAgIC8vIEl0IGlzIGEgcHJpdmF0ZSBtZXRob2QgdGhhdCB0aGUgYnJpZGdlIGVuc3VyZXMgaXMgb25seSBjYWxsZWQgYXQgdGhlIHJpZ2h0IHRpbWVzLlxuICAgICAgaWYgKF90aGlzLl90aW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl90aW1lb3V0SUQpO1xuICAgICAgICBfdGhpcy5fdGltZW91dElEID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLl9tZXNzYWdlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHZhciBfdGhpcyRfd2FsbDtcblxuICAgICAgICAgIChfdGhpcyRfd2FsbCA9IF90aGlzLl93YWxsKS5zZW5kLmFwcGx5KF90aGlzJF93YWxsLCBbX3RoaXMuX21lc3NhZ2VRdWV1ZVtpXV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5fbWVzc2FnZVF1ZXVlW2kgKyAxXSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9tZXNzYWdlUXVldWUubGVuZ3RoID0gMDsgLy8gQ2hlY2sgYWdhaW4gZm9yIHF1ZXVlZCBtZXNzYWdlcyBpbiBCQVRDSF9EVVJBVElPTiBtcy4gVGhpcyB3aWxsIGtlZXBcbiAgICAgICAgLy8gZmx1c2hpbmcgaW4gYSBsb29wIGFzIGxvbmcgYXMgbWVzc2FnZXMgY29udGludWUgdG8gYmUgYWRkZWQuIE9uY2Ugbm9cbiAgICAgICAgLy8gbW9yZSBhcmUsIHRoZSB0aW1lciBleHBpcmVzLlxuXG4gICAgICAgIF90aGlzLl90aW1lb3V0SUQgPSBzZXRUaW1lb3V0KF90aGlzLl9mbHVzaCwgQkFUQ0hfRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYnJpZGdlX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlVmFsdWVBdFBhdGhcIiwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZi5yZW5kZXJlcklELFxuICAgICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgX3RoaXMuc2VuZCgnb3ZlcnJpZGVDb250ZXh0Jywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICBfdGhpcy5zZW5kKCdvdmVycmlkZUhvb2tTdGF0ZScsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgICAgd2FzRm9yd2FyZGVkOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgX3RoaXMuc2VuZCgnb3ZlcnJpZGVQcm9wcycsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgICAgd2FzRm9yd2FyZGVkOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgX3RoaXMuc2VuZCgnb3ZlcnJpZGVTdGF0ZScsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgICAgd2FzRm9yd2FyZGVkOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF90aGlzLl93YWxsID0gd2FsbDtcbiAgICBfdGhpcy5fd2FsbFVubGlzdGVuID0gd2FsbC5saXN0ZW4oZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UuZXZlbnQpIHtcbiAgICAgICAgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykuZW1pdChtZXNzYWdlLmV2ZW50LCBtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgfVxuICAgIH0pIHx8IG51bGw7IC8vIFRlbXBvcmFyaWx5IHN1cHBvcnQgb2xkZXIgc3RhbmRhbG9uZSBmcm9udC1lbmRzIHNlbmRpbmcgY29tbWFuZHMgdG8gbmV3ZXIgZW1iZWRkZWQgYmFja2VuZHMuXG4gICAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIFJlYWN0IE5hdGl2ZSBlbWJlZHMgdGhlIFJlYWN0IERldlRvb2xzIGJhY2tlbmQsXG4gICAgLy8gYnV0IGNhbm5vdCBjb250cm9sIHdoaWNoIHZlcnNpb24gb2YgdGhlIGZyb250ZW5kIHVzZXJzIHVzZS5cblxuICAgIF90aGlzLmFkZExpc3RlbmVyKCdvdmVycmlkZVZhbHVlQXRQYXRoJywgX3RoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gTGlzdGVuaW5nIGRpcmVjdGx5IHRvIHRoZSB3YWxsIGlzbid0IGFkdmlzZWQuXG4gIC8vIEl0IGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3IgbGVnYWN5ICh2MykgbWVzc2FnZXMgKHNpbmNlIHRoZXkgdXNlIGEgZGlmZmVyZW50IGZvcm1hdCkuXG5cblxuICBicmlkZ2VfY3JlYXRlQ2xhc3MoQnJpZGdlLCBbe1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NodXRkb3duKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBzZW5kIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChldmVudCwgXCJcXFwiIHRocm91Z2ggYSBCcmlkZ2UgdGhhdCBoYXMgYmVlbiBzaHV0ZG93bi5cIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFdoZW4gd2UgcmVjZWl2ZSBhIG1lc3NhZ2U6XG4gICAgICAvLyAtIHdlIGFkZCBpdCB0byBvdXIgcXVldWUgb2YgbWVzc2FnZXMgdG8gYmUgc2VudFxuICAgICAgLy8gLSBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhIG1lc3NhZ2UgcmVjZW50bHksIHdlIHNldCBhIHRpbWVyIGZvciAwIG1zIGluXG4gICAgICAvLyAgIHRoZSBmdXR1cmUsIGFsbG93aW5nIGFsbCBtZXNzYWdlcyBjcmVhdGVkIGluIHRoZSBzYW1lIHRpY2sgdG8gYmUgc2VudFxuICAgICAgLy8gICB0b2dldGhlclxuICAgICAgLy8gLSBpZiB0aGVyZSAqaGFzKiBiZWVuIGEgbWVzc2FnZSBmbHVzaGVkIGluIHRoZSBsYXN0IEJBVENIX0RVUkFUSU9OIG1zXG4gICAgICAvLyAgIChvciB3ZSdyZSB3YWl0aW5nIGZvciBvdXIgc2V0VGltZW91dC0wIHRvIGZpcmUpLCB0aGVuIF90aW1lb3V0SUQgd2lsbFxuICAgICAgLy8gICBiZSBzZXQsIGFuZCB3ZSdsbCBzaW1wbHkgYWRkIHRvIHRoZSBxdWV1ZSBhbmQgd2FpdCBmb3IgdGhhdFxuXG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcGF5bG9hZFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZS5wdXNoKGV2ZW50LCBwYXlsb2FkKTtcblxuICAgICAgaWYgKCF0aGlzLl90aW1lb3V0SUQpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dElEID0gc2V0VGltZW91dCh0aGlzLl9mbHVzaCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNodXRkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNodXRkb3duKCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2h1dGRvd24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCcmlkZ2Ugd2FzIGFscmVhZHkgc2h1dGRvd24uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUXVldWUgdGhlIHNodXRkb3duIG91dGdvaW5nIG1lc3NhZ2UgZm9yIHN1YnNjcmliZXJzLlxuXG5cbiAgICAgIHRoaXMuc2VuZCgnc2h1dGRvd24nKTsgLy8gTWFyayB0aGlzIGJyaWRnZSBhcyBkZXN0cm95ZWQsIGkuZS4gZGlzYWJsZSBpdHMgcHVibGljIEFQSS5cblxuICAgICAgdGhpcy5faXNTaHV0ZG93biA9IHRydWU7IC8vIERpc2FibGUgdGhlIEFQSSBpbmhlcml0ZWQgZnJvbSBFdmVudEVtaXR0ZXIgdGhhdCBjYW4gYWRkIG1vcmUgbGlzdGVuZXJzIGFuZCBzZW5kIG1vcmUgbWVzc2FnZXMuXG4gICAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gVGhpcyBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG5cbiAgICAgIHRoaXMuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIFRoaXMgcHJvcGVydHkgaXMgbm90IHdyaXRhYmxlLlxuXG5cbiAgICAgIHRoaXMuZW1pdCA9IGZ1bmN0aW9uICgpIHt9OyAvLyBOT1RFOiBUaGVyZSdzIGFsc28gRXZlbnRFbWl0dGVyIEFQSSBsaWtlIGBvbmAgYW5kIGBwcmVwZW5kTGlzdGVuZXJgIHRoYXQgd2UgZGlkbid0IGFkZCB0byBvdXIgRmxvdyB0eXBlIG9mIEV2ZW50RW1pdHRlci5cbiAgICAgIC8vIFVuc3Vic2NyaWJlIHRoaXMgYnJpZGdlIGluY29taW5nIG1lc3NhZ2UgbGlzdGVuZXJzIHRvIGJlIHN1cmUsIGFuZCBzbyB0aGV5IGRvbid0IGhhdmUgdG8gZG8gdGhhdC5cblxuXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpOyAvLyBTdG9wIGFjY2VwdGluZyBhbmQgZW1pdHRpbmcgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgd2FsbC5cblxuICAgICAgdmFyIHdhbGxVbmxpc3RlbiA9IHRoaXMuX3dhbGxVbmxpc3RlbjtcblxuICAgICAgaWYgKHdhbGxVbmxpc3Rlbikge1xuICAgICAgICB3YWxsVW5saXN0ZW4oKTtcbiAgICAgIH0gLy8gU3luY2hyb25vdXNseSBmbHVzaCBhbGwgcXVldWVkIG91dGdvaW5nIG1lc3NhZ2VzLlxuICAgICAgLy8gQXQgdGhpcyBzdGVwIHRoZSBzdWJzY3JpYmVycycgY29kZSBtYXkgcnVuIGluIHRoaXMgY2FsbCBzdGFjay5cblxuXG4gICAgICBkbyB7XG4gICAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgICB9IHdoaWxlICh0aGlzLl9tZXNzYWdlUXVldWUubGVuZ3RoKTsgLy8gTWFrZSBzdXJlIG9uY2UgYWdhaW4gdGhhdCB0aGVyZSBpcyBubyBkYW5nbGluZyB0aW1lci5cblxuXG4gICAgICBpZiAodGhpcy5fdGltZW91dElEICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0SUQpO1xuICAgICAgICB0aGlzLl90aW1lb3V0SUQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YWxsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2FsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnJpZGdlO1xufShFdmVudEVtaXR0ZXIpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfYnJpZGdlID0gKEJyaWRnZSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC91dGlscy5qcyArIDEgbW9kdWxlc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2FnZW50LmpzXG5mdW5jdGlvbiBhZ2VudF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IGFnZW50X3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBhZ2VudF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gYWdlbnRfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gYWdlbnRfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBhZ2VudF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gYWdlbnRfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBhZ2VudF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgYWdlbnRfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gYWdlbnRfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgYWdlbnRfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGFnZW50X3NldFByb3RvdHlwZU9mKG8sIHApIHsgYWdlbnRfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGFnZW50X3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGFnZW50X2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBhZ2VudF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBhZ2VudF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gYWdlbnRfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIGFnZW50X3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBhZ2VudF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGFnZW50X3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIGFnZW50X2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBhZ2VudF9nZXRQcm90b3R5cGVPZihvKSB7IGFnZW50X2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGFnZW50X2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIGFnZW50X2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBhZ2VudF9kZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKG1ldGhvZE5hbWUpIHtcbiAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBbXCIlY0FnZW50ICVjXCIuY29uY2F0KG1ldGhvZE5hbWUpLCAnY29sb3I6IHB1cnBsZTsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2ZvbnQtd2VpZ2h0OiBib2xkOyddLmNvbmNhdChhcmdzKSk7XG4gIH1cbn07XG5cbnZhciBhZ2VudF9BZ2VudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBhZ2VudF9pbmhlcml0cyhBZ2VudCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IGFnZW50X2NyZWF0ZVN1cGVyKEFnZW50KTtcblxuICBmdW5jdGlvbiBBZ2VudChicmlkZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBhZ2VudF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZ2VudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfaXNQcm9maWxpbmdcIiwgZmFsc2UpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zXCIsIGZhbHNlKTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3JlbmRlcmVySW50ZXJmYWNlc1wiLCB7fSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9wZXJzaXN0ZWRTZWxlY3Rpb25cIiwgbnVsbCk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaFwiLCBudWxsKTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3RyYWNlVXBkYXRlc0VuYWJsZWRcIiwgZmFsc2UpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGVhckVycm9yc0FuZFdhcm5pbmdzXCIsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgcmVuZGVyZXJJRCA9IF9yZWYucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGVhckVycm9yc0ZvckZpYmVySURcIiwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjIucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXJFcnJvcnNGb3JGaWJlcklEKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2xlYXJXYXJuaW5nc0ZvckZpYmVySURcIiwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMy5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjMucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQoaWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjb3B5RWxlbWVudFBhdGhcIiwgZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmNC5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjQucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjQucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSByZW5kZXJlci5nZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoKGlkLCBwYXRoKTtcblxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnc2F2ZVRvQ2xpcGJvYXJkJywgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBvYnRhaW4gc2VyaWFsaXplZCB2YWx1ZSBmb3IgZWxlbWVudCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRlbGV0ZVBhdGhcIiwgZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICB2YXIgaG9va0lEID0gX3JlZjUuaG9va0lELFxuICAgICAgICAgIGlkID0gX3JlZjUuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWY1LnBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWY1LnJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZSA9IF9yZWY1LnR5cGU7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuZGVsZXRlUGF0aCh0eXBlLCBpZCwgaG9va0lELCBwYXRoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZ2V0QmFja2VuZFZlcnNpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnNpb24gPSBcIjQuMjcuNi03ZjhjNTAxZjZcIjtcblxuICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdiYWNrZW5kVmVyc2lvbicsIHZlcnNpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRCcmlkZ2VQcm90b2NvbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ2JyaWRnZVByb3RvY29sJywgY3VycmVudEJyaWRnZVByb3RvY29sKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZ2V0UHJvZmlsaW5nRGF0YVwiLCBmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgIHZhciByZW5kZXJlcklEID0gX3JlZjYucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ0RhdGEnLCByZW5kZXJlci5nZXRQcm9maWxpbmdEYXRhKCkpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRQcm9maWxpbmdTdGF0dXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdwcm9maWxpbmdTdGF0dXMnLCBfdGhpcy5faXNQcm9maWxpbmcpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRPd25lcnNMaXN0XCIsIGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgdmFyIGlkID0gX3JlZjcuaWQsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWY3LnJlbmRlcmVySUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG93bmVycyA9IHJlbmRlcmVyLmdldE93bmVyc0xpc3QoaWQpO1xuXG4gICAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnb3duZXJzTGlzdCcsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgb3duZXJzOiBvd25lcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImluc3BlY3RFbGVtZW50XCIsIGZ1bmN0aW9uIChfcmVmOCkge1xuICAgICAgdmFyIGZvcmNlRnVsbERhdGEgPSBfcmVmOC5mb3JjZUZ1bGxEYXRhLFxuICAgICAgICAgIGlkID0gX3JlZjguaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWY4LnBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWY4LnJlbmRlcmVySUQsXG4gICAgICAgICAgcmVxdWVzdElEID0gX3JlZjgucmVxdWVzdElEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnaW5zcGVjdGVkRWxlbWVudCcsIHJlbmRlcmVyLmluc3BlY3RFbGVtZW50KHJlcXVlc3RJRCwgaWQsIHBhdGgsIGZvcmNlRnVsbERhdGEpKTsgLy8gV2hlbiB1c2VyIHNlbGVjdHMgYW4gZWxlbWVudCwgc3RvcCB0cnlpbmcgdG8gcmVzdG9yZSB0aGUgc2VsZWN0aW9uLFxuICAgICAgICAvLyBhbmQgaW5zdGVhZCByZW1lbWJlciB0aGUgY3VycmVudCBzZWxlY3Rpb24gZm9yIHRoZSBuZXh0IHJlbG9hZC5cblxuXG4gICAgICAgIGlmIChfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uTWF0Y2ggPT09IG51bGwgfHwgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoLmlkICE9PSBpZCkge1xuICAgICAgICAgIF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaCA9IG51bGw7XG4gICAgICAgICAgcmVuZGVyZXIuc2V0VHJhY2tlZFBhdGgobnVsbCk7XG5cbiAgICAgICAgICBfdGhpcy5fdGhyb3R0bGVkUGVyc2lzdFNlbGVjdGlvbihyZW5kZXJlcklELCBpZCk7XG4gICAgICAgIH0gLy8gVE9ETzogSWYgdGhlcmUgd2FzIGEgd2F5IHRvIGNoYW5nZSB0aGUgc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgICAgLy8gaW4gbmF0aXZlIEVsZW1lbnRzIHRhYiB3aXRob3V0IGZvcmNpbmcgYSBzd2l0Y2ggdG8gaXQsIHdlJ2QgZG8gaXQgaGVyZS5cbiAgICAgICAgLy8gRm9yIG5vdywgaXQgZG9lc24ndCBzZWVtIGxpa2UgdGhlcmUgaXMgYSB3YXkgdG8gZG8gdGhhdDpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2J2YXVnaG4vcmVhY3QtZGV2dG9vbHMtZXhwZXJpbWVudGFsL2lzc3Vlcy8xMDJcbiAgICAgICAgLy8gKFNldHRpbmcgJDAgZG9lc24ndCB3b3JrLCBhbmQgY2FsbGluZyBpbnNwZWN0KCkgc3dpdGNoZXMgdGhlIHRhYi4pXG5cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibG9nRWxlbWVudFRvQ29uc29sZVwiLCBmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICAgIHZhciBpZCA9IF9yZWY5LmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmOS5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLmxvZ0VsZW1lbnRUb0NvbnNvbGUoaWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvdmVycmlkZUVycm9yXCIsIGZ1bmN0aW9uIChfcmVmMTApIHtcbiAgICAgIHZhciBpZCA9IF9yZWYxMC5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjEwLnJlbmRlcmVySUQsXG4gICAgICAgICAgZm9yY2VFcnJvciA9IF9yZWYxMC5mb3JjZUVycm9yO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLm92ZXJyaWRlRXJyb3IoaWQsIGZvcmNlRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvdmVycmlkZVN1c3BlbnNlXCIsIGZ1bmN0aW9uIChfcmVmMTEpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYxMS5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjExLnJlbmRlcmVySUQsXG4gICAgICAgICAgZm9yY2VGYWxsYmFjayA9IF9yZWYxMS5mb3JjZUZhbGxiYWNrO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLm92ZXJyaWRlU3VzcGVuc2UoaWQsIGZvcmNlRmFsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvdmVycmlkZVZhbHVlQXRQYXRoXCIsIGZ1bmN0aW9uIChfcmVmMTIpIHtcbiAgICAgIHZhciBob29rSUQgPSBfcmVmMTIuaG9va0lELFxuICAgICAgICAgIGlkID0gX3JlZjEyLmlkLFxuICAgICAgICAgIHBhdGggPSBfcmVmMTIucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjEyLnJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYxMi50eXBlLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjEyLnZhbHVlO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLm92ZXJyaWRlVmFsdWVBdFBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvdmVycmlkZUNvbnRleHRcIiwgZnVuY3Rpb24gKF9yZWYxMykge1xuICAgICAgdmFyIGlkID0gX3JlZjEzLmlkLFxuICAgICAgICAgIHBhdGggPSBfcmVmMTMucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjEzLnJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkID0gX3JlZjEzLndhc0ZvcndhcmRlZCxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYxMy52YWx1ZTtcblxuICAgICAgLy8gRG9uJ3QgZm9yd2FyZCBhIG1lc3NhZ2UgdGhhdCdzIGFscmVhZHkgYmVlbiBmb3J3YXJkZWQgYnkgdGhlIGZyb250LWVuZCBCcmlkZ2UuXG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgb3ZlcnJpZGUgY29tbWFuZCBvbmNlIVxuICAgICAgaWYgKCF3YXNGb3J3YXJkZWQpIHtcbiAgICAgICAgX3RoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlOiAnY29udGV4dCcsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvdmVycmlkZUhvb2tTdGF0ZVwiLCBmdW5jdGlvbiAoX3JlZjE0KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMTQuaWQsXG4gICAgICAgICAgaG9va0lEID0gX3JlZjE0Lmhvb2tJRCxcbiAgICAgICAgICBwYXRoID0gX3JlZjE0LnBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYxNC5yZW5kZXJlcklELFxuICAgICAgICAgIHdhc0ZvcndhcmRlZCA9IF9yZWYxNC53YXNGb3J3YXJkZWQsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMTQudmFsdWU7XG5cbiAgICAgIC8vIERvbid0IGZvcndhcmQgYSBtZXNzYWdlIHRoYXQncyBhbHJlYWR5IGJlZW4gZm9yd2FyZGVkIGJ5IHRoZSBmcm9udC1lbmQgQnJpZGdlLlxuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG92ZXJyaWRlIGNvbW1hbmQgb25jZSFcbiAgICAgIGlmICghd2FzRm9yd2FyZGVkKSB7XG4gICAgICAgIF90aGlzLm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZTogJ2hvb2tzJyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlUHJvcHNcIiwgZnVuY3Rpb24gKF9yZWYxNSkge1xuICAgICAgdmFyIGlkID0gX3JlZjE1LmlkLFxuICAgICAgICAgIHBhdGggPSBfcmVmMTUucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjE1LnJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkID0gX3JlZjE1Lndhc0ZvcndhcmRlZCxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYxNS52YWx1ZTtcblxuICAgICAgLy8gRG9uJ3QgZm9yd2FyZCBhIG1lc3NhZ2UgdGhhdCdzIGFscmVhZHkgYmVlbiBmb3J3YXJkZWQgYnkgdGhlIGZyb250LWVuZCBCcmlkZ2UuXG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgb3ZlcnJpZGUgY29tbWFuZCBvbmNlIVxuICAgICAgaWYgKCF3YXNGb3J3YXJkZWQpIHtcbiAgICAgICAgX3RoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib3ZlcnJpZGVTdGF0ZVwiLCBmdW5jdGlvbiAoX3JlZjE2KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMTYuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxNi5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTYucmVuZGVyZXJJRCxcbiAgICAgICAgICB3YXNGb3J3YXJkZWQgPSBfcmVmMTYud2FzRm9yd2FyZGVkLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjE2LnZhbHVlO1xuXG4gICAgICAvLyBEb24ndCBmb3J3YXJkIGEgbWVzc2FnZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGZvcndhcmRlZCBieSB0aGUgZnJvbnQtZW5kIEJyaWRnZS5cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBvdmVycmlkZSBjb21tYW5kIG9uY2UhXG4gICAgICBpZiAoIXdhc0ZvcndhcmRlZCkge1xuICAgICAgICBfdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgIHR5cGU6ICdzdGF0ZScsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJyZWxvYWRBbmRQcm9maWxlXCIsIGZ1bmN0aW9uIChyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICAgIE9iamVjdChzdG9yYWdlW1wiZVwiIC8qIHNlc3Npb25TdG9yYWdlU2V0SXRlbSAqL10pKGNvbnN0YW50c1tcImtcIiAvKiBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSAqL10sICd0cnVlJyk7XG4gICAgICBPYmplY3Qoc3RvcmFnZVtcImVcIiAvKiBzZXNzaW9uU3RvcmFnZVNldEl0ZW0gKi9dKShjb25zdGFudHNbXCJqXCIgLyogU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSAqL10sIHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/ICd0cnVlJyA6ICdmYWxzZScpOyAvLyBUaGlzIGNvZGUgcGF0aCBzaG91bGQgb25seSBiZSBoaXQgaWYgdGhlIHNoZWxsIGhhcyBleHBsaWNpdGx5IHRvbGQgdGhlIFN0b3JlIHRoYXQgaXQgc3VwcG9ydHMgcHJvZmlsaW5nLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgc2hlbGwgbXVzdCBhbHNvIGxpc3RlbiBmb3IgdGhpcyBzcGVjaWZpYyBtZXNzYWdlIHRvIGtub3cgd2hlbiBpdCBuZWVkcyB0byByZWxvYWQgdGhlIGFwcC5cbiAgICAgIC8vIFRoZSBhZ2VudCBjYW4ndCBkbyB0aGlzIGluIGEgd2F5IHRoYXQgaXMgcmVuZGVyZXIgYWdub3N0aWMuXG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgncmVsb2FkQXBwRm9yUHJvZmlsaW5nJyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbmFtZVBhdGhcIiwgZnVuY3Rpb24gKF9yZWYxNykge1xuICAgICAgdmFyIGhvb2tJRCA9IF9yZWYxNy5ob29rSUQsXG4gICAgICAgICAgaWQgPSBfcmVmMTcuaWQsXG4gICAgICAgICAgbmV3UGF0aCA9IF9yZWYxNy5uZXdQYXRoLFxuICAgICAgICAgIG9sZFBhdGggPSBfcmVmMTcub2xkUGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjE3LnJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYxNy50eXBlO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLnJlbmFtZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNldFRyYWNlVXBkYXRlc0VuYWJsZWRcIiwgZnVuY3Rpb24gKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgIF90aGlzLl90cmFjZVVwZGF0ZXNFbmFibGVkID0gdHJhY2VVcGRhdGVzRW5hYmxlZDtcbiAgICAgIHRvZ2dsZUVuYWJsZWQodHJhY2VVcGRhdGVzRW5hYmxlZCk7XG5cbiAgICAgIGZvciAodmFyIHJlbmRlcmVySUQgaW4gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgICAgICByZW5kZXJlci5zZXRUcmFjZVVwZGF0ZXNFbmFibGVkKHRyYWNlVXBkYXRlc0VuYWJsZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzeW5jU2VsZWN0aW9uRnJvbU5hdGl2ZUVsZW1lbnRzUGFuZWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhcmdldCA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uJDA7XG5cbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNlbGVjdE5vZGUodGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2h1dGRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2xlYW4gdXAgdGhlIG92ZXJsYXkgaWYgdmlzaWJsZSwgYW5kIGFzc29jaWF0ZWQgZXZlbnRzLlxuICAgICAgX3RoaXMuZW1pdCgnc2h1dGRvd24nKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhcnRQcm9maWxpbmdcIiwgZnVuY3Rpb24gKHJlY29yZENoYW5nZURlc2NyaXB0aW9ucykge1xuICAgICAgX3RoaXMuX3JlY29yZENoYW5nZURlc2NyaXB0aW9ucyA9IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucztcbiAgICAgIF90aGlzLl9pc1Byb2ZpbGluZyA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIHJlbmRlcmVySUQgaW4gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgICAgICByZW5kZXJlci5zdGFydFByb2ZpbGluZyhyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ1N0YXR1cycsIF90aGlzLl9pc1Byb2ZpbGluZyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0b3BQcm9maWxpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2lzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgICBfdGhpcy5fcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIHJlbmRlcmVySUQgaW4gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgICAgICByZW5kZXJlci5zdG9wUHJvZmlsaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgncHJvZmlsaW5nU3RhdHVzJywgX3RoaXMuX2lzUHJvZmlsaW5nKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RvcEluc3BlY3RpbmdOYXRpdmVcIiwgZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ3N0b3BJbnNwZWN0aW5nTmF0aXZlJywgc2VsZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdG9yZUFzR2xvYmFsXCIsIGZ1bmN0aW9uIChfcmVmMTgpIHtcbiAgICAgIHZhciBjb3VudCA9IF9yZWYxOC5jb3VudCxcbiAgICAgICAgICBpZCA9IF9yZWYxOC5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjE4LnBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYxOC5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLnN0b3JlQXNHbG9iYWwoaWQsIHBhdGgsIGNvdW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidXBkYXRlQ29uc29sZVBhdGNoU2V0dGluZ3NcIiwgZnVuY3Rpb24gKF9yZWYxOSkge1xuICAgICAgdmFyIGFwcGVuZENvbXBvbmVudFN0YWNrID0gX3JlZjE5LmFwcGVuZENvbXBvbmVudFN0YWNrLFxuICAgICAgICAgIGJyZWFrT25Db25zb2xlRXJyb3JzID0gX3JlZjE5LmJyZWFrT25Db25zb2xlRXJyb3JzLFxuICAgICAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IF9yZWYxOS5zaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMsXG4gICAgICAgICAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlID0gX3JlZjE5LmhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSxcbiAgICAgICAgICBicm93c2VyVGhlbWUgPSBfcmVmMTkuYnJvd3NlclRoZW1lO1xuICAgICAgLy8gSWYgdGhlIGZyb250ZW5kIHByZWZlcmVuY2VzIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIG9yIGluIHRoZSBjYXNlIG9mIFJlYWN0IE5hdGl2ZS0gaWYgdGhlIGJhY2tlbmQgaXMganVzdCBmaW5kaW5nIG91dCB0aGUgcHJlZmVyZW5jZXMtXG4gICAgICAvLyB0aGVuIHJlaW5zdGFsbCB0aGUgY29uc29sZSBvdmVycmlkZXMuXG4gICAgICAvLyBJdCdzIHNhZmUgdG8gY2FsbCBgcGF0Y2hDb25zb2xlYCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgIE9iamVjdChiYWNrZW5kX2NvbnNvbGVbXCJiXCIgLyogcGF0Y2ggKi9dKSh7XG4gICAgICAgIGFwcGVuZENvbXBvbmVudFN0YWNrOiBhcHBlbmRDb21wb25lbnRTdGFjayxcbiAgICAgICAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IGJyZWFrT25Db25zb2xlRXJyb3JzLFxuICAgICAgICBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnM6IHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyxcbiAgICAgICAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlOiBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUsXG4gICAgICAgIGJyb3dzZXJUaGVtZTogYnJvd3NlclRoZW1lXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidXBkYXRlQ29tcG9uZW50RmlsdGVyc1wiLCBmdW5jdGlvbiAoY29tcG9uZW50RmlsdGVycykge1xuICAgICAgZm9yICh2YXIgcmVuZGVyZXJJRCBpbiBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgICAgIHJlbmRlcmVyLnVwZGF0ZUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInZpZXdBdHRyaWJ1dGVTb3VyY2VcIiwgZnVuY3Rpb24gKF9yZWYyMCkge1xuICAgICAgdmFyIGlkID0gX3JlZjIwLmlkLFxuICAgICAgICAgIHBhdGggPSBfcmVmMjAucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjIwLnJlbmRlcmVySUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIucHJlcGFyZVZpZXdBdHRyaWJ1dGVTb3VyY2UoaWQsIHBhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ2aWV3RWxlbWVudFNvdXJjZVwiLCBmdW5jdGlvbiAoX3JlZjIxKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMjEuaWQsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYyMS5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLnByZXBhcmVWaWV3RWxlbWVudFNvdXJjZShpZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uVHJhY2VVcGRhdGVzXCIsIGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgX3RoaXMuZW1pdCgndHJhY2VVcGRhdGVzJywgbm9kZXMpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkZhc3RSZWZyZXNoU2NoZWR1bGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgICBhZ2VudF9kZWJ1Zygnb25GYXN0UmVmcmVzaFNjaGVkdWxlZCcpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ2Zhc3RSZWZyZXNoU2NoZWR1bGVkJyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uSG9va09wZXJhdGlvbnNcIiwgZnVuY3Rpb24gKG9wZXJhdGlvbnMpIHtcbiAgICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgICBhZ2VudF9kZWJ1Zygnb25Ib29rT3BlcmF0aW9ucycsIFwiKFwiLmNvbmNhdChvcGVyYXRpb25zLmxlbmd0aCwgXCIpIFtcIikuY29uY2F0KG9wZXJhdGlvbnMuam9pbignLCAnKSwgXCJdXCIpKTtcbiAgICAgIH0gLy8gVE9ETzpcbiAgICAgIC8vIFRoZSBjaHJvbWUucnVudGltZSBkb2VzIG5vdCBjdXJyZW50bHkgc3VwcG9ydCB0cmFuc2ZlcmFibGVzOyBpdCBmb3JjZXMgSlNPTiBzZXJpYWxpemF0aW9uLlxuICAgICAgLy8gU2VlIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MjcxMzRcbiAgICAgIC8vXG4gICAgICAvLyBSZWdhcmRpbmcgdHJhbnNmZXJhYmxlcywgdGhlIHBvc3RNZXNzYWdlIGRvYyBzdGF0ZXM6XG4gICAgICAvLyBJZiB0aGUgb3duZXJzaGlwIG9mIGFuIG9iamVjdCBpcyB0cmFuc2ZlcnJlZCwgaXQgYmVjb21lcyB1bnVzYWJsZSAobmV1dGVyZWQpXG4gICAgICAvLyBpbiB0aGUgY29udGV4dCBpdCB3YXMgc2VudCBmcm9tIGFuZCBiZWNvbWVzIGF2YWlsYWJsZSBvbmx5IHRvIHRoZSB3b3JrZXIgaXQgd2FzIHNlbnQgdG8uXG4gICAgICAvL1xuICAgICAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIGlzIGV2ZW50dWFsbHkgSlNPTiBzZXJpYWxpemluZyB0aGUgYXJyYXkgYnVmZmVyLFxuICAgICAgLy8gdXNpbmcgdGhlIHRyYW5zZmVyYWJsZSBhcHByb2FjaCBhbHNvIHNvbWV0aW1lcyBjYXVzZXMgaXQgdG8gdGhyb3c6XG4gICAgICAvLyAgIERPTUV4Y2VwdGlvbjogRmFpbGVkIHRvIGV4ZWN1dGUgJ3Bvc3RNZXNzYWdlJyBvbiAnV2luZG93JzogQXJyYXlCdWZmZXIgYXQgaW5kZXggMCBpcyBhbHJlYWR5IG5ldXRlcmVkLlxuICAgICAgLy9cbiAgICAgIC8vIFNlZSBidWcgaHR0cHM6Ly9naXRodWIuY29tL2J2YXVnaG4vcmVhY3QtZGV2dG9vbHMtZXhwZXJpbWVudGFsL2lzc3Vlcy8yNVxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBTdG9yZSBoYXMgYSBmYWxsYmFjayBpbiBwbGFjZSB0aGF0IHBhcnNlcyB0aGUgbWVzc2FnZSBhcyBKU09OIGlmIHRoZSB0eXBlIGlzbid0IGFuIGFycmF5LlxuICAgICAgLy8gRm9yIG5vdyB0aGUgc2ltcGxlc3QgZml4IHNlZW1zIHRvIGJlIHRvIG5vdCB0cmFuc2ZlciB0aGUgYXJyYXkuXG4gICAgICAvLyBUaGlzIHdpbGwgbmVnYXRpdmVseSBpbXBhY3QgcGVyZm9ybWFuY2Ugb24gRmlyZWZveCBzbyBpdCdzIHVuZm9ydHVuYXRlLFxuICAgICAgLy8gYnV0IHVudGlsIHdlJ3JlIGFibGUgdG8gZml4IHRoZSBDaHJvbWUgZXJyb3IgbWVudGlvbmVkIGFib3ZlLCBpdCBzZWVtcyBuZWNlc3NhcnkuXG4gICAgICAvL1xuICAgICAgLy8gdGhpcy5fYnJpZGdlLnNlbmQoJ29wZXJhdGlvbnMnLCBvcGVyYXRpb25zLCBbb3BlcmF0aW9ucy5idWZmZXJdKTtcblxuXG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ29wZXJhdGlvbnMnLCBvcGVyYXRpb25zKTtcblxuICAgICAgaWYgKF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVySUQgPSBvcGVyYXRpb25zWzBdO1xuXG4gICAgICAgIGlmIChfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uLnJlbmRlcmVySUQgPT09IHJlbmRlcmVySUQpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gc2VsZWN0IGEgZGVlcGVyIG1hdGNoIGZvciB0aGUgcGVyc2lzdGVkIHNlbGVjdGlvbi5cbiAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldk1hdGNoID0gX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoO1xuICAgICAgICAgICAgdmFyIG5leHRNYXRjaCA9IHJlbmRlcmVyLmdldEJlc3RNYXRjaEZvclRyYWNrZWRQYXRoKCk7XG4gICAgICAgICAgICBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uTWF0Y2ggPSBuZXh0TWF0Y2g7XG4gICAgICAgICAgICB2YXIgcHJldk1hdGNoSUQgPSBwcmV2TWF0Y2ggIT09IG51bGwgPyBwcmV2TWF0Y2guaWQgOiBudWxsO1xuICAgICAgICAgICAgdmFyIG5leHRNYXRjaElEID0gbmV4dE1hdGNoICE9PSBudWxsID8gbmV4dE1hdGNoLmlkIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHByZXZNYXRjaElEICE9PSBuZXh0TWF0Y2hJRCkge1xuICAgICAgICAgICAgICBpZiAobmV4dE1hdGNoSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtb3ZlZCBmb3J3YXJkLCB1bmxvY2tpbmcgYSBkZWVwZXIgbm9kZS5cbiAgICAgICAgICAgICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ3NlbGVjdEZpYmVyJywgbmV4dE1hdGNoSUQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0TWF0Y2ggIT09IG51bGwgJiYgbmV4dE1hdGNoLmlzRnVsbE1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ3ZlIGp1c3QgdW5sb2NrZWQgdGhlIGlubmVybW9zdCBzZWxlY3RlZCBub2RlLlxuICAgICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHBvaW50IHRyYWNraW5nIGl0IGZ1cnRoZXIuXG4gICAgICAgICAgICAgIF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uTWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJlci5zZXRUcmFja2VkUGF0aChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3Rocm90dGxlZFBlcnNpc3RTZWxlY3Rpb25cIiwgbG9kYXNoX3Rocm90dGxlX2RlZmF1bHQoKShmdW5jdGlvbiAocmVuZGVyZXJJRCwgaWQpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhyb3R0bGVkLCBzbyBib3RoIHJlbmRlcmVyIGFuZCBzZWxlY3RlZCBJRFxuICAgICAgLy8gbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBieSB0aGUgdGltZSB3ZSByZWFkIHRoZW0uXG4gICAgICAvLyBUaGlzIGlzIHdoeSB3ZSBuZWVkIHRoZSBkZWZlbnNpdmUgY2hlY2tzIGhlcmUuXG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgICAgdmFyIHBhdGggPSByZW5kZXJlciAhPSBudWxsID8gcmVuZGVyZXIuZ2V0UGF0aEZvckVsZW1lbnQoaWQpIDogbnVsbDtcblxuICAgICAgaWYgKHBhdGggIT09IG51bGwpIHtcbiAgICAgICAgT2JqZWN0KHN0b3JhZ2VbXCJlXCIgLyogc2Vzc2lvblN0b3JhZ2VTZXRJdGVtICovXSkoY29uc3RhbnRzW1wiaVwiIC8qIFNFU1NJT05fU1RPUkFHRV9MQVNUX1NFTEVDVElPTl9LRVkgKi9dLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdChzdG9yYWdlW1wiZFwiIC8qIHNlc3Npb25TdG9yYWdlUmVtb3ZlSXRlbSAqL10pKGNvbnN0YW50c1tcImlcIiAvKiBTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZICovXSk7XG4gICAgICB9XG4gICAgfSwgMTAwMCkpO1xuXG4gICAgaWYgKE9iamVjdChzdG9yYWdlW1wiY1wiIC8qIHNlc3Npb25TdG9yYWdlR2V0SXRlbSAqL10pKGNvbnN0YW50c1tcImtcIiAvKiBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSAqL10pID09PSAndHJ1ZScpIHtcbiAgICAgIF90aGlzLl9yZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPSBPYmplY3Qoc3RvcmFnZVtcImNcIiAvKiBzZXNzaW9uU3RvcmFnZUdldEl0ZW0gKi9dKShjb25zdGFudHNbXCJqXCIgLyogU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSAqL10pID09PSAndHJ1ZSc7XG4gICAgICBfdGhpcy5faXNQcm9maWxpbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0KHN0b3JhZ2VbXCJkXCIgLyogc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtICovXSkoY29uc3RhbnRzW1wialwiIC8qIFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkgKi9dKTtcbiAgICAgIE9iamVjdChzdG9yYWdlW1wiZFwiIC8qIHNlc3Npb25TdG9yYWdlUmVtb3ZlSXRlbSAqL10pKGNvbnN0YW50c1tcImtcIiAvKiBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSAqL10pO1xuICAgIH1cblxuICAgIHZhciBwZXJzaXN0ZWRTZWxlY3Rpb25TdHJpbmcgPSBPYmplY3Qoc3RvcmFnZVtcImNcIiAvKiBzZXNzaW9uU3RvcmFnZUdldEl0ZW0gKi9dKShjb25zdGFudHNbXCJpXCIgLyogU0VTU0lPTl9TVE9SQUdFX0xBU1RfU0VMRUNUSU9OX0tFWSAqL10pO1xuXG4gICAgaWYgKHBlcnNpc3RlZFNlbGVjdGlvblN0cmluZyAhPSBudWxsKSB7XG4gICAgICBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uID0gSlNPTi5wYXJzZShwZXJzaXN0ZWRTZWxlY3Rpb25TdHJpbmcpO1xuICAgIH1cblxuICAgIF90aGlzLl9icmlkZ2UgPSBicmlkZ2U7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjbGVhckVycm9yc0FuZFdhcm5pbmdzJywgX3RoaXMuY2xlYXJFcnJvcnNBbmRXYXJuaW5ncyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjbGVhckVycm9yc0ZvckZpYmVySUQnLCBfdGhpcy5jbGVhckVycm9yc0ZvckZpYmVySUQpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQnLCBfdGhpcy5jbGVhcldhcm5pbmdzRm9yRmliZXJJRCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjb3B5RWxlbWVudFBhdGgnLCBfdGhpcy5jb3B5RWxlbWVudFBhdGgpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZGVsZXRlUGF0aCcsIF90aGlzLmRlbGV0ZVBhdGgpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZ2V0QmFja2VuZFZlcnNpb24nLCBfdGhpcy5nZXRCYWNrZW5kVmVyc2lvbik7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRCcmlkZ2VQcm90b2NvbCcsIF90aGlzLmdldEJyaWRnZVByb3RvY29sKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2dldFByb2ZpbGluZ0RhdGEnLCBfdGhpcy5nZXRQcm9maWxpbmdEYXRhKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2dldFByb2ZpbGluZ1N0YXR1cycsIF90aGlzLmdldFByb2ZpbGluZ1N0YXR1cyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRPd25lcnNMaXN0JywgX3RoaXMuZ2V0T3duZXJzTGlzdCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdpbnNwZWN0RWxlbWVudCcsIF90aGlzLmluc3BlY3RFbGVtZW50KTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2xvZ0VsZW1lbnRUb0NvbnNvbGUnLCBfdGhpcy5sb2dFbGVtZW50VG9Db25zb2xlKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlRXJyb3InLCBfdGhpcy5vdmVycmlkZUVycm9yKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlU3VzcGVuc2UnLCBfdGhpcy5vdmVycmlkZVN1c3BlbnNlKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlVmFsdWVBdFBhdGgnLCBfdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3JlbG9hZEFuZFByb2ZpbGUnLCBfdGhpcy5yZWxvYWRBbmRQcm9maWxlKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3JlbmFtZVBhdGgnLCBfdGhpcy5yZW5hbWVQYXRoKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3NldFRyYWNlVXBkYXRlc0VuYWJsZWQnLCBfdGhpcy5zZXRUcmFjZVVwZGF0ZXNFbmFibGVkKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0YXJ0UHJvZmlsaW5nJywgX3RoaXMuc3RhcnRQcm9maWxpbmcpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc3RvcFByb2ZpbGluZycsIF90aGlzLnN0b3BQcm9maWxpbmcpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc3RvcmVBc0dsb2JhbCcsIF90aGlzLnN0b3JlQXNHbG9iYWwpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc3luY1NlbGVjdGlvbkZyb21OYXRpdmVFbGVtZW50c1BhbmVsJywgX3RoaXMuc3luY1NlbGVjdGlvbkZyb21OYXRpdmVFbGVtZW50c1BhbmVsKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgX3RoaXMuc2h1dGRvd24pO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigndXBkYXRlQ29uc29sZVBhdGNoU2V0dGluZ3MnLCBfdGhpcy51cGRhdGVDb25zb2xlUGF0Y2hTZXR0aW5ncyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCd1cGRhdGVDb21wb25lbnRGaWx0ZXJzJywgX3RoaXMudXBkYXRlQ29tcG9uZW50RmlsdGVycyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCd2aWV3QXR0cmlidXRlU291cmNlJywgX3RoaXMudmlld0F0dHJpYnV0ZVNvdXJjZSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCd2aWV3RWxlbWVudFNvdXJjZScsIF90aGlzLnZpZXdFbGVtZW50U291cmNlKTsgLy8gVGVtcG9yYXJpbHkgc3VwcG9ydCBvbGRlciBzdGFuZGFsb25lIGZyb250LWVuZHMgc2VuZGluZyBjb21tYW5kcyB0byBuZXdlciBlbWJlZGRlZCBiYWNrZW5kcy5cbiAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgUmVhY3QgTmF0aXZlIGVtYmVkcyB0aGUgUmVhY3QgRGV2VG9vbHMgYmFja2VuZCxcbiAgICAvLyBidXQgY2Fubm90IGNvbnRyb2wgd2hpY2ggdmVyc2lvbiBvZiB0aGUgZnJvbnRlbmQgdXNlcnMgdXNlLlxuXG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZUNvbnRleHQnLCBfdGhpcy5vdmVycmlkZUNvbnRleHQpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVIb29rU3RhdGUnLCBfdGhpcy5vdmVycmlkZUhvb2tTdGF0ZSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZVByb3BzJywgX3RoaXMub3ZlcnJpZGVQcm9wcyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZVN0YXRlJywgX3RoaXMub3ZlcnJpZGVTdGF0ZSk7XG5cbiAgICBpZiAoX3RoaXMuX2lzUHJvZmlsaW5nKSB7XG4gICAgICBicmlkZ2Uuc2VuZCgncHJvZmlsaW5nU3RhdHVzJywgdHJ1ZSk7XG4gICAgfSAvLyBTZW5kIHRoZSBCcmlkZ2UgcHJvdG9jb2wgYW5kIGJhY2tlbmQgdmVyc2lvbnMsIGFmdGVyIGluaXRpYWxpemF0aW9uLCBpbiBjYXNlIHRoZSBmcm9udGVuZCBoYXMgYWxyZWFkeSByZXF1ZXN0ZWQgaXQuXG4gICAgLy8gVGhlIFN0b3JlIG1heSBiZSBpbnN0YW50aWF0ZWQgYmVvcmUgdGhlIGFnZW50LlxuXG5cbiAgICB2YXIgX3ZlcnNpb24gPSBcIjQuMjcuNi03ZjhjNTAxZjZcIjtcblxuICAgIGlmIChfdmVyc2lvbikge1xuICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdiYWNrZW5kVmVyc2lvbicsIF92ZXJzaW9uKTtcbiAgICB9XG5cbiAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ2JyaWRnZVByb3RvY29sJywgY3VycmVudEJyaWRnZVByb3RvY29sKTsgLy8gTm90aWZ5IHRoZSBmcm9udGVuZCBpZiB0aGUgYmFja2VuZCBzdXBwb3J0cyB0aGUgU3RvcmFnZSBBUEkgKGUuZy4gbG9jYWxTdG9yYWdlKS5cbiAgICAvLyBJZiBub3QsIGZlYXR1cmVzIGxpa2UgcmVsb2FkLWFuZC1wcm9maWxlIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGFuZCBtdXN0IGJlIGRpc2FibGVkLlxuXG5cbiAgICB2YXIgaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0ZXN0Jyk7XG4gICAgICBpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge31cblxuICAgIGJyaWRnZS5zZW5kKCdpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkJywgaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZCk7XG4gICAgYnJpZGdlLnNlbmQoJ2lzU3luY2hyb25vdXNYSFJTdXBwb3J0ZWQnLCBPYmplY3QodXRpbHNbXCJrXCIgLyogaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZCAqL10pKCkpO1xuICAgIHNldHVwSGlnaGxpZ2h0ZXIoYnJpZGdlLCBhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBUcmFjZVVwZGF0ZXNfaW5pdGlhbGl6ZShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBhZ2VudF9jcmVhdGVDbGFzcyhBZ2VudCwgW3tcbiAgICBrZXk6IFwiZ2V0SW5zdGFuY2VBbmRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZUFuZFN0eWxlKF9yZWYyMikge1xuICAgICAgdmFyIGlkID0gX3JlZjIyLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMjIucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0SW5zdGFuY2VBbmRTdHlsZShpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJlc3RNYXRjaGluZ1JlbmRlcmVySW50ZXJmYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJlc3RNYXRjaGluZ1JlbmRlcmVySW50ZXJmYWNlKG5vZGUpIHtcbiAgICAgIHZhciBiZXN0TWF0Y2ggPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciByZW5kZXJlcklEIGluIHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgICAgIHZhciBmaWJlciA9IHJlbmRlcmVyLmdldEZpYmVyRm9yTmF0aXZlKG5vZGUpO1xuXG4gICAgICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGZpYmVyLnN0YXRlTm9kZSBpcyBtYXRjaGluZyB0aGUgb3JpZ2luYWwgaG9zdEluc3RhbmNlXG4gICAgICAgICAgaWYgKGZpYmVyLnN0YXRlTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmVzdE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBiZXN0TWF0Y2ggPSByZW5kZXJlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgYW4gZXhhY3QgbWF0Y2ggaXMgbm90IGZvdW5kLCByZXR1cm4gdGhlIGZpcnN0IHZhbGlkIHJlbmRlcmVyIGFzIGZhbGxiYWNrXG5cblxuICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SURGb3JOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElERm9yTm9kZShub2RlKSB7XG4gICAgICB2YXIgcmVuZGVyZXJJbnRlcmZhY2UgPSB0aGlzLmdldEJlc3RNYXRjaGluZ1JlbmRlcmVySW50ZXJmYWNlKG5vZGUpO1xuXG4gICAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJlckludGVyZmFjZS5nZXRGaWJlcklERm9yTmF0aXZlKG5vZGUsIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIFNvbWUgb2xkIFJlYWN0IHZlcnNpb25zIG1pZ2h0IHRocm93IGlmIHRoZXkgY2FuJ3QgZmluZCBhIG1hdGNoLlxuICAgICAgICAgIC8vIElmIHNvIHdlIHNob3VsZCBpZ25vcmUgaXQuLi5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROb2RlKHRhcmdldCkge1xuICAgICAgdmFyIGlkID0gdGhpcy5nZXRJREZvck5vZGUodGFyZ2V0KTtcblxuICAgICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2JyaWRnZS5zZW5kKCdzZWxlY3RGaWJlcicsIGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UmVuZGVyZXJJbnRlcmZhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVuZGVyZXJJbnRlcmZhY2UocmVuZGVyZXJJRCwgcmVuZGVyZXJJbnRlcmZhY2UpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXSA9IHJlbmRlcmVySW50ZXJmYWNlO1xuXG4gICAgICBpZiAodGhpcy5faXNQcm9maWxpbmcpIHtcbiAgICAgICAgcmVuZGVyZXJJbnRlcmZhY2Uuc3RhcnRQcm9maWxpbmcodGhpcy5fcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXJJbnRlcmZhY2Uuc2V0VHJhY2VVcGRhdGVzRW5hYmxlZCh0aGlzLl90cmFjZVVwZGF0ZXNFbmFibGVkKTsgLy8gV2hlbiB0aGUgcmVuZGVyZXIgaXMgYXR0YWNoZWQsIHdlIG5lZWQgdG8gdGVsbCBpdCB3aGV0aGVyXG4gICAgICAvLyB3ZSByZW1lbWJlciB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIHRoYXQgd2UnZCBsaWtlIHRvIHJlc3RvcmUuXG4gICAgICAvLyBJdCdsbCBzdGFydCB0cmFja2luZyBtb3VudHMgZm9yIG1hdGNoZXMgdG8gdGhlIGxhc3Qgc2VsZWN0aW9uIHBhdGguXG5cbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwgJiYgc2VsZWN0aW9uLnJlbmRlcmVySUQgPT09IHJlbmRlcmVySUQpIHtcbiAgICAgICAgcmVuZGVyZXJJbnRlcmZhY2Uuc2V0VHJhY2tlZFBhdGgoc2VsZWN0aW9uLnBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblVuc3VwcG9ydGVkUmVuZGVyZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25VbnN1cHBvcnRlZFJlbmRlcmVyKHJlbmRlcmVySUQpIHtcbiAgICAgIHRoaXMuX2JyaWRnZS5zZW5kKCd1bnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbicsIHJlbmRlcmVySUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJlckludGVyZmFjZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlckludGVyZmFjZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFnZW50O1xufShFdmVudEVtaXR0ZXIpO1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaG9vay5qc1xuZnVuY3Rpb24gaG9va190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IGhvb2tfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGhvb2tfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGhvb2tfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gaG9va190b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIGhvb2tfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBob29rX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IGhvb2tfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBob29rX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gaG9va19ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gaG9va191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGhvb2tfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGhvb2tfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGhvb2tfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gaG9va19hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGhvb2tfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIGhvb2tfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBJbnN0YWxsIHRoZSBob29rIG9uIHdpbmRvdywgd2hpY2ggaXMgYW4gZXZlbnQgZW1pdHRlci5cbiAqIE5vdGU6IHRoaXMgZ2xvYmFsIGhvb2sgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIGlzIGEgZGUgZmFjdG8gcHVibGljIEFQSS5cbiAqIEl0J3MgZXNwZWNpYWxseSBpbXBvcnRhbnQgdG8gYXZvaWQgY3JlYXRpbmcgZGlyZWN0IGRlcGVuZGVuY3kgb24gdGhlIERldlRvb2xzIEJhY2tlbmQuXG4gKiBUaGF0J3Mgd2h5IHdlIHN0aWxsIGlubGluZSB0aGUgd2hvbGUgZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbixcbiAqIHRoZSBzdHJpbmcgZm9ybWF0IGltcGxlbWVudGF0aW9uLCBhbmQgcGFydCBvZiB0aGUgY29uc29sZSBpbXBsZW1lbnRhdGlvbiBoZXJlLlxuICpcbiAqIFxuICovXG5mdW5jdGlvbiBpbnN0YWxsSG9vayh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgnX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fJykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB0YXJnZXRDb25zb2xlID0gY29uc29sZTtcbiAgdmFyIHRhcmdldENvbnNvbGVNZXRob2RzID0ge307XG5cbiAgZm9yICh2YXIgbWV0aG9kIGluIGNvbnNvbGUpIHtcbiAgICB0YXJnZXRDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gY29uc29sZVttZXRob2RdO1xuICB9XG5cbiAgZnVuY3Rpb24gZGFuZ2Vyb3VzX3NldFRhcmdldENvbnNvbGVGb3JUZXN0aW5nKHRhcmdldENvbnNvbGVGb3JUZXN0aW5nKSB7XG4gICAgdGFyZ2V0Q29uc29sZSA9IHRhcmdldENvbnNvbGVGb3JUZXN0aW5nO1xuICAgIHRhcmdldENvbnNvbGVNZXRob2RzID0ge307XG5cbiAgICBmb3IgKHZhciBfbWV0aG9kIGluIHRhcmdldENvbnNvbGUpIHtcbiAgICAgIHRhcmdldENvbnNvbGVNZXRob2RzW19tZXRob2RdID0gY29uc29sZVtfbWV0aG9kXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRlY3RSZWFjdEJ1aWxkVHlwZShyZW5kZXJlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFJlYWN0IERPTSBGaWJlciAoMTYrKVxuICAgICAgICBpZiAocmVuZGVyZXIuYnVuZGxlVHlwZSA+IDApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIHByb2R1Y3Rpb24gYnVpbGQuXG4gICAgICAgICAgLy8gV2UgYXJlIGN1cnJlbnRseSBvbmx5IHVzaW5nIDAgKFBST0QpIGFuZCAxIChERVYpXG4gICAgICAgICAgLy8gYnV0IG1pZ2h0IGFkZCAyIChQUk9GSUxFKSBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICB9IC8vIFJlYWN0IDE2IHVzZXMgZmxhdCBidW5kbGVzLiBJZiB3ZSByZXBvcnQgdGhlIGJ1bmRsZSBhcyBwcm9kdWN0aW9uXG4gICAgICAgIC8vIHZlcnNpb24sIGl0IG1lYW5zIHdlIGFsc28gbWluaWZpZWQgYW5kIGVudmlmaWVkIGl0IG91cnNlbHZlcy5cblxuXG4gICAgICAgIHJldHVybiAncHJvZHVjdGlvbic7IC8vIE5vdGU6IFRoZXJlIGlzIHN0aWxsIGEgcmlzayB0aGF0IHRoZSBDb21tb25KUyBlbnRyeSBwb2ludCBoYXMgbm90XG4gICAgICAgIC8vIGJlZW4gZW52aWZpZWQgb3IgdWdsaWZpZWQuIEluIHRoaXMgY2FzZSB0aGUgdXNlciB3b3VsZCBoYXZlICpib3RoKlxuICAgICAgICAvLyBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiBidW5kbGUsIGJ1dCBvbmx5IHRoZSBwcm9kIG9uZSB3b3VsZCBydW4uXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgcmVhbGx5IGJhZC4gV2UgaGF2ZSBhIHNlcGFyYXRlIGNoZWNrIGZvciB0aGlzIGJlY2F1c2VcbiAgICAgICAgLy8gaXQgaGFwcGVucyAqb3V0c2lkZSogb2YgdGhlIHJlbmRlcmVyIGluamVjdGlvbi4gU2VlIGBjaGVja0RDRWAgYmVsb3cuXG4gICAgICB9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuXG4gICAgICB2YXIgX3RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgICBpZiAocmVuZGVyZXIuTW91bnQgJiYgcmVuZGVyZXIuTW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQpIHtcbiAgICAgICAgLy8gUmVhY3QgRE9NIFN0YWNrXG4gICAgICAgIHZhciByZW5kZXJSb290Q29kZSA9IF90b1N0cmluZy5jYWxsKHJlbmRlcmVyLk1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KTsgLy8gRmlsdGVyIG91dCBiYWQgcmVzdWx0cyAoaWYgdGhhdCBpcyBldmVuIHBvc3NpYmxlKTpcblxuXG4gICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdmdW5jdGlvbicpICE9PSAwKSB7XG4gICAgICAgICAgLy8gSG9wZSBmb3IgdGhlIGJlc3QgaWYgd2UncmUgbm90IHN1cmUuXG4gICAgICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJztcbiAgICAgICAgfSAvLyBDaGVjayBmb3IgUmVhY3QgRE9NIFN0YWNrIDwgMTUuMS4wIGluIGRldmVsb3BtZW50LlxuICAgICAgICAvLyBJZiBpdCBjb250YWlucyBcInN0b3JlZE1lYXN1cmVcIiBjYWxsLCBpdCdzIHdyYXBwZWQgaW4gUmVhY3RQZXJmIChERVYgb25seSkuXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgdHJ1ZSBldmVuIGlmIGl0J3MgbWluaWZpZWQsIGFzIG1ldGhvZCBuYW1lIHN0aWxsIG1hdGNoZXMuXG5cblxuICAgICAgICBpZiAocmVuZGVyUm9vdENvZGUuaW5kZXhPZignc3RvcmVkTWVhc3VyZScpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICB9IC8vIEZvciBvdGhlciB2ZXJzaW9ucyAoYW5kIGNvbmZpZ3VyYXRpb25zKSBpdCdzIG5vdCBzbyBlYXN5LlxuICAgICAgICAvLyBMZXQncyBxdWlja2x5IGV4Y2x1ZGUgcHJvcGVyIHByb2R1Y3Rpb24gYnVpbGRzLlxuICAgICAgICAvLyBJZiBpdCBjb250YWlucyBhIHdhcm5pbmcgbWVzc2FnZSwgaXQncyBlaXRoZXIgYSBERVYgYnVpbGQsXG4gICAgICAgIC8vIG9yIGFuIFBST0QgYnVpbGQgd2l0aG91dCBwcm9wZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uLlxuXG5cbiAgICAgICAgaWYgKHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBOb3cgaG93IGRvIHdlIHRlbGwgYSBERVYgYnVpbGQgZnJvbSBhIGJhZCBQUk9EIGJ1aWxkP1xuICAgICAgICAgIC8vIElmIHdlIHNlZSBOT0RFX0VOViwgd2UncmUgZ29pbmcgdG8gYXNzdW1lIHRoaXMgaXMgYSBkZXYgYnVpbGRcbiAgICAgICAgICAvLyBiZWNhdXNlIG1vc3QgbGlrZWx5IGl0IGlzIHJlZmVycmluZyB0byBhbiBlbXB0eSBzaGltLlxuICAgICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdOT0RFX0VOVicpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgICAgfSAvLyBJZiB3ZSBzZWUgXCJkZXZlbG9wbWVudFwiLCB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gZW52aWZpZWQgREVWIGJ1aWxkXG4gICAgICAgICAgLy8gKHN1Y2ggYXMgdGhlIG9mZmljaWFsIFJlYWN0IERFViBVTUQpLlxuXG5cbiAgICAgICAgICBpZiAocmVuZGVyUm9vdENvZGUuaW5kZXhPZignZGV2ZWxvcG1lbnQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICAgIH0gLy8gSSd2ZSBzZWVuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgYmVpbmcgc21hcnRseVxuICAgICAgICAgIC8vIHJlcGxhY2VkIGJ5IGB0cnVlYCBpbiBERVYgYnkgV2VicGFjay4gSSBkb24ndCBrbm93IGhvdyB0aGF0XG4gICAgICAgICAgLy8gd29ya3MgYnV0IHdlIGNhbiBzYWZlbHkgZ3VhcmQgYWdhaW5zdCBpdCBiZWNhdXNlIGB0cnVlYCB3YXNcbiAgICAgICAgICAvLyBuZXZlciB1c2VkIGluIHRoZSBmdW5jdGlvbiBzb3VyY2Ugc2luY2UgaXQgd2FzIHdyaXR0ZW4uXG5cblxuICAgICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCd0cnVlJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgICB9IC8vIEJ5IG5vdyBlaXRoZXIgaXQgaXMgYSBwcm9kdWN0aW9uIGJ1aWxkIHRoYXQgaGFzIG5vdCBiZWVuIG1pbmlmaWVkLFxuICAgICAgICAgIC8vIG9yICh3b3JzZSkgdGhpcyBpcyBhIG1pbmlmaWVkIGRldmVsb3BtZW50IGJ1aWxkIHVzaW5nIG5vbi1zdGFuZGFyZFxuICAgICAgICAgIC8vIGVudmlyb25tZW50IChlLmcuIFwic3RhZ2luZ1wiKS4gV2UncmUgZ29pbmcgdG8gbG9vayBhdCB3aGV0aGVyXG4gICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IG5hbWUgaXMgbWFuZ2xlZDpcblxuXG4gICAgICAgICAgaWYgKCAvLyAwLjEzIHRvIDE1XG4gICAgICAgICAgcmVuZGVyUm9vdENvZGUuaW5kZXhPZignbmV4dEVsZW1lbnQnKSAhPT0gLTEgfHwgLy8gMC4xMlxuICAgICAgICAgIHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ25leHRDb21wb25lbnQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGJlIGNlcnRhaW4gd2hldGhlciB0aGlzIGlzIGEgZGV2ZWxvcG1lbnQgYnVpbGQgb3Igbm90LFxuICAgICAgICAgICAgLy8gYnV0IGl0IGlzIGRlZmluaXRlbHkgdW5taW5pZmllZC5cbiAgICAgICAgICAgIHJldHVybiAndW5taW5pZmllZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgbWluaWZpZWQgZGV2ZWxvcG1lbnQgYnVpbGQuXG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQnkgbm93IHdlIGtub3cgdGhhdCBpdCdzIGVudmlmaWVkIGFuZCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd29ya2VkLFxuICAgICAgICAvLyBidXQgd2hhdCBpZiBpdCdzIHN0aWxsIG5vdCBtaW5pZmllZD8gKElzIHRoaXMgZXZlbiBwb3NzaWJsZT8pXG4gICAgICAgIC8vIExldCdzIGNoZWNrIG1hdGNoZXMgZm9yIHRoZSBmaXJzdCBhcmd1bWVudCBuYW1lLlxuXG5cbiAgICAgICAgaWYgKCAvLyAwLjEzIHRvIDE1XG4gICAgICAgIHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ25leHRFbGVtZW50JykgIT09IC0xIHx8IC8vIDAuMTJcbiAgICAgICAgcmVuZGVyUm9vdENvZGUuaW5kZXhPZignbmV4dENvbXBvbmVudCcpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiAndW5taW5pZmllZCc7XG4gICAgICAgIH0gLy8gU2VlbXMgbGlrZSB3ZSdyZSB1c2luZyB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uLlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYnJhbmNoIGFib3ZlIGlzIFN0YWNrLW9ubHkgc28gdGhpcyBpcyAxNSBvciBlYXJsaWVyLlxuXG5cbiAgICAgICAgcmV0dXJuICdvdXRkYXRlZCc7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7Ly8gV2VpcmQgZW52aXJvbm1lbnRzIG1heSBleGlzdC5cbiAgICAgIC8vIFRoaXMgY29kZSBuZWVkcyBhIGhpZ2hlciBmYXVsdCB0b2xlcmFuY2VcbiAgICAgIC8vIGJlY2F1c2UgaXQgcnVucyBldmVuIHdpdGggY2xvc2VkIERldlRvb2xzLlxuICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGNhdGNoIGVycm9ycyBpbiBhbGwgaW5qZWN0ZWQgY29kZSwgYW5kIG5vdCBqdXN0IHRoaXMgcGFydD9cbiAgICB9XG5cbiAgICByZXR1cm4gJ3Byb2R1Y3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEQ0UoZm4pIHtcbiAgICAvLyBUaGlzIHJ1bnMgZm9yIHByb2R1Y3Rpb24gdmVyc2lvbnMgb2YgUmVhY3QuXG4gICAgLy8gTmVlZHMgdG8gYmUgc3VwZXIgc2FmZS5cbiAgICB0cnkge1xuICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgdmFyIF90b1N0cmluZzIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAgIHZhciBjb2RlID0gX3RvU3RyaW5nMi5jYWxsKGZuKTsgLy8gVGhpcyBpcyBhIHN0cmluZyBlbWJlZGRlZCBpbiB0aGUgcGFzc2VkIGZ1bmN0aW9uIHVuZGVyIERFVi1vbmx5XG4gICAgICAvLyBjb25kaXRpb24uIEhvd2V2ZXIgdGhlIGZ1bmN0aW9uIGV4ZWN1dGVzIG9ubHkgaW4gUFJPRC4gVGhlcmVmb3JlLFxuICAgICAgLy8gaWYgd2Ugc2VlIGl0LCBkZWFkIGNvZGUgZWxpbWluYXRpb24gZGlkIG5vdCB3b3JrLlxuXG5cbiAgICAgIGlmIChjb2RlLmluZGV4T2YoJ15fXicpID4gLTEpIHtcbiAgICAgICAgLy8gUmVtZW1iZXIgdG8gcmVwb3J0IGR1cmluZyBuZXh0IGluamVjdGlvbi5cbiAgICAgICAgaGFzRGV0ZWN0ZWRCYWREQ0UgPSB0cnVlOyAvLyBCb251czogdGhyb3cgYW4gZXhjZXB0aW9uIGhvcGluZyB0aGF0IGl0IGdldHMgcGlja2VkIHVwIGJ5IGEgcmVwb3J0aW5nIHN5c3RlbS5cbiAgICAgICAgLy8gTm90IHN5bmNocm9ub3VzbHkgc28gdGhhdCBpdCBkb2Vzbid0IGJyZWFrIHRoZSBjYWxsaW5nIGNvZGUuXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBpcyBydW5uaW5nIGluIHByb2R1Y3Rpb24gbW9kZSwgYnV0IGRlYWQgY29kZSAnICsgJ2VsaW1pbmF0aW9uIGhhcyBub3QgYmVlbiBhcHBsaWVkLiBSZWFkIGhvdyB0byBjb3JyZWN0bHkgJyArICdjb25maWd1cmUgUmVhY3QgZm9yIHByb2R1Y3Rpb246ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3BlcmYtdXNlLXByb2R1Y3Rpb24tYnVpbGQnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9IC8vIE5PVEU6IEtFRVAgSU4gU1lOQyB3aXRoIHNyYy9iYWNrZW5kL3V0aWxzLmpzXG5cblxuICBmdW5jdGlvbiBmb3JtYXRXaXRoU3R5bGVzKGlucHV0QXJncywgc3R5bGUpIHtcbiAgICBpZiAoaW5wdXRBcmdzID09PSB1bmRlZmluZWQgfHwgaW5wdXRBcmdzID09PSBudWxsIHx8IGlucHV0QXJncy5sZW5ndGggPT09IDAgfHwgLy8gTWF0Y2hlcyBhbnkgb2YgJWMgYnV0IG5vdCAlJWNcbiAgICB0eXBlb2YgaW5wdXRBcmdzWzBdID09PSAnc3RyaW5nJyAmJiBpbnB1dEFyZ3NbMF0ubWF0Y2goLyhbXiVdfF4pKCVjKS9nKSB8fCBzdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaW5wdXRBcmdzO1xuICAgIH0gLy8gTWF0Y2hlcyBhbnkgb2YgJShvfE98ZHxpfHN8ZiksIGJ1dCBub3QgJSUob3xPfGR8aXxzfGYpXG5cblxuICAgIHZhciBSRUdFWFAgPSAvKFteJV18XikoKCUlKSopKCUoW29PZGlzZl0pKS9nO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dEFyZ3NbMF0gPT09ICdzdHJpbmcnICYmIGlucHV0QXJnc1swXS5tYXRjaChSRUdFWFApKSB7XG4gICAgICByZXR1cm4gW1wiJWNcIi5jb25jYXQoaW5wdXRBcmdzWzBdKSwgc3R5bGVdLmNvbmNhdChob29rX3RvQ29uc3VtYWJsZUFycmF5KGlucHV0QXJncy5zbGljZSgxKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RBcmcgPSBpbnB1dEFyZ3MucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRTdHIsIGVsZW0sIGkpIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgZm9ybWF0U3RyICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoaG9va190eXBlb2YoZWxlbSkpIHtcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyICs9ICclcyc7XG5cbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgdmFyIGZvcm1hdHRpbmcgPSBOdW1iZXIuaXNJbnRlZ2VyKGVsZW0pID8gJyVpJyA6ICclZic7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyICs9IGZvcm1hdHRpbmc7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFN0ciArPSAnJW8nO1xuICAgICAgICB9XG4gICAgICB9LCAnJWMnKTtcbiAgICAgIHJldHVybiBbZmlyc3RBcmcsIHN0eWxlXS5jb25jYXQoaG9va190b0NvbnN1bWFibGVBcnJheShpbnB1dEFyZ3MpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5wYXRjaEZuID0gbnVsbDsgLy8gTk9URTogS0VFUCBJTiBTWU5DIHdpdGggc3JjL2JhY2tlbmQvY29uc29sZS5qczpwYXRjaEZvclN0cmljdE1vZGVcbiAgLy8gVGhpcyBmdW5jdGlvbiBoaWRlcyBvciBkaW1zIGNvbnNvbGUgbG9ncyBkdXJpbmcgdGhlIGluaXRpYWwgZG91YmxlIHJlbmRlcmVyXG4gIC8vIGluIFN0cmljdCBNb2RlLiBXZSBuZWVkIHRoaXMgZnVuY3Rpb24gYmVjYXVzZSBkdXJpbmcgaW5pdGlhbCByZW5kZXIsXG4gIC8vIFJlYWN0IGFuZCBEZXZUb29scyBhcmUgY29ubmVjdGluZyBhbmQgdGhlIHJlbmRlcmVyIGludGVyZmFjZSBpc24ndCBhdmFpYWJsZVxuICAvLyBhbmQgd2Ugd2FudCB0byBiZSBhYmxlIHRvIGhhdmUgY29uc2lzdGVudCBsb2dnaW5nIGJlaGF2aW9yIGZvciBkb3VibGUgbG9nc1xuICAvLyBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyZXIuXG5cbiAgZnVuY3Rpb24gcGF0Y2hDb25zb2xlRm9ySW5pdGlhbFJlbmRlckluU3RyaWN0TW9kZShfcmVmKSB7XG4gICAgdmFyIGhpZGVDb25zb2xlTG9nc0luU3RyaWN0TW9kZSA9IF9yZWYuaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlLFxuICAgICAgICBicm93c2VyVGhlbWUgPSBfcmVmLmJyb3dzZXJUaGVtZTtcbiAgICB2YXIgb3ZlcnJpZGVDb25zb2xlTWV0aG9kcyA9IFsnZXJyb3InLCAnZ3JvdXAnLCAnZ3JvdXBDb2xsYXBzZWQnLCAnaW5mbycsICdsb2cnLCAndHJhY2UnLCAnd2FybiddO1xuXG4gICAgaWYgKHVucGF0Y2hGbiAhPT0gbnVsbCkge1xuICAgICAgLy8gRG9uJ3QgcGF0Y2ggdHdpY2UuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTtcblxuICAgIHVucGF0Y2hGbiA9IGZ1bmN0aW9uIHVucGF0Y2hGbigpIHtcbiAgICAgIGZvciAodmFyIF9tZXRob2QyIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXJnZXRDb25zb2xlW19tZXRob2QyXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbX21ldGhvZDJdO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgb3ZlcnJpZGVDb25zb2xlTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXSA9IHRhcmdldENvbnNvbGVbbWV0aG9kXS5fX1JFQUNUX0RFVlRPT0xTX1NUUklDVF9NT0RFX09SSUdJTkFMX01FVEhPRF9fID8gdGFyZ2V0Q29uc29sZVttZXRob2RdLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1JJR0lOQUxfTUVUSE9EX18gOiB0YXJnZXRDb25zb2xlW21ldGhvZF07XG5cbiAgICAgICAgdmFyIG92ZXJyaWRlTWV0aG9kID0gZnVuY3Rpb24gb3ZlcnJpZGVNZXRob2QoKSB7XG4gICAgICAgICAgaWYgKCFoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgIC8vIERpbSB0aGUgdGV4dCBjb2xvciBvZiB0aGUgZG91YmxlIGxvZ3MgaWYgd2UncmUgbm90XG4gICAgICAgICAgICAvLyBoaWRpbmcgdGhlbS5cbiAgICAgICAgICAgIHZhciBjb2xvcjtcblxuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICAgICAgY29sb3IgPSBicm93c2VyVGhlbWUgPT09ICdsaWdodCcgPyBcInJnYmEoMjUwLCAxODAsIDUwLCAwLjc1KVwiIDogXCJyZ2JhKDI1MCwgMTgwLCA1MCwgMC41KVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBjb2xvciA9IGJyb3dzZXJUaGVtZSA9PT0gJ2xpZ2h0JyA/IFwicmdiYSgyNTAsIDEyMywgMTMwLCAwLjc1KVwiIDogXCJyZ2JhKDI1MCwgMTIzLCAxMzAsIDAuNSlcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbG9yID0gYnJvd3NlclRoZW1lID09PSAnbGlnaHQnID8gXCJyZ2JhKDEyNSwgMTI1LCAxMjUsIDAuNzUpXCIgOiBcInJnYmEoMTI1LCAxMjUsIDEyNSwgMC41KVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHZvaWQgMCwgaG9va190b0NvbnN1bWFibGVBcnJheShmb3JtYXRXaXRoU3R5bGVzKGFyZ3MsIFwiY29sb3I6IFwiLmNvbmNhdChjb2xvcikpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ29uc29sZSBjb2xvciBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvdmVycmlkZU1ldGhvZC5fX1JFQUNUX0RFVlRPT0xTX1NUUklDVF9NT0RFX09SSUdJTkFMX01FVEhPRF9fID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICAgIG9yaWdpbmFsTWV0aG9kLl9fUkVBQ1RfREVWVE9PTFNfU1RSSUNUX01PREVfT1ZFUlJJREVfTUVUSE9EX18gPSBvdmVycmlkZU1ldGhvZDtcbiAgICAgICAgdGFyZ2V0Q29uc29sZVttZXRob2RdID0gb3ZlcnJpZGVNZXRob2Q7XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9KTtcbiAgfSAvLyBOT1RFOiBLRUVQIElOIFNZTkMgd2l0aCBzcmMvYmFja2VuZC9jb25zb2xlLmpzOnVucGF0Y2hGb3JTdHJpY3RNb2RlXG5cblxuICBmdW5jdGlvbiB1bnBhdGNoQ29uc29sZUZvckluaXRpYWxSZW5kZXJJblN0cmljdE1vZGUoKSB7XG4gICAgaWYgKHVucGF0Y2hGbiAhPT0gbnVsbCkge1xuICAgICAgdW5wYXRjaEZuKCk7XG4gICAgICB1bnBhdGNoRm4gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1aWRDb3VudGVyID0gMDtcblxuICBmdW5jdGlvbiBpbmplY3QocmVuZGVyZXIpIHtcbiAgICB2YXIgaWQgPSArK3VpZENvdW50ZXI7XG4gICAgcmVuZGVyZXJzLnNldChpZCwgcmVuZGVyZXIpO1xuICAgIHZhciByZWFjdEJ1aWxkVHlwZSA9IGhhc0RldGVjdGVkQmFkRENFID8gJ2RlYWRjb2RlJyA6IGRldGVjdFJlYWN0QnVpbGRUeXBlKHJlbmRlcmVyKTsgLy8gUGF0Y2hpbmcgdGhlIGNvbnNvbGUgZW5hYmxlcyBEZXZUb29scyB0byBkbyBhIGZldyB1c2VmdWwgdGhpbmdzOlxuICAgIC8vICogQXBwZW5kIGNvbXBvbmVudCBzdGFja3MgdG8gd2FybmluZ3MgYW5kIGVycm9yIG1lc3NhZ2VzXG4gICAgLy8gKiBEaXNhYmxpbmcgb3IgbWFya2luZyBsb2dzIGR1cmluZyBhIGRvdWJsZSByZW5kZXIgaW4gU3RyaWN0IE1vZGVcbiAgICAvLyAqIERpc2FibGUgbG9nZ2luZyBkdXJpbmcgcmUtcmVuZGVycyB0byBpbnNwZWN0IGhvb2tzIChzZWUgaW5zcGVjdEhvb2tzT2ZGaWJlcilcbiAgICAvL1xuICAgIC8vIEFsbG93IHBhdGNoaW5nIGNvbnNvbGUgZWFybHkgKGR1cmluZyBpbmplY3Rpb24pIHRvXG4gICAgLy8gcHJvdmlkZSBkZXZlbG9wZXJzIHdpdGggY29tcG9uZW50cyBzdGFja3MgZXZlbiBpZiB0aGV5IGRvbid0IHJ1biBEZXZUb29scy5cblxuICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ19fUkVBQ1RfREVWVE9PTFNfQ09OU09MRV9GVU5DVElPTlNfXycpKSB7XG4gICAgICB2YXIgX3RhcmdldCRfX1JFQUNUX0RFVlRPID0gdGFyZ2V0Ll9fUkVBQ1RfREVWVE9PTFNfQ09OU09MRV9GVU5DVElPTlNfXyxcbiAgICAgICAgICByZWdpc3RlclJlbmRlcmVyV2l0aENvbnNvbGUgPSBfdGFyZ2V0JF9fUkVBQ1RfREVWVE8ucmVnaXN0ZXJSZW5kZXJlcldpdGhDb25zb2xlLFxuICAgICAgICAgIHBhdGNoQ29uc29sZVVzaW5nV2luZG93VmFsdWVzID0gX3RhcmdldCRfX1JFQUNUX0RFVlRPLnBhdGNoQ29uc29sZVVzaW5nV2luZG93VmFsdWVzO1xuXG4gICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyUmVuZGVyZXJXaXRoQ29uc29sZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVnaXN0ZXJSZW5kZXJlcldpdGhDb25zb2xlKHJlbmRlcmVyKTtcbiAgICAgICAgcGF0Y2hDb25zb2xlVXNpbmdXaW5kb3dWYWx1ZXMoKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHdlIGhhdmUganVzdCByZWxvYWRlZCB0byBwcm9maWxlLCB3ZSBuZWVkIHRvIGluamVjdCB0aGUgcmVuZGVyZXIgaW50ZXJmYWNlIGJlZm9yZSB0aGUgYXBwIGxvYWRzLlxuICAgIC8vIE90aGVyd2lzZSB0aGUgcmVuZGVyZXIgd29uJ3QgeWV0IGV4aXN0IGFuZCB3ZSBjYW4gc2tpcCB0aGlzIHN0ZXAuXG5cblxuICAgIHZhciBhdHRhY2ggPSB0YXJnZXQuX19SRUFDVF9ERVZUT09MU19BVFRBQ0hfXztcblxuICAgIGlmICh0eXBlb2YgYXR0YWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcmVuZGVyZXJJbnRlcmZhY2UgPSBhdHRhY2goaG9vaywgaWQsIHJlbmRlcmVyLCB0YXJnZXQpO1xuICAgICAgaG9vay5yZW5kZXJlckludGVyZmFjZXMuc2V0KGlkLCByZW5kZXJlckludGVyZmFjZSk7XG4gICAgfVxuXG4gICAgaG9vay5lbWl0KCdyZW5kZXJlcicsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICAgIHJlYWN0QnVpbGRUeXBlOiByZWFjdEJ1aWxkVHlwZVxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIHZhciBoYXNEZXRlY3RlZEJhZERDRSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHN1YihldmVudCwgZm4pIHtcbiAgICBob29rLm9uKGV2ZW50LCBmbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBob29rLm9mZihldmVudCwgZm4pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBvbihldmVudCwgZm4pIHtcbiAgICBpZiAoIWxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2goZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gb2ZmKGV2ZW50LCBmbikge1xuICAgIGlmICghbGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1tldmVudF0uaW5kZXhPZihmbik7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdChldmVudCwgZGF0YSkge1xuICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdLm1hcChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKSB7XG4gICAgdmFyIHJvb3RzID0gZmliZXJSb290cztcblxuICAgIGlmICghcm9vdHNbcmVuZGVyZXJJRF0pIHtcbiAgICAgIHJvb3RzW3JlbmRlcmVySURdID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIHJldHVybiByb290c1tyZW5kZXJlcklEXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKSB7XG4gICAgdmFyIHJlbmRlcmVySW50ZXJmYWNlID0gcmVuZGVyZXJJbnRlcmZhY2VzLmdldChyZW5kZXJlcklEKTtcblxuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSAhPSBudWxsKSB7XG4gICAgICByZW5kZXJlckludGVyZmFjZS5oYW5kbGVDb21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIHByaW9yaXR5TGV2ZWwpIHtcbiAgICB2YXIgbW91bnRlZFJvb3RzID0gaG9vay5nZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpO1xuICAgIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICAgIHZhciBpc0tub3duUm9vdCA9IG1vdW50ZWRSb290cy5oYXMocm9vdCk7XG4gICAgdmFyIGlzVW5tb3VudGluZyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA9PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ID09IG51bGw7IC8vIEtlZXAgdHJhY2sgb2YgbW91bnRlZCByb290cyBzbyB3ZSBjYW4gaHlkcmF0ZSB3aGVuIERldlRvb2xzIGNvbm5lY3QuXG5cbiAgICBpZiAoIWlzS25vd25Sb290ICYmICFpc1VubW91bnRpbmcpIHtcbiAgICAgIG1vdW50ZWRSb290cy5hZGQocm9vdCk7XG4gICAgfSBlbHNlIGlmIChpc0tub3duUm9vdCAmJiBpc1VubW91bnRpbmcpIHtcbiAgICAgIG1vdW50ZWRSb290cy5kZWxldGUocm9vdCk7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVySW50ZXJmYWNlID0gcmVuZGVyZXJJbnRlcmZhY2VzLmdldChyZW5kZXJlcklEKTtcblxuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSAhPSBudWxsKSB7XG4gICAgICByZW5kZXJlckludGVyZmFjZS5oYW5kbGVDb21taXRGaWJlclJvb3Qocm9vdCwgcHJpb3JpdHlMZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpIHtcbiAgICB2YXIgcmVuZGVyZXJJbnRlcmZhY2UgPSByZW5kZXJlckludGVyZmFjZXMuZ2V0KHJlbmRlcmVySUQpO1xuXG4gICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlICE9IG51bGwpIHtcbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlLmhhbmRsZVBvc3RDb21taXRGaWJlclJvb3Qocm9vdCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3RyaWN0TW9kZShyZW5kZXJlcklELCBpc1N0cmljdE1vZGUpIHtcbiAgICB2YXIgcmVuZGVyZXJJbnRlcmZhY2UgPSByZW5kZXJlckludGVyZmFjZXMuZ2V0KHJlbmRlcmVySUQpO1xuXG4gICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1N0cmljdE1vZGUpIHtcbiAgICAgICAgcmVuZGVyZXJJbnRlcmZhY2UucGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXJJbnRlcmZhY2UudW5wYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGR1cmluZyBpbml0aWFsIHJlbmRlciBpbiB0aGUgZXh0ZW5zaW9uIGJlZm9yZSBEZXZUb29sc1xuICAgICAgLy8gZmluaXNoZXMgaXRzIGhhbmRzaGFrZSB3aXRoIHRoZSBpbmplY3RlZCByZW5kZXJlclxuICAgICAgaWYgKGlzU3RyaWN0TW9kZSkge1xuICAgICAgICB2YXIgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfSElERV9DT05TT0xFX0xPR1NfSU5fU1RSSUNUX01PREVfXyA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIGJyb3dzZXJUaGVtZSA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0JST1dTRVJfVEhFTUVfXztcbiAgICAgICAgcGF0Y2hDb25zb2xlRm9ySW5pdGlhbFJlbmRlckluU3RyaWN0TW9kZSh7XG4gICAgICAgICAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlOiBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUsXG4gICAgICAgICAgYnJvd3NlclRoZW1lOiBicm93c2VyVGhlbWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnBhdGNoQ29uc29sZUZvckluaXRpYWxSZW5kZXJJblN0cmljdE1vZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb3Blbk1vZHVsZVJhbmdlc1N0YWNrID0gW107XG4gIHZhciBtb2R1bGVSYW5nZXMgPSBbXTtcblxuICBmdW5jdGlvbiBnZXRUb3BTdGFja0ZyYW1lU3RyaW5nKGVycm9yKSB7XG4gICAgdmFyIGZyYW1lcyA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgZnJhbWUgPSBmcmFtZXMubGVuZ3RoID4gMSA/IGZyYW1lc1sxXSA6IG51bGw7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMoKSB7XG4gICAgcmV0dXJuIG1vZHVsZVJhbmdlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChlcnJvcikge1xuICAgIHZhciBzdGFydFN0YWNrRnJhbWUgPSBnZXRUb3BTdGFja0ZyYW1lU3RyaW5nKGVycm9yKTtcblxuICAgIGlmIChzdGFydFN0YWNrRnJhbWUgIT09IG51bGwpIHtcbiAgICAgIG9wZW5Nb2R1bGVSYW5nZXNTdGFjay5wdXNoKHN0YXJ0U3RhY2tGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoZXJyb3IpIHtcbiAgICBpZiAob3Blbk1vZHVsZVJhbmdlc1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBzdGFydFN0YWNrRnJhbWUgPSBvcGVuTW9kdWxlUmFuZ2VzU3RhY2sucG9wKCk7XG4gICAgICB2YXIgc3RvcFN0YWNrRnJhbWUgPSBnZXRUb3BTdGFja0ZyYW1lU3RyaW5nKGVycm9yKTtcblxuICAgICAgaWYgKHN0b3BTdGFja0ZyYW1lICE9PSBudWxsKSB7XG4gICAgICAgIG1vZHVsZVJhbmdlcy5wdXNoKFtzdGFydFN0YWNrRnJhbWUsIHN0b3BTdGFja0ZyYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRPRE86IE1vcmUgbWVhbmluZ2Z1bCBuYW1lcyBmb3IgXCJyZW5kZXJlckludGVyZmFjZXNcIiBhbmQgXCJyZW5kZXJlcnNcIi5cblxuXG4gIHZhciBmaWJlclJvb3RzID0ge307XG4gIHZhciByZW5kZXJlckludGVyZmFjZXMgPSBuZXcgTWFwKCk7XG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgdmFyIHJlbmRlcmVycyA9IG5ldyBNYXAoKTtcbiAgdmFyIGJhY2tlbmRzID0gbmV3IE1hcCgpO1xuICB2YXIgaG9vayA9IHtcbiAgICByZW5kZXJlckludGVyZmFjZXM6IHJlbmRlcmVySW50ZXJmYWNlcyxcbiAgICBsaXN0ZW5lcnM6IGxpc3RlbmVycyxcbiAgICBiYWNrZW5kczogYmFja2VuZHMsXG4gICAgLy8gRmFzdCBSZWZyZXNoIGZvciB3ZWIgcmVsaWVzIG9uIHRoaXMuXG4gICAgcmVuZGVyZXJzOiByZW5kZXJlcnMsXG4gICAgZW1pdDogZW1pdCxcbiAgICBnZXRGaWJlclJvb3RzOiBnZXRGaWJlclJvb3RzLFxuICAgIGluamVjdDogaW5qZWN0LFxuICAgIG9uOiBvbixcbiAgICBvZmY6IG9mZixcbiAgICBzdWI6IHN1YixcbiAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IGZsYWcuXG4gICAgLy8gUmVhY3QgdjE2IGNoZWNrcyB0aGUgaG9vayBmb3IgdGhpcyB0byBlbnN1cmUgRGV2VG9vbHMgaXMgbmV3IGVub3VnaC5cbiAgICBzdXBwb3J0c0ZpYmVyOiB0cnVlLFxuICAgIC8vIFJlYWN0IGNhbGxzIHRoZXNlIG1ldGhvZHMuXG4gICAgY2hlY2tEQ0U6IGNoZWNrRENFLFxuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50OiBvbkNvbW1pdEZpYmVyVW5tb3VudCxcbiAgICBvbkNvbW1pdEZpYmVyUm9vdDogb25Db21taXRGaWJlclJvb3QsXG4gICAgb25Qb3N0Q29tbWl0RmliZXJSb290OiBvblBvc3RDb21taXRGaWJlclJvb3QsXG4gICAgc2V0U3RyaWN0TW9kZTogc2V0U3RyaWN0TW9kZSxcbiAgICAvLyBTY2hlZHVsZSBQcm9maWxlciBydW50aW1lIGhlbHBlcnMuXG4gICAgLy8gVGhlc2UgaW50ZXJuYWwgUmVhY3QgbW9kdWxlcyB0byByZXBvcnQgdGhlaXIgb3duIGJvdW5kYXJpZXNcbiAgICAvLyB3aGljaCBpbiB0dXJuIGVuYWJsZXMgdGhlIHByb2ZpbGVyIHRvIGRpbSBvciBmaWx0ZXIgaW50ZXJuYWwgZnJhbWVzLlxuICAgIGdldEludGVybmFsTW9kdWxlUmFuZ2VzOiBnZXRJbnRlcm5hbE1vZHVsZVJhbmdlcyxcbiAgICByZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQ6IHJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCxcbiAgICByZWdpc3RlckludGVybmFsTW9kdWxlU3RvcDogcmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3BcbiAgfTtcblxuICBpZiAoZmFsc2UpIHt9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ19fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXycsIHtcbiAgICAvLyBUaGlzIHByb3BlcnR5IG5lZWRzIHRvIGJlIGNvbmZpZ3VyYWJsZSBmb3IgdGhlIHRlc3QgZW52aXJvbm1lbnQsXG4gICAgLy8gZWxzZSB3ZSB3b24ndCBiZSBhYmxlIHRvIGRlbGV0ZSBhbmQgcmVjcmVhdGUgaXQgYmV0d2VlbiB0ZXN0cy5cbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGhvb2s7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhvb2s7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9yZW5kZXJlci5qcyArIDYgbW9kdWxlc1xudmFyIGJhY2tlbmRfcmVuZGVyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3R5cGVzLmpzXG52YXIgdHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdXRpbHMuanNcbnZhciBzcmNfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvbGVnYWN5L3V0aWxzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbmZ1bmN0aW9uIGRlY29yYXRlKG9iamVjdCwgYXR0ciwgZm4pIHtcbiAgdmFyIG9sZCA9IG9iamVjdFthdHRyXTsgLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdIHdlYnBhY2sgY29uZmlnIG5lZWRzIHRvIGJlIHVwZGF0ZWQgdG8gYWxsb3cgYHRoaXNgIHR5cGUgYW5ub3RhdGlvbnNcblxuICBvYmplY3RbYXR0cl0gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBvbGQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIG9sZDtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlTWFueShzb3VyY2UsIGZucykge1xuICB2YXIgb2xkcyA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gZm5zKSB7XG4gICAgb2xkc1tuYW1lXSA9IGRlY29yYXRlKHNvdXJjZSwgbmFtZSwgZm5zW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBvbGRzO1xufVxuZnVuY3Rpb24gcmVzdG9yZU1hbnkoc291cmNlLCBvbGRzKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gb2xkcykge1xuICAgIHNvdXJjZVtuYW1lXSA9IG9sZHNbbmFtZV07XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdIHdlYnBhY2sgY29uZmlnIG5lZWRzIHRvIGJlIHVwZGF0ZWQgdG8gYWxsb3cgYHRoaXNgIHR5cGUgYW5ub3RhdGlvbnNcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGUoaW5zdGFuY2UpIHtcbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5mb3JjZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gIH0gZWxzZSBpZiAoaW5zdGFuY2UudXBkYXRlciAhPSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGZ1bmN0aW9uICgpIHt9LCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2xlZ2FjeS9yZW5kZXJlci5qc1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmVuZGVyZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcmVuZGVyZXJfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHJlbmRlcmVyX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyByZW5kZXJlcl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gcmVuZGVyZXJfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBudWxsO1xuICB2YXIga2V5ID0gbnVsbDsgLy8gIT0gdXNlZCBkZWxpYmVyYXRlbHkgaGVyZSB0byBjYXRjaCB1bmRlZmluZWQgYW5kIG51bGxcblxuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5rZXkpIHtcbiAgICAgIGtleSA9IFN0cmluZyhpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5rZXkpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50VHlwZSA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgZGlzcGxheU5hbWUgPSBlbGVtZW50VHlwZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGlzcGxheU5hbWUgPSBPYmplY3Qoc3JjX3V0aWxzW1wiaFwiIC8qIGdldERpc3BsYXlOYW1lICovXSkoZWxlbWVudFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgIGtleToga2V5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgLy8gIT0gdXNlZCBkZWxpYmVyYXRlbHkgaGVyZSB0byBjYXRjaCB1bmRlZmluZWQgYW5kIG51bGxcbiAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHB1YmxpY0luc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuXG4gICAgICBpZiAocHVibGljSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzW1wiaFwiIC8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi9dO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHR5cGVzW1wiaVwiIC8qIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCAqL107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdOyAvLyBJZiB0aGUgcGFyZW50IGlzIGEgbmF0aXZlIG5vZGUgd2l0aG91dCByZW5kZXJlZCBjaGlsZHJlbiwgYnV0IHdpdGhcbiAgLy8gbXVsdGlwbGUgc3RyaW5nIGNoaWxkcmVuLCB0aGVuIHRoZSBgZWxlbWVudGAgdGhhdCBnZXRzIHBhc3NlZCBpbiBoZXJlIGlzXG4gIC8vIGEgcGxhaW4gdmFsdWUgLS0gYSBzdHJpbmcgb3IgbnVtYmVyLlxuXG4gIGlmIChyZW5kZXJlcl90eXBlb2YoaW50ZXJuYWxJbnN0YW5jZSkgIT09ICdvYmplY3QnKSB7Ly8gTm8gY2hpbGRyZW5cbiAgfSBlbHNlIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9PT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9PT0gZmFsc2UpIHsvLyBObyBjaGlsZHJlblxuICB9IGVsc2UgaWYgKGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgdmFyIGNoaWxkID0gaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG5cbiAgICBpZiAoZ2V0RWxlbWVudFR5cGUoY2hpbGQpICE9PSB0eXBlc1tcImtcIiAvKiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duICovXSkge1xuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIHZhciBfY2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuXG4gICAgICBpZiAoZ2V0RWxlbWVudFR5cGUoX2NoaWxkKSAhPT0gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL10pIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChfY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBOb3RlOiB3ZSBza2lwIHRoZSBjYXNlIHdoZXJlIGNoaWxkcmVuIGFyZSBqdXN0IHN0cmluZ3Mgb3IgbnVtYmVyc1xuICAvLyBiZWNhdXNlIHRoZSBuZXcgRGV2VG9vbHMgc2tpcHMgb3ZlciBob3N0IHRleHQgbm9kZXMgYW55d2F5LlxuXG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBhdHRhY2goaG9vaywgcmVuZGVyZXJJRCwgcmVuZGVyZXIsIGdsb2JhbCkge1xuICB2YXIgaWRUb0ludGVybmFsSW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlVG9JRE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgZ2V0SW50ZXJuYWxJREZvck5hdGl2ZSA9IG51bGw7XG4gIHZhciBmaW5kTmF0aXZlTm9kZUZvckludGVybmFsSUQ7XG5cbiAgdmFyIGdldEZpYmVyRm9yTmF0aXZlID0gZnVuY3Rpb24gZ2V0RmliZXJGb3JOYXRpdmUobm9kZSkge1xuICAgIC8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBpZiAocmVuZGVyZXIuQ29tcG9uZW50VHJlZSkge1xuICAgIGdldEludGVybmFsSURGb3JOYXRpdmUgPSBmdW5jdGlvbiBnZXRJbnRlcm5hbElERm9yTmF0aXZlKG5vZGUsIGZpbmROZWFyZXN0VW5maWx0ZXJlZEFuY2VzdG9yKSB7XG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHJlbmRlcmVyLkNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gICAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZVRvSURNYXAuZ2V0KGludGVybmFsSW5zdGFuY2UpIHx8IG51bGw7XG4gICAgfTtcblxuICAgIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRCA9IGZ1bmN0aW9uIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCkge1xuICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLkNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9O1xuXG4gICAgZ2V0RmliZXJGb3JOYXRpdmUgPSBmdW5jdGlvbiBnZXRGaWJlckZvck5hdGl2ZShub2RlKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlbmRlcmVyLk1vdW50LmdldElEICYmIHJlbmRlcmVyLk1vdW50LmdldE5vZGUpIHtcbiAgICBnZXRJbnRlcm5hbElERm9yTmF0aXZlID0gZnVuY3Rpb24gZ2V0SW50ZXJuYWxJREZvck5hdGl2ZShub2RlLCBmaW5kTmVhcmVzdFVuZmlsdGVyZWRBbmNlc3Rvcikge1xuICAgICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRCA9IGZ1bmN0aW9uIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCkge1xuICAgICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yRmliZXJJRChpZCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZSA/IGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSkuZGlzcGxheU5hbWUgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChyZW5kZXJlcl90eXBlb2YoaW50ZXJuYWxJbnN0YW5jZSkgIT09ICdvYmplY3QnIHx8IGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlcm5hbCBpbnN0YW5jZTogJyArIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZVRvSURNYXAuaGFzKGludGVybmFsSW5zdGFuY2UpKSB7XG4gICAgICB2YXIgX2lkID0gT2JqZWN0KHNyY191dGlsc1tcImtcIiAvKiBnZXRVSUQgKi9dKSgpO1xuXG4gICAgICBpbnRlcm5hbEluc3RhbmNlVG9JRE1hcC5zZXQoaW50ZXJuYWxJbnN0YW5jZSwgX2lkKTtcbiAgICAgIGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLnNldChfaWQsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlVG9JRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVFcXVhbEFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFRoaXMgaXMgc2hhcmVkIG11dGFibGUgc3RhdGUgdGhhdCBsZXRzIHVzIGtlZXAgdHJhY2sgb2Ygd2hlcmUgd2UgYXJlLlxuXG5cbiAgdmFyIHBhcmVudElEU3RhY2sgPSBbXTtcbiAgdmFyIG9sZFJlY29uY2lsZXJNZXRob2RzID0gbnVsbDtcblxuICBpZiAocmVuZGVyZXIuUmVjb25jaWxlcikge1xuICAgIC8vIFJlYWN0IDE1XG4gICAgb2xkUmVjb25jaWxlck1ldGhvZHMgPSBkZWNvcmF0ZU1hbnkocmVuZGVyZXIuUmVjb25jaWxlciwge1xuICAgICAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGhvc3RDb250YWluZXJJbmZvID0gYXJnc1szXTtcblxuICAgICAgICBpZiAoZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSkgPT09IHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gU1NSXG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBnZXRJRChpbnRlcm5hbEluc3RhbmNlKTsgLy8gUHVzaCB0aGUgb3BlcmF0aW9uLlxuXG4gICAgICAgIHZhciBwYXJlbnRJRCA9IHBhcmVudElEU3RhY2subGVuZ3RoID4gMCA/IHBhcmVudElEU3RhY2tbcGFyZW50SURTdGFjay5sZW5ndGggLSAxXSA6IDA7XG4gICAgICAgIHJlY29yZE1vdW50KGludGVybmFsSW5zdGFuY2UsIGlkLCBwYXJlbnRJRCk7XG4gICAgICAgIHBhcmVudElEU3RhY2sucHVzaChpZCk7IC8vIFJlbWVtYmVyIHRoZSByb290LlxuXG4gICAgICAgIGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5zZXQoaW50ZXJuYWxJbnN0YW5jZSwgZ2V0SUQoaG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlcikpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgcGFyZW50SURTdGFjay5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgcGFyZW50SURTdGFjayA9IFtdO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocGFyZW50SURTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciByb290SUQgPSBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuZ2V0KGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAocm9vdElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvb3QgSUQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290SUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gYXJnc1swXTtcblxuICAgICAgICBpZiAoZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSkgPT09IHR5cGVzW1wia1wiIC8qIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gKi9dKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBnZXRJRChpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgICAgcGFyZW50SURTdGFjay5wdXNoKGlkKTtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKCFhcmVFcXVhbEFycmF5cyhwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbikpIHtcbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgcmVjb3JkUmVvcmRlcihpbnRlcm5hbEluc3RhbmNlLCBpZCwgbmV4dENoaWxkcmVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrID0gW107XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChwYXJlbnRJRFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHJvb3RJRCA9IGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChyb290SUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgcm9vdCBJRC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3RJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gcmVjZWl2ZUNvbXBvbmVudChmbiwgYXJncykge1xuICAgICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpID09PSB0eXBlc1tcImtcIiAvKiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duICovXSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbb2JqZWN0LXRoaXMtcmVmZXJlbmNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgIHBhcmVudElEU3RhY2sucHVzaChpZCk7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbb2JqZWN0LXRoaXMtcmVmZXJlbmNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgICAgIGlmICghYXJlRXF1YWxBcnJheXMocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAvLyBQdXNoIHRoZSBvcGVyYXRpb25cbiAgICAgICAgICAgIHJlY29yZFJlb3JkZXIoaW50ZXJuYWxJbnN0YW5jZSwgaWQsIG5leHRDaGlsZHJlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50SURTdGFjay5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgcGFyZW50SURTdGFjayA9IFtdO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocGFyZW50SURTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciByb290SUQgPSBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuZ2V0KGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAocm9vdElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvb3QgSUQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290SUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIHVubW91bnRDb21wb25lbnQoZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKSA9PT0gdHlwZXNbXCJrXCIgLyogRWxlbWVudFR5cGVPdGhlck9yVW5rbm93biAqL10pIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGdldElEKGludGVybmFsSW5zdGFuY2UpO1xuICAgICAgICBwYXJlbnRJRFN0YWNrLnB1c2goaWQpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgcGFyZW50SURTdGFjay5wb3AoKTsgLy8gUHVzaCB0aGUgb3BlcmF0aW9uLlxuXG4gICAgICAgICAgcmVjb3JkVW5tb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHBhcmVudElEU3RhY2sgPSBbXTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHBhcmVudElEU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdElEID0gaW50ZXJuYWxJbnN0YW5jZVRvUm9vdElETWFwLmdldChpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgICAgICAgaWYgKHJvb3RJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCByb290IElELicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgaWYgKG9sZFJlY29uY2lsZXJNZXRob2RzICE9PSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyZXIuQ29tcG9uZW50KSB7XG4gICAgICAgIHJlc3RvcmVNYW55KHJlbmRlcmVyLkNvbXBvbmVudC5NaXhpbiwgb2xkUmVjb25jaWxlck1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdG9yZU1hbnkocmVuZGVyZXIuUmVjb25jaWxlciwgb2xkUmVjb25jaWxlck1ldGhvZHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9sZFJlY29uY2lsZXJNZXRob2RzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZE1vdW50KGludGVybmFsSW5zdGFuY2UsIGlkLCBwYXJlbnRJRCkge1xuICAgIHZhciBpc1Jvb3QgPSBwYXJlbnRJRCA9PT0gMDtcblxuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgY29uc29sZS5sb2coJyVjcmVjb3JkTW91bnQoKScsICdjb2xvcjogZ3JlZW47IGZvbnQtd2VpZ2h0OiBib2xkOycsIGlkLCBnZXREYXRhKGludGVybmFsSW5zdGFuY2UpLmRpc3BsYXlOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNSb290KSB7XG4gICAgICAvLyBUT0RPIElzIHRoaXMgcmlnaHQ/IEZvciBhbGwgdmVyc2lvbnM/XG4gICAgICB2YXIgaGFzT3duZXJNZXRhZGF0YSA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICE9IG51bGwgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyICE9IG51bGw7XG4gICAgICBwdXNoT3BlcmF0aW9uKGNvbnN0YW50c1tcImxcIiAvKiBUUkVFX09QRVJBVElPTl9BREQgKi9dKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbih0eXBlc1tcIm1cIiAvKiBFbGVtZW50VHlwZVJvb3QgKi9dKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oMCk7IC8vIFN0cmljdE1vZGUgY29tcGxpYW50P1xuXG4gICAgICBwdXNoT3BlcmF0aW9uKDApOyAvLyBQcm9maWxpbmcgZmxhZ1xuXG4gICAgICBwdXNoT3BlcmF0aW9uKDApOyAvLyBTdHJpY3RNb2RlIHN1cHBvcnRlZD9cblxuICAgICAgcHVzaE9wZXJhdGlvbihoYXNPd25lck1ldGFkYXRhID8gMSA6IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHlwZSA9IGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICB2YXIgX2dldERhdGEgPSBnZXREYXRhKGludGVybmFsSW5zdGFuY2UpLFxuICAgICAgICAgIGRpc3BsYXlOYW1lID0gX2dldERhdGEuZGlzcGxheU5hbWUsXG4gICAgICAgICAga2V5ID0gX2dldERhdGEua2V5O1xuXG4gICAgICB2YXIgb3duZXJJRCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICE9IG51bGwgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyICE9IG51bGwgPyBnZXRJRChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpIDogMDtcbiAgICAgIHZhciBkaXNwbGF5TmFtZVN0cmluZ0lEID0gZ2V0U3RyaW5nSUQoZGlzcGxheU5hbWUpO1xuICAgICAgdmFyIGtleVN0cmluZ0lEID0gZ2V0U3RyaW5nSUQoa2V5KTtcbiAgICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wibFwiIC8qIFRSRUVfT1BFUkFUSU9OX0FERCAqL10pO1xuICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHR5cGUpO1xuICAgICAgcHVzaE9wZXJhdGlvbihwYXJlbnRJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKG93bmVySUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihkaXNwbGF5TmFtZVN0cmluZ0lEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oa2V5U3RyaW5nSUQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFJlb3JkZXIoaW50ZXJuYWxJbnN0YW5jZSwgaWQsIG5leHRDaGlsZHJlbikge1xuICAgIHB1c2hPcGVyYXRpb24oY29uc3RhbnRzW1wib1wiIC8qIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4gKi9dKTtcbiAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICB2YXIgbmV4dENoaWxkSURzID0gbmV4dENoaWxkcmVuLm1hcChnZXRJRCk7XG4gICAgcHVzaE9wZXJhdGlvbihuZXh0Q2hpbGRJRHMubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwdXNoT3BlcmF0aW9uKG5leHRDaGlsZElEc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkVW5tb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCkge1xuICAgIHBlbmRpbmdVbm1vdW50ZWRJRHMucHVzaChpZCk7XG4gICAgaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZGVsZXRlKGlkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cyhpZCwgcGFyZW50SUQsIHJvb3RJRCkge1xuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgY29uc29sZS5ncm91cCgnY3Jhd2xBbmRSZWNvcmRJbml0aWFsTW91bnRzKCkgaWQ6JywgaWQpO1xuICAgIH1cblxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5zZXQoaW50ZXJuYWxJbnN0YW5jZSwgcm9vdElEKTtcbiAgICAgIHJlY29yZE1vdW50KGludGVybmFsSW5zdGFuY2UsIGlkLCBwYXJlbnRJRCk7XG4gICAgICBnZXRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY3Jhd2xBbmRSZWNvcmRJbml0aWFsTW91bnRzKGdldElEKGNoaWxkKSwgaWQsIHJvb3RJRCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3RhbnRzW1wic1wiIC8qIF9fREVCVUdfXyAqL10pIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaEluaXRpYWxPcGVyYXRpb25zKCkge1xuICAgIC8vIENyYXdsIHJvb3RzIHRob3VnaCBhbmQgcmVnaXN0ZXIgYW55IG5vZGVzIHRoYXQgbW91bnRlZCBiZWZvcmUgd2Ugd2VyZSBpbmplY3RlZC5cbiAgICB2YXIgcm9vdHMgPSByZW5kZXJlci5Nb3VudC5faW5zdGFuY2VzQnlSZWFjdFJvb3RJRCB8fCByZW5kZXJlci5Nb3VudC5faW5zdGFuY2VzQnlDb250YWluZXJJRDtcblxuICAgIGZvciAodmFyIGtleSBpbiByb290cykge1xuICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSByb290c1trZXldO1xuXG4gICAgICB2YXIgX2lkMiA9IGdldElEKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICBjcmF3bEFuZFJlY29yZEluaXRpYWxNb3VudHMoX2lkMiwgMCwgX2lkMik7XG4gICAgICBmbHVzaFBlbmRpbmdFdmVudHMoX2lkMik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdPcGVyYXRpb25zID0gW107XG4gIHZhciBwZW5kaW5nU3RyaW5nVGFibGUgPSBuZXcgTWFwKCk7XG4gIHZhciBwZW5kaW5nVW5tb3VudGVkSURzID0gW107XG4gIHZhciBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggPSAwO1xuICB2YXIgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3RJRCkge1xuICAgIGlmIChwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgcGVuZGluZ1VubW91bnRlZElEcy5sZW5ndGggPT09IDAgJiYgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBudW1Vbm1vdW50SURzID0gcGVuZGluZ1VubW91bnRlZElEcy5sZW5ndGggKyAocGVuZGluZ1VubW91bnRlZFJvb3RJRCA9PT0gbnVsbCA/IDAgOiAxKTtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IG5ldyBBcnJheSggLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgMiArIC8vIFtyZW5kZXJlcklELCByb290RmliZXJJRF1cbiAgICAvLyBIb3cgYmlnIGlzIHRoZSBzdHJpbmcgdGFibGU/XG4gICAgMSArIC8vIFtzdHJpbmdUYWJsZUxlbmd0aF1cbiAgICAvLyBUaGVuIGdvZXMgdGhlIGFjdHVhbCBzdHJpbmcgdGFibGUuXG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoICsgKCAvLyBBbGwgdW5tb3VudHMgYXJlIGJhdGNoZWQgaW4gYSBzaW5nbGUgbWVzc2FnZS5cbiAgICAvLyBbVFJFRV9PUEVSQVRJT05fUkVNT1ZFLCByZW1vdmVkSURMZW5ndGgsIC4uLmlkc11cbiAgICBudW1Vbm1vdW50SURzID4gMCA/IDIgKyBudW1Vbm1vdW50SURzIDogMCkgKyAvLyBNb3VudCBvcGVyYXRpb25zXG4gICAgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoKTsgLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgLy8gVGhpcyBlbmFibGVzIHJvb3RzIHRvIGJlIG1hcHBlZCB0byByZW5kZXJlcnMsXG4gICAgLy8gV2hpY2ggaW4gdHVybiBlbmFibGVzIGZpYmVyIHByb3BlcmF0aW9ucywgc3RhdGVzLCBhbmQgaG9va3MgdG8gYmUgaW5zcGVjdGVkLlxuXG4gICAgdmFyIGkgPSAwO1xuICAgIG9wZXJhdGlvbnNbaSsrXSA9IHJlbmRlcmVySUQ7XG4gICAgb3BlcmF0aW9uc1tpKytdID0gcm9vdElEOyAvLyBOb3cgZmlsbCBpbiB0aGUgc3RyaW5nIHRhYmxlLlxuICAgIC8vIFtzdHJpbmdUYWJsZUxlbmd0aCwgc3RyMUxlbmd0aCwgLi4uc3RyMSwgc3RyMkxlbmd0aCwgLi4uc3RyMiwgLi4uXVxuXG4gICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBvcGVyYXRpb25zW2krK10gPSBrZXkubGVuZ3RoO1xuICAgICAgdmFyIGVuY29kZWRLZXkgPSBPYmplY3Qoc3JjX3V0aWxzW1wicFwiIC8qIHV0ZkVuY29kZVN0cmluZyAqL10pKGtleSk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZW5jb2RlZEtleS5sZW5ndGg7IGorKykge1xuICAgICAgICBvcGVyYXRpb25zW2kgKyBqXSA9IGVuY29kZWRLZXlbal07XG4gICAgICB9XG5cbiAgICAgIGkgKz0ga2V5Lmxlbmd0aDtcbiAgICB9KTtcblxuICAgIGlmIChudW1Vbm1vdW50SURzID4gMCkge1xuICAgICAgLy8gQWxsIHVubW91bnRzIGV4Y2VwdCByb290cyBhcmUgYmF0Y2hlZCBpbiBhIHNpbmdsZSBtZXNzYWdlLlxuICAgICAgb3BlcmF0aW9uc1tpKytdID0gY29uc3RhbnRzW1wibVwiIC8qIFRSRUVfT1BFUkFUSU9OX1JFTU9WRSAqL107IC8vIFRoZSBmaXJzdCBudW1iZXIgaXMgaG93IG1hbnkgdW5tb3VudGVkIElEcyB3ZSdyZSBnb25uYSBzZW5kLlxuXG4gICAgICBvcGVyYXRpb25zW2krK10gPSBudW1Vbm1vdW50SURzOyAvLyBGaWxsIGluIHRoZSB1bm1vdW50c1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlbmRpbmdVbm1vdW50ZWRJRHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1VubW91bnRlZElEc1tqXTtcbiAgICAgIH0gLy8gVGhlIHJvb3QgSUQgc2hvdWxkIGFsd2F5cyBiZSB1bm1vdW50ZWQgbGFzdC5cblxuXG4gICAgICBpZiAocGVuZGluZ1VubW91bnRlZFJvb3RJRCAhPT0gbnVsbCkge1xuICAgICAgICBvcGVyYXRpb25zW2ldID0gcGVuZGluZ1VubW91bnRlZFJvb3RJRDtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgb3BlcmF0aW9ucy5cblxuXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDsgX2orKykge1xuICAgICAgb3BlcmF0aW9uc1tpICsgX2pdID0gcGVuZGluZ09wZXJhdGlvbnNbX2pdO1xuICAgIH1cblxuICAgIGkgKz0gcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoO1xuXG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBPYmplY3Qoc3JjX3V0aWxzW1wibVwiIC8qIHByaW50T3BlcmF0aW9uc0FycmF5ICovXSkob3BlcmF0aW9ucyk7XG4gICAgfSAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGNvbm5lY3RlZCB0byB0aGUgZnJvbnRlbmQsIGp1c3QgcGFzcyB0aGUgb3BlcmF0aW9ucyB0aHJvdWdoLlxuXG5cbiAgICBob29rLmVtaXQoJ29wZXJhdGlvbnMnLCBvcGVyYXRpb25zKTtcbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHBlbmRpbmdVbm1vdW50ZWRJRHMgPSBbXTtcbiAgICBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gbnVsbDtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuY2xlYXIoKTtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCkge1xuICAgIGlmIChmYWxzZSkge31cblxuICAgIHBlbmRpbmdPcGVyYXRpb25zLnB1c2gob3ApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RyaW5nSUQoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGV4aXN0aW5nSUQgPSBwZW5kaW5nU3RyaW5nVGFibGUuZ2V0KHN0cik7XG5cbiAgICBpZiAoZXhpc3RpbmdJRCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdJRDtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nSUQgPSBwZW5kaW5nU3RyaW5nVGFibGUuc2l6ZSArIDE7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLnNldChzdHIsIHN0cmluZ0lEKTsgLy8gVGhlIHN0cmluZyB0YWJsZSB0b3RhbCBsZW5ndGggbmVlZHMgdG8gYWNjb3VudFxuICAgIC8vIGJvdGggZm9yIHRoZSBzdHJpbmcgbGVuZ3RoLCBhbmQgZm9yIHRoZSBhcnJheSBpdGVtXG4gICAgLy8gdGhhdCBjb250YWlucyB0aGUgbGVuZ3RoIGl0c2VsZi4gSGVuY2UgKyAxLlxuXG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoICs9IHN0ci5sZW5ndGggKyAxO1xuICAgIHJldHVybiBzdHJpbmdJRDtcbiAgfVxuXG4gIHZhciBjdXJyZW50bHlJbnNwZWN0ZWRFbGVtZW50SUQgPSBudWxsO1xuICB2YXIgY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgPSB7fTsgLy8gVHJhY2sgdGhlIGludGVyc2VjdGlvbiBvZiBjdXJyZW50bHkgaW5zcGVjdGVkIHBhdGhzLFxuICAvLyBzbyB0aGF0IHdlIGNhbiBzZW5kIHRoZWlyIGRhdGEgYWxvbmcgaWYgdGhlIGVsZW1lbnQgaXMgcmUtcmVuZGVyZWQuXG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnNwZWN0ZWRQYXRocyhwYXRoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocztcbiAgICBwYXRoLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFjdXJyZW50W2tleV0pIHtcbiAgICAgICAgY3VycmVudFtrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJc1BhdGhBbGxvd2VkKGtleSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGVscHMgcHJldmVudCBwcmV2aW91c2x5LWluc3BlY3RlZCBwYXRocyBmcm9tIGJlaW5nIGRlaHlkcmF0ZWQgaW4gdXBkYXRlcy5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCB0byBhdm9pZCBhIGJhZCB1c2VyIGV4cGVyaWVuY2Ugd2hlcmUgZXhwYW5kZWQgdG9nZ2xlcyBjb2xsYXBzZSBvbiB1cGRhdGUuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzUGF0aEFsbG93ZWQocGF0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlJbnNwZWN0ZWRQYXRoc1trZXldO1xuXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aFtpXV07XG5cbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0gLy8gRmFzdCBwYXRoIHByb3BzIGxvb2t1cCBmb3IgUmVhY3QgTmF0aXZlIHN0eWxlIGVkaXRvci5cblxuXG4gIGZ1bmN0aW9uIGdldEluc3RhbmNlQW5kU3R5bGUoaWQpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBudWxsO1xuICAgIHZhciBzdHlsZSA9IG51bGw7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZSB8fCBudWxsO1xuICAgICAgdmFyIGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50LnByb3BzICE9IG51bGwpIHtcbiAgICAgICAgc3R5bGUgPSBlbGVtZW50LnByb3BzLnN0eWxlIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZEVsZW1lbnQoaWQpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBpbnN0YW5jZSB3aXRoIGlkIFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKSkge1xuICAgICAgY2FzZSB0eXBlc1tcImVcIiAvKiBFbGVtZW50VHlwZUNsYXNzICovXTpcbiAgICAgICAgZ2xvYmFsLiRyID0gaW50ZXJuYWxJbnN0YW5jZS5faW5zdGFuY2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHR5cGVzW1wiaFwiIC8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi9dOlxuICAgICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgcHJvcHM6IGVsZW1lbnQucHJvcHMsXG4gICAgICAgICAgdHlwZTogZWxlbWVudC50eXBlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBnbG9iYWwuJHIgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9yZUFzR2xvYmFsKGlkLCBwYXRoLCBjb3VudCkge1xuICAgIHZhciBpbnNwZWN0ZWRFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnRSYXcoaWQpO1xuXG4gICAgaWYgKGluc3BlY3RlZEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IE9iamVjdChzcmNfdXRpbHNbXCJqXCIgLyogZ2V0SW5PYmplY3QgKi9dKShpbnNwZWN0ZWRFbGVtZW50LCBwYXRoKTtcbiAgICAgIHZhciBrZXkgPSBcIiRyZWFjdFRlbXBcIi5jb25jYXQoY291bnQpO1xuICAgICAgd2luZG93W2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VyaWFsaXplZEVsZW1lbnRWYWx1ZUJ5UGF0aChpZCwgcGF0aCkge1xuICAgIHZhciBpbnNwZWN0ZWRFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnRSYXcoaWQpO1xuXG4gICAgaWYgKGluc3BlY3RlZEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZVRvQ29weSA9IE9iamVjdChzcmNfdXRpbHNbXCJqXCIgLyogZ2V0SW5PYmplY3QgKi9dKShpbnNwZWN0ZWRFbGVtZW50LCBwYXRoKTtcbiAgICAgIHJldHVybiBPYmplY3QodXRpbHNbXCJsXCIgLyogc2VyaWFsaXplVG9TdHJpbmcgKi9dKSh2YWx1ZVRvQ29weSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdEVsZW1lbnQocmVxdWVzdElELCBpZCwgcGF0aCwgZm9yY2VGdWxsRGF0YSkge1xuICAgIGlmIChmb3JjZUZ1bGxEYXRhIHx8IGN1cnJlbnRseUluc3BlY3RlZEVsZW1lbnRJRCAhPT0gaWQpIHtcbiAgICAgIGN1cnJlbnRseUluc3BlY3RlZEVsZW1lbnRJRCA9IGlkO1xuICAgICAgY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgaW5zcGVjdGVkRWxlbWVudCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcblxuICAgIGlmIChpbnNwZWN0ZWRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgICAgdHlwZTogJ25vdC1mb3VuZCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHBhdGggIT09IG51bGwpIHtcbiAgICAgIG1lcmdlSW5zcGVjdGVkUGF0aHMocGF0aCk7XG4gICAgfSAvLyBBbnkgdGltZSBhbiBpbnNwZWN0ZWQgZWxlbWVudCBoYXMgYW4gdXBkYXRlLFxuICAgIC8vIHdlIHNob3VsZCB1cGRhdGUgdGhlIHNlbGVjdGVkICRyIHZhbHVlIGFzIHdlbC5cbiAgICAvLyBEbyB0aGlzIGJlZm9yZSBkZWh5ZHJhdGlvbiAoY2xlYW5Gb3JCcmlkZ2UpLlxuXG5cbiAgICB1cGRhdGVTZWxlY3RlZEVsZW1lbnQoaWQpO1xuICAgIGluc3BlY3RlZEVsZW1lbnQuY29udGV4dCA9IE9iamVjdCh1dGlsc1tcImFcIiAvKiBjbGVhbkZvckJyaWRnZSAqL10pKGluc3BlY3RlZEVsZW1lbnQuY29udGV4dCwgY3JlYXRlSXNQYXRoQWxsb3dlZCgnY29udGV4dCcpKTtcbiAgICBpbnNwZWN0ZWRFbGVtZW50LnByb3BzID0gT2JqZWN0KHV0aWxzW1wiYVwiIC8qIGNsZWFuRm9yQnJpZGdlICovXSkoaW5zcGVjdGVkRWxlbWVudC5wcm9wcywgY3JlYXRlSXNQYXRoQWxsb3dlZCgncHJvcHMnKSk7XG4gICAgaW5zcGVjdGVkRWxlbWVudC5zdGF0ZSA9IE9iamVjdCh1dGlsc1tcImFcIiAvKiBjbGVhbkZvckJyaWRnZSAqL10pKGluc3BlY3RlZEVsZW1lbnQuc3RhdGUsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ3N0YXRlJykpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogaWQsXG4gICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICB0eXBlOiAnZnVsbC1kYXRhJyxcbiAgICAgIHZhbHVlOiBpbnNwZWN0ZWRFbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50UmF3KGlkKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF9nZXREYXRhMiA9IGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSksXG4gICAgICAgIGRpc3BsYXlOYW1lID0gX2dldERhdGEyLmRpc3BsYXlOYW1lLFxuICAgICAgICBrZXkgPSBfZ2V0RGF0YTIua2V5O1xuXG4gICAgdmFyIHR5cGUgPSBnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB2YXIgY29udGV4dCA9IG51bGw7XG4gICAgdmFyIG93bmVycyA9IG51bGw7XG4gICAgdmFyIHByb3BzID0gbnVsbDtcbiAgICB2YXIgc3RhdGUgPSBudWxsO1xuICAgIHZhciBzb3VyY2UgPSBudWxsO1xuICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgICAgc291cmNlID0gZWxlbWVudC5fc291cmNlICE9IG51bGwgPyBlbGVtZW50Ll9zb3VyY2UgOiBudWxsO1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lcnMgPSBbXTtcblxuICAgICAgICB3aGlsZSAob3duZXIgIT0gbnVsbCkge1xuICAgICAgICAgIG93bmVycy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBnZXREYXRhKG93bmVyKS5kaXNwbGF5TmFtZSB8fCAnVW5rbm93bicsXG4gICAgICAgICAgICBpZDogZ2V0SUQob3duZXIpLFxuICAgICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICAgIHR5cGU6IGdldEVsZW1lbnRUeXBlKG93bmVyKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG93bmVyLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgb3duZXIgPSBvd25lci5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuXG4gICAgaWYgKHB1YmxpY0luc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIGNvbnRleHQgPSBwdWJsaWNJbnN0YW5jZS5jb250ZXh0IHx8IG51bGw7XG4gICAgICBzdGF0ZSA9IHB1YmxpY0luc3RhbmNlLnN0YXRlIHx8IG51bGw7XG4gICAgfSAvLyBOb3QgaW1wbGVtZW50ZWRcblxuXG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB3YXJuaW5ncyA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogaWQsXG4gICAgICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgZWRpdGFibGUgaG9va3MgYW5kIGZ1bmN0aW9uIHByb3BzP1xuICAgICAgY2FuRWRpdEhvb2tzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzOiBmYWxzZSxcbiAgICAgIC8vIERvZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydCBhZHZhbmNlZCBlZGl0aW5nIGludGVyZmFjZT9cbiAgICAgIGNhbkVkaXRIb29rc0FuZERlbGV0ZVBhdGhzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRIb29rc0FuZFJlbmFtZVBhdGhzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzRGVsZXRlUGF0aHM6IGZhbHNlLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNSZW5hbWVQYXRoczogZmFsc2UsXG4gICAgICAvLyBUb2dnbGUgZXJyb3IgYm91bmRhcnkgZGlkIG5vdCBleGlzdCBpbiBsZWdhY3kgdmVyc2lvbnNcbiAgICAgIGNhblRvZ2dsZUVycm9yOiBmYWxzZSxcbiAgICAgIGlzRXJyb3JlZDogZmFsc2UsXG4gICAgICB0YXJnZXRFcnJvckJvdW5kYXJ5SUQ6IG51bGwsXG4gICAgICAvLyBTdXNwZW5zZSBkaWQgbm90IGV4aXN0IGluIGxlZ2FjeSB2ZXJzaW9uc1xuICAgICAgY2FuVG9nZ2xlU3VzcGVuc2U6IGZhbHNlLFxuICAgICAgLy8gQ2FuIHZpZXcgY29tcG9uZW50IHNvdXJjZSBsb2NhdGlvbi5cbiAgICAgIGNhblZpZXdTb3VyY2U6IHR5cGUgPT09IHR5cGVzW1wiZVwiIC8qIEVsZW1lbnRUeXBlQ2xhc3MgKi9dIHx8IHR5cGUgPT09IHR5cGVzW1wiaFwiIC8qIEVsZW1lbnRUeXBlRnVuY3Rpb24gKi9dLFxuICAgICAgLy8gT25seSBsZWdhY3kgY29udGV4dCBleGlzdHMgaW4gbGVnYWN5IHZlcnNpb25zLlxuICAgICAgaGFzTGVnYWN5Q29udGV4dDogdHJ1ZSxcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSAhPSBudWxsID8ga2V5IDogbnVsbCxcbiAgICAgIC8vIEluc3BlY3RhYmxlIHByb3BlcnRpZXMuXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgaG9va3M6IG51bGwsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyxcbiAgICAgIC8vIExpc3Qgb2Ygb3duZXJzXG4gICAgICBvd25lcnM6IG93bmVycyxcbiAgICAgIC8vIExvY2F0aW9uIG9mIGNvbXBvbmVudCBpbiBzb3VyY2UgY29kZS5cbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgcm9vdFR5cGU6IG51bGwsXG4gICAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBudWxsLFxuICAgICAgcmVuZGVyZXJWZXJzaW9uOiBudWxsLFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICBzdHlsZXg6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nRWxlbWVudFRvQ29uc29sZShpZCkge1xuICAgIHZhciByZXN1bHQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3VwcG9ydHNHcm91cCA9IHR5cGVvZiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkID09PSAnZnVuY3Rpb24nO1xuXG4gICAgaWYgKHN1cHBvcnRzR3JvdXApIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJbQ2xpY2sgdG8gZXhwYW5kXSAlYzxcIi5jb25jYXQocmVzdWx0LmRpc3BsYXlOYW1lIHx8ICdDb21wb25lbnQnLCBcIiAvPlwiKSwgLy8gLS1kb20tdGFnLW5hbWUtY29sb3IgaXMgdGhlIENTUyB2YXJpYWJsZSBDaHJvbWUgc3R5bGVzIEhUTUwgZWxlbWVudHMgd2l0aCBpbiB0aGUgY29uc29sZS5cbiAgICAgICdjb2xvcjogdmFyKC0tZG9tLXRhZy1uYW1lLWNvbG9yKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsnKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnByb3BzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnUHJvcHM6JywgcmVzdWx0LnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnN0YXRlICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RhdGU6JywgcmVzdWx0LnN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb250ZXh0OicsIHJlc3VsdC5jb250ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgbmF0aXZlTm9kZSA9IGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCk7XG5cbiAgICBpZiAobmF0aXZlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ05vZGU6JywgbmF0aXZlTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5jaHJvbWUgfHwgL2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zb2xlLmxvZygnUmlnaHQtY2xpY2sgYW55IHZhbHVlIHRvIHNhdmUgaXQgYXMgYSBnbG9iYWwgdmFyaWFibGUgZm9yIGZ1cnRoZXIgaW5zcGVjdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlKGlkLCBwYXRoKSB7XG4gICAgdmFyIGluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAoaW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LiRhdHRyaWJ1dGUgPSBPYmplY3Qoc3JjX3V0aWxzW1wialwiIC8qIGdldEluT2JqZWN0ICovXSkoaW5zcGVjdGVkRWxlbWVudCwgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVZpZXdFbGVtZW50U291cmNlKGlkKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgaW5zdGFuY2Ugd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnbG9iYWwuJHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVQYXRoKHR5cGUsIGlkLCBob29rSUQsIHBhdGgpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICB2YXIgcHVibGljSW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZTtcblxuICAgICAgaWYgKHB1YmxpY0luc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICBPYmplY3Qoc3JjX3V0aWxzW1wiY1wiIC8qIGRlbGV0ZVBhdGhJbk9iamVjdCAqL10pKHB1YmxpY0luc3RhbmNlLmNvbnRleHQsIHBhdGgpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvb2tzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuXG4gICAgICAgICAgY2FzZSAncHJvcHMnOlxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcHM6IE9iamVjdCh1dGlsc1tcImJcIiAvKiBjb3B5V2l0aERlbGV0ZSAqL10pKGVsZW1lbnQucHJvcHMsIHBhdGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgICAgT2JqZWN0KHNyY191dGlsc1tcImNcIiAvKiBkZWxldGVQYXRoSW5PYmplY3QgKi9dKShwdWJsaWNJbnN0YW5jZS5zdGF0ZSwgcGF0aCk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmFtZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuXG4gICAgICBpZiAocHVibGljSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAgIE9iamVjdChzcmNfdXRpbHNbXCJuXCIgLyogcmVuYW1lUGF0aEluT2JqZWN0ICovXSkocHVibGljSW5zdGFuY2UuY29udGV4dCwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSG9va3Mgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG5cbiAgICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wczogT2JqZWN0KHV0aWxzW1wiY1wiIC8qIGNvcHlXaXRoUmVuYW1lICovXSkoZWxlbWVudC5wcm9wcywgb2xkUGF0aCwgbmV3UGF0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgICBPYmplY3Qoc3JjX3V0aWxzW1wiblwiIC8qIHJlbmFtZVBhdGhJbk9iamVjdCAqL10pKHB1YmxpY0luc3RhbmNlLnN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGVWYWx1ZUF0UGF0aCh0eXBlLCBpZCwgaG9va0lELCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuXG4gICAgICBpZiAocHVibGljSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAgIE9iamVjdChzcmNfdXRpbHNbXCJvXCIgLyogc2V0SW5PYmplY3QgKi9dKShwdWJsaWNJbnN0YW5jZS5jb250ZXh0LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSG9va3Mgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG5cbiAgICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wczogT2JqZWN0KHV0aWxzW1wiZFwiIC8qIGNvcHlXaXRoU2V0ICovXSkoZWxlbWVudC5wcm9wcywgcGF0aCwgdmFsdWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgICAgT2JqZWN0KHNyY191dGlsc1tcIm9cIiAvKiBzZXRJbk9iamVjdCAqL10pKHB1YmxpY0luc3RhbmNlLnN0YXRlLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyB2MTYrIG9ubHkgZmVhdHVyZXNcblxuXG4gIHZhciBnZXRQcm9maWxpbmdEYXRhID0gZnVuY3Rpb24gZ2V0UHJvZmlsaW5nRGF0YSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFByb2ZpbGluZ0RhdGEgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbW1pdEZpYmVyUm9vdCA9IGZ1bmN0aW9uIGhhbmRsZUNvbW1pdEZpYmVyUm9vdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZUNvbW1pdEZpYmVyUm9vdCBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50ID0gZnVuY3Rpb24gaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290ID0gZnVuY3Rpb24gaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZVBvc3RDb21taXRGaWJlclJvb3Qgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG5cbiAgdmFyIG92ZXJyaWRlRXJyb3IgPSBmdW5jdGlvbiBvdmVycmlkZUVycm9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb3ZlcnJpZGVFcnJvciBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcblxuICB2YXIgb3ZlcnJpZGVTdXNwZW5zZSA9IGZ1bmN0aW9uIG92ZXJyaWRlU3VzcGVuc2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvdmVycmlkZVN1c3BlbnNlIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuXG4gIHZhciBzdGFydFByb2ZpbGluZyA9IGZ1bmN0aW9uIHN0YXJ0UHJvZmlsaW5nKCkgey8vIERvIG5vdCB0aHJvdywgc2luY2UgdGhpcyB3b3VsZCBicmVhayBhIG11bHRpLXJvb3Qgc2NlbmFyaW8gd2hlcmUgdjE1IGFuZCB2MTYgd2VyZSBib3RoIHByZXNlbnQuXG4gIH07XG5cbiAgdmFyIHN0b3BQcm9maWxpbmcgPSBmdW5jdGlvbiBzdG9wUHJvZmlsaW5nKCkgey8vIERvIG5vdCB0aHJvdywgc2luY2UgdGhpcyB3b3VsZCBicmVhayBhIG11bHRpLXJvb3Qgc2NlbmFyaW8gd2hlcmUgdjE1IGFuZCB2MTYgd2VyZSBib3RoIHByZXNlbnQuXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgoKSB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGF0aEZvckVsZW1lbnQoaWQpIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnMpIHsvLyBOb3QgaW1wbGVtZW50ZWQuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkKGVuYWJsZWQpIHsvLyBOb3QgaW1wbGVtZW50ZWQuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFja2VkUGF0aChwYXRoKSB7Ly8gTm90IGltcGxlbWVudGVkLlxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3duZXJzTGlzdChpZCkge1xuICAgIC8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3JzQW5kV2FybmluZ3MoKSB7Ly8gTm90IGltcGxlbWVudGVkXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckVycm9yc0ZvckZpYmVySUQoaWQpIHsvLyBOb3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyV2FybmluZ3NGb3JGaWJlcklEKGlkKSB7Ly8gTm90IGltcGxlbWVudGVkXG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlKCkge31cblxuICBmdW5jdGlvbiB1bnBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUoKSB7fVxuXG4gIHJldHVybiB7XG4gICAgY2xlYXJFcnJvcnNBbmRXYXJuaW5nczogY2xlYXJFcnJvcnNBbmRXYXJuaW5ncyxcbiAgICBjbGVhckVycm9yc0ZvckZpYmVySUQ6IGNsZWFyRXJyb3JzRm9yRmliZXJJRCxcbiAgICBjbGVhcldhcm5pbmdzRm9yRmliZXJJRDogY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQsXG4gICAgY2xlYW51cDogY2xlYW51cCxcbiAgICBnZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoOiBnZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoLFxuICAgIGRlbGV0ZVBhdGg6IGRlbGV0ZVBhdGgsXG4gICAgZmx1c2hJbml0aWFsT3BlcmF0aW9uczogZmx1c2hJbml0aWFsT3BlcmF0aW9ucyxcbiAgICBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aDogZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgsXG4gICAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlcklEOiBnZXREaXNwbGF5TmFtZUZvckZpYmVySUQsXG4gICAgZ2V0RmliZXJGb3JOYXRpdmU6IGdldEZpYmVyRm9yTmF0aXZlLFxuICAgIGdldEZpYmVySURGb3JOYXRpdmU6IGdldEludGVybmFsSURGb3JOYXRpdmUsXG4gICAgZ2V0SW5zdGFuY2VBbmRTdHlsZTogZ2V0SW5zdGFuY2VBbmRTdHlsZSxcbiAgICBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEOiBmdW5jdGlvbiBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKSB7XG4gICAgICB2YXIgbmF0aXZlTm9kZSA9IGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCk7XG4gICAgICByZXR1cm4gbmF0aXZlTm9kZSA9PSBudWxsID8gbnVsbCA6IFtuYXRpdmVOb2RlXTtcbiAgICB9LFxuICAgIGdldE93bmVyc0xpc3Q6IGdldE93bmVyc0xpc3QsXG4gICAgZ2V0UGF0aEZvckVsZW1lbnQ6IGdldFBhdGhGb3JFbGVtZW50LFxuICAgIGdldFByb2ZpbGluZ0RhdGE6IGdldFByb2ZpbGluZ0RhdGEsXG4gICAgaGFuZGxlQ29tbWl0RmliZXJSb290OiBoYW5kbGVDb21taXRGaWJlclJvb3QsXG4gICAgaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50OiBoYW5kbGVDb21taXRGaWJlclVubW91bnQsXG4gICAgaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdDogaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCxcbiAgICBpbnNwZWN0RWxlbWVudDogaW5zcGVjdEVsZW1lbnQsXG4gICAgbG9nRWxlbWVudFRvQ29uc29sZTogbG9nRWxlbWVudFRvQ29uc29sZSxcbiAgICBvdmVycmlkZUVycm9yOiBvdmVycmlkZUVycm9yLFxuICAgIG92ZXJyaWRlU3VzcGVuc2U6IG92ZXJyaWRlU3VzcGVuc2UsXG4gICAgb3ZlcnJpZGVWYWx1ZUF0UGF0aDogb3ZlcnJpZGVWYWx1ZUF0UGF0aCxcbiAgICByZW5hbWVQYXRoOiByZW5hbWVQYXRoLFxuICAgIHBhdGNoQ29uc29sZUZvclN0cmljdE1vZGU6IHBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUsXG4gICAgcHJlcGFyZVZpZXdBdHRyaWJ1dGVTb3VyY2U6IHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlLFxuICAgIHByZXBhcmVWaWV3RWxlbWVudFNvdXJjZTogcHJlcGFyZVZpZXdFbGVtZW50U291cmNlLFxuICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkOiBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkLFxuICAgIHNldFRyYWNrZWRQYXRoOiBzZXRUcmFja2VkUGF0aCxcbiAgICBzdGFydFByb2ZpbGluZzogc3RhcnRQcm9maWxpbmcsXG4gICAgc3RvcFByb2ZpbGluZzogc3RvcFByb2ZpbGluZyxcbiAgICBzdG9yZUFzR2xvYmFsOiBzdG9yZUFzR2xvYmFsLFxuICAgIHVucGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZTogdW5wYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlLFxuICAgIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnM6IHVwZGF0ZUNvbXBvbmVudEZpbHRlcnNcbiAgfTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9pbmRleC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxuLy8gdGhpcyBpcyB0aGUgYmFja2VuZCB0aGF0IGlzIGNvbXBhY3RpYmxlIHdpdGggYWxsIG9sZGVyIFJlYWN0IHZlcnNpb25zXG5mdW5jdGlvbiBpc01hdGNoaW5nUmVuZGVyKHZlcnNpb24pIHtcbiAgcmV0dXJuICFPYmplY3QodXRpbHNbXCJqXCIgLyogaGFzQXNzaWduZWRCYWNrZW5kICovXSkodmVyc2lvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRCYWNrZW5kKGhvb2ssIGFnZW50LCBnbG9iYWwpIHtcbiAgaWYgKGhvb2sgPT0gbnVsbCkge1xuICAgIC8vIERldlRvb2xzIGRpZG4ndCBnZXQgaW5qZWN0ZWQgaW50byB0aGlzIHBhZ2UgKG1heWJlIGInYyBvZiB0aGUgY29udGVudFR5cGUpLlxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIHZhciBzdWJzID0gW2hvb2suc3ViKCdyZW5kZXJlci1hdHRhY2hlZCcsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgcmVuZGVyZXIgPSBfcmVmLnJlbmRlcmVyLFxuICAgICAgICByZW5kZXJlckludGVyZmFjZSA9IF9yZWYucmVuZGVyZXJJbnRlcmZhY2U7XG4gICAgYWdlbnQuc2V0UmVuZGVyZXJJbnRlcmZhY2UoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTsgLy8gTm93IHRoYXQgdGhlIFN0b3JlIGFuZCB0aGUgcmVuZGVyZXIgaW50ZXJmYWNlIGFyZSBjb25uZWN0ZWQsXG4gICAgLy8gaXQncyB0aW1lIHRvIGZsdXNoIHRoZSBwZW5kaW5nIG9wZXJhdGlvbiBjb2RlcyB0byB0aGUgZnJvbnRlbmQuXG5cbiAgICByZW5kZXJlckludGVyZmFjZS5mbHVzaEluaXRpYWxPcGVyYXRpb25zKCk7XG4gIH0pLCBob29rLnN1YigndW5zdXBwb3J0ZWQtcmVuZGVyZXItdmVyc2lvbicsIGZ1bmN0aW9uIChpZCkge1xuICAgIGFnZW50Lm9uVW5zdXBwb3J0ZWRSZW5kZXJlcihpZCk7XG4gIH0pLCBob29rLnN1YignZmFzdFJlZnJlc2hTY2hlZHVsZWQnLCBhZ2VudC5vbkZhc3RSZWZyZXNoU2NoZWR1bGVkKSwgaG9vay5zdWIoJ29wZXJhdGlvbnMnLCBhZ2VudC5vbkhvb2tPcGVyYXRpb25zKSwgaG9vay5zdWIoJ3RyYWNlVXBkYXRlcycsIGFnZW50Lm9uVHJhY2VVcGRhdGVzKSAvLyBUT0RPIEFkZCBhZGRpdGlvbmFsIHN1YnNjcmlwdGlvbnMgcmVxdWlyZWQgZm9yIHByb2ZpbGluZyBtb2RlXG4gIF07XG5cbiAgdmFyIGF0dGFjaFJlbmRlcmVyID0gZnVuY3Rpb24gYXR0YWNoUmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XG4gICAgLy8gc2tpcCBpZiBhbHJlYWR5IGF0dGFjaGVkXG4gICAgaWYgKHJlbmRlcmVyLmF0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBvbmx5IGF0dGFjaCBpZiB0aGUgcmVuZGVyZXIgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGJhY2tlbmRcblxuXG4gICAgaWYgKCFpc01hdGNoaW5nUmVuZGVyKHJlbmRlcmVyLnJlY29uY2lsZXJWZXJzaW9uIHx8IHJlbmRlcmVyLnZlcnNpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVySW50ZXJmYWNlID0gaG9vay5yZW5kZXJlckludGVyZmFjZXMuZ2V0KGlkKTsgLy8gSW5qZWN0IGFueSBub3QteWV0LWluamVjdGVkIHJlbmRlcmVycyAoaWYgd2UgZGlkbid0IHJlbG9hZC1hbmQtcHJvZmlsZSlcblxuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSA9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHJlYWN0LXJlY29uY2lsZXIgdjE2K1xuICAgICAgICByZW5kZXJlckludGVyZmFjZSA9IE9iamVjdChiYWNrZW5kX3JlbmRlcmVyW1wiYVwiIC8qIGF0dGFjaCAqL10pKGhvb2ssIGlkLCByZW5kZXJlciwgZ2xvYmFsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyZXIuQ29tcG9uZW50VHJlZSkge1xuICAgICAgICAvLyByZWFjdC1kb20gdjE1XG4gICAgICAgIHJlbmRlcmVySW50ZXJmYWNlID0gYXR0YWNoKGhvb2ssIGlkLCByZW5kZXJlciwgZ2xvYmFsKTtcbiAgICAgIH0gZWxzZSB7Ly8gT2xkZXIgcmVhY3QtZG9tIG9yIG90aGVyIHVuc3VwcG9ydGVkIHJlbmRlcmVyIHZlcnNpb25cbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlICE9IG51bGwpIHtcbiAgICAgICAgaG9vay5yZW5kZXJlckludGVyZmFjZXMuc2V0KGlkLCByZW5kZXJlckludGVyZmFjZSk7XG4gICAgICB9XG4gICAgfSAvLyBOb3RpZnkgdGhlIERldlRvb2xzIGZyb250ZW5kIGFib3V0IG5ldyByZW5kZXJlcnMuXG4gICAgLy8gVGhpcyBpbmNsdWRlcyBhbnkgdGhhdCB3ZXJlIGF0dGFjaGVkIGVhcmx5ICh2aWEgX19SRUFDVF9ERVZUT09MU19BVFRBQ0hfXykuXG5cblxuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSAhPSBudWxsKSB7XG4gICAgICBob29rLmVtaXQoJ3JlbmRlcmVyLWF0dGFjaGVkJywge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICAgICAgcmVuZGVyZXJJbnRlcmZhY2U6IHJlbmRlcmVySW50ZXJmYWNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9vay5lbWl0KCd1bnN1cHBvcnRlZC1yZW5kZXJlci12ZXJzaW9uJywgaWQpO1xuICAgIH1cblxuICAgIHJlbmRlcmVyLmF0dGFjaGVkID0gdHJ1ZTtcbiAgfTsgLy8gQ29ubmVjdCByZW5kZXJlcnMgdGhhdCBoYXZlIGFscmVhZHkgaW5qZWN0ZWQgdGhlbXNlbHZlcy5cblxuXG4gIGhvb2sucmVuZGVyZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlbmRlcmVyLCBpZCkge1xuICAgIGF0dGFjaFJlbmRlcmVyKGlkLCByZW5kZXJlcik7XG4gIH0pOyAvLyBDb25uZWN0IGFueSBuZXcgcmVuZGVyZXJzIHRoYXQgaW5qZWN0ZWQgdGhlbXNlbHZlcy5cblxuICBzdWJzLnB1c2goaG9vay5zdWIoJ3JlbmRlcmVyJywgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICAgIHJlbmRlcmVyID0gX3JlZjIucmVuZGVyZXI7XG4gICAgYXR0YWNoUmVuZGVyZXIoaWQsIHJlbmRlcmVyKTtcbiAgfSkpO1xuICBob29rLmVtaXQoJ3JlYWN0LWRldnRvb2xzJywgYWdlbnQpO1xuICBob29rLnJlYWN0RGV2dG9vbHNBZ2VudCA9IGFnZW50O1xuXG4gIHZhciBvbkFnZW50U2h1dGRvd24gPSBmdW5jdGlvbiBvbkFnZW50U2h1dGRvd24oKSB7XG4gICAgc3Vicy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSk7XG4gICAgaG9vay5yZW5kZXJlckludGVyZmFjZXMuZm9yRWFjaChmdW5jdGlvbiAocmVuZGVyZXJJbnRlcmZhY2UpIHtcbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlLmNsZWFudXAoKTtcbiAgICB9KTtcbiAgICBob29rLnJlYWN0RGV2dG9vbHNBZ2VudCA9IG51bGw7XG4gIH07XG5cbiAgYWdlbnQuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgb25BZ2VudFNodXRkb3duKTtcbiAgc3Vicy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBhZ2VudC5yZW1vdmVMaXN0ZW5lcignc2h1dGRvd24nLCBvbkFnZW50U2h1dGRvd24pO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdWJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9OYXRpdmVTdHlsZUVkaXRvci9yZXNvbHZlQm94U3R5bGUuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG4vKipcbiAqIFRoaXMgbWlycm9ycyByZWFjdC1uYXRpdmUvTGlicmFyaWVzL0luc3BlY3Rvci9yZXNvbHZlQm94U3R5bGUuanMgKGJ1dCB3aXRob3V0IFJUTCBzdXBwb3J0KS5cbiAqXG4gKiBSZXNvbHZlIGEgc3R5bGUgcHJvcGVydHkgaW50byBpdCdzIGNvbXBvbmVudCBwYXJ0cywgZS5nLlxuICpcbiAqIHJlc29sdmVCb3hTdHlsZSgnbWFyZ2luJywge21hcmdpbjogNSwgbWFyZ2luQm90dG9tOiAxMH0pXG4gKiAtPiB7dG9wOiA1LCBsZWZ0OiA1LCByaWdodDogNSwgYm90dG9tOiAxMH1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUJveFN0eWxlKHByZWZpeCwgc3R5bGUpIHtcbiAgdmFyIGhhc1BhcnRzID0gZmFsc2U7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwXG4gIH07XG4gIHZhciBzdHlsZUZvckFsbCA9IHN0eWxlW3ByZWZpeF07XG5cbiAgaWYgKHN0eWxlRm9yQWxsICE9IG51bGwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMocmVzdWx0KTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgIHJlc3VsdFtrZXldID0gc3R5bGVGb3JBbGw7XG4gICAgfVxuXG4gICAgaGFzUGFydHMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0eWxlRm9ySG9yaXpvbnRhbCA9IHN0eWxlW3ByZWZpeCArICdIb3Jpem9udGFsJ107XG5cbiAgaWYgKHN0eWxlRm9ySG9yaXpvbnRhbCAhPSBudWxsKSB7XG4gICAgcmVzdWx0LmxlZnQgPSBzdHlsZUZvckhvcml6b250YWw7XG4gICAgcmVzdWx0LnJpZ2h0ID0gc3R5bGVGb3JIb3Jpem9udGFsO1xuICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3R5bGVGb3JMZWZ0ID0gc3R5bGVbcHJlZml4ICsgJ0xlZnQnXTtcblxuICAgIGlmIChzdHlsZUZvckxlZnQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmxlZnQgPSBzdHlsZUZvckxlZnQ7XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlRm9yUmlnaHQgPSBzdHlsZVtwcmVmaXggKyAnUmlnaHQnXTtcblxuICAgIGlmIChzdHlsZUZvclJpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHN0eWxlRm9yUmlnaHQ7XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlRm9yRW5kID0gc3R5bGVbcHJlZml4ICsgJ0VuZCddO1xuXG4gICAgaWYgKHN0eWxlRm9yRW5kICE9IG51bGwpIHtcbiAgICAgIC8vIFRPRE8gUlRMIHN1cHBvcnRcbiAgICAgIHJlc3VsdC5yaWdodCA9IHN0eWxlRm9yRW5kO1xuICAgICAgaGFzUGFydHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdHlsZUZvclN0YXJ0ID0gc3R5bGVbcHJlZml4ICsgJ1N0YXJ0J107XG5cbiAgICBpZiAoc3R5bGVGb3JTdGFydCAhPSBudWxsKSB7XG4gICAgICAvLyBUT0RPIFJUTCBzdXBwb3J0XG4gICAgICByZXN1bHQubGVmdCA9IHN0eWxlRm9yU3RhcnQ7XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0eWxlRm9yVmVydGljYWwgPSBzdHlsZVtwcmVmaXggKyAnVmVydGljYWwnXTtcblxuICBpZiAoc3R5bGVGb3JWZXJ0aWNhbCAhPSBudWxsKSB7XG4gICAgcmVzdWx0LmJvdHRvbSA9IHN0eWxlRm9yVmVydGljYWw7XG4gICAgcmVzdWx0LnRvcCA9IHN0eWxlRm9yVmVydGljYWw7XG4gICAgaGFzUGFydHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHlsZUZvckJvdHRvbSA9IHN0eWxlW3ByZWZpeCArICdCb3R0b20nXTtcblxuICAgIGlmIChzdHlsZUZvckJvdHRvbSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQuYm90dG9tID0gc3R5bGVGb3JCb3R0b207XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlRm9yVG9wID0gc3R5bGVbcHJlZml4ICsgJ1RvcCddO1xuXG4gICAgaWYgKHN0eWxlRm9yVG9wICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC50b3AgPSBzdHlsZUZvclRvcDtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGFzUGFydHMgPyByZXN1bHQgOiBudWxsO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2lzQXJyYXkuanNcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL05hdGl2ZVN0eWxlRWRpdG9yL3NldHVwTmF0aXZlU3R5bGVFZGl0b3IuanNcbmZ1bmN0aW9uIHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cbmZ1bmN0aW9uIHNldHVwTmF0aXZlU3R5bGVFZGl0b3IoYnJpZGdlLCBhZ2VudCwgcmVzb2x2ZU5hdGl2ZVN0eWxlLCB2YWxpZEF0dHJpYnV0ZXMpIHtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdOYXRpdmVTdHlsZUVkaXRvcl9tZWFzdXJlJywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICByZW5kZXJlcklEID0gX3JlZi5yZW5kZXJlcklEO1xuICAgIG1lYXN1cmVTdHlsZShhZ2VudCwgYnJpZGdlLCByZXNvbHZlTmF0aXZlU3R5bGUsIGlkLCByZW5kZXJlcklEKTtcbiAgfSk7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcignTmF0aXZlU3R5bGVFZGl0b3JfcmVuYW1lQXR0cmlidXRlJywgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMi5yZW5kZXJlcklELFxuICAgICAgICBvbGROYW1lID0gX3JlZjIub2xkTmFtZSxcbiAgICAgICAgbmV3TmFtZSA9IF9yZWYyLm5ld05hbWUsXG4gICAgICAgIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgcmVuYW1lU3R5bGUoYWdlbnQsIGlkLCByZW5kZXJlcklELCBvbGROYW1lLCBuZXdOYW1lLCB2YWx1ZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZVN0eWxlKGFnZW50LCBicmlkZ2UsIHJlc29sdmVOYXRpdmVTdHlsZSwgaWQsIHJlbmRlcmVySUQpO1xuICAgIH0pO1xuICB9KTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdOYXRpdmVTdHlsZUVkaXRvcl9zZXRWYWx1ZScsIGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBpZCA9IF9yZWYzLmlkLFxuICAgICAgICByZW5kZXJlcklEID0gX3JlZjMucmVuZGVyZXJJRCxcbiAgICAgICAgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgIHZhbHVlID0gX3JlZjMudmFsdWU7XG4gICAgc2V0U3R5bGUoYWdlbnQsIGlkLCByZW5kZXJlcklELCBuYW1lLCB2YWx1ZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZVN0eWxlKGFnZW50LCBicmlkZ2UsIHJlc29sdmVOYXRpdmVTdHlsZSwgaWQsIHJlbmRlcmVySUQpO1xuICAgIH0pO1xuICB9KTtcbiAgYnJpZGdlLnNlbmQoJ2lzTmF0aXZlU3R5bGVFZGl0b3JTdXBwb3J0ZWQnLCB7XG4gICAgaXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgdmFsaWRBdHRyaWJ1dGVzOiB2YWxpZEF0dHJpYnV0ZXNcbiAgfSk7XG59XG52YXIgRU1QVFlfQk9YX1NUWUxFID0ge1xuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDBcbn07XG52YXIgY29tcG9uZW50SURUb1N0eWxlT3ZlcnJpZGVzID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBtZWFzdXJlU3R5bGUoYWdlbnQsIGJyaWRnZSwgcmVzb2x2ZU5hdGl2ZVN0eWxlLCBpZCwgcmVuZGVyZXJJRCkge1xuICB2YXIgZGF0YSA9IGFnZW50LmdldEluc3RhbmNlQW5kU3R5bGUoe1xuICAgIGlkOiBpZCxcbiAgICByZW5kZXJlcklEOiByZW5kZXJlcklEXG4gIH0pO1xuXG4gIGlmICghZGF0YSB8fCAhZGF0YS5zdHlsZSkge1xuICAgIGJyaWRnZS5zZW5kKCdOYXRpdmVTdHlsZUVkaXRvcl9zdHlsZUFuZExheW91dCcsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGxheW91dDogbnVsbCxcbiAgICAgIHN0eWxlOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZGF0YS5pbnN0YW5jZSxcbiAgICAgIHN0eWxlID0gZGF0YS5zdHlsZTtcbiAgdmFyIHJlc29sdmVkU3R5bGUgPSByZXNvbHZlTmF0aXZlU3R5bGUoc3R5bGUpOyAvLyBJZiBpdCdzIGEgaG9zdCBjb21wb25lbnQgd2UgZWRpdGVkIGJlZm9yZSwgYW1lbmQgc3R5bGVzLlxuXG4gIHZhciBzdHlsZU92ZXJyaWRlcyA9IGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5nZXQoaWQpO1xuXG4gIGlmIChzdHlsZU92ZXJyaWRlcyAhPSBudWxsKSB7XG4gICAgcmVzb2x2ZWRTdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHJlc29sdmVkU3R5bGUsIHN0eWxlT3ZlcnJpZGVzKTtcbiAgfVxuXG4gIGlmICghaW5zdGFuY2UgfHwgdHlwZW9mIGluc3RhbmNlLm1lYXN1cmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICBicmlkZ2Uuc2VuZCgnTmF0aXZlU3R5bGVFZGl0b3Jfc3R5bGVBbmRMYXlvdXQnLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICBzdHlsZTogcmVzb2x2ZWRTdHlsZSB8fCBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5zdGFuY2UubWVhc3VyZShmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wKSB7XG4gICAgLy8gUk4gQW5kcm9pZCBzb21ldGltZXMgcmV0dXJucyB1bmRlZmluZWQgaGVyZS4gRG9uJ3Qgc2VuZCBtZWFzdXJlbWVudHMgaW4gdGhpcyBjYXNlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGVuMDQwOS9yZWFjdC1uYXRpdmUtZGVidWdnZXIvaXNzdWVzLzg0I2lzc3VlY29tbWVudC0zMDQ2MTE4MTdcbiAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSB7XG4gICAgICBicmlkZ2Uuc2VuZCgnTmF0aXZlU3R5bGVFZGl0b3Jfc3R5bGVBbmRMYXlvdXQnLCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgICBzdHlsZTogcmVzb2x2ZWRTdHlsZSB8fCBudWxsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWFyZ2luID0gcmVzb2x2ZWRTdHlsZSAhPSBudWxsICYmIHJlc29sdmVCb3hTdHlsZSgnbWFyZ2luJywgcmVzb2x2ZWRTdHlsZSkgfHwgRU1QVFlfQk9YX1NUWUxFO1xuICAgIHZhciBwYWRkaW5nID0gcmVzb2x2ZWRTdHlsZSAhPSBudWxsICYmIHJlc29sdmVCb3hTdHlsZSgncGFkZGluZycsIHJlc29sdmVkU3R5bGUpIHx8IEVNUFRZX0JPWF9TVFlMRTtcbiAgICBicmlkZ2Uuc2VuZCgnTmF0aXZlU3R5bGVFZGl0b3Jfc3R5bGVBbmRMYXlvdXQnLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHJlc29sdmVkU3R5bGUgfHwgbnVsbFxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iamVjdCkge1xuICB2YXIgY2xvbmVkID0ge307XG5cbiAgZm9yICh2YXIgbiBpbiBvYmplY3QpIHtcbiAgICBjbG9uZWRbbl0gPSBvYmplY3Rbbl07XG4gIH1cblxuICByZXR1cm4gY2xvbmVkO1xufVxuXG5mdW5jdGlvbiByZW5hbWVTdHlsZShhZ2VudCwgaWQsIHJlbmRlcmVySUQsIG9sZE5hbWUsIG5ld05hbWUsIHZhbHVlKSB7XG4gIHZhciBfcmVmNDtcblxuICB2YXIgZGF0YSA9IGFnZW50LmdldEluc3RhbmNlQW5kU3R5bGUoe1xuICAgIGlkOiBpZCxcbiAgICByZW5kZXJlcklEOiByZW5kZXJlcklEXG4gIH0pO1xuXG4gIGlmICghZGF0YSB8fCAhZGF0YS5zdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGRhdGEuaW5zdGFuY2UsXG4gICAgICBzdHlsZSA9IGRhdGEuc3R5bGU7XG4gIHZhciBuZXdTdHlsZSA9IG5ld05hbWUgPyAoX3JlZjQgPSB7fSwgc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl9kZWZpbmVQcm9wZXJ0eShfcmVmNCwgb2xkTmFtZSwgdW5kZWZpbmVkKSwgc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl9kZWZpbmVQcm9wZXJ0eShfcmVmNCwgbmV3TmFtZSwgdmFsdWUpLCBfcmVmNCkgOiBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX2RlZmluZVByb3BlcnR5KHt9LCBvbGROYW1lLCB1bmRlZmluZWQpO1xuICB2YXIgY3VzdG9tU3R5bGU7IC8vIFRPRE8gSXQgd291bGQgYmUgbmljZSBpZiB0aGUgcmVuZGVyZXIgaW50ZXJmYWNlIGFic3RyYWN0ZWQgdGhpcyBhd2F5IHNvbWVob3cuXG5cbiAgaWYgKGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5zZXROYXRpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgaG9zdCBjb21wb25lbnQsIHdlIG5lZWQgdG8gdXNlIHNldE5hdGl2ZVByb3BzKCkuXG4gICAgLy8gUmVtZW1iZXIgdG8gXCJjb3JyZWN0XCIgcmVzb2x2ZWQgc3R5bGVzIHdoZW4gd2UgcmVhZCB0aGVtIG5leHQgdGltZS5cbiAgICB2YXIgc3R5bGVPdmVycmlkZXMgPSBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMuZ2V0KGlkKTtcblxuICAgIGlmICghc3R5bGVPdmVycmlkZXMpIHtcbiAgICAgIGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5zZXQoaWQsIG5ld1N0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZU92ZXJyaWRlcywgbmV3U3R5bGUpO1xuICAgIH0gLy8gVE9ETyBGYWJyaWMgZG9lcyBub3Qgc3VwcG9ydCBzZXROYXRpdmVQcm9wczsgY2hhdCB3aXRoIFNlYmFzdGlhbiBvciBFbGlcblxuXG4gICAgaW5zdGFuY2Uuc2V0TmF0aXZlUHJvcHMoe1xuICAgICAgc3R5bGU6IG5ld1N0eWxlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0eWxlKSkge1xuICAgIHZhciBsYXN0SW5kZXggPSBzdHlsZS5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfdHlwZW9mKHN0eWxlW2xhc3RJbmRleF0pID09PSAnb2JqZWN0JyAmJiAhT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0eWxlW2xhc3RJbmRleF0pKSB7XG4gICAgICBjdXN0b21TdHlsZSA9IHNoYWxsb3dDbG9uZShzdHlsZVtsYXN0SW5kZXhdKTtcbiAgICAgIGRlbGV0ZSBjdXN0b21TdHlsZVtvbGROYW1lXTtcblxuICAgICAgaWYgKG5ld05hbWUpIHtcbiAgICAgICAgY3VzdG9tU3R5bGVbbmV3TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1c3RvbVN0eWxlW29sZE5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICBwYXRoOiBbJ3N0eWxlJywgbGFzdEluZGV4XSxcbiAgICAgICAgdmFsdWU6IGN1c3RvbVN0eWxlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgcGF0aDogWydzdHlsZSddLFxuICAgICAgICB2YWx1ZTogc3R5bGUuY29uY2F0KFtuZXdTdHlsZV0pXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl90eXBlb2Yoc3R5bGUpID09PSAnb2JqZWN0Jykge1xuICAgIGN1c3RvbVN0eWxlID0gc2hhbGxvd0Nsb25lKHN0eWxlKTtcbiAgICBkZWxldGUgY3VzdG9tU3R5bGVbb2xkTmFtZV07XG5cbiAgICBpZiAobmV3TmFtZSkge1xuICAgICAgY3VzdG9tU3R5bGVbbmV3TmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tU3R5bGVbb2xkTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgaWQ6IGlkLFxuICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgIHZhbHVlOiBjdXN0b21TdHlsZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICBwYXRoOiBbJ3N0eWxlJ10sXG4gICAgICB2YWx1ZTogW3N0eWxlLCBuZXdTdHlsZV1cbiAgICB9KTtcbiAgfVxuXG4gIGFnZW50LmVtaXQoJ2hpZGVOYXRpdmVIaWdobGlnaHQnKTtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoYWdlbnQsIGlkLCByZW5kZXJlcklELCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGFnZW50LmdldEluc3RhbmNlQW5kU3R5bGUoe1xuICAgIGlkOiBpZCxcbiAgICByZW5kZXJlcklEOiByZW5kZXJlcklEXG4gIH0pO1xuXG4gIGlmICghZGF0YSB8fCAhZGF0YS5zdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGRhdGEuaW5zdGFuY2UsXG4gICAgICBzdHlsZSA9IGRhdGEuc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgdmFsdWUpOyAvLyBUT0RPIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIHJlbmRlcmVyIGludGVyZmFjZSBhYnN0cmFjdGVkIHRoaXMgYXdheSBzb21laG93LlxuXG5cbiAgaWYgKGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5zZXROYXRpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgaG9zdCBjb21wb25lbnQsIHdlIG5lZWQgdG8gdXNlIHNldE5hdGl2ZVByb3BzKCkuXG4gICAgLy8gUmVtZW1iZXIgdG8gXCJjb3JyZWN0XCIgcmVzb2x2ZWQgc3R5bGVzIHdoZW4gd2UgcmVhZCB0aGVtIG5leHQgdGltZS5cbiAgICB2YXIgc3R5bGVPdmVycmlkZXMgPSBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMuZ2V0KGlkKTtcblxuICAgIGlmICghc3R5bGVPdmVycmlkZXMpIHtcbiAgICAgIGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5zZXQoaWQsIG5ld1N0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZU92ZXJyaWRlcywgbmV3U3R5bGUpO1xuICAgIH0gLy8gVE9ETyBGYWJyaWMgZG9lcyBub3Qgc3VwcG9ydCBzZXROYXRpdmVQcm9wczsgY2hhdCB3aXRoIFNlYmFzdGlhbiBvciBFbGlcblxuXG4gICAgaW5zdGFuY2Uuc2V0TmF0aXZlUHJvcHMoe1xuICAgICAgc3R5bGU6IG5ld1N0eWxlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoT2JqZWN0KGlzQXJyYXlbXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0eWxlKSkge1xuICAgIHZhciBsYXN0TGVuZ3RoID0gc3R5bGUubGVuZ3RoIC0gMTtcblxuICAgIGlmIChzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZihzdHlsZVtsYXN0TGVuZ3RoXSkgPT09ICdvYmplY3QnICYmICFPYmplY3QoaXNBcnJheVtcImFcIiAvKiBkZWZhdWx0ICovXSkoc3R5bGVbbGFzdExlbmd0aF0pKSB7XG4gICAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICBwYXRoOiBbJ3N0eWxlJywgbGFzdExlbmd0aCwgbmFtZV0sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgICAgdmFsdWU6IHN0eWxlLmNvbmNhdChbbmV3U3R5bGVdKVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICBwYXRoOiBbJ3N0eWxlJ10sXG4gICAgICB2YWx1ZTogW3N0eWxlLCBuZXdTdHlsZV1cbiAgICB9KTtcbiAgfVxuXG4gIGFnZW50LmVtaXQoJ2hpZGVOYXRpdmVIaWdobGlnaHQnKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NhY2hlZFNldHRpbmdzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbiAvLyBOb3RlOiBhbGwga2V5cyBzaG91bGQgYmUgb3B0aW9uYWwgaW4gdGhpcyB0eXBlLCBiZWNhdXNlIHVzZXJzIGNhbiB1c2UgbmV3ZXJcbi8vIHZlcnNpb25zIG9mIFJlYWN0IERldlRvb2xzIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgUmVhY3QgTmF0aXZlLCBhbmQgdGhlIG9iamVjdFxuLy8gcHJvdmlkZWQgYnkgUmVhY3QgTmF0aXZlIG1heSBub3QgaW5jbHVkZSBhbGwgb2YgdGhpcyB0eXBlJ3MgZmllbGRzLlxuXG5mdW5jdGlvbiBpbml0aWFsaXplVXNpbmdDYWNoZWRTZXR0aW5ncyhkZXZUb29sc1NldHRpbmdzTWFuYWdlcikge1xuICBpbml0aWFsaXplQ29uc29sZVBhdGNoU2V0dGluZ3MoZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplQ29uc29sZVBhdGNoU2V0dGluZ3MoZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIpIHtcbiAgaWYgKGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyLmdldENvbnNvbGVQYXRjaFNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29uc29sZVBhdGNoU2V0dGluZ3NTdHJpbmcgPSBkZXZUb29sc1NldHRpbmdzTWFuYWdlci5nZXRDb25zb2xlUGF0Y2hTZXR0aW5ncygpO1xuXG4gIGlmIChjb25zb2xlUGF0Y2hTZXR0aW5nc1N0cmluZyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcnNlZENvbnNvbGVQYXRjaFNldHRpbmdzID0gcGFyc2VDb25zb2xlUGF0Y2hTZXR0aW5ncyhjb25zb2xlUGF0Y2hTZXR0aW5nc1N0cmluZyk7XG5cbiAgaWYgKHBhcnNlZENvbnNvbGVQYXRjaFNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QoYmFja2VuZF9jb25zb2xlW1wiZ1wiIC8qIHdyaXRlQ29uc29sZVBhdGNoU2V0dGluZ3NUb1dpbmRvdyAqL10pKHBhcnNlZENvbnNvbGVQYXRjaFNldHRpbmdzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb25zb2xlUGF0Y2hTZXR0aW5ncyhjb25zb2xlUGF0Y2hTZXR0aW5nc1N0cmluZykge1xuICB2YXIgX2Nhc3RCb29sLCBfY2FzdEJvb2wyLCBfY2FzdEJvb2wzLCBfY2FzdEJvb2w0LCBfY2FzdEJyb3dzZXJUaGVtZTtcblxuICB2YXIgcGFyc2VkVmFsdWUgPSBKU09OLnBhcnNlKGNvbnNvbGVQYXRjaFNldHRpbmdzU3RyaW5nICE9PSBudWxsICYmIGNvbnNvbGVQYXRjaFNldHRpbmdzU3RyaW5nICE9PSB2b2lkIDAgPyBjb25zb2xlUGF0Y2hTZXR0aW5nc1N0cmluZyA6ICd7fScpO1xuICB2YXIgYXBwZW5kQ29tcG9uZW50U3RhY2sgPSBwYXJzZWRWYWx1ZS5hcHBlbmRDb21wb25lbnRTdGFjayxcbiAgICAgIGJyZWFrT25Db25zb2xlRXJyb3JzID0gcGFyc2VkVmFsdWUuYnJlYWtPbkNvbnNvbGVFcnJvcnMsXG4gICAgICBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPSBwYXJzZWRWYWx1ZS5zaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMsXG4gICAgICBoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUgPSBwYXJzZWRWYWx1ZS5oaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUsXG4gICAgICBicm93c2VyVGhlbWUgPSBwYXJzZWRWYWx1ZS5icm93c2VyVGhlbWU7XG4gIHJldHVybiB7XG4gICAgYXBwZW5kQ29tcG9uZW50U3RhY2s6IChfY2FzdEJvb2wgPSBPYmplY3Qoc3JjX3V0aWxzW1wiYVwiIC8qIGNhc3RCb29sICovXSkoYXBwZW5kQ29tcG9uZW50U3RhY2spKSAhPT0gbnVsbCAmJiBfY2FzdEJvb2wgIT09IHZvaWQgMCA/IF9jYXN0Qm9vbCA6IHRydWUsXG4gICAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IChfY2FzdEJvb2wyID0gT2JqZWN0KHNyY191dGlsc1tcImFcIiAvKiBjYXN0Qm9vbCAqL10pKGJyZWFrT25Db25zb2xlRXJyb3JzKSkgIT09IG51bGwgJiYgX2Nhc3RCb29sMiAhPT0gdm9pZCAwID8gX2Nhc3RCb29sMiA6IGZhbHNlLFxuICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9yczogKF9jYXN0Qm9vbDMgPSBPYmplY3Qoc3JjX3V0aWxzW1wiYVwiIC8qIGNhc3RCb29sICovXSkoc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSkgIT09IG51bGwgJiYgX2Nhc3RCb29sMyAhPT0gdm9pZCAwID8gX2Nhc3RCb29sMyA6IHRydWUsXG4gICAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlOiAoX2Nhc3RCb29sNCA9IE9iamVjdChzcmNfdXRpbHNbXCJhXCIgLyogY2FzdEJvb2wgKi9dKShoaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGUpKSAhPT0gbnVsbCAmJiBfY2FzdEJvb2w0ICE9PSB2b2lkIDAgPyBfY2FzdEJvb2w0IDogZmFsc2UsXG4gICAgYnJvd3NlclRoZW1lOiAoX2Nhc3RCcm93c2VyVGhlbWUgPSBPYmplY3Qoc3JjX3V0aWxzW1wiYlwiIC8qIGNhc3RCcm93c2VyVGhlbWUgKi9dKShicm93c2VyVGhlbWUpKSAhPT0gbnVsbCAmJiBfY2FzdEJyb3dzZXJUaGVtZSAhPT0gdm9pZCAwID8gX2Nhc3RCcm93c2VyVGhlbWUgOiAnZGFyaydcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb25zb2xlUGF0Y2hTZXR0aW5ncyhkZXZUb29sc1NldHRpbmdzTWFuYWdlciwgdmFsdWUpIHtcbiAgaWYgKGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyLnNldENvbnNvbGVQYXRjaFNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZXZUb29sc1NldHRpbmdzTWFuYWdlci5zZXRDb25zb2xlUGF0Y2hTZXR0aW5ncyhKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYmFja2VuZC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxuXG5cblxuXG4vLyBJbnN0YWxsIGEgZ2xvYmFsIHZhcmlhYmxlIHRvIGFsbG93IHBhdGNoaW5nIGNvbnNvbGUgZWFybHkgKGR1cmluZyBpbmplY3Rpb24pLlxuLy8gVGhpcyBwcm92aWRlcyBSZWFjdCBOYXRpdmUgZGV2ZWxvcGVycyB3aXRoIGNvbXBvbmVudHMgc3RhY2tzIGV2ZW4gaWYgdGhleSBkb24ndCBydW4gRGV2VG9vbHMuXG5PYmplY3QoYmFja2VuZF9jb25zb2xlW1wiYVwiIC8qIGluc3RhbGxDb25zb2xlRnVuY3Rpb25zVG9XaW5kb3cgKi9dKSgpO1xuaW5zdGFsbEhvb2sod2luZG93KTtcbnZhciBiYWNrZW5kX2hvb2sgPSB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xudmFyIHNhdmVkQ29tcG9uZW50RmlsdGVycyA9IE9iamVjdChzcmNfdXRpbHNbXCJnXCIgLyogZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMgKi9dKSgpO1xuXG5mdW5jdGlvbiBiYWNrZW5kX2RlYnVnKG1ldGhvZE5hbWUpIHtcbiAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBbXCIlY1tjb3JlL2JhY2tlbmRdICVjXCIuY29uY2F0KG1ldGhvZE5hbWUpLCAnY29sb3I6IHRlYWw7IGZvbnQtd2VpZ2h0OiBib2xkOycsICdmb250LXdlaWdodDogYm9sZDsnXS5jb25jYXQoYXJncykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3RUb0RldlRvb2xzKG9wdGlvbnMpIHtcbiAgaWYgKGJhY2tlbmRfaG9vayA9PSBudWxsKSB7XG4gICAgLy8gRGV2VG9vbHMgZGlkbid0IGdldCBpbmplY3RlZCBpbnRvIHRoaXMgcGFnZSAobWF5YmUgYidjIG9mIHRoZSBjb250ZW50VHlwZSkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgX3JlZiRob3N0ID0gX3JlZi5ob3N0LFxuICAgICAgaG9zdCA9IF9yZWYkaG9zdCA9PT0gdm9pZCAwID8gJ2xvY2FsaG9zdCcgOiBfcmVmJGhvc3QsXG4gICAgICBuYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyA9IF9yZWYubmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMsXG4gICAgICBfcmVmJHVzZUh0dHBzID0gX3JlZi51c2VIdHRwcyxcbiAgICAgIHVzZUh0dHBzID0gX3JlZiR1c2VIdHRwcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHVzZUh0dHBzLFxuICAgICAgX3JlZiRwb3J0ID0gX3JlZi5wb3J0LFxuICAgICAgcG9ydCA9IF9yZWYkcG9ydCA9PT0gdm9pZCAwID8gODA5NyA6IF9yZWYkcG9ydCxcbiAgICAgIHdlYnNvY2tldCA9IF9yZWYud2Vic29ja2V0LFxuICAgICAgX3JlZiRyZXNvbHZlUk5TdHlsZSA9IF9yZWYucmVzb2x2ZVJOU3R5bGUsXG4gICAgICByZXNvbHZlUk5TdHlsZSA9IF9yZWYkcmVzb2x2ZVJOU3R5bGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJHJlc29sdmVSTlN0eWxlLFxuICAgICAgX3JlZiRyZXRyeUNvbm5lY3Rpb25EID0gX3JlZi5yZXRyeUNvbm5lY3Rpb25EZWxheSxcbiAgICAgIHJldHJ5Q29ubmVjdGlvbkRlbGF5ID0gX3JlZiRyZXRyeUNvbm5lY3Rpb25EID09PSB2b2lkIDAgPyAyMDAwIDogX3JlZiRyZXRyeUNvbm5lY3Rpb25ELFxuICAgICAgX3JlZiRpc0FwcEFjdGl2ZSA9IF9yZWYuaXNBcHBBY3RpdmUsXG4gICAgICBpc0FwcEFjdGl2ZSA9IF9yZWYkaXNBcHBBY3RpdmUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSA6IF9yZWYkaXNBcHBBY3RpdmUsXG4gICAgICBkZXZUb29sc1NldHRpbmdzTWFuYWdlciA9IF9yZWYuZGV2VG9vbHNTZXR0aW5nc01hbmFnZXI7XG5cbiAgdmFyIHByb3RvY29sID0gdXNlSHR0cHMgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciByZXRyeVRpbWVvdXRJRCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVSZXRyeSgpIHtcbiAgICBpZiAocmV0cnlUaW1lb3V0SUQgPT09IG51bGwpIHtcbiAgICAgIC8vIFR3byBzZWNvbmRzIGJlY2F1c2UgUk4gaGFkIGlzc3VlcyB3aXRoIHF1aWNrIHJldHJpZXMuXG4gICAgICByZXRyeVRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdFRvRGV2VG9vbHMob3B0aW9ucyk7XG4gICAgICB9LCByZXRyeUNvbm5lY3Rpb25EZWxheSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldlRvb2xzU2V0dGluZ3NNYW5hZ2VyICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgaW5pdGlhbGl6ZVVzaW5nQ2FjaGVkU2V0dGluZ3MoZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGNhbGwgYSBtZXRob2Qgb24gZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIgdGhhdCB0aHJvd3MsIG9yIGlmXG4gICAgICAvLyBpcyBpbnZhbGlkIGRhdGEgcmVhZCBvdXQsIGRvbid0IHRocm93IGFuZCBkb24ndCBpbnRlcnJ1cHQgaW5pdGlhbGl6YXRpb25cbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0FwcEFjdGl2ZSgpKSB7XG4gICAgLy8gSWYgdGhlIGFwcCBpcyBpbiBiYWNrZ3JvdW5kLCBtYXliZSByZXRyeSBsYXRlci5cbiAgICAvLyBEb24ndCBhY3R1YWxseSBhdHRlbXB0IHRvIGNvbm5lY3QgdW50aWwgd2UncmUgaW4gZm9yZWdyb3VuZC5cbiAgICBzY2hlZHVsZVJldHJ5KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJyaWRnZSA9IG51bGw7XG4gIHZhciBtZXNzYWdlTGlzdGVuZXJzID0gW107XG4gIHZhciB1cmkgPSBwcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIHBvcnQ7IC8vIElmIGV4aXN0aW5nIHdlYnNvY2tldCBpcyBwYXNzZWQsIHVzZSBpdC5cbiAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydCBvdXIgY3VzdG9tIGludGVncmF0aW9ucy5cbiAgLy8gU2VlIEQ2MjUxNzQ0LlxuXG4gIHZhciB3cyA9IHdlYnNvY2tldCA/IHdlYnNvY2tldCA6IG5ldyB3aW5kb3cuV2ViU29ja2V0KHVyaSk7XG4gIHdzLm9uY2xvc2UgPSBoYW5kbGVDbG9zZTtcbiAgd3Mub25lcnJvciA9IGhhbmRsZUZhaWxlZDtcbiAgd3Mub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTtcblxuICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgYnJpZGdlID0gbmV3IHNyY19icmlkZ2Uoe1xuICAgICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4oZm4pIHtcbiAgICAgICAgbWVzc2FnZUxpc3RlbmVycy5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBtZXNzYWdlTGlzdGVuZXJzLmluZGV4T2YoZm4pO1xuXG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2VMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChldmVudCwgcGF5bG9hZCwgdHJhbnNmZXJhYmxlKSB7XG4gICAgICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOKSB7XG4gICAgICAgICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICAgICAgICBiYWNrZW5kX2RlYnVnKCd3YWxsLnNlbmQoKScsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICAgICAgICBiYWNrZW5kX2RlYnVnKCd3YWxsLnNlbmQoKScsICdTaHV0dGluZyBkb3duIGJyaWRnZSBiZWNhdXNlIG9mIGNsb3NlZCBXZWJTb2NrZXQgY29ubmVjdGlvbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChicmlkZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyaWRnZS5zaHV0ZG93bigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigndXBkYXRlQ29tcG9uZW50RmlsdGVycycsIGZ1bmN0aW9uIChjb21wb25lbnRGaWx0ZXJzKSB7XG4gICAgICAvLyBTYXZlIGZpbHRlciBjaGFuZ2VzIGluIG1lbW9yeSwgaW4gY2FzZSBEZXZUb29scyBpcyByZWxvYWRlZC5cbiAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIHJlbmRlcmVyIHdpbGwgYWxyZWFkeSBiZSB1c2luZyB0aGUgdXBkYXRlZCB2YWx1ZXMuXG4gICAgICAvLyBXZSdsbCBsb3NlIHRoZXNlIGluIGJldHdlZW4gYmFja2VuZCByZWxvYWRzIGJ1dCB0aGF0IGNhbid0IGJlIGhlbHBlZC5cbiAgICAgIHNhdmVkQ29tcG9uZW50RmlsdGVycyA9IGNvbXBvbmVudEZpbHRlcnM7XG4gICAgfSk7XG5cbiAgICBpZiAoZGV2VG9vbHNTZXR0aW5nc01hbmFnZXIgIT0gbnVsbCAmJiBicmlkZ2UgIT0gbnVsbCkge1xuICAgICAgYnJpZGdlLmFkZExpc3RlbmVyKCd1cGRhdGVDb25zb2xlUGF0Y2hTZXR0aW5ncycsIGZ1bmN0aW9uIChjb25zb2xlUGF0Y2hTZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gY2FjaGVDb25zb2xlUGF0Y2hTZXR0aW5ncyhkZXZUb29sc1NldHRpbmdzTWFuYWdlciwgY29uc29sZVBhdGNoU2V0dGluZ3MpO1xuICAgICAgfSk7XG4gICAgfSAvLyBUaGUgcmVuZGVyZXIgaW50ZXJmYWNlIGRvZXNuJ3QgcmVhZCBzYXZlZCBjb21wb25lbnQgZmlsdGVycyBkaXJlY3RseSxcbiAgICAvLyBiZWNhdXNlIHRoZXkgYXJlIGdlbmVyYWxseSBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZXh0ZW5zaW9uLlxuICAgIC8vIEJlY2F1c2Ugb2YgdGhpcyBpdCByZWxpZXMgb24gdGhlIGV4dGVuc2lvbiB0byBwYXNzIGZpbHRlcnMuXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgdGhlIHN0YW5kYWxvbmUgRGV2VG9vbHMgYmVpbmcgdXNlZCB3aXRoIGEgd2Vic2l0ZSxcbiAgICAvLyBzYXZlZCBmaWx0ZXJzIGFyZSBpbmplY3RlZCBhbG9uZyB3aXRoIHRoZSBiYWNrZW5kIHNjcmlwdCB0YWcgc28gd2Ugc2hvdWxkbid0IG92ZXJyaWRlIHRoZW0gaGVyZS5cbiAgICAvLyBUaGlzIGluamVjdGlvbiBzdHJhdGVneSBkb2Vzbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSB0aG91Z2guXG4gICAgLy8gSWRlYWxseSB0aGUgYmFja2VuZCB3b3VsZCBzYXZlIHRoZSBmaWx0ZXJzIGl0c2VsZiwgYnV0IFJOIGRvZXNuJ3QgcHJvdmlkZSBhIHN5bmMgc3RvcmFnZSBzb2x1dGlvbi5cbiAgICAvLyBTbyBmb3Igbm93IHdlIGp1c3QgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBkZWZhdWx0IGZpbHRlcnMuLi5cblxuXG4gICAgaWYgKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTVBPTkVOVF9GSUxURVJTX18gPT0gbnVsbCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBicmlkZ2Uuc2VuZCgnb3ZlcnJpZGVDb21wb25lbnRGaWx0ZXJzJywgc2F2ZWRDb21wb25lbnRGaWx0ZXJzKTtcbiAgICB9IC8vIFRPRE8gKG5wbS1wYWNrYWdlcykgV2FybiBpZiBcImlzQmFja2VuZFN0b3JhZ2VBUElTdXBwb3J0ZWRcIlxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgdmFyIGFnZW50ID0gbmV3IGFnZW50X0FnZW50KGJyaWRnZSk7XG4gICAgYWdlbnQuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSWYgd2UgcmVjZWl2ZWQgJ3NodXRkb3duJyBmcm9tIGBhZ2VudGAsIHdlIGFzc3VtZSB0aGUgYGJyaWRnZWAgaXMgYWxyZWFkeSBzaHV0dGluZyBkb3duLFxuICAgICAgLy8gYW5kIHRoYXQgY2F1c2VkIHRoZSAnc2h1dGRvd24nIGV2ZW50IG9uIHRoZSBgYWdlbnRgLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgYGJyaWRnZS5zaHV0ZG93bigpYCBoZXJlLlxuICAgICAgYmFja2VuZF9ob29rLmVtaXQoJ3NodXRkb3duJyk7XG4gICAgfSk7XG4gICAgaW5pdEJhY2tlbmQoYmFja2VuZF9ob29rLCBhZ2VudCwgd2luZG93KTsgLy8gU2V0dXAgUmVhY3QgTmF0aXZlIHN0eWxlIGVkaXRvciBpZiB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgaXQuXG5cbiAgICBpZiAocmVzb2x2ZVJOU3R5bGUgIT0gbnVsbCB8fCBiYWNrZW5kX2hvb2sucmVzb2x2ZVJOU3R5bGUgIT0gbnVsbCkge1xuICAgICAgc2V0dXBOYXRpdmVTdHlsZUVkaXRvciggLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgYnJpZGdlLCBhZ2VudCwgcmVzb2x2ZVJOU3R5bGUgfHwgYmFja2VuZF9ob29rLnJlc29sdmVSTlN0eWxlLCBuYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyB8fCBiYWNrZW5kX2hvb2submF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMgfHwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBsaXN0ZW4gdG8gZGV0ZWN0IGlmIHRoZSBlbnZpcm9ubWVudCBsYXRlciBzdXBwb3J0cyBpdC5cbiAgICAgIC8vIEZvciBleGFtcGxlLCBGbGlwcGVyIGRvZXMgbm90IGVhZ2VybHkgaW5qZWN0IHRoZXNlIHZhbHVlcy5cbiAgICAgIC8vIEluc3RlYWQgaXQgcmVsaWVzIG9uIHRoZSBSZWFjdCBOYXRpdmUgSW5zcGVjdG9yIHRvIGxhemlseSBpbmplY3QgdGhlbS5cbiAgICAgIHZhciBsYXp5UmVzb2x2ZVJOU3R5bGU7XG4gICAgICB2YXIgbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzO1xuXG4gICAgICB2YXIgaW5pdEFmdGVyVGljayA9IGZ1bmN0aW9uIGluaXRBZnRlclRpY2soKSB7XG4gICAgICAgIGlmIChicmlkZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yKGJyaWRnZSwgYWdlbnQsIGxhenlSZXNvbHZlUk5TdHlsZSwgbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKCFiYWNrZW5kX2hvb2suaGFzT3duUHJvcGVydHkoJ3Jlc29sdmVSTlN0eWxlJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJhY2tlbmRfaG9vaywgJ3Jlc29sdmVSTlN0eWxlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhenlSZXNvbHZlUk5TdHlsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBsYXp5UmVzb2x2ZVJOU3R5bGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGluaXRBZnRlclRpY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJhY2tlbmRfaG9vay5oYXNPd25Qcm9wZXJ0eSgnbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYmFja2VuZF9ob29rLCAnbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIGxhenlOYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyA9IHZhbHVlO1xuICAgICAgICAgICAgaW5pdEFmdGVyVGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsb3NlKCkge1xuICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgYmFja2VuZF9kZWJ1ZygnV2ViU29ja2V0Lm9uY2xvc2UnKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlICE9PSBudWxsKSB7XG4gICAgICBicmlkZ2UuZW1pdCgnc2h1dGRvd24nKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVJldHJ5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVGYWlsZWQoKSB7XG4gICAgaWYgKGNvbnN0YW50c1tcInNcIiAvKiBfX0RFQlVHX18gKi9dKSB7XG4gICAgICBiYWNrZW5kX2RlYnVnKCdXZWJTb2NrZXQub25lcnJvcicpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICB2YXIgZGF0YTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuXG4gICAgICAgIGlmIChjb25zdGFudHNbXCJzXCIgLyogX19ERUJVR19fICovXSkge1xuICAgICAgICAgIGJhY2tlbmRfZGVidWcoJ1dlYlNvY2tldC5vbm1lc3NhZ2UnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbUmVhY3QgRGV2VG9vbHNdIEZhaWxlZCB0byBwYXJzZSBKU09OOiAnICsgZXZlbnQuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVzc2FnZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBqc2MgZG9lc24ndCBwbGF5IHNvIHdlbGwgd2l0aCB0cmFjZWJhY2tzIHRoYXQgZ28gaW50byBldmFsJ2QgY29kZSxcbiAgICAgICAgLy8gc28gdGhlIHN0YWNrIHRyYWNlIGhlcmUgd2lsbCBzdG9wIGF0IHRoZSBgKDAsZXZhbCkoKWAgY2FsbC4gR2V0dGluZyB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgaXMgdGhlIGJlc3Qgd2UgY2FuIGRvIGZvciBub3cuXG4gICAgICAgIGNvbnNvbGUubG9nKCdbUmVhY3QgRGV2VG9vbHNdIEVycm9yIGNhbGxpbmcgbGlzdGVuZXInLCBkYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrZW5kLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmNvbnN0IHtjb25uZWN0VG9EZXZUb29sc30gPSByZXF1aXJlKCdyZWFjdC1kZXZ0b29scy1jb3JlL2JhY2tlbmQnKTtcblxuLy8gQ29ubmVjdCBpbW1lZGlhdGVseSB3aXRoIGRlZmF1bHQgb3B0aW9ucy5cbi8vIElmIHlvdSBuZWVkIG1vcmUgY29udHJvbCwgdXNlIGByZWFjdC1kZXZ0b29scy1jb3JlYCBkaXJlY3RseSBpbnN0ZWFkIG9mIGByZWFjdC1kZXZ0b29sc2AuXG5jb25uZWN0VG9EZXZUb29scygpO1xuIl0sInByZUV4aXN0aW5nQ29tbWVudCI6Ii8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJ9
