LavaPack.loadBundle([
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js", {"./protocol/latticeConstants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cconstants.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PUBLIC = exports.ETH_ABI_LATTICE_FW_TYPE_MAP = exports.MAX_CHAIN_ID_BYTES = exports.HANDLE_LARGER_CHAIN_ID = exports.HARDENED_OFFSET = exports.VERSION_BYTE = exports.REQUEST_TYPE_BYTE = exports.signingSchema = exports.ethMsgProtocol = exports.addressSizes = exports.EXTERNAL_NETWORKS_BY_CHAIN_ID_URL = exports.NETWORKS_BY_CHAIN_ID = exports.MAX_ADDR = exports.CURRENCIES = exports.BASE_URL = exports.BIP_CONSTANTS = exports.getFwVersionConst = exports.ASCII_REGEX = exports.LEDGER_LEGACY_DERIVATION = exports.LEDGER_LIVE_DERIVATION = exports.SOLANA_DERIVATION = exports.BTC_WRAPPED_SEGWIT_DERIVATION = exports.BTC_SEGWIT_DERIVATION = exports.BTC_LEGACY_DERIVATION = exports.DEFAULT_ETH_DERIVATION = exports.DEFAULT_ACTIVE_WALLETS = exports.EMPTY_WALLET_UID = exports.EXTERNAL = void 0;
var latticeConstants_1 = require("./protocol/latticeConstants");
/**
 * Externally exported constants used for building requests
 * @public
 */
exports.EXTERNAL = {
    // Optional flags for `getAddresses`
    GET_ADDR_FLAGS: {
        SECP256K1_PUB: latticeConstants_1.LatticeGetAddressesFlag.secp256k1Pubkey,
        ED25519_PUB: latticeConstants_1.LatticeGetAddressesFlag.ed25519Pubkey,
        BLS12_381_G1_PUB: latticeConstants_1.LatticeGetAddressesFlag.bls12_381Pubkey,
    },
    // Options for building general signing requests
    SIGNING: {
        HASHES: {
            NONE: latticeConstants_1.LatticeSignHash.none,
            KECCAK256: latticeConstants_1.LatticeSignHash.keccak256,
            SHA256: latticeConstants_1.LatticeSignHash.sha256,
        },
        CURVES: {
            SECP256K1: latticeConstants_1.LatticeSignCurve.secp256k1,
            ED25519: latticeConstants_1.LatticeSignCurve.ed25519,
            BLS12_381_G2: latticeConstants_1.LatticeSignCurve.bls12_381,
        },
        ENCODINGS: {
            NONE: latticeConstants_1.LatticeSignEncoding.none,
            SOLANA: latticeConstants_1.LatticeSignEncoding.solana,
            EVM: latticeConstants_1.LatticeSignEncoding.evm,
            ETH_DEPOSIT: latticeConstants_1.LatticeSignEncoding.eth_deposit,
        },
        BLS_DST: {
            BLS_DST_NUL: latticeConstants_1.LatticeSignBlsDst.NUL,
            BLS_DST_POP: latticeConstants_1.LatticeSignBlsDst.POP,
        },
    },
    // Options for exporting encrypted data
    ENC_DATA: {
        SCHEMAS: {
            BLS_KEYSTORE_EIP2335_PBKDF_V4: latticeConstants_1.LatticeEncDataSchema.eip2335,
        },
    },
    ETH_CONSENSUS_SPEC: {
        NETWORKS: {
            MAINNET_GENESIS: {
                networkName: 'mainnet',
                forkVersion: Buffer.alloc(4),
                // Empty root because there were no validators at genesis
                validatorsRoot: Buffer.alloc(32),
            },
        },
        DOMAINS: {
            DEPOSIT: Buffer.from('03000000', 'hex'),
            VOLUNTARY_EXIT: Buffer.from('04000000', 'hex'),
        },
    },
};
exports.PUBLIC = exports.EXTERNAL;
//===============================
// INTERNAL CONSTANTS
//===============================
/** @internal */
var addressSizes = {
    BTC: 20,
    ETH: 20, // 20 byte address not including 0x prefix
};
exports.addressSizes = addressSizes;
/** @internal */
var CURRENCIES = {
    ETH: 'ETH',
    BTC: 'BTC',
    ETH_MSG: 'ETH_MSG',
};
exports.CURRENCIES = CURRENCIES;
/** @internal */
// THIS NEEDS TO BE A PROTOCOL CONSTANT TOO
var signingSchema = {
    BTC_TRANSFER: 0,
    ETH_TRANSFER: 1,
    ERC20_TRANSFER: 2,
    ETH_MSG: 3,
    EXTRA_DATA: 4,
    GENERAL_SIGNING: 5,
};
exports.signingSchema = signingSchema;
/** @internal */
var HARDENED_OFFSET = 0x80000000; // Hardened offset
exports.HARDENED_OFFSET = HARDENED_OFFSET;
/** @internal */
var BIP_CONSTANTS = {
    PURPOSES: {
        ETH: HARDENED_OFFSET + 44,
        BTC_LEGACY: HARDENED_OFFSET + 44,
        BTC_WRAPPED_SEGWIT: HARDENED_OFFSET + 49,
        BTC_SEGWIT: HARDENED_OFFSET + 84,
    },
    COINS: {
        ETH: HARDENED_OFFSET + 60,
        BTC: HARDENED_OFFSET,
        BTC_TESTNET: HARDENED_OFFSET + 1,
    },
};
exports.BIP_CONSTANTS = BIP_CONSTANTS;
/** @internal For all HSM-bound requests */
var REQUEST_TYPE_BYTE = 0x02;
exports.REQUEST_TYPE_BYTE = REQUEST_TYPE_BYTE;
/** @internal */
var VERSION_BYTE = 1;
exports.VERSION_BYTE = VERSION_BYTE;
/** @internal ChainId value to signify larger chainID is in data buffer */
var HANDLE_LARGER_CHAIN_ID = 255;
exports.HANDLE_LARGER_CHAIN_ID = HANDLE_LARGER_CHAIN_ID;
/** @internal Max number of bytes to contain larger chainID in data buffer */
var MAX_CHAIN_ID_BYTES = 8;
exports.MAX_CHAIN_ID_BYTES = MAX_CHAIN_ID_BYTES;
/** @internal */
var BASE_URL = 'https://signing.gridpl.us';
exports.BASE_URL = BASE_URL;
/** @internal */
var EIP712_ABI_LATTICE_FW_TYPE_MAP = {
    address: 1,
    bool: 2,
    uint8: 3,
    uint16: 4,
    uint24: 5,
    uint32: 6,
    uint40: 7,
    uint48: 8,
    uint56: 9,
    uint64: 10,
    uint72: 11,
    uint80: 12,
    uint88: 13,
    uint96: 14,
    uint104: 15,
    uint112: 16,
    uint120: 17,
    uint128: 18,
    uint136: 19,
    uint144: 20,
    uint152: 21,
    uint160: 22,
    uint168: 23,
    uint176: 24,
    uint184: 25,
    uint192: 26,
    uint200: 27,
    uint208: 28,
    uint216: 29,
    uint224: 30,
    uint232: 31,
    uint240: 32,
    uint248: 33,
    uint256: 34,
    int8: 35,
    int16: 36,
    int24: 37,
    int32: 38,
    int40: 39,
    int48: 40,
    int56: 41,
    int64: 42,
    int72: 43,
    int80: 44,
    int88: 45,
    int96: 46,
    int104: 47,
    int112: 48,
    int120: 49,
    int128: 50,
    int136: 51,
    int144: 52,
    int152: 53,
    int160: 54,
    int168: 55,
    int176: 56,
    int184: 57,
    int192: 58,
    int200: 59,
    int208: 60,
    int216: 61,
    int224: 62,
    int232: 63,
    int240: 64,
    int248: 65,
    int256: 66,
    uint: 67,
    bytes1: 69,
    bytes2: 70,
    bytes3: 71,
    bytes4: 72,
    bytes5: 73,
    bytes6: 74,
    bytes7: 75,
    bytes8: 76,
    bytes9: 77,
    bytes10: 78,
    bytes11: 79,
    bytes12: 80,
    bytes13: 81,
    bytes14: 82,
    bytes15: 83,
    bytes16: 84,
    bytes17: 85,
    bytes18: 86,
    bytes19: 87,
    bytes20: 88,
    bytes21: 89,
    bytes22: 90,
    bytes23: 91,
    bytes24: 92,
    bytes25: 93,
    bytes26: 94,
    bytes27: 95,
    bytes28: 96,
    bytes29: 97,
    bytes30: 98,
    bytes31: 99,
    bytes32: 100,
    bytes: 101,
    string: 102,
};
/** @internal */
var ETH_ABI_LATTICE_FW_TYPE_MAP = __assign(__assign({}, EIP712_ABI_LATTICE_FW_TYPE_MAP), { tuple1: 103, tuple2: 104, tuple3: 105, tuple4: 106, tuple5: 107, tuple6: 108, tuple7: 109, tuple8: 110, tuple9: 111, tuple10: 112, tuple11: 113, tuple12: 114, tuple13: 115, tuple14: 116, tuple15: 117, tuple16: 118, tuple17: 119 });
exports.ETH_ABI_LATTICE_FW_TYPE_MAP = ETH_ABI_LATTICE_FW_TYPE_MAP;
/** @internal */
var ethMsgProtocol = {
    SIGN_PERSONAL: {
        str: 'signPersonal',
        enumIdx: 0, // Enum index of this protocol in Lattice firmware
    },
    TYPED_DATA: {
        str: 'typedData',
        enumIdx: 1,
        rawDataMaxLen: 1629,
        typeCodes: EIP712_ABI_LATTICE_FW_TYPE_MAP, // Enum indices of data types in Lattice firmware
    },
};
exports.ethMsgProtocol = ethMsgProtocol;
/** @internal */
function getFwVersionConst(v) {
    var c = {
        extraDataFrameSz: 0,
        extraDataMaxFrames: 0,
        genericSigning: {},
    };
    function gte(v, exp) {
        // Note that `v` fields come in as [fix|minor|major]
        return (v[2] > exp[0] ||
            (v[2] === exp[0] && v[1] > exp[1]) ||
            (v[2] === exp[0] && v[1] === exp[1] && v[0] > exp[2]) ||
            (v[2] === exp[0] && v[1] === exp[1] && v[0] === exp[2]));
    }
    // Very old legacy versions do not give a version number
    var legacy = v.length === 0;
    // BASE FIELDS
    //--------------------------------------
    // Various size constants have changed on the firmware side over time and
    // are captured here
    if (!legacy && gte(v, [0, 10, 4])) {
        // >=0.10.3
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    }
    else if (!legacy && gte(v, [0, 10, 0])) {
        // >=0.10.0
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    }
    else {
        // Legacy or <0.10.0
        c.reqMaxDataSz = 1152;
        c.ethMaxGasPrice = 500000000000; // 500 gwei
        c.addrFlagsAllowed = false;
    }
    // These transformations apply to all versions. The subtraction
    // of 128 bytes accounts for metadata and is for legacy reasons.
    // For all modern versions, these are 1550 bytes.
    // NOTE: Non-legacy ETH txs (e.g. EIP1559) will shrink
    // this number.
    // See `ETH_BASE_TX_MAX_DATA_SZ` and `ETH_MAX_BASE_MSG_SZ` in firmware
    c.ethMaxDataSz = c.reqMaxDataSz - 128;
    c.ethMaxMsgSz = c.ethMaxDataSz;
    // Max number of params in an EIP712 type. This was added to firmware
    // to avoid blowing stack size.
    c.eip712MaxTypeParams = 18;
    // -----
    // EXTRA FIELDS ADDED IN LATER FIRMWARE VERSIONS
    // -----
    // --- V0.10.X ---
    // V0.10.4 introduced the ability to send signing requests over multiple
    // data frames (i.e. in multiple requests)
    if (!legacy && gte(v, [0, 10, 4])) {
        c.extraDataFrameSz = 1500; // 1500 bytes per frame of extraData allowed
        c.extraDataMaxFrames = 1; // 1 frame of extraData allowed
    }
    // V0.10.5 added the ability to use flexible address path sizes, which
    // changes the `getAddress` API. It also added support for EIP712
    if (!legacy && gte(v, [0, 10, 5])) {
        c.varAddrPathSzAllowed = true;
        c.eip712Supported = true;
    }
    // V0.10.8 allows a user to sign a prehashed transaction if the payload
    // is too big
    if (!legacy && gte(v, [0, 10, 8])) {
        c.prehashAllowed = true;
    }
    // V0.10.10 allows a user to sign a prehashed ETH message if payload too big
    if (!legacy && gte(v, [0, 10, 10])) {
        c.ethMsgPreHashAllowed = true;
    }
    // --- 0.11.X ---
    // V0.11.0 allows new ETH transaction types
    if (!legacy && gte(v, [0, 11, 0])) {
        c.allowedEthTxTypes = [
            1,
            2, // eip1559
        ];
        // This version added extra data fields to the ETH tx
        c.ethMaxDataSz -= 10;
        c.ethMaxMsgSz = c.ethMaxDataSz;
    }
    // V0.11.2 changed how messages are displayed. For personal_sign messages
    // we now write the header (`Signer: <path>`) into the main body of the screen.
    // This means personal sign message max size is slightly smaller than for
    // EIP712 messages because in the latter case there is no header
    // Note that `<path>` has max size of 62 bytes (`m/X/X/...`)
    if (!legacy && gte(v, [0, 11, 2])) {
        c.personalSignHeaderSz = 72;
    }
    // --- V0.12.X ---
    // V0.12.0 added an API for creating, removing, and fetching key-val file
    // records. For the purposes of this SDK, we only hook into one type of kv
    // file: address names.
    if (!legacy && gte(v, [0, 12, 0])) {
        c.kvActionsAllowed = true;
        c.kvKeyMaxStrSz = 63;
        c.kvValMaxStrSz = 63;
        c.kvActionMaxNum = 10;
        c.kvRemoveMaxNum = 100;
    }
    // --- V0.13.X ---
    // V0.13.0 added native segwit addresses and fixed a bug in exporting
    // legacy bitcoin addresses
    if (!legacy && gte(v, [0, 13, 0])) {
        c.allowBtcLegacyAndSegwitAddrs = true;
        // Random address to be used when trying to deploy a contract
        c.contractDeployKey = '0x08002e0fec8e6acf00835f43c9764f7364fa3f42';
    }
    // --- V0.14.X ---
    // V0.14.0 added support for a more robust API around ABI definitions
    // and generic signing functionality
    if (!legacy && gte(v, [0, 14, 0])) {
        // Size of `category` buffer. Inclusive of null terminator byte.
        c.abiCategorySz = 32;
        c.abiMaxRmv = 200; // Max number of ABI defs that can be removed with
        // a single request
        // See `sizeof(GenericSigningRequest_t)` in firmware
        c.genericSigning.baseReqSz = 1552;
        // See `GENERIC_SIGNING_BASE_MSG_SZ` in firmware
        c.genericSigning.baseDataSz = 1519;
        c.genericSigning.hashTypes = exports.EXTERNAL.SIGNING.HASHES;
        c.genericSigning.curveTypes = exports.EXTERNAL.SIGNING.CURVES;
        c.genericSigning.encodingTypes = {
            NONE: exports.EXTERNAL.SIGNING.ENCODINGS.NONE,
            SOLANA: exports.EXTERNAL.SIGNING.ENCODINGS.SOLANA,
        };
        // Supported flags for `getAddresses`
        c.getAddressFlags = [
            exports.EXTERNAL.GET_ADDR_FLAGS.ED25519_PUB,
            exports.EXTERNAL.GET_ADDR_FLAGS.SECP256K1_PUB,
        ];
        // We updated the max number of params in EIP712 types
        c.eip712MaxTypeParams = 36;
    }
    // DEPRECATED
    // V0.14.1 Added the Terra decoder
    // if (!legacy && gte(v, [0, 14, 1])) {
    //   c.genericSigning.encodingTypes.TERRA = EXTERNAL.SIGNING.ENCODINGS.TERRA;
    // }
    // --- V0.15.X ---
    // V0.15.0 added an EVM decoder and removed the legacy ETH signing pathway
    if (!legacy && gte(v, [0, 15, 0])) {
        c.genericSigning.encodingTypes.EVM = exports.EXTERNAL.SIGNING.ENCODINGS.EVM;
        // We now use the general signing data field as the base
        // Note that we have NOT removed the ETH_MSG type so we should
        // not change ethMaxMsgSz
        c.ethMaxDataSz = 1550 - 31;
        // Max buffer size for get/add decoder requests
        c.maxDecoderBufSz = 1600;
        // Code used to write a calldata decoder
        c.genericSigning.calldataDecoding = {
            reserved: 2895728,
            maxSz: 1024,
        };
    }
    // --- V0.17.X ---
    // V0.17.0 added support for BLS12-381-G1 pubkeys and G2 sigs
    if (!legacy && gte(v, [0, 17, 0])) {
        c.getAddressFlags.push(exports.EXTERNAL.GET_ADDR_FLAGS.BLS12_381_G1_PUB);
        c.genericSigning.encodingTypes.ETH_DEPOSIT = exports.EXTERNAL.SIGNING.ENCODINGS.ETH_DEPOSIT;
    }
    return c;
}
exports.getFwVersionConst = getFwVersionConst;
/** @internal */
// eslint-disable-next-line no-control-regex
var ASCII_REGEX = /^[\x00-\x7F]+$/;
exports.ASCII_REGEX = ASCII_REGEX;
/** @internal */
var EXTERNAL_NETWORKS_BY_CHAIN_ID_URL = 'https://gridplus.github.io/chains/chains.json';
exports.EXTERNAL_NETWORKS_BY_CHAIN_ID_URL = EXTERNAL_NETWORKS_BY_CHAIN_ID_URL;
/** @internal - Max number of addresses to fetch */
var MAX_ADDR = 10;
exports.MAX_ADDR = MAX_ADDR;
/** @internal */
var NETWORKS_BY_CHAIN_ID = {
    1: {
        name: 'ethereum',
        baseUrl: 'https://api.etherscan.io',
        apiRoute: 'api?module=contract&action=getabi',
    },
    137: {
        name: 'polygon',
        baseUrl: 'https://api.polygonscan.com',
        apiRoute: 'api?module=contract&action=getabi',
    },
    56: {
        name: 'binance',
        baseUrl: 'https://api.bscscan.com',
        apiRoute: 'api?module=contract&action=getabi',
    },
    42220: {
        name: 'celo',
        baseUrl: 'https://api.celoscan.io',
        apiRoute: 'api?module=contract&action=getabi',
    },
    43114: {
        name: 'avalanche',
        baseUrl: 'https://api.snowtrace.io',
        apiRoute: 'api?module=contract&action=getabi',
    },
};
exports.NETWORKS_BY_CHAIN_ID = NETWORKS_BY_CHAIN_ID;
/** @internal */
exports.EMPTY_WALLET_UID = Buffer.alloc(32);
/** @internal */
exports.DEFAULT_ACTIVE_WALLETS = {
    internal: {
        uid: exports.EMPTY_WALLET_UID,
        external: false,
        name: Buffer.alloc(0),
        capabilities: 0,
    },
    external: {
        uid: exports.EMPTY_WALLET_UID,
        external: true,
        name: Buffer.alloc(0),
        capabilities: 0,
    },
};
/** @internal */
exports.DEFAULT_ETH_DERIVATION = [
    HARDENED_OFFSET + 44,
    HARDENED_OFFSET + 60,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.BTC_LEGACY_DERIVATION = [
    HARDENED_OFFSET + 44,
    HARDENED_OFFSET + 0,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.BTC_SEGWIT_DERIVATION = [
    HARDENED_OFFSET + 84,
    HARDENED_OFFSET,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.BTC_WRAPPED_SEGWIT_DERIVATION = [
    HARDENED_OFFSET + 49,
    HARDENED_OFFSET,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.SOLANA_DERIVATION = [
    HARDENED_OFFSET + 44,
    HARDENED_OFFSET + 501,
    HARDENED_OFFSET,
];
/** @internal */
exports.LEDGER_LIVE_DERIVATION = [
    HARDENED_OFFSET + 49,
    HARDENED_OFFSET + 60,
    HARDENED_OFFSET,
    0,
    0,
];
/** @internal */
exports.LEDGER_LEGACY_DERIVATION = [
    HARDENED_OFFSET + 49,
    HARDENED_OFFSET + 60,
    HARDENED_OFFSET,
    0,
];

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\constants.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\ethereum.js", {"./constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","@ethereumjs/common":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\index.js","@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\index.js","bignumber.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js","borc":"F:\\metamask-extension\\node_modules\\borc\\src\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-eip712-util-browser":"F:\\metamask-extension\\node_modules\\eth-eip712-util-browser\\index.js","js-sha3":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js","rlp":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\rlp\\dist\\index.js","secp256k1":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cethereum.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which
// does not have browser (or, by proxy, React-Native) support.
var common_1 = require("@ethereumjs/common");
var tx_1 = require("@ethereumjs/tx");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var borc_1 = __importDefault(require("borc"));
//@ts-expect-error - This third-party package is not typed properly
var eth_eip712_util_browser_1 = require("eth-eip712-util-browser");
var js_sha3_1 = require("js-sha3");
var rlp_1 = require("rlp");
var secp256k1_1 = __importDefault(require("secp256k1"));
var constants_1 = require("./constants");
var protocol_1 = require("./protocol");
var util_1 = require("./util");
var buildEthereumMsgRequest = function (input) {
    if (!input.payload || !input.protocol || !input.signerPath)
        throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');
    if (input.signerPath.length > 5 || input.signerPath.length < 2)
        throw new Error('Please provide a signer path with 2-5 indices');
    var req = {
        schema: protocol_1.LatticeSignSchema.ethereumMsg,
        payload: null,
        input: input,
        msg: null, // Save the buffered message for later
    };
    switch (input.protocol) {
        case 'signPersonal':
            return buildPersonalSignRequest(req, input);
        case 'eip712':
            if (!input.fwConstants.eip712Supported)
                throw new Error('EIP712 is not supported by your Lattice firmware version. Please upgrade.');
            return buildEIP712Request(req, input);
        default:
            throw new Error('Unsupported protocol');
    }
};
var validateEthereumMsgResponse = function (res, req) {
    var signer = res.signer, sig = res.sig;
    var input = req.input, msg = req.msg, _a = req.prehash, prehash = _a === void 0 ? null : _a;
    if (input.protocol === 'signPersonal') {
        // NOTE: We are currently hardcoding networkID=1 and useEIP155=false but these
        //       may be configurable in future versions
        var hash_1 = prehash
            ? prehash
            : Buffer.from((0, js_sha3_1.keccak256)(Buffer.concat([get_personal_sign_prefix(msg.length), msg])), 'hex');
        // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
        return addRecoveryParam(hash_1, sig, signer, {
            chainId: 1,
            useEIP155: false,
        });
    }
    else if (input.protocol === 'eip712') {
        var encoded = eth_eip712_util_browser_1.TypedDataUtils.hash(req.input.payload);
        var digest = prehash ? prehash : encoded;
        // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
        return addRecoveryParam(digest, sig, signer, { useEIP155: false });
    }
    else {
        throw new Error('Unsupported protocol');
    }
};
var buildEthereumTxRequest = function (data) {
    try {
        var _a = data.chainId, chainId = _a === void 0 ? 1 : _a;
        var signerPath = data.signerPath, _b = data.eip155, eip155 = _b === void 0 ? null : _b, fwConstants = data.fwConstants, _c = data.type, type = _c === void 0 ? null : _c;
        var contractDeployKey = fwConstants.contractDeployKey, extraDataFrameSz = fwConstants.extraDataFrameSz, extraDataMaxFrames = fwConstants.extraDataMaxFrames, prehashAllowed = fwConstants.prehashAllowed;
        var EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
        var MAX_BASE_DATA_SZ = fwConstants.ethMaxDataSz;
        var VAR_PATH_SZ = fwConstants.varAddrPathSzAllowed;
        // Sanity checks:
        // There are a handful of named chains we allow the user to reference (`chainIds`)
        // Custom chainIDs should be either numerical or hex strings
        if (typeof chainId !== 'number' &&
            isValidChainIdHexNumStr(chainId) === false) {
            chainId = chainIds[chainId];
        }
        // If this was not a custom chainID and we cannot find the name of it, exit
        if (!chainId)
            throw new Error('Unsupported chain ID or name');
        // Sanity check on signePath
        if (!signerPath)
            throw new Error('`signerPath` not provided');
        // Is this a contract deployment?
        if (data.to === null && !contractDeployKey) {
            throw new Error('Contract deployment not supported. Please update your Lattice firmware.');
        }
        var isDeployment = data.to === null && contractDeployKey;
        // We support eip1559 and eip2930 types (as well as legacy)
        var eip1559IsAllowed = fwConstants.allowedEthTxTypes &&
            fwConstants.allowedEthTxTypes.indexOf(2) > -1;
        var eip2930IsAllowed = fwConstants.allowedEthTxTypes &&
            fwConstants.allowedEthTxTypes.indexOf(1) > -1;
        var isEip1559 = eip1559IsAllowed && (type === 2 || type === 'eip1559');
        var isEip2930 = eip2930IsAllowed && (type === 1 || type === 'eip2930');
        if (type !== null && !isEip1559 && !isEip2930)
            throw new Error('Unsupported Ethereum transaction type');
        // Determine if we should use EIP155 given the chainID.
        // If we are explicitly told to use eip155, we will use it. Otherwise,
        // we will look up if the specified chainId is associated with a chain
        // that does not use EIP155 by default. Note that most do use EIP155.
        var useEIP155 = chainUsesEIP155(chainId);
        if (eip155 !== null && typeof eip155 === 'boolean') {
            useEIP155 = eip155;
        }
        else if (isEip1559 || isEip2930) {
            // Newer transaction types do not use EIP155 since the chainId is serialized
            useEIP155 = false;
        }
        // Hack for metamask, which sends value=null for 0 ETH transactions
        if (!data.value)
            data.value = 0;
        //--------------
        // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING
        //--------------
        // Ensure all fields are 0x-prefixed hex strings
        var rawTx = [];
        // Build the transaction buffer array
        var chainIdBytes = (0, util_1.ensureHexBuffer)(chainId);
        var nonceBytes = (0, util_1.ensureHexBuffer)(data.nonce);
        var gasPriceBytes = void 0;
        var gasLimitBytes = (0, util_1.ensureHexBuffer)(data.gasLimit);
        // Handle contract deployment (indicated by `to` being `null`)
        // For contract deployment we write a 20-byte key to the request
        // buffer, which gets swapped for an empty buffer in firmware.
        var toRlpElem = void 0, toBytes = void 0;
        if (isDeployment) {
            toRlpElem = Buffer.alloc(0);
            toBytes = (0, util_1.ensureHexBuffer)(contractDeployKey);
        }
        else {
            toRlpElem = (0, util_1.ensureHexBuffer)(data.to);
            toBytes = (0, util_1.ensureHexBuffer)(data.to);
        }
        var valueBytes = (0, util_1.ensureHexBuffer)(data.value);
        var dataBytes = (0, util_1.ensureHexBuffer)(data.data);
        if (isEip1559 || isEip2930) {
            // EIP1559 and EIP2930 transactions have a chainID field
            rawTx.push(chainIdBytes);
        }
        rawTx.push(nonceBytes);
        var maxPriorityFeePerGasBytes = void 0, maxFeePerGasBytes = void 0;
        if (isEip1559) {
            if (!data.maxPriorityFeePerGas)
                throw new Error('EIP1559 transactions must include `maxPriorityFeePerGas`');
            maxPriorityFeePerGasBytes = (0, util_1.ensureHexBuffer)(data.maxPriorityFeePerGas);
            rawTx.push(maxPriorityFeePerGasBytes);
            maxFeePerGasBytes = (0, util_1.ensureHexBuffer)(data.maxFeePerGas);
            rawTx.push(maxFeePerGasBytes);
            // EIP1559 renamed "gasPrice" to "maxFeePerGas", but firmware still
            // uses `gasPrice` in the struct, so update that value here.
            gasPriceBytes = maxFeePerGasBytes;
        }
        else {
            // EIP1559 transactions do not have the gasPrice field
            gasPriceBytes = (0, util_1.ensureHexBuffer)(data.gasPrice);
            rawTx.push(gasPriceBytes);
        }
        rawTx.push(gasLimitBytes);
        rawTx.push(toRlpElem);
        rawTx.push(valueBytes);
        rawTx.push(dataBytes);
        // We do not currently support accessList in firmware so we need to prehash if
        // the list is non-null
        var PREHASH_FROM_ACCESS_LIST_1 = false;
        if (isEip1559 || isEip2930) {
            var accessList_1 = [];
            if (Array.isArray(data.accessList)) {
                data.accessList.forEach(function (listItem) {
                    var keys = [];
                    listItem.storageKeys.forEach(function (key) {
                        keys.push((0, util_1.ensureHexBuffer)(key));
                    });
                    accessList_1.push([(0, util_1.ensureHexBuffer)(listItem.address), keys]);
                    PREHASH_FROM_ACCESS_LIST_1 = true;
                });
            }
            rawTx.push(accessList_1);
        }
        else if (useEIP155 === true) {
            // Add empty v,r,s values for EIP155 legacy transactions
            rawTx.push(chainIdBytes); // v (which is the same as chainId in EIP155 txs)
            rawTx.push((0, util_1.ensureHexBuffer)(null)); // r
            rawTx.push((0, util_1.ensureHexBuffer)(null)); // s
        }
        //--------------
        // 2. BUILD THE LATTICE REQUEST PAYLOAD
        //--------------
        var ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params
        var txReqPayload = Buffer.alloc(MAX_BASE_DATA_SZ + ETH_TX_NON_DATA_SZ);
        var off = 0;
        // 1. EIP155 switch and chainID
        //------------------
        txReqPayload.writeUInt8(Number(useEIP155), off);
        off++;
        // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger
        // chainID values. To account for these, we will put the chainID into the `data` buffer if it
        // is >=255. Values up to UINT64_MAX will be allowed.
        var chainIdBuf = void 0;
        var chainIdBufSz = 0;
        if (useChainIdBuffer(chainId) === true) {
            chainIdBuf = getChainIdBuf(chainId);
            chainIdBufSz = chainIdBuf.length;
            if (chainIdBufSz > constants_1.MAX_CHAIN_ID_BYTES)
                throw new Error('ChainID provided is too large.');
            // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer
            txReqPayload.writeUInt8(constants_1.HANDLE_LARGER_CHAIN_ID, off);
            off++;
        }
        else {
            // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer
            chainIdBuf = (0, util_1.ensureHexBuffer)(chainId);
            if (chainIdBuf.length !== 1)
                throw new Error('Error parsing chainID');
            chainIdBuf.copy(txReqPayload, off);
            off += chainIdBuf.length;
        }
        // 2. Signer Path
        //------------------
        var signerPathBuf = (0, util_1.buildSignerPathBuf)(signerPath, VAR_PATH_SZ);
        signerPathBuf.copy(txReqPayload, off);
        off += signerPathBuf.length;
        // 3. ETH TX request data
        //------------------
        if (nonceBytes.length > 4)
            throw new Error('Nonce too large');
        nonceBytes.copy(txReqPayload, off + (4 - nonceBytes.length));
        off += 4;
        if (gasPriceBytes.length > 8)
            throw new Error('Gas price too large');
        gasPriceBytes.copy(txReqPayload, off + (8 - gasPriceBytes.length));
        off += 8;
        if (gasLimitBytes.length > 4)
            throw new Error('Gas limit too large');
        gasLimitBytes.copy(txReqPayload, off + (4 - gasLimitBytes.length));
        off += 4;
        if (toBytes.length !== 20)
            throw new Error('Invalid `to` address');
        toBytes.copy(txReqPayload, off);
        off += 20;
        if (valueBytes.length > 32)
            throw new Error('Value too large');
        valueBytes.copy(txReqPayload, off + (32 - valueBytes.length));
        off += 32;
        // Extra Tx data comes before `data` in the struct
        var PREHASH_UNSUPPORTED = false;
        if (fwConstants.allowedEthTxTypes) {
            // Some types may not be supported by firmware, so we will need to prehash
            if (PREHASH_FROM_ACCESS_LIST_1) {
                PREHASH_UNSUPPORTED = true;
            }
            txReqPayload.writeUInt8(PREHASH_UNSUPPORTED ? 1 : 0, off);
            off += 1;
            // EIP1559 & EIP2930 struct version
            if (isEip1559) {
                txReqPayload.writeUInt8(2, off);
                off += 1; // Eip1559 type enum value
                if (maxPriorityFeePerGasBytes.length > 8)
                    throw new Error('maxPriorityFeePerGasBytes too large');
                maxPriorityFeePerGasBytes.copy(txReqPayload, off + (8 - maxPriorityFeePerGasBytes.length));
                off += 8; // Skip EIP1559 params
            }
            else if (isEip2930) {
                txReqPayload.writeUInt8(1, off);
                off += 1; // Eip2930 type enum value
                off += 8; // Skip EIP1559 params
            }
            else {
                off += 9; // Skip EIP1559 and EIP2930 params
            }
        }
        // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable
        var extraDataPayloads_1 = [];
        var prehash = null;
        // Create the buffer, prefix with chainId (if needed) and add data slice
        var dataSz = dataBytes.length || 0;
        var chainIdExtraSz = chainIdBufSz > 0 ? chainIdBufSz + 1 : 0;
        var dataToCopy = Buffer.alloc(dataSz + chainIdExtraSz);
        if (chainIdExtraSz > 0) {
            dataToCopy.writeUInt8(chainIdBufSz, 0);
            chainIdBuf.copy(dataToCopy, 1);
        }
        dataBytes.copy(dataToCopy, chainIdExtraSz);
        if (dataSz > MAX_BASE_DATA_SZ) {
            // Determine sizes and run through sanity checks
            var totalSz = dataSz + chainIdExtraSz;
            var maxSzAllowed = MAX_BASE_DATA_SZ + extraDataMaxFrames * extraDataFrameSz;
            if (prehashAllowed && totalSz > maxSzAllowed) {
                // If this payload is too large to send, but the Lattice allows a prehashed message, do that
                prehash = Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(rawTx, type)), 'hex');
            }
            else {
                if (!EXTRA_DATA_ALLOWED ||
                    (EXTRA_DATA_ALLOWED && totalSz > maxSzAllowed))
                    throw new Error("Data field too large (got ".concat(dataBytes.length, "; must be <=").concat(maxSzAllowed - chainIdExtraSz, " bytes)"));
                // Split overflow data into extraData frames
                var frames_1 = (0, util_1.splitFrames)(dataToCopy.slice(MAX_BASE_DATA_SZ), extraDataFrameSz);
                frames_1.forEach(function (frame) {
                    var szLE = Buffer.alloc(4);
                    szLE.writeUInt32LE(frame.length, 0);
                    extraDataPayloads_1.push(Buffer.concat([szLE, frame]));
                });
            }
        }
        else if (PREHASH_UNSUPPORTED) {
            // If something is unsupported in firmware but we want to allow such transactions,
            // we prehash the message here.
            prehash = Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(rawTx, type)), 'hex');
        }
        // Write the data size (does *NOT* include the chainId buffer, if that exists)
        txReqPayload.writeUInt16BE(dataBytes.length, off);
        off += 2;
        // Copy in the chainId buffer if needed
        if (chainIdBufSz > 0) {
            txReqPayload.writeUInt8(chainIdBufSz, off);
            off++;
            chainIdBuf.copy(txReqPayload, off);
            off += chainIdBufSz;
        }
        // Copy the first slice of the data itself. If this payload has been pre-hashed, include it
        // in the `data` field. This will result in a different Lattice screen being drawn.
        if (prehash) {
            prehash.copy(txReqPayload, off);
            off += MAX_BASE_DATA_SZ;
        }
        else {
            dataBytes.slice(0, MAX_BASE_DATA_SZ).copy(txReqPayload, off);
            off += MAX_BASE_DATA_SZ;
        }
        return {
            rawTx: rawTx,
            type: type,
            payload: txReqPayload.slice(0, off),
            extraDataPayloads: extraDataPayloads_1,
            schema: protocol_1.LatticeSignSchema.ethereum,
            chainId: chainId,
            useEIP155: useEIP155,
            signerPath: signerPath,
        };
    }
    catch (err) {
        return { err: err.message };
    }
};
// From ethereumjs-util
function stripZeros(a) {
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
}
// Given a 64-byte signature [r,s] we need to figure out the v value
// and attah the full signature to the end of the transaction payload
var buildEthRawTx = function (tx, sig, address) {
    // RLP-encode the data we sent to the lattice
    var hash = Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(tx.rawTx, tx.type)), 'hex');
    var newSig = addRecoveryParam(hash, sig, address, tx);
    // Use the signature to generate a new raw transaction payload
    // Strip the last 3 items and replace them with signature components
    var newRawTx = tx.useEIP155 ? tx.rawTx.slice(0, -3) : tx.rawTx;
    newRawTx.push(newSig.v);
    // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros
    // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187
    newRawTx.push(stripZeros(newSig.r));
    newRawTx.push(stripZeros(newSig.s));
    var rlpEncodedWithSig = Buffer.from((0, rlp_1.encode)(newRawTx));
    if (tx.type) {
        rlpEncodedWithSig = Buffer.concat([
            Buffer.from([tx.type]),
            rlpEncodedWithSig,
        ]);
    }
    return { rawTx: rlpEncodedWithSig.toString('hex'), sigWithV: newSig };
};
// Attach a recovery parameter to a signature by brute-forcing ECRecover
function addRecoveryParam(hashBuf, sig, address, txData) {
    if (txData === void 0) { txData = {}; }
    try {
        // Rebuild the keccak256 hash here so we can `ecrecover`
        var hash_2 = new Uint8Array(hashBuf);
        var v = 0;
        // Fix signature componenet lengths to 32 bytes each
        var r = (0, util_1.fixLen)(sig.r, 32);
        sig.r = r;
        var s = (0, util_1.fixLen)(sig.s, 32);
        sig.s = s;
        // Calculate the recovery param
        var rs = new Uint8Array(Buffer.concat([r, s]));
        var pubkey = secp256k1_1.default.ecdsaRecover(rs, v, hash_2, false).slice(1);
        // If the first `v` value is a match, return the sig!
        if (pubToAddrStr(pubkey) === address.toString('hex')) {
            sig.v = getRecoveryParam(v, txData);
            return sig;
        }
        // Otherwise, try the other `v` value
        v = 1;
        pubkey = secp256k1_1.default.ecdsaRecover(rs, v, hash_2, false).slice(1);
        if (pubToAddrStr(pubkey) === address.toString('hex')) {
            sig.v = getRecoveryParam(v, txData);
            return sig;
        }
        else {
            // If neither is a match, we should return an error
            throw new Error('Invalid Ethereum signature returned.');
        }
    }
    catch (err) {
        throw new Error(err);
    }
}
// Convert an RLP-serialized transaction (plus signature) into a transaction hash
var hashTransaction = function (serializedTx) {
    return (0, js_sha3_1.keccak256)(Buffer.from(serializedTx, 'hex'));
};
// Returns address string given public key buffer
function pubToAddrStr(pub) {
    return (0, js_sha3_1.keccak256)(pub).slice(-40);
}
// Convert a 0/1 `v` into a recovery param:
// * For non-EIP155 transactions, return `27 + v`
// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`
function getRecoveryParam(v, txData) {
    if (txData === void 0) { txData = {}; }
    var chainId = txData.chainId, useEIP155 = txData.useEIP155, type = txData.type;
    // For EIP1559 and EIP2930 transactions, we want the recoveryParam (0 or 1)
    // rather than the `v` value because the `chainId` is already included in the
    // transaction payload.
    if (type === 1 || type === 2) {
        return (0, util_1.ensureHexBuffer)(v, true); // 0 or 1, with 0 expected as an empty buffer
    }
    else if (false === useEIP155 || chainId === null) {
        // For ETH messages and non-EIP155 chains the set should be [27, 28] for `v`
        return Buffer.from(new bignumber_js_1.default(v).plus(27).toString(16), 'hex');
    }
    // We will use EIP155 in most cases. Convert v to a bignum and operate on it.
    // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36
    // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1
    // so we add 35 to that.
    var chainIdBuf = getChainIdBuf(chainId);
    var chainIdBN = new bignumber_js_1.default(chainIdBuf.toString('hex'), 16);
    return (0, util_1.ensureHexBuffer)("0x".concat(chainIdBN.times(2).plus(35).plus(v).toString(16)));
}
var chainIds = {
    mainnet: 1,
    roptsten: 3,
    rinkeby: 4,
    kovan: 42,
    goerli: 5,
};
// Get a buffer containing the chainId value.
// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian
function getChainIdBuf(chainId) {
    var b;
    // If our chainID is a hex string, we can convert it to a hex
    // buffer directly
    if (true === isValidChainIdHexNumStr(chainId))
        b = (0, util_1.ensureHexBuffer)(chainId);
    // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer
    else
        b = (0, util_1.ensureHexBuffer)("0x".concat(new bignumber_js_1.default(chainId).toString(16)));
    // Make sure the buffer is an allowed size
    if (b.length > 8)
        throw new Error('ChainID provided is too large.');
    // If this matches a u16, u32, or u64 size, return it now
    if (b.length <= 2 || b.length === 4 || b.length === 8)
        return b;
    // For other size buffers, we need to pack into u32 or u64 before returning;
    var buf;
    if (b.length === 3) {
        buf = Buffer.alloc(4);
        buf.writeUInt32BE(chainId);
    }
    else if (b.length <= 8) {
        buf = Buffer.alloc(8);
        b.copy(buf, 8 - b.length);
    }
    return buf;
}
// Determine if the chain uses EIP155 by default, based on the chainID
function chainUsesEIP155(chainID) {
    switch (chainID) {
        case 3: // ropsten
        case 4: // rinkeby
            return false;
        case 1: // mainnet
        case 42: // kovan
        case 5: // goerli
        default:
            // all others should use eip155
            return true;
    }
}
// Determine if a valid number was passed in as a hex string
function isValidChainIdHexNumStr(s) {
    if (typeof s !== 'string')
        return false;
    if (s.slice(0, 2) !== '0x')
        return false;
    try {
        var b = new bignumber_js_1.default(s, 16);
        return b.isNaN() === false;
    }
    catch (err) {
        return false;
    }
}
// If this is a nubmer that fits in one byte, we don't need to add it
// to the `data` buffer of the main transaction.
// Note the one edge case: we still need to use the `data` field for chainID=255.
function useChainIdBuffer(id) {
    var buf = getChainIdBuf(id);
    if (buf.length === 1)
        return buf.readUInt8(0) === 255;
    return true;
}
function buildPersonalSignRequest(req, input) {
    var MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;
    var VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;
    var L = 24 + MAX_BASE_MSG_SZ + 4;
    var off = 0;
    req.payload = Buffer.alloc(L);
    req.payload.writeUInt8(constants_1.ethMsgProtocol.SIGN_PERSONAL, 0);
    off += 1;
    // Write the signer path into the buffer
    var signerPathBuf = (0, util_1.buildSignerPathBuf)(input.signerPath, VAR_PATH_SZ);
    signerPathBuf.copy(req.payload, off);
    off += signerPathBuf.length;
    // Write the payload buffer. The payload can come in either as a buffer or as a string
    var payload = input.payload;
    // Determine if this is a hex string
    var displayHex = false;
    if (typeof input.payload === 'string') {
        if (input.payload.slice(0, 2) === '0x') {
            payload = (0, util_1.ensureHexBuffer)(input.payload);
            displayHex =
                false ===
                    constants_1.ASCII_REGEX.test(Buffer.from(input.payload.slice(2), 'hex').toString());
        }
        else {
            if (false === (0, util_1.isAsciiStr)(input.payload))
                throw new Error('Currently, the Lattice can only display ASCII strings.');
            payload = Buffer.from(input.payload);
        }
    }
    else if (typeof input.displayHex === 'boolean') {
        // If this is a buffer and the user has specified whether or not this
        // is a hex buffer with the optional argument, write that
        displayHex = input.displayHex;
    }
    else {
        // Otherwise, determine if this buffer is an ASCII string. If it is, set `displayHex` accordingly.
        // NOTE: THIS MEANS THAT NON-ASCII STRINGS WILL DISPLAY AS HEX SINCE WE CANNOT KNOW IF THE REQUESTER
        //        EXPECTED NON-ASCII CHARACTERS TO DISPLAY IN A STRING
        // TODO: Develop a more elegant solution for this
        if (!input.payload.toString)
            throw new Error('Unsupported input data type');
        displayHex = false === constants_1.ASCII_REGEX.test(input.payload.toString());
    }
    var fwConst = input.fwConstants;
    var maxSzAllowed = MAX_BASE_MSG_SZ + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;
    if (fwConst.personalSignHeaderSz) {
        // Account for the personal_sign header string
        maxSzAllowed -= fwConst.personalSignHeaderSz;
    }
    if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {
        // If this message will not fit and pre-hashing is allowed, do that
        req.payload.writeUInt8(displayHex, off);
        off += 1;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        var prehash = Buffer.from((0, js_sha3_1.keccak256)(Buffer.concat([get_personal_sign_prefix(payload.length), payload])), 'hex');
        prehash.copy(req.payload, off);
        req.prehash = prehash;
    }
    else {
        // Otherwise we can fit the payload.
        // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable
        var extraDataPayloads = getExtraData(payload, input);
        // Write the payload and metadata into our buffer
        req.extraDataPayloads = extraDataPayloads;
        req.msg = payload;
        req.payload.writeUInt8(displayHex, off);
        off += 1;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        payload.copy(req.payload, off);
    }
    return req;
}
function buildEIP712Request(req, input) {
    var _a = input.fwConstants, ethMaxMsgSz = _a.ethMaxMsgSz, varAddrPathSzAllowed = _a.varAddrPathSzAllowed, eip712MaxTypeParams = _a.eip712MaxTypeParams;
    var TYPED_DATA = constants_1.ethMsgProtocol.TYPED_DATA;
    var L = 24 + ethMaxMsgSz + 4;
    var off = 0;
    req.payload = Buffer.alloc(L);
    req.payload.writeUInt8(TYPED_DATA.enumIdx, 0);
    off += 1;
    // Write the signer path
    var signerPathBuf = (0, util_1.buildSignerPathBuf)(input.signerPath, varAddrPathSzAllowed);
    signerPathBuf.copy(req.payload, off);
    off += signerPathBuf.length;
    // Parse/clean the EIP712 payload, serialize with CBOR, and write to the payload
    var data = JSON.parse(JSON.stringify(input.payload));
    if (!data.primaryType || !data.types[data.primaryType])
        throw new Error('primaryType must be specified and the type must be included.');
    if (!data.message || !data.domain)
        throw new Error('message and domain must be specified.');
    if (0 > Object.keys(data.types).indexOf('EIP712Domain'))
        throw new Error('EIP712Domain type must be defined.');
    // Parse the payload to ensure we have valid EIP712 data types and that
    // they are encoded such that Lattice firmware can parse them.
    // We need two different encodings: one to send to the Lattice in a format that plays
    // nicely with our firmware CBOR decoder. The other is formatted to be consumable by
    // our EIP712 validation module.
    input.payload.message = parseEIP712Msg(JSON.parse(JSON.stringify(data.message)), JSON.parse(JSON.stringify(data.primaryType)), JSON.parse(JSON.stringify(data.types)), true);
    input.payload.domain = parseEIP712Msg(JSON.parse(JSON.stringify(data.domain)), 'EIP712Domain', JSON.parse(JSON.stringify(data.types)), true);
    data.domain = parseEIP712Msg(data.domain, 'EIP712Domain', data.types, false);
    data.message = parseEIP712Msg(data.message, data.primaryType, data.types, false);
    // Now build the message to be sent to the Lattice
    var payload = Buffer.from(borc_1.default.encode(data));
    var fwConst = input.fwConstants;
    var maxSzAllowed = ethMaxMsgSz + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;
    // Determine if we need to prehash
    var shouldPrehash = payload.length > maxSzAllowed;
    Object.keys(data.types).forEach(function (k) {
        if (data.types[k].length > eip712MaxTypeParams) {
            shouldPrehash = true;
        }
    });
    if (fwConst.ethMsgPreHashAllowed && shouldPrehash) {
        // If this payload is too large to send, but the Lattice allows a prehashed message, do that
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        var prehash = eth_eip712_util_browser_1.TypedDataUtils.hash(req.input.payload);
        var prehashBuf = Buffer.from(prehash);
        prehashBuf.copy(req.payload, off);
        req.prehash = prehash;
    }
    else {
        var extraDataPayloads = getExtraData(payload, input);
        req.extraDataPayloads = extraDataPayloads;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        payload.copy(req.payload, off);
        off += payload.length;
        // Slice out the part of the buffer that we didn't use.
        req.payload = req.payload.slice(0, off);
    }
    return req;
}
function getExtraData(payload, input) {
    var _a = input.fwConstants, ethMaxMsgSz = _a.ethMaxMsgSz, extraDataFrameSz = _a.extraDataFrameSz, extraDataMaxFrames = _a.extraDataMaxFrames;
    var MAX_BASE_MSG_SZ = ethMaxMsgSz;
    var EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
    var extraDataPayloads = [];
    if (payload.length > MAX_BASE_MSG_SZ) {
        // Determine sizes and run through sanity checks
        var maxSzAllowed = MAX_BASE_MSG_SZ + extraDataMaxFrames * extraDataFrameSz;
        if (!EXTRA_DATA_ALLOWED)
            throw new Error("Your message is ".concat(payload.length, " bytes, but can only be a maximum of ").concat(MAX_BASE_MSG_SZ));
        else if (EXTRA_DATA_ALLOWED && payload.length > maxSzAllowed)
            throw new Error("Your message is ".concat(payload.length, " bytes, but can only be a maximum of ").concat(maxSzAllowed));
        // Split overflow data into extraData frames
        var frames_2 = (0, util_1.splitFrames)(payload.slice(MAX_BASE_MSG_SZ), extraDataFrameSz);
        frames_2.forEach(function (frame) {
            var szLE = Buffer.alloc(4);
            szLE.writeUInt32LE(frame.length, 0);
            extraDataPayloads.push(Buffer.concat([szLE, frame]));
        });
    }
    return extraDataPayloads;
}
function parseEIP712Msg(msg, typeName, types, forJSParser) {
    if (forJSParser === void 0) { forJSParser = false; }
    var type = types[typeName];
    type.forEach(function (item) {
        var isArrayType = item.type.indexOf('[') > -1;
        var singularType = isArrayType
            ? item.type.slice(0, item.type.indexOf('['))
            : item.type;
        var isCustomType = Object.keys(types).indexOf(singularType) > -1;
        if (isCustomType && Array.isArray(msg)) {
            // For custom types we need to jump into the `msg` using the key (name of type) and
            // parse that entire sub-struct as if it were a message.
            // We will recurse into sub-structs until we reach a level where every item is an
            // elementary (i.e. non-custom) type.
            // For arrays, we need to loop through each message item.
            for (var i = 0; i < msg.length; i++) {
                msg[i][item.name] = parseEIP712Msg(msg[i][item.name], singularType, types, forJSParser);
            }
        }
        else if (isCustomType) {
            // Not an array means we can jump directly into the sub-struct to convert
            msg[item.name] = parseEIP712Msg(msg[item.name], singularType, types, forJSParser);
        }
        else if (Array.isArray(msg)) {
            // If we have an array for this particular type and the type we are parsing
            // is *not* a custom type, loop through the array elements and convert the types.
            for (var i = 0; i < msg.length; i++) {
                if (isArrayType) {
                    // If this type is itself an array, loop through those elements and parse individually.
                    // This code is not reachable for custom types so we assume these are arrays of
                    // elementary types.
                    for (var j = 0; j < msg[i][item.name].length; j++) {
                        msg[i][item.name][j] = parseEIP712Item(msg[i][item.name][j], singularType, forJSParser);
                    }
                }
                else {
                    // Non-arrays parse + replace one value for the elementary type
                    msg[i][item.name] = parseEIP712Item(msg[i][item.name], singularType, forJSParser);
                }
            }
        }
        else if (isArrayType) {
            // If we have an elementary array type and a non-array message level,
            //loop through the array and parse + replace  each item individually.
            for (var i = 0; i < msg[item.name].length; i++) {
                msg[item.name][i] = parseEIP712Item(msg[item.name][i], singularType, forJSParser);
            }
        }
        else {
            // If this is a singular elementary type, simply parse + replace.
            msg[item.name] = parseEIP712Item(msg[item.name], singularType, forJSParser);
        }
    });
    return msg;
}
function parseEIP712Item(data, type, forJSParser) {
    if (forJSParser === void 0) { forJSParser = false; }
    if (type === 'bytes') {
        // Variable sized bytes need to be buffer type
        data = (0, util_1.ensureHexBuffer)(data);
        if (forJSParser) {
            // For EIP712 encoding module it's easier to encode hex strings
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (type.slice(0, 5) === 'bytes') {
        // Fixed sizes bytes need to be buffer type. We also add some sanity checks.
        var nBytes = parseInt(type.slice(5));
        data = (0, util_1.ensureHexBuffer)(data);
        if (data.length !== nBytes)
            throw new Error("Expected ".concat(type, " type, but got ").concat(data.length, " bytes"));
        if (forJSParser) {
            // For EIP712 encoding module it's easier to encode hex strings
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (type === 'address') {
        // Address must be a 20 byte buffer
        data = (0, util_1.ensureHexBuffer)(data);
        // Edge case to handle the 0-address
        if (data.length === 0) {
            data = Buffer.alloc(20);
        }
        if (data.length !== 20)
            throw new Error("Address type must be 20 bytes, but got ".concat(data.length, " bytes"));
        // For EIP712 encoding module it's easier to encode hex strings
        if (forJSParser) {
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (constants_1.ethMsgProtocol.TYPED_DATA.typeCodes[type] &&
        (type.indexOf('uint') > -1 || type.indexOf('int') > -1)) {
        var b = (0, util_1.ensureHexBuffer)(data);
        // Edge case to handle 0-value bignums
        if (b.length === 0) {
            b = Buffer.from('00', 'hex');
        }
        // Uint256s should be encoded as bignums.
        if (forJSParser) {
            // For EIP712 encoding in this module we need strings to represent the numbers
            data = "0x".concat(b.toString('hex'));
        }
        else {
            // `bignumber.js` is needed for `cbor` encoding, which gets sent to the Lattice and plays
            // nicely with its firmware cbor lib.
            // NOTE: If we instantiate a `bignumber.js` object, it will not match what `borc` creates
            // when run inside of the browser (i.e. MetaMask). Thus we introduce this hack to make sure
            // we are creating a compatible type.
            // TODO: Find another cbor lib that is compataible with the firmware's lib in a browser
            // context. This is surprisingly difficult - I tried several libs and only cbor/borc have
            // worked (borc is a supposedly "browser compatible" version of cbor)
            data = new borc_1.default.Encoder().semanticTypes[1][0](b.toString('hex'), 16);
        }
    }
    else if (type === 'bool') {
        // Booleans need to be cast to a u8
        data = data === true ? 1 : 0;
    }
    // Other types don't need to be modified
    return data;
}
function get_personal_sign_prefix(L) {
    return Buffer.from("\u0019Ethereum Signed Message:\n".concat(L.toString()), 'utf-8');
}
function get_rlp_encoded_preimage(rawTx, txType) {
    if (txType) {
        return Buffer.concat([Buffer.from([txType]), Buffer.from((0, rlp_1.encode)(rawTx))]);
    }
    else {
        return Buffer.from((0, rlp_1.encode)(rawTx));
    }
}
// ======
// TEMPORARY BRIDGE
// We are migrating from all legacy signing paths to a single generic
// signing route. If users are attempting a legacy transaction request
// against a Lattice on firmware v0.15.0 and above, we need to convert
// that to a generic signing request.
//
// NOTE: Once we deprecate, we will remove this entire file
// ======
var ethConvertLegacyToGenericReq = function (req) {
    var common;
    if (!req.chainId || (0, util_1.ensureHexBuffer)(req.chainId).toString('hex') === '01') {
        common = new common_1.Common({ chain: common_1.Chain.Mainnet, hardfork: common_1.Hardfork.London });
    }
    else {
        // Not every network will support these EIPs but we will allow
        // signing of transactions using them
        common = common_1.Common.custom({ chainId: Number(req.chainId) }, { hardfork: common_1.Hardfork.London, eips: [1559, 2930] });
    }
    var tx = tx_1.TransactionFactory.fromTxData(req, { common: common });
    // Get the raw transaction payload to be hashed and signed.
    // Different `@ethereumjs/tx` Transaction object types have
    // slightly different APIs around this.
    if (req.type) {
        // Newer transaction types
        return tx.getMessageToSign(false);
    }
    else {
        // Legacy transaction type
        return Buffer.from((0, rlp_1.encode)(tx.getMessageToSign(false)));
    }
};
exports.default = {
    buildEthereumMsgRequest: buildEthereumMsgRequest,
    validateEthereumMsgResponse: validateEthereumMsgResponse,
    buildEthereumTxRequest: buildEthereumTxRequest,
    buildEthRawTx: buildEthRawTx,
    hashTransaction: hashTransaction,
    chainIds: chainIds,
    ensureHexBuffer: util_1.ensureHexBuffer,
    ethConvertLegacyToGenericReq: ethConvertLegacyToGenericReq,
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\ethereum.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\addKvRecords.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CaddKvRecords.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeAddKvRecordsRequest = exports.validateAddKvRequest = exports.addKvRecords = void 0;
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
/**
 * `addKvRecords` takes in a set of key-value records and sends a request to add them to the
 * Lattice.
 * @category Lattice
 * @returns A callback with an error or null.
 */
function addKvRecords(_a) {
    var client = _a.client, records = _a.records, type = _a.type, caseSensitive = _a.caseSensitive;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, data, _c, decryptedData, newEphemeralPub;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    (0, exports.validateAddKvRequest)({ records: records, fwConstants: fwConstants });
                    data = (0, exports.encodeAddKvRecordsRequest)({
                        records: records,
                        type: type,
                        caseSensitive: caseSensitive,
                        fwConstants: fwConstants,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.addKvRecords,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _c = _d.sent(), decryptedData = _c.decryptedData, newEphemeralPub = _c.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, decryptedData];
            }
        });
    });
}
exports.addKvRecords = addKvRecords;
var validateAddKvRequest = function (_a) {
    var records = _a.records, fwConstants = _a.fwConstants;
    (0, validators_1.validateKvRecords)(records, fwConstants);
};
exports.validateAddKvRequest = validateAddKvRequest;
var encodeAddKvRecordsRequest = function (_a) {
    var records = _a.records, type = _a.type, caseSensitive = _a.caseSensitive, fwConstants = _a.fwConstants;
    var payload = Buffer.alloc(1 + 139 * fwConstants.kvActionMaxNum);
    payload.writeUInt8(Object.keys(records).length, 0);
    var off = 1;
    Object.entries(records).forEach(function (_a) {
        var _key = _a[0], _val = _a[1];
        var _b = (0, validators_1.validateKvRecord)({ key: _key, val: _val }, fwConstants), key = _b.key, val = _b.val;
        // Skip the ID portion. This will get added by firmware.
        payload.writeUInt32LE(0, off);
        off += 4;
        payload.writeUInt32LE(type, off);
        off += 4;
        payload.writeUInt8(caseSensitive ? 1 : 0, off);
        off += 1;
        payload.writeUInt8(String(key).length + 1, off);
        off += 1;
        Buffer.from(String(key)).copy(payload, off);
        off += fwConstants.kvKeyMaxStrSz + 1;
        payload.writeUInt8(String(val).length + 1, off);
        off += 1;
        Buffer.from(String(val)).copy(payload, off);
        off += fwConstants.kvValMaxStrSz + 1;
    });
    return payload;
};
exports.encodeAddKvRecordsRequest = encodeAddKvRecordsRequest;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\addKvRecords.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\connect.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/predicates":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\predicates.js","../shared/utilities":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Cconnect.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeConnectResponse = exports.validateConnectRequest = exports.connect = void 0;
var protocol_1 = require("../protocol");
var predicates_1 = require("../shared/predicates");
var utilities_1 = require("../shared/utilities");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
function connect(_a) {
    var client = _a.client, id = _a.id;
    return __awaiter(this, void 0, void 0, function () {
        var _b, deviceId, key, baseUrl, url, respPayloadData, _c, isPaired, fwVersion, activeWallets, ephemeralPub;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, exports.validateConnectRequest)({
                        deviceId: id,
                        key: client.key,
                        baseUrl: client.baseUrl,
                    }), deviceId = _b.deviceId, key = _b.key, baseUrl = _b.baseUrl;
                    url = "".concat(baseUrl, "/").concat(deviceId);
                    return [4 /*yield*/, (0, protocol_1.connectSecureRequest)({
                            url: url,
                            pubkey: client.publicKey,
                        })];
                case 1:
                    respPayloadData = _d.sent();
                    return [4 /*yield*/, (0, exports.decodeConnectResponse)(respPayloadData, key)];
                case 2:
                    _c = _d.sent(), isPaired = _c.isPaired, fwVersion = _c.fwVersion, activeWallets = _c.activeWallets, ephemeralPub = _c.ephemeralPub;
                    // Update client state with response data
                    client.mutate({
                        deviceId: deviceId,
                        ephemeralPub: ephemeralPub,
                        url: url,
                        isPaired: isPaired,
                        fwVersion: fwVersion,
                        activeWallets: activeWallets,
                    });
                    if (!(isPaired && !(0, predicates_1.doesFetchWalletsOnLoad)(client.getFwVersion()))) return [3 /*break*/, 4];
                    return [4 /*yield*/, client.fetchActiveWallet()];
                case 3:
                    _d.sent();
                    _d.label = 4;
                case 4: 
                // Return flag indicating whether we are paired or not.
                // If we are *not* already paired, the Lattice is now in
                // pairing mode and expects a `finalizePairing` encrypted
                // request as a follow up.
                return [2 /*return*/, isPaired];
            }
        });
    });
}
exports.connect = connect;
var validateConnectRequest = function (_a) {
    var deviceId = _a.deviceId, key = _a.key, baseUrl = _a.baseUrl;
    var validDeviceId = (0, validators_1.validateDeviceId)(deviceId);
    var validKey = (0, validators_1.validateKey)(key);
    var validBaseUrl = (0, validators_1.validateBaseUrl)(baseUrl);
    return {
        deviceId: validDeviceId,
        key: validKey,
        baseUrl: validBaseUrl,
    };
};
exports.validateConnectRequest = validateConnectRequest;
/**
 * `decodeConnectResponse` will call `StartPairingMode` on the device, which gives the user 60 seconds to
 * finalize the pairing. This will return an ephemeral public key, which is needed for the next
 * request.
 * - If the device is already paired, this ephemPub is simply used to encrypt the next request.
 * - If the device is not paired, it is needed to pair the device within 60 seconds.
 * @category Device Response
 * @internal
 * @returns true if we are paired to the device already
 */
var decodeConnectResponse = function (response, key) {
    var off = 0;
    var isPaired = response.readUInt8(off) === protocol_1.ProtocolConstants.pairingStatus.paired;
    off++;
    // If we are already paired, we get the next ephemeral key
    var pub = response.slice(off, off + 65).toString('hex');
    off += 65; // Set the public key
    var ephemeralPub = (0, util_1.getP256KeyPairFromPub)(pub);
    // Grab the firmware version (will be 0-length for older fw versions) It is of format
    // |fix|minor|major|reserved|
    var fwVersion = response.slice(off, off + 4);
    off += 4;
    // If we are already paired, the response will include some encrypted data about the current
    // wallets This data was added in Lattice firmware v0.14.1
    if (isPaired) {
        //TODO && this._fwVersionGTE(0, 14, 1)) {
        // Later versions of firmware added wallet info
        var encWalletData = response.slice(off, off + 160);
        off += 160;
        var sharedSecret = (0, utilities_1.getSharedSecret)(key, ephemeralPub);
        var decWalletData = (0, util_1.aes256_decrypt)(encWalletData, sharedSecret);
        // Sanity check to make sure the last part of the decrypted data is empty. The last 2 bytes
        // are AES padding
        if (decWalletData[decWalletData.length - 2] !== 0 ||
            decWalletData[decWalletData.length - 1] !== 0) {
            throw new Error('Failed to connect to Lattice.');
        }
        var activeWallets = (0, utilities_1.parseWallets)(decWalletData);
        return { isPaired: isPaired, fwVersion: fwVersion, activeWallets: activeWallets, ephemeralPub: ephemeralPub };
    }
    // return the state of our pairing
    return { isPaired: isPaired, fwVersion: fwVersion, activeWallets: undefined, ephemeralPub: ephemeralPub };
};
exports.decodeConnectResponse = decodeConnectResponse;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\connect.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchActiveWallet.js", {"../constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CfetchActiveWallet.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeFetchActiveWalletResponse = exports.fetchActiveWallet = void 0;
var constants_1 = require("../constants");
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
/**
 * Fetch the active wallet in the device.
 *
 * The Lattice has two wallet interfaces: internal and external. If a SafeCard is inserted and
 * unlocked, the external interface is considered "active" and this will return its {@link Wallet}
 * data. Otherwise it will return the info for the internal Lattice wallet.
 */
function fetchActiveWallet(_a) {
    var client = _a.client;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, _c, decryptedData, newEphemeralPub, activeWallets, validActiveWallets;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub;
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: Buffer.alloc(0),
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.getWallets,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _c = _d.sent(), decryptedData = _c.decryptedData, newEphemeralPub = _c.newEphemeralPub;
                    activeWallets = (0, exports.decodeFetchActiveWalletResponse)(decryptedData);
                    validActiveWallets = (0, validators_1.validateActiveWallets)(activeWallets);
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                        activeWallets: validActiveWallets,
                    });
                    return [2 /*return*/, validActiveWallets];
            }
        });
    });
}
exports.fetchActiveWallet = fetchActiveWallet;
var decodeFetchActiveWalletResponse = function (data) {
    // Read the external wallet data first. If it is non-null, the external wallet will be the
    // active wallet of the device and we should save it. If the external wallet is blank, it means
    // there is no card present and we should save and use the interal wallet. If both wallets are
    // empty, it means the device still needs to be set up.
    var walletDescriptorLen = 71;
    // Internal first
    var activeWallets = {
        internal: {
            uid: constants_1.EMPTY_WALLET_UID,
            external: false,
            name: Buffer.alloc(0),
            capabilities: 0,
        },
        external: {
            uid: constants_1.EMPTY_WALLET_UID,
            external: true,
            name: Buffer.alloc(0),
            capabilities: 0,
        },
    };
    var off = 0;
    activeWallets.internal.uid = data.slice(off, off + 32);
    activeWallets.internal.capabilities = data.readUInt32BE(off + 32);
    activeWallets.internal.name = data.slice(off + 36, off + walletDescriptorLen);
    // Offset the first item
    off += walletDescriptorLen;
    // External
    activeWallets.external.uid = data.slice(off, off + 32);
    activeWallets.external.capabilities = data.readUInt32BE(off + 32);
    activeWallets.external.name = data.slice(off + 36, off + walletDescriptorLen);
    return activeWallets;
};
exports.decodeFetchActiveWalletResponse = decodeFetchActiveWalletResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\fetchActiveWallet.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchEncData.js", {"../constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/utilities":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","uuid":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CfetchEncData.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeFetchEncData = exports.encodeFetchEncDataRequest = exports.validateFetchEncDataRequest = exports.fetchEncData = void 0;
/**
 * Export encrypted data from the Lattice. Data must conform
 * to known schema, e.g. EIP2335 derived privkey export.
 */
var uuid_1 = require("uuid");
var constants_1 = require("../constants");
var protocol_1 = require("../protocol");
var utilities_1 = require("../shared/utilities");
var validators_1 = require("../shared/validators");
var ENC_DATA = constants_1.EXTERNAL.ENC_DATA;
var ENC_DATA_ERR_STR = 'Unknown encrypted data export type requested. Exiting.';
var ENC_DATA_REQ_DATA_SZ = 1025;
var ENC_DATA_RESP_SZ = {
    EIP2335: {
        CIPHERTEXT: 32,
        SALT: 32,
        CHECKSUM: 32,
        IV: 16,
        PUBKEY: 48,
    },
};
function fetchEncData(_a) {
    var client = _a.client, schema = _a.schema, params = _a.params;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwVersion, activeWallet, data, _c, decryptedData, newEphemeralPub;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwVersion = _b.fwVersion;
                    activeWallet = (0, validators_1.validateWallet)(client.getActiveWallet());
                    (0, exports.validateFetchEncDataRequest)({ params: params });
                    data = (0, exports.encodeFetchEncDataRequest)({
                        schema: schema,
                        params: params,
                        fwVersion: fwVersion,
                        activeWallet: activeWallet,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.fetchEncryptedData,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _c = _d.sent(), decryptedData = _c.decryptedData, newEphemeralPub = _c.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, (0, exports.decodeFetchEncData)({ data: decryptedData, schema: schema, params: params })];
            }
        });
    });
}
exports.fetchEncData = fetchEncData;
var validateFetchEncDataRequest = function (_a) {
    var params = _a.params;
    // Validate derivation path
    (0, validators_1.validateStartPath)(params.path);
};
exports.validateFetchEncDataRequest = validateFetchEncDataRequest;
var encodeFetchEncDataRequest = function (_a) {
    var schema = _a.schema, params = _a.params, fwVersion = _a.fwVersion, activeWallet = _a.activeWallet;
    // Check firmware version
    if (fwVersion.major < 1 && fwVersion.minor < 17) {
        throw new Error('Firmware version >=v0.17.0 is required for encrypted data export.');
    }
    // Update params depending on what type of data is being exported
    if (schema === ENC_DATA.SCHEMAS.BLS_KEYSTORE_EIP2335_PBKDF_V4) {
        // Set the wallet UID to the client's current active wallet
        params.walletUID = activeWallet.uid;
    }
    else {
        throw new Error(ENC_DATA_ERR_STR);
    }
    // Build the payload data
    var payload = Buffer.alloc(ENC_DATA_REQ_DATA_SZ);
    var off = 0;
    payload.writeUInt8(schema, off);
    off += 1;
    if (schema === ENC_DATA.SCHEMAS.BLS_KEYSTORE_EIP2335_PBKDF_V4) {
        params.walletUID.copy(payload, off);
        off += params.walletUID.length;
        payload.writeUInt8(params.path.length, off);
        off += 1;
        for (var i = 0; i < 5; i++) {
            if (i <= params.path.length) {
                payload.writeUInt32LE(params.path[i], off);
            }
            off += 4;
        }
        if (params.c) {
            payload.writeUInt32LE(params.c, off);
        }
        off += 4;
        return payload;
    }
    else {
        throw new Error(ENC_DATA_ERR_STR);
    }
};
exports.encodeFetchEncDataRequest = encodeFetchEncDataRequest;
var decodeFetchEncData = function (_a) {
    var data = _a.data, schema = _a.schema, params = _a.params;
    var off = 0;
    if (schema === ENC_DATA.SCHEMAS.BLS_KEYSTORE_EIP2335_PBKDF_V4) {
        var respData = {};
        var _b = ENC_DATA_RESP_SZ.EIP2335, CIPHERTEXT = _b.CIPHERTEXT, SALT = _b.SALT, CHECKSUM = _b.CHECKSUM, IV = _b.IV, PUBKEY = _b.PUBKEY;
        var expectedSz = 4 + // iterations = u32
            CIPHERTEXT +
            SALT +
            CHECKSUM +
            IV +
            PUBKEY;
        var dataSz = data.readUInt32LE(off);
        off += 4;
        if (dataSz !== expectedSz) {
            throw new Error('Invalid data returned from Lattice. Expected EIP2335 data.');
        }
        respData.iterations = data.readUInt32LE(off);
        off += 4;
        respData.cipherText = data.slice(off, off + CIPHERTEXT);
        off += CIPHERTEXT;
        respData.salt = data.slice(off, off + SALT);
        off += SALT;
        respData.checksum = data.slice(off, off + CHECKSUM);
        off += CHECKSUM;
        respData.iv = data.slice(off, off + IV);
        off += IV;
        respData.pubkey = data.slice(off, off + PUBKEY);
        off += PUBKEY;
        return formatEIP2335ExportData(respData, params.path);
    }
    else {
        throw new Error(ENC_DATA_ERR_STR);
    }
};
exports.decodeFetchEncData = decodeFetchEncData;
var formatEIP2335ExportData = function (resp, path) {
    try {
        var iterations = resp.iterations, salt = resp.salt, checksum = resp.checksum, iv = resp.iv, cipherText = resp.cipherText, pubkey = resp.pubkey;
        return Buffer.from(JSON.stringify({
            'version': 4,
            'uuid': (0, uuid_1.v4)(),
            'path': (0, utilities_1.getPathStr)(path),
            'pubkey': pubkey.toString('hex'),
            'crypto': {
                'kdf': {
                    'function': 'pbkdf2',
                    'params': {
                        'dklen': 32,
                        'c': iterations,
                        'prf': 'hmac-sha256',
                        'salt': salt.toString('hex'),
                    },
                    'message': ''
                },
                'checksum': {
                    'function': 'sha256',
                    'params': {},
                    'message': checksum.toString('hex'),
                },
                'cipher': {
                    'function': 'aes-128-ctr',
                    'params': {
                        'iv': iv.toString('hex'),
                    },
                    'message': cipherText.toString('hex')
                }
            }
        }));
    }
    catch (err) {
        throw Error("Failed to format EIP2335 return data: ".concat(err.toString()));
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\fetchEncData.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getAddresses.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","bitwise":"F:\\metamask-extension\\node_modules\\bitwise\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CgetAddresses.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeGetAddressesResponse = exports.encodeGetAddressesRequest = exports.validateGetAddressesRequest = exports.getAddresses = void 0;
var bitwise_1 = __importDefault(require("bitwise"));
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
/**
 * `getAddresses` takes a starting path and a number to get the addresses or public keys associated
 * with the active wallet.
 * @category Lattice
 * @returns An array of addresses or public keys.
 */
function getAddresses(_a) {
    var client = _a.client, _startPath = _a.startPath, _n = _a.n, _flag = _a.flag;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, activeWallet, _c, startPath, n, flag, data, _d, decryptedData, newEphemeralPub;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    activeWallet = (0, validators_1.validateWallet)(client.getActiveWallet());
                    _c = (0, exports.validateGetAddressesRequest)({
                        startPath: _startPath,
                        n: _n,
                        flag: _flag,
                    }), startPath = _c.startPath, n = _c.n, flag = _c.flag;
                    data = (0, exports.encodeGetAddressesRequest)({
                        startPath: startPath,
                        n: n,
                        flag: flag,
                        fwConstants: fwConstants,
                        wallet: activeWallet,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.getAddresses,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _d = _e.sent(), decryptedData = _d.decryptedData, newEphemeralPub = _d.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, (0, exports.decodeGetAddressesResponse)(decryptedData, flag)];
            }
        });
    });
}
exports.getAddresses = getAddresses;
var validateGetAddressesRequest = function (_a) {
    var startPath = _a.startPath, n = _a.n, flag = _a.flag;
    return {
        startPath: (0, validators_1.validateStartPath)(startPath),
        n: (0, validators_1.validateNAddresses)(n),
        flag: (0, validators_1.validateIsUInt4)(flag),
    };
};
exports.validateGetAddressesRequest = validateGetAddressesRequest;
var encodeGetAddressesRequest = function (_a) {
    var _b;
    var startPath = _a.startPath, n = _a.n, flag = _a.flag, fwConstants = _a.fwConstants, wallet = _a.wallet;
    var flags = fwConstants.getAddressFlags || [];
    var isPubkeyOnly = flags.indexOf(flag) > -1 &&
        (flag === protocol_1.LatticeGetAddressesFlag.ed25519Pubkey ||
            flag === protocol_1.LatticeGetAddressesFlag.secp256k1Pubkey ||
            flag === protocol_1.LatticeGetAddressesFlag.bls12_381Pubkey);
    if (!isPubkeyOnly && !(0, util_1.isValidAssetPath)(startPath, fwConstants)) {
        throw new Error('Derivation path or flag is not supported. Try updating Lattice firmware.');
    }
    var sz = 32 + 20 + 1; // walletUID + 5 u32 indices + count/flag
    if (fwConstants.varAddrPathSzAllowed) {
        sz += 1; // pathDepth
    }
    else if (startPath.length !== 5) {
        throw new Error('Your Lattice firmware only supports derivation paths with 5 indices. Please upgrade.');
    }
    var payload = Buffer.alloc(sz);
    var off = 0;
    wallet.uid.copy(payload, off);
    off += 32;
    // Build the start path (5x u32 indices)
    if (fwConstants.varAddrPathSzAllowed) {
        payload.writeUInt8(startPath.length, off);
        off += 1;
    }
    for (var i = 0; i < 5; i++) {
        if (i <= startPath.length) {
            var val_1 = (_b = startPath[i]) !== null && _b !== void 0 ? _b : 0;
            payload.writeUInt32BE(val_1, off);
        }
        off += 4;
    }
    // Specify the number of subsequent addresses to request. We also allow the user to skip the
    // cache and request any address related to the asset in the wallet.
    var val, flagVal = 0;
    if (fwConstants.addrFlagsAllowed) {
        // A 4-bit flag can be used for non-standard address requests Client needs to be combined with
        // `n` as a 4 bit value
        flagVal =
            fwConstants.getAddressFlags &&
                fwConstants.getAddressFlags.indexOf(flag) > -1
                ? flag
                : 0;
        var flagBits = bitwise_1.default.nibble.read(flagVal);
        var countBits = bitwise_1.default.nibble.read(n);
        val = bitwise_1.default.byte.write(flagBits.concat(countBits));
    }
    else {
        // Very old firmware does not support client flag. We can deprecate client soon.
        val = n;
    }
    payload.writeUInt8(val, off);
    off++;
    return payload;
};
exports.encodeGetAddressesRequest = encodeGetAddressesRequest;
/**
 * @internal
 * @return an array of address strings or pubkey buffers
 */
var decodeGetAddressesResponse = function (data, flag) {
    var off = 0;
    // Look for addresses until we reach the end (a 4 byte checksum)
    var addrs = [];
    // Pubkeys are formatted differently in the response
    var arePubkeys = flag === protocol_1.LatticeGetAddressesFlag.secp256k1Pubkey ||
        flag === protocol_1.LatticeGetAddressesFlag.ed25519Pubkey ||
        flag === protocol_1.LatticeGetAddressesFlag.bls12_381Pubkey;
    if (arePubkeys) {
        off += 1; // skip uint8 representing pubkey type
    }
    var respDataLength = protocol_1.ProtocolConstants.msgSizes.secure.data.response.encrypted[protocol_1.LatticeSecureEncryptedRequestType.getAddresses];
    while (off < respDataLength) {
        if (arePubkeys) {
            // Pubkeys are shorter and are returned as buffers
            var pubBytes = data.slice(off, off + 65);
            var isEmpty = pubBytes.every(function (byte) { return byte === 0x00; });
            if (!isEmpty && flag === protocol_1.LatticeGetAddressesFlag.ed25519Pubkey) {
                // ED25519 pubkeys are 32 bytes
                addrs.push(pubBytes.slice(0, 32));
            }
            else if (!isEmpty && flag === protocol_1.LatticeGetAddressesFlag.bls12_381Pubkey) {
                // BLS12_381_G1 keys are 48 bytes
                addrs.push(pubBytes.slice(0, 48));
            }
            else if (!isEmpty) {
                // Only other returned pubkeys are ECC, or 65 bytes Note that we return full
                // (uncompressed) ECC pubkeys
                addrs.push(pubBytes);
            }
            off += 65;
        }
        else {
            // Otherwise we are dealing with address strings
            var addrBytes = data.slice(off, off + protocol_1.ProtocolConstants.addrStrLen);
            off += protocol_1.ProtocolConstants.addrStrLen;
            // Return the UTF-8 representation
            var len = addrBytes.indexOf(0); // First 0 is the null terminator
            if (len > 0) {
                addrs.push(addrBytes.slice(0, len).toString());
            }
        }
    }
    return addrs;
};
exports.decodeGetAddressesResponse = decodeGetAddressesResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\getAddresses.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getKvRecords.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CgetKvRecords.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeGetKvRecordsResponse = exports.encodeGetKvRecordsRequest = exports.validateGetKvRequest = exports.getKvRecords = void 0;
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
function getKvRecords(_a) {
    var client = _a.client, _type = _a.type, _n = _a.n, _start = _a.start;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, _c, type, n, start, data, _d, decryptedData, newEphemeralPub;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    _c = (0, exports.validateGetKvRequest)({
                        type: _type,
                        n: _n,
                        start: _start,
                        fwConstants: fwConstants,
                    }), type = _c.type, n = _c.n, start = _c.start;
                    data = (0, exports.encodeGetKvRecordsRequest)({ type: type, n: n, start: start });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.getKvRecords,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _d = _e.sent(), decryptedData = _d.decryptedData, newEphemeralPub = _d.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, (0, exports.decodeGetKvRecordsResponse)(decryptedData, fwConstants)];
            }
        });
    });
}
exports.getKvRecords = getKvRecords;
var validateGetKvRequest = function (_a) {
    var fwConstants = _a.fwConstants, n = _a.n, type = _a.type, start = _a.start;
    if (!fwConstants.kvActionsAllowed) {
        throw new Error('Unsupported. Please update firmware.');
    }
    if (!n || n < 1) {
        throw new Error('You must request at least one record.');
    }
    if (n > fwConstants.kvActionMaxNum) {
        throw new Error("You may only request up to ".concat(fwConstants.kvActionMaxNum, " records at once."));
    }
    if (type !== 0 && !type) {
        throw new Error('You must specify a type.');
    }
    if (start !== 0 && !start) {
        throw new Error('You must specify a type.');
    }
    return { fwConstants: fwConstants, n: n, type: type, start: start };
};
exports.validateGetKvRequest = validateGetKvRequest;
var encodeGetKvRecordsRequest = function (_a) {
    var type = _a.type, n = _a.n, start = _a.start;
    var payload = Buffer.alloc(9);
    payload.writeUInt32LE(type, 0);
    payload.writeUInt8(n, 4);
    payload.writeUInt32LE(start, 5);
    return payload;
};
exports.encodeGetKvRecordsRequest = encodeGetKvRecordsRequest;
var decodeGetKvRecordsResponse = function (data, fwConstants) {
    var off = 0;
    var nTotal = data.readUInt32BE(off);
    off += 4;
    var nFetched = parseInt(data.slice(off, off + 1).toString('hex'), 16);
    off += 1;
    if (nFetched > fwConstants.kvActionMaxNum)
        throw new Error('Too many records fetched. Firmware error.');
    var records = [];
    for (var i = 0; i < nFetched; i++) {
        var r = {};
        r.id = data.readUInt32BE(off);
        off += 4;
        r.type = data.readUInt32BE(off);
        off += 4;
        r.caseSensitive =
            parseInt(data.slice(off, off + 1).toString('hex'), 16) === 1
                ? true
                : false;
        off += 1;
        var keySz = parseInt(data.slice(off, off + 1).toString('hex'), 16);
        off += 1;
        r.key = data.slice(off, off + keySz - 1).toString();
        off += fwConstants.kvKeyMaxStrSz + 1;
        var valSz = parseInt(data.slice(off, off + 1).toString('hex'), 16);
        off += 1;
        r.val = data.slice(off, off + valSz - 1).toString();
        off += fwConstants.kvValMaxStrSz + 1;
        records.push(r);
    }
    return {
        records: records,
        total: nTotal,
        fetched: nFetched,
    };
};
exports.decodeGetKvRecordsResponse = decodeGetKvRecordsResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\getKvRecords.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\index.js", {"./addKvRecords":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\addKvRecords.js","./connect":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\connect.js","./fetchActiveWallet":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchActiveWallet.js","./fetchEncData":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\fetchEncData.js","./getAddresses":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getAddresses.js","./getKvRecords":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\getKvRecords.js","./pair":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\pair.js","./removeKvRecords":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\removeKvRecords.js","./sign":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\sign.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./addKvRecords"), exports);
__exportStar(require("./connect"), exports);
__exportStar(require("./fetchEncData"), exports);
__exportStar(require("./fetchActiveWallet"), exports);
__exportStar(require("./getAddresses"), exports);
__exportStar(require("./getKvRecords"), exports);
__exportStar(require("./pair"), exports);
__exportStar(require("./removeKvRecords"), exports);
__exportStar(require("./sign"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\pair.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/utilities":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Cpair.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePairRequest = exports.pair = void 0;
var protocol_1 = require("../protocol");
var utilities_1 = require("../shared/utilities");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
/**
 * If a pairing secret is provided, `pair` uses it to sign a hash of the public key, name, and
 * pairing secret. It then sends the name and signature to the device. If no pairing secret is
 * provided, `pair` sends a zero-length name buffer to the device.
 * @category Lattice
 * @returns The active wallet object.
 */
function pair(_a) {
    var client = _a.client, pairingSecret = _a.pairingSecret;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, appName, key, data, newEphemeralPub;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, appName = _b.appName, key = _b.key;
                    data = (0, exports.encodePairRequest)({ pairingSecret: pairingSecret, key: key, appName: appName });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.finalizePairing,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    newEphemeralPub = (_c.sent()).newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                        isPaired: true,
                    });
                    return [4 /*yield*/, client.fetchActiveWallet()];
                case 2:
                    _c.sent();
                    return [2 /*return*/, client.hasActiveWallet()];
            }
        });
    });
}
exports.pair = pair;
var encodePairRequest = function (_a) {
    var key = _a.key, pairingSecret = _a.pairingSecret, appName = _a.appName;
    // Build the payload data
    var pubKeyBytes = (0, utilities_1.getPubKeyBytes)(key);
    var nameBuf = Buffer.alloc(25);
    if (pairingSecret.length > 0) {
        // If a pairing secret of zero length is passed in, it usually indicates we want to cancel
        // the pairing attempt. In this case we pass a zero-length name buffer so the firmware can
        // know not to draw the error screen. Note that we still expect an error to come back
        // (RESP_ERR_PAIR_FAIL)
        nameBuf.write(appName);
    }
    var hash = (0, util_1.generateAppSecret)(pubKeyBytes, nameBuf, Buffer.from(pairingSecret));
    var sig = key.sign(hash); // returns an array, not a buffer
    var derSig = (0, util_1.toPaddedDER)(sig);
    var payload = Buffer.concat([nameBuf, derSig]);
    return payload;
};
exports.encodePairRequest = encodePairRequest;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\pair.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\removeKvRecords.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5CremoveKvRecords.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeRemoveKvRecordsRequest = exports.validateRemoveKvRequest = exports.removeKvRecords = void 0;
var protocol_1 = require("../protocol");
var validators_1 = require("../shared/validators");
/**
 * `removeKvRecords` takes in an array of ids and sends a request to remove them from the Lattice.
 * @category Lattice
 * @returns A callback with an error or null.
 */
function removeKvRecords(_a) {
    var client = _a.client, _type = _a.type, _ids = _a.ids;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, _c, type, ids, data, _d, decryptedData, newEphemeralPub;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    _c = (0, exports.validateRemoveKvRequest)({
                        fwConstants: fwConstants,
                        type: _type,
                        ids: _ids,
                    }), type = _c.type, ids = _c.ids;
                    data = (0, exports.encodeRemoveKvRecordsRequest)({
                        type: type,
                        ids: ids,
                        fwConstants: fwConstants,
                    });
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: data,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.removeKvRecords,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _d = _e.sent(), decryptedData = _d.decryptedData, newEphemeralPub = _d.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    return [2 /*return*/, decryptedData];
            }
        });
    });
}
exports.removeKvRecords = removeKvRecords;
var validateRemoveKvRequest = function (_a) {
    var fwConstants = _a.fwConstants, type = _a.type, ids = _a.ids;
    if (!fwConstants.kvActionsAllowed) {
        throw new Error('Unsupported. Please update firmware.');
    }
    if (!Array.isArray(ids) || ids.length < 1) {
        throw new Error('You must include one or more `ids` to removed.');
    }
    if (ids.length > fwConstants.kvRemoveMaxNum) {
        throw new Error("Only up to ".concat(fwConstants.kvRemoveMaxNum, " records may be removed at once."));
    }
    if (type !== 0 && !type) {
        throw new Error('You must specify a type.');
    }
    return { type: type, ids: ids };
};
exports.validateRemoveKvRequest = validateRemoveKvRequest;
var encodeRemoveKvRecordsRequest = function (_a) {
    var fwConstants = _a.fwConstants, type = _a.type, ids = _a.ids;
    var payload = Buffer.alloc(5 + 4 * fwConstants.kvRemoveMaxNum);
    payload.writeUInt32LE(type, 0);
    payload.writeUInt8(ids.length, 4);
    for (var i = 0; i < ids.length; i++) {
        var id = parseInt(ids[i]);
        payload.writeUInt32LE(id, 5 + 4 * i);
    }
    return payload;
};
exports.encodeRemoveKvRecordsRequest = encodeRemoveKvRecordsRequest;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\removeKvRecords.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\functions\\sign.js", {"../bitcoin":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\bitcoin.js","../constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../ethereum":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\ethereum.js","../genericSigning":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\genericSigning.js","../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","../shared/functions":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\functions.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js":"F:\\metamask-extension\\node_modules\\hash.js\\lib\\hash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cfunctions%5Csign.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeSignResponse = exports.encodeSignRequest = exports.sign = void 0;
var hash_js_1 = require("hash.js");
var bitcoin_1 = __importDefault(require("../bitcoin"));
var constants_1 = require("../constants");
var ethereum_1 = __importDefault(require("../ethereum"));
var genericSigning_1 = require("../genericSigning");
var protocol_1 = require("../protocol");
var functions_1 = require("../shared/functions");
var validators_1 = require("../shared/validators");
var util_1 = require("../util");
/**
 * `sign` builds and sends a request for signing to the device.
 * @category Lattice
 * @returns The response from the device.
 */
function sign(_a) {
    var client = _a.client, data = _a.data, currency = _a.currency, cachedData = _a.cachedData, nextCode = _a.nextCode;
    return __awaiter(this, void 0, void 0, function () {
        var _b, url, sharedSecret, ephemeralPub, fwConstants, wallet, _c, requestData, isGeneric, _d, payload, hasExtraPayloads, _e, decryptedData, newEphemeralPub, decodedResponse;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    _b = (0, validators_1.validateConnectedClient)(client), url = _b.url, sharedSecret = _b.sharedSecret, ephemeralPub = _b.ephemeralPub, fwConstants = _b.fwConstants;
                    wallet = (0, validators_1.validateWallet)(client.getActiveWallet());
                    _c = (0, functions_1.buildTransaction)({
                        data: data,
                        currency: currency,
                        fwConstants: fwConstants,
                    }), requestData = _c.requestData, isGeneric = _c.isGeneric;
                    _d = (0, exports.encodeSignRequest)({
                        fwConstants: fwConstants,
                        wallet: wallet,
                        requestData: requestData,
                        cachedData: cachedData,
                        nextCode: nextCode,
                    }), payload = _d.payload, hasExtraPayloads = _d.hasExtraPayloads;
                    return [4 /*yield*/, (0, protocol_1.encryptedSecureRequest)({
                            data: payload,
                            requestType: protocol_1.LatticeSecureEncryptedRequestType.sign,
                            sharedSecret: sharedSecret,
                            ephemeralPub: ephemeralPub,
                            url: url,
                        })];
                case 1:
                    _e = _f.sent(), decryptedData = _e.decryptedData, newEphemeralPub = _e.newEphemeralPub;
                    client.mutate({
                        ephemeralPub: newEphemeralPub,
                    });
                    // If this request has multiple payloads, we need to recurse
                    // so that we can make the next request.
                    // It is chained to the first request using `nextCode`
                    if (hasExtraPayloads) {
                        return [2 /*return*/, client.sign({
                                data: data,
                                currency: currency,
                                cachedData: requestData,
                                nextCode: decryptedData.slice(0, 8),
                            })];
                    }
                    decodedResponse = (0, exports.decodeSignResponse)({
                        data: decryptedData,
                        request: requestData,
                        isGeneric: isGeneric,
                        currency: currency,
                    });
                    return [2 /*return*/, decodedResponse];
            }
        });
    });
}
exports.sign = sign;
var encodeSignRequest = function (_a) {
    var _b, _c, _d;
    var fwConstants = _a.fwConstants, wallet = _a.wallet, requestData = _a.requestData, cachedData = _a.cachedData, nextCode = _a.nextCode;
    var reqPayload, schema;
    if (cachedData && nextCode) {
        requestData = cachedData;
        reqPayload = Buffer.concat([
            nextCode,
            requestData.extraDataPayloads.shift(),
        ]);
        schema = protocol_1.LatticeSignSchema.extraData;
    }
    else {
        reqPayload = requestData.payload;
        schema = requestData.schema;
    }
    var payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);
    var off = 0;
    var hasExtraPayloads = requestData.extraDataPayloads &&
        Number(requestData.extraDataPayloads.length > 0);
    payload.writeUInt8(hasExtraPayloads, off);
    off += 1;
    // Copy request schema (e.g. ETH or BTC transfer)
    payload.writeUInt8(schema, off);
    off += 1;
    // Copy the wallet UID
    (_b = wallet.uid) === null || _b === void 0 ? void 0 : _b.copy(payload, off);
    off += (_d = (_c = wallet.uid) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
    // Build data based on the type of request
    reqPayload.copy(payload, off);
    return { payload: payload, hasExtraPayloads: hasExtraPayloads };
};
exports.encodeSignRequest = encodeSignRequest;
var decodeSignResponse = function (_a) {
    var _b;
    var data = _a.data, request = _a.request, isGeneric = _a.isGeneric, currency = _a.currency;
    var off = 0;
    var derSigLen = 74; // DER signatures are 74 bytes
    if (currency === constants_1.CURRENCIES.BTC) {
        var btcRequest = request;
        var pkhLen = 20; // Pubkeyhashes are 20 bytes
        var sigsLen = 740; // Up to 10x DER signatures
        var changeVersion = bitcoin_1.default.getAddressFormat(btcRequest.origData.changePath);
        var changePubKeyHash = data.slice(off, off + pkhLen);
        off += pkhLen;
        var changeRecipient = bitcoin_1.default.getBitcoinAddress(changePubKeyHash, changeVersion);
        var compressedPubLength = 33; // Size of compressed public key
        var pubkeys = [];
        var sigs = [];
        var n = 0;
        // Parse the signature for each output -- they are returned in the serialized payload in form
        // [pubkey, sig] There is one signature per output
        while (off < data.length) {
            // Exit out if we have seen all the returned sigs and pubkeys
            if (data[off] !== 0x30)
                break;
            // Otherwise grab another set Note that all DER sigs returned fill the maximum 74 byte
            // buffer, but also contain a length at off+1, which we use to parse the non-zero data.
            // First get the signature from its slot
            var sigStart = off;
            var sigEnd = off + 2 + data[off + 1];
            sigs.push(data.slice(sigStart, sigEnd));
            off += derSigLen;
            // Next, shift by the full set of signatures to hit the respective pubkey NOTE: The data
            // returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]
            var pubStart = n * compressedPubLength + sigsLen;
            var pubEnd = (n + 1) * compressedPubLength + sigsLen;
            pubkeys.push(data.slice(pubStart, pubEnd));
            // Update offset to hit the next signature slot
            n += 1;
        }
        // Build the transaction data to be serialized
        var preSerializedData = {
            inputs: [],
            outputs: [],
        };
        // First output comes from request dta
        preSerializedData.outputs.push({
            value: btcRequest.origData.value,
            recipient: btcRequest.origData.recipient,
        });
        if (((_b = btcRequest.changeData) === null || _b === void 0 ? void 0 : _b.value) && btcRequest.changeData.value > 0) {
            // Second output comes from change data
            preSerializedData.outputs.push({
                value: btcRequest.changeData.value,
                recipient: changeRecipient,
            });
        }
        // Add the inputs
        for (var i = 0; i < sigs.length; i++) {
            preSerializedData.inputs.push({
                hash: btcRequest.origData.prevOuts[i].txHash,
                index: btcRequest.origData.prevOuts[i].index,
                sig: sigs[i],
                pubkey: pubkeys[i],
                signerPath: btcRequest.origData.prevOuts[i].signerPath,
            });
        }
        // Finally, serialize the transaction
        var serializedTx = bitcoin_1.default.serializeTx(preSerializedData);
        // Generate the transaction hash so the user can look this transaction up later
        var preImageTxHash = serializedTx;
        var txHashPre = Buffer.from((0, hash_js_1.sha256)().update(Buffer.from(preImageTxHash, 'hex')).digest('hex'), 'hex');
        // Add extra data for debugging/lookup purposes
        return {
            tx: serializedTx,
            txHash: (0, hash_js_1.sha256)().update(txHashPre).digest('hex'),
            changeRecipient: changeRecipient,
            sigs: sigs,
        };
    }
    else if (currency === constants_1.CURRENCIES.ETH && !isGeneric) {
        var sig = (0, util_1.parseDER)(data.slice(off, off + 2 + data[off + 1]));
        off += derSigLen;
        var ethAddr = data.slice(off, off + 20);
        // Determine the `v` param and add it to the sig before returning
        var _c = ethereum_1.default.buildEthRawTx(request, sig, ethAddr), rawTx = _c.rawTx, sigWithV = _c.sigWithV;
        return {
            tx: "0x".concat(rawTx),
            txHash: "0x".concat(ethereum_1.default.hashTransaction(rawTx)),
            sig: {
                v: sigWithV.v,
                r: sigWithV.r.toString('hex'),
                s: sigWithV.s.toString('hex'),
            },
            signer: ethAddr,
        };
    }
    else if (currency === constants_1.CURRENCIES.ETH_MSG) {
        var sig = (0, util_1.parseDER)(data.slice(off, off + 2 + data[off + 1]));
        off += derSigLen;
        var signer = data.slice(off, off + 20);
        var validatedSig = ethereum_1.default.validateEthereumMsgResponse({ signer: signer, sig: sig }, request);
        return {
            sig: {
                v: validatedSig.v,
                r: validatedSig.r.toString('hex'),
                s: validatedSig.s.toString('hex'),
            },
            signer: signer,
        };
    }
    else {
        // Generic signing request
        return (0, genericSigning_1.parseGenericSigningResponse)(data, off, request);
    }
};
exports.decodeSignResponse = decodeSignResponse;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\functions\\sign.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\genericSigning.js", {"./constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./index":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js","./protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js/lib/hash/sha":"F:\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\sha.js","js-sha3":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5CgenericSigning.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncodedPayload = exports.parseGenericSigningResponse = exports.buildGenericSigningMsgRequest = void 0;
/**
Generic signing module. Any payload can be sent to the Lattice and
will be displayed in full (note that \n and \t characters will be
displayed as line breaks and tabs on the screen).

This payload should be coupled with:
* Signer's BIP44 path
* Curve on which to derive the signing key
* Hash function to use on the message
*/
var sha_1 = require("hash.js/lib/hash/sha");
var js_sha3_1 = require("js-sha3");
var constants_1 = require("./constants");
var index_1 = require("./index");
var protocol_1 = require("./protocol");
var util_1 = require("./util");
var buildGenericSigningMsgRequest = function (req) {
    var signerPath = req.signerPath, curveType = req.curveType, hashType = req.hashType, _a = req.encodingType, encodingType = _a === void 0 ? null : _a, _b = req.decoder, decoder = _b === void 0 ? null : _b, _c = req.omitPubkey, omitPubkey = _c === void 0 ? false : _c, fwConstants = req.fwConstants, _d = req.blsDst, blsDst = _d === void 0 ? index_1.Constants.SIGNING.BLS_DST.BLS_DST_NUL : _d;
    var extraDataFrameSz = fwConstants.extraDataFrameSz, extraDataMaxFrames = fwConstants.extraDataMaxFrames, prehashAllowed = fwConstants.prehashAllowed, genericSigning = fwConstants.genericSigning, varAddrPathSzAllowed = fwConstants.varAddrPathSzAllowed;
    var curveTypes = genericSigning.curveTypes, encodingTypes = genericSigning.encodingTypes, hashTypes = genericSigning.hashTypes, baseDataSz = genericSigning.baseDataSz, baseReqSz = genericSigning.baseReqSz, calldataDecoding = genericSigning.calldataDecoding;
    var encodedPayload = (0, exports.getEncodedPayload)(req.payload, encodingType, encodingTypes);
    var encoding = encodedPayload.encoding;
    var payloadBuf = encodedPayload.payloadBuf;
    var origPayloadBuf = payloadBuf;
    var payloadDataSz = payloadBuf.length;
    // Size of data payload that can be included in the first/base request
    var maxExpandedSz = baseDataSz + extraDataMaxFrames * extraDataFrameSz;
    // Sanity checks
    if (!payloadDataSz) {
        throw new Error('Payload could not be handled.');
    }
    else if (!genericSigning ||
        !extraDataFrameSz ||
        !extraDataMaxFrames ||
        !prehashAllowed) {
        throw new Error('Unsupported. Please update your Lattice firmware.');
    }
    else if (!(0, util_1.existsIn)(curveType, curveTypes)) {
        throw new Error('Unsupported curve type.');
    }
    else if (!(0, util_1.existsIn)(hashType, hashTypes)) {
        throw new Error('Unsupported hash type.');
    }
    // If there is a decoder attached to our payload, add it to
    // the data field of the request.
    var hasDecoder = (decoder && calldataDecoding && decoder.length <= calldataDecoding.maxSz);
    // Make sure the payload AND decoder data fits in the firmware buffer.
    // If it doesn't, we can't include the decoder because the payload will likely
    // be pre-hashed and the decoder data isn't part of the message to sign.
    var decoderFits = (hasDecoder && payloadBuf.length + decoder.length <= maxExpandedSz);
    if (hasDecoder && decoderFits) {
        var decoderBuf = Buffer.alloc(8 + decoder.length);
        // First write th reserved word
        decoderBuf.writeUInt32LE(calldataDecoding.reserved, 0);
        // Then write size, then the data
        decoderBuf.writeUInt32LE(decoder.length, 4);
        Buffer.from(decoder).copy(decoderBuf, 8);
        payloadBuf = Buffer.concat([payloadBuf, decoderBuf]);
    }
    // Ed25519 specific sanity checks
    if (curveType === curveTypes.ED25519) {
        if (hashType !== hashTypes.NONE) {
            throw new Error('Signing on ed25519 requires unhashed message');
        }
        signerPath.forEach(function (idx) {
            if (idx < constants_1.HARDENED_OFFSET) {
                throw new Error('Signing on ed25519 requires all signer path indices be hardened.');
            }
        });
    }
    // BLS12_381 specific processing
    else if (curveType === curveTypes.BLS12_381_G2) {
        // For BLS signing we need to prefix 4 bytes to represent the
        // domain separator (DST). If none is provided, we use the default
        // value of DST_NUL.
        var blsDstBuf = Buffer.alloc(4);
        blsDstBuf.writeUInt32LE(blsDst);
        payloadBuf = Buffer.concat([blsDstBuf, payloadBuf]);
        payloadDataSz += blsDstBuf.length;
    }
    // Build the request buffer with metadata and then the payload to sign.
    var buf = Buffer.alloc(baseReqSz);
    var off = 0;
    buf.writeUInt32LE(encoding, off);
    off += 4;
    buf.writeUInt8(hashType, off);
    off += 1;
    buf.writeUInt8(curveType, off);
    off += 1;
    var signerPathBuf = (0, util_1.buildSignerPathBuf)(signerPath, varAddrPathSzAllowed);
    signerPathBuf.copy(buf, off);
    off += signerPathBuf.length;
    buf.writeUInt8(omitPubkey ? 1 : 0, off);
    off += 1;
    // Flow data into extraData requests if applicable
    var extraDataPayloads = [];
    var prehash = null;
    var didPrehash = false;
    if (payloadBuf.length > baseDataSz) {
        if (prehashAllowed && payloadBuf.length > maxExpandedSz) {
            // If we prehash, we need to provide the full payload size
            buf.writeUInt16LE(payloadBuf.length, off);
            off += 2;
            didPrehash = true;
            // If we have to prehash, only hash the actual payload data, i.e. exclude
            // any optional calldata decoder data.
            var payloadData = payloadBuf.slice(0, payloadDataSz);
            // If this payload is too large to send, but the Lattice allows a prehashed message, do that
            if (hashType === hashTypes.NONE) {
                // This cannot be done for ED25519 signing, which must sign the full message
                throw new Error('Message too large to send and could not be prehashed (hashType=NONE).');
            }
            else if (hashType === hashTypes.KECCAK256) {
                prehash = Buffer.from((0, js_sha3_1.keccak256)(payloadData), 'hex');
            }
            else if (hashType === hashTypes.SHA256) {
                prehash = Buffer.from((0, sha_1.sha256)().update(payloadData).digest('hex'), 'hex');
            }
            else {
                throw new Error('Unsupported hash type.');
            }
        }
        else {
            // Split overflow data into extraData frames
            var frames_1 = (0, util_1.splitFrames)(payloadBuf.slice(baseDataSz), extraDataFrameSz);
            frames_1.forEach(function (frame) {
                var szLE = Buffer.alloc(4);
                szLE.writeUInt32LE(frame.length, 0);
                extraDataPayloads.push(Buffer.concat([szLE, frame]));
            });
        }
    }
    // If we didn't prehash, we know the full request (including calldata info) fits.
    // Set the payload size to only include message data. This will inform firmware
    // where to slice off calldata info.
    if (!didPrehash) {
        buf.writeUInt16LE(payloadDataSz, off);
        off += 2;
    }
    // If the message had to be prehashed, we will only copy the hash data into the request.
    // Otherwise copy as many payload bytes into the request as possible. Follow up data
    // from `frames` will come in follow up requests.
    var toCopy = prehash ? prehash : payloadBuf;
    toCopy.copy(buf, off);
    // Return all the necessary data
    return {
        payload: buf,
        extraDataPayloads: extraDataPayloads,
        schema: protocol_1.LatticeSignSchema.generic,
        curveType: curveType,
        encodingType: encodingType,
        hashType: hashType,
        omitPubkey: omitPubkey,
        origPayloadBuf: origPayloadBuf,
    };
};
exports.buildGenericSigningMsgRequest = buildGenericSigningMsgRequest;
var parseGenericSigningResponse = function (res, off, req) {
    var parsed = {
        pubkey: null,
        sig: null,
    };
    // Parse BIP44 path
    // Parse pubkey and then sig
    if (req.curveType === index_1.Constants.SIGNING.CURVES.SECP256K1) {
        // Handle `GpEccPubkey256_t`
        if (!req.omitPubkey) {
            var compression = res.readUInt8(off);
            off += 1;
            if (compression === 0x02 || compression === 0x03) {
                // Compressed key - only copy x
                parsed.pubkey = Buffer.alloc(33);
                parsed.pubkey.writeUInt8(compression, 0);
                res.slice(off, off + 32).copy(parsed.pubkey, 1);
            }
            else if (compression === 0x04) {
                // Uncompressed key
                parsed.pubkey = Buffer.alloc(65);
                parsed.pubkey.writeUInt8(compression, 0);
                res.slice(off).copy(parsed.pubkey, 1);
            }
            else {
                throw new Error('Bad compression byte in signing response.');
            }
            off += 64;
        }
        else {
            // Skip pubkey section
            off += 65;
        }
        // Handle `GpECDSASig_t`
        parsed.sig = (0, util_1.parseDER)(res.slice(off, off + 2 + res[off + 1]));
        // Remove any leading zeros in signature components to ensure
        // the result is a 64 byte sig
        parsed.sig.r = (0, util_1.fixLen)(parsed.sig.r, 32);
        parsed.sig.s = (0, util_1.fixLen)(parsed.sig.s, 32);
        // If this is an EVM request, we want to add a `v`. Other request
        // types do not require this additional signature param.
        if (req.encodingType === index_1.Constants.SIGNING.ENCODINGS.EVM) {
            var vBn = (0, util_1.getV)(req.origPayloadBuf, parsed);
            // NOTE: For backward-compatibility reasons we are returning
            // a Buffer for `v` here. In the future, we will switch to
            // returning `v` as a BN and `r`,`s` as Buffers (they are hex
            // strings right now).
            parsed.sig.v = vBn.toArrayLike(Buffer);
        }
    }
    else if (req.curveType === index_1.Constants.SIGNING.CURVES.ED25519) {
        if (!req.omitPubkey) {
            // Handle `GpEdDSAPubkey_t`
            parsed.pubkey = Buffer.alloc(32);
            res.slice(off, off + 32).copy(parsed.pubkey);
        }
        off += 32;
        // Handle `GpEdDSASig_t`
        parsed.sig = {
            r: res.slice(off, off + 32),
            s: res.slice(off + 32, off + 64),
        };
    }
    else if (req.curveType === index_1.Constants.SIGNING.CURVES.BLS12_381_G2) {
        if (!req.omitPubkey) {
            // Handle `GpBLS12_381_G1Pub_t`
            parsed.pubkey = Buffer.alloc(48);
            res.slice(off, off + 48).copy(parsed.pubkey);
        }
        off += 48;
        // Handle `GpBLS12_381_G2Sig_t`
        parsed.sig = Buffer.alloc(96);
        res.slice(off, off + 96).copy(parsed.sig);
    }
    else {
        throw new Error('Unsupported curve.');
    }
    return parsed;
};
exports.parseGenericSigningResponse = parseGenericSigningResponse;
var getEncodedPayload = function (payload, encoding, allowedEncodings) {
    if (!encoding) {
        encoding = index_1.Constants.SIGNING.ENCODINGS.NONE;
    }
    // Make sure the encoding type specified is supported by firmware
    if (!(0, util_1.existsIn)(encoding, allowedEncodings)) {
        throw new Error('Encoding not supported by Lattice firmware. You may want to update.');
    }
    var payloadBuf;
    if (!payload) {
        throw new Error('No payload included');
    }
    if (typeof payload === 'string' && payload.slice(0, 2) === '0x') {
        payloadBuf = Buffer.from(payload.slice(2), 'hex');
    }
    else {
        payloadBuf = Buffer.from(payload);
    }
    // Build the request with the specified encoding type
    return {
        payloadBuf: payloadBuf,
        encoding: encoding,
    };
};
exports.getEncodedPayload = getEncodedPayload;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\genericSigning.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js", {"./api":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\api\\index.js","./calldata/index":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\calldata\\index.js","./client":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\client.js","./constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = exports.Constants = exports.Client = exports.Calldata = void 0;
var index_1 = require("./calldata/index");
Object.defineProperty(exports, "Calldata", { enumerable: true, get: function () { return index_1.CALLDATA; } });
var client_1 = require("./client");
Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
var constants_1 = require("./constants");
Object.defineProperty(exports, "Constants", { enumerable: true, get: function () { return constants_1.EXTERNAL; } });
var util_1 = require("./util");
Object.defineProperty(exports, "Utils", { enumerable: true, get: function () { return util_1.EXTERNAL; } });
__exportStar(require("./api"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js", {"./latticeConstants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js","./secureMessages":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\secureMessages.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cprotocol%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./latticeConstants"), exports);
__exportStar(require("./secureMessages"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\protocol\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cprotocol%5ClatticeConstants.js
      return function (require, module, exports) {
"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtocolConstants = exports.LatticeEncDataSchema = exports.LatticeSignBlsDst = exports.LatticeSignEncoding = exports.LatticeSignCurve = exports.LatticeSignHash = exports.LatticeSignSchema = exports.LatticeGetAddressesFlag = exports.LatticeSecureEncryptedRequestType = exports.LatticeMsgType = exports.LatticeProtocolVersion = exports.LatticeSecureMsgType = exports.LatticeResponseCode = void 0;
var LatticeResponseCode;
(function (LatticeResponseCode) {
    LatticeResponseCode[LatticeResponseCode["success"] = 0] = "success";
    LatticeResponseCode[LatticeResponseCode["invalidMsg"] = 128] = "invalidMsg";
    LatticeResponseCode[LatticeResponseCode["unsupportedVersion"] = 129] = "unsupportedVersion";
    LatticeResponseCode[LatticeResponseCode["deviceBusy"] = 130] = "deviceBusy";
    LatticeResponseCode[LatticeResponseCode["userTimeout"] = 131] = "userTimeout";
    LatticeResponseCode[LatticeResponseCode["userDeclined"] = 132] = "userDeclined";
    LatticeResponseCode[LatticeResponseCode["pairFailed"] = 133] = "pairFailed";
    LatticeResponseCode[LatticeResponseCode["pairDisabled"] = 134] = "pairDisabled";
    LatticeResponseCode[LatticeResponseCode["permissionDisabled"] = 135] = "permissionDisabled";
    LatticeResponseCode[LatticeResponseCode["internalError"] = 136] = "internalError";
    LatticeResponseCode[LatticeResponseCode["gceTimeout"] = 137] = "gceTimeout";
    LatticeResponseCode[LatticeResponseCode["wrongWallet"] = 138] = "wrongWallet";
    LatticeResponseCode[LatticeResponseCode["deviceLocked"] = 139] = "deviceLocked";
    LatticeResponseCode[LatticeResponseCode["disabled"] = 140] = "disabled";
    LatticeResponseCode[LatticeResponseCode["already"] = 141] = "already";
    LatticeResponseCode[LatticeResponseCode["invalidEphemId"] = 142] = "invalidEphemId";
})(LatticeResponseCode = exports.LatticeResponseCode || (exports.LatticeResponseCode = {}));
var LatticeSecureMsgType;
(function (LatticeSecureMsgType) {
    LatticeSecureMsgType[LatticeSecureMsgType["connect"] = 1] = "connect";
    LatticeSecureMsgType[LatticeSecureMsgType["encrypted"] = 2] = "encrypted";
})(LatticeSecureMsgType = exports.LatticeSecureMsgType || (exports.LatticeSecureMsgType = {}));
var LatticeProtocolVersion;
(function (LatticeProtocolVersion) {
    LatticeProtocolVersion[LatticeProtocolVersion["v1"] = 1] = "v1";
})(LatticeProtocolVersion = exports.LatticeProtocolVersion || (exports.LatticeProtocolVersion = {}));
var LatticeMsgType;
(function (LatticeMsgType) {
    LatticeMsgType[LatticeMsgType["response"] = 0] = "response";
    LatticeMsgType[LatticeMsgType["secure"] = 2] = "secure";
})(LatticeMsgType = exports.LatticeMsgType || (exports.LatticeMsgType = {}));
var LatticeSecureEncryptedRequestType;
(function (LatticeSecureEncryptedRequestType) {
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["finalizePairing"] = 0] = "finalizePairing";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["getAddresses"] = 1] = "getAddresses";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["sign"] = 3] = "sign";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["getWallets"] = 4] = "getWallets";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["getKvRecords"] = 7] = "getKvRecords";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["addKvRecords"] = 8] = "addKvRecords";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["removeKvRecords"] = 9] = "removeKvRecords";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["fetchEncryptedData"] = 12] = "fetchEncryptedData";
    LatticeSecureEncryptedRequestType[LatticeSecureEncryptedRequestType["test"] = 13] = "test";
})(LatticeSecureEncryptedRequestType = exports.LatticeSecureEncryptedRequestType || (exports.LatticeSecureEncryptedRequestType = {}));
var LatticeGetAddressesFlag;
(function (LatticeGetAddressesFlag) {
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["none"] = 0] = "none";
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["secp256k1Pubkey"] = 3] = "secp256k1Pubkey";
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["ed25519Pubkey"] = 4] = "ed25519Pubkey";
    LatticeGetAddressesFlag[LatticeGetAddressesFlag["bls12_381Pubkey"] = 5] = "bls12_381Pubkey";
})(LatticeGetAddressesFlag = exports.LatticeGetAddressesFlag || (exports.LatticeGetAddressesFlag = {}));
var LatticeSignSchema;
(function (LatticeSignSchema) {
    LatticeSignSchema[LatticeSignSchema["bitcoin"] = 0] = "bitcoin";
    LatticeSignSchema[LatticeSignSchema["ethereum"] = 1] = "ethereum";
    LatticeSignSchema[LatticeSignSchema["ethereumMsg"] = 3] = "ethereumMsg";
    LatticeSignSchema[LatticeSignSchema["extraData"] = 4] = "extraData";
    LatticeSignSchema[LatticeSignSchema["generic"] = 5] = "generic";
})(LatticeSignSchema = exports.LatticeSignSchema || (exports.LatticeSignSchema = {}));
var LatticeSignHash;
(function (LatticeSignHash) {
    LatticeSignHash[LatticeSignHash["none"] = 0] = "none";
    LatticeSignHash[LatticeSignHash["keccak256"] = 1] = "keccak256";
    LatticeSignHash[LatticeSignHash["sha256"] = 2] = "sha256";
})(LatticeSignHash = exports.LatticeSignHash || (exports.LatticeSignHash = {}));
var LatticeSignCurve;
(function (LatticeSignCurve) {
    LatticeSignCurve[LatticeSignCurve["secp256k1"] = 0] = "secp256k1";
    LatticeSignCurve[LatticeSignCurve["ed25519"] = 1] = "ed25519";
    LatticeSignCurve[LatticeSignCurve["bls12_381"] = 2] = "bls12_381";
})(LatticeSignCurve = exports.LatticeSignCurve || (exports.LatticeSignCurve = {}));
var LatticeSignEncoding;
(function (LatticeSignEncoding) {
    LatticeSignEncoding[LatticeSignEncoding["none"] = 1] = "none";
    LatticeSignEncoding[LatticeSignEncoding["solana"] = 2] = "solana";
    LatticeSignEncoding[LatticeSignEncoding["evm"] = 4] = "evm";
    LatticeSignEncoding[LatticeSignEncoding["eth_deposit"] = 5] = "eth_deposit";
})(LatticeSignEncoding = exports.LatticeSignEncoding || (exports.LatticeSignEncoding = {}));
var LatticeSignBlsDst;
(function (LatticeSignBlsDst) {
    LatticeSignBlsDst[LatticeSignBlsDst["NUL"] = 1] = "NUL";
    LatticeSignBlsDst[LatticeSignBlsDst["POP"] = 2] = "POP";
})(LatticeSignBlsDst = exports.LatticeSignBlsDst || (exports.LatticeSignBlsDst = {}));
var LatticeEncDataSchema;
(function (LatticeEncDataSchema) {
    LatticeEncDataSchema[LatticeEncDataSchema["eip2335"] = 0] = "eip2335";
})(LatticeEncDataSchema = exports.LatticeEncDataSchema || (exports.LatticeEncDataSchema = {}));
exports.ProtocolConstants = {
    // Lattice firmware uses a static initialization vector for
    // message encryption/decryption. This is generally considered
    // fine because each encryption/decryption uses a unique encryption
    // secret (derived from the per-message ephemeral key pair).
    aesIv: [
        0x6d, 0x79, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x70, 0x61, 0x73, 0x73,
        0x77, 0x6f, 0x72, 0x64,
    ],
    // Constant size of address buffers from the Lattice.
    // Note that this size also captures public keys returned
    // by the Lattice (addresses = strings, pubkeys = buffers)
    addrStrLen: 129,
    // Status of the client's pairing with the target Lattice
    pairingStatus: {
        notPaired: 0x00,
        paired: 0x01,
    },
    // Response types, codes, and error messages
    responseMsg: (_a = {},
        _a[LatticeResponseCode.success] = '',
        _a[LatticeResponseCode.invalidMsg] = 'Invalid Request',
        _a[LatticeResponseCode.unsupportedVersion] = 'Unsupported Version',
        _a[LatticeResponseCode.deviceBusy] = 'Device Busy',
        _a[LatticeResponseCode.userTimeout] = 'Timeout waiting for user',
        _a[LatticeResponseCode.userDeclined] = 'Request declined by user',
        _a[LatticeResponseCode.pairFailed] = 'Pairing failed',
        _a[LatticeResponseCode.pairDisabled] = 'Pairing is currently disabled',
        _a[LatticeResponseCode.permissionDisabled] = 'Automated signing is currently disabled',
        _a[LatticeResponseCode.internalError] = 'Device Error',
        _a[LatticeResponseCode.gceTimeout] = 'Device Timeout',
        _a[LatticeResponseCode.wrongWallet] = 'Active wallet does not match request',
        _a[LatticeResponseCode.deviceLocked] = 'Device Locked',
        _a[LatticeResponseCode.disabled] = 'Feature Disabled',
        _a[LatticeResponseCode.already] = 'Record already exists on device',
        _a[LatticeResponseCode.invalidEphemId] = 'Request failed - needs resync',
        _a),
    msgSizes: {
        // General message header size. Valid for all Lattice messages
        header: 8,
        // Checksum must be appended to each message
        checksum: 4,
        // Lattice secure message constants. All requests from this SDK
        // are secure messages.
        secure: {
            // Sizes of full payloads for secure messages
            payload: {
                request: {
                    // [ requestType (1 byte) | pubkey (65 bytes) ]
                    connect: 66,
                    // [ requestType (1 byte) | ephemeralId (4 bytes) | encryptedData (1728 bytes) ]
                    encrypted: 1733,
                },
                // Note that the response payload always has status code as the
                // first byte. This byte is removed as part of `request`, inside
                // `parseLattice1Response`. These constants include the status
                // code byte.
                response: {
                    connect: 215,
                    // Encrypted responses are as follows:
                    // encryptedData (1728) | empty (1728)
                    // The latter half is empty due to an invalid type definition
                    // in Lattice firmware. (Someone made a C `struct` instead of
                    // a `union`, oops).
                    encrypted: 3457,
                },
            },
            // Sizes for data inside secure message payloads
            data: {
                // All requests also have a `requestCode`, which is omitted
                // from these constants.
                request: {
                    connect: 65,
                    encrypted: (_b = {
                            // All encrypted requests are encrypted into a 1728 byte buffer
                            encryptedData: 1728
                        },
                        // Individual request types have different data sizes.
                        _b[LatticeSecureEncryptedRequestType.finalizePairing] = 99,
                        _b[LatticeSecureEncryptedRequestType.getAddresses] = 54,
                        _b[LatticeSecureEncryptedRequestType.sign] = 1680,
                        _b[LatticeSecureEncryptedRequestType.getWallets] = 0,
                        _b[LatticeSecureEncryptedRequestType.getKvRecords] = 9,
                        _b[LatticeSecureEncryptedRequestType.addKvRecords] = 1391,
                        _b[LatticeSecureEncryptedRequestType.removeKvRecords] = 405,
                        _b[LatticeSecureEncryptedRequestType.fetchEncryptedData] = 1025,
                        _b[LatticeSecureEncryptedRequestType.test] = 506,
                        _b),
                },
                // All responses also have a `responseCode`, which is omitted
                // from these constants.
                response: {
                    encrypted: (_c = {
                            encryptedData: 1728
                        },
                        // Once decrypted, the data size of the response
                        // payload will be determined by the request type.
                        // NOTE: All requests also have ephemeralPublicKey (65 bytes) and
                        // checksum (4 bytes), which are excluded from these sizes.
                        _c[LatticeSecureEncryptedRequestType.finalizePairing] = 0,
                        _c[LatticeSecureEncryptedRequestType.getAddresses] = 1290,
                        _c[LatticeSecureEncryptedRequestType.sign] = 1090,
                        _c[LatticeSecureEncryptedRequestType.getWallets] = 142,
                        _c[LatticeSecureEncryptedRequestType.getKvRecords] = 1395,
                        _c[LatticeSecureEncryptedRequestType.addKvRecords] = 0,
                        _c[LatticeSecureEncryptedRequestType.removeKvRecords] = 0,
                        _c[LatticeSecureEncryptedRequestType.fetchEncryptedData] = 1608,
                        _c[LatticeSecureEncryptedRequestType.test] = 1646,
                        _c),
                },
            },
        },
    },
};

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\secureMessages.js", {"../shared/functions":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\functions.js","../shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","../util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","./latticeConstants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\latticeConstants.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cprotocol%5CsecureMessages.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encryptedSecureRequest = exports.connectSecureRequest = void 0;
/**
 * All messages sent to the Lattice from this SDK will be
 * "secure messages", of which there are two types:
 *
 * 1. Connect requests are *unencrypted* and serve to establish
 *    a connection between the SDK Client instance and the target
 *    Lattice. If the client is already paired to the target Lattice,
 *    the response will indicate that. If the client has never paired
 *    with this Lattice, the Lattice will go into "pairing mode" and
 *    will expect a follow up `finalizePairing` request, which is
 *    an encrypted request. This will return an ephemeral public key,
 *    which is used to encrypt the next request.
 * 2. Encrypted requests are *encrypted* (obviously) and from a Lattice
 *    protocol perspective they are all constructed the same way:
 *    create a buffer of `payload` length and fill it with unencrypted
 *    data, then encrypt the entire payload (not just the data you filled)
 *    with the ECDH secret formed from the last ephemeral public key.
 *    The response to this request will contain a new ephemral public
 *    key, which you will need for the next encrypted request.
 */
var latticeConstants_1 = require("./latticeConstants");
var util_1 = require("../util");
var functions_1 = require("../shared/functions");
var validators_1 = require("../shared/validators");
var msgSizes = latticeConstants_1.ProtocolConstants.msgSizes;
var szs = msgSizes.secure;
/**
 * Build and make a request to connect to a specific Lattice
 * based on its `deviceId`.
 * @param deviceId - Device ID for the target Lattice. Must be in
 *                   the same `client.baseUrl` domain to be found.
 * @return {Buffer} - Connection response payload data, which contains
 *                    information about the connected Lattice.
 */
function connectSecureRequest(_a) {
    var url = _a.url, pubkey = _a.pubkey;
    return __awaiter(this, void 0, void 0, function () {
        var payloadData, msgId, msg, resp;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    payloadData = serializeSecureRequestConnectPayloadData({
                        pubkey: pubkey,
                    });
                    msgId = (0, util_1.randomBytes)(4);
                    msg = serializeSecureRequestMsg(msgId, latticeConstants_1.LatticeSecureMsgType.connect, payloadData);
                    return [4 /*yield*/, (0, functions_1.request)({ url: url, payload: msg })];
                case 1:
                    resp = _b.sent();
                    if (resp.length !== szs.payload.response.connect - 1) {
                        throw new Error('Wrong Lattice response message size.');
                    }
                    return [2 /*return*/, resp];
            }
        });
    });
}
exports.connectSecureRequest = connectSecureRequest;
/**
 * Build an encrypted secure request using raw data,
 * then send that request to the target Lattice, handle
 * the response, and return the *decrypted* response
 * payload data.
 * Also updates ephemeral public key in the client.
 * This is a wrapper around several local util functions.
 * @param data - Unencrypted raw calldata for function
 * @param requestType - Type of encrypted reques to make
 * @return {Buffer} Decrypted response data (excluding metadata)
 */
function encryptedSecureRequest(_a) {
    var data = _a.data, requestType = _a.requestType, sharedSecret = _a.sharedSecret, ephemeralPub = _a.ephemeralPub, url = _a.url;
    return __awaiter(this, void 0, void 0, function () {
        var msgId, payloadData, msg, resp, encPayloadData;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    msgId = (0, util_1.randomBytes)(4);
                    payloadData = serializeSecureRequestEncryptedPayloadData({
                        data: data,
                        requestType: requestType,
                        ephemeralPub: ephemeralPub,
                        sharedSecret: sharedSecret,
                    });
                    msg = serializeSecureRequestMsg(msgId, latticeConstants_1.LatticeSecureMsgType.encrypted, payloadData);
                    return [4 /*yield*/, (0, functions_1.request)({
                            url: url,
                            payload: msg,
                        })];
                case 1:
                    resp = _b.sent();
                    // Deserialize the response payload data
                    if (resp.length !== szs.payload.response.encrypted - 1) {
                        throw new Error('Wrong Lattice response message size.');
                    }
                    encPayloadData = resp.slice(0, szs.data.response.encrypted.encryptedData);
                    // Return decrypted response payload data
                    return [2 /*return*/, decryptEncryptedLatticeResponseData({
                            encPayloadData: encPayloadData,
                            requestType: requestType,
                            sharedSecret: sharedSecret,
                        })];
            }
        });
    });
}
exports.encryptedSecureRequest = encryptedSecureRequest;
/**
 * @internal
 * Serialize a Secure Request message for the Lattice.
 * All outgoing SDK requests are of this form.
 * @param msgId - Random 4 bytes of data for internally tracking this message
 * @param secureRequestType - 0x01 for connect, 0x02 for encrypted
 * @param payloadData - Request data
 * @return {Buffer} Serialized message to be sent to Lattice
 */
function serializeSecureRequestMsg(msgId, secureRequestType, payloadData) {
    // Sanity check request data
    if (msgId.length !== 4) {
        throw new Error('msgId must be four bytes');
    }
    if (secureRequestType !== latticeConstants_1.LatticeSecureMsgType.connect &&
        secureRequestType !== latticeConstants_1.LatticeSecureMsgType.encrypted) {
        throw new Error('Invalid Lattice secure request type');
    }
    // Validate the incoming payload data size. Note that the payload
    // data is prepended with a secure request type byte, so the
    // payload data size is one less than the expected size.
    var isValidConnectPayloadDataSz = secureRequestType === latticeConstants_1.LatticeSecureMsgType.connect &&
        payloadData.length === szs.payload.request.connect - 1;
    var isValidEncryptedPayloadDataSz = secureRequestType === latticeConstants_1.LatticeSecureMsgType.encrypted &&
        payloadData.length === szs.payload.request.encrypted - 1;
    // Build payload and size
    var msgSz = msgSizes.header + msgSizes.checksum;
    var payloadLen;
    var payload = {
        requestType: secureRequestType,
        data: payloadData,
    };
    if (isValidConnectPayloadDataSz) {
        payloadLen = szs.payload.request.connect;
    }
    else if (isValidEncryptedPayloadDataSz) {
        payloadLen = szs.payload.request.encrypted;
    }
    else {
        throw new Error('Invalid Lattice secure request payload size');
    }
    msgSz += payloadLen;
    // Construct the request in object form
    var header = {
        version: latticeConstants_1.LatticeProtocolVersion.v1,
        type: latticeConstants_1.LatticeMsgType.secure,
        id: msgId,
        len: payloadLen,
    };
    var req = {
        header: header,
        payload: payload,
    };
    // Now serialize the whole message
    // Header | requestType | payloadData | checksum
    var msg = Buffer.alloc(msgSz);
    var off = 0;
    // Header
    msg.writeUInt8(req.header.version, off);
    off += 1;
    msg.writeUInt8(req.header.type, off);
    off += 1;
    req.header.id.copy(msg, off);
    off += req.header.id.length;
    msg.writeUInt16BE(req.header.len, off);
    off += 2;
    // Payload
    msg.writeUInt8(req.payload.requestType, off);
    off += 1;
    req.payload.data.copy(msg, off);
    off += req.payload.data.length;
    // Checksum
    msg.writeUInt32BE((0, util_1.checksum)(msg.slice(0, off)), off);
    off += 4;
    if (off !== msgSz) {
        throw new Error('Failed to build request message');
    }
    // We have our serialized secure message!
    return msg;
}
/**
 * @internal
 * Serialize payload data for a Lattice secure request: connect
 * @return {Buffer} - 1700 bytes, of which only 65 are used
 */
function serializeSecureRequestConnectPayloadData(payloadData) {
    var serPayloadData = Buffer.alloc(szs.data.request.connect);
    payloadData.pubkey.copy(serPayloadData, 0);
    return serPayloadData;
}
/**
 * @internal
 * Serialize payload data for Lattice secure request: encrypted
 * @param data - Raw (unencrypted) request data
 * @return {Buffer} - 1700 bytes, all of which should be used
 */
function serializeSecureRequestEncryptedPayloadData(_a) {
    var data = _a.data, requestType = _a.requestType, ephemeralPub = _a.ephemeralPub, sharedSecret = _a.sharedSecret;
    // Sanity checks request size
    if (data.length > szs.data.request.encrypted.encryptedData) {
        throw new Error('Encrypted request data too large');
    }
    // Make sure we have a shared secret. An error will be thrown
    // if there is no ephemeral pub, indicating we need to reconnect.
    (0, validators_1.validateEphemeralPub)(ephemeralPub);
    // Validate the request data size matches the desired request
    var requestDataSize = szs.data.request.encrypted[requestType];
    if (data.length !== requestDataSize) {
        throw new Error("Invalid request datasize (wanted ".concat(requestDataSize, ", got ").concat(data.length, ")"));
    }
    // Build the pre-encrypted data payload, which variable sized and of form:
    // encryptedRequestType | data | checksum
    var preEncryptedData = Buffer.alloc(1 + requestDataSize);
    preEncryptedData[0] = requestType;
    data.copy(preEncryptedData, 1);
    var preEncryptedDataChecksum = (0, util_1.checksum)(preEncryptedData);
    // Encrypt the data into a fixed size buffer. The buffer size should
    // equal to the full message request less the 4-byte ephemeral id.
    var _encryptedData = Buffer.alloc(szs.data.request.encrypted.encryptedData);
    preEncryptedData.copy(_encryptedData, 0);
    _encryptedData.writeUInt32LE(preEncryptedDataChecksum, preEncryptedData.length);
    var encryptedData = (0, util_1.aes256_encrypt)(_encryptedData, sharedSecret);
    // Calculate ephemeral ID
    var ephemeralId = (0, functions_1.getEphemeralId)(sharedSecret);
    // Now we will serialize the payload data.
    var serPayloadData = Buffer.alloc(szs.payload.request.encrypted - 1);
    serPayloadData.writeUInt32LE(ephemeralId);
    encryptedData.copy(serPayloadData, 4);
    return serPayloadData;
}
/**
 * @internal
 * Decrypt the response data from an encrypted request.
 * @param encPayloadData - Encrypted payload data in response
 * @return {Buffer} Decrypted response data (excluding metadata)
 */
function decryptEncryptedLatticeResponseData(_a) {
    var encPayloadData = _a.encPayloadData, requestType = _a.requestType, sharedSecret = _a.sharedSecret;
    // Decrypt data using the *current* shared secret
    var decData = (0, util_1.aes256_decrypt)(encPayloadData, sharedSecret);
    // Bulid the object
    var ephemeralPubSz = 65; // secp256r1 pubkey
    var checksumOffset = ephemeralPubSz + szs.data.response.encrypted[requestType];
    var respData = {
        ephemeralPub: decData.slice(0, ephemeralPubSz),
        data: decData.slice(ephemeralPubSz, checksumOffset),
        checksum: decData.readUInt32BE(checksumOffset),
    };
    // Validate the checksum
    var validChecksum = (0, util_1.checksum)(decData.slice(0, checksumOffset));
    if (respData.checksum !== validChecksum) {
        throw new Error('Checksum mismatch in decrypted Lattice data');
    }
    // Validate the response data size
    var validSz = szs.data.response.encrypted[requestType];
    if (respData.data.length !== validSz) {
        throw new Error('Incorrect response data returned from Lattice');
    }
    var newEphemeralPub = (0, util_1.getP256KeyPairFromPub)(respData.ephemeralPub);
    // Returned the decrypted data
    return { decryptedData: respData.data, newEphemeralPub: newEphemeralPub };
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\protocol\\secureMessages.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\errors.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cerrors.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LatticeResponseError = void 0;
var protocol_1 = require("../protocol");
var buildLatticeResponseErrorMessage = function (_a) {
    var responseCode = _a.responseCode, errorMessage = _a.errorMessage;
    var msg = [];
    if (responseCode) {
        msg.push("".concat(protocol_1.ProtocolConstants.responseMsg[responseCode]));
    }
    if (errorMessage) {
        msg.push('Error Message: ');
        msg.push(errorMessage);
    }
    return msg.join('\n');
};
var LatticeResponseError = /** @class */ (function (_super) {
    __extends(LatticeResponseError, _super);
    function LatticeResponseError(responseCode, errorMessage) {
        var _this = this;
        var message = buildLatticeResponseErrorMessage({
            responseCode: responseCode,
            errorMessage: errorMessage,
        });
        _this = _super.call(this, message) || this;
        _this.responseCode = responseCode;
        _this.errorMessage = errorMessage;
        _this.name = 'LatticeResponseError';
        _this.responseCode = responseCode;
        _this.errorMessage = errorMessage;
        return _this;
    }
    return LatticeResponseError;
}(Error));
exports.LatticeResponseError = LatticeResponseError;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\errors.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\functions.js", {"../bitcoin":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\bitcoin.js","../constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../ethereum":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\ethereum.js","../genericSigning":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\genericSigning.js","../util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","./errors":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\errors.js","./predicates":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\predicates.js","./validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js/lib/hash/sha":"F:\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\sha.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cfunctions.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEphemeralId = exports.retryWrapper = exports.buildRetryWrapper = exports.request = exports.buildTransaction = void 0;
var sha_1 = require("hash.js/lib/hash/sha");
var bitcoin_1 = __importDefault(require("../bitcoin"));
var constants_1 = require("../constants");
var ethereum_1 = __importDefault(require("../ethereum"));
var genericSigning_1 = require("../genericSigning");
var util_1 = require("../util");
var errors_1 = require("./errors");
var predicates_1 = require("./predicates");
var validators_1 = require("./validators");
var buildTransaction = function (_a) {
    // All transaction requests must be put into the same sized buffer. This comes from
    // sizeof(GpTransactionRequest_t), but note we remove the 2-byte schemaId since it is not
    // returned from our resolver. Note that different firmware versions may have different data
    // sizes.
    var data = _a.data, currency = _a.currency, fwConstants = _a.fwConstants;
    // TEMPORARY BRIDGE -- DEPRECATE ME In v0.15.0 Lattice firmware removed the legacy ETH
    // signing path, so we need to convert such requests to general signing requests using the
    // EVM decoder. NOTE: Not every request can be converted, so users should switch to using
    // general signing requests for newer firmware versions. EIP1559 and EIP155 legacy
    // requests will convert, but others may not.
    if (currency === 'ETH' && (0, predicates_1.shouldUseEVMLegacyConverter)(fwConstants)) {
        console.log('Using the legacy ETH signing path. This will soon be deprecated. ' +
            'Please switch to general signing request.');
        var payload = void 0;
        try {
            payload = ethereum_1.default.ethConvertLegacyToGenericReq(data);
        }
        catch (err) {
            throw new Error('Could not convert legacy request. Please switch to a general signing ' +
                'request. See gridplus-sdk docs for more information.');
        }
        data = {
            fwConstants: fwConstants,
            encodingType: constants_1.EXTERNAL.SIGNING.ENCODINGS.EVM,
            curveType: constants_1.EXTERNAL.SIGNING.CURVES.SECP256K1,
            hashType: constants_1.EXTERNAL.SIGNING.HASHES.KECCAK256,
            signerPath: data.signerPath,
            payload: payload,
        };
        return {
            requestData: (0, genericSigning_1.buildGenericSigningMsgRequest)(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: true,
        };
    }
    else if (currency === 'ETH') {
        // Legacy signing pathway -- should deprecate in the future
        return {
            requestData: ethereum_1.default.buildEthereumTxRequest(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: false,
        };
    }
    else if (currency === 'ETH_MSG') {
        return {
            requestData: ethereum_1.default.buildEthereumMsgRequest(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: false,
        };
    }
    else if (currency === 'BTC') {
        return {
            requestData: bitcoin_1.default.buildBitcoinTxRequest(__assign(__assign({}, data), { fwConstants: fwConstants })),
            isGeneric: false,
        };
    }
    return {
        requestData: (0, genericSigning_1.buildGenericSigningMsgRequest)(__assign(__assign({}, data), { fwConstants: fwConstants })),
        isGeneric: true,
    };
};
exports.buildTransaction = buildTransaction;
var request = function (_a) {
    var url = _a.url, payload = _a.payload, _b = _a.timeout, timeout = _b === void 0 ? 60000 : _b;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_c) {
            return [2 /*return*/, (0, util_1.fetchWithTimeout)(url, {
                    method: 'POST',
                    body: JSON.stringify({ data: payload }),
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    timeout: timeout,
                })
                    .catch(validators_1.validateRequestError)
                    .then(function (res) { return res.json(); })
                    .then(function (body) {
                    // Handle formatting or generic HTTP errors
                    if (!body || !body.message) {
                        throw new Error('Invalid response');
                    }
                    else if (body.status !== 200) {
                        throw new Error("Error code ".concat(body.status, ": ").concat(body.message));
                    }
                    var _a = (0, util_1.parseLattice1Response)(body.message), data = _a.data, errorMessage = _a.errorMessage, responseCode = _a.responseCode;
                    if (errorMessage || responseCode) {
                        throw new errors_1.LatticeResponseError(responseCode, errorMessage);
                    }
                    return data;
                })];
        });
    });
};
exports.request = request;
/**
 * `sleep()` returns a Promise that resolves after a given number of milliseconds.
 */
function sleep(ms) {
    return new Promise(function (resolve) { return setTimeout(resolve, ms); });
}
/**
 * Takes a function and a set of parameters, and returns a function that will retry the original
 * function with the given parameters a number of times
 *
 * @param client - a {@link Client} instance that is passed to the {@link retryWrapper}
 * @param retries - the number of times to retry the function before giving up
 * @returns a {@link retryWrapper} function for handing retry logic
 */
var buildRetryWrapper = function (client, retries) {
    return function (fn, params) {
        return (0, exports.retryWrapper)({
            fn: fn,
            params: __assign(__assign({}, params), { client: client }),
            retries: retries,
            client: client,
        });
    };
};
exports.buildRetryWrapper = buildRetryWrapper;
/**
 * Retries a function call if the error message or response code is present and the number of
 * retries is greater than 0.
 *
 * @param fn - The function to retry
 * @param params - The parameters to pass to the function
 * @param retries - The number of times to retry the function
 * @param client - The {@link Client} to use for side-effects
 */
var retryWrapper = function (_a) {
    var fn = _a.fn, params = _a.params, retries = _a.retries, client = _a.client;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            return [2 /*return*/, fn(__assign({}, params)).catch(function (err) { return __awaiter(void 0, void 0, void 0, function () {
                    var errorMessage, responseCode;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                errorMessage = err.errorMessage;
                                responseCode = err.responseCode;
                                if (!((errorMessage || responseCode) && retries)) return [3 /*break*/, 8];
                                if (!(0, predicates_1.isDeviceBusy)(responseCode)) return [3 /*break*/, 2];
                                return [4 /*yield*/, sleep(3000)];
                            case 1:
                                _a.sent();
                                return [3 /*break*/, 7];
                            case 2:
                                if (!((0, predicates_1.isWrongWallet)(responseCode) &&
                                    !client.skipRetryOnWrongWallet)) return [3 /*break*/, 4];
                                return [4 /*yield*/, client.fetchActiveWallet()];
                            case 3:
                                _a.sent();
                                return [3 /*break*/, 7];
                            case 4:
                                if (!(0, predicates_1.isInvalidEphemeralId)(responseCode)) return [3 /*break*/, 6];
                                return [4 /*yield*/, client.connect(client.deviceId)];
                            case 5:
                                _a.sent();
                                return [3 /*break*/, 7];
                            case 6: throw err;
                            case 7: return [2 /*return*/, (0, exports.retryWrapper)({
                                    fn: fn,
                                    params: params,
                                    retries: retries - 1,
                                    client: client,
                                })];
                            case 8: throw err;
                        }
                    });
                }); })];
        });
    });
};
exports.retryWrapper = retryWrapper;
/**
 * Get the ephemeral id, which is the first 4 bytes of the shared secret generated from the local
 * private key and the ephemeral public key from the device.
 * @internal
 * @returns Buffer
 */
var getEphemeralId = function (sharedSecret) {
    // EphemId is the first 4 bytes of the hash of the shared secret
    var hash = Buffer.from((0, sha_1.sha256)().update(sharedSecret).digest('hex'), 'hex');
    return parseInt(hash.slice(0, 4).toString('hex'), 16);
};
exports.getEphemeralId = getEphemeralId;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\functions.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\predicates.js", {"../protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./utilities":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cpredicates.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldUseEVMLegacyConverter = exports.doesFetchWalletsOnLoad = exports.isInvalidEphemeralId = exports.isWrongWallet = exports.isDeviceBusy = void 0;
var protocol_1 = require("../protocol");
var utilities_1 = require("./utilities");
var isDeviceBusy = function (responseCode) {
    return responseCode === protocol_1.LatticeResponseCode.deviceBusy ||
        responseCode === protocol_1.LatticeResponseCode.gceTimeout;
};
exports.isDeviceBusy = isDeviceBusy;
var isWrongWallet = function (responseCode) {
    return responseCode === protocol_1.LatticeResponseCode.wrongWallet;
};
exports.isWrongWallet = isWrongWallet;
var isInvalidEphemeralId = function (responseCode) {
    return responseCode === protocol_1.LatticeResponseCode.invalidEphemId;
};
exports.isInvalidEphemeralId = isInvalidEphemeralId;
var doesFetchWalletsOnLoad = function (fwVersion) {
    return (0, utilities_1.isFWSupported)(fwVersion, { major: 0, minor: 14, fix: 1 });
};
exports.doesFetchWalletsOnLoad = doesFetchWalletsOnLoad;
var shouldUseEVMLegacyConverter = function (fwConstants) {
    return fwConstants.genericSigning &&
        fwConstants.genericSigning.encodingTypes &&
        fwConstants.genericSigning.encodingTypes.EVM;
};
exports.shouldUseEVMLegacyConverter = shouldUseEVMLegacyConverter;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\predicates.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\utilities.js", {"../constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cutilities.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPathStr = exports.isFWSupported = exports.parseWallets = exports.getSharedSecret = exports.getPubKeyBytes = void 0;
var constants_1 = require("../constants");
/**
 * Get 64 bytes representing the public key This is the uncompressed key without the leading 04
 * byte
 * @param KeyPair - //TODO Describe the keypair
 * @param LE - Whether to return the public key in little endian format.
 * @returns A Buffer containing the public key.
 */
var getPubKeyBytes = function (key, LE) {
    if (LE === void 0) { LE = false; }
    var k = key.getPublic();
    var p = k.encode('hex');
    var pb = Buffer.from(p, 'hex');
    if (LE === true) {
        // Need to flip X and Y components to little endian
        var x = pb.slice(1, 33).reverse();
        var y = pb.slice(33, 65).reverse();
        // @ts-expect-error - TODO: Find out why Buffer won't accept pb[0]
        return Buffer.concat([pb[0], x, y]);
    }
    else {
        return pb;
    }
};
exports.getPubKeyBytes = getPubKeyBytes;
/**
 * Get the shared secret, derived via ECDH from the local private key and the ephemeral public key
 * @internal
 * @returns Buffer
 */
var getSharedSecret = function (key, ephemeralPub) {
    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which can lead to
    // problems initializing AES if we don't force a 32 byte BE buffer.
    return Buffer.from(key.derive(ephemeralPub.getPublic()).toArray('be', 32));
};
exports.getSharedSecret = getSharedSecret;
// Given a set of wallet data, which contains two wallet descriptors, parse the data and save it
// to memory
var parseWallets = function (walletData) {
    // Read the external wallet data first. If it is non-null, the external wallet will be the
    // active wallet of the device and we should save it. If the external wallet is blank, it means
    // there is no card present and we should save and use the interal wallet. If both wallets are
    // empty, it means the device still needs to be set up.
    var walletDescriptorLen = 71;
    // Internal first
    var off = 0;
    var activeWallets = {
        internal: {
            uid: undefined,
            capabilities: undefined,
            name: undefined,
            external: false,
        },
        external: {
            uid: undefined,
            capabilities: undefined,
            name: undefined,
            external: true,
        },
    };
    activeWallets.internal.uid = walletData.slice(off, off + 32);
    // NOTE: `capabilities` and `name` were deprecated in Lattice firmware.
    // They never provided any real information, but have been archived here
    // since the response size has been preserved and we may bring them back
    // in a different form.
    // activeWallets.internal.capabilities = walletData.readUInt32BE(off + 32);
    // activeWallets.internal.name = walletData.slice(
    // off + 36,
    // off + walletDescriptorLen,
    // );
    // Offset the first item
    off += walletDescriptorLen;
    // External
    activeWallets.external.uid = walletData.slice(off, off + 32);
    // activeWallets.external.capabilities = walletData.readUInt32BE(off + 32);
    // activeWallets.external.name = walletData.slice(
    // off + 36,
    // off + walletDescriptorLen,
    // );
    return activeWallets;
};
exports.parseWallets = parseWallets;
// Determine if a provided firmware version matches or exceeds the current firmware version
var isFWSupported = function (fwVersion, versionSupported) {
    var major = fwVersion.major, minor = fwVersion.minor, fix = fwVersion.fix;
    var _major = versionSupported.major, _minor = versionSupported.minor, _fix = versionSupported.fix;
    return (major > _major ||
        (major >= _major && minor > _minor) ||
        (major >= _major && minor >= _minor && fix >= _fix));
};
exports.isFWSupported = isFWSupported;
/**
 * Convert a set of BIP39 path indices to a string
 * @param path - Set of indices
 */
var getPathStr = function (path) {
    var pathStr = 'm';
    path.forEach(function (idx) {
        if (idx >= constants_1.HARDENED_OFFSET) {
            pathStr += "/".concat(idx - constants_1.HARDENED_OFFSET, "'");
        }
        else {
            pathStr += "/".concat(idx);
        }
    });
    return pathStr;
};
exports.getPathStr = getPathStr;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\utilities.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js", {"../constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","../util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js","lodash/isEmpty":"F:\\metamask-extension\\node_modules\\lodash\\isEmpty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cshared%5Cvalidators.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValid4ByteResponse = exports.isValidBlockExplorerResponse = exports.validateKvRecord = exports.validateKvRecords = exports.validateActiveWallets = exports.validateKey = exports.validateSharedSecret = exports.validateEphemeralPub = exports.validateConnectedClient = exports.validateWallet = exports.validateRequestError = exports.validateFwVersion = exports.validateFwConstants = exports.validateBaseUrl = exports.validateUrl = exports.validateAppName = exports.validateDeviceId = exports.validateStartPath = exports.validateNAddresses = exports.validateIsUInt4 = void 0;
var constants_1 = require("../constants");
var util_1 = require("../util");
var isEmpty_1 = __importDefault(require("lodash/isEmpty"));
var validateIsUInt4 = function (n) {
    if (typeof n !== 'number' || !(0, util_1.isUInt4)(n)) {
        throw new Error('Must be an integer between 0 and 15 inclusive');
    }
    return n;
};
exports.validateIsUInt4 = validateIsUInt4;
var validateNAddresses = function (n) {
    if (!n) {
        throw new Error('The number of addresses is required.');
    }
    if (n > constants_1.MAX_ADDR) {
        throw new Error("You may only request ".concat(constants_1.MAX_ADDR, " addresses at once."));
    }
    return n;
};
exports.validateNAddresses = validateNAddresses;
var validateStartPath = function (startPath) {
    if (!startPath) {
        throw new Error('Start path is required');
    }
    if (startPath.length < 1 || startPath.length > 5)
        throw new Error('Path must include between 1 and 5 indices');
    return startPath;
};
exports.validateStartPath = validateStartPath;
var validateDeviceId = function (deviceId) {
    if (!deviceId) {
        throw new Error('No device ID has been stored. Please connect with your device ID first.');
    }
    return deviceId;
};
exports.validateDeviceId = validateDeviceId;
var validateAppName = function (name) {
    if (!name) {
        throw new Error('Name is required.');
    }
    if (name.length < 5 || name.length > 24) {
        throw new Error('Invalid length for name provided. Must be 5-24 characters.');
    }
    return name;
};
exports.validateAppName = validateAppName;
var validateUrl = function (url) {
    if (!url) {
        throw new Error('URL does not exist. Please reconnect.');
    }
    try {
        new URL(url);
    }
    catch (err) {
        throw new Error('Invalid URL provided. Please use a valid URL.');
    }
    return url;
};
exports.validateUrl = validateUrl;
var validateBaseUrl = function (baseUrl) {
    if (!baseUrl) {
        throw new Error('Base URL is required.');
    }
    try {
        new URL(baseUrl);
    }
    catch (err) {
        throw new Error('Invalid Base URL provided. Please use a valid URL.');
    }
    return baseUrl;
};
exports.validateBaseUrl = validateBaseUrl;
var validateFwConstants = function (fwConstants) {
    if (!fwConstants) {
        throw new Error('Firmware constants do not exist. Please reconnect.');
    }
    return fwConstants;
};
exports.validateFwConstants = validateFwConstants;
var validateFwVersion = function (fwVersion) {
    if (!fwVersion) {
        throw new Error('Firmware version does not exist. Please reconnect.');
    }
    if (typeof fwVersion.fix !== 'number' ||
        typeof fwVersion.minor !== 'number' ||
        typeof fwVersion.major !== 'number') {
        throw new Error('Firmware version improperly formatted. Please reconnect.');
    }
    return fwVersion;
};
exports.validateFwVersion = validateFwVersion;
var validateRequestError = function (err) {
    var isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';
    if (isTimeout) {
        throw new Error('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.');
    }
    throw new Error("Failed to make request to device:\n".concat(err.message));
};
exports.validateRequestError = validateRequestError;
var validateWallet = function (wallet) {
    if (!wallet || wallet === null) {
        throw new Error('No active wallet.');
    }
    return wallet;
};
exports.validateWallet = validateWallet;
var validateConnectedClient = function (client) {
    var appName = (0, exports.validateAppName)(client.getAppName());
    var ephemeralPub = (0, exports.validateEphemeralPub)(client.ephemeralPub);
    var sharedSecret = (0, exports.validateSharedSecret)(client.sharedSecret);
    var url = (0, exports.validateUrl)(client.url);
    var fwConstants = (0, exports.validateFwConstants)(client.getFwConstants());
    var fwVersion = (0, exports.validateFwVersion)(client.getFwVersion());
    // @ts-expect-error - Key is private
    var key = (0, exports.validateKey)(client.key);
    return {
        appName: appName,
        ephemeralPub: ephemeralPub,
        sharedSecret: sharedSecret,
        url: url,
        fwConstants: fwConstants,
        fwVersion: fwVersion,
        key: key,
    };
};
exports.validateConnectedClient = validateConnectedClient;
var validateEphemeralPub = function (ephemeralPub) {
    if (!ephemeralPub) {
        throw new Error('`ephemeralPub` (ephemeral public key) is required. Please reconnect.');
    }
    return ephemeralPub;
};
exports.validateEphemeralPub = validateEphemeralPub;
var validateSharedSecret = function (sharedSecret) {
    if (!sharedSecret) {
        throw new Error('Shared secret required. Please reconnect.');
    }
    return sharedSecret;
};
exports.validateSharedSecret = validateSharedSecret;
var validateKey = function (key) {
    if (!key) {
        throw new Error('Key is required. Please reconnect.');
    }
    return key;
};
exports.validateKey = validateKey;
var validateActiveWallets = function (activeWallets) {
    var _a, _b, _c, _d;
    if (!activeWallets ||
        (((_b = (_a = activeWallets === null || activeWallets === void 0 ? void 0 : activeWallets.internal) === null || _a === void 0 ? void 0 : _a.uid) === null || _b === void 0 ? void 0 : _b.equals(constants_1.EMPTY_WALLET_UID)) &&
            ((_d = (_c = activeWallets === null || activeWallets === void 0 ? void 0 : activeWallets.external) === null || _c === void 0 ? void 0 : _c.uid) === null || _d === void 0 ? void 0 : _d.equals(constants_1.EMPTY_WALLET_UID)))) {
        throw new Error('No active wallet.');
    }
    return activeWallets;
};
exports.validateActiveWallets = validateActiveWallets;
var validateKvRecords = function (records, fwConstants) {
    if (!fwConstants || !fwConstants.kvActionsAllowed) {
        throw new Error('Unsupported. Please update firmware.');
    }
    else if (typeof records !== 'object' || Object.keys(records).length < 1) {
        throw new Error('One or more key-value mapping must be provided in `records` param.');
    }
    else if (Object.keys(records).length > fwConstants.kvActionMaxNum) {
        throw new Error("Too many keys provided. Please only provide up to ".concat(fwConstants.kvActionMaxNum, "."));
    }
    return records;
};
exports.validateKvRecords = validateKvRecords;
var validateKvRecord = function (_a, fwConstants) {
    var key = _a.key, val = _a.val;
    if (typeof key !== 'string' ||
        String(key).length > fwConstants.kvKeyMaxStrSz) {
        throw new Error("Key ".concat(key, " too large. Must be <=").concat(fwConstants.kvKeyMaxStrSz, " characters."));
    }
    else if (typeof val !== 'string' ||
        String(val).length > fwConstants.kvValMaxStrSz) {
        throw new Error("Value ".concat(val, " too large. Must be <=").concat(fwConstants.kvValMaxStrSz, " characters."));
    }
    else if (String(key).length === 0 || String(val).length === 0) {
        throw new Error('Keys and values must be >0 characters.');
    }
    else if (!constants_1.ASCII_REGEX.test(key) || !constants_1.ASCII_REGEX.test(val)) {
        throw new Error('Unicode characters are not supported.');
    }
    return { key: key, val: val };
};
exports.validateKvRecord = validateKvRecord;
var isValidBlockExplorerResponse = function (data) {
    try {
        var result = JSON.parse(data.result);
        return !(0, isEmpty_1.default)(result);
    }
    catch (err) {
        return false;
    }
};
exports.isValidBlockExplorerResponse = isValidBlockExplorerResponse;
var isValid4ByteResponse = function (data) {
    try {
        return !(0, isEmpty_1.default)(data.results);
    }
    catch (err) {
        return false;
    }
};
exports.isValid4ByteResponse = isValid4ByteResponse;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\shared\\validators.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\util.js", {".":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\index.js","./constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\constants.js","./protocol":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\protocol\\index.js","./shared/validators":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\dist\\shared\\validators.js","@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\index.js","aes-js":"F:\\metamask-extension\\node_modules\\aes-js\\index.js","bignumber.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","crc-32":"F:\\metamask-extension\\node_modules\\crc-32\\crc32.js","elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js","hash.js/lib/hash/sha":"F:\\metamask-extension\\node_modules\\hash.js\\lib\\hash\\sha.js","js-sha3":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js","lodash/inRange":"F:\\metamask-extension\\node_modules\\lodash\\inRange.js","lodash/isInteger":"F:\\metamask-extension\\node_modules\\lodash\\isInteger.js","rlp":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\rlp\\dist\\index.js","secp256k1":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cdist%5Cutil.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTERNAL = exports.getV = exports.generateAppSecret = exports.fetchCalldataDecoder = exports.fetchWithTimeout = exports.selectDefFrom4byteABI = exports.isUInt4 = exports.randomBytes = exports.existsIn = exports.isAsciiStr = exports.buildSignerPathBuf = exports.getP256KeyPairFromPub = exports.getP256KeyPair = exports.parseDER = exports.aes256_decrypt = exports.aes256_encrypt = exports.fixLen = exports.ensureHexBuffer = exports.splitFrames = exports.isValidAssetPath = exports.toPaddedDER = exports.checksum = exports.parseLattice1Response = void 0;
// Static utility functions
var tx_1 = require("@ethereumjs/tx");
var aes_js_1 = __importDefault(require("aes-js"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var bn_js_1 = require("bn.js");
var crc_32_1 = __importDefault(require("crc-32"));
var elliptic_1 = __importDefault(require("elliptic"));
var sha_1 = require("hash.js/lib/hash/sha");
var js_sha3_1 = require("js-sha3");
var inRange_1 = __importDefault(require("lodash/inRange"));
var isInteger_1 = __importDefault(require("lodash/isInteger"));
var rlp_1 = require("rlp");
var secp256k1_1 = require("secp256k1");
var _1 = require(".");
var constants_1 = require("./constants");
var protocol_1 = require("./protocol");
var validators_1 = require("./shared/validators");
var COINS = constants_1.BIP_CONSTANTS.COINS, PURPOSES = constants_1.BIP_CONSTANTS.PURPOSES;
var EC = elliptic_1.default.ec;
var ec;
//--------------------------------------------------
// LATTICE UTILS
//--------------------------------------------------
/** @internal Parse a response from the Lattice1 */
var parseLattice1Response = function (r) {
    var parsed = {
        errorMessage: null,
        data: null,
    };
    var b = Buffer.from(r, 'hex');
    var off = 0;
    // Get protocol version
    var protoVer = b.readUInt8(off);
    off++;
    if (protoVer !== constants_1.VERSION_BYTE) {
        parsed.errorMessage = 'Incorrect protocol version. Please update your SDK';
        return parsed;
    }
    // Get the type of response
    // Should always be 0x00
    var msgType = b.readUInt8(off);
    off++;
    if (msgType !== 0x00) {
        parsed.errorMessage = 'Incorrect response from Lattice1';
        return parsed;
    }
    // Get the payload
    b.readUInt32BE(off);
    off += 4; // First 4 bytes is the id, but we don't need that anymore
    var len = b.readUInt16BE(off);
    off += 2;
    var payload = b.slice(off, off + len);
    off += len;
    // Get response code
    var responseCode = payload.readUInt8(0);
    if (responseCode !== protocol_1.LatticeResponseCode.success) {
        var errMsg = protocol_1.ProtocolConstants.responseMsg[responseCode];
        parsed.errorMessage = "[Lattice] ".concat(errMsg ? errMsg : 'Unknown Error');
        parsed.responseCode = responseCode;
        return parsed;
    }
    else {
        parsed.data = payload.slice(1, payload.length);
    }
    // Verify checksum
    var cs = b.readUInt32BE(off);
    var expectedCs = (0, exports.checksum)(b.slice(0, b.length - 4));
    if (cs !== expectedCs) {
        parsed.errorMessage = 'Invalid checksum from device response';
        parsed.data = null;
        return parsed;
    }
    return parsed;
};
exports.parseLattice1Response = parseLattice1Response;
/** @internal */
var checksum = function (x) {
    // crc32 returns a signed integer - need to cast it to unsigned
    // Note that this uses the default 0xedb88320 polynomial
    return crc_32_1.default.buf(x) >>> 0; // Need this to be a uint, hence the bit shift
};
exports.checksum = checksum;
// Get a 74-byte padded DER-encoded signature buffer
// `sig` must be the signature output from elliptic.js
/** @internal */
var toPaddedDER = function (sig) {
    // We use 74 as the maximum length of a DER signature. All sigs must
    // be right-padded with zeros so that this can be a fixed size field
    var b = Buffer.alloc(74);
    var ds = Buffer.from(sig.toDER());
    ds.copy(b);
    return b;
};
exports.toPaddedDER = toPaddedDER;
//--------------------------------------------------
// TRANSACTION UTILS
//--------------------------------------------------
/** @internal */
var isValidAssetPath = function (path, fwConstants) {
    var allowedPurposes = [
        PURPOSES.ETH,
        PURPOSES.BTC_LEGACY,
        PURPOSES.BTC_WRAPPED_SEGWIT,
        PURPOSES.BTC_SEGWIT,
    ];
    var allowedCoins = [COINS.ETH, COINS.BTC, COINS.BTC_TESTNET];
    // These coin types were given to us by MyCrypto. They should be allowed, but we expect
    // an Ethereum-type address with these coin types.
    // These all use SLIP44: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    var allowedMyCryptoCoins = [
        60, 61, 966, 700, 9006, 9000, 1007, 553, 178, 137, 37310, 108, 40, 889,
        1987, 820, 6060, 1620, 1313114, 76, 246529, 246785, 1001, 227, 916, 464,
        2221, 344, 73799, 246,
    ];
    // Make sure firmware supports this Bitcoin path
    var isBitcoin = path[1] === COINS.BTC || path[1] === COINS.BTC_TESTNET;
    var isBitcoinNonWrappedSegwit = isBitcoin && path[0] !== PURPOSES.BTC_WRAPPED_SEGWIT;
    if (isBitcoinNonWrappedSegwit && !fwConstants.allowBtcLegacyAndSegwitAddrs)
        return false;
    // Make sure this path is otherwise valid
    return (allowedPurposes.indexOf(path[0]) >= 0 &&
        (allowedCoins.indexOf(path[1]) >= 0 ||
            allowedMyCryptoCoins.indexOf(path[1] - constants_1.HARDENED_OFFSET) > 0));
};
exports.isValidAssetPath = isValidAssetPath;
/** @internal */
var splitFrames = function (data, frameSz) {
    var frames = [];
    var n = Math.ceil(data.length / frameSz);
    var off = 0;
    for (var i = 0; i < n; i++) {
        frames.push(data.slice(off, off + frameSz));
        off += frameSz;
    }
    return frames;
};
exports.splitFrames = splitFrames;
/** @internal */
function isBase10NumStr(x) {
    var bn = new bignumber_js_1.default(x).toFixed().split('.').join('');
    var s = new String(x);
    // Note that the JS native `String()` loses precision for large numbers, but we only
    // want to validate the base of the number so we don't care about far out precision.
    return bn.slice(0, 8) === s.slice(0, 8);
}
/** @internal Ensure a param is represented by a buffer */
var ensureHexBuffer = function (x, zeroIsNull) {
    if (zeroIsNull === void 0) { zeroIsNull = true; }
    try {
        // For null values, return a 0-sized buffer. For most situations we assume
        // 0 should be represented with a zero-length buffer (e.g. for RLP-building
        // txs), but it can also be treated as a 1-byte buffer (`00`) if needed
        if (x === null || (x === 0 && zeroIsNull === true))
            return Buffer.alloc(0);
        var isNumber = typeof x === 'number' || isBase10NumStr(x);
        // Otherwise try to get this converted to a hex string
        if (isNumber) {
            // If this is a number or a base-10 number string, convert it to hex
            x = "".concat(new bignumber_js_1.default(x).toString(16));
        }
        else if (typeof x === 'string' && x.slice(0, 2) === '0x') {
            x = x.slice(2);
        }
        else {
            x = x.toString('hex');
        }
        if (x.length % 2 > 0)
            x = "0".concat(x);
        if (x === '00' && !isNumber)
            return Buffer.alloc(0);
        return Buffer.from(x, 'hex');
    }
    catch (err) {
        throw new Error("Cannot convert ".concat(x.toString(), " to hex buffer (").concat(err.toString(), ")"));
    }
};
exports.ensureHexBuffer = ensureHexBuffer;
/** @internal */
var fixLen = function (msg, length) {
    var buf = Buffer.alloc(length);
    if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
    }
    return msg.slice(-length);
};
exports.fixLen = fixLen;
//--------------------------------------------------
// CRYPTO UTILS
//--------------------------------------------------
/** @internal */
var aes256_encrypt = function (data, key) {
    var iv = Buffer.from(protocol_1.ProtocolConstants.aesIv);
    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    var paddedData = data.length % 16 === 0 ? data : aes_js_1.default.padding.pkcs7.pad(data);
    return Buffer.from(aesCbc.encrypt(paddedData));
};
exports.aes256_encrypt = aes256_encrypt;
/** @internal */
var aes256_decrypt = function (data, key) {
    var iv = Buffer.from(protocol_1.ProtocolConstants.aesIv);
    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    return Buffer.from(aesCbc.decrypt(data));
};
exports.aes256_decrypt = aes256_decrypt;
// Decode a DER signature. Returns signature object {r, s } or null if there is an error
/** @internal */
var parseDER = function (sigBuf) {
    if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02)
        throw new Error('Failed to decode DER signature');
    var off = 3;
    var rLen = sigBuf[off];
    off++;
    var r = sigBuf.slice(off, off + rLen);
    off += rLen;
    if (sigBuf[off] !== 0x02)
        throw new Error('Failed to decode DER signature');
    off++;
    var sLen = sigBuf[off];
    off++;
    var s = sigBuf.slice(off, off + sLen);
    return { r: r, s: s };
};
exports.parseDER = parseDER;
/** @internal */
var getP256KeyPair = function (priv) {
    if (ec === undefined)
        ec = new EC('p256');
    return ec.keyFromPrivate(priv, 'hex');
};
exports.getP256KeyPair = getP256KeyPair;
/** @internal */
var getP256KeyPairFromPub = function (pub) {
    if (ec === undefined)
        ec = new EC('p256');
    return ec.keyFromPublic(pub, 'hex');
};
exports.getP256KeyPairFromPub = getP256KeyPairFromPub;
/** @internal */
var buildSignerPathBuf = function (signerPath, varAddrPathSzAllowed) {
    var buf = Buffer.alloc(24);
    var off = 0;
    if (varAddrPathSzAllowed && signerPath.length > 5)
        throw new Error('Signer path must be <=5 indices.');
    if (!varAddrPathSzAllowed && signerPath.length !== 5)
        throw new Error('Your Lattice firmware only supports 5-index derivation paths. Please upgrade.');
    buf.writeUInt32LE(signerPath.length, off);
    off += 4;
    for (var i = 0; i < 5; i++) {
        if (i < signerPath.length)
            buf.writeUInt32LE(signerPath[i], off);
        else
            buf.writeUInt32LE(0, off);
        off += 4;
    }
    return buf;
};
exports.buildSignerPathBuf = buildSignerPathBuf;
//--------------------------------------------------
// OTHER UTILS
//--------------------------------------------------
/** @internal */
var isAsciiStr = function (str, allowFormatChars) {
    if (allowFormatChars === void 0) { allowFormatChars = false; }
    if (typeof str !== 'string') {
        return false;
    }
    var extraChars = allowFormatChars ?
        [
            0x0020,
            0x000a, // New line
        ] : [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (extraChars.indexOf(c) < 0 && (c < 0x0020 || c > 0x007f)) {
            return false;
        }
    }
    return true;
};
exports.isAsciiStr = isAsciiStr;
/** @internal Check if a value exists in an object. Only checks first level of keys. */
var existsIn = function (val, obj) {
    return Object.keys(obj).some(function (key) { return obj[key] === val; });
};
exports.existsIn = existsIn;
/** @internal Create a buffer of size `n` and fill it with random data */
var randomBytes = function (n) {
    var buf = Buffer.alloc(n);
    for (var i = 0; i < n; i++) {
        buf[i] = Math.round(Math.random() * 255);
    }
    return buf;
};
exports.randomBytes = randomBytes;
/** @internal `isUInt4` accepts a number and returns true if it is a UInt4 */
var isUInt4 = function (n) { return (0, isInteger_1.default)(n) && (0, inRange_1.default)(n, 0, 16); };
exports.isUInt4 = isUInt4;
/**
 * Fetches an external JSON file containing networks indexed by chain id from a GridPlus repo, and
 * returns the parsed JSON.
 */
function fetchExternalNetworkForChainId(chainId) {
    return __awaiter(this, void 0, void 0, function () {
        var body, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, fetch(constants_1.EXTERNAL_NETWORKS_BY_CHAIN_ID_URL)
                            .then(function (res) { return res.json(); })];
                case 1:
                    body = _a.sent();
                    if (body) {
                        return [2 /*return*/, body[chainId]];
                    }
                    else {
                        return [2 /*return*/, undefined];
                    }
                    return [3 /*break*/, 3];
                case 2:
                    err_1 = _a.sent();
                    console.warn('Fetching external networks failed.\n', err_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
/**
 * Builds a URL for fetching calldata from block explorers for any supported chains
 * */
function buildUrlForSupportedChainAndAddress(_a) {
    var supportedChain = _a.supportedChain, address = _a.address;
    var baseUrl = supportedChain.baseUrl;
    var apiRoute = supportedChain.apiRoute;
    var urlWithRoute = "".concat(baseUrl, "/").concat(apiRoute, "&address=").concat(address);
    var apiKey = null;
    var apiKeyParam = apiKey ? "&apiKey=".concat(null) : '';
    return urlWithRoute + apiKeyParam;
}
/**
 * Takes a list of ABI data objects and a selector, and returns the earliest ABI data object that
 * matches the selector.
 */
function selectDefFrom4byteABI(abiData, selector) {
    if (abiData.length > 1) {
        console.warn('WARNING: There are multiple results. Using the first one.');
    }
    var def;
    abiData
        .sort(function (a, b) {
        var aTime = new Date(a.created_at).getTime();
        var bTime = new Date(b.created_at).getTime();
        return aTime - bTime;
    })
        .find(function (result) {
        try {
            def = _1.Calldata.EVM.parsers.parseCanonicalName(selector, result.text_signature);
            return !!def;
        }
        catch (err) {
            return false;
        }
    });
    if (def) {
        return def;
    }
    else {
        throw new Error('Could not find definition for selector');
    }
}
exports.selectDefFrom4byteABI = selectDefFrom4byteABI;
function fetchWithTimeout(url, options) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, timeout, controller, timeoutId, response;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = options.timeout, timeout = _a === void 0 ? 8000 : _a;
                    controller = new AbortController();
                    timeoutId = setTimeout(function () { return controller.abort(); }, timeout);
                    return [4 /*yield*/, fetch(url, __assign(__assign({}, options), { signal: controller.signal }))];
                case 1:
                    response = _b.sent();
                    clearTimeout(timeoutId);
                    return [2 /*return*/, response];
            }
        });
    });
}
exports.fetchWithTimeout = fetchWithTimeout;
function fetchAndCache(url, opts) {
    return __awaiter(this, void 0, void 0, function () {
        var cache, request, match, response, responseClone, data, err_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 11, , 12]);
                    if (!(globalThis.caches && globalThis.Request)) return [3 /*break*/, 9];
                    return [4 /*yield*/, caches.open('gp-calldata')];
                case 1:
                    cache = _a.sent();
                    request = new Request(url, opts);
                    return [4 /*yield*/, cache.match(request)];
                case 2:
                    match = _a.sent();
                    if (!match) return [3 /*break*/, 3];
                    return [2 /*return*/, match];
                case 3: return [4 /*yield*/, fetch(request, opts)];
                case 4:
                    response = _a.sent();
                    responseClone = response.clone();
                    return [4 /*yield*/, response.json()];
                case 5:
                    data = _a.sent();
                    if (!(response.ok &&
                        ((0, validators_1.isValidBlockExplorerResponse)(data) || (0, validators_1.isValid4ByteResponse)(data)))) return [3 /*break*/, 7];
                    return [4 /*yield*/, cache.put(request, responseClone)];
                case 6:
                    _a.sent();
                    return [2 /*return*/, cache.match(request, opts)];
                case 7: return [2 /*return*/, response];
                case 8: return [3 /*break*/, 10];
                case 9: return [2 /*return*/, fetch(url, opts)];
                case 10: return [3 /*break*/, 12];
                case 11:
                    err_2 = _a.sent();
                    console.error(err_2);
                    throw err_2;
                case 12: return [2 /*return*/];
            }
        });
    });
}
function fetchSupportedChainData(address, supportedChain) {
    return __awaiter(this, void 0, void 0, function () {
        var url;
        return __generator(this, function (_a) {
            url = buildUrlForSupportedChainAndAddress({ address: address, supportedChain: supportedChain });
            return [2 /*return*/, fetchAndCache(url)
                    .then(function (res) { return res.json(); })
                    .then(function (body) {
                    if (body && body.result) {
                        return JSON.parse(body.result);
                    }
                    else {
                        throw new Error('Server response was malformed');
                    }
                })
                    .catch(function () {
                    throw new Error('Fetching data from external network failed');
                })];
        });
    });
}
function fetch4byteData(selector) {
    return __awaiter(this, void 0, void 0, function () {
        var url;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    url = "https://www.4byte.directory/api/v1/signatures/?hex_signature=0x".concat(selector);
                    return [4 /*yield*/, fetch(url)
                            .then(function (res) { return res.json(); })
                            .then(function (body) {
                            if (body && body.results) {
                                return body.results;
                            }
                            else {
                                throw new Error('No results found');
                            }
                        })
                            .catch(function (err) {
                            throw new Error("Fetching data from 4byte failed: ".concat(err.message));
                        })];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function encodeDef(def) {
    return Buffer.from((0, rlp_1.encode)(def));
}
/**
 * Post-process fetched ABI definition.
 * @param def - Calldata decoder data definition for calling function
 * @param calldata - Raw transaction calldata
 * @return - Updated `def`
 */
function postProcessDef(def, calldata) {
    var e_1, _a, e_2, _b;
    return __awaiter(this, void 0, void 0, function () {
        var nestedCalldata, nestedDefs, _c, _e, i, _f, _g, j, _h, _j, e_2_1, _k, _l, e_1_1, newDef;
        return __generator(this, function (_m) {
            switch (_m.label) {
                case 0:
                    nestedCalldata = _1.Calldata.EVM.processors.getNestedCalldata(def, calldata);
                    return [4 /*yield*/, replaceNestedDefs(nestedCalldata)];
                case 1:
                    nestedDefs = _m.sent();
                    _m.label = 2;
                case 2:
                    _m.trys.push([2, 22, 23, 28]);
                    _c = __asyncValues(nestedDefs.entries());
                    _m.label = 3;
                case 3: return [4 /*yield*/, _c.next()];
                case 4:
                    if (!(_e = _m.sent(), !_e.done)) return [3 /*break*/, 21];
                    i = _e.value[0];
                    if (!(Array.isArray(nestedDefs[i]) && typeof nestedDefs[i][0] !== 'string')) return [3 /*break*/, 18];
                    _m.label = 5;
                case 5:
                    _m.trys.push([5, 11, 12, 17]);
                    _f = (e_2 = void 0, __asyncValues(nestedDefs[i].entries()));
                    _m.label = 6;
                case 6: return [4 /*yield*/, _f.next()];
                case 7:
                    if (!(_g = _m.sent(), !_g.done)) return [3 /*break*/, 10];
                    j = _g.value[0];
                    if (!(nestedDefs[i][j] !== null)) return [3 /*break*/, 9];
                    _h = nestedDefs[i];
                    _j = j;
                    return [4 /*yield*/, postProcessDef(nestedDefs[i][j], Buffer.from(nestedCalldata[i][j].slice(2), 'hex'))];
                case 8:
                    _h[_j] = _m.sent();
                    _m.label = 9;
                case 9: return [3 /*break*/, 6];
                case 10: return [3 /*break*/, 17];
                case 11:
                    e_2_1 = _m.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 17];
                case 12:
                    _m.trys.push([12, , 15, 16]);
                    if (!(_g && !_g.done && (_b = _f.return))) return [3 /*break*/, 14];
                    return [4 /*yield*/, _b.call(_f)];
                case 13:
                    _m.sent();
                    _m.label = 14;
                case 14: return [3 /*break*/, 16];
                case 15:
                    if (e_2) throw e_2.error;
                    return [7 /*endfinally*/];
                case 16: return [7 /*endfinally*/];
                case 17: return [3 /*break*/, 20];
                case 18:
                    if (!(nestedDefs[i] !== null)) return [3 /*break*/, 20];
                    _k = nestedDefs;
                    _l = i;
                    return [4 /*yield*/, postProcessDef(nestedDefs[i], Buffer.from(nestedCalldata[i].slice(2), 'hex'))];
                case 19:
                    _k[_l] = _m.sent();
                    _m.label = 20;
                case 20: return [3 /*break*/, 3];
                case 21: return [3 /*break*/, 28];
                case 22:
                    e_1_1 = _m.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 28];
                case 23:
                    _m.trys.push([23, , 26, 27]);
                    if (!(_e && !_e.done && (_a = _c.return))) return [3 /*break*/, 25];
                    return [4 /*yield*/, _a.call(_c)];
                case 24:
                    _m.sent();
                    _m.label = 25;
                case 25: return [3 /*break*/, 27];
                case 26:
                    if (e_1) throw e_1.error;
                    return [7 /*endfinally*/];
                case 27: return [7 /*endfinally*/];
                case 28:
                    newDef = _1.Calldata.EVM.processors.replaceNestedDefs(def, nestedDefs);
                    return [2 /*return*/, newDef];
            }
        });
    });
}
/**
 * Given a set of possible nested defs, slice out selectors and look up
 * definitions on 4byte.
 * @param possNestedDefs - result of `getPossibleNestedDefs` processor
 * @return Array containing calldata decoding data for each parameter
 *          that had a possible nested def. If there was no possible
 *          nested def or if a def could not be fetched from 4byte, the
 *          array item will be `null`. In the case of multiple possible
 *          defs behind one param (e.g. multicall pattern), ALL nested
 *          items must have defs associated or the item will map to a
 *          single `null` value in the return array.
 *
 */
function replaceNestedDefs(possNestedDefs) {
    var possNestedDefs_1, possNestedDefs_1_1;
    var e_3, _a, e_4, _b;
    return __awaiter(this, void 0, void 0, function () {
        var nestedDefs, d, _nestedDefs, shouldInclude, d_1, d_1_1, _d, _nestedSelector, _nestedAbi, _nestedDef, err_3, e_4_1, nestedSelector, nestedAbi, nestedDef, err_4, e_3_1;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    nestedDefs = [];
                    _c.label = 1;
                case 1:
                    _c.trys.push([1, 26, 27, 32]);
                    possNestedDefs_1 = __asyncValues(possNestedDefs);
                    _c.label = 2;
                case 2: return [4 /*yield*/, possNestedDefs_1.next()];
                case 3:
                    if (!(possNestedDefs_1_1 = _c.sent(), !possNestedDefs_1_1.done)) return [3 /*break*/, 25];
                    d = possNestedDefs_1_1.value;
                    if (!(d !== null)) return [3 /*break*/, 23];
                    if (!Array.isArray(d)) return [3 /*break*/, 19];
                    _nestedDefs = [];
                    shouldInclude = true;
                    _c.label = 4;
                case 4:
                    _c.trys.push([4, 12, 13, 18]);
                    d_1 = (e_4 = void 0, __asyncValues(d));
                    _c.label = 5;
                case 5: return [4 /*yield*/, d_1.next()];
                case 6:
                    if (!(d_1_1 = _c.sent(), !d_1_1.done)) return [3 /*break*/, 11];
                    _d = d_1_1.value;
                    _c.label = 7;
                case 7:
                    _c.trys.push([7, 9, , 10]);
                    _nestedSelector = _d.slice(2, 10);
                    return [4 /*yield*/, fetch4byteData(_nestedSelector)];
                case 8:
                    _nestedAbi = _c.sent();
                    _nestedDef = selectDefFrom4byteABI(_nestedAbi, _nestedSelector);
                    _nestedDefs.push(_nestedDef);
                    return [3 /*break*/, 10];
                case 9:
                    err_3 = _c.sent();
                    shouldInclude = false;
                    _nestedDefs.push(null);
                    return [3 /*break*/, 10];
                case 10: return [3 /*break*/, 5];
                case 11: return [3 /*break*/, 18];
                case 12:
                    e_4_1 = _c.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 18];
                case 13:
                    _c.trys.push([13, , 16, 17]);
                    if (!(d_1_1 && !d_1_1.done && (_b = d_1.return))) return [3 /*break*/, 15];
                    return [4 /*yield*/, _b.call(d_1)];
                case 14:
                    _c.sent();
                    _c.label = 15;
                case 15: return [3 /*break*/, 17];
                case 16:
                    if (e_4) throw e_4.error;
                    return [7 /*endfinally*/];
                case 17: return [7 /*endfinally*/];
                case 18:
                    if (shouldInclude) {
                        nestedDefs.push(_nestedDefs);
                    }
                    else {
                        nestedDefs.push(null);
                    }
                    return [3 /*break*/, 22];
                case 19:
                    _c.trys.push([19, 21, , 22]);
                    nestedSelector = d.slice(2, 10);
                    return [4 /*yield*/, fetch4byteData(nestedSelector)];
                case 20:
                    nestedAbi = _c.sent();
                    nestedDef = selectDefFrom4byteABI(nestedAbi, nestedSelector);
                    nestedDefs.push(nestedDef);
                    return [3 /*break*/, 22];
                case 21:
                    err_4 = _c.sent();
                    nestedDefs.push(null);
                    return [3 /*break*/, 22];
                case 22: return [3 /*break*/, 24];
                case 23:
                    nestedDefs.push(null);
                    _c.label = 24;
                case 24: return [3 /*break*/, 2];
                case 25: return [3 /*break*/, 32];
                case 26:
                    e_3_1 = _c.sent();
                    e_3 = { error: e_3_1 };
                    return [3 /*break*/, 32];
                case 27:
                    _c.trys.push([27, , 30, 31]);
                    if (!(possNestedDefs_1_1 && !possNestedDefs_1_1.done && (_a = possNestedDefs_1.return))) return [3 /*break*/, 29];
                    return [4 /*yield*/, _a.call(possNestedDefs_1)];
                case 28:
                    _c.sent();
                    _c.label = 29;
                case 29: return [3 /*break*/, 31];
                case 30:
                    if (e_3) throw e_3.error;
                    return [7 /*endfinally*/];
                case 31: return [7 /*endfinally*/];
                case 32: 
                // For all nested defs, replace the 
                return [2 /*return*/, nestedDefs];
            }
        });
    });
}
//--------------------------------------------------
//--------------------------------------------------
// EXTERNAL UTILS
//--------------------------------------------------
//--------------------------------------------------
/**
 *  Fetches calldata from a remote scanner based on the transaction's `chainId`
 */
function fetchCalldataDecoder(_data, to, _chainId, recurse) {
    if (recurse === void 0) { recurse = true; }
    return __awaiter(this, void 0, void 0, function () {
        var isHexString, data, selector, chainId, cachedNetwork, supportedChain, _a, abi_1, parsedAbi, def_1, err_5, abi, def, err_6;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 15, , 16]);
                    // Exit if there is no data. The 2 comes from the 0x prefix, but a later
                    // check will confirm that there are at least 4 bytes of data in the buffer.
                    if (!_data || _data.length < 2) {
                        throw new Error('Data is either undefined or less than two bytes');
                    }
                    isHexString = typeof _data === 'string' && _data.slice(0, 2) === '0x';
                    data = isHexString ?
                        Buffer.from(_data.slice(2), 'hex') :
                        //@ts-expect-error - Buffer doesn't recognize Uint8Array type properly
                        Buffer.from(_data, 'hex');
                    if (data.length < 4) {
                        throw new Error('Data must contain at least 4 bytes of data to define the selector');
                    }
                    selector = Buffer.from(data.slice(0, 4)).toString('hex');
                    chainId = Number(_chainId);
                    cachedNetwork = constants_1.NETWORKS_BY_CHAIN_ID[chainId];
                    if (!cachedNetwork) return [3 /*break*/, 1];
                    _a = cachedNetwork;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, fetchExternalNetworkForChainId(chainId)];
                case 2:
                    _a = _b.sent();
                    _b.label = 3;
                case 3:
                    supportedChain = _a;
                    _b.label = 4;
                case 4:
                    _b.trys.push([4, 10, , 11]);
                    if (!supportedChain) return [3 /*break*/, 8];
                    return [4 /*yield*/, fetchSupportedChainData(to, supportedChain)];
                case 5:
                    abi_1 = _b.sent();
                    parsedAbi = _1.Calldata.EVM.parsers.parseSolidityJSONABI(selector, abi_1);
                    def_1 = parsedAbi.def;
                    if (!recurse) return [3 /*break*/, 7];
                    return [4 /*yield*/, postProcessDef(def_1, data)];
                case 6:
                    def_1 = _b.sent();
                    _b.label = 7;
                case 7: return [2 /*return*/, { abi: abi_1, def: encodeDef(def_1) }];
                case 8: throw new Error("Chain (id: ".concat(chainId, ") is not supported"));
                case 9: return [3 /*break*/, 11];
                case 10:
                    err_5 = _b.sent();
                    console.warn(err_5.message, '\n', 'Falling back to 4byte');
                    return [3 /*break*/, 11];
                case 11: return [4 /*yield*/, fetch4byteData(selector)];
                case 12:
                    abi = _b.sent();
                    def = selectDefFrom4byteABI(abi, selector);
                    if (!recurse) return [3 /*break*/, 14];
                    return [4 /*yield*/, postProcessDef(def, data)];
                case 13:
                    def = _b.sent();
                    _b.label = 14;
                case 14: return [2 /*return*/, { abi: abi, def: encodeDef(def) }];
                case 15:
                    err_6 = _b.sent();
                    console.warn("Fetching calldata failed: ".concat(err_6.message));
                    return [3 /*break*/, 16];
                case 16: return [2 /*return*/, { def: null, abi: null }];
            }
        });
    });
}
exports.fetchCalldataDecoder = fetchCalldataDecoder;
/**
 * Generates an application secret for use in maintaining connection to device.
 * @param deviceId - The device ID of the device you want to generate a token for.
 * @param password - The password entered when connecting to the device.
 * @param appName - The name of the application.
 * @returns an application secret as a Buffer
 * @public
 */
var generateAppSecret = function (deviceId, password, appName) {
    var deviceIdBuffer = typeof deviceId === 'string' ? Buffer.from(deviceId) : deviceId;
    var passwordBuffer = typeof password === 'string' ? Buffer.from(password) : password;
    var appNameBuffer = typeof appName === 'string' ? Buffer.from(appName) : appName;
    var preImage = Buffer.concat([
        deviceIdBuffer,
        passwordBuffer,
        appNameBuffer,
    ]);
    return Buffer.from((0, sha_1.sha256)().update(preImage).digest('hex'), 'hex');
};
exports.generateAppSecret = generateAppSecret;
/**
 * Generic signing does not return a `v` value like legacy ETH signing requests did.
 * Get the `v` component of the signature as well as an `initV`
 * parameter, which is what you need to use to re-create an `@ethereumjs/tx`
 * object. There is a lot of tech debt in `@ethereumjs/tx` which also
 * inherits the tech debt of ethereumjs-util.
 * 1.  The legacy `Transaction` type can call `_processSignature` with the regular
 *     `v` value.
 * 2.  Newer transaction types such as `FeeMarketEIP1559Transaction` will subtract
 *     27 from the `v` that gets passed in, so we need to add `27` to create `initV`
 * @param tx - An @ethereumjs/tx Transaction object or Buffer (serialized tx)
 * @param resp - response from Lattice. Can be either legacy or generic signing variety
 * @returns bn.js BN object containing the `v` param
 */
var getV = function (tx, resp) {
    var chainId, hash, type;
    var txIsBuf = Buffer.isBuffer(tx);
    if (txIsBuf) {
        hash = Buffer.from((0, js_sha3_1.keccak256)(tx), 'hex');
        try {
            var legacyTxArray = (0, rlp_1.decode)(tx);
            if (legacyTxArray.length === 6) {
                // Six item array means this is a pre-EIP155 transaction
                chainId = null;
            }
            else {
                // Otherwise the `v` param is the `chainId`
                chainId = new bn_js_1.BN(legacyTxArray[6]);
            }
            // Legacy tx = type 0
            type = 0;
        }
        catch (err) {
            // This is likely a typed transaction
            try {
                var txObj = tx_1.TransactionFactory.fromSerializedData(tx);
                //@ts-expect-error -- Accessing private property
                type = txObj._type;
            }
            catch (err) {
                // If we can't RLP decode and can't hydrate an @ethereumjs/tx object,
                // we don't know what this is and should abort.
                throw new Error('Could not recover V. Bad transaction data.');
            }
        }
    }
    else {
        // @ethereumjs/tx object passed in
        type = tx._type;
        hash = type ?
            tx.getMessageToSign(true) : // newer tx types
            (0, rlp_1.encode)(tx.getMessageToSign(false)); // legacy tx
        if (tx.supports(tx_1.Capability.EIP155ReplayProtection)) {
            chainId = tx.common.chainIdBN().toNumber();
        }
    }
    var rs = new Uint8Array(Buffer.concat([resp.sig.r, resp.sig.s]));
    var pubkey = new Uint8Array(resp.pubkey);
    var recovery0 = (0, secp256k1_1.ecdsaRecover)(rs, 0, hash, false);
    var recovery1 = (0, secp256k1_1.ecdsaRecover)(rs, 1, hash, false);
    var pubkeyStr = Buffer.from(pubkey).toString('hex');
    var recovery0Str = Buffer.from(recovery0).toString('hex');
    var recovery1Str = Buffer.from(recovery1).toString('hex');
    var recovery;
    if (pubkeyStr === recovery0Str) {
        recovery = 0;
    }
    else if (pubkeyStr === recovery1Str) {
        recovery = 1;
    }
    else {
        // If we fail a second time, exit here.
        throw new Error('Failed to recover V parameter. Bad signature or transaction data.');
    }
    // Newer transaction types just use the [0, 1] value
    if (type) {
        return new bn_js_1.BN(recovery);
    }
    // If there is no chain ID, this is a pre-EIP155 tx
    if (!chainId) {
        return new bn_js_1.BN(recovery).addn(27);
    }
    // EIP155 replay protection is included in the `v` param
    // and uses the chainId value.
    return chainId.muln(2).addn(35).addn(recovery);
};
exports.getV = getV;
/** @internal */
exports.EXTERNAL = {
    fetchCalldataDecoder: fetchCalldataDecoder,
    generateAppSecret: exports.generateAppSecret,
    getV: exports.getV,
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk",file:"node_modules\\gridplus-sdk\\dist\\util.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\gindex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cgindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;
function bitIndexBigInt(v) {
    return v.toString(2).length - 1;
}
exports.bitIndexBigInt = bitIndexBigInt;
function toGindex(depth, index) {
    const anchor = BigInt(1) << BigInt(depth);
    if (index >= anchor) {
        throw new Error(`index ${index} too large for depth ${depth}`);
    }
    return anchor | index;
}
exports.toGindex = toGindex;
function toGindexBitstring(depth, index) {
    const str = index ? Number(index).toString(2) : "";
    if (str.length > depth) {
        throw new Error("index too large for depth");
    }
    else {
        return "1" + str.padStart(depth, "0");
    }
}
exports.toGindexBitstring = toGindexBitstring;
function convertGindexToBitstring(gindex) {
    if (typeof gindex === "string") {
        if (gindex.length === 0) {
            throw new Error(ERR_INVALID_GINDEX);
        }
        return gindex;
    }
    else {
        if (gindex < 1) {
            throw new Error(ERR_INVALID_GINDEX);
        }
        return gindex.toString(2);
    }
}
exports.convertGindexToBitstring = convertGindexToBitstring;
// Get the depth (root starting at 0) necessary to cover a subtree of `count` elements.
// (in out): (0 0), (1 0), (2 1), (3 2), (4 2), (5 3), (6 3), (7 3), (8 3), (9 4)
function countToDepth(count) {
    if (count <= 1) {
        return 0;
    }
    return (count - BigInt(1)).toString(2).length;
}
exports.countToDepth = countToDepth;
/**
 * Iterate through Gindexes at a certain depth
 */
function iterateAtDepth(depth, startIndex, count) {
    const anchor = BigInt(1) << BigInt(depth);
    if (startIndex + count > anchor) {
        throw new Error("Too large for depth");
    }
    let i = toGindex(depth, startIndex);
    const last = i + count;
    return {
        [Symbol.iterator]() {
            return {
                next() {
                    if (i < last) {
                        const value = i;
                        i++;
                        return { done: false, value };
                    }
                    else {
                        return { done: true, value: undefined };
                    }
                },
            };
        },
    };
}
exports.iterateAtDepth = iterateAtDepth;
/**
 * Return Gindexes at a certain depth
 */
function getGindicesAtDepth(depth, startIndex, count) {
    const anchor = BigInt(1) << BigInt(depth);
    if (startIndex + count > anchor) {
        throw new Error("Too large for depth");
    }
    let gindex = toGindex(depth, BigInt(startIndex));
    const gindices = [];
    for (let i = 0; i < count; i++) {
        gindices.push(gindex++);
    }
    return gindices;
}
exports.getGindicesAtDepth = getGindicesAtDepth;
const ERR_INVALID_GINDEX = "Invalid gindex";
function gindexIterator(gindex) {
    let bitstring;
    if (typeof gindex === "string") {
        if (!gindex.length) {
            throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex;
    }
    else {
        if (gindex < 1) {
            throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex.toString(2);
    }
    let i = 1;
    const next = () => {
        if (i === bitstring.length) {
            return { done: true, value: undefined };
        }
        const bit = Number(bitstring[i]);
        i++;
        return { done: false, value: bit };
    };
    return {
        [Symbol.iterator]() {
            return { next };
        },
        remainingBitLength() {
            return bitstring.length - i;
        },
    };
}
exports.gindexIterator = gindexIterator;
function getGindexBits(gindex) {
    let bitstring;
    if (typeof gindex === "string") {
        if (!gindex.length) {
            throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex;
    }
    else {
        if (gindex < 1) {
            throw new Error(ERR_INVALID_GINDEX);
        }
        bitstring = gindex.toString(2);
    }
    const bits = [];
    for (let i = 1; i < bitstring.length; i++) {
        bits.push(Number(bitstring[i]));
    }
    return bits;
}
exports.getGindexBits = getGindexBits;
/**
 * Concatenate Generalized Indices
 * Given generalized indices i1 for A -> B, i2 for B -> C .... i_n for Y -> Z, returns
 * the generalized index for A -> Z.
 */
function concatGindices(gindices) {
    return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), "0b1"));
}
exports.concatGindices = concatGindices;
function gindexSibling(gindex) {
    return gindex ^ BigInt(1);
}
exports.gindexSibling = gindexSibling;
function gindexParent(gindex) {
    return gindex / BigInt(2);
}
exports.gindexParent = gindexParent;
function gindexChild(gindex, rightChild) {
    return gindex * BigInt(2) + BigInt(rightChild);
}
exports.gindexChild = gindexChild;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\gindex.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\hash.js", {"@chainsafe/as-sha256":"F:\\metamask-extension\\node_modules\\browserify\\lib\\_empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Chash.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHashObject = exports.uint8ArrayToHashObject = exports.hashObjectToUint8Array = exports.hashTwoObjects = exports.hash = void 0;
const as_sha256_1 = require("@chainsafe/as-sha256");
const input = new Uint8Array(64);
/**
 * Hash two 32 byte arrays
 */
function hash(a, b) {
    input.set(a, 0);
    input.set(b, 32);
    return as_sha256_1.digest64(input);
}
exports.hash = hash;
/**
 * Hash 2 objects, each store 8 numbers (equivalent to Uint8Array(32))
 */
function hashTwoObjects(a, b) {
    return as_sha256_1.digest64HashObjects(a, b);
}
exports.hashTwoObjects = hashTwoObjects;
function hashObjectToUint8Array(obj) {
    const byteArr = new Uint8Array(32);
    as_sha256_1.hashObjectToByteArray(obj, byteArr, 0);
    return byteArr;
}
exports.hashObjectToUint8Array = hashObjectToUint8Array;
function uint8ArrayToHashObject(byteArr) {
    return as_sha256_1.byteArrayToHashObject(byteArr);
}
exports.uint8ArrayToHashObject = uint8ArrayToHashObject;
function isHashObject(hash) {
    // @ts-ignore
    return hash.length === undefined;
}
exports.isHashObject = isHashObject;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\hash.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js", {"./gindex":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\gindex.js","./hash":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\hash.js","./node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js","./packedNode":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\packedNode.js","./proof":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\index.js","./subtree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\subtree.js","./tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\tree.js","./zeroNode":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\zeroNode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./gindex"), exports);
__exportStar(require("./hash"), exports);
__exportStar(require("./node"), exports);
__exportStar(require("./packedNode"), exports);
__exportStar(require("./proof"), exports);
__exportStar(require("./subtree"), exports);
__exportStar(require("./tree"), exports);
__exportStar(require("./zeroNode"), exports);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js", {"./hash":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\hash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cnode.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;
const hash_1 = require("./hash");
const TWO_POWER_32 = 2 ** 32;
/**
 * An immutable binary merkle tree node
 */
class Node {
    constructor(h0, h1, h2, h3, h4, h5, h6, h7) {
        this.h0 = h0;
        this.h1 = h1;
        this.h2 = h2;
        this.h3 = h3;
        this.h4 = h4;
        this.h5 = h5;
        this.h6 = h6;
        this.h7 = h7;
    }
    applyHash(root) {
        this.h0 = root.h0;
        this.h1 = root.h1;
        this.h2 = root.h2;
        this.h3 = root.h3;
        this.h4 = root.h4;
        this.h5 = root.h5;
        this.h6 = root.h6;
        this.h7 = root.h7;
    }
}
exports.Node = Node;
/**
 * An immutable binary merkle tree node that has a `left` and `right` child
 */
class BranchNode extends Node {
    constructor(_left, _right) {
        // First null value is to save an extra variable to check if a node has a root or not
        super(null, 0, 0, 0, 0, 0, 0, 0);
        this._left = _left;
        this._right = _right;
        if (!_left) {
            throw new Error("Left node is undefined");
        }
        if (!_right) {
            throw new Error("Right node is undefined");
        }
    }
    get rootHashObject() {
        if (this.h0 === null) {
            super.applyHash(hash_1.hashTwoObjects(this.left.rootHashObject, this.right.rootHashObject));
        }
        return this;
    }
    get root() {
        return hash_1.hashObjectToUint8Array(this.rootHashObject);
    }
    isLeaf() {
        return false;
    }
    get left() {
        return this._left;
    }
    get right() {
        return this._right;
    }
}
exports.BranchNode = BranchNode;
/**
 * An immutable binary merkle tree node that has no children
 */
class LeafNode extends Node {
    static fromRoot(root) {
        return this.fromHashObject(hash_1.uint8ArrayToHashObject(root));
    }
    /**
     * New LeafNode from existing HashObject.
     */
    static fromHashObject(ho) {
        return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);
    }
    /**
     * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.
     */
    static fromZero() {
        return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.
     */
    static fromUint32(uint32) {
        return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Create a new LeafNode with the same internal values. The returned instance is safe to mutate
     */
    clone() {
        return LeafNode.fromHashObject(this);
    }
    get rootHashObject() {
        return this;
    }
    get root() {
        return hash_1.hashObjectToUint8Array(this);
    }
    isLeaf() {
        return true;
    }
    get left() {
        throw Error("LeafNode has no left node");
    }
    get right() {
        throw Error("LeafNode has no right node");
    }
    writeToBytes(data, start, size) {
        // TODO: Optimize
        data.set(this.root.slice(0, size), start);
    }
    getUint(uintBytes, offsetBytes, clipInfinity) {
        const hIndex = Math.floor(offsetBytes / 4);
        // number has to be masked from an h value
        if (uintBytes < 4) {
            const bitIndex = (offsetBytes % 4) * 8;
            const h = getNodeH(this, hIndex);
            if (uintBytes === 1) {
                return 0xff & (h >> bitIndex);
            }
            else {
                return 0xffff & (h >> bitIndex);
            }
        }
        // number equals the h value
        else if (uintBytes === 4) {
            return getNodeH(this, hIndex) >>> 0;
        }
        // number spans 2 h values
        else if (uintBytes === 8) {
            const low = getNodeH(this, hIndex);
            const high = getNodeH(this, hIndex + 1);
            if (high === 0) {
                return low >>> 0;
            }
            else if (high === -1 && low === -1 && clipInfinity) {
                // Limit uint returns
                return Infinity;
            }
            else {
                return (low >>> 0) + (high >>> 0) * TWO_POWER_32;
            }
        }
        // Bigger uint can't be represented
        else {
            throw Error("uintBytes > 8");
        }
    }
    getUintBigint(uintBytes, offsetBytes) {
        const hIndex = Math.floor(offsetBytes / 4);
        // number has to be masked from an h value
        if (uintBytes < 4) {
            const bitIndex = (offsetBytes % 4) * 8;
            const h = getNodeH(this, hIndex);
            if (uintBytes === 1) {
                return BigInt(0xff & (h >> bitIndex));
            }
            else {
                return BigInt(0xffff & (h >> bitIndex));
            }
        }
        // number equals the h value
        else if (uintBytes === 4) {
            return BigInt(getNodeH(this, hIndex) >>> 0);
        }
        // number spans multiple h values
        else {
            const hRange = Math.ceil(uintBytes / 4);
            let v = BigInt(0);
            for (let i = 0; i < hRange; i++) {
                v += BigInt(getNodeH(this, hIndex + i) >>> 0) << BigInt(32 * i);
            }
            return v;
        }
    }
    setUint(uintBytes, offsetBytes, value, clipInfinity) {
        const hIndex = Math.floor(offsetBytes / 4);
        // number has to be masked from an h value
        if (uintBytes < 4) {
            const bitIndex = (offsetBytes % 4) * 8;
            let h = getNodeH(this, hIndex);
            if (uintBytes === 1) {
                h &= ~(0xff << bitIndex);
                h |= (0xff && value) << bitIndex;
            }
            else {
                h &= ~(0xffff << bitIndex);
                h |= (0xffff && value) << bitIndex;
            }
            setNodeH(this, hIndex, h);
        }
        // number equals the h value
        else if (uintBytes === 4) {
            setNodeH(this, hIndex, value);
        }
        // number spans 2 h values
        else if (uintBytes === 8) {
            if (value === Infinity && clipInfinity) {
                setNodeH(this, hIndex, -1);
                setNodeH(this, hIndex + 1, -1);
            }
            else {
                setNodeH(this, hIndex, value & 0xffffffff);
                setNodeH(this, hIndex + 1, (value / TWO_POWER_32) & 0xffffffff);
            }
        }
        // Bigger uint can't be represented
        else {
            throw Error("uintBytes > 8");
        }
    }
    setUintBigint(uintBytes, offsetBytes, valueBN) {
        const hIndex = Math.floor(offsetBytes / 4);
        // number has to be masked from an h value
        if (uintBytes < 4) {
            const value = Number(valueBN);
            const bitIndex = (offsetBytes % 4) * 8;
            let h = getNodeH(this, hIndex);
            if (uintBytes === 1) {
                h &= ~(0xff << bitIndex);
                h |= (0xff && value) << bitIndex;
            }
            else {
                h &= ~(0xffff << bitIndex);
                h |= (0xffff && value) << bitIndex;
            }
            setNodeH(this, hIndex, h);
        }
        // number equals the h value
        else if (uintBytes === 4) {
            setNodeH(this, hIndex, Number(valueBN));
        }
        // number spans multiple h values
        else {
            const hEnd = hIndex + Math.ceil(uintBytes / 4);
            for (let i = hIndex; i < hEnd; i++) {
                setNodeH(this, i, Number(valueBN & BigInt(0xffffffff)));
                valueBN = valueBN >> BigInt(32);
            }
        }
    }
    bitwiseOrUint(uintBytes, offsetBytes, value) {
        const hIndex = Math.floor(offsetBytes / 4);
        // number has to be masked from an h value
        if (uintBytes < 4) {
            const bitIndex = (offsetBytes % 4) * 8;
            bitwiseOrNodeH(this, hIndex, value << bitIndex);
        }
        // number equals the h value
        else if (uintBytes === 4) {
            bitwiseOrNodeH(this, hIndex, value);
        }
        // number spans multiple h values
        else {
            const hEnd = hIndex + Math.ceil(uintBytes / 4);
            for (let i = hIndex; i < hEnd; i++) {
                bitwiseOrNodeH(this, i, value & 0xffffffff);
                value >>= 32;
            }
        }
    }
}
exports.LeafNode = LeafNode;
function identity(n) {
    return n;
}
exports.identity = identity;
function compose(inner, outer) {
    return function (n) {
        return outer(inner(n));
    };
}
exports.compose = compose;
function getNodeH(node, hIndex) {
    if (hIndex === 0)
        return node.h0;
    else if (hIndex === 1)
        return node.h1;
    else if (hIndex === 2)
        return node.h2;
    else if (hIndex === 3)
        return node.h3;
    else if (hIndex === 4)
        return node.h4;
    else if (hIndex === 5)
        return node.h5;
    else if (hIndex === 6)
        return node.h6;
    else if (hIndex === 7)
        return node.h7;
    else
        throw Error("hIndex > 7");
}
exports.getNodeH = getNodeH;
function setNodeH(node, hIndex, value) {
    if (hIndex === 0)
        node.h0 = value;
    else if (hIndex === 1)
        node.h1 = value;
    else if (hIndex === 2)
        node.h2 = value;
    else if (hIndex === 3)
        node.h3 = value;
    else if (hIndex === 4)
        node.h4 = value;
    else if (hIndex === 5)
        node.h5 = value;
    else if (hIndex === 6)
        node.h6 = value;
    else if (hIndex === 7)
        node.h7 = value;
    else
        throw Error("hIndex > 7");
}
exports.setNodeH = setNodeH;
function bitwiseOrNodeH(node, hIndex, value) {
    if (hIndex === 0)
        node.h0 |= value;
    else if (hIndex === 1)
        node.h1 |= value;
    else if (hIndex === 2)
        node.h2 |= value;
    else if (hIndex === 3)
        node.h3 |= value;
    else if (hIndex === 4)
        node.h4 |= value;
    else if (hIndex === 5)
        node.h5 |= value;
    else if (hIndex === 6)
        node.h6 |= value;
    else if (hIndex === 7)
        node.h7 |= value;
    else
        throw Error("hIndex > 7");
}
exports.bitwiseOrNodeH = bitwiseOrNodeH;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\packedNode.js", {"./node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js","./subtree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\subtree.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5CpackedNode.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;
const subtree_1 = require("./subtree");
const node_1 = require("./node");
function packedRootsBytesToNode(depth, dataView, start, end) {
    const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);
    return subtree_1.subtreeFillToContents(leafNodes, depth);
}
exports.packedRootsBytesToNode = packedRootsBytesToNode;
/**
 * Optimized deserialization of linear bytes to consecutive leaf nodes
 */
function packedRootsBytesToLeafNodes(dataView, start, end) {
    const size = end - start;
    // If the offset in data is not a multiple of 4, Uint32Array can't be used
    // > start offset of Uint32Array should be a multiple of 4
    // NOTE: Performance tests show that using a DataView is as fast as Uint32Array
    const fullNodeCount = Math.floor(size / 32);
    const leafNodes = new Array(Math.ceil(size / 32));
    // Efficiently construct the tree writing to hashObjects directly
    // TODO: Optimize, with this approach each h property is written twice
    for (let i = 0; i < fullNodeCount; i++) {
        const offset = start + i * 32;
        leafNodes[i] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));
    }
    // Consider that the last node may only include partial data
    const remainderBytes = size % 32;
    // Last node
    if (remainderBytes > 0) {
        const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);
        leafNodes[fullNodeCount] = node;
        // Loop to dynamically copy the full h values
        const fullHCount = Math.floor(remainderBytes / 4);
        for (let h = 0; h < fullHCount; h++) {
            node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));
        }
        const remainderUint32 = size % 4;
        if (remainderUint32 > 0) {
            let h = 0;
            for (let i = 0; i < remainderUint32; i++) {
                h |= dataView.getUint8(start + size - remainderUint32 + i) << (i * 8);
            }
            node_1.setNodeH(node, fullHCount, h);
        }
    }
    return leafNodes;
}
exports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;
/**
 * Optimized serialization of consecutive leave nodes to linear bytes
 */
function packedNodeRootsToBytes(dataView, start, size, nodes) {
    // If the offset in data is not a multiple of 4, Uint32Array can't be used
    // > start offset of Uint32Array should be a multiple of 4
    // NOTE: Performance tests show that using a DataView is as fast as Uint32Array
    // Consider that the last node may only include partial data
    const remainderBytes = size % 32;
    // Full nodes
    // Efficiently get hashObjects data into data
    const fullNodeCount = Math.floor(size / 32);
    for (let i = 0; i < fullNodeCount; i++) {
        const node = nodes[i];
        const offset = start + i * 32;
        dataView.setInt32(offset + 0, node.h0, true);
        dataView.setInt32(offset + 4, node.h1, true);
        dataView.setInt32(offset + 8, node.h2, true);
        dataView.setInt32(offset + 12, node.h3, true);
        dataView.setInt32(offset + 16, node.h4, true);
        dataView.setInt32(offset + 20, node.h5, true);
        dataView.setInt32(offset + 24, node.h6, true);
        dataView.setInt32(offset + 28, node.h7, true);
    }
    // Last node
    if (remainderBytes > 0) {
        const node = nodes[fullNodeCount];
        // Loop to dynamically copy the full h values
        const fullHCount = Math.floor(remainderBytes / 4);
        for (let h = 0; h < fullHCount; h++) {
            dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);
        }
        const remainderUint32 = size % 4;
        if (remainderUint32 > 0) {
            const h = node_1.getNodeH(node, fullHCount);
            for (let i = 0; i < remainderUint32; i++) {
                dataView.setUint8(start + size - remainderUint32 + i, (h >> (i * 8)) & 0xff);
            }
        }
    }
}
exports.packedNodeRootsToBytes = packedNodeRootsToBytes;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\packedNode.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\index.js", {"./multi":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\multi.js","./single":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\single.js","./treeOffset":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\treeOffset.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cproof%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = void 0;
const multi_1 = require("./multi");
const single_1 = require("./single");
const treeOffset_1 = require("./treeOffset");
var ProofType;
(function (ProofType) {
    ProofType["single"] = "single";
    ProofType["treeOffset"] = "treeOffset";
    ProofType["multi"] = "multi";
})(ProofType = exports.ProofType || (exports.ProofType = {}));
/**
 * Serialized proofs are prepended with a single byte, denoting their type
 */
exports.ProofTypeSerialized = [
    ProofType.single,
    ProofType.treeOffset,
    ProofType.multi, // 2
];
function createProof(rootNode, input) {
    switch (input.type) {
        case ProofType.single: {
            const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);
            return {
                type: ProofType.single,
                gindex: input.gindex,
                leaf,
                witnesses,
            };
        }
        case ProofType.treeOffset: {
            const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);
            return {
                type: ProofType.treeOffset,
                offsets,
                leaves,
            };
        }
        case ProofType.multi: {
            const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);
            return {
                type: ProofType.multi,
                leaves,
                witnesses,
                gindices,
            };
        }
        default:
            throw new Error("Invalid proof type");
    }
}
exports.createProof = createProof;
function createNodeFromProof(proof) {
    switch (proof.type) {
        case ProofType.single:
            return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);
        case ProofType.treeOffset:
            return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);
        case ProofType.multi:
            return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);
        default:
            throw new Error("Invalid proof type");
    }
}
exports.createNodeFromProof = createNodeFromProof;
function serializeProof(proof) {
    switch (proof.type) {
        case ProofType.single:
        case ProofType.multi:
            throw new Error("Not implemented");
        case ProofType.treeOffset: {
            const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));
            output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);
            treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);
            return output;
        }
        default:
            throw new Error("Invalid proof type");
    }
}
exports.serializeProof = serializeProof;
function deserializeProof(data) {
    const proofType = exports.ProofTypeSerialized[data[0]];
    if (!proofType) {
        throw new Error("Invalid proof type");
    }
    switch (proofType) {
        case ProofType.single:
        case ProofType.multi:
            throw new Error("Not implemented");
        case ProofType.treeOffset: {
            const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);
            return {
                type: ProofType.treeOffset,
                offsets,
                leaves,
            };
        }
        default:
            throw new Error("Invalid proof type");
    }
}
exports.deserializeProof = deserializeProof;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\multi.js", {"../node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js","../tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\tree.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cproof%5Cmulti.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeFromMultiProof = exports.createMultiProof = void 0;
const node_1 = require("../node");
const tree_1 = require("../tree");
const util_1 = require("./util");
/**
 * Create an multiproof
 *
 * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs
 *
 * @param rootNode the root node of the tree
 * @param gindices generalized indices of leaves to include in the proof
 */
function createMultiProof(rootNode, gindices) {
    const tree = new tree_1.Tree(rootNode);
    const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map((gindex) => gindex.toString(2)), false, util_1.SortOrder.Decreasing);
    const leafGindices = gindices.slice().sort((a, b) => (a < b ? 1 : -1));
    const leaves = leafGindices.map((gindex) => tree.getRoot(gindex));
    const witnesses = witnessGindices.map((gindex) => tree.getRoot(gindex));
    return [leaves, witnesses, leafGindices];
}
exports.createMultiProof = createMultiProof;
/**
 * Recreate a `Node` given a multiproof
 *
 * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs
 *
 * @param leaves leaves of a EF multiproof
 * @param witnesses witnesses of a EF multiproof
 * @param gindices generalized indices of the leaves
 */
function createNodeFromMultiProof(leaves, witnesses, gindices) {
    if (leaves.length !== gindices.length) {
        throw new Error("Leaves length should equal gindices length");
    }
    const leafBitstrings = gindices.map((gindex) => gindex.toString(2));
    const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);
    if (witnessBitstrings.length !== witnesses.length) {
        throw new Error("Witnesses length should equal witnesses gindices length");
    }
    // Algorithm:
    // create an object which tracks key-values for each level
    // pre-load leaves and witnesses into the level object
    // level by level, starting from the bottom,
    // find the sibling, create the parent, store it in the next level up
    // the root is in level 1
    const maxLevel = Math.max(leafBitstrings[0]?.length ?? 0, witnessBitstrings[0]?.length ?? 0);
    const levels = Object.fromEntries(Array.from({ length: maxLevel }, (_, i) => [i + 1, {}]));
    // preload leaves and witnesses
    for (let i = 0; i < leafBitstrings.length; i++) {
        const leafBitstring = leafBitstrings[i];
        const leaf = leaves[i];
        levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);
    }
    for (let i = 0; i < witnessBitstrings.length; i++) {
        const witnessBitstring = witnessBitstrings[i];
        const witness = witnesses[i];
        levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);
    }
    for (let i = maxLevel; i > 1; i--) {
        const level = levels[i];
        const parentLevel = levels[i - 1];
        for (const bitstring of Object.keys(level)) {
            const node = level[bitstring];
            // if the node doesn't exist, we've already processed its sibling
            if (!node) {
                continue;
            }
            const isLeft = bitstring[bitstring.length - 1] === "0";
            const parentBitstring = bitstring.substring(0, bitstring.length - 1);
            const siblingBitstring = parentBitstring + (isLeft ? "1" : "0");
            const siblingNode = level[siblingBitstring];
            if (!siblingNode) {
                throw new Error(`Sibling not found: ${siblingBitstring}`);
            }
            // store the parent node
            const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);
            parentLevel[parentBitstring] = parentNode;
            // delete the used nodes
            delete level[bitstring];
            delete level[siblingBitstring];
        }
    }
    const root = levels[1]["1"];
    if (!root) {
        throw new Error("Internal consistency error: no root found");
    }
    return root;
}
exports.createNodeFromMultiProof = createNodeFromMultiProof;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\multi.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\single.js", {"../gindex":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\gindex.js","../node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cproof%5Csingle.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;
const node_1 = require("../node");
const gindex_1 = require("../gindex");
exports.ERR_INVALID_NAV = "Invalid tree navigation";
function createSingleProof(rootNode, index) {
    const witnesses = [];
    let node = rootNode;
    for (const i of gindex_1.gindexIterator(index)) {
        if (i) {
            if (node.isLeaf())
                throw new Error(exports.ERR_INVALID_NAV);
            witnesses.push(node.left.root);
            node = node.right;
        }
        else {
            if (node.isLeaf())
                throw new Error(exports.ERR_INVALID_NAV);
            witnesses.push(node.right.root);
            node = node.left;
        }
    }
    return [node.root, witnesses.reverse()];
}
exports.createSingleProof = createSingleProof;
function createNodeFromSingleProof(gindex, leaf, witnesses) {
    let node = node_1.LeafNode.fromRoot(leaf);
    const w = witnesses.slice().reverse();
    while (gindex > 1) {
        const sibling = node_1.LeafNode.fromRoot(w.pop());
        if (gindex % BigInt(2) === BigInt(0)) {
            node = new node_1.BranchNode(node, sibling);
        }
        else {
            node = new node_1.BranchNode(sibling, node);
        }
        gindex = gindex / BigInt(2);
    }
    return node;
}
exports.createNodeFromSingleProof = createNodeFromSingleProof;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\single.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\treeOffset.js", {"../node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cproof%5CtreeOffset.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeTreeOffsetProof = exports.serializeTreeOffsetProof = exports.computeTreeOffsetProofSerializedLength = exports.createNodeFromTreeOffsetProof = exports.createTreeOffsetProof = exports.treeOffsetProofToNode = exports.nodeToTreeOffsetProof = void 0;
const node_1 = require("../node");
const util_1 = require("./util");
/**
 * Compute offsets and leaves of a tree-offset proof
 *
 * Recursive function
 *
 * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md
 * @param node current node in the tree
 * @param gindex current generalized index in the tree
 * @param proofGindices generalized indices to left include in the proof - must be sorted in-order according to the tree
 */
function nodeToTreeOffsetProof(node, gindex, proofGindices) {
    if (!proofGindices.length || !proofGindices[0].startsWith(gindex)) {
        // there are no proof indices left OR the current subtree contains no remaining proof indices
        return [[], []];
    }
    else if (gindex === proofGindices[0]) {
        // the current node is at the next proof index
        proofGindices.shift();
        return [[], [node.root]];
    }
    else {
        // recursively compute offsets, leaves for the left and right subtree
        const [leftOffsets, leftLeaves] = nodeToTreeOffsetProof(node.left, gindex + "0", proofGindices);
        const [rightOffsets, rightLeaves] = nodeToTreeOffsetProof(node.right, gindex + "1", proofGindices);
        // the offset prepended to the list is # of leaves in the left subtree
        const pivot = leftLeaves.length;
        return [[pivot].concat(leftOffsets, rightOffsets), leftLeaves.concat(rightLeaves)];
    }
}
exports.nodeToTreeOffsetProof = nodeToTreeOffsetProof;
/**
 * Recreate a `Node` given offsets and leaves of a tree-offset proof
 *
 * Recursive definition
 *
 * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md
 */
function treeOffsetProofToNode(offsets, leaves) {
    if (!leaves.length) {
        throw new Error("Proof must contain gt 0 leaves");
    }
    else if (leaves.length === 1) {
        return node_1.LeafNode.fromRoot(leaves[0]);
    }
    else {
        // the offset popped from the list is the # of leaves in the left subtree
        const pivot = offsets[0];
        return new node_1.BranchNode(treeOffsetProofToNode(offsets.slice(1, pivot), leaves.slice(0, pivot)), treeOffsetProofToNode(offsets.slice(pivot), leaves.slice(pivot)));
    }
}
exports.treeOffsetProofToNode = treeOffsetProofToNode;
/**
 * Create a tree-offset proof
 *
 * @param rootNode the root node of the tree
 * @param gindices generalized indices to include in the proof
 */
function createTreeOffsetProof(rootNode, gindices) {
    return nodeToTreeOffsetProof(rootNode, "1", util_1.computeMultiProofBitstrings(gindices.map((g) => g.toString(2))));
}
exports.createTreeOffsetProof = createTreeOffsetProof;
/**
 * Recreate a `Node` given a tree-offset proof
 *
 * @param offsets offsets of a tree-offset proof
 * @param leaves leaves of a tree-offset proof
 */
function createNodeFromTreeOffsetProof(offsets, leaves) {
    // TODO validation
    return treeOffsetProofToNode(offsets, leaves);
}
exports.createNodeFromTreeOffsetProof = createNodeFromTreeOffsetProof;
function computeTreeOffsetProofSerializedLength(offsets, leaves) {
    // add 1 for # of leaves
    return (offsets.length + 1) * 2 + leaves.length * 32;
}
exports.computeTreeOffsetProofSerializedLength = computeTreeOffsetProofSerializedLength;
// Serialized tree offset proof structure:
// # of leaves - 2 bytes
// offsets - 2 bytes each
// leaves - 32 bytes each
function serializeTreeOffsetProof(output, byteOffset, offsets, leaves) {
    const writer = new DataView(output.buffer, output.byteOffset, output.byteLength);
    // set # of leaves
    writer.setUint16(byteOffset, leaves.length, true);
    // set offsets
    const offsetsStartIndex = byteOffset + 2;
    for (let i = 0; i < offsets.length; i++) {
        writer.setUint16(i * 2 + offsetsStartIndex, offsets[i], true);
    }
    // set leaves
    const leavesStartIndex = offsetsStartIndex + offsets.length * 2;
    for (let i = 0; i < leaves.length; i++) {
        output.set(leaves[i], i * 32 + leavesStartIndex);
    }
}
exports.serializeTreeOffsetProof = serializeTreeOffsetProof;
function deserializeTreeOffsetProof(data, byteOffset) {
    const reader = new DataView(data.buffer, data.byteOffset, data.byteLength);
    // get # of leaves
    const leafCount = reader.getUint16(byteOffset, true);
    if (data.length < (leafCount - 1) * 2 + leafCount * 32) {
        throw new Error("Unable to deserialize tree offset proof: not enough bytes");
    }
    // get offsets
    const offsetsStartIndex = byteOffset + 2;
    const offsets = Array.from({ length: leafCount - 1 }, (_, i) => reader.getUint16(i * 2 + offsetsStartIndex, true));
    // get leaves
    const leavesStartIndex = offsetsStartIndex + offsets.length * 2;
    const leaves = Array.from({ length: leafCount }, (_, i) => data.subarray(i * 32 + leavesStartIndex, (i + 1) * 32 + leavesStartIndex));
    return [offsets, leaves];
}
exports.deserializeTreeOffsetProof = deserializeTreeOffsetProof;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\treeOffset.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\util.js", {"../gindex":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\gindex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Cproof%5Cutil.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;
const gindex_1 = require("../gindex");
// Not currently in use, but simpler implementation useful for testing
/**
 * Compute both the path and branch indices
 *
 * Path indices are parent indices upwards toward the root
 * Branch indices are witnesses required for a merkle proof
 */
function computeProofGindices(gindex) {
    const path = new Set();
    const branch = new Set();
    let g = gindex;
    while (g > 1) {
        path.add(g);
        branch.add(gindex_1.gindexSibling(g));
        g = gindex_1.gindexParent(g);
    }
    return { path, branch };
}
exports.computeProofGindices = computeProofGindices;
/**
 * Compute both the path and branch indices
 *
 * Path indices are parent indices upwards toward the root
 * Branch indices are witnesses required for a merkle proof
 */
function computeProofBitstrings(gindex) {
    const path = new Set();
    const branch = new Set();
    let g = gindex;
    while (g.length > 1) {
        path.add(g);
        const lastBit = g[g.length - 1];
        const parent = g.substring(0, g.length - 1);
        branch.add(parent + (Number(lastBit) ^ 1));
        g = parent;
    }
    return { path, branch };
}
exports.computeProofBitstrings = computeProofBitstrings;
/**
 * Sort generalized indices in-order
 * @param bitLength maximum bit length of generalized indices to sort
 */
function sortInOrderBitstrings(gindices, bitLength) {
    if (!gindices.length) {
        return [];
    }
    return gindices
        .map((g) => g.padEnd(bitLength))
        .sort()
        .map((g) => g.trim());
}
exports.sortInOrderBitstrings = sortInOrderBitstrings;
/**
 * Sort generalized indices in decreasing order
 */
function sortDecreasingBitstrings(gindices) {
    if (!gindices.length) {
        return [];
    }
    return gindices.sort((a, b) => {
        if (a.length < b.length) {
            return 1;
        }
        else if (b.length < a.length) {
            return -1;
        }
        let aPos0 = a.indexOf("0");
        let bPos0 = b.indexOf("0");
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (aPos0 === -1) {
                return -1;
            }
            else if (bPos0 === -1) {
                return 1;
            }
            if (aPos0 < bPos0) {
                return 1;
            }
            else if (bPos0 < aPos0) {
                return -1;
            }
            aPos0 = a.indexOf("0", aPos0 + 1);
            bPos0 = b.indexOf("0", bPos0 + 1);
        }
    });
}
exports.sortDecreasingBitstrings = sortDecreasingBitstrings;
/**
 * Filter out parent generalized indices
 */
function filterParentBitstrings(gindices) {
    const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);
    const filtered = [];
    outer: for (let i = 0; i < sortedBitstrings.length; i++) {
        const bsA = sortedBitstrings[i];
        for (let j = i + 1; j < sortedBitstrings.length; j++) {
            const bsB = sortedBitstrings[j];
            if (bsB.startsWith(bsA)) {
                continue outer;
            }
        }
        filtered.push(bsA);
    }
    return filtered;
}
exports.filterParentBitstrings = filterParentBitstrings;
var SortOrder;
(function (SortOrder) {
    SortOrder[SortOrder["InOrder"] = 0] = "InOrder";
    SortOrder[SortOrder["Decreasing"] = 1] = "Decreasing";
    SortOrder[SortOrder["Unsorted"] = 2] = "Unsorted";
})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
/**
 * Return the set of generalized indices required for a multiproof
 * This may include all leaves and any necessary witnesses
 * @param gindices leaves to include in proof
 * @returns all generalized indices required for a multiproof (leaves and witnesses), deduplicated and sorted
 */
function computeMultiProofBitstrings(gindices, includeLeaves = true, sortOrder = SortOrder.InOrder) {
    const leaves = filterParentBitstrings(gindices);
    // Maybe initialize the proof indices with the leaves
    const proof = new Set(includeLeaves ? leaves : []);
    const paths = new Set();
    const branches = new Set();
    // Collect all path indices and all branch indices
    let maxBitLength = 1;
    for (const gindex of leaves) {
        if (gindex.length > maxBitLength)
            maxBitLength = gindex.length;
        const { path, branch } = computeProofBitstrings(gindex);
        path.forEach((g) => paths.add(g));
        branch.forEach((g) => branches.add(g));
    }
    // Remove all branches that are included in the paths
    paths.forEach((g) => branches.delete(g));
    // Add all remaining branches to the leaves
    branches.forEach((g) => proof.add(g));
    switch (sortOrder) {
        case SortOrder.InOrder:
            return sortInOrderBitstrings(Array.from(proof), maxBitLength);
        case SortOrder.Decreasing:
            return sortDecreasingBitstrings(Array.from(proof));
        case SortOrder.Unsorted:
            return Array.from(proof);
    }
}
exports.computeMultiProofBitstrings = computeMultiProofBitstrings;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\util.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\subtree.js", {"./node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js","./zeroNode":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\zeroNode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Csubtree.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;
const node_1 = require("./node");
const zeroNode_1 = require("./zeroNode");
function subtreeFillToDepth(bottom, depth) {
    let node = bottom;
    while (depth > 0) {
        node = new node_1.BranchNode(node, node);
        depth--;
    }
    return node;
}
exports.subtreeFillToDepth = subtreeFillToDepth;
function subtreeFillToLength(bottom, depth, length) {
    const maxLength = 1 << depth;
    if (length > maxLength)
        throw new Error("ERR_TOO_MANY_NODES");
    if (length === maxLength)
        return subtreeFillToDepth(bottom, depth);
    if (depth === 0) {
        if (length === 1)
            return bottom;
        else
            throw new Error("ERR_NAVIGATION");
    }
    if (depth === 1) {
        return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));
    }
    const pivot = maxLength >> 1;
    if (length <= pivot) {
        return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));
    }
    else {
        return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));
    }
}
exports.subtreeFillToLength = subtreeFillToLength;
/**
 * WARNING: Mutates the provided nodes array.
 * TODO: Don't mutate the nodes array.
 */
function subtreeFillToContents(nodes, depth) {
    const maxLength = 2 ** depth;
    if (nodes.length > maxLength) {
        throw new Error(`nodes.length ${nodes.length} over maxIndex at depth ${depth}`);
    }
    if (nodes.length === 0) {
        return zeroNode_1.zeroNode(depth);
    }
    if (depth === 0) {
        return nodes[0];
    }
    if (depth === 1) {
        return nodes.length > 1
            ? // All nodes at depth 1 available
                new node_1.BranchNode(nodes[0], nodes[1])
            : // Pad with zero node
                new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0));
    }
    let count = nodes.length;
    for (let d = depth; d > 0; d--) {
        const countRemainder = count % 2;
        const countEven = count - countRemainder;
        // For each depth level compute the new BranchNodes and overwrite the nodes array
        for (let i = 0; i < countEven; i += 2) {
            nodes[i / 2] = new node_1.BranchNode(nodes[i], nodes[i + 1]);
        }
        if (countRemainder > 0) {
            nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));
        }
        // If there was remainer, 2 nodes are added to the count
        count = countEven / 2 + countRemainder;
    }
    return nodes[0];
}
exports.subtreeFillToContents = subtreeFillToContents;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\subtree.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\tree.js", {"./gindex":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\gindex.js","./node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js","./proof":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\index.js","./proof/single":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\proof\\single.js","./zeroNode":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\zeroNode.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5Ctree.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;
const zeroNode_1 = require("./zeroNode");
const gindex_1 = require("./gindex");
const node_1 = require("./node");
const proof_1 = require("./proof");
const single_1 = require("./proof/single");
/**
 * Binary merkle tree
 *
 * Wrapper around immutable `Node` to support mutability.
 *
 * Mutability between a parent tree and subtree is achieved by maintaining a `hook` callback, which updates the parent when the subtree is updated.
 */
class Tree {
    constructor(node, hook) {
        this._rootNode = node;
        if (hook) {
            if (typeof WeakRef === "undefined") {
                this.hook = hook;
            }
            else {
                this.hook = new WeakRef(hook);
            }
        }
    }
    /**
     * Create a `Tree` from a `Proof` object
     */
    static createFromProof(proof) {
        return new Tree(proof_1.createNodeFromProof(proof));
    }
    /**
     * The root node of the tree
     */
    get rootNode() {
        return this._rootNode;
    }
    /**
     *
     * Setting the root node will trigger a call to the tree's `hook` if it exists.
     */
    set rootNode(newRootNode) {
        this._rootNode = newRootNode;
        if (this.hook) {
            // WeakRef should not change status during a program's execution
            // So, use WeakRef feature detection to assume the type of this.hook
            // to minimize the memory footprint of Tree
            if (typeof WeakRef === "undefined") {
                this.hook(newRootNode);
            }
            else {
                const hookVar = this.hook.deref();
                if (hookVar) {
                    hookVar(newRootNode);
                }
                else {
                    // Hook has been garbage collected, no need to keep the hookRef
                    this.hook = undefined;
                }
            }
        }
    }
    /**
     * The root hash of the tree
     */
    get root() {
        return this.rootNode.root;
    }
    /**
     * Return a copy of the tree
     */
    clone() {
        return new Tree(this.rootNode);
    }
    /**
     * Return the subtree at the specified gindex.
     *
     * Note: The returned subtree will have a `hook` attached to the parent tree.
     * Updates to the subtree will result in updates to the parent.
     */
    getSubtree(index) {
        return new Tree(this.getNode(index), (node) => this.setNode(index, node));
    }
    /**
     * Return the node at the specified gindex.
     */
    getNode(gindex) {
        return getNode(this.rootNode, gindex);
    }
    /**
     * Return the node at the specified depth and index.
     *
     * Supports index up to `Number.MAX_SAFE_INTEGER`.
     */
    getNodeAtDepth(depth, index) {
        return getNodeAtDepth(this.rootNode, depth, index);
    }
    /**
     * Return the hash at the specified gindex.
     */
    getRoot(index) {
        return this.getNode(index).root;
    }
    /**
     * Set the node at at the specified gindex.
     */
    setNode(gindex, n) {
        this.rootNode = setNode(this.rootNode, gindex, n);
    }
    /**
     * Traverse to the node at the specified gindex,
     * then apply the function to get a new node and set the node at the specified gindex with the result.
     *
     * This is a convenient method to avoid traversing the tree 2 times to
     * get and set.
     */
    setNodeWithFn(gindex, getNewNode) {
        this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);
    }
    /**
     * Set the node at the specified depth and index.
     *
     * Supports index up to `Number.MAX_SAFE_INTEGER`.
     */
    setNodeAtDepth(depth, index, node) {
        this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);
    }
    /**
     * Set the hash at the specified gindex.
     *
     * Note: This will set a new `LeafNode` at the specified gindex.
     */
    setRoot(index, root) {
        this.setNode(index, node_1.LeafNode.fromRoot(root));
    }
    /**
     * Fast read-only iteration
     * In-order traversal of nodes at `depth`
     * starting from the `startIndex`-indexed node
     * iterating through `count` nodes
     *
     * Supports index up to `Number.MAX_SAFE_INTEGER`.
     */
    getNodesAtDepth(depth, startIndex, count) {
        return getNodesAtDepth(this.rootNode, depth, startIndex, count);
    }
    /**
     * Fast read-only iteration
     * In-order traversal of nodes at `depth`
     * starting from the `startIndex`-indexed node
     * iterating through `count` nodes
     *
     * Supports index up to `Number.MAX_SAFE_INTEGER`.
     */
    iterateNodesAtDepth(depth, startIndex, count) {
        return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);
    }
    /**
     * Return a merkle proof for the node at the specified gindex.
     */
    getSingleProof(index) {
        return single_1.createSingleProof(this.rootNode, index)[1];
    }
    /**
     * Return a merkle proof for the proof input.
     *
     * This method can be used to create multiproofs.
     */
    getProof(input) {
        return proof_1.createProof(this.rootNode, input);
    }
}
exports.Tree = Tree;
/**
 * Return the node at the specified gindex.
 */
function getNode(rootNode, gindex) {
    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
    let node = rootNode;
    for (let i = 1; i < gindexBitstring.length; i++) {
        if (node.isLeaf()) {
            throw new Error(`Invalid tree - found leaf at depth ${i}`);
        }
        // If bit is set, means navigate right
        node = gindexBitstring[i] === "1" ? node.right : node.left;
    }
    return node;
}
exports.getNode = getNode;
/**
 * Set the node at at the specified gindex.
 * Returns the new root node.
 */
function setNode(rootNode, gindex, n) {
    // Pre-compute entire bitstring instead of using an iterator (25% faster)
    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
    const parentNodes = getParentNodes(rootNode, gindexBitstring);
    return rebindNodeToRoot(gindexBitstring, parentNodes, n);
}
exports.setNode = setNode;
/**
 * Traverse to the node at the specified gindex,
 * then apply the function to get a new node and set the node at the specified gindex with the result.
 *
 * This is a convenient method to avoid traversing the tree 2 times to
 * get and set.
 *
 * Returns the new root node.
 */
function setNodeWithFn(rootNode, gindex, getNewNode) {
    // Pre-compute entire bitstring instead of using an iterator (25% faster)
    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);
    const parentNodes = getParentNodes(rootNode, gindexBitstring);
    const lastParentNode = parentNodes[parentNodes.length - 1];
    const lastBit = gindexBitstring[gindexBitstring.length - 1];
    const oldNode = lastBit === "1" ? lastParentNode.right : lastParentNode.left;
    const newNode = getNewNode(oldNode);
    return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);
}
exports.setNodeWithFn = setNodeWithFn;
/**
 * Traverse the tree from root node, ignore the last bit to get all parent nodes
 * of the specified bitstring.
 */
function getParentNodes(rootNode, bitstring) {
    let node = rootNode;
    // Keep a list of all parent nodes of node at gindex `index`. Then walk the list
    // backwards to rebind them "recursively" with the new nodes without using functions
    const parentNodes = [rootNode];
    // Ignore the first bit, left right directions are at bits [1,..]
    // Ignore the last bit, no need to push the target node to the parentNodes array
    for (let i = 1; i < bitstring.length - 1; i++) {
        // Compare to string directly to prevent unnecessary type conversions
        if (bitstring[i] === "1") {
            node = node.right;
        }
        else {
            node = node.left;
        }
        parentNodes.push(node);
    }
    return parentNodes;
}
/**
 * Build a new tree structure from bitstring, parentNodes and a new node.
 * Returns the new root node.
 */
function rebindNodeToRoot(bitstring, parentNodes, newNode) {
    let node = newNode;
    // Ignore the first bit, left right directions are at bits [1,..]
    // Iterate the list backwards including the last bit, but offset the parentNodes array
    // by one since the first bit in bitstring was ignored in the previous loop
    for (let i = bitstring.length - 1; i >= 1; i--) {
        if (bitstring[i] === "1") {
            node = new node_1.BranchNode(parentNodes[i - 1].left, node);
        }
        else {
            node = new node_1.BranchNode(node, parentNodes[i - 1].right);
        }
    }
    return node;
}
/**
 * Supports index up to `Number.MAX_SAFE_INTEGER`.
 */
function getNodeAtDepth(rootNode, depth, index) {
    if (depth === 0) {
        return rootNode;
    }
    if (depth === 1) {
        return index === 0 ? rootNode.left : rootNode.right;
    }
    // Ignore first bit "1", then substract 1 to get to the parent
    const depthiRoot = depth - 1;
    const depthiParent = 0;
    let node = rootNode;
    for (let d = depthiRoot; d >= depthiParent; d--) {
        node = isLeftNode(d, index) ? node.left : node.right;
    }
    return node;
}
exports.getNodeAtDepth = getNodeAtDepth;
/**
 * Supports index up to `Number.MAX_SAFE_INTEGER`.
 */
function setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {
    // TODO: OPTIMIZE (if necessary)
    return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);
}
exports.setNodeAtDepth = setNodeAtDepth;
/**
 * Set multiple nodes in batch, editing and traversing nodes strictly once.
 *
 * - gindexes MUST be sorted in ascending order beforehand.
 * - All gindexes must be at the exact same depth.
 * - Depth must be > 0, if 0 just replace the root node.
 *
 * Strategy: for each gindex in `gindexes` navigate to the depth of its parent,
 * and create a new parent. Then calculate the closest common depth with the next
 * gindex and navigate upwards creating or caching nodes as necessary. Loop and repeat.
 *
 * Supports index up to `Number.MAX_SAFE_INTEGER`.
 */
function setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {
    // depth depthi   gindexes   indexes
    // 0     1           1          0
    // 1     0         2   3      0   1
    // 2     -        4 5 6 7    0 1 2 3
    // '10' means, at depth 1, node is at the left
    //
    // For index N check if the bit at position depthi is set to navigate right at depthi
    // ```
    // mask = 1 << depthi
    // goRight = (N & mask) == mask
    // ```
    // If depth is 0 there's only one node max and the optimization below will cause a navigation error.
    // For this case, check if there's a new root node and return it, otherwise the current rootNode.
    if (nodesDepth === 0) {
        return nodes.length > 0 ? nodes[0] : rootNode;
    }
    /**
     * Contiguous filled stack of parent nodes. It get filled in the first descent
     * Indexed by depthi
     */
    const parentNodeStack = new Array(nodesDepth);
    /**
     * Temp stack of left parent nodes, index by depthi.
     * Node leftParentNodeStack[depthi] is a node at d = depthi - 1, such that:
     * ```
     * parentNodeStack[depthi].left = leftParentNodeStack[depthi]
     * ```
     */
    const leftParentNodeStack = new Array(nodesDepth);
    // Ignore first bit "1", then substract 1 to get to the parent
    const depthiRoot = nodesDepth - 1;
    const depthiParent = 0;
    let depthi = depthiRoot;
    let node = rootNode;
    // Insert root node to make the loop below general
    parentNodeStack[depthiRoot] = rootNode;
    // TODO: Iterate to depth 32 to allow using bit ops
    // for (; depthi >= 32; depthi--) {
    //   node = node.left;
    // }
    for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i];
        // Navigate down until parent depth, and store the chain of nodes
        //
        // Starts from latest common depth, so node is the parent node at `depthi`
        // When persisting the next node, store at the `d - 1` since its the child of node at `depthi`
        //
        // Stops at the level above depthiParent. For the re-binding routing below node must be at depthiParent
        for (let d = depthi; d > depthiParent; d--) {
            node = isLeftNode(d, index) ? node.left : node.right;
            parentNodeStack[d - 1] = node;
        }
        depthi = depthiParent;
        // If this is the left node, check first it the next node is on the right
        //
        //   -    If both nodes exist, create new
        //  / \
        // x   x
        //
        //   -    If only the left node exists, rebind left
        //  / \
        // x   -
        //
        //   -    If this is the right node, only the right node exists, rebind right
        //  / \
        // -   x
        // d = 0, mask = 1 << d = 1
        const isLeftLeafNode = (index & 1) !== 1;
        if (isLeftLeafNode) {
            // Next node is the very next to the right of current node
            if (index + 1 === indexes[i + 1]) {
                node = new node_1.BranchNode(nodes[i], nodes[i + 1]);
                // Move pointer one extra forward since node has consumed two nodes
                i++;
            }
            else {
                node = new node_1.BranchNode(nodes[i], node.right);
            }
        }
        else {
            node = new node_1.BranchNode(node.left, nodes[i]);
        }
        // Here `node` is the new BranchNode at depthi `depthiParent`
        // Now climb upwards until finding the common node with the next index
        // For the last iteration, climb to the root at `depthiRoot`
        const isLastIndex = i >= indexes.length - 1;
        const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i + 1]);
        // When climbing up from a left node there are two possible paths
        // 1. Go to the right of the parent: Store left node to rebind latter
        // 2. Go another level up: Will never visit the left node again, so must rebind now
        // 🡼 \     Rebind left only, will never visit this node again
        // 🡽 /\
        //
        //    / 🡽  Rebind left only (same as above)
        // 🡽 /\
        //
        // 🡽 /\ 🡾  Store left node to rebind the entire node when returning
        //
        // 🡼 \     Rebind right with left if exists, will never visit this node again
        //   /\ 🡼
        //
        //    / 🡽  Rebind right with left if exists (same as above)
        //   /\ 🡼
        for (let d = depthiParent + 1; d <= diffDepthi; d++) {
            // If node is on the left, store for latter
            // If node is on the right merge with stored left node
            if (isLeftNode(d, index)) {
                if (isLastIndex || d !== diffDepthi) {
                    // If it's last index, bind with parent since it won't navigate to the right anymore
                    // Also, if still has to move upwards, rebind since the node won't be visited anymore
                    node = new node_1.BranchNode(node, parentNodeStack[d].right);
                }
                else {
                    // Only store the left node if it's at d = diffDepth
                    leftParentNodeStack[d] = node;
                    node = parentNodeStack[d];
                }
            }
            else {
                const leftNode = leftParentNodeStack[d];
                if (leftNode !== undefined) {
                    node = new node_1.BranchNode(leftNode, node);
                    leftParentNodeStack[d] = undefined;
                }
                else {
                    node = new node_1.BranchNode(parentNodeStack[d].left, node);
                }
            }
        }
        // Prepare next loop
        // Go to the parent of the depth with diff, to switch branches to the right
        depthi = diffDepthi;
    }
    // Done, return new root node
    return node;
}
exports.setNodesAtDepth = setNodesAtDepth;
/**
 * Fast read-only iteration
 * In-order traversal of nodes at `depth`
 * starting from the `startIndex`-indexed node
 * iterating through `count` nodes
 *
 * **Strategy**
 * 1. Navigate down to parentDepth storing a stack of parents
 * 2. At target level push current node
 * 3. Go up to the first level that navigated left
 * 4. Repeat (1) for next index
 */
function getNodesAtDepth(rootNode, depth, startIndex, count) {
    // Optimized paths for short trees (x20 times faster)
    if (depth === 0) {
        return startIndex === 0 && count > 0 ? [rootNode] : [];
    }
    else if (depth === 1) {
        if (count === 0) {
            return [];
        }
        else if (count === 1) {
            return startIndex === 0 ? [rootNode.left] : [rootNode.right];
        }
        else {
            return [rootNode.left, rootNode.right];
        }
    }
    // Ignore first bit "1", then substract 1 to get to the parent
    const depthiRoot = depth - 1;
    const depthiParent = 0;
    let depthi = depthiRoot;
    let node = rootNode;
    // Contiguous filled stack of parent nodes. It get filled in the first descent
    // Indexed by depthi
    const parentNodeStack = new Array(depth);
    const isLeftStack = new Array(depth);
    const nodes = new Array(count);
    // Insert root node to make the loop below general
    parentNodeStack[depthiRoot] = rootNode;
    for (let i = 0; i < count; i++) {
        for (let d = depthi; d >= depthiParent; d--) {
            if (d !== depthi) {
                parentNodeStack[d] = node;
            }
            const isLeft = isLeftNode(d, startIndex + i);
            isLeftStack[d] = isLeft;
            node = isLeft ? node.left : node.right;
        }
        nodes[i] = node;
        // Find the first depth where navigation when left.
        // Store that height and go right from there
        for (let d = depthiParent; d <= depthiRoot; d++) {
            if (isLeftStack[d] === true) {
                depthi = d;
                break;
            }
        }
        node = parentNodeStack[depthi];
    }
    return nodes;
}
exports.getNodesAtDepth = getNodesAtDepth;
/**
 * @see getNodesAtDepth but instead of pushing to an array, it yields
 */
function* iterateNodesAtDepth(rootNode, depth, startIndex, count) {
    const endIndex = startIndex + count;
    // Ignore first bit "1", then substract 1 to get to the parent
    const depthiRoot = depth - 1;
    const depthiParent = 0;
    let depthi = depthiRoot;
    let node = rootNode;
    // Contiguous filled stack of parent nodes. It get filled in the first descent
    // Indexed by depthi
    const parentNodeStack = new Array(depth);
    const isLeftStack = new Array(depth);
    // Insert root node to make the loop below general
    parentNodeStack[depthiRoot] = rootNode;
    for (let index = startIndex; index < endIndex; index++) {
        for (let d = depthi; d >= depthiParent; d--) {
            if (d !== depthi) {
                parentNodeStack[d] = node;
            }
            const isLeft = isLeftNode(d, index);
            isLeftStack[d] = isLeft;
            node = isLeft ? node.left : node.right;
        }
        yield node;
        // Find the first depth where navigation when left.
        // Store that height and go right from there
        for (let d = depthiParent; d <= depthiRoot; d++) {
            if (isLeftStack[d] === true) {
                depthi = d;
                break;
            }
        }
        node = parentNodeStack[depthi];
    }
}
exports.iterateNodesAtDepth = iterateNodesAtDepth;
/**
 * Zero's all nodes right of index with constant depth of `nodesDepth`.
 *
 * For example, zero-ing this tree at depth 2 after index 0
 * ```
 *    X              X
 *  X   X    ->    X   0
 * X X X X        X 0 0 0
 * ```
 *
 * Or, zero-ing this tree at depth 3 after index 2
 * ```
 *        X                     X
 *    X       X             X       0
 *  X   X   X   X    ->   X   X   0   0
 * X X X X X X X X       X X X 0 0 0 0 0
 * ```
 *
 * The strategy is to first navigate down to `nodesDepth` and `index` and keep a stack of parents.
 * Then navigate up re-binding:
 * - If navigated to the left rebind with zeroNode()
 * - If navigated to the right rebind with parent.left from the stack
 */
function treeZeroAfterIndex(rootNode, nodesDepth, index) {
    // depth depthi   gindexes   indexes
    // 0     1           1          0
    // 1     0         2   3      0   1
    // 2     -        4 5 6 7    0 1 2 3
    // '10' means, at depth 1, node is at the left
    //
    // For index N check if the bit at position depthi is set to navigate right at depthi
    // ```
    // mask = 1 << depthi
    // goRight = (N & mask) == mask
    // ```
    // Degenerate case where tree is zero after a negative index (-1).
    // All positive indexes are zero, so the entire tree is zero. Return cached zero node as root.
    if (index < 0) {
        return zeroNode_1.zeroNode(nodesDepth);
    }
    /**
     * Contiguous filled stack of parent nodes. It get filled in the first descent
     * Indexed by depthi
     */
    const parentNodeStack = new Array(nodesDepth);
    // Ignore first bit "1", then substract 1 to get to the parent
    const depthiRoot = nodesDepth - 1;
    const depthiParent = 0;
    let depthi = depthiRoot;
    let node = rootNode;
    // Insert root node to make the loop below general
    parentNodeStack[depthiRoot] = rootNode;
    // Navigate down until parent depth, and store the chain of nodes
    //
    // Stops at the depthiParent level. To rebind below down to `nodesDepth`
    for (let d = depthi; d >= depthiParent; d--) {
        node = isLeftNode(d, index) ? node.left : node.right;
        parentNodeStack[d - 1] = node;
    }
    depthi = depthiParent;
    // Now climb up re-binding with either zero of existing tree.
    for (let d = depthiParent; d <= depthiRoot; d++) {
        if (isLeftNode(d, index)) {
            // If navigated to the left, then all the child nodes of the right node are NOT part of the new tree.
            // So re-bind new `node` with a zeroNode at the current depth.
            node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));
        }
        else {
            // If navigated to the right, then all the child nodes of the left node are part of the new tree.
            // So re-bind new `node` with the existing left node of the parent.
            node = new node_1.BranchNode(parentNodeStack[d].left, node);
        }
    }
    // Done, return new root node
    return node;
}
exports.treeZeroAfterIndex = treeZeroAfterIndex;
/**
 * Returns true if the `index` at `depth` is a left node, false if it is a right node.
 *
 * Supports index up to `Number.MAX_SAFE_INTEGER`.
 * In Eth2 case the biggest tree's index is 2**40 (VALIDATOR_REGISTRY_LIMIT)
 */
function isLeftNode(depthi, index) {
    if (depthi > 31) {
        // Javascript can only do bitwise ops with 32 bit numbers.
        // Shifting left 1 by 32 wraps around and becomes 1.
        // Get the high part of `index` and adjust depthi
        const indexHi = (index / 2 ** 32) >>> 0;
        const mask = 1 << (depthi - 32);
        return (indexHi & mask) !== mask;
    }
    const mask = 1 << depthi;
    return (index & mask) !== mask;
}
/**
 * depth depthi   gindexes   indexes
 * 0     1           1          0
 * 1     0         2   3      0   1
 * 2     -        4 5 6 7    0 1 2 3
 *
 * **Conditions**:
 * - `from` and `to` must not be equal
 *
 * @param from Index
 * @param to Index
 */
function findDiffDepthi(from, to) {
    return (
    // (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2
    Math.ceil(Math.log2(-~(from ^ to))) -
        // Must offset by one to match the depthi scale
        1);
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\tree.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\zeroNode.js", {"./node":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\node.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cpersistent-merkle-tree%5Clib%5CzeroNode.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zeroNode = void 0;
const node_1 = require("./node");
const zeroes = [node_1.LeafNode.fromZero()];
/**
 * Return the `Node` at a specified height from the merkle tree made of "zero data"
 * ```
 *           ...
 *          /
 *         x           <- height 2
 *      /     \
 *     x       x       <- height 1
 *   /  \      /  \
 * 0x0  0x0  0x0  0x0  <- height 0
 * ```
 */
function zeroNode(height) {
    if (height >= zeroes.length) {
        for (let i = zeroes.length; i <= height; i++) {
            zeroes[i] = new node_1.BranchNode(zeroes[i - 1], zeroes[i - 1]);
        }
    }
    return zeroes[height];
}
exports.zeroNode = zeroNode;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz>@chainsafe/persistent-merkle-tree",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\zeroNode.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\branchNodeStruct.js", {"@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CbranchNodeStruct.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchNodeStruct = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
/**
 * BranchNode whose children's data is represented as a struct, not a tree.
 *
 * This approach is usefull for memory efficiency of data that is not modified often, for example the validators
 * registry in Ethereum consensus `state.validators`. The tradeoff is that getting the hash, are proofs is more
 * expensive because the tree has to be recreated every time.
 */
class BranchNodeStruct extends persistent_merkle_tree_1.Node {
    constructor(valueToNode, value) {
        // First null value is to save an extra variable to check if a node has a root or not
        super(null, 0, 0, 0, 0, 0, 0, 0);
        this.valueToNode = valueToNode;
        this.value = value;
    }
    get rootHashObject() {
        if (this.h0 === null) {
            const node = this.valueToNode(this.value);
            super.applyHash(node.rootHashObject);
        }
        return this;
    }
    get root() {
        return persistent_merkle_tree_1.hashObjectToUint8Array(this.rootHashObject);
    }
    isLeaf() {
        return false;
    }
    get left() {
        return this.valueToNode(this.value).left;
    }
    get right() {
        return this.valueToNode(this.value).right;
    }
}
exports.BranchNodeStruct = BranchNodeStruct;
//# sourceMappingURL=branchNodeStruct.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\branchNodeStruct.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\index.js", {"./type/abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\abstract.js","./type/array":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\array.js","./type/basic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js","./type/bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitArray.js","./type/bitList":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitList.js","./type/bitVector":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitVector.js","./type/boolean":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\boolean.js","./type/byteArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteArray.js","./type/byteList":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteList.js","./type/byteVector":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteVector.js","./type/composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","./type/container":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\container.js","./type/containerNodeStruct":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\containerNodeStruct.js","./type/listBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\listBasic.js","./type/listComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\listComposite.js","./type/none":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\none.js","./type/uint":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\uint.js","./type/union":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\union.js","./type/vectorBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\vectorBasic.js","./type/vectorComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\vectorComposite.js","./util/byteArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\byteArray.js","./util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","./value/bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\value\\bitArray.js","./view/abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js","./viewDU/abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hash64 = exports.byteArrayEquals = exports.toHexString = exports.fromHexString = exports.getUint8ByteToBitBooleanArray = exports.BitArray = exports.TreeViewDU = exports.TreeView = exports.isCompositeType = exports.CompositeType = exports.isBasicType = exports.BasicType = exports.Type = exports.ByteArrayType = exports.BitArrayType = exports.ArrayType = exports.VectorCompositeType = exports.VectorBasicType = exports.UnionType = exports.UintNumberType = exports.UintBigintType = exports.NoneType = exports.ListCompositeType = exports.ListBasicType = exports.ContainerNodeStructType = exports.ContainerType = exports.ByteVectorType = exports.ByteListType = exports.BooleanType = exports.BitVectorType = exports.BitListType = void 0;
// Types
var bitList_1 = require("./type/bitList");
Object.defineProperty(exports, "BitListType", { enumerable: true, get: function () { return bitList_1.BitListType; } });
var bitVector_1 = require("./type/bitVector");
Object.defineProperty(exports, "BitVectorType", { enumerable: true, get: function () { return bitVector_1.BitVectorType; } });
var boolean_1 = require("./type/boolean");
Object.defineProperty(exports, "BooleanType", { enumerable: true, get: function () { return boolean_1.BooleanType; } });
var byteList_1 = require("./type/byteList");
Object.defineProperty(exports, "ByteListType", { enumerable: true, get: function () { return byteList_1.ByteListType; } });
var byteVector_1 = require("./type/byteVector");
Object.defineProperty(exports, "ByteVectorType", { enumerable: true, get: function () { return byteVector_1.ByteVectorType; } });
var container_1 = require("./type/container");
Object.defineProperty(exports, "ContainerType", { enumerable: true, get: function () { return container_1.ContainerType; } });
var containerNodeStruct_1 = require("./type/containerNodeStruct");
Object.defineProperty(exports, "ContainerNodeStructType", { enumerable: true, get: function () { return containerNodeStruct_1.ContainerNodeStructType; } });
var listBasic_1 = require("./type/listBasic");
Object.defineProperty(exports, "ListBasicType", { enumerable: true, get: function () { return listBasic_1.ListBasicType; } });
var listComposite_1 = require("./type/listComposite");
Object.defineProperty(exports, "ListCompositeType", { enumerable: true, get: function () { return listComposite_1.ListCompositeType; } });
var none_1 = require("./type/none");
Object.defineProperty(exports, "NoneType", { enumerable: true, get: function () { return none_1.NoneType; } });
var uint_1 = require("./type/uint");
Object.defineProperty(exports, "UintBigintType", { enumerable: true, get: function () { return uint_1.UintBigintType; } });
Object.defineProperty(exports, "UintNumberType", { enumerable: true, get: function () { return uint_1.UintNumberType; } });
var union_1 = require("./type/union");
Object.defineProperty(exports, "UnionType", { enumerable: true, get: function () { return union_1.UnionType; } });
var vectorBasic_1 = require("./type/vectorBasic");
Object.defineProperty(exports, "VectorBasicType", { enumerable: true, get: function () { return vectorBasic_1.VectorBasicType; } });
var vectorComposite_1 = require("./type/vectorComposite");
Object.defineProperty(exports, "VectorCompositeType", { enumerable: true, get: function () { return vectorComposite_1.VectorCompositeType; } });
// Base types
var array_1 = require("./type/array");
Object.defineProperty(exports, "ArrayType", { enumerable: true, get: function () { return array_1.ArrayType; } });
var bitArray_1 = require("./type/bitArray");
Object.defineProperty(exports, "BitArrayType", { enumerable: true, get: function () { return bitArray_1.BitArrayType; } });
var byteArray_1 = require("./type/byteArray");
Object.defineProperty(exports, "ByteArrayType", { enumerable: true, get: function () { return byteArray_1.ByteArrayType; } });
// Base type clases
var abstract_1 = require("./type/abstract");
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return abstract_1.Type; } });
var basic_1 = require("./type/basic");
Object.defineProperty(exports, "BasicType", { enumerable: true, get: function () { return basic_1.BasicType; } });
Object.defineProperty(exports, "isBasicType", { enumerable: true, get: function () { return basic_1.isBasicType; } });
var composite_1 = require("./type/composite");
Object.defineProperty(exports, "CompositeType", { enumerable: true, get: function () { return composite_1.CompositeType; } });
Object.defineProperty(exports, "isCompositeType", { enumerable: true, get: function () { return composite_1.isCompositeType; } });
var abstract_2 = require("./view/abstract");
Object.defineProperty(exports, "TreeView", { enumerable: true, get: function () { return abstract_2.TreeView; } });
var abstract_3 = require("./viewDU/abstract");
Object.defineProperty(exports, "TreeViewDU", { enumerable: true, get: function () { return abstract_3.TreeViewDU; } });
// Values
var bitArray_2 = require("./value/bitArray");
Object.defineProperty(exports, "BitArray", { enumerable: true, get: function () { return bitArray_2.BitArray; } });
Object.defineProperty(exports, "getUint8ByteToBitBooleanArray", { enumerable: true, get: function () { return bitArray_2.getUint8ByteToBitBooleanArray; } });
// Utils
var byteArray_2 = require("./util/byteArray");
Object.defineProperty(exports, "fromHexString", { enumerable: true, get: function () { return byteArray_2.fromHexString; } });
Object.defineProperty(exports, "toHexString", { enumerable: true, get: function () { return byteArray_2.toHexString; } });
Object.defineProperty(exports, "byteArrayEquals", { enumerable: true, get: function () { return byteArray_2.byteArrayEquals; } });
var merkleize_1 = require("./util/merkleize");
Object.defineProperty(exports, "hash64", { enumerable: true, get: function () { return merkleize_1.hash64; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\abstract.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Cabstract.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = void 0;
/**
 * An SSZ type provides the following operations:
 * - Serialization from/to bytes to either a value or a tree
 * - Merkelization to compute the hashTreeRoot of both a value and a tree
 * - Proof creation from trees
 * - Create a View and a ViewDU instance from a tree
 * - Manipulate views
 */
class Type {
    /** INTERNAL METHOD: Merkleize value to tree */
    value_toTree(value) {
        // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
    }
    /** INTERNAL METHOD: Un-merkleize tree to value */
    tree_toValue(node) {
        // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important
        const uint8Array = new Uint8Array(this.tree_serializedSize(node));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.tree_serializeToBytes({ uint8Array, dataView }, 0, node);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
    }
    /** Serialize a value to binary data */
    serialize(value) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return uint8Array;
    }
    /** Deserialize binary data to value */
    deserialize(uint8Array) {
        // Buffer.prototype.slice does not copy memory, force use Uint8Array.prototype.slice https://github.com/nodejs/node/issues/28087
        // - Uint8Array.prototype.slice: Copy memory, safe to mutate
        // - Buffer.prototype.slice: Does NOT copy memory, mutation affects both views
        // We could ensure that all Buffer instances are converted to Uint8Array before calling value_deserializeFromBytes
        // However doing that in a browser friendly way is not easy. Downstream code uses `Uint8Array.prototype.slice.call`
        // to ensure Buffer.prototype.slice is never used. Unit tests also test non-mutability.
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
    }
}
exports.Type = Type;
//# sourceMappingURL=abstract.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\abstract.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\array.js", {"./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js","./composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Carray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const composite_1 = require("./composite");
const arrayBasic_1 = require("./arrayBasic");
/* eslint-disable @typescript-eslint/member-ordering */
/**
 * Array: ordered homogeneous collection
 */
class ArrayType extends composite_1.CompositeType {
    constructor(elementType) {
        super();
        this.elementType = elementType;
    }
    defaultValue() {
        return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);
    }
    // Proofs
    getPropertyType() {
        return this.elementType;
    }
    getPropertyGindex(prop) {
        if (typeof prop !== "number") {
            throw Error(`Invalid array index: ${prop}`);
        }
        const chunkIdx = Math.floor(prop / this.itemsPerChunk);
        return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));
    }
    getIndexProperty(index) {
        return index;
    }
    tree_getLeafGindices(rootGindex, rootNode) {
        let length;
        if (this.isList) {
            if (!rootNode) {
                throw new Error("List type requires tree argument to get leaves");
            }
            length = this.tree_getLength(rootNode);
        }
        else {
            // Vectors don't need a rootNode to return length
            length = this.tree_getLength(null);
        }
        const gindices = [];
        if (composite_1.isCompositeType(this.elementType)) {
            // Underlying elements exist one per chunk
            // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk
            const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));
            const endGindex = startIndex + BigInt(length);
            const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);
            if (this.elementType.fixedSize === null) {
                if (!rootNode) {
                    /* istanbul ignore next - unreachable code */
                    throw new Error("Array of variable size requires tree argument to get leaves");
                }
                // variable-length elements must pass the underlying subtrees to determine the length
                for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {
                    gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));
                }
            }
            else {
                for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {
                    gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));
                }
            }
        }
        // Basic
        else {
            const chunkCount = Math.ceil(length / this.itemsPerChunk);
            const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
            const endGindex = startIndex + BigInt(chunkCount);
            for (let gindex = startIndex; gindex < endGindex; gindex++) {
                gindices.push(gindex);
            }
        }
        // include the length chunk
        if (this.isList) {
            gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
    }
    // JSON
    fromJson(json) {
        // TODO: Do a better typesafe approach, all final classes of ArrayType implement ArrayProps
        // There are multiple tests that cover this path for all clases
        return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);
    }
    toJson(value) {
        return arrayBasic_1.value_toJsonArray(this.elementType, value, this);
    }
    clone(value) {
        return arrayBasic_1.value_cloneArray(this.elementType, value);
    }
    equals(a, b) {
        return arrayBasic_1.value_equals(this.elementType, a, b);
    }
}
exports.ArrayType = ArrayType;
//# sourceMappingURL=array.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\array.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js", {"@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CarrayBasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
// There's a matrix of Array-ish types that require a combination of this functions.
// Regular class extends syntax doesn't work because it can only extend a single class.
//
// Type of array: List, Vector. Changes length property
// Type of element: Basic, Composite. Changes merkelization if packing or not.
// If Composite: Fixed len, Variable len. Changes the serialization requiring offsets.
/**
 * SSZ Lists (variable-length arrays) include the length of the list in the tree
 * This length is always in the same index in the tree
 * ```
 *   1
 *  / \
 * 2   3 // <-here
 * ```
 */
function getLengthFromRootNode(node) {
    // Length is represented as a Uint32 at the start of the chunk:
    // 4 = 4 bytes in Uint32
    // 0 = 0 offset bytes in Node's data
    return node.right.getUint(4, 0);
}
exports.getLengthFromRootNode = getLengthFromRootNode;
function getChunksNodeFromRootNode(node) {
    return node.left;
}
exports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;
function addLengthNode(chunksNode, length) {
    return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length));
}
exports.addLengthNode = addLengthNode;
function setChunksNode(rootNode, chunksNode, newLength) {
    const lengthNode = newLength !== undefined
        ? // If newLength is set, create a new node for length
            persistent_merkle_tree_1.LeafNode.fromUint32(newLength)
        : // else re-use existing node
            rootNode.right;
    return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);
}
exports.setChunksNode = setChunksNode;
/**
 * @param length In List length = value.length, Vector length = fixed value
 */
function value_serializeToBytesArrayBasic(elementType, length, output, offset, value) {
    const elSize = elementType.byteLength;
    for (let i = 0; i < length; i++) {
        elementType.value_serializeToBytes(output, offset + i * elSize, value[i]);
    }
    return offset + length * elSize;
}
exports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;
function value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {
    const elSize = elementType.byteLength;
    // Vector + List length validation
    const length = (end - start) / elSize;
    assertValidArrayLength(length, arrayProps, true);
    const values = new Array(length);
    for (let i = 0; i < length; i++) {
        // TODO: If faster, consider skipping size check for uint types
        values[i] = elementType.value_deserializeFromBytes(data, start + i * elSize, start + (i + 1) * elSize);
    }
    return values;
}
exports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;
/**
 * @param length In List length = value.length, Vector length = fixed value
 */
function tree_serializeToBytesArrayBasic(elementType, length, depth, output, offset, node) {
    const size = elementType.byteLength * length;
    const chunkCount = Math.ceil(size / 32);
    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);
    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);
    return offset + size;
}
exports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic;
// List of basic elements will pack them in merkelized form
function tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {
    // Vector + List length validation
    const length = (end - start) / elementType.byteLength;
    assertValidArrayLength(length, arrayProps, true);
    // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject
    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);
    if (arrayProps.isList) {
        return addLengthNode(chunksNode, length);
    }
    else {
        return chunksNode;
    }
}
exports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;
/**
 * @param length In List length = undefined, Vector length = fixed value
 */
function value_fromJsonArray(elementType, json, arrayProps) {
    if (!Array.isArray(json)) {
        throw Error("JSON is not an array");
    }
    assertValidArrayLength(json.length, arrayProps);
    const value = new Array(json.length);
    for (let i = 0; i < json.length; i++) {
        value[i] = elementType.fromJson(json[i]);
    }
    return value;
}
exports.value_fromJsonArray = value_fromJsonArray;
/**
 * @param length In List length = undefined, Vector length = fixed value
 */
function value_toJsonArray(elementType, value, arrayProps) {
    const length = arrayProps.isList ? value.length : arrayProps.length;
    const json = new Array(length);
    for (let i = 0; i < length; i++) {
        json[i] = elementType.toJson(value[i]);
    }
    return json;
}
exports.value_toJsonArray = value_toJsonArray;
/**
 * Clone recursively an array of basic or composite types
 */
function value_cloneArray(elementType, value) {
    const newValue = new Array(value.length);
    for (let i = 0; i < value.length; i++) {
        newValue[i] = elementType.clone(value[i]);
    }
    return newValue;
}
exports.value_cloneArray = value_cloneArray;
/**
 * Check recursively if a type is structuraly equal. Returns early
 */
function value_equals(elementType, a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (!elementType.equals(a[i], b[i])) {
            return false;
        }
    }
    return true;
}
exports.value_equals = value_equals;
function value_defaultValueArray(elementType, length) {
    const values = new Array(length);
    for (let i = 0; i < length; i++) {
        values[i] = elementType.defaultValue();
    }
    return values;
}
exports.value_defaultValueArray = value_defaultValueArray;
/**
 * @param checkNonDecimalLength Check that length is a multiple of element size.
 * Optional since it's not necessary in getOffsetsArrayComposite() fn.
 */
function assertValidArrayLength(length, arrayProps, checkNonDecimalLength) {
    if (checkNonDecimalLength && length % 1 !== 0) {
        throw Error("size not multiple of element fixedSize");
    }
    // Vector + List length validation
    if (arrayProps.isList) {
        if (length > arrayProps.limit) {
            throw new Error(`Invalid list length ${length} over limit ${arrayProps.limit}`);
        }
    }
    else {
        if (length !== arrayProps.length) {
            throw new Error(`Incorrect vector length ${length} expected ${arrayProps.length}`);
        }
    }
}
exports.assertValidArrayLength = assertValidArrayLength;
//# sourceMappingURL=arrayBasic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayComposite.js", {"./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CarrayComposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.value_getRootsArrayComposite = exports.tree_deserializeFromBytesArrayComposite = exports.tree_serializeToBytesArrayComposite = exports.tree_serializedSizeArrayComposite = exports.value_deserializeFromBytesArrayComposite = exports.value_serializeToBytesArrayComposite = exports.value_serializedSizeArrayComposite = exports.maxSizeArrayComposite = exports.minSizeArrayComposite = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const arrayBasic_1 = require("./arrayBasic");
function minSizeArrayComposite(elementType, minCount) {
    // Variable Length
    if (elementType.fixedSize === null) {
        return minCount * (4 + elementType.minSize);
    }
    // Fixed length
    else {
        return minCount * elementType.minSize;
    }
}
exports.minSizeArrayComposite = minSizeArrayComposite;
function maxSizeArrayComposite(elementType, maxCount) {
    // Variable Length
    if (elementType.fixedSize === null) {
        return maxCount * (4 + elementType.maxSize);
    }
    // Fixed length
    else {
        return maxCount * elementType.maxSize;
    }
}
exports.maxSizeArrayComposite = maxSizeArrayComposite;
function value_serializedSizeArrayComposite(elementType, length, value) {
    // Variable Length
    if (elementType.fixedSize === null) {
        let size = 0;
        for (let i = 0; i < length; i++) {
            size += 4 + elementType.value_serializedSize(value[i]);
        }
        return size;
    }
    // Fixed length
    else {
        return length * elementType.fixedSize;
    }
}
exports.value_serializedSizeArrayComposite = value_serializedSizeArrayComposite;
/**
 * @param length In List length = value.length, Vector length = fixed value
 */
function value_serializeToBytesArrayComposite(elementType, length, output, offset, value) {
    // Variable length
    if (elementType.fixedSize === null) {
        let variableIndex = offset + length * 4;
        for (let i = 0; i < length; i++) {
            // write offset
            output.dataView.setUint32(offset + i * 4, variableIndex - offset, true);
            // write serialized element to variable section
            variableIndex = elementType.value_serializeToBytes(output, variableIndex, value[i]);
        }
        return variableIndex;
    }
    // Fixed length
    else {
        for (let i = 0; i < length; i++) {
            elementType.value_serializeToBytes(output, offset + i * elementType.fixedSize, value[i]);
        }
        return offset + length * elementType.fixedSize;
    }
}
exports.value_serializeToBytesArrayComposite = value_serializeToBytesArrayComposite;
function value_deserializeFromBytesArrayComposite(elementType, data, start, end, arrayProps) {
    const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);
    const length = offsets.length; // Capture length before pushing end offset
    const values = new Array(length);
    // offests include the last element end
    for (let i = 0; i < length; i++) {
        // The offsets are relative to the start
        const startEl = start + offsets[i];
        const endEl = i === length - 1 ? end : start + offsets[i + 1];
        values[i] = elementType.value_deserializeFromBytes(data, startEl, endEl);
    }
    return values;
}
exports.value_deserializeFromBytesArrayComposite = value_deserializeFromBytesArrayComposite;
/**
 * @param length In List length = value.length, Vector length = fixed value
 */
function tree_serializedSizeArrayComposite(elementType, length, depth, node) {
    // Variable Length
    if (elementType.fixedSize === null) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);
        let size = 0;
        for (let i = 0; i < nodes.length; i++) {
            size += 4 + elementType.tree_serializedSize(nodes[i]);
        }
        return size;
    }
    // Fixed length
    else {
        return length * elementType.fixedSize;
    }
}
exports.tree_serializedSizeArrayComposite = tree_serializedSizeArrayComposite;
/**
 * @param length In List length = value.length, Vector length = fixed value
 */
function tree_serializeToBytesArrayComposite(elementType, length, depth, node, output, offset) {
    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);
    // Variable Length
    // Indices contain offsets, which are indices deeper in the byte array
    if (elementType.fixedSize === null) {
        let variableIndex = offset + length * 4;
        const { dataView } = output;
        for (let i = 0; i < nodes.length; i++) {
            // write offset
            dataView.setUint32(offset + i * 4, variableIndex - offset, true);
            // write serialized element to variable section
            variableIndex = elementType.tree_serializeToBytes(output, variableIndex, nodes[i]);
        }
        return variableIndex;
    }
    // Fixed length
    else {
        for (let i = 0; i < nodes.length; i++) {
            offset = elementType.tree_serializeToBytes(output, offset, nodes[i]);
        }
        return offset;
    }
}
exports.tree_serializeToBytesArrayComposite = tree_serializeToBytesArrayComposite;
function tree_deserializeFromBytesArrayComposite(elementType, chunkDepth, data, start, end, arrayProps) {
    const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);
    const length = offsets.length; // Capture length before pushing end offset
    const nodes = new Array(length);
    // offests include the last element end
    for (let i = 0; i < length; i++) {
        // The offsets are relative to the start
        const startEl = start + offsets[i];
        const endEl = i === length - 1 ? end : start + offsets[i + 1];
        nodes[i] = elementType.tree_deserializeFromBytes(data, startEl, endEl);
    }
    // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject
    const chunksNode = persistent_merkle_tree_1.subtreeFillToContents(nodes, chunkDepth);
    // TODO: Add LeafNode.fromUint()
    if (arrayProps.isList) {
        return arrayBasic_1.addLengthNode(chunksNode, length);
    }
    else {
        return chunksNode;
    }
}
exports.tree_deserializeFromBytesArrayComposite = tree_deserializeFromBytesArrayComposite;
/**
 * @param length In List length = value.length, Vector length = fixed value
 */
function value_getRootsArrayComposite(elementType, length, value) {
    const roots = new Array(length);
    for (let i = 0; i < length; i++) {
        roots[i] = elementType.hashTreeRoot(value[i]);
    }
    return roots;
}
exports.value_getRootsArrayComposite = value_getRootsArrayComposite;
function readOffsetsArrayComposite(elementFixedSize, data, start, end, arrayProps) {
    const size = end - start;
    let offsets;
    // Variable Length
    // Indices contain offsets, which are indices deeper in the byte array
    if (elementFixedSize === null) {
        offsets = readVariableOffsetsArrayComposite(data, start, size);
    }
    // Fixed length
    else {
        // There's no valid CompositeType with fixed size 0, it's un-rechable code. But prevents diving by zero
        /* istanbul ignore if */
        if (elementFixedSize === 0) {
            throw Error("element fixed length is 0");
        }
        if (size % elementFixedSize !== 0) {
            throw Error(`size ${size} is not multiple of element fixedSize ${elementFixedSize}`);
        }
        const length = size / elementFixedSize;
        offsets = new Uint32Array(length);
        for (let i = 0; i < length; i++) {
            offsets[i] = i * elementFixedSize;
        }
    }
    // Vector + List length validation
    arrayBasic_1.assertValidArrayLength(offsets.length, arrayProps);
    return offsets;
}
/**
 * Reads the values of contiguous variable offsets. Provided buffer includes offsets that point to position
 * within `size`. This function also validates that all offsets are in range.
 */
function readVariableOffsetsArrayComposite(dataView, start, size) {
    if (size === 0) {
        return new Uint32Array(0);
    }
    // all elements are variable-sized
    // indices contain offsets, which are indices deeper in the byte array
    // The serialized data will start with offsets of all the serialized objects (BYTES_PER_LENGTH_OFFSET bytes each)
    const firstOffset = dataView.getUint32(start, true);
    // Using the first offset, we can compute the length of the list (divide by BYTES_PER_LENGTH_OFFSET), as it gives
    // us the total number of bytes in the offset data
    const offsetDataLength = firstOffset;
    if (firstOffset === 0) {
        throw Error("First offset must be > 0");
    }
    if (offsetDataLength % 4 !== 0) {
        throw Error("Offset data length not multiple of 4");
    }
    const offsetCount = offsetDataLength / 4;
    const offsets = new Uint32Array(offsetCount);
    offsets[0] = firstOffset;
    // ArrayComposite has a contiguous section of offsets, then the data
    //
    //    [offset 1] [offset 2] [data 1 ..........] [data 2 ..]
    // 0x 08000000   0e000000   010002000300        01000200
    //
    // Ensure that:
    // - Offsets point to regions of > 0 bytes, i.e. are increasing
    // - Offsets don't point to bytes outside of the array's size
    //
    // In the example above the first offset is 8, so 8 / 4 = 2 offsets.
    // Then, read the rest of offsets to get offsets = [8, 14]
    for (let offsetIdx = 1; offsetIdx < offsetCount; offsetIdx++) {
        const offset = dataView.getUint32(start + offsetIdx * 4, true);
        offsets[offsetIdx] = offset;
        // Offsets must point to data within the Array bytes section
        if (offset > size) {
            throw new Error(`Offset out of bounds ${offset} > ${size}`);
        }
        if (offset < offsets[offsetIdx - 1]) {
            throw new Error(`Offsets must be increasing ${offset} < ${offsets[offsetIdx - 1]}`);
        }
    }
    return offsets;
}
//# sourceMappingURL=arrayComposite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayComposite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js", {"./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\abstract.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Cbasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBasicType = exports.BasicType = void 0;
const abstract_1 = require("./abstract");
/* eslint-disable @typescript-eslint/member-ordering */
/**
 * Represents a basic type as defined in the spec:
 * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#basic-types
 */
class BasicType extends abstract_1.Type {
    constructor() {
        super(...arguments);
        this.isBasic = true;
        // Basic types merkleize to exactly one chunk, thus depth of 0
        this.depth = 0;
        // Basic types merkleize to exactly one chunk
        this.maxChunkCount = 1;
    }
    value_serializedSize() {
        return this.byteLength;
    }
    tree_serializedSize() {
        return this.byteLength;
    }
    assertValidSize(size) {
        if (size !== this.byteLength) {
            throw Error(`BasicType invalid size ${size} expected ${this.byteLength}`);
        }
    }
    hashTreeRoot(value) {
        // TODO: Optimize
        const uint8Array = new Uint8Array(32);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return uint8Array;
    }
    clone(value) {
        // All basic types are represented by primitive Javascript types, don't require clone
        return value;
    }
    equals(a, b) {
        // All basic types are represented by primitive Javascript types, the operator === is sufficient
        return a === b;
    }
}
exports.BasicType = BasicType;
function isBasicType(type) {
    return type.isBasic;
}
exports.isBasicType = isBasicType;
//# sourceMappingURL=basic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitArray.js", {"../util/byteArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\byteArray.js","../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../view/bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\bitArray.js","../viewDU/bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\bitArray.js","./composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CbitArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitArrayType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const byteArray_1 = require("../util/byteArray");
const merkleize_1 = require("../util/merkleize");
const composite_1 = require("./composite");
const bitArray_1 = require("../view/bitArray");
const bitArray_2 = require("../viewDU/bitArray");
/* eslint-disable @typescript-eslint/member-ordering */
/**
 * BitArray: ordered array collection of boolean values
 * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance
 * - View: `BitArrayTreeView`
 * - ViewDU: `BitArrayTreeViewDU`
 */
class BitArrayType extends composite_1.CompositeType {
    constructor() {
        super(...arguments);
        this.isViewMutable = true;
    }
    getView(tree) {
        return new bitArray_1.BitArrayTreeView(this, tree);
    }
    getViewDU(node) {
        return new bitArray_2.BitArrayTreeViewDU(this, node);
    }
    commitView(view) {
        return view.node;
    }
    commitViewDU(view) {
        view.commit();
        return view.node;
    }
    cacheOfViewDU(view) {
        return view.cache;
    }
    // Merkleization
    getRoots(value) {
        return merkleize_1.splitIntoRootChunks(value.uint8Array);
    }
    // Proofs
    getPropertyGindex() {
        // Stop navigating below this type. Must only request complete data
        return null;
    }
    getPropertyType() {
        /* istanbul ignore next - unreachable code, getPropertyGindex null return prevents this call */
        throw Error("Must only request BitArray complete data");
    }
    getIndexProperty() {
        /* istanbul ignore next - unreachable code, getPropertyGindex null return prevents this call */
        throw Error("Must only request BitArray complete data");
    }
    tree_fromProofNode(node) {
        return { node, done: true };
    }
    tree_getLeafGindices(rootGindex, rootNode) {
        const byteLen = this.tree_getByteLen(rootNode);
        const chunkCount = Math.ceil(byteLen / 32);
        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
        const gindices = new Array(chunkCount);
        for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {
            gindices[i] = gindex;
        }
        // include the length chunk
        if (this.isList) {
            gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
    }
    // JSON
    fromJson(json) {
        const uint8Array = byteArray_1.fromHexString(json);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        // value_deserializeFromBytes MUST validate length (limit, or length)
        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
    }
    toJson(value) {
        return byteArray_1.toHexString(this.serialize(value));
    }
    clone(value) {
        return value.clone();
    }
    equals(a, b) {
        return a.bitLen === b.bitLen && byteArray_1.byteArrayEquals(a.uint8Array, b.uint8Array);
    }
}
exports.BitArrayType = BitArrayType;
//# sourceMappingURL=bitArray.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitArray.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitList.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../value/bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\value\\bitArray.js","./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js","./bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitArray.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CbitList.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitListType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const arrayBasic_1 = require("./arrayBasic");
const bitArray_1 = require("../value/bitArray");
const bitArray_2 = require("./bitArray");
/**
 * BitList: ordered variable-length collection of boolean values, limited to N bits
 * - Notation `Bitlist[N]`
 * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance
 * - View: `BitArrayTreeView`
 * - ViewDU: `BitArrayTreeViewDU`
 */
class BitListType extends bitArray_2.BitArrayType {
    constructor(limitBits, opts) {
        super();
        this.limitBits = limitBits;
        this.fixedSize = null;
        this.minSize = 1; // +1 for the extra padding bit
        this.isList = true;
        if (limitBits === 0)
            throw Error("List limit must be > 0");
        this.typeName = opts?.typeName ?? `BitList[${limitBits}]`;
        // TODO Check that itemsPerChunk is an integer
        this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        // Depth includes the extra level for the length node
        this.depth = 1 + this.chunkDepth;
        this.maxSize = Math.ceil(limitBits / 8) + 1; // +1 for the extra padding bit
    }
    static named(limitBits, opts) {
        return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);
    }
    defaultValue() {
        return bitArray_1.BitArray.fromBitLen(0);
    }
    // Views: inherited from BitArrayType
    // Serialization + deserialization
    value_serializedSize(value) {
        return bitLenToSerializedLength(value.bitLen);
    }
    value_serializeToBytes(output, offset, value) {
        output.uint8Array.set(value.uint8Array, offset);
        return applyPaddingBit(output.uint8Array, offset, value.bitLen);
    }
    value_deserializeFromBytes(data, start, end) {
        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);
        return new bitArray_1.BitArray(uint8Array, bitLen);
    }
    tree_serializedSize(node) {
        return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));
    }
    tree_serializeToBytes(output, offset, node) {
        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);
        const bitLen = arrayBasic_1.getLengthFromRootNode(node);
        const byteLen = Math.ceil(bitLen / 8);
        const chunkLen = Math.ceil(byteLen / 32);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);
        return applyPaddingBit(output.uint8Array, offset, bitLen);
    }
    tree_deserializeFromBytes(data, start, end) {
        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);
        return arrayBasic_1.addLengthNode(chunksNode, bitLen);
    }
    tree_getByteLen(node) {
        if (!node)
            throw new Error("BitListType requires a node to get leaves");
        return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);
    }
    // Merkleization: inherited from BitArrayType
    hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);
    }
    // Proofs: inherited from BitArrayType
    // JSON: inherited from BitArrayType
    // Deserializer helpers
    deserializeUint8ArrayBitListFromBytes(data, start, end) {
        const { uint8Array, bitLen } = deserializeUint8ArrayBitListFromBytes(data, start, end);
        if (bitLen > this.limitBits) {
            throw Error(`bitLen over limit ${bitLen} > ${this.limitBits}`);
        }
        return { uint8Array, bitLen };
    }
}
exports.BitListType = BitListType;
function deserializeUint8ArrayBitListFromBytes(data, start, end) {
    if (end > data.length) {
        throw Error(`BitList attempting to read byte ${end} of data length ${data.length}`);
    }
    const lastByte = data[end - 1];
    const size = end - start;
    if (lastByte === 0) {
        throw new Error("Invalid deserialized bitlist, padding bit required");
    }
    if (lastByte === 1) {
        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087
        const uint8Array = Uint8Array.prototype.slice.call(data, start, end - 1);
        const bitLen = (size - 1) * 8;
        return { uint8Array, bitLen };
    }
    // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed
    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087
    const uint8Array = Uint8Array.prototype.slice.call(data, start, end);
    // mask lastChunkByte
    const lastByteBitLength = lastByte.toString(2).length - 1;
    const bitLen = (size - 1) * 8 + lastByteBitLength;
    const mask = 0xff >> (8 - lastByteBitLength);
    uint8Array[size - 1] &= mask;
    return { uint8Array, bitLen };
}
function bitLenToSerializedLength(bitLen) {
    const bytes = Math.ceil(bitLen / 8);
    // +1 for the extra padding bit
    return bitLen % 8 === 0 ? bytes + 1 : bytes;
}
/**
 * Apply padding bit to a serialized BitList already written to `output` at `offset`
 * @returns New offset after (maybe) writting a padding bit.
 */
function applyPaddingBit(output, offset, bitLen) {
    const byteLen = Math.ceil(bitLen / 8);
    const newOffset = offset + byteLen;
    if (bitLen % 8 === 0) {
        output[newOffset] = 1;
        return newOffset + 1;
    }
    else {
        output[newOffset - 1] |= 1 << bitLen % 8;
        return newOffset;
    }
}
//# sourceMappingURL=bitList.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitList.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitVector.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../value/bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\value\\bitArray.js","./bitArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitArray.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CbitVector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitVectorType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const bitArray_1 = require("../value/bitArray");
const bitArray_2 = require("./bitArray");
/**
 * BitVector: ordered fixed-length collection of boolean values, with N bits
 * - Notation: `Bitvector[N]`
 * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance
 * - View: `BitArrayTreeView`
 * - ViewDU: `BitArrayTreeViewDU`
 */
class BitVectorType extends bitArray_2.BitArrayType {
    constructor(lengthBits, opts) {
        super();
        this.lengthBits = lengthBits;
        this.isList = false;
        if (lengthBits === 0)
            throw Error("Vector length must be > 0");
        this.typeName = opts?.typeName ?? `BitVector[${lengthBits}]`;
        this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);
        this.maxChunkCount = this.chunkCount;
        this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);
        this.fixedSize = Math.ceil(this.lengthBits / 8);
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
        // To cache mask for trailing zero bits validation
        this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 0xff & (0xff << lengthBits % 8);
    }
    static named(limitBits, opts) {
        return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);
    }
    defaultValue() {
        return bitArray_1.BitArray.fromBitLen(this.lengthBits);
    }
    // Views: inherited from BitArrayType
    // Serialization + deserialization
    value_serializedSize() {
        return this.fixedSize;
    }
    value_serializeToBytes(output, offset, value) {
        output.uint8Array.set(value.uint8Array, offset);
        return offset + this.fixedSize;
    }
    value_deserializeFromBytes(data, start, end) {
        this.assertValidLength(data.uint8Array, start, end);
        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087
        return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);
    }
    tree_serializedSize() {
        return this.fixedSize;
    }
    tree_serializeToBytes(output, offset, node) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);
        return offset + this.fixedSize;
    }
    tree_deserializeFromBytes(data, start, end) {
        this.assertValidLength(data.uint8Array, start, end);
        return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);
    }
    tree_getByteLen() {
        return this.fixedSize;
    }
    // Merkleization: inherited from BitArrayType
    // Proofs: inherited from BitArrayType
    // JSON: inherited from BitArrayType
    // Deserializer helpers
    assertValidLength(data, start, end) {
        const size = end - start;
        if (end - start !== this.fixedSize) {
            throw Error(`Invalid BitVector size ${size} != ${this.fixedSize}`);
        }
        // If lengthBits is not aligned to bytes, ensure trailing bits are zeroed
        if (
        // If zeroBitsMask == 0, then the BitVector uses full bytes only
        this.zeroBitsMask > 0 &&
            // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed
            (data[end - 1] & this.zeroBitsMask) > 0) {
            throw Error("BitVector: nonzero bits past length");
        }
    }
}
exports.BitVectorType = BitVectorType;
//# sourceMappingURL=bitVector.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\bitVector.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\boolean.js", {"../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","./basic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Cboolean.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BooleanType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const named_1 = require("../util/named");
const basic_1 = require("./basic");
/**
 * Boolean: True or False
 * - Notation: `boolean`
 */
class BooleanType extends basic_1.BasicType {
    constructor(opts) {
        super();
        this.byteLength = 1;
        this.itemsPerChunk = 32;
        this.fixedSize = 1;
        this.minSize = 1;
        this.maxSize = 1;
        this.typeName = opts?.typeName ?? "boolean";
    }
    static named(opts) {
        return new (named_1.namedClass(BooleanType, opts.typeName))(opts);
    }
    defaultValue() {
        return false;
    }
    // Serialization + deserialization
    value_serializeToBytes(output, offset, value) {
        output.uint8Array[offset] = value ? 1 : 0;
        return offset + 1;
    }
    value_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        switch (data.uint8Array[start]) {
            case 1:
                return true;
            case 0:
                return false;
            default:
                throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);
        }
    }
    tree_serializeToBytes(output, offset, node) {
        // TODO: Assumes LeafNode has 4 byte uints are primary unit
        output.uint8Array[offset] = node.getUint(4, 0);
        return offset + 1;
    }
    tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const value = data.uint8Array[start];
        if (value > 1) {
            throw Error(`Boolean: invalid value ${value}`);
        }
        return persistent_merkle_tree_1.LeafNode.fromUint32(value);
    }
    // Fast tree opts
    tree_getFromNode(leafNode) {
        return leafNode.getUint(4, 0) === 1;
    }
    tree_setToNode(leafNode, value) {
        leafNode.setUint(4, 0, value ? 1 : 0);
    }
    tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = index % this.itemsPerChunk;
        return leafNode.getUint(1, offsetBytes) !== 0;
    }
    tree_setToPackedNode(leafNode, index, value) {
        const offsetBytes = index % this.itemsPerChunk;
        leafNode.setUint(1, offsetBytes, value ? 1 : 0);
    }
    // JSON
    fromJson(json) {
        if (typeof json !== "boolean") {
            throw Error(`JSON invalid type ${typeof json} expected boolean`);
        }
        return json;
    }
    toJson(value) {
        return value;
    }
}
exports.BooleanType = BooleanType;
//# sourceMappingURL=boolean.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\boolean.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteArray.js", {"../util/byteArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\byteArray.js","../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","./composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CbyteArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByteArrayType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const byteArray_1 = require("../util/byteArray");
const merkleize_1 = require("../util/merkleize");
const composite_1 = require("./composite");
/* eslint-disable @typescript-eslint/member-ordering */
/**
 * ByteArray: ordered array collection of byte values
 * - Value: `Uint8Array`
 * - View: `Uint8Array`
 * - ViewDU: `Uint8Array`
 *
 * ByteArray is an immutable value which is represented by a Uint8Array for memory efficiency and performance.
 * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteArray.
 */
class ByteArrayType extends composite_1.CompositeType {
    constructor() {
        super(...arguments);
        this.isViewMutable = false;
    }
    defaultValue() {
        // Since it's a byte array the minSize is bytes is the default size
        return new Uint8Array(this.minSize);
    }
    getView(tree) {
        return this.getViewDU(tree.rootNode);
    }
    getViewDU(node) {
        return this.tree_toValue(node);
    }
    commitView(view) {
        return this.commitViewDU(view);
    }
    commitViewDU(view) {
        const uint8Array = new Uint8Array(this.value_serializedSize(view));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, view);
        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
    }
    cacheOfViewDU() {
        return;
    }
    // Over-write to prevent serialize + deserialize
    toView(value) {
        return value;
    }
    toViewDU(value) {
        return value;
    }
    // Serialization + deserialization (only value is generic)
    value_serializeToBytes(output, offset, value) {
        output.uint8Array.set(value, offset);
        return offset + value.length;
    }
    value_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        return Uint8Array.prototype.slice.call(data.uint8Array, start, end);
    }
    // Merkleization
    getRoots(value) {
        return merkleize_1.splitIntoRootChunks(value);
    }
    // Proofs
    getPropertyGindex() {
        // Stop navigating below this type. Must only request complete data
        return null;
    }
    getPropertyType() {
        throw Error("Must only request ByteArray complete data");
    }
    getIndexProperty() {
        throw Error("Must only request ByteArray complete data");
    }
    tree_fromProofNode(node) {
        return { node, done: true };
    }
    tree_getLeafGindices(rootGindex, rootNode) {
        const byteLen = this.tree_getByteLen(rootNode);
        const chunkCount = Math.ceil(byteLen / 32);
        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);
        const gindices = new Array(chunkCount);
        for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {
            gindices[i] = gindex;
        }
        // include the length chunk
        if (this.isList) {
            gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));
        }
        return gindices;
    }
    // JSON
    fromJson(json) {
        const value = byteArray_1.fromHexString(json);
        this.assertValidSize(value.length);
        return value;
    }
    toJson(value) {
        return byteArray_1.toHexString(value);
    }
    // ByteArray is immutable
    clone(value) {
        return value;
    }
    equals(a, b) {
        return byteArray_1.byteArrayEquals(a, b);
    }
}
exports.ByteArrayType = ByteArrayType;
//# sourceMappingURL=byteArray.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteArray.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteList.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js","./byteArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteArray.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CbyteList.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByteListType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const arrayBasic_1 = require("./arrayBasic");
const byteArray_1 = require("./byteArray");
/**
 * ByteList: Immutable alias of List[byte, N]
 * - Notation: `ByteList[N]`
 * - Value: `Uint8Array`
 * - View: `Uint8Array`
 * - ViewDU: `Uint8Array`
 *
 * ByteList is an immutable value which is represented by a Uint8Array for memory efficiency and performance.
 * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteList.
 *
 * For a `ByteListType` with mutability, use `ListBasicType(byteType)`
 */
class ByteListType extends byteArray_1.ByteArrayType {
    constructor(limitBytes, opts) {
        super();
        this.limitBytes = limitBytes;
        this.fixedSize = null;
        this.isList = true;
        if (limitBytes === 0)
            throw Error("List limit must be > 0");
        this.typeName = opts?.typeName ?? `ByteList[${limitBytes}]`;
        this.maxChunkCount = Math.ceil(this.limitBytes / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = 1 + this.chunkDepth;
        this.minSize = 0;
        this.maxSize = this.limitBytes;
    }
    static named(limitBits, opts) {
        return new (named_1.namedClass(ByteListType, opts.typeName))(limitBits, opts);
    }
    // Views: inherited from ByteArrayType
    // Serialization + deserialization
    value_serializedSize(value) {
        return value.length;
    }
    // value_* inherited from ByteArrayType
    tree_serializedSize(node) {
        return arrayBasic_1.getLengthFromRootNode(node);
    }
    tree_serializeToBytes(output, offset, node) {
        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);
        const byteLen = arrayBasic_1.getLengthFromRootNode(node);
        const chunkLen = Math.ceil(byteLen / 32);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);
        return offset + byteLen;
    }
    tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);
        return arrayBasic_1.addLengthNode(chunksNode, end - start);
    }
    tree_getByteLen(node) {
        if (!node)
            throw new Error("ByteListType requires a node to get leaves");
        return arrayBasic_1.getLengthFromRootNode(node);
    }
    // Merkleization: inherited from ByteArrayType
    hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);
    }
    // Proofs: inherited from BitArrayType
    // JSON: inherited from ByteArrayType
    assertValidSize(size) {
        if (size > this.limitBytes) {
            throw Error(`ByteList invalid size ${size} limit ${this.limitBytes}`);
        }
    }
}
exports.ByteListType = ByteListType;
//# sourceMappingURL=byteList.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteList.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteVector.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","./byteArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteArray.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CbyteVector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByteVectorType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const byteArray_1 = require("./byteArray");
/* eslint-disable @typescript-eslint/member-ordering */
/**
 * ByteVector: Immutable alias of Vector[byte, N]
 * - Notation: `ByteVector[N]`
 * - Value: `Uint8Array`
 * - View: `Uint8Array`
 * - ViewDU: `Uint8Array`
 *
 * ByteVector is an immutable value which is represented by a Uint8Array for memory efficiency and performance.
 * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteVector.
 *
 * For a `ByteVectorType` with mutability, use `VectorBasicType(byteType)`
 */
class ByteVectorType extends byteArray_1.ByteArrayType {
    constructor(lengthBytes, opts) {
        super();
        this.lengthBytes = lengthBytes;
        this.isList = false;
        if (lengthBytes === 0)
            throw Error("Vector length must be > 0");
        this.typeName = opts?.typeName ?? `ByteVector[${lengthBytes}]`;
        this.maxChunkCount = Math.ceil(this.lengthBytes / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = this.lengthBytes;
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
    }
    static named(limitBits, opts) {
        return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);
    }
    // Views: inherited from ByteArrayType
    // Serialization + deserialization
    value_serializedSize() {
        return this.fixedSize;
    }
    // value_* inherited from ByteArrayType
    tree_serializedSize() {
        return this.fixedSize;
    }
    tree_serializeToBytes(output, offset, node) {
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);
        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);
        return offset + this.fixedSize;
    }
    tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);
    }
    tree_getByteLen() {
        return this.lengthBytes;
    }
    // Merkleization: inherited from ByteArrayType
    // Proofs: inherited from BitArrayType
    // JSON: inherited from ByteArrayType
    assertValidSize(size) {
        if (size !== this.lengthBytes) {
            throw Error(`ByteVector invalid size ${size} expected ${this.lengthBytes}`);
        }
    }
}
exports.ByteVectorType = ByteVectorType;
//# sourceMappingURL=byteVector.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\byteVector.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js", {"../util/byteArray":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\byteArray.js","../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/proof/treePostProcessFromProofNode":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\proof\\treePostProcessFromProofNode.js","./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\abstract.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Ccomposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const byteArray_1 = require("../util/byteArray");
const merkleize_1 = require("../util/merkleize");
const treePostProcessFromProofNode_1 = require("../util/proof/treePostProcessFromProofNode");
const abstract_1 = require("./abstract");
exports.LENGTH_GINDEX = BigInt(3);
/** Dedicated property to cache hashTreeRoot of immutable CompositeType values */
const symbolCachedPermanentRoot = Symbol("ssz_cached_permanent_root");
/* eslint-disable @typescript-eslint/member-ordering  */
/**
 * Represents a composite type as defined in the spec:
 * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#composite-types
 */
class CompositeType extends abstract_1.Type {
    constructor(
    /**
     * Caches `hashTreeRoot()` result for struct values.
     *
     * WARNING: Must only be used for immutable values. The cached root is never discarded
     */
    cachePermanentRootStruct) {
        super();
        this.cachePermanentRootStruct = cachePermanentRootStruct;
        this.isBasic = false;
    }
    /** New instance of a recursive zero'ed value converted to Tree View */
    defaultView() {
        return this.toView(this.defaultValue());
    }
    /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */
    defaultViewDU() {
        return this.toViewDU(this.defaultValue());
    }
    /**
     * Deserialize binary data to a Tree View.
     * @see {@link CompositeType.getView}
     */
    deserializeToView(data) {
        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
    }
    /**
     * Deserialize binary data to a Deferred Update Tree View.
     * @see {@link CompositeType.getViewDU}
     */
    deserializeToViewDU(data) {
        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);
        return this.getViewDU(node);
    }
    /**
     * Transform value to a View.
     * @see {@link CompositeType.getView}
     */
    toView(value) {
        const node = this.value_toTree(value);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
    }
    /**
     * Transform value to a ViewDU.
     * @see {@link CompositeType.getViewDU}
     */
    toViewDU(value) {
        const node = this.value_toTree(value);
        return this.getViewDU(node);
    }
    /**
     * Transform value to a View.
     * @see {@link CompositeType.getView}
     */
    toValueFromView(view) {
        const node = this.commitView(view);
        return this.tree_toValue(node);
    }
    /**
     * Transform value to a ViewDU.
     * @see {@link CompositeType.getViewDU}
     */
    toValueFromViewDU(view) {
        const node = this.commitViewDU(view);
        return this.tree_toValue(node);
    }
    /**
     * Transform a ViewDU to a View.
     * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}
     */
    toViewFromViewDU(view) {
        const node = this.commitViewDU(view);
        return this.getView(new persistent_merkle_tree_1.Tree(node));
    }
    /**
     * Transform a View to a ViewDU.
     * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}
     */
    toViewDUFromView(view) {
        const node = this.commitView(view);
        return this.getViewDU(node);
    }
    // Merkleize API
    hashTreeRoot(value) {
        // Return cached mutable root if any
        if (this.cachePermanentRootStruct) {
            const cachedRoot = value[symbolCachedPermanentRoot];
            if (cachedRoot) {
                return cachedRoot;
            }
        }
        const root = merkleize_1.merkleize(this.getRoots(value), this.maxChunkCount);
        if (this.cachePermanentRootStruct) {
            value[symbolCachedPermanentRoot] = root;
        }
        return root;
    }
    // For debugging and testing this feature
    getCachedPermanentRoot(value) {
        return value[symbolCachedPermanentRoot];
    }
    // Proofs API
    /**
     * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.
     * @see {@link CompositeType.getView}
     */
    createFromProof(proof, root) {
        const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;
        const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);
        if (root !== undefined && !byteArray_1.byteArrayEquals(rootNode.root, root)) {
            throw new Error("Proof does not match trusted root");
        }
        return this.getView(new persistent_merkle_tree_1.Tree(rootNode));
    }
    /** INTERNAL METHOD: For view's API, create proof from a tree */
    tree_createProof(node, jsonPaths) {
        const gindexes = this.tree_createProofGindexes(node, jsonPaths);
        return persistent_merkle_tree_1.createProof(node, {
            type: persistent_merkle_tree_1.ProofType.treeOffset,
            gindices: gindexes,
        });
    }
    /** INTERNAL METHOD: For view's API, create proof from a tree */
    tree_createProofGindexes(node, jsonPaths) {
        const gindexes = [];
        for (const jsonPath of jsonPaths) {
            const { type, gindex } = this.getPathInfo(jsonPath);
            if (!isCompositeType(type)) {
                gindexes.push(gindex);
            }
            else {
                // if the path subtype is composite, include the gindices of all the leaves
                const leafGindexes = type.tree_getLeafGindices(gindex, type.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : undefined);
                for (const gindex of leafGindexes) {
                    gindexes.push(gindex);
                }
            }
        }
        return gindexes;
    }
    /**
     * Navigate to a subtype & gindex using a path
     */
    getPathInfo(path) {
        const gindices = [];
        let type = this;
        for (const prop of path) {
            if (type.isBasic) {
                throw new Error("Invalid path: cannot navigate beyond a basic type");
            }
            const gindex = type.getPropertyGindex(prop);
            // else stop navigating
            if (gindex !== null) {
                gindices.push(gindex);
                type = type.getPropertyType(prop);
            }
        }
        return {
            type,
            gindex: persistent_merkle_tree_1.concatGindices(gindices),
        };
    }
    /**
     * INTERNAL METHOD: post process `Ǹode` instance created from a proof and return either the same node,
     * and a new node representing the same data is a different `Node` instance. Currently used exclusively
     * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.
     */
    tree_fromProofNode(node) {
        return { node, done: false };
    }
}
exports.CompositeType = CompositeType;
function isCompositeType(type) {
    return !type.isBasic;
}
exports.isCompositeType = isCompositeType;
//# sourceMappingURL=composite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\container.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../view/container":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\container.js","../viewDU/container":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\container.js","./composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js","case":"F:\\metamask-extension\\node_modules\\case\\dist\\Case.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Ccontainer.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const case_1 = __importDefault(require("case"));
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const composite_1 = require("./composite");
const container_1 = require("../view/container");
const container_2 = require("../viewDU/container");
/**
 * Container: ordered heterogeneous collection of values
 * - Notation: Custom name per instance
 */
class ContainerType extends composite_1.CompositeType {
    constructor(fields, opts) {
        super(opts?.cachePermanentRootStruct);
        this.fields = fields;
        this.opts = opts;
        this.isList = false;
        this.isViewMutable = true;
        // Render detailed typeName. Consumers should overwrite since it can get long
        this.typeName = opts?.typeName ?? renderContainerTypeName(fields);
        this.maxChunkCount = Object.keys(fields).length;
        this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        // Precalculated data for faster serdes
        this.fieldsEntries = [];
        for (const fieldName of Object.keys(fields)) {
            this.fieldsEntries.push({
                fieldName,
                fieldType: this.fields[fieldName],
                jsonKey: precomputeJsonKey(fieldName, opts?.casingMap, opts?.jsonCase),
                gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length)),
            });
        }
        if (this.fieldsEntries.length === 0) {
            throw Error("Container must have > 0 fields");
        }
        // Precalculate for Proofs API
        this.fieldsGindex = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));
        }
        // To resolve JSON paths in fieldName notation and jsonKey notation
        this.jsonKeyToFieldName = {};
        for (const { fieldName, jsonKey } of this.fieldsEntries) {
            this.jsonKeyToFieldName[jsonKey] = fieldName;
        }
        const { minLen, maxLen, fixedSize } = precomputeSizes(fields);
        this.minSize = minLen;
        this.maxSize = maxLen;
        this.fixedSize = fixedSize;
        const { isFixedLen, fieldRangesFixedLen, variableOffsetsPosition, fixedEnd } = precomputeSerdesData(fields);
        this.isFixedLen = isFixedLen;
        this.fieldRangesFixedLen = fieldRangesFixedLen;
        this.variableOffsetsPosition = variableOffsetsPosition;
        this.fixedEnd = fixedEnd;
        // TODO: This options are necessary for ContainerNodeStruct to override this.
        // Refactor this constructor to allow customization without pollutin the options
        this.TreeView = opts?.getContainerTreeViewClass?.(this) ?? container_1.getContainerTreeViewClass(this);
        this.TreeViewDU = opts?.getContainerTreeViewDUClass?.(this) ?? container_2.getContainerTreeViewDUClass(this);
    }
    static named(fields, opts) {
        return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);
    }
    defaultValue() {
        const value = {};
        for (const { fieldName, fieldType } of this.fieldsEntries) {
            value[fieldName] = fieldType.defaultValue();
        }
        return value;
    }
    getView(tree) {
        return new this.TreeView(this, tree);
    }
    getViewDU(node, cache) {
        return new this.TreeViewDU(this, node, cache);
    }
    cacheOfViewDU(view) {
        return view.cache;
    }
    commitView(view) {
        return view.node;
    }
    commitViewDU(view) {
        view.commit();
        return view.node;
    }
    // Serialization + deserialization
    // -------------------------------
    // Containers can mix fixed length and variable length data.
    //
    // Fixed part                         Variable part
    // [field1 offset][field2 data       ][field1 data               ]
    // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]
    value_serializedSize(value) {
        let totalSize = 0;
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType } = this.fieldsEntries[i];
            // Offset (4 bytes) + size
            totalSize +=
                fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;
        }
        return totalSize;
    }
    value_serializeToBytes(output, offset, value) {
        let fixedIndex = offset;
        let variableIndex = offset + this.fixedEnd;
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType } = this.fieldsEntries[i];
            if (fieldType.fixedSize === null) {
                // write offset
                output.dataView.setUint32(fixedIndex, variableIndex - offset, true);
                fixedIndex += 4;
                // write serialized element to variable section
                variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);
            }
            else {
                fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);
            }
        }
        return variableIndex;
    }
    value_deserializeFromBytes(data, start, end) {
        const fieldRanges = this.getFieldRanges(data.dataView, start, end);
        const value = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType } = this.fieldsEntries[i];
            const fieldRange = fieldRanges[i];
            value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);
        }
        return value;
    }
    tree_serializedSize(node) {
        let totalSize = 0;
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldType } = this.fieldsEntries[i];
            const node = nodes[i];
            // Offset (4 bytes) + size
            totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node) : fieldType.fixedSize;
        }
        return totalSize;
    }
    tree_serializeToBytes(output, offset, node) {
        let fixedIndex = offset;
        let variableIndex = offset + this.fixedEnd;
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldType } = this.fieldsEntries[i];
            const node = nodes[i];
            if (fieldType.fixedSize === null) {
                // write offset
                output.dataView.setUint32(fixedIndex, variableIndex - offset, true);
                fixedIndex += 4;
                // write serialized element to variable section
                variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node);
            }
            else {
                fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node);
            }
        }
        return variableIndex;
    }
    tree_deserializeFromBytes(data, start, end) {
        const fieldRanges = this.getFieldRanges(data.dataView, start, end);
        const nodes = new Array(this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldType } = this.fieldsEntries[i];
            const fieldRange = fieldRanges[i];
            nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);
        }
        return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);
    }
    // Merkleization
    getRoots(struct) {
        const roots = new Array(this.fieldsEntries.length);
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType } = this.fieldsEntries[i];
            roots[i] = fieldType.hashTreeRoot(struct[fieldName]);
        }
        return roots;
    }
    // Proofs
    // getPropertyGindex
    // getPropertyType
    // tree_getLeafGindices
    getPropertyGindex(prop) {
        const gindex = this.fieldsGindex[prop] ?? this.fieldsGindex[this.jsonKeyToFieldName[prop]];
        if (gindex === undefined)
            throw Error(`Unknown container property ${prop}`);
        return gindex;
    }
    getPropertyType(prop) {
        const type = this.fields[prop] ?? this.fields[this.jsonKeyToFieldName[prop]];
        if (type === undefined)
            throw Error(`Unknown container property ${prop}`);
        return type;
    }
    getIndexProperty(index) {
        if (index >= this.fieldsEntries.length) {
            return null;
        }
        return this.fieldsEntries[index].fieldName;
    }
    tree_getLeafGindices(rootGindex, rootNode) {
        const gindices = [];
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType } = this.fieldsEntries[i];
            const fieldGindex = this.fieldsGindex[fieldName];
            const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);
            if (fieldType.isBasic) {
                gindices.push(fieldGindexFromRoot);
            }
            else {
                const compositeType = fieldType;
                if (fieldType.fixedSize === null) {
                    if (!rootNode) {
                        throw new Error("variable type requires tree argument to get leaves");
                    }
                    gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));
                }
                else {
                    gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));
                }
            }
        }
        return gindices;
    }
    // JSON
    fromJson(json) {
        if (typeof json !== "object") {
            throw Error("JSON must be of type object");
        }
        if (json === null) {
            throw Error("JSON must not be null");
        }
        const value = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];
            const jsonValue = json[jsonKey];
            if (jsonValue === undefined) {
                throw Error(`JSON expected key ${jsonKey} is undefined`);
            }
            value[fieldName] = fieldType.fromJson(jsonValue);
        }
        return value;
    }
    toJson(value) {
        const json = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];
            json[jsonKey] = fieldType.toJson(value[fieldName]);
        }
        return json;
    }
    clone(value) {
        const newValue = {};
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType } = this.fieldsEntries[i];
            newValue[fieldName] = fieldType.clone(value[fieldName]);
        }
        return newValue;
    }
    equals(a, b) {
        for (let i = 0; i < this.fieldsEntries.length; i++) {
            const { fieldName, fieldType } = this.fieldsEntries[i];
            if (!fieldType.equals(a[fieldName], b[fieldName])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.
     * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].
     * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen
     * - For variable size fields does a first pass over the fixed section to read offsets
     */
    getFieldRanges(data, start, end) {
        if (this.variableOffsetsPosition.length === 0) {
            // Validate fixed length container
            const size = end - start;
            if (size !== this.fixedEnd) {
                throw Error(`${this.typeName} size ${size} not equal fixed size ${this.fixedEnd}`);
            }
            return this.fieldRangesFixedLen;
        }
        // Read offsets in one pass
        const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);
        offsets.push(end - start); // The offsets are relative to the start
        // Merge fieldRangesFixedLen + offsets in one array
        let variableIdx = 0;
        let fixedIdx = 0;
        const fieldRanges = new Array(this.isFixedLen.length);
        for (let i = 0; i < this.isFixedLen.length; i++) {
            if (this.isFixedLen[i]) {
                // push from fixLen ranges ++
                fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];
            }
            else {
                // push from varLen ranges ++
                fieldRanges[i] = { start: offsets[variableIdx], end: offsets[variableIdx + 1] };
                variableIdx++;
            }
        }
        return fieldRanges;
    }
}
exports.ContainerType = ContainerType;
/**
 * Returns the byte ranges of all variable size fields.
 */
function readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {
    // Since variable-sized values can be interspersed with fixed-sized values, we precalculate
    // the offset indices so we can more easily deserialize the fields in once pass first we get the fixed sizes
    // Note: `fixedSizes[i] = null` if that field has variable length
    const size = end - start;
    // with the fixed sizes, we can read the offsets, and store for our single pass
    const offsets = new Array(variableOffsetsPosition.length);
    for (let i = 0; i < variableOffsetsPosition.length; i++) {
        const offset = data.getUint32(start + variableOffsetsPosition[i], true);
        // Validate offsets. If the list is empty the offset points to the end of the buffer, offset == size
        if (offset > size) {
            throw new Error(`Offset out of bounds ${offset} > ${size}`);
        }
        if (i === 0) {
            if (offset !== fixedEnd) {
                throw new Error(`First offset must equal to fixedEnd ${offset} != ${fixedEnd}`);
            }
        }
        else {
            if (offset < offsets[i - 1]) {
                throw new Error(`Offsets must be increasing ${offset} < ${offsets[i - 1]}`);
            }
        }
        offsets[i] = offset;
    }
    return offsets;
}
/**
 * Precompute fixed and variable offsets position for faster deserialization.
 * @returns Does a single pass over all fields and returns:
 * - isFixedLen: If field index [i] is fixed length
 * - fieldRangesFixedLen: For fields with fixed length, their range of bytes
 * - variableOffsetsPosition: Position of the 4 bytes offset for variable size fields
 * - fixedEnd: End of the fixed size range
 * -
 */
function precomputeSerdesData(fields) {
    const isFixedLen = [];
    const fieldRangesFixedLen = [];
    const variableOffsetsPosition = [];
    let pointerFixed = 0;
    for (const fieldType of Object.values(fields)) {
        isFixedLen.push(fieldType.fixedSize !== null);
        if (fieldType.fixedSize === null) {
            // Variable length
            variableOffsetsPosition.push(pointerFixed);
            pointerFixed += 4;
        }
        else {
            fieldRangesFixedLen.push({ start: pointerFixed, end: pointerFixed + fieldType.fixedSize });
            pointerFixed += fieldType.fixedSize;
        }
    }
    return {
        isFixedLen,
        fieldRangesFixedLen,
        variableOffsetsPosition,
        fixedEnd: pointerFixed,
    };
}
/**
 * Precompute sizes of the Container doing one pass over fields
 */
function precomputeSizes(fields) {
    let minLen = 0;
    let maxLen = 0;
    let fixedSize = 0;
    for (const fieldType of Object.values(fields)) {
        minLen += fieldType.minSize;
        maxLen += fieldType.maxSize;
        if (fieldType.fixedSize === null) {
            // +4 for the offset
            minLen += 4;
            maxLen += 4;
            fixedSize = null;
        }
        else if (fixedSize !== null) {
            fixedSize += fieldType.fixedSize;
        }
    }
    return { minLen, maxLen, fixedSize };
}
/**
 * Compute the JSON key for each fieldName. There will exist a single JSON representation for each type.
 * To transform JSON payloads to a casing that is different from the type's defined use external tooling.
 */
function precomputeJsonKey(fieldName, casingMap, jsonCase) {
    if (casingMap) {
        const keyFromCaseMap = casingMap[fieldName];
        if (keyFromCaseMap === undefined) {
            throw Error(`casingMap[${fieldName}] not defined`);
        }
        return keyFromCaseMap;
    }
    else if (jsonCase) {
        if (jsonCase === "eth2") {
            const snake = case_1.default.snake(fieldName);
            return snake.replace(/(\d)$/, "_$1");
        }
        else {
            return case_1.default[jsonCase](fieldName);
        }
    }
    else {
        return fieldName;
    }
}
exports.precomputeJsonKey = precomputeJsonKey;
/**
 * Render field typeNames for a detailed typeName of this Container
 */
function renderContainerTypeName(fields, prefix = "Container") {
    const fieldNames = Object.keys(fields);
    const fieldTypeNames = fieldNames.map((fieldName) => `${fieldName}: ${fields[fieldName].typeName}`).join(", ");
    return `${prefix}({${fieldTypeNames}})`;
}
exports.renderContainerTypeName = renderContainerTypeName;
//# sourceMappingURL=container.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\container.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\containerNodeStruct.js", {"../branchNodeStruct":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\branchNodeStruct.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../view/containerNodeStruct":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\containerNodeStruct.js","../viewDU/containerNodeStruct":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\containerNodeStruct.js","./composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","./container":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\container.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CcontainerNodeStruct.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerNodeStructType = void 0;
const composite_1 = require("./composite");
const container_1 = require("./container");
const named_1 = require("../util/named");
const containerNodeStruct_1 = require("../view/containerNodeStruct");
const containerNodeStruct_2 = require("../viewDU/containerNodeStruct");
const branchNodeStruct_1 = require("../branchNodeStruct");
/**
 * ContainerNodeStruct: ordered heterogeneous collection of values.
 * - Notation: Custom name per instance
 *
 * A ContainerNodeStruct is identical to a Container type except that it represents tree data with a custom
 * BranchNodeStruct node. This special branch node represents the data of its entire sub tree as a value, instead
 * of a tree of nodes. This approach is a tradeoff:
 *
 * - More memory efficient
 * - Faster reads, since it doesn't require parsing merkleized data
 * - Slower hashing, since it has to merkleize the entire value everytime and has not intermediary hashing cache
 *
 * This tradeoff is good for data that is read often, written rarely, and consumes a lot of memory (i.e. Validator)
 */
class ContainerNodeStructType extends container_1.ContainerType {
    constructor(fields, opts) {
        super(fields, {
            // Overwrite default "Container" typeName
            // Render detailed typeName. Consumers should overwrite since it can get long
            typeName: opts?.typeName ?? container_1.renderContainerTypeName(fields, "ContainerNodeStruct"),
            ...opts,
            getContainerTreeViewClass: containerNodeStruct_1.getContainerTreeViewClass,
            getContainerTreeViewDUClass: containerNodeStruct_2.getContainerTreeViewDUClass,
        });
        this.fields = fields;
        // ContainerNodeStructType TreeViews don't handle recursive mutable TreeViews like ContainerType does.
        // Using ContainerNodeStructType for fields that have mutable views (like a ListBasic), will result in
        // unnexpected behaviour if those child views are mutated.
        //
        // For example, this example below won't persist the pushed values to the list:
        // ```ts
        // const type = ContainerNodeStructType({a: new ListBasicType(byteType, 1)});
        // const view = type.defaultViewDU();
        // view.a.push(0)
        // ```
        // because the ListBasicViewDU in view.a will never propagate the changes upwards to its ContainerNodeStructType.
        for (const { fieldName, fieldType } of this.fieldsEntries) {
            if (composite_1.isCompositeType(fieldType) && fieldType.isViewMutable) {
                throw Error(`ContainerNodeStructType field '${fieldName}' ${fieldType.typeName} view is mutable`);
            }
        }
    }
    static named(fields, opts) {
        return new (named_1.namedClass(container_1.ContainerType, opts.typeName))(fields, opts);
    }
    tree_serializedSize(node) {
        return this.value_serializedSize(node.value);
    }
    tree_serializeToBytes(output, offset, node) {
        const { value } = node;
        return this.value_serializeToBytes(output, offset, value);
    }
    tree_deserializeFromBytes(data, start, end) {
        const value = this.value_deserializeFromBytes(data, start, end);
        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);
    }
    // Proofs
    // ContainerNodeStructType can only parse proofs that contain all the data.
    // TODO: Support converting a partial tree to a partial value
    getPropertyGindex() {
        return null;
    }
    // Post process tree to convert regular BranchNode to BranchNodeStruct
    // TODO: Optimize conversions
    tree_fromProofNode(node) {
        // TODO: Figure out from `node` alone if it contains complete data.
        // Otherwise throw a nice error "ContainerNodeStruct type requires proofs for all its data"
        const uint8Array = new Uint8Array(super.tree_serializedSize(node));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        super.tree_serializeToBytes({ uint8Array, dataView }, 0, node);
        const value = this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
        return {
            node: new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value),
            done: true,
        };
    }
    // Overwrites for fast conversion node <-> value
    tree_toValue(node) {
        return node.value;
    }
    value_toTree(value) {
        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);
    }
    // TODO: Optimize conversion
    valueToTree(value) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);
        return super.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);
    }
}
exports.ContainerNodeStructType = ContainerNodeStructType;
//# sourceMappingURL=containerNodeStruct.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\containerNodeStruct.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\listBasic.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../view/listBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\listBasic.js","../viewDU/listBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\listBasic.js","./array":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\array.js","./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5ClistBasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListBasicType = void 0;
const arrayBasic_1 = require("./arrayBasic");
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const listBasic_1 = require("../view/listBasic");
const listBasic_2 = require("../viewDU/listBasic");
const array_1 = require("./array");
/**
 * List: ordered variable-length homogeneous collection, limited to N values
 *
 * Array of Basic type:
 * - Basic types are max 32 bytes long so multiple values may be packed in the same node.
 * - Basic types are never returned in a view wrapper, but their value representation
 */
class ListBasicType extends array_1.ArrayType {
    constructor(elementType, limit, opts) {
        super(elementType);
        this.elementType = elementType;
        this.limit = limit;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        this.defaultLen = 0;
        if (!elementType.isBasic)
            throw Error("elementType must be basic");
        if (limit === 0)
            throw Error("List limit must be > 0");
        this.typeName = opts?.typeName ?? `List[${elementType.typeName}, ${limit}]`;
        // TODO Check that itemsPerChunk is an integer
        this.itemsPerChunk = 32 / elementType.byteLength;
        this.maxChunkCount = Math.ceil((this.limit * elementType.byteLength) / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        // Depth includes the extra level for the length node
        this.depth = this.chunkDepth + 1;
        this.minSize = 0;
        this.maxSize = this.limit * elementType.maxSize;
    }
    static named(elementType, limit, opts) {
        return new (named_1.namedClass(ListBasicType, opts.typeName))(elementType, limit, opts);
    }
    getView(tree) {
        return new listBasic_1.ListBasicTreeView(this, tree);
    }
    getViewDU(node, cache) {
        // cache type should be validated (if applicate) in the view
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return new listBasic_2.ListBasicTreeViewDU(this, node, cache);
    }
    commitView(view) {
        return view.node;
    }
    commitViewDU(view) {
        view.commit();
        return view.node;
    }
    cacheOfViewDU(view) {
        return view.cache;
    }
    // Serialization + deserialization
    value_serializedSize(value) {
        return value.length * this.elementType.byteLength;
    }
    value_serializeToBytes(output, offset, value) {
        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value.length, output, offset, value);
    }
    value_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);
    }
    tree_serializedSize(node) {
        return this.tree_getLength(node) * this.elementType.byteLength;
    }
    tree_serializeToBytes(output, offset, node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length = this.tree_getLength(node);
        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, length, this.chunkDepth, output, offset, chunksNode);
    }
    tree_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.chunkDepth, data, start, end, this);
    }
    // Helpers for TreeView
    tree_getLength(node) {
        return node.right.getUint(4, 0);
    }
    tree_setLength(tree, length) {
        tree.rootNode = arrayBasic_1.addLengthNode(tree.rootNode.left, length);
    }
    tree_getChunksNode(node) {
        return node.left;
    }
    tree_setChunksNode(rootNode, chunksNode, newLength) {
        return arrayBasic_1.setChunksNode(rootNode, chunksNode, newLength);
    }
    // Merkleization
    hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);
    }
    getRoots(value) {
        const uint8Array = new Uint8Array(this.value_serializedSize(value));
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value.length, { uint8Array, dataView }, 0, value);
        return merkleize_1.splitIntoRootChunks(uint8Array);
    }
}
exports.ListBasicType = ListBasicType;
//# sourceMappingURL=listBasic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\listBasic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\listComposite.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../view/listComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\listComposite.js","../viewDU/listComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\listComposite.js","./array":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\array.js","./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js","./arrayComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayComposite.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5ClistComposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListCompositeType = void 0;
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const arrayBasic_1 = require("./arrayBasic");
const arrayComposite_1 = require("./arrayComposite");
const listComposite_1 = require("../view/listComposite");
const listComposite_2 = require("../viewDU/listComposite");
const array_1 = require("./array");
/**
 * List: ordered variable-length homogeneous collection, limited to N values
 *
 * Array of Composite type:
 * - Composite types always take at least one chunk
 * - Composite types are always returned as views
 */
class ListCompositeType extends array_1.ArrayType {
    constructor(elementType, limit, opts) {
        super(elementType);
        this.elementType = elementType;
        this.limit = limit;
        this.itemsPerChunk = 1;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        this.defaultLen = 0;
        if (elementType.isBasic)
            throw Error("elementType must not be basic");
        if (limit === 0)
            throw Error("List limit must be > 0");
        this.typeName = opts?.typeName ?? `List[${elementType.typeName}, ${limit}]`;
        this.maxChunkCount = this.limit;
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        // Depth includes the extra level for the length node
        this.depth = this.chunkDepth + 1;
        this.minSize = 0;
        this.maxSize = arrayComposite_1.maxSizeArrayComposite(elementType, this.limit);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static named(elementType, limit, opts) {
        return new (named_1.namedClass(ListCompositeType, opts.typeName))(elementType, limit, opts);
    }
    getView(tree) {
        return new listComposite_1.ListCompositeTreeView(this, tree);
    }
    getViewDU(node, cache) {
        // cache type should be validated (if applicate) in the view
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return new listComposite_2.ListCompositeTreeViewDU(this, node, cache);
    }
    commitView(view) {
        return view.node;
    }
    commitViewDU(view) {
        view.commit();
        return view.node;
    }
    cacheOfViewDU(view) {
        return view.cache;
    }
    // Serialization + deserialization
    value_serializedSize(value) {
        return arrayComposite_1.value_serializedSizeArrayComposite(this.elementType, value.length, value);
    }
    value_serializeToBytes(output, offset, value) {
        return arrayComposite_1.value_serializeToBytesArrayComposite(this.elementType, value.length, output, offset, value);
    }
    value_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.value_deserializeFromBytesArrayComposite(this.elementType, data, start, end, this);
    }
    tree_serializedSize(node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length = this.tree_getLength(node);
        return arrayComposite_1.tree_serializedSizeArrayComposite(this.elementType, length, this.chunkDepth, chunksNode);
    }
    tree_serializeToBytes(output, offset, node) {
        const chunksNode = this.tree_getChunksNode(node);
        const length = this.tree_getLength(node);
        return arrayComposite_1.tree_serializeToBytesArrayComposite(this.elementType, length, this.chunkDepth, chunksNode, output, offset);
    }
    tree_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.tree_deserializeFromBytesArrayComposite(this.elementType, this.chunkDepth, data, start, end, this);
    }
    // Helpers for TreeView
    tree_getLength(node) {
        return arrayBasic_1.getLengthFromRootNode(node);
    }
    tree_setLength(tree, length) {
        tree.rootNode = arrayBasic_1.addLengthNode(tree.rootNode.left, length);
    }
    tree_getChunksNode(node) {
        return node.left;
    }
    tree_setChunksNode(rootNode, chunksNode, newLength) {
        return arrayBasic_1.setChunksNode(rootNode, chunksNode, newLength);
    }
    // Merkleization
    hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);
    }
    getRoots(value) {
        return arrayComposite_1.value_getRootsArrayComposite(this.elementType, value.length, value);
    }
}
exports.ListCompositeType = ListCompositeType;
//# sourceMappingURL=listComposite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\listComposite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\none.js", {"./basic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Cnone.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoneType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const basic_1 = require("./basic");
/* eslint-disable @typescript-eslint/member-ordering */
/* eslint-disable @typescript-eslint/no-unused-vars */
class NoneType extends basic_1.BasicType {
    constructor() {
        super(...arguments);
        this.typeName = "none";
        this.byteLength = 0;
        this.itemsPerChunk = 32;
        this.fixedSize = 0;
        this.minSize = 0;
        this.maxSize = 0;
    }
    defaultValue() {
        return null;
    }
    // bytes serdes
    value_serializeToBytes(output, offset, value) {
        return offset;
    }
    value_deserializeFromBytes(data, start) {
        return null;
    }
    tree_serializeToBytes(output, offset, node) {
        return offset;
    }
    tree_deserializeFromBytes(data, start, end) {
        return persistent_merkle_tree_1.zeroNode(0);
    }
    // Fast tree opts
    tree_getFromNode(leafNode) {
        return null;
    }
    tree_setToNode(leafNode, value) {
        return;
    }
    tree_getFromPackedNode(leafNode, index) {
        return null;
    }
    tree_setToPackedNode(leafNode, index, value) {
        return;
    }
    // JSON
    fromJson(json) {
        if (json !== null) {
            throw Error("JSON invalid type none must be null");
        }
        return null;
    }
    toJson(value) {
        return null;
    }
}
exports.NoneType = NoneType;
//# sourceMappingURL=none.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\none.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\uint.js", {"../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","./basic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Cuint.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const named_1 = require("../util/named");
const basic_1 = require("./basic");
/* eslint-disable @typescript-eslint/member-ordering */
const MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);
const BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);
const BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);
const BIGINT_2_POW_192 = BigInt(2) ** BigInt(192);
// const BIGINT_64_MAX = BigInt("0xffffffffffffffff");
const NUMBER_2_POW_32 = 2 ** 32;
const NUMBER_32_MAX = 0xffffffff;
exports.uintNumberByteLens = [1, 2, 4, 8];
exports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];
/**
 * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])
 * - Notation: uintN
 *
 * UintNumber is represented as the Javascript primitive value 'Number'.
 *
 * The Number type is a double-precision 64-bit binary format IEEE 754 value (numbers between -(2^53 − 1) and
 * 2^53 − 1). It also has the symbolic value: +Infinity.
 *
 * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. Some values are spec'ed as Uint64 but
 * practically they will never exceed 53 bits, such as any unit time or simple counters. This type is an optimization
 * for these cases, as UintNumber64 can represent any value between 0 and 2^53−1 as well as the max value 2^64-1.
 */
class UintNumberType extends basic_1.BasicType {
    constructor(byteLength, opts) {
        super();
        this.byteLength = byteLength;
        if (byteLength > 8) {
            throw Error("UintNumber byteLength limit is 8");
        }
        if (Math.log2(byteLength) % 1 !== 0) {
            throw Error("byteLength must be a power of 2");
        }
        this.typeName = opts?.typeName ?? `uint${byteLength * 8}`;
        if (opts?.clipInfinity)
            this.typeName += "Inf";
        if (opts?.setBitwiseOR)
            this.typeName += "OR";
        this.itemsPerChunk = 32 / this.byteLength;
        this.fixedSize = byteLength;
        this.minSize = byteLength;
        this.maxSize = byteLength;
        this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);
        this.clipInfinity = opts?.clipInfinity === true;
        this.setBitwiseOR = opts?.setBitwiseOR === true;
    }
    static named(byteLength, opts) {
        return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength, opts);
    }
    defaultValue() {
        return 0;
    }
    // Serialization + deserialization
    value_serializeToBytes({ dataView }, offset, value) {
        switch (this.byteLength) {
            case 1:
                dataView.setInt8(offset, value);
                break;
            case 2:
                dataView.setUint16(offset, value, true);
                break;
            case 4:
                dataView.setUint32(offset, value, true);
                break;
            case 8:
                if (value === Infinity) {
                    // TODO: Benchmark if it's faster to set BIGINT_64_MAX once
                    dataView.setUint32(offset, 0xffffffff);
                    dataView.setUint32(offset + 4, 0xffffffff);
                }
                else {
                    dataView.setUint32(offset, value & 0xffffffff, true);
                    dataView.setUint32(offset + 4, (value / NUMBER_2_POW_32) & 0xffffffff, true);
                }
                break;
        }
        return offset + this.byteLength;
    }
    value_deserializeFromBytes({ dataView }, start, end) {
        this.assertValidSize(end - start);
        switch (this.byteLength) {
            case 1:
                return dataView.getUint8(start);
            case 2:
                return dataView.getUint16(start, true);
            case 4:
                return dataView.getUint32(start, true);
            case 8: {
                const a = dataView.getUint32(start, true);
                const b = dataView.getUint32(start + 4, true);
                if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {
                    return Infinity;
                }
                else {
                    return b * NUMBER_2_POW_32 + a;
                }
            }
        }
    }
    tree_serializeToBytes(output, offset, node) {
        const value = node.getUint(this.byteLength, 0, this.clipInfinity);
        this.value_serializeToBytes(output, offset, value);
        return offset + this.byteLength;
    }
    tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const value = this.value_deserializeFromBytes(data, start, end);
        const node = persistent_merkle_tree_1.LeafNode.fromZero();
        node.setUint(this.byteLength, 0, value, this.clipInfinity);
        return node;
    }
    // Fast Tree access
    tree_getFromNode(leafNode) {
        return leafNode.getUint(this.byteLength, 0, this.clipInfinity);
    }
    tree_setToNode(leafNode, value) {
        this.tree_setToPackedNode(leafNode, 0, value);
    }
    tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);
    }
    tree_setToPackedNode(leafNode, index, value) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        // TODO: Benchmark the cost of this if, and consider using a different class
        if (this.setBitwiseOR) {
            leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value);
        }
        else {
            leafNode.setUint(this.byteLength, offsetBytes, value, this.clipInfinity);
        }
    }
    // JSON
    fromJson(json) {
        if (typeof json === "number") {
            return json;
        }
        else if (typeof json === "string") {
            if (this.clipInfinity && json === this.maxDecimalStr) {
                // Allow to handle max possible number
                return Infinity;
            }
            else {
                const num = parseInt(json, 10);
                if (isNaN(num)) {
                    throw Error("JSON invalid number isNaN");
                }
                else if (num > Number.MAX_SAFE_INTEGER) {
                    // Throw to prevent decimal precision errors downstream
                    throw Error("JSON invalid number > MAX_SAFE_INTEGER");
                }
                else {
                    return num;
                }
            }
        }
        else if (typeof json === "bigint") {
            if (json > MAX_SAFE_INTEGER_BN) {
                // Throw to prevent decimal precision errors downstream
                throw Error("JSON invalid number > MAX_SAFE_INTEGER_BN");
            }
            else {
                return Number(json);
            }
        }
        else {
            throw Error(`JSON invalid type ${typeof json} expected number`);
        }
    }
    toJson(value) {
        if (value === Infinity) {
            return this.maxDecimalStr;
        }
        else {
            return value.toString(10);
        }
    }
}
exports.UintNumberType = UintNumberType;
/**
 * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])
 * - Notation: uintN
 *
 * UintBigint is represented as the Javascript primitive value 'BigInt'.
 *
 * The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision.
 * With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers.
 *
 * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. For Uint values under 53 bits use UintNumber.
 * For other values that may exceed 53 bits, use UintBigint.
 */
class UintBigintType extends basic_1.BasicType {
    constructor(byteLength, opts) {
        super();
        this.byteLength = byteLength;
        if (byteLength > 32) {
            throw Error("UintBigint byteLength limit is 32");
        }
        if (Math.log2(byteLength) % 1 !== 0) {
            throw Error("byteLength must be a power of 2");
        }
        this.typeName = opts?.typeName ?? `uintBigint${byteLength * 8}`;
        this.byteLength = byteLength;
        this.itemsPerChunk = 32 / this.byteLength;
        this.fixedSize = byteLength;
        this.minSize = byteLength;
        this.maxSize = byteLength;
    }
    static named(byteLength, opts) {
        return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength, opts);
    }
    defaultValue() {
        return BigInt(0);
    }
    // Serialization + deserialization
    value_serializeToBytes({ dataView }, offset, value) {
        switch (this.byteLength) {
            case 1:
                dataView.setInt8(offset, Number(value));
                break;
            case 2:
                dataView.setUint16(offset, Number(value), true);
                break;
            case 4:
                dataView.setUint32(offset, Number(value), true);
                break;
            case 8:
                dataView.setBigUint64(offset, value, true);
                break;
            default: {
                for (let i = 0; i < this.byteLength; i += 8) {
                    if (i > 0)
                        value = value / BIGINT_2_POW_64;
                    const lo = BigInt.asUintN(64, value);
                    dataView.setBigUint64(offset + i, lo, true);
                }
            }
        }
        return offset + this.byteLength;
    }
    value_deserializeFromBytes({ dataView }, start, end) {
        const size = end - start;
        if (size !== this.byteLength) {
            throw Error(`Invalid size ${size} expected ${this.byteLength}`);
        }
        // Note: pre-assigning the right function at the constructor to avoid this switch is not faster
        switch (this.byteLength) {
            case 1:
                return BigInt(dataView.getUint8(start));
            case 2:
                return BigInt(dataView.getUint16(start, true));
            case 4:
                return BigInt(dataView.getUint32(start, true));
            case 8:
                return dataView.getBigUint64(start, true);
            case 16: {
                const a = dataView.getBigUint64(start, true);
                const b = dataView.getBigUint64(start + 8, true);
                return b * BIGINT_2_POW_64 + a;
            }
            case 32: {
                const a = dataView.getBigUint64(start, true);
                const b = dataView.getBigUint64(start + 8, true);
                const c = dataView.getBigUint64(start + 16, true);
                const d = dataView.getBigUint64(start + 24, true);
                return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;
            }
        }
    }
    tree_serializeToBytes(output, offset, node) {
        const value = node.getUintBigint(this.byteLength, 0);
        this.value_serializeToBytes(output, offset, value);
        return offset + this.byteLength;
    }
    tree_deserializeFromBytes(data, start, end) {
        const size = end - start;
        if (size !== this.byteLength) {
            throw Error(`Invalid size ${size} expected ${this.byteLength}`);
        }
        const value = this.value_deserializeFromBytes(data, start, end);
        const node = persistent_merkle_tree_1.LeafNode.fromZero();
        node.setUintBigint(this.byteLength, 0, value);
        return node;
    }
    // Fast Tree access
    tree_getFromNode(leafNode) {
        return leafNode.getUintBigint(this.byteLength, 0);
    }
    /** Mutates node to set value */
    tree_setToNode(leafNode, value) {
        this.tree_setToPackedNode(leafNode, 0, value);
    }
    /** EXAMPLE of `tree_getFromNode` */
    tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        return leafNode.getUintBigint(this.byteLength, offsetBytes);
    }
    /** Mutates node to set value */
    tree_setToPackedNode(leafNode, index, value) {
        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);
        // TODO: Not-optimized, copy pasted from UintNumberType
        leafNode.setUintBigint(this.byteLength, offsetBytes, value);
    }
    // JSON
    fromJson(json) {
        if (typeof json === "bigint") {
            return json;
        }
        else if (typeof json === "string" || typeof json === "number") {
            return BigInt(json);
        }
        else {
            throw Error(`JSON invalid type ${typeof json} expected bigint`);
        }
    }
    toJson(value) {
        return value.toString(10);
    }
}
exports.UintBigintType = UintBigintType;
//# sourceMappingURL=uint.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\uint.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\union.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js","./composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","./none":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\none.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5Cunion.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionType = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const composite_1 = require("./composite");
const arrayBasic_1 = require("./arrayBasic");
const none_1 = require("./none");
const VALUE_GINDEX = BigInt(2);
const SELECTOR_GINDEX = BigInt(3);
/**
 * Union: union type containing one of the given subtypes
 * - Notation: Union[type_0, type_1, ...], e.g. union[None, uint64, uint32]
 */
class UnionType extends composite_1.CompositeType {
    constructor(types, opts) {
        super();
        this.types = types;
        this.depth = 1;
        this.maxChunkCount = 1;
        this.fixedSize = null;
        this.isList = true;
        this.isViewMutable = true;
        if (types.length >= 128) {
            throw Error("Must have less than 128 types");
        }
        if (types.length === 0) {
            throw Error("Must have at least 1 type option");
        }
        if (types[0] instanceof none_1.NoneType && types.length < 2) {
            throw Error("Must have at least 2 type options if the first is None");
        }
        for (let i = 1; i < types.length; i++) {
            if (types[i] instanceof none_1.NoneType) {
                throw Error("None may only be the first option");
            }
        }
        this.typeName = opts?.typeName ?? `Union[${types.map((t) => t.typeName).join(",")}]`;
        const minLens = [];
        const maxLens = [];
        for (const _type of types) {
            minLens.push(_type.minSize);
            maxLens.push(_type.maxSize);
        }
        this.minSize = 1 + Math.min(...minLens);
        this.maxSize = 1 + Math.max(...maxLens);
        this.maxSelector = this.types.length - 1;
    }
    static named(types, opts) {
        return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);
    }
    defaultValue() {
        return {
            selector: 0,
            value: this.types[0].defaultValue(),
        };
    }
    getView(tree) {
        return this.tree_toValue(tree.rootNode);
    }
    getViewDU(node) {
        return this.tree_toValue(node);
    }
    cacheOfViewDU() {
        return;
    }
    commitView(view) {
        return this.value_toTree(view);
    }
    commitViewDU(view) {
        return this.value_toTree(view);
    }
    value_serializedSize(value) {
        return 1 + this.types[value.selector].value_serializedSize(value.value);
    }
    value_serializeToBytes(output, offset, value) {
        output.uint8Array[offset] = value.selector;
        return this.types[value.selector].value_serializeToBytes(output, offset + 1, value.value);
    }
    value_deserializeFromBytes(data, start, end) {
        const selector = data.uint8Array[start];
        if (selector > this.maxSelector) {
            throw Error(`Invalid selector ${selector}`);
        }
        return {
            selector,
            value: this.types[selector].value_deserializeFromBytes(data, start + 1, end),
        };
    }
    tree_serializedSize(node) {
        const selector = arrayBasic_1.getLengthFromRootNode(node);
        const valueNode = node.left;
        return 1 + this.types[selector].value_serializedSize(valueNode);
    }
    tree_serializeToBytes(output, offset, node) {
        const selector = arrayBasic_1.getLengthFromRootNode(node);
        const valueNode = node.left;
        output.uint8Array[offset] = selector;
        return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);
    }
    tree_deserializeFromBytes(data, start, end) {
        const selector = data.uint8Array[start];
        if (selector > this.maxSelector) {
            throw Error(`Invalid selector ${selector}`);
        }
        const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);
        return arrayBasic_1.addLengthNode(valueNode, selector);
    }
    // Merkleization
    hashTreeRoot(value) {
        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.selector);
    }
    getRoots(value) {
        const valueRoot = this.types[value.selector].hashTreeRoot(value.value);
        return [valueRoot];
    }
    // Proofs
    getPropertyGindex(prop) {
        switch (prop) {
            case "value":
                return VALUE_GINDEX;
            case "selector":
                return SELECTOR_GINDEX;
            default:
                throw new Error(`Invalid Union type property ${prop}`);
        }
    }
    getPropertyType() {
        // a Union has multiple types
        throw new Error("Not applicable for Union type");
    }
    getIndexProperty(index) {
        if (index === 0)
            return "value";
        if (index === 1)
            return "selector";
        throw Error("Union index of out bounds");
    }
    tree_getLeafGindices(rootGindex, rootNode) {
        if (!rootNode) {
            throw Error("rootNode required");
        }
        const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];
        const selector = arrayBasic_1.getLengthFromRootNode(rootNode);
        const type = this.types[selector];
        const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);
        if (composite_1.isCompositeType(type)) {
            gindices.push(...type.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));
        }
        else {
            gindices.push(extendedFieldGindex);
        }
        return gindices;
    }
    // JSON
    fromJson(json) {
        if (typeof json !== "object") {
            throw new Error("JSON must be of type object");
        }
        const union = json;
        if (typeof union.selector !== "number") {
            throw new Error("Invalid JSON Union selector must be number");
        }
        const type = this.types[union.selector];
        if (!type) {
            throw new Error("Invalid JSON Union selector out of range");
        }
        return {
            selector: union.selector,
            value: type.toJson(union.value),
        };
    }
    toJson(value) {
        return {
            selector: value.selector,
            value: this.types[value.selector].toJson(value.value),
        };
    }
    clone(value) {
        return {
            selector: value.selector,
            value: this.types[value.selector].clone(value.value),
        };
    }
    equals(a, b) {
        if (a.selector !== b.selector) {
            return false;
        }
        return this.types[a.selector].equals(a.value, b.value);
    }
}
exports.UnionType = UnionType;
//# sourceMappingURL=union.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\union.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\vectorBasic.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../view/arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayBasic.js","../viewDU/arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayBasic.js","./array":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\array.js","./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayBasic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CvectorBasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorBasicType = void 0;
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const arrayBasic_1 = require("./arrayBasic");
const arrayBasic_2 = require("../view/arrayBasic");
const arrayBasic_3 = require("../viewDU/arrayBasic");
const array_1 = require("./array");
/**
 * Vector: Ordered fixed-length homogeneous collection, with N values
 *
 * Array of Basic type:
 * - Basic types are max 32 bytes long so multiple values may be packed in the same node.
 * - Basic types are never returned in a view wrapper, but their value representation
 */
class VectorBasicType extends array_1.ArrayType {
    constructor(elementType, length, opts) {
        super(elementType);
        this.elementType = elementType;
        this.length = length;
        this.isList = false;
        this.isViewMutable = true;
        if (!elementType.isBasic)
            throw Error("elementType must be basic");
        if (length === 0)
            throw Error("Vector length must be > 0");
        this.typeName = opts?.typeName ?? `Vector[${elementType.typeName}, ${length}]`;
        // TODO Check that itemsPerChunk is an integer
        this.itemsPerChunk = 32 / elementType.byteLength;
        this.maxChunkCount = Math.ceil((length * elementType.byteLength) / 32);
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = length * elementType.byteLength;
        this.minSize = this.fixedSize;
        this.maxSize = this.fixedSize;
        this.defaultLen = length;
    }
    static named(elementType, limit, opts) {
        return new (named_1.namedClass(VectorBasicType, opts.typeName))(elementType, limit, opts);
    }
    getView(tree) {
        return new arrayBasic_2.ArrayBasicTreeView(this, tree);
    }
    getViewDU(node, cache) {
        // cache type should be validated (if applicate) in the view
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return new arrayBasic_3.ArrayBasicTreeViewDU(this, node, cache);
    }
    commitView(view) {
        return view.node;
    }
    commitViewDU(view) {
        view.commit();
        return view.node;
    }
    cacheOfViewDU(view) {
        return view.cache;
    }
    // Serialization + deserialization
    value_serializedSize() {
        return this.fixedSize;
    }
    value_serializeToBytes(output, offset, value) {
        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, output, offset, value);
    }
    value_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);
    }
    tree_serializedSize() {
        return this.fixedSize;
    }
    tree_serializeToBytes(output, offset, node) {
        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, output, offset, node);
    }
    tree_deserializeFromBytes(data, start, end) {
        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, data, start, end, this);
    }
    // Helpers for TreeView
    tree_getLength() {
        return this.length;
    }
    tree_setLength() {
        // Vector's length is immutable, ignore this call
    }
    tree_getChunksNode(node) {
        return node;
    }
    tree_setChunksNode(rootNode, chunksNode) {
        return chunksNode;
    }
    // Merkleization
    getRoots(value) {
        const uint8Array = new Uint8Array(this.fixedSize);
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, { uint8Array, dataView }, 0, value);
        return merkleize_1.splitIntoRootChunks(uint8Array);
    }
}
exports.VectorBasicType = VectorBasicType;
//# sourceMappingURL=vectorBasic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\vectorBasic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\vectorComposite.js", {"../util/merkleize":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js","../util/named":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js","../view/arrayComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayComposite.js","../viewDU/arrayComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayComposite.js","./array":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\array.js","./arrayComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\arrayComposite.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Ctype%5CvectorComposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorCompositeType = void 0;
const merkleize_1 = require("../util/merkleize");
const named_1 = require("../util/named");
const arrayComposite_1 = require("./arrayComposite");
const arrayComposite_2 = require("../view/arrayComposite");
const arrayComposite_3 = require("../viewDU/arrayComposite");
const array_1 = require("./array");
/**
 * Vector: Ordered fixed-length homogeneous collection, with N values
 *
 * Array of Composite type:
 * - Composite types always take at least one chunk
 * - Composite types are always returned as views
 */
class VectorCompositeType extends array_1.ArrayType {
    constructor(elementType, length, opts) {
        super(elementType);
        this.elementType = elementType;
        this.length = length;
        this.itemsPerChunk = 1;
        this.isList = false;
        this.isViewMutable = true;
        if (elementType.isBasic)
            throw Error("elementType must not be basic");
        if (length === 0)
            throw Error("Vector length must be > 0");
        this.typeName = opts?.typeName ?? `Vector[${elementType.typeName}, ${length}]`;
        this.maxChunkCount = length;
        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);
        this.depth = this.chunkDepth;
        this.fixedSize = elementType.fixedSize === null ? null : length * elementType.fixedSize;
        this.minSize = arrayComposite_1.minSizeArrayComposite(elementType, length);
        this.maxSize = arrayComposite_1.maxSizeArrayComposite(elementType, length);
        this.defaultLen = length;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static named(elementType, limit, opts) {
        return new (named_1.namedClass(VectorCompositeType, opts.typeName))(elementType, limit, opts);
    }
    getView(tree) {
        return new arrayComposite_2.ArrayCompositeTreeView(this, tree);
    }
    getViewDU(node, cache) {
        // cache type should be validated (if applicate) in the view
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return new arrayComposite_3.ArrayCompositeTreeViewDU(this, node, cache);
    }
    commitView(view) {
        return view.node;
    }
    commitViewDU(view) {
        view.commit();
        return view.node;
    }
    cacheOfViewDU(view) {
        return view.cache;
    }
    // Serialization + deserialization
    value_serializedSize(value) {
        return arrayComposite_1.value_serializedSizeArrayComposite(this.elementType, this.length, value);
    }
    value_serializeToBytes(output, offset, value) {
        return arrayComposite_1.value_serializeToBytesArrayComposite(this.elementType, this.length, output, offset, value);
    }
    value_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.value_deserializeFromBytesArrayComposite(this.elementType, data, start, end, this);
    }
    tree_serializedSize(node) {
        return arrayComposite_1.tree_serializedSizeArrayComposite(this.elementType, this.length, this.depth, node);
    }
    tree_serializeToBytes(output, offset, node) {
        return arrayComposite_1.tree_serializeToBytesArrayComposite(this.elementType, this.length, this.depth, node, output, offset);
    }
    tree_deserializeFromBytes(data, start, end) {
        return arrayComposite_1.tree_deserializeFromBytesArrayComposite(this.elementType, this.depth, data, start, end, this);
    }
    // Helpers for TreeView
    tree_getLength() {
        return this.length;
    }
    tree_setLength() {
        // Vector's length is immutable, ignore this call
    }
    tree_getChunksNode(node) {
        return node;
    }
    tree_setChunksNode(rootNode, chunksNode) {
        return chunksNode;
    }
    // Merkleization
    getRoots(value) {
        return arrayComposite_1.value_getRootsArrayComposite(this.elementType, this.length, value);
    }
}
exports.VectorCompositeType = VectorCompositeType;
//# sourceMappingURL=vectorComposite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\vectorComposite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\byteArray.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cutil%5CbyteArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0;
// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6
const hexByByte = new Array(256);
function toHexString(bytes) {
    let hex = "0x";
    for (const byte of bytes) {
        if (!hexByByte[byte]) {
            hexByByte[byte] = byte < 16 ? "0" + byte.toString(16) : byte.toString(16);
        }
        hex += hexByByte[byte];
    }
    return hex;
}
exports.toHexString = toHexString;
function fromHexString(hex) {
    if (typeof hex !== "string") {
        throw new Error(`hex argument type ${typeof hex} must be of type string`);
    }
    if (hex.startsWith("0x")) {
        hex = hex.slice(2);
    }
    if (hex.length % 2 !== 0) {
        throw new Error(`hex string length ${hex.length} must be multiple of 2`);
    }
    const byteLen = hex.length / 2;
    const bytes = new Uint8Array(byteLen);
    for (let i = 0; i < byteLen; i++) {
        const byte = parseInt(hex.slice(i * 2, (i + 1) * 2), 16);
        bytes[i] = byte;
    }
    return bytes;
}
exports.fromHexString = fromHexString;
function byteArrayEquals(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
exports.byteArrayEquals = byteArrayEquals;
//# sourceMappingURL=byteArray.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\byteArray.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js", {"./zeros":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\zeros.js","@chainsafe/as-sha256":"F:\\metamask-extension\\node_modules\\browserify\\lib\\_empty.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cutil%5Cmerkleize.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;
const as_sha256_1 = require("@chainsafe/as-sha256");
const zeros_1 = require("./zeros");
function hash64(bytes32A, bytes32B) {
    return as_sha256_1.digest2Bytes32(bytes32A, bytes32B);
}
exports.hash64 = hash64;
function merkleize(chunks, padFor) {
    const layerCount = bitLength(nextPowerOf2(padFor) - 1);
    if (chunks.length == 0) {
        return zeros_1.zeroHash(layerCount);
    }
    let chunkCount = chunks.length;
    // Instead of pushing on all padding zero chunks at the leaf level
    // we push on zero hash chunks at the highest possible level to avoid over-hashing
    for (let l = 0; l < layerCount; l++) {
        const padCount = chunkCount % 2;
        const paddedChunkCount = chunkCount + padCount;
        // if the chunks.length is odd
        // we need to push on the zero-hash of that level to merkleize that level
        for (let i = 0; i < padCount; i++) {
            chunks[chunkCount + i] = zeros_1.zeroHash(l);
        }
        for (let i = 0; i < paddedChunkCount; i += 2) {
            chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);
        }
        chunkCount = paddedChunkCount / 2;
    }
    return chunks[0];
}
exports.merkleize = merkleize;
/**
 * Split a long Uint8Array into Uint8Array of exactly 32 bytes
 */
function splitIntoRootChunks(longChunk) {
    const chunkCount = Math.ceil(longChunk.length / 32);
    const chunks = new Array(chunkCount);
    for (let i = 0; i < chunkCount; i++) {
        const chunk = new Uint8Array(32);
        chunk.set(longChunk.slice(i * 32, (i + 1) * 32));
        chunks[i] = chunk;
    }
    return chunks;
}
exports.splitIntoRootChunks = splitIntoRootChunks;
/** @ignore */
function mixInLength(root, length) {
    const lengthBuf = Buffer.alloc(32);
    lengthBuf.writeUIntLE(length, 0, 6);
    return hash64(root, lengthBuf);
}
exports.mixInLength = mixInLength;
// x2 faster than bitLengthStr() which uses Number.toString(2)
function bitLength(i) {
    if (i === 0) {
        return 0;
    }
    return Math.floor(Math.log2(i)) + 1;
}
exports.bitLength = bitLength;
/**
 * Given maxChunkCount return the chunkDepth
 * ```
 * n: [0,1,2,3,4,5,6,7,8,9]
 * d: [0,0,1,2,2,3,3,3,3,4]
 * ```
 */
function maxChunksToDepth(n) {
    if (n === 0)
        return 0;
    return Math.ceil(Math.log2(n));
}
exports.maxChunksToDepth = maxChunksToDepth;
/** @ignore */
function nextPowerOf2(n) {
    return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));
}
exports.nextPowerOf2 = nextPowerOf2;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\merkleize.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cutil%5Cnamed.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.namedClass = void 0;
function namedClass(superClass, className) {
    return new Function("superClass", `return class ${className} extends superClass {}`)(superClass);
}
exports.namedClass = namedClass;
//# sourceMappingURL=named.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\named.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\proof\\treePostProcessFromProofNode.js", {"@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cutil%5Cproof%5CtreePostProcessFromProofNode.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.treePostProcessFromProofNode = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
/** Duplicated partial declaration to break circular dependency with CompositeType */
function isCompositeType(type) {
    return !type.isBasic;
}
/**
 * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.
 * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features
 * non-standard nodes that make proofs for those types to be un-usable. This include:
 * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and
 *   all of its data into a single BranchNodeStruct instance.
 *
 * @param bitstring Bitstring without the leading "1", since it's only used to compute horizontal indexes.
 */
function treePostProcessFromProofNode(node, type, bitstring = "", currentDepth = 0) {
    // Must run tree_fromProofNode on the first received node (i.e. Validator object)
    if (currentDepth === 0) {
        const nodePost = type.tree_fromProofNode(node);
        if (nodePost.done) {
            return nodePost.node;
        }
        else {
            node = nodePost.node;
        }
    }
    const atTypeDepth = type.depth === currentDepth;
    if (node.isLeaf()) {
        if (atTypeDepth) {
            const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));
            if (jsonPathProp === null) {
                // bitstring is out of bounds, witness node
                return node;
            }
            const childType = type.getPropertyType(jsonPathProp);
            // If this type merkleized fits in a single chunk then this LeafNode includes all data
            if (childType.maxChunkCount === 1 && isCompositeType(childType)) {
                return childType.tree_fromProofNode(node).node;
            }
            // Witness node
            else {
                return node;
            }
        }
        // LeafNode not at type depth is a witness or a length / selector nodes
        else {
            return node;
        }
    }
    else {
        if (atTypeDepth) {
            const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));
            if (jsonPathProp === null) {
                // bitstring is out of bounds, witness node
                return node;
            }
            const childType = type.getPropertyType(jsonPathProp);
            if (!isCompositeType(childType)) {
                throw Error("BranchNode does not map to CompositeType");
            }
            const nodePost = childType.tree_fromProofNode(node);
            // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating
            if (nodePost.done) {
                return nodePost.node;
            }
            else {
                return treePostProcessFromProofNode(nodePost.node, childType);
            }
        }
        // BranchNode at not type depth, keep navigating
        else {
            const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + "0", currentDepth + 1);
            const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + "1", currentDepth + 1);
            if (leftNode === node.left && rightNode === node.right) {
                return node;
            }
            else {
                return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);
            }
        }
    }
}
exports.treePostProcessFromProofNode = treePostProcessFromProofNode;
/** Return the node horizontal index given a bitstring without the leading "1" */
function bitstringToIndex(bitstring) {
    if (bitstring === "")
        return 0;
    return parseInt(bitstring, 2);
}
//# sourceMappingURL=treePostProcessFromProofNode.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\proof\\treePostProcessFromProofNode.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\zeros.js", {"@chainsafe/as-sha256":"F:\\metamask-extension\\node_modules\\browserify\\lib\\_empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cutil%5Czeros.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zeroHash = void 0;
const as_sha256_1 = require("@chainsafe/as-sha256");
// create array of "zero hashes", successively hashed zero chunks
const zeroHashes = [new Uint8Array(32)];
function zeroHash(depth) {
    if (depth >= zeroHashes.length) {
        for (let i = zeroHashes.length; i <= depth; i++) {
            zeroHashes[i] = as_sha256_1.digest2Bytes32(zeroHashes[i - 1], zeroHashes[i - 1]);
        }
    }
    return zeroHashes[depth];
}
exports.zeroHash = zeroHash;
//# sourceMappingURL=zeros.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\util\\zeros.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\value\\bitArray.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cvalue%5CbitArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;
/** Globally cache this information. @see getUint8ByteToBitBooleanArray */
const uint8ByteToBitBooleanArrays = new Array(256);
/**
 * BitArray may be represented as an array of bits or compressed into an array of bytes.
 *
 * **Array of bits**:
 * Require 8.87 bytes per bit, so for 512 bits = 4500 bytes.
 * Are 'faster' to iterate with native tooling but are as fast as array of bytes with precomputed caches.
 *
 * **Array of bytes**:
 * Require an average cost of Uint8Array in JS = 220 bytes for 32 bytes, so for 512 bits = 220 bytes.
 * With precomputed boolean arrays per bytes value are as fast to iterate as an array of bits above.
 *
 * This BitArray implementation will represent data as a Uint8Array since it's very cheap to deserialize and can be as
 * fast to iterate as a native array of booleans, precomputing boolean arrays (total memory cost of 16000 bytes).
 */
class BitArray {
    constructor(
    /** Underlying BitArray Uint8Array data */
    uint8Array, 
    /** Immutable bitLen of this BitArray */
    bitLen) {
        this.uint8Array = uint8Array;
        this.bitLen = bitLen;
        if (uint8Array.length !== Math.ceil(bitLen / 8)) {
            throw Error("BitArray uint8Array length does not match bitLen");
        }
    }
    /** Returns a zero'ed BitArray of `bitLen` */
    static fromBitLen(bitLen) {
        return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);
    }
    /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */
    static fromSingleBit(bitLen, bitIndex) {
        const bitArray = BitArray.fromBitLen(bitLen);
        bitArray.set(bitIndex, true);
        return bitArray;
    }
    /** Returns a BitArray from an array of booleans representation */
    static fromBoolArray(bitBoolArr) {
        const bitArray = BitArray.fromBitLen(bitBoolArr.length);
        for (let i = 0; i < bitBoolArr.length; i++) {
            if (bitBoolArr[i] === true) {
                bitArray.set(i, true);
            }
        }
        return bitArray;
    }
    clone() {
        // TODO: Benchmark if Uint8Array.slice(0) is the fastest way to copy data here
        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087
        return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);
    }
    /**
     * Get bit value at index `bitIndex`
     */
    get(bitIndex) {
        const byteIdx = Math.floor(bitIndex / 8);
        const bitInBit = bitIndex % 8;
        const mask = 1 << bitInBit;
        return (this.uint8Array[byteIdx] & mask) === mask;
    }
    /**
     * Set bit value at index `bitIndex`
     */
    set(bitIndex, bit) {
        if (bitIndex >= this.bitLen) {
            throw Error(`BitArray set bitIndex ${bitIndex} beyond bitLen ${this.bitLen}`);
        }
        const byteIdx = Math.floor(bitIndex / 8);
        const bitInBit = bitIndex % 8;
        const mask = 1 << bitInBit;
        let byte = this.uint8Array[byteIdx];
        if (bit) {
            // For bit in byte, 1,0 OR 1 = 1
            // byte 100110
            // mask 010000
            // res  110110
            byte |= mask;
            this.uint8Array[byteIdx] = byte;
        }
        else {
            // For bit in byte, 1,0 OR 1 = 0
            if ((byte & mask) === mask) {
                // byte 110110
                // mask 010000
                // res  100110
                byte ^= mask;
                this.uint8Array[byteIdx] = byte;
            }
            else {
                // Ok, bit is already 0
            }
        }
    }
    /** Merge two BitArray bitfields with OR. Must have the same bitLen */
    mergeOrWith(bitArray2) {
        if (bitArray2.bitLen !== this.bitLen) {
            throw Error("Must merge BitArrays of same bitLen");
        }
        // Merge bitFields
        for (let i = 0; i < this.uint8Array.length; i++) {
            this.uint8Array[i] = this.uint8Array[i] | bitArray2.uint8Array[i];
        }
    }
    /**
     * Returns an array with the indexes which have a bit set to true
     */
    intersectValues(values) {
        const yes = [];
        if (values.length !== this.bitLen) {
            throw Error(`Must not intersect values of length ${values.length} != bitLen ${this.bitLen}`);
        }
        const fullByteLen = Math.floor(this.bitLen / 8);
        const remainderBits = this.bitLen % 8;
        // Iterate over each byte of bits
        const bytes = this.uint8Array;
        for (let iByte = 0; iByte < fullByteLen; iByte++) {
            // Get the precomputed boolean array for this byte
            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
            // For each bit in the byte check participation and add to indexesSelected array
            for (let iBit = 0; iBit < 8; iBit++) {
                if (booleansInByte[iBit]) {
                    yes.push(values[iByte * 8 + iBit]);
                }
            }
        }
        if (remainderBits > 0) {
            // Get the precomputed boolean array for this byte
            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]);
            // For each bit in the byte check participation and add to indexesSelected array
            for (let iBit = 0; iBit < remainderBits; iBit++) {
                if (booleansInByte[iBit]) {
                    yes.push(values[fullByteLen * 8 + iBit]);
                }
            }
        }
        return yes;
    }
    /**
     * Returns the positions of all bits that are set to true
     */
    getTrueBitIndexes() {
        const indexes = [];
        // Iterate over each byte of bits
        const bytes = this.uint8Array;
        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {
            // Get the precomputed boolean array for this byte
            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
            // For each bit in the byte check participation and add to indexesSelected array
            for (let iBit = 0; iBit < 8; iBit++) {
                if (booleansInByte[iBit]) {
                    indexes.push(iByte * 8 + iBit);
                }
            }
        }
        return indexes;
    }
    /**
     * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.
     * @returns
     *  - number: if there's a single bit set, the number it the single bit set position
     *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET
     * @throws
     *  - ERROR_MORE_THAN_ONE_BIT_SET
     *  - ERROR_NO_BIT_SET
     */
    getSingleTrueBit() {
        let index = null;
        const bytes = this.uint8Array;
        // Iterate over each byte of bits
        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {
            // If it's exactly zero, there won't be any indexes, continue early
            if (bytes[iByte] === 0) {
                continue;
            }
            // Get the precomputed boolean array for this byte
            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);
            // For each bit in the byte check participation and add to indexesSelected array
            for (let iBit = 0; iBit < 8; iBit++) {
                if (booleansInByte[iBit] === true) {
                    if (index !== null) {
                        // ERROR_MORE_THAN_ONE_BIT_SET
                        return null;
                    }
                    index = iByte * 8 + iBit;
                }
            }
        }
        if (index === null) {
            // ERROR_NO_BIT_SET
            return null;
        }
        else {
            return index;
        }
    }
    toBoolArray() {
        const bitBoolArr = new Array(this.bitLen);
        for (let i = 0; i < this.bitLen; i++) {
            bitBoolArr[i] = this.get(i);
        }
        return bitBoolArr;
    }
}
exports.BitArray = BitArray;
/**
 * Given a byte (0 -> 255), return a Array of boolean with length = 8, big endian.
 * Ex: 1 => [true false false false false false false false]
 *     5 => [true false true false false fase false false]
 */
function getUint8ByteToBitBooleanArray(byte) {
    if (!uint8ByteToBitBooleanArrays[byte]) {
        uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);
    }
    return uint8ByteToBitBooleanArrays[byte];
}
exports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;
/** @see getUint8ByteToBitBooleanArray */
function computeUint8ByteToBitBooleanArray(byte) {
    // this returns little endian
    const binaryStr = byte.toString(2);
    const binaryLength = binaryStr.length;
    const bits = new Array(8);
    for (let i = 0; i < 8; i++) {
        bits[i] =
            i < binaryLength
                ? //
                    binaryStr[binaryLength - i - 1] === "1"
                : false;
    }
    return bits;
}
//# sourceMappingURL=bitArray.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\value\\bitArray.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js", {"../view/abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5Cabstract.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeViewDU = void 0;
const abstract_1 = require("../view/abstract");
/* eslint-disable @typescript-eslint/member-ordering  */
/**
 * A Deferred Update Tree View (`ViewDU`) is a wrapper around a type and
 * a SSZ Node that contains:
 * - data merkleized
 * - some arbitrary caches to speed up data manipulation required by the type
 *
 * **ViewDU**
 * - Best for complex usage where performance is important
 * - Defers changes to when commit is called
 * - Does NOT have a reference to the parent ViewDU
 * - Has caches for fast get / set ops
 */
class TreeViewDU extends abstract_1.TreeView {
    /**
     * Merkleize view and compute its hashTreeRoot.
     * Commits any pending changes before computing the root.
     *
     * See spec for definition of hashTreeRoot:
     * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization
     */
    hashTreeRoot() {
        this.commit();
        return super.hashTreeRoot();
    }
    /**
     * Serialize view to binary data.
     * Commits any pending changes before computing the root.
     */
    serialize() {
        this.commit();
        return super.serialize();
    }
    /**
     * Return a new ViewDU instance referencing the same internal `Node`.
     *
     * By default it will transfer the cache of this ViewDU to the new cloned instance. Set `dontTransferCache` to true
     * to NOT transfer the cache to the cloned instance.
     */
    clone(dontTransferCache) {
        if (dontTransferCache) {
            return this.type.getViewDU(this.node);
        }
        else {
            const cache = this.cache;
            this.clearCache();
            return this.type.getViewDU(this.node, cache);
        }
    }
}
exports.TreeViewDU = TreeViewDU;
//# sourceMappingURL=abstract.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayBasic.js", {"./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5CarrayBasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayBasicTreeViewDU = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const abstract_1 = require("./abstract");
class ArrayBasicTreeViewDU extends abstract_1.TreeViewDU {
    constructor(type, _rootNode, cache) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        this.nodesChanged = new Set();
        this.dirtyLength = false;
        if (cache) {
            this.nodes = cache.nodes;
            this._length = cache.length;
            this.nodesPopulated = cache.nodesPopulated;
        }
        else {
            this.nodes = [];
            this._length = this.type.tree_getLength(_rootNode);
            this.nodesPopulated = false;
        }
    }
    /**
     * Number of elements in the array. Equal to un-commited length of the array
     */
    get length() {
        return this._length;
    }
    get node() {
        return this._rootNode;
    }
    get cache() {
        return {
            nodes: this.nodes,
            length: this._length,
            nodesPopulated: this.nodesPopulated,
        };
    }
    /**
     * Get element at `index`. Returns the Basic element type value directly
     */
    get(index) {
        // First walk through the tree to get the root node for that index
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        let node = this.nodes[chunkIndex];
        if (node === undefined) {
            node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);
            this.nodes[chunkIndex] = node;
        }
        return this.type.elementType.tree_getFromPackedNode(node, index);
    }
    /**
     * Set Basic element type `value` at `index`
     */
    set(index, value) {
        if (index >= this._length) {
            throw Error(`Error setting index over length ${index} > ${this._length}`);
        }
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        // Create new node if current leafNode is not dirty
        let nodeChanged;
        if (this.nodesChanged.has(chunkIndex)) {
            // TODO: This assumes that node has already been populated
            nodeChanged = this.nodes[chunkIndex];
        }
        else {
            const nodePrev = (this.nodes[chunkIndex] ??
                persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex));
            nodeChanged = nodePrev.clone();
            // Store the changed node in the nodes cache
            this.nodes[chunkIndex] = nodeChanged;
            this.nodesChanged.add(chunkIndex);
        }
        this.type.elementType.tree_setToPackedNode(nodeChanged, index, value);
    }
    /**
     * Get all values of this array as Basic element type values, from index zero to `this.length - 1`
     */
    getAll() {
        if (!this.nodesPopulated) {
            const nodesPrev = this.nodes;
            const chunksNode = this.type.tree_getChunksNode(this.node);
            const chunkCount = Math.ceil(this._length / this.type.itemsPerChunk);
            this.nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);
            // Re-apply changed nodes
            for (const index of this.nodesChanged) {
                this.nodes[index] = nodesPrev[index];
            }
            this.nodesPopulated = true;
        }
        const values = new Array(this._length);
        const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below
        const lenFullNodes = Math.floor(this._length / itemsPerChunk);
        const remainder = this._length % itemsPerChunk;
        // TODO Optimize: caching the variables used in the loop above it
        for (let n = 0; n < lenFullNodes; n++) {
            const leafNode = this.nodes[n];
            // TODO: Implement add a fast bulk packed element reader in the elementType
            // ```
            // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;
            // ```
            // if performance here is a problem
            for (let i = 0; i < itemsPerChunk; i++) {
                values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
            }
        }
        if (remainder > 0) {
            const leafNode = this.nodes[lenFullNodes];
            for (let i = 0; i < remainder; i++) {
                values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
            }
        }
        return values;
    }
    commit() {
        if (this.nodesChanged.size === 0) {
            return;
        }
        // Numerical sort ascending
        const indexes = Array.from(this.nodesChanged.keys()).sort((a, b) => a - b);
        const nodes = new Array(indexes.length);
        for (let i = 0; i < indexes.length; i++) {
            nodes[i] = this.nodes[indexes[i]];
        }
        const chunksNode = this.type.tree_getChunksNode(this._rootNode);
        // TODO: Ensure fast setNodesAtDepth() method is correct
        const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);
        this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : undefined);
        this.nodesChanged.clear();
        this.dirtyLength = false;
    }
    clearCache() {
        this.nodes = [];
        this.nodesPopulated = false;
        // Must clear nodesChanged, otherwise a subsequent commit call will break, because it assumes a node is there
        this.nodesChanged.clear();
        // Reset cached length only if it has been mutated
        if (this.dirtyLength) {
            this._length = this.type.tree_getLength(this._rootNode);
            this.dirtyLength = false;
        }
    }
}
exports.ArrayBasicTreeViewDU = ArrayBasicTreeViewDU;
//# sourceMappingURL=arrayBasic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayBasic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayComposite.js", {"./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5CarrayComposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayCompositeTreeViewDU = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const abstract_1 = require("./abstract");
class ArrayCompositeTreeViewDU extends abstract_1.TreeViewDU {
    constructor(type, _rootNode, cache) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        this.viewsChanged = new Map();
        // TODO: Consider these properties are not accessible in the cache object persisted in the parent's cache.
        // nodes, caches, _length, and nodesPopulated are mutated. Consider having them in a _cache object such that
        // mutations affect the cache already found in the parent object
        this.dirtyLength = false;
        if (cache) {
            this.nodes = cache.nodes;
            this.caches = cache.caches;
            this._length = cache.length;
            this.nodesPopulated = cache.nodesPopulated;
        }
        else {
            this.nodes = [];
            this.caches = [];
            this._length = this.type.tree_getLength(_rootNode);
            // If there are exactly 0 nodes, nodesPopulated = true because 0 / 0 are in the nodes array
            this.nodesPopulated = this._length === 0;
        }
    }
    /**
     * Number of elements in the array. Equal to un-commited length of the array
     */
    get length() {
        return this._length;
    }
    get node() {
        return this._rootNode;
    }
    get cache() {
        return {
            nodes: this.nodes,
            caches: this.caches,
            length: this._length,
            nodesPopulated: this.nodesPopulated,
        };
    }
    /**
     * Get element at `index`. Returns a view of the Composite element type.
     *
     * NOTE: Assumes that any view created here will change and will call .commit() on it.
     * .get() should be used only for cases when something may mutate. To get all items without
     * triggering a .commit() in all them use .getAllReadOnly().
     */
    get(index) {
        const viewChanged = this.viewsChanged.get(index);
        if (viewChanged) {
            return viewChanged;
        }
        let node = this.nodes[index];
        if (node === undefined) {
            node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
            this.nodes[index] = node;
        }
        // Keep a reference to the new view to call .commit on it latter, only if mutable
        const view = this.type.elementType.getViewDU(node, this.caches[index]);
        if (this.type.elementType.isViewMutable) {
            this.viewsChanged.set(index, view);
        }
        // No need to persist the child's view cache since a second get returns this view instance.
        // The cache is only persisted on commit where the viewsChanged map is dropped.
        return view;
    }
    /**
     * Get element at `index`. Returns a view of the Composite element type.
     * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.
     */
    getReadonly(index) {
        const viewChanged = this.viewsChanged.get(index);
        if (viewChanged) {
            return viewChanged;
        }
        let node = this.nodes[index];
        if (node === undefined) {
            node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
            this.nodes[index] = node;
        }
        return this.type.elementType.getViewDU(node, this.caches[index]);
    }
    // Did not implemented
    // `getReadonlyValue(index: number): ValueOf<ElementType>`
    // because it can break in unexpected ways if there are pending changes in this.viewsChanged.
    // This function could first check if `this.viewsChanged` has a view for `index` and commit it,
    // but that would be pretty slow, and the same result can be achieved with
    // `this.getReadonly(index).toValue()`
    /**
     * Set Composite element type `view` at `index`
     */
    set(index, view) {
        if (index >= this._length) {
            throw Error(`Error setting index over length ${index} > ${this._length}`);
        }
        // When setting a view:
        // - Not necessary to commit node
        // - Not necessary to persist cache
        // Just keeping a reference to the view in this.viewsChanged ensures consistency
        this.viewsChanged.set(index, view);
    }
    /**
     * WARNING: Returns all commited changes, if there are any pending changes commit them beforehand
     */
    getAllReadonly() {
        this.populateAllNodes();
        const views = new Array(this._length);
        for (let i = 0; i < this._length; i++) {
            views[i] = this.type.elementType.getViewDU(this.nodes[i], this.caches[i]);
        }
        return views;
    }
    /**
     * WARNING: Returns all commited changes, if there are any pending changes commit them beforehand
     */
    getAllReadonlyValues() {
        this.populateAllNodes();
        const values = new Array(this._length);
        for (let i = 0; i < this._length; i++) {
            values[i] = this.type.elementType.tree_toValue(this.nodes[i]);
        }
        return values;
    }
    commit() {
        if (this.viewsChanged.size === 0) {
            return;
        }
        const nodesChanged = [];
        for (const [index, view] of this.viewsChanged) {
            const node = this.type.elementType.commitViewDU(view);
            // Set new node in nodes array to ensure data represented in the tree and fast nodes access is equal
            this.nodes[index] = node;
            nodesChanged.push({ index, node });
            // Cache the view's caches to preserve it's data after 'this.viewsChanged.clear()'
            const cache = this.type.elementType.cacheOfViewDU(view);
            if (cache)
                this.caches[index] = cache;
        }
        // TODO: Optimize to loop only once, Numerical sort ascending
        const nodesChangedSorted = nodesChanged.sort((a, b) => a.index - b.index);
        const indexes = nodesChangedSorted.map((entry) => entry.index);
        const nodes = nodesChangedSorted.map((entry) => entry.node);
        const chunksNode = this.type.tree_getChunksNode(this._rootNode);
        // TODO: Ensure fast setNodesAtDepth() method is correct
        const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);
        this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : undefined);
        this.viewsChanged.clear();
        this.dirtyLength = false;
    }
    clearCache() {
        this.nodes = [];
        this.caches = [];
        this.nodesPopulated = false;
        // It's not necessary to clear this.viewsChanged since they have no effect on the cache.
        // However preserving _SOME_ caches results in a very unpredictable experience.
        this.viewsChanged.clear();
        // Reset cached length only if it has been mutated
        if (this.dirtyLength) {
            this._length = this.type.tree_getLength(this._rootNode);
            this.dirtyLength = false;
        }
    }
    populateAllNodes() {
        // If there's uncommited changes it may break.
        // this.length can be increased but this._rootNode doesn't have that item
        if (this.viewsChanged.size > 0) {
            throw Error("Must commit changes before reading all nodes");
        }
        if (!this.nodesPopulated) {
            this.nodes = persistent_merkle_tree_1.getNodesAtDepth(this._rootNode, this.type.depth, 0, this.length);
            this.nodesPopulated = true;
        }
    }
}
exports.ArrayCompositeTreeViewDU = ArrayCompositeTreeViewDU;
//# sourceMappingURL=arrayComposite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayComposite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\bitArray.js", {"./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5CbitArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitArrayTreeViewDU = void 0;
const abstract_1 = require("./abstract");
/**
 * Thin wrapper around BitArray to upstream changes after `this.commit()`
 */
class BitArrayTreeViewDU extends abstract_1.TreeViewDU {
    constructor(type, _rootNode) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        /** Cached BitArray instance computed only on demand */
        this._bitArray = null;
    }
    get node() {
        return this._rootNode;
    }
    get cache() {
        return;
    }
    commit() {
        if (this._bitArray !== null) {
            this._rootNode = this.type.value_toTree(this._bitArray);
        }
    }
    // Wrapped API from BitArray
    /** @see BitArray.uint8Array */
    get uint8Array() {
        return this.bitArray.uint8Array;
    }
    /** @see BitArray.bitLen */
    get bitLen() {
        return this.bitArray.bitLen;
    }
    /** @see BitArray.get */
    get(bitIndex) {
        return this.bitArray.get(bitIndex);
    }
    /** @see BitArray.set */
    set(bitIndex, bit) {
        this.bitArray.set(bitIndex, bit);
    }
    /** @see BitArray.mergeOrWith */
    mergeOrWith(bitArray2) {
        this.bitArray.mergeOrWith(bitArray2);
    }
    /** @see BitArray.intersectValues */
    intersectValues(values) {
        return this.bitArray.intersectValues(values);
    }
    /** @see BitArray.getTrueBitIndexes */
    getTrueBitIndexes() {
        return this.bitArray.getTrueBitIndexes();
    }
    /** @see BitArray.getSingleTrueBit */
    getSingleTrueBit() {
        return this.bitArray.getSingleTrueBit();
    }
    /** @see BitArray.toBoolArray */
    toBoolArray() {
        return this.bitArray.toBoolArray();
    }
    /** Lazily computed bitArray instance */
    get bitArray() {
        if (this._bitArray === null) {
            this._bitArray = this.type.tree_toValue(this._rootNode);
        }
        return this._bitArray;
    }
    clearCache() {
        this._bitArray = null;
    }
}
exports.BitArrayTreeViewDU = BitArrayTreeViewDU;
//# sourceMappingURL=bitArray.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\bitArray.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\container.js", {"../type/basic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js","../type/composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5Ccontainer.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContainerTreeViewDUClass = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const basic_1 = require("../type/basic");
const composite_1 = require("../type/composite");
const abstract_1 = require("./abstract");
class ContainerTreeViewDU extends abstract_1.TreeViewDU {
    constructor(type, _rootNode, cache) {
        super();
        this.type = type;
        this._rootNode = _rootNode;
        this.nodes = [];
        this.nodesChanged = new Set();
        this.viewsChanged = new Map();
        if (cache) {
            this.nodes = cache.nodes;
            this.caches = cache.caches;
            this.nodesPopulated = cache.nodesPopulated;
        }
        else {
            this.nodes = [];
            this.caches = [];
            this.nodesPopulated = false;
        }
    }
    get node() {
        return this._rootNode;
    }
    get cache() {
        return {
            nodes: this.nodes,
            caches: this.caches,
            nodesPopulated: this.nodesPopulated,
        };
    }
    commit() {
        if (this.nodesChanged.size === 0 && this.viewsChanged.size === 0) {
            return;
        }
        const nodesChanged = [];
        for (const [index, view] of this.viewsChanged) {
            const fieldType = this.type.fieldsEntries[index].fieldType;
            const node = fieldType.commitViewDU(view);
            // Set new node in nodes array to ensure data represented in the tree and fast nodes access is equal
            this.nodes[index] = node;
            nodesChanged.push({ index, node });
            // Cache the view's caches to preserve it's data after 'this.viewsChanged.clear()'
            const cache = fieldType.cacheOfViewDU(view);
            if (cache)
                this.caches[index] = cache;
        }
        for (const index of this.nodesChanged) {
            nodesChanged.push({ index, node: this.nodes[index] });
        }
        // TODO: Optimize to loop only once, Numerical sort ascending
        const nodesChangedSorted = nodesChanged.sort((a, b) => a.index - b.index);
        const indexes = nodesChangedSorted.map((entry) => entry.index);
        const nodes = nodesChangedSorted.map((entry) => entry.node);
        this._rootNode = persistent_merkle_tree_1.setNodesAtDepth(this._rootNode, this.type.depth, indexes, nodes);
        this.nodesChanged.clear();
        this.viewsChanged.clear();
    }
    clearCache() {
        this.nodes = [];
        this.caches = [];
        this.nodesPopulated = false;
        // Must clear nodesChanged, otherwise a subsequent commit call will break, because it assumes a node is there
        this.nodesChanged.clear();
        // It's not necessary to clear this.viewsChanged since they have no effect on the cache.
        // However preserving _SOME_ caches results in a very unpredictable experience.
        this.viewsChanged.clear();
    }
}
function getContainerTreeViewDUClass(type) {
    class CustomContainerTreeViewDU extends ContainerTreeViewDU {
    }
    // Dynamically define prototype methods
    for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        // If the field type is basic, the value to get and set will be the actual 'struct' value (i.e. a JS number).
        // The view must use the tree_getFromNode() and tree_setToNode() methods to persist the struct data to the node,
        // and use the cached views array to store the new node.
        if (basic_1.isBasicType(fieldType)) {
            Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // TODO: Review the memory cost of this closures
                get: function () {
                    // First walk through the tree to get the root node for that index
                    let node = this.nodes[index];
                    if (node === undefined) {
                        node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                        this.nodes[index] = node;
                    }
                    return fieldType.tree_getFromNode(node);
                },
                set: function (value) {
                    // Create new node if current leafNode is not dirty
                    let nodeChanged;
                    if (this.nodesChanged.has(index)) {
                        // TODO: This assumes that node has already been populated
                        nodeChanged = this.nodes[index];
                    }
                    else {
                        const nodePrev = (this.nodes[index] ?? persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index));
                        nodeChanged = nodePrev.clone();
                        // Store the changed node in the nodes cache
                        this.nodes[index] = nodeChanged;
                        this.nodesChanged.add(index);
                    }
                    fieldType.tree_setToNode(nodeChanged, value);
                },
            });
        }
        // If the field type is composite, the value to get and set will be another TreeView. The parent TreeView must
        // cache the view itself to retain the caches of the child view. To set a value the view must return a node to
        // set it to the parent tree in the field gindex.
        else if (composite_1.isCompositeType(fieldType)) {
            Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // Returns TreeViewDU of fieldName
                get: function () {
                    const viewChanged = this.viewsChanged.get(index);
                    if (viewChanged) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                        return viewChanged;
                    }
                    let node = this.nodes[index];
                    if (node === undefined) {
                        node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, index);
                        this.nodes[index] = node;
                    }
                    // Keep a reference to the new view to call .commit on it latter, only if mutable
                    const view = fieldType.getViewDU(node, this.caches[index]);
                    if (fieldType.isViewMutable) {
                        this.viewsChanged.set(index, view);
                    }
                    // No need to persist the child's view cache since a second get returns this view instance.
                    // The cache is only persisted on commit where the viewsChanged map is dropped.
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return view;
                },
                // Expects TreeViewDU of fieldName
                set: function (view) {
                    // When setting a view:
                    // - Not necessary to commit node
                    // - Not necessary to persist cache
                    // Just keeping a reference to the view in this.viewsChanged ensures consistency
                    this.viewsChanged.set(index, view);
                },
            });
        }
        // Should never happen
        else {
            /* istanbul ignore next - unreachable code */
            throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
    }
    // Change class name
    Object.defineProperty(CustomContainerTreeViewDU, "name", { value: type.typeName, writable: false });
    return CustomContainerTreeViewDU;
}
exports.getContainerTreeViewDUClass = getContainerTreeViewDUClass;
//# sourceMappingURL=container.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\container.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\containerNodeStruct.js", {"../type/composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\abstract.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5CcontainerNodeStruct.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContainerTreeViewDUClass = void 0;
const composite_1 = require("../type/composite");
const abstract_1 = require("./abstract");
/* eslint-disable @typescript-eslint/member-ordering */
class ContainerTreeViewDU extends abstract_1.TreeViewDU {
    constructor(type, node) {
        super();
        this.type = type;
        this.valueChanged = null;
        this._rootNode = node;
    }
    get node() {
        return this._rootNode;
    }
    get cache() {
        return;
    }
    commit() {
        if (this.valueChanged === null) {
            return;
        }
        const value = this.valueChanged;
        this.valueChanged = null;
        this._rootNode = this.type.value_toTree(value);
    }
    clearCache() {
        this.valueChanged = null;
    }
}
function getContainerTreeViewDUClass(type) {
    class CustomContainerTreeViewDU extends ContainerTreeViewDU {
    }
    // Dynamically define prototype methods
    for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        // If the field type is basic, the value to get and set will be the actual 'struct' value (i.e. a JS number).
        // The view must use the tree_getFromNode() and tree_setToNode() methods to persist the struct data to the node,
        // and use the cached views array to store the new node.
        if (fieldType.isBasic) {
            Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // TODO: Review the memory cost of this closures
                get: function () {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return (this.valueChanged || this._rootNode.value)[fieldName];
                },
                set: function (value) {
                    if (this.valueChanged === null) {
                        this.valueChanged = this.type.clone(this._rootNode.value);
                    }
                    this.valueChanged[fieldName] = value;
                },
            });
        }
        // If the field type is composite, the value to get and set will be another TreeView. The parent TreeView must
        // cache the view itself to retain the caches of the child view. To set a value the view must return a node to
        // set it to the parent tree in the field gindex.
        else if (composite_1.isCompositeType(fieldType)) {
            Object.defineProperty(CustomContainerTreeViewDU.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // Returns TreeViewDU of fieldName
                get: function () {
                    const value = this.valueChanged || this._rootNode.value;
                    return fieldType.toViewDU(value[fieldName]);
                },
                // Expects TreeViewDU of fieldName
                set: function (view) {
                    if (this.valueChanged === null) {
                        this.valueChanged = this.type.clone(this._rootNode.value);
                    }
                    const value = fieldType.toValueFromViewDU(view);
                    this.valueChanged[fieldName] = value;
                },
            });
        }
        // Should never happen
        else {
            /* istanbul ignore next - unreachable code */
            throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
    }
    // Change class name
    Object.defineProperty(CustomContainerTreeViewDU, "name", { value: type.typeName, writable: false });
    return CustomContainerTreeViewDU;
}
exports.getContainerTreeViewDUClass = getContainerTreeViewDUClass;
//# sourceMappingURL=containerNodeStruct.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\containerNodeStruct.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\listBasic.js", {"./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayBasic.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5ClistBasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListBasicTreeViewDU = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const arrayBasic_1 = require("./arrayBasic");
class ListBasicTreeViewDU extends arrayBasic_1.ArrayBasicTreeViewDU {
    constructor(type, _rootNode, cache) {
        super(type, _rootNode, cache);
        this.type = type;
        this._rootNode = _rootNode;
    }
    /**
     * Adds one value element at the end of the array and adds 1 to the un-commited ViewDU length
     */
    push(value) {
        if (this._length >= this.type.limit) {
            throw Error("Error pushing over limit");
        }
        // Mutate length before .set()
        this.dirtyLength = true;
        const index = this._length++;
        // If in new node..
        if (index % this.type.itemsPerChunk === 0) {
            // Set a zero node to the nodes array to avoid a navigation downwards in .set()
            const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
            this.nodes[chunkIndex] = persistent_merkle_tree_1.zeroNode(0);
        }
        this.set(index, value);
    }
}
exports.ListBasicTreeViewDU = ListBasicTreeViewDU;
//# sourceMappingURL=listBasic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\listBasic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\listComposite.js", {"./arrayComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\arrayComposite.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5CviewDU%5ClistComposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListCompositeTreeViewDU = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const arrayComposite_1 = require("./arrayComposite");
class ListCompositeTreeViewDU extends arrayComposite_1.ArrayCompositeTreeViewDU {
    constructor(type, _rootNode, cache) {
        super(type, _rootNode, cache);
        this.type = type;
        this._rootNode = _rootNode;
    }
    /**
     * Adds one value element at the end of the array and adds 1 to the un-commited ViewDU length
     */
    push(view) {
        if (this._length >= this.type.limit) {
            throw Error("Error pushing over limit");
        }
        this.dirtyLength = true;
        const index = this._length++;
        // No need for pre-initialization like in ListBasic.push since ArrayCompositeTreeViewDU.set() doesn't do a get node
        this.set(index, view);
    }
    /**
     * Returns a new ListCompositeTreeViewDU instance with the values from 0 to `index`.
     * The new list is equivalent to (pseudo-code):
     *
     * ```ts
     * const nodes = getChunkNodes()
     * return listFromChunkNodes(nodes.slice(0, index + 1))
     * ```
     *
     * To achieve it, rebinds the underlying tree zero-ing all nodes right of `index`.
     *
     * Note: Using index = -1, returns an empty list of length 0.
     */
    sliceTo(index) {
        // Commit before getting rootNode to ensure all pending data is in the rootNode
        this.commit();
        const rootNode = this._rootNode;
        const length = this.type.tree_getLength(rootNode);
        // All nodes beyond length are already zero
        // Array of length 2: [X,X,0,0], for index >= 1 no action needed
        if (index >= length - 1) {
            return this;
        }
        // Since this is a List, do the treeZeroAfterIndex operation on the chunks tree
        const chunksNode = this.type.tree_getChunksNode(rootNode);
        const newChunksNode = persistent_merkle_tree_1.treeZeroAfterIndex(chunksNode, this.type.chunkDepth, index);
        // Must set new length and commit to tree to restore the same tree at that index
        const newLength = index + 1;
        const newRootNode = this.type.tree_setChunksNode(rootNode, newChunksNode, newLength);
        return this.type.getViewDU(newRootNode);
    }
}
exports.ListCompositeTreeViewDU = ListCompositeTreeViewDU;
//# sourceMappingURL=listComposite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\viewDU\\listComposite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js", {"@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5Cabstract.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeView = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
/**
 * A Tree View is a wrapper around a type and an SSZ Tree that contains:
 * - data merkleized
 * - a hook to its parent Tree to propagate changes upwards
 *
 * **View**
 * - Best for simple usage where performance is NOT important
 * - Applies changes immediately
 * - Has reference to parent tree
 * - Does NOT have caches for fast get / set ops
 */
class TreeView {
    /** Serialize view to binary data */
    serialize() {
        const output = new Uint8Array(this.type.tree_serializedSize(this.node));
        const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);
        this.type.tree_serializeToBytes({ uint8Array: output, dataView }, 0, this.node);
        return output;
    }
    /**
     * Merkleize view and compute its hashTreeRoot.
     *
     * See spec for definition of hashTreeRoot:
     * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization
     */
    hashTreeRoot() {
        return this.node.root;
    }
    /**
     * Create a Merkle multiproof on this view's data.
     * A `path` is an array of 'JSON' paths into the data
     * @example
     * ```ts
     * state.createProof([
     *   ["validators", 1234, "slashed"],
     *   ["genesisTime"]
     * ])
     * ```
     *
     * See spec for definition of merkle multiproofs:
     * https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs
     */
    createProof(paths) {
        return this.type.tree_createProof(this.node, paths);
    }
    /**
     * Transform the view into a value, from the current node instance.
     * For ViewDU returns the value of the committed data, so call .commit() before if there are pending changes.
     */
    toValue() {
        return this.type.tree_toValue(this.node);
    }
    /** Return a new Tree View instance referencing the same internal `Node`. Drops its existing `Tree` hook if any */
    clone() {
        return this.type.getView(new persistent_merkle_tree_1.Tree(this.node));
    }
}
exports.TreeView = TreeView;
//# sourceMappingURL=abstract.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayBasic.js", {"./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5CarrayBasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayBasicTreeView = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const abstract_1 = require("./abstract");
class ArrayBasicTreeView extends abstract_1.TreeView {
    constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
    }
    /**
     * Number of elements in the array. Equal to the Uint32 value of the Tree's length node
     */
    get length() {
        return this.type.tree_getLength(this.tree.rootNode);
    }
    get node() {
        return this.tree.rootNode;
    }
    /**
     * Get element at `index`. Returns the Basic element type value directly
     */
    get(index) {
        // First walk through the tree to get the root node for that index
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        const leafNode = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.type.elementType.tree_getFromPackedNode(leafNode, index);
    }
    /**
     * Set Basic element type `value` at `index`
     */
    set(index, value) {
        const length = this.length;
        if (index >= length) {
            throw Error(`Error setting index over length ${index} > ${length}`);
        }
        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);
        const leafNodePrev = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);
        // Create a new node to preserve immutability
        const leafNode = leafNodePrev.clone();
        this.type.elementType.tree_setToPackedNode(leafNode, index, value);
        // Commit immediately
        this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);
    }
    /**
     * Get all values of this array as Basic element type values, from index zero to `this.length - 1`
     */
    getAll() {
        const length = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const chunkCount = Math.ceil(length / this.type.itemsPerChunk);
        const leafNodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);
        const values = new Array(length);
        const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below
        const lenFullNodes = Math.floor(length / itemsPerChunk);
        const remainder = length % itemsPerChunk;
        for (let n = 0; n < lenFullNodes; n++) {
            const leafNode = leafNodes[n];
            // TODO: Implement add a fast bulk packed element reader in the elementType
            // ```
            // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;
            // ```
            // if performance here is a problem
            for (let i = 0; i < itemsPerChunk; i++) {
                values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
            }
        }
        if (remainder > 0) {
            const leafNode = leafNodes[lenFullNodes];
            for (let i = 0; i < remainder; i++) {
                values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);
            }
        }
        return values;
    }
}
exports.ArrayBasicTreeView = ArrayBasicTreeView;
//# sourceMappingURL=arrayBasic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayBasic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayComposite.js", {"./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5CarrayComposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayCompositeTreeView = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const abstract_1 = require("./abstract");
class ArrayCompositeTreeView extends abstract_1.TreeView {
    constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
    }
    /**
     * Number of elements in the array. Equal to the Uint32 value of the Tree's length node
     */
    get length() {
        return this.type.tree_getLength(this.tree.rootNode);
    }
    /**
     * Returns the View's Tree rootNode
     */
    get node() {
        return this.tree.rootNode;
    }
    /**
     * Get element at `index`. Returns a view of the Composite element type
     */
    get(index) {
        // TODO: Optimize without bitstring
        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
        const subtree = this.tree.getSubtree(gindex);
        return this.type.elementType.getView(subtree);
    }
    /**
     * Get element at `index`. Returns a view of the Composite element type.
     * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.
     */
    getReadonly(index) {
        // TODO: Optimize without bitstring
        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
        // tree.getSubtree but without the hook
        const subtree = new persistent_merkle_tree_1.Tree(this.tree.getNode(gindex));
        return this.type.elementType.getView(subtree);
    }
    /**
     * Set Composite element type `view` at `index`
     */
    set(index, view) {
        const length = this.length;
        if (index >= length) {
            throw Error(`Error setting index over length ${index} > ${length}`);
        }
        const node = this.type.elementType.commitView(view);
        this.tree.setNodeAtDepth(this.type.depth, index, node);
    }
    /**
     * Returns an array of views of all elements in the array, from index zero to `this.length - 1`.
     * The returned views don't have a parent hook to this View's Tree, so changes in the returned views won't be
     * propagated upwards. To get linked element Views use `this.get()`
     */
    getAllReadonly() {
        const length = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);
        const views = new Array(length);
        for (let i = 0; i < length; i++) {
            // TODO: Optimize
            views[i] = this.type.elementType.getView(new persistent_merkle_tree_1.Tree(nodes[i]));
        }
        return views;
    }
    /**
     * Returns an array of values of all elements in the array, from index zero to `this.length - 1`.
     * The returned values are not Views so any changes won't be propagated upwards.
     * To get linked element Views use `this.get()`
     */
    getAllReadonlyValues() {
        const length = this.length;
        const chunksNode = this.type.tree_getChunksNode(this.node);
        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);
        const values = new Array(length);
        for (let i = 0; i < length; i++) {
            values[i] = this.type.elementType.tree_toValue(nodes[i]);
        }
        return values;
    }
}
exports.ArrayCompositeTreeView = ArrayCompositeTreeView;
//# sourceMappingURL=arrayComposite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayComposite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\bitArray.js", {"./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5CbitArray.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitArrayTreeView = void 0;
const abstract_1 = require("./abstract");
/**
 * Thin wrapper around BitArray to upstream changes to `tree` on every `this.set()`
 */
class BitArrayTreeView extends abstract_1.TreeView {
    constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
        this.bitArray = type.tree_toValue(tree.rootNode);
    }
    get node() {
        return this.tree.rootNode;
    }
    // Wrapped API from BitArray
    /** @see BitArray.uint8Array */
    get uint8Array() {
        return this.bitArray.uint8Array;
    }
    /** @see BitArray.bitLen */
    get bitLen() {
        return this.bitArray.bitLen;
    }
    /** @see BitArray.get */
    get(bitIndex) {
        return this.bitArray.get(bitIndex);
    }
    /** @see BitArray.set */
    set(bitIndex, bit) {
        this.bitArray.set(bitIndex, bit);
        // Upstream changes
        this.tree.rootNode = this.type.value_toTree(this.bitArray);
    }
    /** @see BitArray.mergeOrWith */
    mergeOrWith(bitArray2) {
        this.bitArray.mergeOrWith(bitArray2);
    }
    /** @see BitArray.intersectValues */
    intersectValues(values) {
        return this.bitArray.intersectValues(values);
    }
    /** @see BitArray.getTrueBitIndexes */
    getTrueBitIndexes() {
        return this.bitArray.getTrueBitIndexes();
    }
    /** @see BitArray.getSingleTrueBit */
    getSingleTrueBit() {
        return this.bitArray.getSingleTrueBit();
    }
    /** @see BitArray.toBoolArray */
    toBoolArray() {
        return this.bitArray.toBoolArray();
    }
}
exports.BitArrayTreeView = BitArrayTreeView;
//# sourceMappingURL=bitArray.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\bitArray.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\container.js", {"../type/basic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\basic.js","../type/composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5Ccontainer.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContainerTreeViewClass = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const basic_1 = require("../type/basic");
const composite_1 = require("../type/composite");
const abstract_1 = require("./abstract");
/**
 * Intented usage:
 *
 * - Get initial BeaconState from disk.
 * - Before applying next block, switch to mutable
 * - Get some field, create a view in mutable mode
 * - Do modifications of the state in the state transition function
 * - When done, commit and apply new root node once to og BeaconState
 * - However, keep all the caches and transfer them to the new BeaconState
 *
 * Questions:
 * - Can the child views created in mutable mode switch to not mutable? If so, it seems that it needs to recursively
 *   iterate the entire data structure and views
 *
 */
class ContainerTreeView extends abstract_1.TreeView {
    constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
    }
    get node() {
        return this.tree.rootNode;
    }
}
function getContainerTreeViewClass(type) {
    class CustomContainerTreeView extends ContainerTreeView {
    }
    // Dynamically define prototype methods
    for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        // If the field type is basic, the value to get and set will be the actual 'struct' value (i.e. a JS number).
        // The view must use the tree_getFromNode() and tree_setToNode() methods to persist the struct data to the node,
        // and use the cached views array to store the new node.
        if (basic_1.isBasicType(fieldType)) {
            Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // TODO: Review the memory cost of this closures
                get: function () {
                    const leafNode = persistent_merkle_tree_1.getNodeAtDepth(this.node, this.type.depth, index);
                    return fieldType.tree_getFromNode(leafNode);
                },
                set: function (value) {
                    const leafNodePrev = persistent_merkle_tree_1.getNodeAtDepth(this.node, this.type.depth, index);
                    const leafNode = leafNodePrev.clone();
                    fieldType.tree_setToNode(leafNode, value);
                    this.tree.setNodeAtDepth(this.type.depth, index, leafNode);
                },
            });
        }
        // If the field type is composite, the value to get and set will be another TreeView. The parent TreeView must
        // cache the view itself to retain the caches of the child view. To set a value the view must return a node to
        // set it to the parent tree in the field gindex.
        else if (composite_1.isCompositeType(fieldType)) {
            Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // Returns TreeView of fieldName
                get: function () {
                    const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);
                    return fieldType.getView(this.tree.getSubtree(gindex));
                },
                // Expects TreeView of fieldName
                set: function (value) {
                    const node = fieldType.commitView(value);
                    this.tree.setNodeAtDepth(this.type.depth, index, node);
                },
            });
        }
        // Should never happen
        else {
            /* istanbul ignore next - unreachable code */
            throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
    }
    // Change class name
    Object.defineProperty(CustomContainerTreeView, "name", { value: type.typeName, writable: false });
    return CustomContainerTreeView;
}
exports.getContainerTreeViewClass = getContainerTreeViewClass;
//# sourceMappingURL=container.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\container.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\containerNodeStruct.js", {"../branchNodeStruct":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\branchNodeStruct.js","../type/composite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\type\\composite.js","./abstract":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\abstract.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5CcontainerNodeStruct.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContainerTreeViewClass = void 0;
const composite_1 = require("../type/composite");
const branchNodeStruct_1 = require("../branchNodeStruct");
const abstract_1 = require("./abstract");
/* eslint-disable @typescript-eslint/member-ordering */
/**
 * Intented usage:
 *
 * - Get initial BeaconState from disk.
 * - Before applying next block, switch to mutable
 * - Get some field, create a view in mutable mode
 * - Do modifications of the state in the state transition function
 * - When done, commit and apply new root node once to og BeaconState
 * - However, keep all the caches and transfer them to the new BeaconState
 *
 * Questions:
 * - Can the child views created in mutable mode switch to not mutable? If so, it seems that it needs to recursively
 *   iterate the entire data structure and views
 *
 */
class ContainerTreeView extends abstract_1.TreeView {
    constructor(type, tree) {
        super();
        this.type = type;
        this.tree = tree;
    }
    get node() {
        return this.tree.rootNode;
    }
}
function getContainerTreeViewClass(type) {
    class CustomContainerTreeView extends ContainerTreeView {
    }
    // Dynamically define prototype methods
    for (let index = 0; index < type.fieldsEntries.length; index++) {
        const { fieldName, fieldType } = type.fieldsEntries[index];
        // If the field type is basic, the value to get and set will be the actual 'struct' value (i.e. a JS number).
        // The view must use the tree_getFromNode() and tree_setToNode() methods to persist the struct data to the node,
        // and use the cached views array to store the new node.
        if (fieldType.isBasic) {
            Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // TODO: Review the memory cost of this closures
                get: function () {
                    return this.tree.rootNode.value[fieldName];
                },
                set: function (value) {
                    const node = this.tree.rootNode;
                    const newNodeValue = this.type.clone(node.value);
                    // TODO: Should this check for valid field name? Benchmark the cost
                    newNodeValue[fieldName] = value;
                    this.tree.rootNode = new branchNodeStruct_1.BranchNodeStruct(node["valueToNode"], newNodeValue);
                },
            });
        }
        // If the field type is composite, the value to get and set will be another TreeView. The parent TreeView must
        // cache the view itself to retain the caches of the child view. To set a value the view must return a node to
        // set it to the parent tree in the field gindex.
        else if (composite_1.isCompositeType(fieldType)) {
            Object.defineProperty(CustomContainerTreeView.prototype, fieldName, {
                configurable: false,
                enumerable: true,
                // Returns TreeView of fieldName
                get: function () {
                    const { value } = this.tree.rootNode;
                    return fieldType.toView(value[fieldName]);
                },
                // Expects TreeView of fieldName
                set: function (view) {
                    const node = this.tree.rootNode;
                    const newNodeValue = this.type.clone(node.value);
                    // TODO: Should this check for valid field name? Benchmark the cost
                    newNodeValue[fieldName] = fieldType.toValueFromView(view);
                    this.tree.rootNode = new branchNodeStruct_1.BranchNodeStruct(node["valueToNode"], newNodeValue);
                },
            });
        }
        // Should never happen
        else {
            /* istanbul ignore next - unreachable code */
            throw Error(`Unknown fieldType ${fieldType.typeName} for fieldName ${fieldName}`);
        }
    }
    // Change class name
    Object.defineProperty(CustomContainerTreeView, "name", { value: type.typeName, writable: false });
    return CustomContainerTreeView;
}
exports.getContainerTreeViewClass = getContainerTreeViewClass;
//# sourceMappingURL=containerNodeStruct.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\containerNodeStruct.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\listBasic.js", {"./arrayBasic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayBasic.js","@chainsafe/persistent-merkle-tree":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\persistent-merkle-tree\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5ClistBasic.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListBasicTreeView = void 0;
const persistent_merkle_tree_1 = require("@chainsafe/persistent-merkle-tree");
const arrayBasic_1 = require("./arrayBasic");
class ListBasicTreeView extends arrayBasic_1.ArrayBasicTreeView {
    constructor(type, tree) {
        super(type, tree);
        this.type = type;
        this.tree = tree;
    }
    /**
     * Adds one value element at the end of the array and adds 1 to the current Tree length.
     */
    push(value) {
        const length = this.length;
        if (length >= this.type.limit) {
            throw Error("Error pushing over limit");
        }
        this.type.tree_setLength(this.tree, length + 1);
        // If in new node..
        if (length % this.type.itemsPerChunk === 0) {
            // TODO: Optimize: This `inNewNode` could be ommitted but it would cause a full navigation in .set()
            // Benchmark the cost of that navigation vs the extra math here
            // TODO: Optimize: prevent double initialization
            const leafNode = persistent_merkle_tree_1.LeafNode.fromZero();
            this.type.elementType.tree_setToPackedNode(leafNode, length, value);
            // Commit immediately
            const chunkIndex = Math.floor(length / this.type.itemsPerChunk);
            this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);
        }
        else {
            // Re-use .set() since no new node is added
            this.set(length, value);
        }
    }
}
exports.ListBasicTreeView = ListBasicTreeView;
//# sourceMappingURL=listBasic.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\listBasic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\listComposite.js", {"./arrayComposite":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\arrayComposite.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@chainsafe%5Cssz%5Clib%5Cview%5ClistComposite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListCompositeTreeView = void 0;
const arrayComposite_1 = require("./arrayComposite");
class ListCompositeTreeView extends arrayComposite_1.ArrayCompositeTreeView {
    constructor(type, tree) {
        super(type, tree);
        this.type = type;
        this.tree = tree;
    }
    /**
     * Adds one view element at the end of the array and adds 1 to the current Tree length.
     */
    push(view) {
        const length = this.length;
        if (length >= this.type.limit) {
            throw Error("Error pushing over limit");
        }
        this.type.tree_setLength(this.tree, length + 1);
        // No need for pre-initialization like in ListBasic.push since ArrayCompositeTreeView.set() doesn't do a get node
        this.set(length, view);
    }
}
exports.ListCompositeTreeView = ListCompositeTreeView;
//# sourceMappingURL=listComposite.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@chainsafe/ssz",file:"node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\view\\listComposite.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\goerli.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Cgoerli.json
      return function (require, module, exports) {
module.exports={
    "name": "goerli",
    "chainId": 5,
    "networkId": 5,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "poa",
        "algorithm": "clique",
        "clique": {
            "period": 15,
            "epoch": 30000
        }
    },
    "comment": "Cross-client PoA test network",
    "url": "https://github.com/goerli/testnet",
    "genesis": {
        "timestamp": "0x5c51a607",
        "gasLimit": 10485760,
        "difficulty": 1,
        "nonce": "0x0000000000000000",
        "extraData": "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "homestead",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "tangerineWhistle",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "spuriousDragon",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "byzantium",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "constantinople",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "petersburg",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "istanbul",
            "block": 1561651,
            "forkHash": "0xc25efa5c"
        },
        {
            "name": "berlin",
            "block": 4460644,
            "forkHash": "0x757a1c47"
        },
        {
            "name": "london",
            "block": 5062605,
            "forkHash": "0xb8c6299d"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
            "name": "merge",
            "ttd": "10790000",
            "block": 7382819,
            "forkHash": "0xb8c6299d"
        },
        {
            "name": "mergeForkIdTransition",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "forkHash": null
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "51.141.78.53",
            "port": 30303,
            "id": "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
            "location": "",
            "comment": "Upstream bootnode 1"
        },
        {
            "ip": "13.93.54.137",
            "port": 30303,
            "id": "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
            "location": "",
            "comment": "Upstream bootnode 2"
        },
        {
            "ip": "94.237.54.114",
            "port": 30313,
            "id": "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
            "location": "",
            "comment": "Upstream bootnode 3"
        },
        {
            "ip": "18.218.250.66",
            "port": 30313,
            "id": "b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",
            "location": "",
            "comment": "Upstream bootnode 4"
        },
        {
            "ip": "3.11.147.67",
            "port": 30303,
            "id": "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
            "location": "",
            "comment": "Ethereum Foundation bootnode"
        },
        {
            "ip": "51.15.116.226",
            "port": 30303,
            "id": "a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",
            "location": "",
            "comment": "Goerli Initiative bootnode"
        },
        {
            "ip": "51.15.119.157",
            "port": 30303,
            "id": "807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",
            "location": "",
            "comment": "Goerli Initiative bootnode"
        },
        {
            "ip": "51.15.119.157",
            "port": 40303,
            "id": "a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",
            "location": "",
            "comment": "Goerli Initiative bootnode"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\goerli.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\mainnet.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Cmainnet.json
      return function (require, module, exports) {
module.exports={
    "name": "mainnet",
    "chainId": 1,
    "networkId": 1,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "pow",
        "algorithm": "ethash",
        "ethash": {}
    },
    "comment": "The Ethereum main chain",
    "url": "https://ethstats.net/",
    "genesis": {
        "gasLimit": 5000,
        "difficulty": 17179869184,
        "nonce": "0x0000000000000042",
        "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0xfc64ec04"
        },
        {
            "name": "homestead",
            "block": 1150000,
            "forkHash": "0x97c2c34c"
        },
        {
            "name": "dao",
            "block": 1920000,
            "forkHash": "0x91d1f948"
        },
        {
            "name": "tangerineWhistle",
            "block": 2463000,
            "forkHash": "0x7a64da13"
        },
        {
            "name": "spuriousDragon",
            "block": 2675000,
            "forkHash": "0x3edd5b10"
        },
        {
            "name": "byzantium",
            "block": 4370000,
            "forkHash": "0xa00bc324"
        },
        {
            "name": "constantinople",
            "block": 7280000,
            "forkHash": "0x668db0af"
        },
        {
            "name": "petersburg",
            "block": 7280000,
            "forkHash": "0x668db0af"
        },
        {
            "name": "istanbul",
            "block": 9069000,
            "forkHash": "0x879d6e30"
        },
        {
            "name": "muirGlacier",
            "block": 9200000,
            "forkHash": "0xe029e991"
        },
        {
            "name": "berlin",
            "block": 12244000,
            "forkHash": "0x0eb440f6"
        },
        {
            "name": "london",
            "block": 12965000,
            "forkHash": "0xb715077d"
        },
        {
            "name": "arrowGlacier",
            "block": 13773000,
            "forkHash": "0x20c327fc"
        },
        {
            "name": "grayGlacier",
            "block": 15050000,
            "forkHash": "0xf0afd0e3"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
            "name": "merge",
            "ttd": "58750000000000000000000",
            "block": 15537394,
            "forkHash": "0xf0afd0e3"
        },
        {
            "name": "mergeForkIdTransition",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "forkHash": null
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "18.138.108.67",
            "port": 30303,
            "id": "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
            "location": "ap-southeast-1-001",
            "comment": "bootnode-aws-ap-southeast-1-001"
        },
        {
            "ip": "3.209.45.79",
            "port": 30303,
            "id": "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
            "location": "us-east-1-001",
            "comment": "bootnode-aws-us-east-1-001"
        },
        {
            "ip": "34.255.23.113",
            "port": 30303,
            "id": "ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758",
            "location": "eu-west-1-001",
            "comment": "bootnode-aws-eu-west-1-001"
        },
        {
            "ip": "35.158.244.151",
            "port": 30303,
            "id": "279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8",
            "location": "eu-central-1-001",
            "comment": "bootnode-aws-eu-central-1-001"
        },
        {
            "ip": "52.187.207.27",
            "port": 30303,
            "id": "8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a",
            "location": "australiaeast-001",
            "comment": "bootnode-azure-australiaeast-001"
        },
        {
            "ip": "191.234.162.198",
            "port": 30303,
            "id": "103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1",
            "location": "brazilsouth-001",
            "comment": "bootnode-azure-brazilsouth-001"
        },
        {
            "ip": "52.231.165.108",
            "port": 30303,
            "id": "715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8",
            "location": "koreasouth-001",
            "comment": "bootnode-azure-koreasouth-001"
        },
        {
            "ip": "104.42.217.25",
            "port": 30303,
            "id": "5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f",
            "location": "westus-001",
            "comment": "bootnode-azure-westus-001"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\mainnet.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\rinkeby.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Crinkeby.json
      return function (require, module, exports) {
module.exports={
    "name": "rinkeby",
    "chainId": 4,
    "networkId": 4,
    "defaultHardfork": "london",
    "consensus": {
        "type": "poa",
        "algorithm": "clique",
        "clique": {
            "period": 15,
            "epoch": 30000
        }
    },
    "comment": "PoA test network",
    "url": "https://www.rinkeby.io",
    "genesis": {
        "timestamp": "0x58ee40ba",
        "gasLimit": 4700000,
        "difficulty": 1,
        "nonce": "0x0000000000000000",
        "extraData": "0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0x3b8e0691"
        },
        {
            "name": "homestead",
            "block": 1,
            "forkHash": "0x60949295"
        },
        {
            "name": "tangerineWhistle",
            "block": 2,
            "forkHash": "0x8bde40dd"
        },
        {
            "name": "spuriousDragon",
            "block": 3,
            "forkHash": "0xcb3a64bb"
        },
        {
            "name": "byzantium",
            "block": 1035301,
            "forkHash": "0x8d748b57"
        },
        {
            "name": "constantinople",
            "block": 3660663,
            "forkHash": "0xe49cab14"
        },
        {
            "name": "petersburg",
            "block": 4321234,
            "forkHash": "0xafec6b27"
        },
        {
            "name": "istanbul",
            "block": 5435345,
            "forkHash": "0xcbdb8838"
        },
        {
            "name": "berlin",
            "block": 8290928,
            "forkHash": "0x6910c8bd"
        },
        {
            "name": "london",
            "block": 8897988,
            "forkHash": "0x8e29f2f3"
        },
        {
            "name": "merge",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "forkHash": null
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "52.169.42.101",
            "port": 30303,
            "id": "a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",
            "location": "",
            "comment": "IE"
        },
        {
            "ip": "52.3.158.184",
            "port": 30303,
            "id": "343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",
            "location": "",
            "comment": "INFURA"
        },
        {
            "ip": "159.89.28.211",
            "port": 30303,
            "id": "b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",
            "location": "",
            "comment": "AKASHA"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\rinkeby.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\ropsten.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Cropsten.json
      return function (require, module, exports) {
module.exports={
    "name": "ropsten",
    "chainId": 3,
    "networkId": 3,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "pow",
        "algorithm": "ethash",
        "ethash": {}
    },
    "comment": "PoW test network",
    "url": "https://github.com/ethereum/ropsten",
    "genesis": {
        "gasLimit": 16777216,
        "difficulty": 1048576,
        "nonce": "0x0000000000000042",
        "extraData": "0x3535353535353535353535353535353535353535353535353535353535353535"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0x30c7ddbc"
        },
        {
            "name": "homestead",
            "block": 0,
            "forkHash": "0x30c7ddbc"
        },
        {
            "name": "tangerineWhistle",
            "block": 0,
            "forkHash": "0x30c7ddbc"
        },
        {
            "name": "spuriousDragon",
            "block": 10,
            "forkHash": "0x63760190"
        },
        {
            "name": "byzantium",
            "block": 1700000,
            "forkHash": "0x3ea159c7"
        },
        {
            "name": "constantinople",
            "block": 4230000,
            "forkHash": "0x97b544f3"
        },
        {
            "name": "petersburg",
            "block": 4939394,
            "forkHash": "0xd6e2149b"
        },
        {
            "name": "istanbul",
            "block": 6485846,
            "forkHash": "0x4bc66396"
        },
        {
            "name": "muirGlacier",
            "block": 7117117,
            "forkHash": "0x6727ef90"
        },
        {
            "name": "berlin",
            "block": 9812189,
            "forkHash": "0xa157d377"
        },
        {
            "name": "london",
            "block": 10499401,
            "forkHash": "0x7119b6b3"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
            "name": "merge",
            "ttd": "50000000000000000",
            "block": null,
            "forkHash": "0x7119b6b3"
        },
        {
            "name": "mergeForkIdTransition",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "forkHash": null
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "52.176.7.10",
            "port": 30303,
            "id": "30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",
            "location": "",
            "comment": "US-Azure geth"
        },
        {
            "ip": "52.176.100.77",
            "port": 30303,
            "id": "865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",
            "location": "",
            "comment": "US-Azure parity"
        },
        {
            "ip": "52.232.243.152",
            "port": 30303,
            "id": "6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",
            "location": "",
            "comment": "Parity"
        },
        {
            "ip": "192.81.208.223",
            "port": 30303,
            "id": "94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",
            "location": "",
            "comment": "@gpip"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\ropsten.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\sepolia.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Csepolia.json
      return function (require, module, exports) {
module.exports={
    "name": "sepolia",
    "chainId": 11155111,
    "networkId": 11155111,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "pow",
        "algorithm": "ethash",
        "ethash": {}
    },
    "comment": "PoW test network to replace Ropsten",
    "url": "https://github.com/ethereum/go-ethereum/pull/23730",
    "genesis": {
        "timestamp": "0x6159af19",
        "gasLimit": 30000000,
        "difficulty": 131072,
        "nonce": "0x0000000000000000",
        "extraData": "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "homestead",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "tangerineWhistle",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "spuriousDragon",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "byzantium",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "constantinople",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "petersburg",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "istanbul",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "muirGlacier",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "berlin",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "london",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
            "name": "merge",
            "ttd": "17000000000000000",
            "block": 1450409,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "mergeForkIdTransition",
            "block": 1735371,
            "forkHash": "0xb96cbd13"
        },
        {
            "name": "shanghai",
            "block": null,
            "timestamp": "1677557088",
            "forkHash": "0xf7f9bc08"
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "18.168.182.86",
            "port": 30303,
            "id": "9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",
            "location": "",
            "comment": "geth"
        },
        {
            "ip": "52.14.151.177",
            "port": 30303,
            "id": "ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",
            "location": "",
            "comment": "besu"
        },
        {
            "ip": "165.22.196.173",
            "port": 30303,
            "id": "ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",
            "location": "",
            "comment": "EF"
        },
        {
            "ip": "65.108.95.67",
            "port": 30303,
            "id": "075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",
            "location": "",
            "comment": "lodestar"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\sepolia.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\common.js", {"./chains/goerli.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\goerli.json","./chains/mainnet.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\mainnet.json","./chains/rinkeby.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\rinkeby.json","./chains/ropsten.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\ropsten.json","./chains/sepolia.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\chains\\sepolia.json","./eips":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\index.js","./enums":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\enums.js","./hardforks":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\index.js","./utils":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","crc-32":"F:\\metamask-extension\\node_modules\\crc-32\\crc32.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ccommon.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Common = void 0;
const util_1 = require("@ethereumjs/util");
const crc_32_1 = require("crc-32");
const events_1 = require("events");
const goerli = require("./chains/goerli.json");
const mainnet = require("./chains/mainnet.json");
const rinkeby = require("./chains/rinkeby.json");
const ropsten = require("./chains/ropsten.json");
const sepolia = require("./chains/sepolia.json");
const eips_1 = require("./eips");
const enums_1 = require("./enums");
const hardforks_1 = require("./hardforks");
const utils_1 = require("./utils");
/**
 * Common class to access chain and hardfork parameters and to provide
 * a unified and shared view on the network and hardfork state.
 *
 * Use the {@link Common.custom} static constructor for creating simple
 * custom chain {@link Common} objects (more complete custom chain setups
 * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).
 */
class Common extends events_1.EventEmitter {
    constructor(opts) {
        super();
        this._eips = [];
        this._customChains = opts.customChains ?? [];
        this._chainParams = this.setChain(opts.chain);
        this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;
        // Assign hardfork changes in the sequence of the applied hardforks
        this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
            hf.name,
            hardforks_1.hardforks[hf.name],
        ]);
        this._hardfork = this.DEFAULT_HARDFORK;
        if (opts.hardfork !== undefined) {
            this.setHardfork(opts.hardfork);
        }
        if (opts.eips) {
            this.setEIPs(opts.eips);
        }
    }
    /**
     * Creates a {@link Common} object for a custom chain, based on a standard one.
     *
     * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden
     * in a provided {@link chainParamsOrName} dictionary. Some usage example:
     *
     * ```javascript
     * Common.custom({chainId: 123})
     * ```
     *
     * There are also selected supported custom chains which can be initialized by using one of the
     * {@link CustomChains} for {@link chainParamsOrName}, e.g.:
     *
     * ```javascript
     * Common.custom(CustomChains.MaticMumbai)
     * ```
     *
     * Note that these supported custom chains only provide some base parameters (usually the chain and
     * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with
     * the `@ethereumjs/tx` library to a Layer-2 chain).
     *
     * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain
     * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others
     */
    static custom(chainParamsOrName, opts = {}) {
        const baseChain = opts.baseChain ?? 'mainnet';
        const standardChainParams = { ...Common._getChainParams(baseChain) };
        standardChainParams['name'] = 'custom-chain';
        if (typeof chainParamsOrName !== 'string') {
            return new Common({
                chain: {
                    ...standardChainParams,
                    ...chainParamsOrName,
                },
                ...opts,
            });
        }
        else {
            if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {
                return Common.custom({
                    name: enums_1.CustomChain.PolygonMainnet,
                    chainId: 137,
                    networkId: 137,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {
                return Common.custom({
                    name: enums_1.CustomChain.PolygonMumbai,
                    chainId: 80001,
                    networkId: 80001,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {
                return Common.custom({
                    name: enums_1.CustomChain.ArbitrumRinkebyTestnet,
                    chainId: 421611,
                    networkId: 421611,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {
                return Common.custom({
                    name: enums_1.CustomChain.ArbitrumOne,
                    chainId: 42161,
                    networkId: 42161,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {
                return Common.custom({
                    name: enums_1.CustomChain.xDaiChain,
                    chainId: 100,
                    networkId: 100,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {
                return Common.custom({
                    name: enums_1.CustomChain.OptimisticKovan,
                    chainId: 69,
                    networkId: 69,
                }, 
                // Optimism has not implemented the London hardfork yet (targeting Q1.22)
                { hardfork: enums_1.Hardfork.Berlin, ...opts });
            }
            if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {
                return Common.custom({
                    name: enums_1.CustomChain.OptimisticEthereum,
                    chainId: 10,
                    networkId: 10,
                }, 
                // Optimism has not implemented the London hardfork yet (targeting Q1.22)
                { hardfork: enums_1.Hardfork.Berlin, ...opts });
            }
            throw new Error(`Custom chain ${chainParamsOrName} not supported`);
        }
    }
    /**
     * Static method to load and set common from a geth genesis json
     * @param genesisJson json of geth configuration
     * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance
     * @returns Common
     */
    static fromGethGenesis(genesisJson, { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }) {
        const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);
        const common = new Common({
            chain: genesisParams.name ?? 'custom',
            customChains: [genesisParams],
            eips,
            hardfork: hardfork ?? genesisParams.hardfork,
        });
        if (genesisHash !== undefined) {
            common.setForkHashes(genesisHash);
        }
        return common;
    }
    /**
     * Static method to determine if a {@link chainId} is supported as a standard chain
     * @param chainId bigint id (`1`) of a standard chain
     * @returns boolean
     */
    static isSupportedChainId(chainId) {
        const initializedChains = this._getInitializedChains();
        return Boolean(initializedChains['names'][chainId.toString()]);
    }
    static _getChainParams(chain, customChains) {
        const initializedChains = this._getInitializedChains(customChains);
        if (typeof chain === 'number' || typeof chain === 'bigint') {
            chain = chain.toString();
            if (initializedChains['names'][chain]) {
                const name = initializedChains['names'][chain];
                return initializedChains[name];
            }
            throw new Error(`Chain with ID ${chain} not supported`);
        }
        if (initializedChains[chain] !== undefined) {
            return initializedChains[chain];
        }
        throw new Error(`Chain with name ${chain} not supported`);
    }
    /**
     * Sets the chain
     * @param chain String ('mainnet') or Number (1) chain representation.
     *              Or, a Dictionary of chain parameters for a private network.
     * @returns The dictionary with parameters set as chain
     */
    setChain(chain) {
        if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {
            this._chainParams = Common._getChainParams(chain, this._customChains);
        }
        else if (typeof chain === 'object') {
            if (this._customChains.length > 0) {
                throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');
            }
            const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];
            for (const param of required) {
                if (!(param in chain)) {
                    throw new Error(`Missing required chain parameter: ${param}`);
                }
            }
            this._chainParams = chain;
        }
        else {
            throw new Error('Wrong input format');
        }
        for (const hf of this.hardforks()) {
            if (hf.block === undefined) {
                throw new Error(`Hardfork cannot have undefined block number`);
            }
        }
        return this._chainParams;
    }
    /**
     * Sets the hardfork to get params for
     * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum
     */
    setHardfork(hardfork) {
        let existing = false;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if (hfChanges[0] === hardfork) {
                if (this._hardfork !== hardfork) {
                    this._hardfork = hardfork;
                    this.emit('hardforkChanged', hardfork);
                }
                existing = true;
            }
        }
        if (!existing) {
            throw new Error(`Hardfork with name ${hardfork} not supported`);
        }
    }
    /**
     * Returns the hardfork based on the block number or an optional
     * total difficulty (Merge HF) provided.
     *
     * An optional TD takes precedence in case the corresponding HF block
     * is set to `null` or otherwise needs to match (if not an error
     * will be thrown).
     *
     * @param blockNumber
     * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)
     * @param timestamp: timestamp in seconds at which block was/is to be minted
     * @returns The name of the HF
     */
    getHardforkByBlockNumber(blockNumber, td, timestamp) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);
        timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number);
        // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)
        const hfs = this.hardforks().filter((hf) => hf.block !== null || (hf.ttd !== null && hf.ttd !== undefined) || hf.timestamp !== undefined);
        const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
        const doubleTTDHF = hfs
            .slice(mergeIndex + 1)
            .findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
        if (doubleTTDHF >= 0) {
            throw Error(`More than one merge hardforks found with ttd specified`);
        }
        // Find the first hardfork that has a block number greater than `blockNumber`
        // (skips the merge hardfork since it cannot have a block number specified).
        // If timestamp is not provided, it also skips timestamps hardforks to continue
        // discovering/checking number hardforks.
        let hfIndex = hfs.findIndex((hf) => (hf.block !== null && hf.block > blockNumber) ||
            (timestamp !== undefined && Number(hf.timestamp) > timestamp));
        if (hfIndex === -1) {
            // all hardforks apply, set hfIndex to the last one as that's the candidate
            hfIndex = hfs.length;
        }
        else if (hfIndex === 0) {
            // cannot have a case where a block number is before all applied hardforks
            // since the chain has to start with a hardfork
            throw Error('Must have at least one hardfork at block 0');
        }
        // If timestamp is not provided, we need to rollback to the last hf with block or ttd
        if (timestamp === undefined) {
            const stepBack = hfs
                .slice(0, hfIndex)
                .reverse()
                .findIndex((hf) => hf.block !== null || hf.ttd !== undefined);
            hfIndex = hfIndex - stepBack;
        }
        // Move hfIndex one back to arrive at candidate hardfork
        hfIndex = hfIndex - 1;
        // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number
        // hardforks. so it will now be needed to rollback
        if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {
            // We're on the merge hardfork.  Let's check the TTD
            if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {
                // Merge ttd greater than current td so we're on hardfork before merge
                hfIndex -= 1;
            }
        }
        else {
            if (mergeIndex >= 0 && td !== undefined && td !== null) {
                if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
                    throw Error('Maximum HF determined by total difficulty is lower than the block number HF');
                }
                else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
                    throw Error('HF determined by block number is lower than the minimum total difficulty HF');
                }
            }
        }
        const hfStartIndex = hfIndex;
        // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp
        // This won't anyway be the case with Merge hfs
        for (; hfIndex < hfs.length - 1; hfIndex++) {
            // break out if hfIndex + 1 is not scheduled at hfIndex
            if (hfs[hfIndex].block !== hfs[hfIndex + 1].block ||
                hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
                break;
            }
        }
        if (timestamp) {
            const minTimeStamp = hfs
                .slice(0, hfStartIndex)
                .reduce((acc, hf) => Math.max(Number(hf.timestamp ?? '0'), acc), 0);
            if (minTimeStamp > timestamp) {
                throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
            }
            const maxTimeStamp = hfs
                .slice(hfIndex + 1)
                .reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);
            if (maxTimeStamp < timestamp) {
                throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
            }
        }
        const hardfork = hfs[hfIndex];
        return hardfork.name;
    }
    /**
     * Sets a new hardfork based on the block number or an optional
     * total difficulty (Merge HF) provided.
     *
     * An optional TD takes precedence in case the corresponding HF block
     * is set to `null` or otherwise needs to match (if not an error
     * will be thrown).
     *
     * @param blockNumber
     * @param td
     * @param timestamp
     * @returns The name of the HF set
     */
    setHardforkByBlockNumber(blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        this.setHardfork(hardfork);
        return hardfork;
    }
    /**
     * Internal helper function, returns the params for the given hardfork for the chain set
     * @param hardfork Hardfork name
     * @returns Dictionary with hardfork params or null if hardfork not on chain
     */
    _getHardfork(hardfork) {
        const hfs = this.hardforks();
        for (const hf of hfs) {
            if (hf['name'] === hardfork)
                return hf;
        }
        return null;
    }
    /**
     * Sets the active EIPs
     * @param eips
     */
    setEIPs(eips = []) {
        for (const eip of eips) {
            if (!(eip in eips_1.EIPs)) {
                throw new Error(`${eip} not supported`);
            }
            const minHF = this.gteHardfork(eips_1.EIPs[eip]['minimumHardfork']);
            if (!minHF) {
                throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
            }
            if (eips_1.EIPs[eip].requiredEIPs !== undefined) {
                for (const elem of eips_1.EIPs[eip].requiredEIPs) {
                    if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
                        throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
                    }
                }
            }
        }
        this._eips = eips;
    }
    /**
     * Returns a parameter for the current chain setup
     *
     * If the parameter is present in an EIP, the EIP always takes precedence.
     * Otherwise the parameter if taken from the latest applied HF with
     * a change on the respective parameter.
     *
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @returns The value requested or `BigInt(0)` if not found
     */
    param(topic, name) {
        // TODO: consider the case that different active EIPs
        // can change the same parameter
        let value;
        for (const eip of this._eips) {
            value = this.paramByEIP(topic, name, eip);
            if (value !== undefined)
                return value;
        }
        return this.paramByHardfork(topic, name, this._hardfork);
    }
    /**
     * Returns the parameter corresponding to a hardfork
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param hardfork Hardfork name
     * @returns The value requested or `BigInt(0)` if not found
     */
    paramByHardfork(topic, name, hardfork) {
        let value = null;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            // EIP-referencing HF file (e.g. berlin.json)
            if ('eips' in hfChanges[1]) {
                const hfEIPs = hfChanges[1]['eips'];
                for (const eip of hfEIPs) {
                    const valueEIP = this.paramByEIP(topic, name, eip);
                    value = typeof valueEIP === 'bigint' ? valueEIP : value;
                }
                // Parameter-inlining HF file (e.g. istanbul.json)
            }
            else {
                if (hfChanges[1][topic] === undefined) {
                    throw new Error(`Topic ${topic} not defined`);
                }
                if (hfChanges[1][topic][name] !== undefined) {
                    value = hfChanges[1][topic][name].v;
                }
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return BigInt(value ?? 0);
    }
    /**
     * Returns a parameter corresponding to an EIP
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param eip Number of the EIP
     * @returns The value requested or `undefined` if not found
     */
    paramByEIP(topic, name, eip) {
        if (!(eip in eips_1.EIPs)) {
            throw new Error(`${eip} not supported`);
        }
        const eipParams = eips_1.EIPs[eip];
        if (!(topic in eipParams)) {
            throw new Error(`Topic ${topic} not defined`);
        }
        if (eipParams[topic][name] === undefined) {
            return undefined;
        }
        const value = eipParams[topic][name].v;
        return BigInt(value);
    }
    /**
     * Returns a parameter for the hardfork active on block number or
     * optional provided total difficulty (Merge HF)
     * @param topic Parameter topic
     * @param name Parameter name
     * @param blockNumber Block number
     * @param td Total difficulty
     *    * @returns The value requested or `BigInt(0)` if not found
     */
    paramByBlock(topic, name, blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        return this.paramByHardfork(topic, name, hardfork);
    }
    /**
     * Checks if an EIP is activated by either being included in the EIPs
     * manually passed in with the {@link CommonOpts.eips} or in a
     * hardfork currently being active
     *
     * Note: this method only works for EIPs being supported
     * by the {@link CommonOpts.eips} constructor option
     * @param eip
     */
    isActivatedEIP(eip) {
        if (this.eips().includes(eip)) {
            return true;
        }
        for (const hfChanges of this.HARDFORK_CHANGES) {
            const hf = hfChanges[1];
            if (this.gteHardfork(hf['name']) && 'eips' in hf) {
                if (hf['eips'].includes(eip)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Checks if set or provided hardfork is active on block number
     * @param hardfork Hardfork name or null (for HF set)
     * @param blockNumber
     * @returns True if HF is active on block number
     */
    hardforkIsActiveOnBlock(hardfork, blockNumber) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const hfBlock = this.hardforkBlock(hardfork);
        if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
            return true;
        }
        return false;
    }
    /**
     * Alias to hardforkIsActiveOnBlock when hardfork is set
     * @param blockNumber
     * @returns True if HF is active on block number
     */
    activeOnBlock(blockNumber) {
        return this.hardforkIsActiveOnBlock(null, blockNumber);
    }
    /**
     * Sequence based check if given or set HF1 is greater than or equal HF2
     * @param hardfork1 Hardfork name or null (if set)
     * @param hardfork2 Hardfork name
     * @param opts Hardfork options
     * @returns True if HF1 gte HF2
     */
    hardforkGteHardfork(hardfork1, hardfork2) {
        hardfork1 = hardfork1 ?? this._hardfork;
        const hardforks = this.hardforks();
        let posHf1 = -1, posHf2 = -1;
        let index = 0;
        for (const hf of hardforks) {
            if (hf['name'] === hardfork1)
                posHf1 = index;
            if (hf['name'] === hardfork2)
                posHf2 = index;
            index += 1;
        }
        return posHf1 >= posHf2 && posHf2 !== -1;
    }
    /**
     * Alias to hardforkGteHardfork when hardfork is set
     * @param hardfork Hardfork name
     * @returns True if hardfork set is greater than hardfork provided
     */
    gteHardfork(hardfork) {
        return this.hardforkGteHardfork(null, hardfork);
    }
    /**
     * Returns the hardfork change block for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number or null if unscheduled
     */
    hardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const block = this._getHardfork(hardfork)?.['block'];
        if (block === undefined || block === null) {
            return null;
        }
        return BigInt(block);
    }
    hardforkTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const timestamp = this._getHardfork(hardfork)?.['timestamp'];
        if (timestamp === undefined || timestamp === null) {
            return null;
        }
        return BigInt(timestamp);
    }
    /**
     * Returns the hardfork change block for eip
     * @param eip EIP number
     * @returns Block number or null if unscheduled
     */
    eipBlock(eip) {
        for (const hfChanges of this.HARDFORK_CHANGES) {
            const hf = hfChanges[1];
            if ('eips' in hf) {
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                if (hf['eips'].includes(eip)) {
                    return this.hardforkBlock(hfChanges[0]);
                }
            }
        }
        return null;
    }
    /**
     * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Total difficulty or null if no set
     */
    hardforkTTD(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const ttd = this._getHardfork(hardfork)?.['ttd'];
        if (ttd === undefined || ttd === null) {
            return null;
        }
        return BigInt(ttd);
    }
    /**
     * True if block number provided is the hardfork (given or set) change block
     * @param blockNumber Number of the block to check
     * @param hardfork Hardfork name, optional if HF set
     * @returns True if blockNumber is HF block
     * @deprecated
     */
    isHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const block = this.hardforkBlock(hardfork);
        return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false;
    }
    /**
     * Returns the change block for the next hardfork after the hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block timestamp, number or null if not available
     */
    nextHardforkBlockOrTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const hfs = this.hardforks();
        let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
        // If the current hardfork is merge, go one behind as merge hf is not part of these
        // calcs even if the merge hf block is set
        if (hardfork === enums_1.Hardfork.Merge) {
            hfIndex -= 1;
        }
        // Hardfork not found
        if (hfIndex < 0) {
            return null;
        }
        let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;
        currHfTimeOrBlock =
            currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined
                ? Number(currHfTimeOrBlock)
                : null;
        const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
            let hfTimeOrBlock = hf.timestamp ?? hf.block;
            hfTimeOrBlock =
                hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;
            return (hf.name !== enums_1.Hardfork.Merge &&
                hfTimeOrBlock !== null &&
                hfTimeOrBlock !== undefined &&
                hfTimeOrBlock !== currHfTimeOrBlock);
        });
        // If no next hf found with valid block or timestamp return null
        if (nextHf === undefined) {
            return null;
        }
        const nextHfBlock = nextHf.timestamp ?? nextHf.block;
        if (nextHfBlock === null || nextHfBlock === undefined) {
            return null;
        }
        return BigInt(nextHfBlock);
    }
    /**
     * Returns the change block for the next hardfork after the hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number or null if not available
     * @deprecated
     */
    nextHardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        let hfBlock = this.hardforkBlock(hardfork);
        // If this is a merge hardfork with block not set, then we fallback to previous hardfork
        // to find the nextHardforkBlock
        if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {
            const hfs = this.hardforks();
            const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
            if (mergeIndex < 0) {
                throw Error(`Merge hardfork should have been found`);
            }
            hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
        }
        if (hfBlock === null) {
            return null;
        }
        // Next fork block number or null if none available
        // Logic: if accumulator is still null and on the first occurrence of
        // a block greater than the current hfBlock set the accumulator,
        // pass on the accumulator as the final result from this time on
        const nextHfBlock = this.hardforks().reduce((acc, hf) => {
            // We need to ignore the merge block in our next hardfork calc
            const block = BigInt(hf.block === null || (hf.ttd !== undefined && hf.ttd !== null) ? 0 : hf.block);
            // Typescript can't seem to follow that the hfBlock is not null at this point
            return block > hfBlock && acc === null ? block : acc;
        }, null);
        return nextHfBlock;
    }
    /**
     * True if block number provided is the hardfork change block following the hardfork given or set
     * @param blockNumber Number of the block to check
     * @param hardfork Hardfork name, optional if HF set
     * @returns True if blockNumber is HF block
     * @deprecated
     */
    isNextHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const nextHardforkBlock = this.nextHardforkBlock(hardfork);
        return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
    }
    /**
     * Internal helper function to calculate a fork hash
     * @param hardfork Hardfork name
     * @param genesisHash Genesis block hash of the chain
     * @returns Fork hash as hex string
     */
    _calcForkHash(hardfork, genesisHash) {
        let hfBuffer = Buffer.alloc(0);
        let prevBlockOrTime = 0;
        for (const hf of this.hardforks()) {
            const { block, timestamp, name } = hf;
            // Timestamp to be used for timestamp based hfs even if we may bundle
            // block number with them retrospectively
            let blockOrTime = timestamp ?? block;
            blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
            // Skip for chainstart (0), not applied HFs (null) and
            // when already applied on same blockOrTime HFs
            // and on the merge since forkhash doesn't change on merge hf
            if (typeof blockOrTime === 'number' &&
                blockOrTime !== 0 &&
                blockOrTime !== prevBlockOrTime &&
                name !== enums_1.Hardfork.Merge) {
                const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex');
                hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);
                prevBlockOrTime = blockOrTime;
            }
            if (hf.name === hardfork)
                break;
        }
        const inputBuffer = Buffer.concat([genesisHash, hfBuffer]);
        // CRC32 delivers result as signed (negative) 32-bit integer,
        // convert to hex string
        const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString('hex');
        return `0x${forkhash}`;
    }
    /**
     * Returns an eth/64 compliant fork hash (EIP-2124)
     * @param hardfork Hardfork name, optional if HF set
     * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated
     */
    forkHash(hardfork, genesisHash) {
        hardfork = hardfork ?? this._hardfork;
        const data = this._getHardfork(hardfork);
        if (data === null ||
            (data?.block === null && data?.timestamp === undefined && data?.ttd === undefined)) {
            const msg = 'No fork hash calculation possible for future hardfork';
            throw new Error(msg);
        }
        if (data?.forkHash !== null && data?.forkHash !== undefined) {
            return data.forkHash;
        }
        if (!genesisHash)
            throw new Error('genesisHash required for forkHash calculation');
        return this._calcForkHash(hardfork, genesisHash);
    }
    /**
     *
     * @param forkHash Fork hash as a hex string
     * @returns Array with hardfork data (name, block, forkHash)
     */
    hardforkForForkHash(forkHash) {
        const resArray = this.hardforks().filter((hf) => {
            return hf.forkHash === forkHash;
        });
        return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
    }
    /**
     * Sets any missing forkHashes on the passed-in {@link Common} instance
     * @param common The {@link Common} to set the forkHashes for
     * @param genesisHash The genesis block hash
     */
    setForkHashes(genesisHash) {
        for (const hf of this.hardforks()) {
            const blockOrTime = hf.timestamp ?? hf.block;
            if ((hf.forkHash === null || hf.forkHash === undefined) &&
                ((blockOrTime !== null && blockOrTime !== undefined) || typeof hf.ttd !== 'undefined')) {
                hf.forkHash = this.forkHash(hf.name, genesisHash);
            }
        }
    }
    /**
     * Returns the Genesis parameters of the current chain
     * @returns Genesis dictionary
     */
    genesis() {
        return this._chainParams.genesis;
    }
    /**
     * Returns the hardforks for current chain
     * @returns {Array} Array with arrays of hardforks
     */
    hardforks() {
        return this._chainParams.hardforks;
    }
    /**
     * Returns bootstrap nodes for the current chain
     * @returns {Dictionary} Dict with bootstrap nodes
     */
    bootstrapNodes() {
        return this._chainParams.bootstrapNodes;
    }
    /**
     * Returns DNS networks for the current chain
     * @returns {String[]} Array of DNS ENR urls
     */
    dnsNetworks() {
        return this._chainParams.dnsNetworks;
    }
    /**
     * Returns the hardfork set
     * @returns Hardfork name
     */
    hardfork() {
        return this._hardfork;
    }
    /**
     * Returns the Id of current chain
     * @returns chain Id
     */
    chainId() {
        return BigInt(this._chainParams.chainId);
    }
    /**
     * Returns the name of current chain
     * @returns chain name (lower case)
     */
    chainName() {
        return this._chainParams.name;
    }
    /**
     * Returns the Id of current network
     * @returns network Id
     */
    networkId() {
        return BigInt(this._chainParams.networkId);
    }
    /**
     * Returns the active EIPs
     * @returns List of EIPs
     */
    eips() {
        return this._eips;
    }
    /**
     * Returns the consensus type of the network
     * Possible values: "pow"|"poa"|"pos"
     *
     * Note: This value can update along a Hardfork.
     */
    consensusType() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if ('consensus' in hfChanges[1]) {
                value = hfChanges[1]['consensus']['type'];
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return value ?? this._chainParams['consensus']['type'];
    }
    /**
     * Returns the concrete consensus implementation
     * algorithm or protocol for the network
     * e.g. "ethash" for "pow" consensus type,
     * "clique" for "poa" consensus type or
     * "casper" for "pos" consensus type.
     *
     * Note: This value can update along a Hardfork.
     */
    consensusAlgorithm() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if ('consensus' in hfChanges[1]) {
                value = hfChanges[1]['consensus']['algorithm'];
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return value ?? this._chainParams['consensus']['algorithm'];
    }
    /**
     * Returns a dictionary with consensus configuration
     * parameters based on the consensus algorithm
     *
     * Expected returns (parameters must be present in
     * the respective chain json files):
     *
     * ethash: empty object
     * clique: period, epoch
     * casper: empty object
     *
     * Note: This value can update along a Hardfork.
     */
    consensusConfig() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if ('consensus' in hfChanges[1]) {
                // The config parameter is named after the respective consensus algorithm
                value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']];
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return (value ?? this._chainParams['consensus'][this.consensusAlgorithm()] ?? {});
    }
    /**
     * Returns a deep copy of this {@link Common} instance.
     */
    copy() {
        const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        copy.removeAllListeners();
        return copy;
    }
    static _getInitializedChains(customChains) {
        const names = {};
        for (const [name, id] of Object.entries(enums_1.Chain)) {
            names[id] = name.toLowerCase();
        }
        const chains = { mainnet, ropsten, rinkeby, goerli, sepolia };
        if (customChains) {
            for (const chain of customChains) {
                const { name } = chain;
                names[chain.chainId.toString()] = name;
                chains[name] = chain;
            }
        }
        chains.names = names;
        return chains;
    }
}
exports.Common = Common;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\common.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\1153.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C1153.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-1153",
    "number": 1153,
    "comment": "Transient Storage",
    "url": "https://eips.ethereum.org/EIPS/eip-1153",
    "status": "Review",
    "minimumHardfork": "chainstart",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {
        "tstore": {
            "v": 100,
            "d": "Base fee of the TSTORE opcode"
        },
        "tload": {
            "v": 100,
            "d": "Base fee of the TLOAD opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\1153.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\1559.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C1559.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-1559",
    "number": 1559,
    "comment": "Fee market change for ETH 1.0 chain",
    "url": "https://eips.ethereum.org/EIPS/eip-1559",
    "status": "Final",
    "minimumHardfork": "berlin",
    "requiredEIPs": [2930],
    "gasConfig": {
        "baseFeeMaxChangeDenominator": {
            "v": 8,
            "d": "Maximum base fee change denominator"
        },
        "elasticityMultiplier": {
            "v": 2,
            "d": "Maximum block gas target elasticity"
        },
        "initialBaseFee": {
            "v": 1000000000,
            "d": "Initial base fee on first EIP1559 block"
        }
    },
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\1559.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2315.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2315.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2315",
    "number": 2315,
    "comment": "Simple subroutines for the EVM",
    "url": "https://eips.ethereum.org/EIPS/eip-2315",
    "status": "Draft",
    "minimumHardfork": "istanbul",
    "gasConfig": {},
    "gasPrices": {
        "beginsub": {
            "v": 2,
            "d": "Base fee of the BEGINSUB opcode"
        },
        "returnsub": {
            "v": 5,
            "d": "Base fee of the RETURNSUB opcode"
        },
        "jumpsub": {
            "v": 10,
            "d": "Base fee of the JUMPSUB opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2315.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2537.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2537.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2537",
    "number": 2537,
    "comment": "BLS12-381 precompiles",
    "url": "https://eips.ethereum.org/EIPS/eip-2537",
    "status": "Draft",
    "minimumHardfork": "chainstart",
    "gasConfig": {},
    "gasPrices": {
        "Bls12381G1AddGas": {
            "v": 600,
            "d": "Gas cost of a single BLS12-381 G1 addition precompile-call"
        },
        "Bls12381G1MulGas": {
            "v": 12000,
            "d": "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
        },
        "Bls12381G2AddGas": {
            "v": 4500,
            "d": "Gas cost of a single BLS12-381 G2 addition precompile-call"
        },
        "Bls12381G2MulGas": {
            "v": 55000,
            "d": "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
        },
        "Bls12381PairingBaseGas": {
            "v": 115000,
            "d": "Base gas cost of BLS12-381 pairing check"
        },
        "Bls12381PairingPerPairGas": {
            "v": 23000,
            "d": "Per-pair gas cost of BLS12-381 pairing check"
        },
        "Bls12381MapG1Gas": {
            "v": 5500,
            "d": "Gas cost of BLS12-381 map field element to G1"
        },
        "Bls12381MapG2Gas": {
            "v": 110000,
            "d": "Gas cost of BLS12-381 map field element to G2"
        },
        "Bls12381MultiExpGasDiscount": {
            "v": [
                [1, 1200],
                [2, 888],
                [3, 764],
                [4, 641],
                [5, 594],
                [6, 547],
                [7, 500],
                [8, 453],
                [9, 438],
                [10, 423],
                [11, 408],
                [12, 394],
                [13, 379],
                [14, 364],
                [15, 349],
                [16, 334],
                [17, 330],
                [18, 326],
                [19, 322],
                [20, 318],
                [21, 314],
                [22, 310],
                [23, 306],
                [24, 302],
                [25, 298],
                [26, 294],
                [27, 289],
                [28, 285],
                [29, 281],
                [30, 277],
                [31, 273],
                [32, 269],
                [33, 268],
                [34, 266],
                [35, 265],
                [36, 263],
                [37, 262],
                [38, 260],
                [39, 259],
                [40, 257],
                [41, 256],
                [42, 254],
                [43, 253],
                [44, 251],
                [45, 250],
                [46, 248],
                [47, 247],
                [48, 245],
                [49, 244],
                [50, 242],
                [51, 241],
                [52, 239],
                [53, 238],
                [54, 236],
                [55, 235],
                [56, 233],
                [57, 232],
                [58, 231],
                [59, 229],
                [60, 228],
                [61, 226],
                [62, 225],
                [63, 223],
                [64, 222],
                [65, 221],
                [66, 220],
                [67, 219],
                [68, 219],
                [69, 218],
                [70, 217],
                [71, 216],
                [72, 216],
                [73, 215],
                [74, 214],
                [75, 213],
                [76, 213],
                [77, 212],
                [78, 211],
                [79, 211],
                [80, 210],
                [81, 209],
                [82, 208],
                [83, 208],
                [84, 207],
                [85, 206],
                [86, 205],
                [87, 205],
                [88, 204],
                [89, 203],
                [90, 202],
                [91, 202],
                [92, 201],
                [93, 200],
                [94, 199],
                [95, 199],
                [96, 198],
                [97, 197],
                [98, 196],
                [99, 196],
                [100, 195],
                [101, 194],
                [102, 193],
                [103, 193],
                [104, 192],
                [105, 191],
                [106, 191],
                [107, 190],
                [108, 189],
                [109, 188],
                [110, 188],
                [111, 187],
                [112, 186],
                [113, 185],
                [114, 185],
                [115, 184],
                [116, 183],
                [117, 182],
                [118, 182],
                [119, 181],
                [120, 180],
                [121, 179],
                [122, 179],
                [123, 178],
                [124, 177],
                [125, 176],
                [126, 176],
                [127, 175],
                [128, 174]
            ],
            "d": "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2537.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2565.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2565.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2565",
    "number": 2565,
    "comment": "ModExp gas cost",
    "url": "https://eips.ethereum.org/EIPS/eip-2565",
    "status": "Final",
    "minimumHardfork": "byzantium",
    "gasConfig": {},
    "gasPrices": {
        "modexpGquaddivisor": {
            "v": 3,
            "d": "Gquaddivisor from modexp precompile for gas calculation"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2565.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2718.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2718.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2718",
    "comment": "Typed Transaction Envelope",
    "url": "https://eips.ethereum.org/EIPS/eip-2718",
    "status": "Final",
    "minimumHardfork": "chainstart",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2718.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2929.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2929.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2929",
    "comment": "Gas cost increases for state access opcodes",
    "url": "https://eips.ethereum.org/EIPS/eip-2929",
    "status": "Final",
    "minimumHardfork": "chainstart",
    "gasConfig": {},
    "gasPrices": {
        "coldsload": {
            "v": 2100,
            "d": "Gas cost of the first read of storage from a given location (per transaction)"
        },
        "coldaccountaccess": {
            "v": 2600,
            "d": "Gas cost of the first read of a given address (per transaction)"
        },
        "warmstorageread": {
            "v": 100,
            "d": "Gas cost of reading storage locations which have already loaded 'cold'"
        },
        "sstoreCleanGasEIP2200": {
            "v": 2900,
            "d": "Once per SSTORE operation from clean non-zero to something else"
        },
        "sstoreNoopGasEIP2200": {
            "v": 100,
            "d": "Once per SSTORE operation if the value doesn't change"
        },
        "sstoreDirtyGasEIP2200": {
            "v": 100,
            "d": "Once per SSTORE operation if a dirty value is changed"
        },
        "sstoreInitRefundEIP2200": {
            "v": 19900,
            "d": "Once per SSTORE operation for resetting to the original zero value"
        },
        "sstoreCleanRefundEIP2200": {
            "v": 4900,
            "d": "Once per SSTORE operation for resetting to the original non-zero value"
        },
        "call": {
            "v": 0,
            "d": "Base fee of the CALL opcode"
        },
        "callcode": {
            "v": 0,
            "d": "Base fee of the CALLCODE opcode"
        },
        "delegatecall": {
            "v": 0,
            "d": "Base fee of the DELEGATECALL opcode"
        },
        "staticcall": {
            "v": 0,
            "d": "Base fee of the STATICCALL opcode"
        },
        "balance": {
            "v": 0,
            "d": "Base fee of the BALANCE opcode"
        },
        "extcodesize": {
            "v": 0,
            "d": "Base fee of the EXTCODESIZE opcode"
        },
        "extcodecopy": {
            "v": 0,
            "d": "Base fee of the EXTCODECOPY opcode"
        },
        "extcodehash": {
            "v": 0,
            "d": "Base fee of the EXTCODEHASH opcode"
        },
        "sload": {
            "v": 0,
            "d": "Base fee of the SLOAD opcode"
        },
        "sstore": {
            "v": 0,
            "d": "Base fee of the SSTORE opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2929.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2930.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2930.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2930",
    "comment": "Optional access lists",
    "url": "https://eips.ethereum.org/EIPS/eip-2930",
    "status": "Final",
    "minimumHardfork": "istanbul",
    "requiredEIPs": [2718, 2929],
    "gasConfig": {},
    "gasPrices": {
        "accessListStorageKeyCost": {
            "v": 1900,
            "d": "Gas cost per storage key in an Access List transaction"
        },
        "accessListAddressCost": {
            "v": 2400,
            "d": "Gas cost per storage key in an Access List transaction"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2930.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3074.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3074.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3074",
    "number": 3074,
    "comment": "AUTH and AUTHCALL opcodes",
    "url": "https://eips.ethereum.org/EIPS/eip-3074",
    "status": "Review",
    "minimumHardfork": "london",
    "gasConfig": {},
    "gasPrices": {
        "auth": {
            "v": 3100,
            "d": "Gas cost of the AUTH opcode"
        },
        "authcall": {
            "v": 0,
            "d": "Gas cost of the AUTHCALL opcode"
        },
        "authcallValueTransfer": {
            "v": 6700,
            "d": "Paid for CALL when the value transfer is non-zero"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3074.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3198.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3198.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3198",
    "number": 3198,
    "comment": "BASEFEE opcode",
    "url": "https://eips.ethereum.org/EIPS/eip-3198",
    "status": "Final",
    "minimumHardfork": "london",
    "gasConfig": {},
    "gasPrices": {
        "basefee": {
            "v": 2,
            "d": "Gas cost of the BASEFEE opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3198.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3529.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3529.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3529",
    "comment": "Reduction in refunds",
    "url": "https://eips.ethereum.org/EIPS/eip-3529",
    "status": "Final",
    "minimumHardfork": "berlin",
    "requiredEIPs": [2929],
    "gasConfig": {
        "maxRefundQuotient": {
            "v": 5,
            "d": "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
    },
    "gasPrices": {
        "selfdestructRefund": {
            "v": 0,
            "d": "Refunded following a selfdestruct operation"
        },
        "sstoreClearRefundEIP2200": {
            "v": 4800,
            "d": "Once per SSTORE operation for clearing an originally existing storage slot"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3529.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3540.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3540.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3540",
    "number": 3540,
    "comment": "EVM Object Format (EOF) v1",
    "url": "https://eips.ethereum.org/EIPS/eip-3540",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [3541],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3540.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3541.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3541.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3541",
    "comment": "Reject new contracts starting with the 0xEF byte",
    "url": "https://eips.ethereum.org/EIPS/eip-3541",
    "status": "Final",
    "minimumHardfork": "berlin",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3541.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3554.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3554.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3554",
    "comment": "Reduction in refunds",
    "url": "Difficulty Bomb Delay to December 1st 2021",
    "status": "Final",
    "minimumHardfork": "muirGlacier",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 9500000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3554.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3607.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3607.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3607",
    "number": 3607,
    "comment": "Reject transactions from senders with deployed code",
    "url": "https://eips.ethereum.org/EIPS/eip-3607",
    "status": "Final",
    "minimumHardfork": "chainstart",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3607.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3651.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3651.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3651",
    "number": 3198,
    "comment": "Warm COINBASE",
    "url": "https://eips.ethereum.org/EIPS/eip-3651",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [2929],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3651.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3670.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3670.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3670",
    "number": 3670,
    "comment": "EOF - Code Validation",
    "url": "https://eips.ethereum.org/EIPS/eip-3670",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [3540],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3670.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3675.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3675.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3675",
    "number": 3675,
    "comment": "Upgrade consensus to Proof-of-Stake",
    "url": "https://eips.ethereum.org/EIPS/eip-3675",
    "status": "Final",
    "minimumHardfork": "london",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3675.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3855.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3855.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3855",
    "number": 3855,
    "comment": "PUSH0 instruction",
    "url": "https://eips.ethereum.org/EIPS/eip-3855",
    "status": "Review",
    "minimumHardfork": "chainstart",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {
        "push0": {
            "v": 2,
            "d": "Base fee of the PUSH0 opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3855.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3860.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3860.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3860",
    "number": 3860,
    "comment": "Limit and meter initcode",
    "url": "https://eips.ethereum.org/EIPS/eip-3860",
    "status": "Review",
    "minimumHardfork": "spuriousDragon",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {
        "initCodeWordCost": {
            "v": 2,
            "d": "Gas to pay for each word (32 bytes) of initcode when creating a contract"
        }
    },
    "vm": {
        "maxInitCodeSize": {
            "v": 49152,
            "d": "Maximum length of initialization code when creating a contract"
        }
    },
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3860.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4345.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4345.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4345",
    "number": 4345,
    "comment": "Difficulty Bomb Delay to June 2022",
    "url": "https://eips.ethereum.org/EIPS/eip-4345",
    "status": "Final",
    "minimumHardfork": "london",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 10700000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4345.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4399.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4399.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4399",
    "number": 4399,
    "comment": "Supplant DIFFICULTY opcode with PREVRANDAO",
    "url": "https://eips.ethereum.org/EIPS/eip-4399",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4399.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4844.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4844.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4844",
    "number": 4844,
    "comment": "Shard Blob Transactions",
    "url": "https://eips.ethereum.org/EIPS/eip-4844",
    "status": "Draft",
    "minimumHardfork": "merge",
    "requiredEIPs": [1559, 2718, 2930, 4895],
    "gasConfig": {
        "dataGasPerBlob": {
            "v": 131072,
            "d": "The base fee for data gas per blob"
        },
        "targetDataGasPerBlock": {
            "v": 262144,
            "d": "The target data gas consumed per block"
        },
        "maxDataGasPerBlock": {
            "v": 524288,
            "d": "The max data gas allowable per block"
        },
        "dataGasPriceUpdateFraction": {
            "v": 2225652,
            "d": "The denominator used in the exponential when calculating a data gas price"
        }
    },
    "gasPrices": {
        "simpleGasPerBlob": {
            "v": 12000,
            "d": "The basic gas fee for each blob"
        },
        "minDataGasPrice": {
            "v": 1,
            "d": "The minimum fee per data gas"
        },
        "kzgPointEvaluationGasPrecompilePrice": {
            "v": 50000,
            "d": "The fee associated with the point evaluation precompile"
        },
        "datahash": {
            "v": 3,
            "d": "Base fee of the DATAHASH opcode"
        }
    },
    "sharding": {
        "blobCommitmentVersionKzg": {
            "v": 1,
            "d": "The number indicated a versioned hash is a KZG commitment"
        },
        "fieldElementsPerBlob": {
            "v": 4096,
            "d": "The number of field elements allowed per blob"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4844.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4895.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4895.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4895",
    "number": 4895,
    "comment": "Beacon chain push withdrawals as operations",
    "url": "https://eips.ethereum.org/EIPS/eip-4895",
    "status": "Review",
    "minimumHardfork": "merge",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4895.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\5133.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C5133.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-5133",
    "number": 5133,
    "comment": "Delaying Difficulty Bomb to mid-September 2022",
    "url": "https://eips.ethereum.org/EIPS/eip-5133",
    "status": "Draft",
    "minimumHardfork": "grayGlacier",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 11400000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\5133.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\index.js", {"./1153.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\1153.json","./1559.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\1559.json","./2315.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2315.json","./2537.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2537.json","./2565.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2565.json","./2718.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2718.json","./2929.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2929.json","./2930.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\2930.json","./3074.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3074.json","./3198.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3198.json","./3529.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3529.json","./3540.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3540.json","./3541.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3541.json","./3554.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3554.json","./3607.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3607.json","./3651.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3651.json","./3670.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3670.json","./3675.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3675.json","./3855.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3855.json","./3860.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\3860.json","./4345.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4345.json","./4399.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4399.json","./4844.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4844.json","./4895.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\4895.json","./5133.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\5133.json"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIPs = void 0;
exports.EIPs = {
    1153: require('./1153.json'),
    1559: require('./1559.json'),
    2315: require('./2315.json'),
    2537: require('./2537.json'),
    2565: require('./2565.json'),
    2718: require('./2718.json'),
    2929: require('./2929.json'),
    2930: require('./2930.json'),
    3074: require('./3074.json'),
    3198: require('./3198.json'),
    3529: require('./3529.json'),
    3540: require('./3540.json'),
    3541: require('./3541.json'),
    3554: require('./3554.json'),
    3607: require('./3607.json'),
    3651: require('./3651.json'),
    3670: require('./3670.json'),
    3675: require('./3675.json'),
    3855: require('./3855.json'),
    3860: require('./3860.json'),
    4345: require('./4345.json'),
    4399: require('./4399.json'),
    4844: require('./4844.json'),
    4895: require('./4895.json'),
    5133: require('./5133.json'),
};
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\eips\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\enums.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cenums.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomChain = exports.ConsensusAlgorithm = exports.ConsensusType = exports.Hardfork = exports.Chain = void 0;
var Chain;
(function (Chain) {
    Chain[Chain["Mainnet"] = 1] = "Mainnet";
    Chain[Chain["Ropsten"] = 3] = "Ropsten";
    Chain[Chain["Rinkeby"] = 4] = "Rinkeby";
    Chain[Chain["Goerli"] = 5] = "Goerli";
    Chain[Chain["Sepolia"] = 11155111] = "Sepolia";
})(Chain = exports.Chain || (exports.Chain = {}));
var Hardfork;
(function (Hardfork) {
    Hardfork["Chainstart"] = "chainstart";
    Hardfork["Homestead"] = "homestead";
    Hardfork["Dao"] = "dao";
    Hardfork["TangerineWhistle"] = "tangerineWhistle";
    Hardfork["SpuriousDragon"] = "spuriousDragon";
    Hardfork["Byzantium"] = "byzantium";
    Hardfork["Constantinople"] = "constantinople";
    Hardfork["Petersburg"] = "petersburg";
    Hardfork["Istanbul"] = "istanbul";
    Hardfork["MuirGlacier"] = "muirGlacier";
    Hardfork["Berlin"] = "berlin";
    Hardfork["London"] = "london";
    Hardfork["ArrowGlacier"] = "arrowGlacier";
    Hardfork["GrayGlacier"] = "grayGlacier";
    Hardfork["MergeForkIdTransition"] = "mergeForkIdTransition";
    Hardfork["Merge"] = "merge";
    Hardfork["Shanghai"] = "shanghai";
    Hardfork["ShardingForkDev"] = "shardingFork";
})(Hardfork = exports.Hardfork || (exports.Hardfork = {}));
var ConsensusType;
(function (ConsensusType) {
    ConsensusType["ProofOfStake"] = "pos";
    ConsensusType["ProofOfWork"] = "pow";
    ConsensusType["ProofOfAuthority"] = "poa";
})(ConsensusType = exports.ConsensusType || (exports.ConsensusType = {}));
var ConsensusAlgorithm;
(function (ConsensusAlgorithm) {
    ConsensusAlgorithm["Ethash"] = "ethash";
    ConsensusAlgorithm["Clique"] = "clique";
    ConsensusAlgorithm["Casper"] = "casper";
})(ConsensusAlgorithm = exports.ConsensusAlgorithm || (exports.ConsensusAlgorithm = {}));
var CustomChain;
(function (CustomChain) {
    /**
     * Polygon (Matic) Mainnet
     *
     * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
     */
    CustomChain["PolygonMainnet"] = "polygon-mainnet";
    /**
     * Polygon (Matic) Mumbai Testnet
     *
     * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
     */
    CustomChain["PolygonMumbai"] = "polygon-mumbai";
    /**
     * Arbitrum Rinkeby Testnet
     *
     * - [Documentation](https://developer.offchainlabs.com/docs/public_testnet)
     */
    CustomChain["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
    /**
     * Arbitrum One - mainnet for Arbitrum roll-up
     *
     * - [Documentation](https://developer.offchainlabs.com/public-chains)
     */
    CustomChain["ArbitrumOne"] = "arbitrum-one";
    /**
     * xDai EVM sidechain with a native stable token
     *
     * - [Documentation](https://www.xdaichain.com/)
     */
    CustomChain["xDaiChain"] = "x-dai-chain";
    /**
     * Optimistic Kovan - testnet for Optimism roll-up
     *
     * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)
     */
    CustomChain["OptimisticKovan"] = "optimistic-kovan";
    /**
     * Optimistic Ethereum - mainnet for Optimism roll-up
     *
     * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)
     */
    CustomChain["OptimisticEthereum"] = "optimistic-ethereum";
})(CustomChain = exports.CustomChain || (exports.CustomChain = {}));
//# sourceMappingURL=enums.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\enums.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\arrowGlacier.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CarrowGlacier.json
      return function (require, module, exports) {
module.exports={
    "name": "arrowGlacier",
    "comment": "HF to delay the difficulty bomb",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
    "status": "Final",
    "eips": [4345],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\arrowGlacier.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\berlin.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cberlin.json
      return function (require, module, exports) {
module.exports={
    "name": "berlin",
    "comment": "HF targeted for July 2020 following the Muir Glacier HF",
    "url": "https://eips.ethereum.org/EIPS/eip-2070",
    "status": "Final",
    "eips": [2565, 2929, 2718, 2930]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\berlin.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\byzantium.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cbyzantium.json
      return function (require, module, exports) {
module.exports={
    "name": "byzantium",
    "comment": "Hardfork with new precompiles, instructions and other protocol changes",
    "url": "https://eips.ethereum.org/EIPS/eip-609",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "modexpGquaddivisor": {
            "v": 20,
            "d": "Gquaddivisor from modexp precompile for gas calculation"
        },
        "ecAdd": {
            "v": 500,
            "d": "Gas costs for curve addition precompile"
        },
        "ecMul": {
            "v": 40000,
            "d": "Gas costs for curve multiplication precompile"
        },
        "ecPairing": {
            "v": 100000,
            "d": "Base gas costs for curve pairing precompile"
        },
        "ecPairingWord": {
            "v": 80000,
            "d": "Gas costs regarding curve pairing precompile input length"
        },
        "revert": {
            "v": 0,
            "d": "Base fee of the REVERT opcode"
        },
        "staticcall": {
            "v": 700,
            "d": "Base fee of the STATICCALL opcode"
        },
        "returndatasize": {
            "v": 2,
            "d": "Base fee of the RETURNDATASIZE opcode"
        },
        "returndatacopy": {
            "v": 3,
            "d": "Base fee of the RETURNDATACOPY opcode"
        }
    },
    "vm": {},
    "pow": {
        "minerReward": {
            "v": "3000000000000000000",
            "d": "the amount a miner get rewarded for mining a block"
        },
        "difficultyBombDelay": {
            "v": 3000000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\byzantium.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\chainstart.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cchainstart.json
      return function (require, module, exports) {
module.exports={
    "name": "chainstart",
    "comment": "Start of the Ethereum main chain",
    "url": "",
    "status": "",
    "gasConfig": {
        "minGasLimit": {
            "v": 5000,
            "d": "Minimum the gas limit may ever be"
        },
        "gasLimitBoundDivisor": {
            "v": 1024,
            "d": "The bound divisor of the gas limit, used in update calculations"
        },
        "maxRefundQuotient": {
            "v": 2,
            "d": "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
    },
    "gasPrices": {
        "base": {
            "v": 2,
            "d": "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
        },
        "tierStep": {
            "v": [0, 2, 3, 5, 8, 10, 20],
            "d": "Once per operation, for a selection of them"
        },
        "exp": {
            "v": 10,
            "d": "Base fee of the EXP opcode"
        },
        "expByte": {
            "v": 10,
            "d": "Times ceil(log256(exponent)) for the EXP instruction"
        },
        "sha3": {
            "v": 30,
            "d": "Base fee of the SHA3 opcode"
        },
        "sha3Word": {
            "v": 6,
            "d": "Once per word of the SHA3 operation's data"
        },
        "sload": {
            "v": 50,
            "d": "Base fee of the SLOAD opcode"
        },
        "sstoreSet": {
            "v": 20000,
            "d": "Once per SSTORE operation if the zeroness changes from zero"
        },
        "sstoreReset": {
            "v": 5000,
            "d": "Once per SSTORE operation if the zeroness does not change from zero"
        },
        "sstoreRefund": {
            "v": 15000,
            "d": "Once per SSTORE operation if the zeroness changes to zero"
        },
        "jumpdest": {
            "v": 1,
            "d": "Base fee of the JUMPDEST opcode"
        },
        "log": {
            "v": 375,
            "d": "Base fee of the LOG opcode"
        },
        "logData": {
            "v": 8,
            "d": "Per byte in a LOG* operation's data"
        },
        "logTopic": {
            "v": 375,
            "d": "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
        },
        "create": {
            "v": 32000,
            "d": "Base fee of the CREATE opcode"
        },
        "call": {
            "v": 40,
            "d": "Base fee of the CALL opcode"
        },
        "callStipend": {
            "v": 2300,
            "d": "Free gas given at beginning of call"
        },
        "callValueTransfer": {
            "v": 9000,
            "d": "Paid for CALL when the value transfor is non-zero"
        },
        "callNewAccount": {
            "v": 25000,
            "d": "Paid for CALL when the destination address didn't exist prior"
        },
        "selfdestructRefund": {
            "v": 24000,
            "d": "Refunded following a selfdestruct operation"
        },
        "memory": {
            "v": 3,
            "d": "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
        },
        "quadCoeffDiv": {
            "v": 512,
            "d": "Divisor for the quadratic particle of the memory cost equation"
        },
        "createData": {
            "v": 200,
            "d": ""
        },
        "tx": {
            "v": 21000,
            "d": "Per transaction. NOTE: Not payable on data of calls between transactions"
        },
        "txCreation": {
            "v": 32000,
            "d": "The cost of creating a contract via tx"
        },
        "txDataZero": {
            "v": 4,
            "d": "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
        },
        "txDataNonZero": {
            "v": 68,
            "d": "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        "copy": {
            "v": 3,
            "d": "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
        },
        "ecRecover": {
            "v": 3000,
            "d": ""
        },
        "sha256": {
            "v": 60,
            "d": ""
        },
        "sha256Word": {
            "v": 12,
            "d": ""
        },
        "ripemd160": {
            "v": 600,
            "d": ""
        },
        "ripemd160Word": {
            "v": 120,
            "d": ""
        },
        "identity": {
            "v": 15,
            "d": ""
        },
        "identityWord": {
            "v": 3,
            "d": ""
        },
        "stop": {
            "v": 0,
            "d": "Base fee of the STOP opcode"
        },
        "add": {
            "v": 3,
            "d": "Base fee of the ADD opcode"
        },
        "mul": {
            "v": 5,
            "d": "Base fee of the MUL opcode"
        },
        "sub": {
            "v": 3,
            "d": "Base fee of the SUB opcode"
        },
        "div": {
            "v": 5,
            "d": "Base fee of the DIV opcode"
        },
        "sdiv": {
            "v": 5,
            "d": "Base fee of the SDIV opcode"
        },
        "mod": {
            "v": 5,
            "d": "Base fee of the MOD opcode"
        },
        "smod": {
            "v": 5,
            "d": "Base fee of the SMOD opcode"
        },
        "addmod": {
            "v": 8,
            "d": "Base fee of the ADDMOD opcode"
        },
        "mulmod": {
            "v": 8,
            "d": "Base fee of the MULMOD opcode"
        },
        "signextend": {
            "v": 5,
            "d": "Base fee of the SIGNEXTEND opcode"
        },
        "lt": {
            "v": 3,
            "d": "Base fee of the LT opcode"
        },
        "gt": {
            "v": 3,
            "d": "Base fee of the GT opcode"
        },
        "slt": {
            "v": 3,
            "d": "Base fee of the SLT opcode"
        },
        "sgt": {
            "v": 3,
            "d": "Base fee of the SGT opcode"
        },
        "eq": {
            "v": 3,
            "d": "Base fee of the EQ opcode"
        },
        "iszero": {
            "v": 3,
            "d": "Base fee of the ISZERO opcode"
        },
        "and": {
            "v": 3,
            "d": "Base fee of the AND opcode"
        },
        "or": {
            "v": 3,
            "d": "Base fee of the OR opcode"
        },
        "xor": {
            "v": 3,
            "d": "Base fee of the XOR opcode"
        },
        "not": {
            "v": 3,
            "d": "Base fee of the NOT opcode"
        },
        "byte": {
            "v": 3,
            "d": "Base fee of the BYTE opcode"
        },
        "address": {
            "v": 2,
            "d": "Base fee of the ADDRESS opcode"
        },
        "balance": {
            "v": 20,
            "d": "Base fee of the BALANCE opcode"
        },
        "origin": {
            "v": 2,
            "d": "Base fee of the ORIGIN opcode"
        },
        "caller": {
            "v": 2,
            "d": "Base fee of the CALLER opcode"
        },
        "callvalue": {
            "v": 2,
            "d": "Base fee of the CALLVALUE opcode"
        },
        "calldataload": {
            "v": 3,
            "d": "Base fee of the CALLDATALOAD opcode"
        },
        "calldatasize": {
            "v": 2,
            "d": "Base fee of the CALLDATASIZE opcode"
        },
        "calldatacopy": {
            "v": 3,
            "d": "Base fee of the CALLDATACOPY opcode"
        },
        "codesize": {
            "v": 2,
            "d": "Base fee of the CODESIZE opcode"
        },
        "codecopy": {
            "v": 3,
            "d": "Base fee of the CODECOPY opcode"
        },
        "gasprice": {
            "v": 2,
            "d": "Base fee of the GASPRICE opcode"
        },
        "extcodesize": {
            "v": 20,
            "d": "Base fee of the EXTCODESIZE opcode"
        },
        "extcodecopy": {
            "v": 20,
            "d": "Base fee of the EXTCODECOPY opcode"
        },
        "blockhash": {
            "v": 20,
            "d": "Base fee of the BLOCKHASH opcode"
        },
        "coinbase": {
            "v": 2,
            "d": "Base fee of the COINBASE opcode"
        },
        "timestamp": {
            "v": 2,
            "d": "Base fee of the TIMESTAMP opcode"
        },
        "number": {
            "v": 2,
            "d": "Base fee of the NUMBER opcode"
        },
        "difficulty": {
            "v": 2,
            "d": "Base fee of the DIFFICULTY opcode"
        },
        "gaslimit": {
            "v": 2,
            "d": "Base fee of the GASLIMIT opcode"
        },
        "pop": {
            "v": 2,
            "d": "Base fee of the POP opcode"
        },
        "mload": {
            "v": 3,
            "d": "Base fee of the MLOAD opcode"
        },
        "mstore": {
            "v": 3,
            "d": "Base fee of the MSTORE opcode"
        },
        "mstore8": {
            "v": 3,
            "d": "Base fee of the MSTORE8 opcode"
        },
        "sstore": {
            "v": 0,
            "d": "Base fee of the SSTORE opcode"
        },
        "jump": {
            "v": 8,
            "d": "Base fee of the JUMP opcode"
        },
        "jumpi": {
            "v": 10,
            "d": "Base fee of the JUMPI opcode"
        },
        "pc": {
            "v": 2,
            "d": "Base fee of the PC opcode"
        },
        "msize": {
            "v": 2,
            "d": "Base fee of the MSIZE opcode"
        },
        "gas": {
            "v": 2,
            "d": "Base fee of the GAS opcode"
        },
        "push": {
            "v": 3,
            "d": "Base fee of the PUSH opcode"
        },
        "dup": {
            "v": 3,
            "d": "Base fee of the DUP opcode"
        },
        "swap": {
            "v": 3,
            "d": "Base fee of the SWAP opcode"
        },
        "callcode": {
            "v": 40,
            "d": "Base fee of the CALLCODE opcode"
        },
        "return": {
            "v": 0,
            "d": "Base fee of the RETURN opcode"
        },
        "invalid": {
            "v": 0,
            "d": "Base fee of the INVALID opcode"
        },
        "selfdestruct": {
            "v": 0,
            "d": "Base fee of the SELFDESTRUCT opcode"
        }
    },
    "vm": {
        "stackLimit": {
            "v": 1024,
            "d": "Maximum size of VM stack allowed"
        },
        "callCreateDepth": {
            "v": 1024,
            "d": "Maximum depth of call/create stack"
        },
        "maxExtraDataSize": {
            "v": 32,
            "d": "Maximum size extra data may be after Genesis"
        }
    },
    "pow": {
        "minimumDifficulty": {
            "v": 131072,
            "d": "The minimum that the difficulty may ever be"
        },
        "difficultyBoundDivisor": {
            "v": 2048,
            "d": "The bound divisor of the difficulty, used in the update calculations"
        },
        "durationLimit": {
            "v": 13,
            "d": "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
        },
        "epochDuration": {
            "v": 30000,
            "d": "Duration between proof-of-work epochs"
        },
        "timebombPeriod": {
            "v": 100000,
            "d": "Exponential difficulty timebomb period"
        },
        "minerReward": {
            "v": "5000000000000000000",
            "d": "the amount a miner get rewarded for mining a block"
        },
        "difficultyBombDelay": {
            "v": 0,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\chainstart.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\constantinople.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cconstantinople.json
      return function (require, module, exports) {
module.exports={
    "name": "constantinople",
    "comment": "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
    "url": "https://eips.ethereum.org/EIPS/eip-1013",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "netSstoreNoopGas": {
            "v": 200,
            "d": "Once per SSTORE operation if the value doesn't change"
        },
        "netSstoreInitGas": {
            "v": 20000,
            "d": "Once per SSTORE operation from clean zero"
        },
        "netSstoreCleanGas": {
            "v": 5000,
            "d": "Once per SSTORE operation from clean non-zero"
        },
        "netSstoreDirtyGas": {
            "v": 200,
            "d": "Once per SSTORE operation from dirty"
        },
        "netSstoreClearRefund": {
            "v": 15000,
            "d": "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        "netSstoreResetRefund": {
            "v": 4800,
            "d": "Once per SSTORE operation for resetting to the original non-zero value"
        },
        "netSstoreResetClearRefund": {
            "v": 19800,
            "d": "Once per SSTORE operation for resetting to the original zero value"
        },
        "shl": {
            "v": 3,
            "d": "Base fee of the SHL opcode"
        },
        "shr": {
            "v": 3,
            "d": "Base fee of the SHR opcode"
        },
        "sar": {
            "v": 3,
            "d": "Base fee of the SAR opcode"
        },
        "extcodehash": {
            "v": 400,
            "d": "Base fee of the EXTCODEHASH opcode"
        },
        "create2": {
            "v": 32000,
            "d": "Base fee of the CREATE2 opcode"
        }
    },
    "vm": {},
    "pow": {
        "minerReward": {
            "v": "2000000000000000000",
            "d": "The amount a miner gets rewarded for mining a block"
        },
        "difficultyBombDelay": {
            "v": 5000000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\constantinople.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\dao.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cdao.json
      return function (require, module, exports) {
module.exports={
    "name": "dao",
    "comment": "DAO rescue hardfork",
    "url": "https://eips.ethereum.org/EIPS/eip-779",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\dao.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\grayGlacier.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CgrayGlacier.json
      return function (require, module, exports) {
module.exports={
    "name": "grayGlacier",
    "comment": "Delaying the difficulty bomb to Mid September 2022",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
    "status": "Draft",
    "eips": [5133],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\grayGlacier.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\homestead.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Chomestead.json
      return function (require, module, exports) {
module.exports={
    "name": "homestead",
    "comment": "Homestead hardfork with protocol and network changes",
    "url": "https://eips.ethereum.org/EIPS/eip-606",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "delegatecall": {
            "v": 40,
            "d": "Base fee of the DELEGATECALL opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\homestead.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\index.js", {"./arrowGlacier.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\arrowGlacier.json","./berlin.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\berlin.json","./byzantium.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\byzantium.json","./chainstart.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\chainstart.json","./constantinople.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\constantinople.json","./dao.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\dao.json","./grayGlacier.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\grayGlacier.json","./homestead.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\homestead.json","./istanbul.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\istanbul.json","./london.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\london.json","./merge.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\merge.json","./mergeForkIdTransition.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\mergeForkIdTransition.json","./muirGlacier.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\muirGlacier.json","./petersburg.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\petersburg.json","./shanghai.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\shanghai.json","./sharding.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\sharding.json","./spuriousDragon.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\spuriousDragon.json","./tangerineWhistle.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\tangerineWhistle.json"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hardforks = void 0;
exports.hardforks = {
    chainstart: require('./chainstart.json'),
    homestead: require('./homestead.json'),
    dao: require('./dao.json'),
    tangerineWhistle: require('./tangerineWhistle.json'),
    spuriousDragon: require('./spuriousDragon.json'),
    byzantium: require('./byzantium.json'),
    constantinople: require('./constantinople.json'),
    petersburg: require('./petersburg.json'),
    istanbul: require('./istanbul.json'),
    muirGlacier: require('./muirGlacier.json'),
    berlin: require('./berlin.json'),
    london: require('./london.json'),
    shanghai: require('./shanghai.json'),
    arrowGlacier: require('./arrowGlacier.json'),
    grayGlacier: require('./grayGlacier.json'),
    mergeForkIdTransition: require('./mergeForkIdTransition.json'),
    merge: require('./merge.json'),
    shardingFork: require('./sharding.json'),
};
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\istanbul.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cistanbul.json
      return function (require, module, exports) {
module.exports={
    "name": "istanbul",
    "comment": "HF targeted for December 2019 following the Constantinople/Petersburg HF",
    "url": "https://eips.ethereum.org/EIPS/eip-1679",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "blake2Round": {
            "v": 1,
            "d": "Gas cost per round for the Blake2 F precompile"
        },
        "ecAdd": {
            "v": 150,
            "d": "Gas costs for curve addition precompile"
        },
        "ecMul": {
            "v": 6000,
            "d": "Gas costs for curve multiplication precompile"
        },
        "ecPairing": {
            "v": 45000,
            "d": "Base gas costs for curve pairing precompile"
        },
        "ecPairingWord": {
            "v": 34000,
            "d": "Gas costs regarding curve pairing precompile input length"
        },
        "txDataNonZero": {
            "v": 16,
            "d": "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        "sstoreSentryGasEIP2200": {
            "v": 2300,
            "d": "Minimum gas required to be present for an SSTORE call, not consumed"
        },
        "sstoreNoopGasEIP2200": {
            "v": 800,
            "d": "Once per SSTORE operation if the value doesn't change"
        },
        "sstoreDirtyGasEIP2200": {
            "v": 800,
            "d": "Once per SSTORE operation if a dirty value is changed"
        },
        "sstoreInitGasEIP2200": {
            "v": 20000,
            "d": "Once per SSTORE operation from clean zero to non-zero"
        },
        "sstoreInitRefundEIP2200": {
            "v": 19200,
            "d": "Once per SSTORE operation for resetting to the original zero value"
        },
        "sstoreCleanGasEIP2200": {
            "v": 5000,
            "d": "Once per SSTORE operation from clean non-zero to something else"
        },
        "sstoreCleanRefundEIP2200": {
            "v": 4200,
            "d": "Once per SSTORE operation for resetting to the original non-zero value"
        },
        "sstoreClearRefundEIP2200": {
            "v": 15000,
            "d": "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        "balance": {
            "v": 700,
            "d": "Base fee of the BALANCE opcode"
        },
        "extcodehash": {
            "v": 700,
            "d": "Base fee of the EXTCODEHASH opcode"
        },
        "chainid": {
            "v": 2,
            "d": "Base fee of the CHAINID opcode"
        },
        "selfbalance": {
            "v": 5,
            "d": "Base fee of the SELFBALANCE opcode"
        },
        "sload": {
            "v": 800,
            "d": "Base fee of the SLOAD opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\istanbul.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\london.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Clondon.json
      return function (require, module, exports) {
module.exports={
    "name": "london",
    "comment": "HF targeted for July 2021 following the Berlin fork",
    "url": "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
    "status": "Final",
    "eips": [1559, 3198, 3529, 3541]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\london.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\merge.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cmerge.json
      return function (require, module, exports) {
module.exports={
    "name": "merge",
    "comment": "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
    "status": "Final",
    "consensus": {
        "type": "pos",
        "algorithm": "casper",
        "casper": {}
    },
    "eips": [3675, 4399]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\merge.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\mergeForkIdTransition.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CmergeForkIdTransition.json
      return function (require, module, exports) {
module.exports={
    "name": "mergeForkIdTransition",
    "comment": "Pre-merge hardfork to fork off non-upgraded clients",
    "url": "https://eips.ethereum.org/EIPS/eip-3675",
    "status": "Draft",
    "eips": []
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\mergeForkIdTransition.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\muirGlacier.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CmuirGlacier.json
      return function (require, module, exports) {
module.exports={
    "name": "muirGlacier",
    "comment": "HF to delay the difficulty bomb",
    "url": "https://eips.ethereum.org/EIPS/eip-2384",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 9000000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\muirGlacier.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\petersburg.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cpetersburg.json
      return function (require, module, exports) {
module.exports={
    "name": "petersburg",
    "comment": "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
    "url": "https://eips.ethereum.org/EIPS/eip-1716",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "netSstoreNoopGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreInitGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreCleanGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreDirtyGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreClearRefund": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreResetRefund": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreResetClearRefund": {
            "v": null,
            "d": "Removed along EIP-1283"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\petersburg.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\shanghai.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cshanghai.json
      return function (require, module, exports) {
module.exports={
    "name": "shanghai",
    "comment": "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
    "status": "Final",
    "eips": [3651, 3855, 3860, 4895]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\shanghai.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\sharding.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Csharding.json
      return function (require, module, exports) {
module.exports={
    "name": "shardingFork",
    "comment": "Internal hardfork to test proto-danksharding (do not use in production)",
    "url": "https://eips.ethereum.org/EIPS/eip-4844",
    "status": "Experimental",
    "eips": [4844]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\sharding.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\spuriousDragon.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CspuriousDragon.json
      return function (require, module, exports) {
module.exports={
    "name": "spuriousDragon",
    "comment": "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
    "url": "https://eips.ethereum.org/EIPS/eip-607",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "expByte": {
            "v": 50,
            "d": "Times ceil(log256(exponent)) for the EXP instruction"
        }
    },
    "vm": {
        "maxCodeSize": {
            "v": 24576,
            "d": "Maximum length of contract code"
        }
    },
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\spuriousDragon.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\tangerineWhistle.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CtangerineWhistle.json
      return function (require, module, exports) {
module.exports={
    "name": "tangerineWhistle",
    "comment": "Hardfork with gas cost changes for IO-heavy operations",
    "url": "https://eips.ethereum.org/EIPS/eip-608",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "sload": {
            "v": 200,
            "d": "Once per SLOAD operation"
        },
        "call": {
            "v": 700,
            "d": "Once per CALL operation & message call transaction"
        },
        "extcodesize": {
            "v": 700,
            "d": "Base fee of the EXTCODESIZE opcode"
        },
        "extcodecopy": {
            "v": 700,
            "d": "Base fee of the EXTCODECOPY opcode"
        },
        "balance": {
            "v": 400,
            "d": "Base fee of the BALANCE opcode"
        },
        "delegatecall": {
            "v": 700,
            "d": "Base fee of the DELEGATECALL opcode"
        },
        "callcode": {
            "v": 700,
            "d": "Base fee of the CALLCODE opcode"
        },
        "selfdestruct": {
            "v": 5000,
            "d": "Base fee of the SELFDESTRUCT opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\tangerineWhistle.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\index.js", {"./common":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\common.js","./enums":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\enums.js","./types":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\types.js","./utils":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./common"), exports);
__exportStar(require("./enums"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\types.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\utils.js", {"./enums":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\enums.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGethGenesis = void 0;
const util_1 = require("@ethereumjs/util");
const enums_1 = require("./enums");
/**
 * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally
 * @param nonce string parsed from the Geth genesis file
 * @returns nonce as a 0x-prefixed 8 byte string
 */
function formatNonce(nonce) {
    if (!nonce || nonce === '0x0') {
        return '0x0000000000000000';
    }
    if ((0, util_1.isHexPrefixed)(nonce)) {
        return '0x' + (0, util_1.stripHexPrefix)(nonce).padStart(16, '0');
    }
    return '0x' + nonce.padStart(16, '0');
}
/**
 * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object
 * @param json object representing the Geth genesis file
 * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition
 * hardfork, which by default is post merge as with the merged eth networks but could also come
 * before merge like in kiln genesis
 * @returns genesis parameters in a `CommonOpts` compliant object
 */
function parseGethParams(json, mergeForkIdPostMerge = true) {
    const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas, } = json;
    let { extraData, timestamp, nonce } = json;
    const genesisTimestamp = Number(timestamp);
    const { chainId } = config;
    // geth is not strictly putting empty fields with a 0x prefix
    if (extraData === '') {
        extraData = '0x';
    }
    // geth may use number for timestamp
    if (!(0, util_1.isHexPrefixed)(timestamp)) {
        timestamp = (0, util_1.intToHex)(parseInt(timestamp));
    }
    // geth may not give us a nonce strictly formatted to an 8 byte hex string
    if (nonce.length !== 18) {
        nonce = formatNonce(nonce);
    }
    // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time
    // but have different configuration parameters in geth genesis parameters
    if (config.eip155Block !== config.eip158Block) {
        throw new Error('EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork');
    }
    const params = {
        name,
        chainId,
        networkId: chainId,
        genesis: {
            timestamp,
            gasLimit: parseInt(gasLimit),
            difficulty: parseInt(difficulty),
            nonce,
            extraData,
            mixHash,
            coinbase,
            baseFeePerGas,
        },
        hardfork: undefined,
        hardforks: [],
        bootstrapNodes: [],
        consensus: config.clique !== undefined
            ? {
                type: 'poa',
                algorithm: 'clique',
                clique: {
                    // The recent geth genesis seems to be using blockperiodseconds
                    // and epochlength for clique specification
                    // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ
                    period: config.clique.period ?? config.clique.blockperiodseconds,
                    epoch: config.clique.epoch ?? config.clique.epochlength,
                },
            }
            : {
                type: 'pow',
                algorithm: 'ethash',
                ethash: {},
            },
    };
    const forkMap = {
        [enums_1.Hardfork.Homestead]: { name: 'homesteadBlock' },
        [enums_1.Hardfork.Dao]: { name: 'daoForkBlock' },
        [enums_1.Hardfork.TangerineWhistle]: { name: 'eip150Block' },
        [enums_1.Hardfork.SpuriousDragon]: { name: 'eip155Block' },
        [enums_1.Hardfork.Byzantium]: { name: 'byzantiumBlock' },
        [enums_1.Hardfork.Constantinople]: { name: 'constantinopleBlock' },
        [enums_1.Hardfork.Petersburg]: { name: 'petersburgBlock' },
        [enums_1.Hardfork.Istanbul]: { name: 'istanbulBlock' },
        [enums_1.Hardfork.MuirGlacier]: { name: 'muirGlacierBlock' },
        [enums_1.Hardfork.Berlin]: { name: 'berlinBlock' },
        [enums_1.Hardfork.London]: { name: 'londonBlock' },
        [enums_1.Hardfork.MergeForkIdTransition]: { name: 'mergeForkBlock', postMerge: mergeForkIdPostMerge },
        [enums_1.Hardfork.Shanghai]: { name: 'shanghaiTime', postMerge: true, isTimestamp: true },
        [enums_1.Hardfork.ShardingForkDev]: { name: 'shardingForkTime', postMerge: true, isTimestamp: true },
    };
    // forkMapRev is the map from config field name to Hardfork
    const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
        acc[forkMap[elem].name] = elem;
        return acc;
    }, {});
    const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null);
    params.hardforks = configHardforkNames
        .map((nameBlock) => ({
        name: forkMapRev[nameBlock],
        block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number'
            ? null
            : config[nameBlock],
        timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number'
            ? config[nameBlock]
            : undefined,
    }))
        .filter((fork) => fork.block !== null || fork.timestamp !== undefined);
    params.hardforks.sort(function (a, b) {
        return (a.block ?? Infinity) - (b.block ?? Infinity);
    });
    params.hardforks.sort(function (a, b) {
        return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);
    });
    if (config.terminalTotalDifficulty !== undefined) {
        // Following points need to be considered for placement of merge hf
        // - Merge hardfork can't be placed at genesis
        // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals
        // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL
        //   necessary for e.g. withdrawals
        const mergeConfig = {
            name: enums_1.Hardfork.Merge,
            ttd: config.terminalTotalDifficulty,
            block: null,
        };
        // Merge hardfork has to be placed before first hardfork that is dependent on merge
        const postMergeIndex = params.hardforks.findIndex((hf) => forkMap[hf.name]?.postMerge === true);
        if (postMergeIndex !== -1) {
            params.hardforks.splice(postMergeIndex, 0, mergeConfig);
        }
        else {
            params.hardforks.push(mergeConfig);
        }
    }
    const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;
    params.hardfork = latestHardfork?.name;
    params.hardforks.unshift({ name: enums_1.Hardfork.Chainstart, block: 0 });
    return params;
}
/**
 * Parses a genesis.json exported from Geth into parameters for Common instance
 * @param json representing the Geth genesis file
 * @param name optional chain name
 * @returns parsed params
 */
function parseGethGenesis(json, name, mergeForkIdPostMerge) {
    try {
        if (['config', 'difficulty', 'gasLimit', 'alloc'].some((field) => !(field in json))) {
            throw new Error('Invalid format, expected geth genesis fields missing');
        }
        if (name !== undefined) {
            json.name = name;
        }
        return parseGethParams(json, mergeForkIdPostMerge);
    }
    catch (e) {
        throw new Error(`Error parsing parameters file: ${e.message}`);
    }
}
exports.parseGethGenesis = parseGethGenesis;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\common\\dist\\utils.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\baseTransaction.js", {"./types":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\types.js","@ethereumjs/common":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5CbaseTransaction.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransaction = void 0;
const common_1 = require("@ethereumjs/common");
const util_1 = require("@ethereumjs/util");
const types_1 = require("./types");
/**
 * This base class will likely be subject to further
 * refactoring along the introduction of additional tx types
 * on the Ethereum network.
 *
 * It is therefore not recommended to use directly.
 */
class BaseTransaction {
    constructor(txData, opts) {
        this.cache = {
            hash: undefined,
            dataFee: undefined,
        };
        /**
         * List of tx type defining EIPs,
         * e.g. 1559 (fee market) and 2930 (access lists)
         * for FeeMarketEIP1559Transaction objects
         */
        this.activeCapabilities = [];
        /**
         * The default chain the tx falls back to if no Common
         * is provided and if the chain can't be derived from
         * a passed in chainId (only EIP-2718 typed txs) or
         * EIP-155 signature (legacy txs).
         *
         * @hidden
         */
        this.DEFAULT_CHAIN = common_1.Chain.Mainnet;
        /**
         * The default HF if the tx type is active on that HF
         * or the first greater HF where the tx is active.
         *
         * @hidden
         */
        this.DEFAULT_HARDFORK = common_1.Hardfork.Merge;
        const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
        this._type = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(type)));
        this.txOptions = opts;
        const toB = (0, util_1.toBuffer)(to === '' ? '0x' : to);
        const vB = (0, util_1.toBuffer)(v === '' ? '0x' : v);
        const rB = (0, util_1.toBuffer)(r === '' ? '0x' : r);
        const sB = (0, util_1.toBuffer)(s === '' ? '0x' : s);
        this.nonce = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(nonce === '' ? '0x' : nonce));
        this.gasLimit = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasLimit === '' ? '0x' : gasLimit));
        this.to = toB.length > 0 ? new util_1.Address(toB) : undefined;
        this.value = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(value === '' ? '0x' : value));
        this.data = (0, util_1.toBuffer)(data === '' ? '0x' : data);
        this.v = vB.length > 0 ? (0, util_1.bufferToBigInt)(vB) : undefined;
        this.r = rB.length > 0 ? (0, util_1.bufferToBigInt)(rB) : undefined;
        this.s = sB.length > 0 ? (0, util_1.bufferToBigInt)(sB) : undefined;
        this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
        // geth limits gasLimit to 2^64-1
        this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
        // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)
        this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
    }
    /**
     * Returns the transaction type.
     *
     * Note: legacy txs will return tx type `0`.
     */
    get type() {
        return this._type;
    }
    /**
     * Checks if a tx type defining capability is active
     * on a tx, for example the EIP-1559 fee market mechanism
     * or the EIP-2930 access list feature.
     *
     * Note that this is different from the tx type itself,
     * so EIP-2930 access lists can very well be active
     * on an EIP-1559 tx for example.
     *
     * This method can be useful for feature checks if the
     * tx type is unknown (e.g. when instantiated with
     * the tx factory).
     *
     * See `Capabilites` in the `types` module for a reference
     * on all supported capabilities.
     */
    supports(capability) {
        return this.activeCapabilities.includes(capability);
    }
    validate(stringError = false) {
        const errors = [];
        if (this.getBaseFee() > this.gasLimit) {
            errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
        }
        if (this.isSigned() && !this.verifySignature()) {
            errors.push('Invalid Signature');
        }
        return stringError ? errors : errors.length === 0;
    }
    _validateYParity() {
        const { v } = this;
        if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {
            const msg = this._errorMsg('The y-parity of the transaction should either be 0 or 1');
            throw new Error(msg);
        }
    }
    /**
     * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.
     * Reasoning: https://ethereum.stackexchange.com/a/55728
     */
    _validateHighS() {
        const { s } = this;
        if (this.common.gteHardfork('homestead') && s !== undefined && s > util_1.SECP256K1_ORDER_DIV_2) {
            const msg = this._errorMsg('Invalid Signature: s-values greater than secp256k1n/2 are considered invalid');
            throw new Error(msg);
        }
    }
    /**
     * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
     */
    getBaseFee() {
        const txFee = this.common.param('gasPrices', 'tx');
        let fee = this.getDataFee();
        if (txFee)
            fee += txFee;
        if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {
            const txCreationFee = this.common.param('gasPrices', 'txCreation');
            if (txCreationFee)
                fee += txCreationFee;
        }
        return fee;
    }
    /**
     * The amount of gas paid for the data in this tx
     */
    getDataFee() {
        const txDataZero = this.common.param('gasPrices', 'txDataZero');
        const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero');
        let cost = BigInt(0);
        for (let i = 0; i < this.data.length; i++) {
            this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero);
        }
        if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {
            const dataLength = BigInt(Math.ceil(this.data.length / 32));
            const initCodeCost = this.common.param('gasPrices', 'initCodeWordCost') * dataLength;
            cost += initCodeCost;
        }
        return cost;
    }
    /**
     * If the tx's `to` is to the creation address
     */
    toCreationAddress() {
        return this.to === undefined || this.to.buf.length === 0;
    }
    isSigned() {
        const { v, r, s } = this;
        if (v === undefined || r === undefined || s === undefined) {
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * Determines if the signature is valid
     */
    verifySignature() {
        try {
            // Main signature verification is done in `getSenderPublicKey()`
            const publicKey = this.getSenderPublicKey();
            return (0, util_1.unpadBuffer)(publicKey).length !== 0;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Returns the sender's address
     */
    getSenderAddress() {
        return new util_1.Address((0, util_1.publicToAddress)(this.getSenderPublicKey()));
    }
    /**
     * Signs a transaction.
     *
     * Note that the signed tx is returned as a new object,
     * use as follows:
     * ```javascript
     * const signedTx = tx.sign(privateKey)
     * ```
     */
    sign(privateKey) {
        if (privateKey.length !== 32) {
            const msg = this._errorMsg('Private key must be 32 bytes in length.');
            throw new Error(msg);
        }
        // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature
        // and want to recreate a signature (where EIP155 should be applied)
        // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail
        // 2021-06-23
        let hackApplied = false;
        if (this.type === 0 &&
            this.common.gteHardfork('spuriousDragon') &&
            !this.supports(types_1.Capability.EIP155ReplayProtection)) {
            this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
            hackApplied = true;
        }
        const msgHash = this.getMessageToSign(true);
        const { v, r, s } = (0, util_1.ecsign)(msgHash, privateKey);
        const tx = this._processSignature(v, r, s);
        // Hack part 2
        if (hackApplied) {
            const index = this.activeCapabilities.indexOf(types_1.Capability.EIP155ReplayProtection);
            if (index > -1) {
                this.activeCapabilities.splice(index, 1);
            }
        }
        return tx;
    }
    /**
     * Does chain ID checks on common and returns a common
     * to be used on instantiation
     * @hidden
     *
     * @param common - {@link Common} instance from tx options
     * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)
     */
    _getCommon(common, chainId) {
        // Chain ID provided
        if (chainId !== undefined) {
            const chainIdBigInt = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(chainId));
            if (common) {
                if (common.chainId() !== chainIdBigInt) {
                    const msg = this._errorMsg('The chain ID does not match the chain ID of Common');
                    throw new Error(msg);
                }
                // Common provided, chain ID does match
                // -> Return provided Common
                return common.copy();
            }
            else {
                if (common_1.Common.isSupportedChainId(chainIdBigInt)) {
                    // No Common, chain ID supported by Common
                    // -> Instantiate Common with chain ID
                    return new common_1.Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
                }
                else {
                    // No Common, chain ID not supported by Common
                    // -> Instantiate custom Common derived from DEFAULT_CHAIN
                    return common_1.Common.custom({
                        name: 'custom-chain',
                        networkId: chainIdBigInt,
                        chainId: chainIdBigInt,
                    }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
                }
            }
        }
        else {
            // No chain ID provided
            // -> return Common provided or create new default Common
            return (common?.copy() ?? new common_1.Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK }));
        }
    }
    /**
     * Validates that an object with BigInt values cannot exceed the specified bit limit.
     * @param values Object containing string keys and BigInt values
     * @param bits Number of bits to check (64 or 256)
     * @param cannotEqual Pass true if the number also cannot equal one less the maximum value
     */
    _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
        for (const [key, value] of Object.entries(values)) {
            switch (bits) {
                case 64:
                    if (cannotEqual) {
                        if (value !== undefined && value >= util_1.MAX_UINT64) {
                            const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    else {
                        if (value !== undefined && value > util_1.MAX_UINT64) {
                            const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    break;
                case 256:
                    if (cannotEqual) {
                        if (value !== undefined && value >= util_1.MAX_INTEGER) {
                            const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    else {
                        if (value !== undefined && value > util_1.MAX_INTEGER) {
                            const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    break;
                default: {
                    const msg = this._errorMsg('unimplemented bits value');
                    throw new Error(msg);
                }
            }
        }
    }
    static _validateNotArray(values) {
        const txDataKeys = [
            'nonce',
            'gasPrice',
            'gasLimit',
            'to',
            'value',
            'data',
            'v',
            'r',
            's',
            'type',
            'baseFee',
            'maxFeePerGas',
            'chainId',
        ];
        for (const [key, value] of Object.entries(values)) {
            if (txDataKeys.includes(key)) {
                if (Array.isArray(value)) {
                    throw new Error(`${key} cannot be an array`);
                }
            }
        }
    }
    /**
     * Returns the shared error postfix part for _error() method
     * tx type implementations.
     */
    _getSharedErrorPostfix() {
        let hash = '';
        try {
            hash = this.isSigned() ? (0, util_1.bufferToHex)(this.hash()) : 'not available (unsigned)';
        }
        catch (e) {
            hash = 'error';
        }
        let isSigned = '';
        try {
            isSigned = this.isSigned().toString();
        }
        catch (e) {
            hash = 'error';
        }
        let hf = '';
        try {
            hf = this.common.hardfork();
        }
        catch (e) {
            hf = 'error';
        }
        let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;
        postfix += `signed=${isSigned} hf=${hf}`;
        return postfix;
    }
}
exports.BaseTransaction = BaseTransaction;
//# sourceMappingURL=baseTransaction.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\baseTransaction.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Cconstants.js
      return function (require, module, exports) {
"use strict";
/** EIP4844 constants */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BYTES_PER_FIELD_ELEMENT = exports.FIELD_ELEMENTS_PER_BLOB = exports.MAX_TX_WRAP_KZG_COMMITMENTS = exports.LIMIT_BLOBS_PER_TX = exports.MAX_VERSIONED_HASHES_LIST_SIZE = exports.MAX_ACCESS_LIST_SIZE = exports.MAX_CALLDATA_SIZE = void 0;
exports.MAX_CALLDATA_SIZE = 16777216; // 2 ** 24
exports.MAX_ACCESS_LIST_SIZE = 16777216; // 2 ** 24
exports.MAX_VERSIONED_HASHES_LIST_SIZE = 16777216; // 2 ** 24
exports.LIMIT_BLOBS_PER_TX = 16777216; // 2 ** 24
exports.MAX_TX_WRAP_KZG_COMMITMENTS = 16777216; // 2 ** 24
exports.FIELD_ELEMENTS_PER_BLOB = 4096; // This is also in the Common 4844 parameters but needed here since types can't access Common params
exports.BYTES_PER_FIELD_ELEMENT = 32;
//# sourceMappingURL=constants.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\constants.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip1559Transaction.js", {"./baseTransaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\baseTransaction.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\util.js","@ethereumjs/rlp":"F:\\metamask-extension\\node_modules\\@ethereumjs\\rlp\\dist\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\keccak.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Ceip1559Transaction.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeeMarketEIP1559Transaction = void 0;
const rlp_1 = require("@ethereumjs/rlp");
const util_1 = require("@ethereumjs/util");
const keccak_1 = require("ethereum-cryptography/keccak");
const baseTransaction_1 = require("./baseTransaction");
const util_2 = require("./util");
const TRANSACTION_TYPE = 2;
const TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex');
/**
 * Typed transaction with a new gas fee market mechanism
 *
 * - TransactionType: 2
 * - EIP: [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)
 */
class FeeMarketEIP1559Transaction extends baseTransaction_1.BaseTransaction {
    /**
     * This constructor takes the values, validates them, assigns them and freezes the object.
     *
     * It is not recommended to use this constructor directly. Instead use
     * the static factory methods to assist in creating a Transaction object from
     * varying data types.
     */
    constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        /**
         * The default HF if the tx type is active on that HF
         * or the first greater HF where the tx is active.
         *
         * @hidden
         */
        this.DEFAULT_HARDFORK = 'london';
        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (this.common.isActivatedEIP(1559) === false) {
            throw new Error('EIP-1559 not enabled on Common');
        }
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        // Populate the access list fields
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        // Verify the access list format.
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === '' ? '0x' : maxFeePerGas));
        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === '' ? '0x' : maxPriorityFeePerGas));
        this._validateCannotExceedMaxInteger({
            maxFeePerGas: this.maxFeePerGas,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas,
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {
            const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)');
            throw new Error(msg);
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
            const msg = this._errorMsg('maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)');
            throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        if (this.common.isActivatedEIP(3860)) {
            (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        const freeze = opts?.freeze ?? true;
        if (freeze) {
            Object.freeze(this);
        }
    }
    /**
     * Instantiate a transaction from a data dictionary.
     *
     * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, v, r, s }
     *
     * Notes:
     * - `chainId` will be set automatically if not provided
     * - All parameters are optional and have some basic default values
     */
    static fromTxData(txData, opts = {}) {
        return new FeeMarketEIP1559Transaction(txData, opts);
    }
    /**
     * Instantiate a transaction from the serialized tx.
     *
     * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS])`
     */
    static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
            throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized
                .slice(0, 1)
                .toString('hex')}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(serialized.slice(1)));
        if (!Array.isArray(values)) {
            throw new Error('Invalid serialized tx input: must be array');
        }
        return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
    }
    /**
     * Create a transaction from a values array.
     *
     * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS]`
     */
    static fromValuesArray(values, opts = {}) {
        if (values.length !== 9 && values.length !== 12) {
            throw new Error('Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).');
        }
        const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s,] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
        return new FeeMarketEIP1559Transaction({
            chainId: (0, util_1.bufferToBigInt)(chainId),
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gasLimit,
            to,
            value,
            data,
            accessList: accessList ?? [],
            v: v !== undefined ? (0, util_1.bufferToBigInt)(v) : undefined,
            r,
            s,
        }, opts);
    }
    /**
     * The amount of gas paid for the data in this tx
     */
    getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
            return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
            this.cache.dataFee = {
                value: cost,
                hardfork: this.common.hardfork(),
            };
        }
        return cost;
    }
    /**
     * The up front amount that an account must have for this transaction to be valid
     * @param baseFee The base fee of the block (will be set to 0 if not provided)
     */
    getUpfrontCost(baseFee = BigInt(0)) {
        const prio = this.maxPriorityFeePerGas;
        const maxBase = this.maxFeePerGas - baseFee;
        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
        const gasPrice = inclusionFeePerGas + baseFee;
        return this.gasLimit * gasPrice + this.value;
    }
    /**
     * Returns a Buffer Array of the raw Buffers of the EIP-1559 transaction, in order.
     *
     * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS]`
     *
     * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block
     * with {@link Block.fromValuesArray}.
     *
     * For an unsigned tx this method uses the empty Buffer values for the
     * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
     * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.
     */
    raw() {
        return [
            (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
            (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
            (0, util_1.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),
            (0, util_1.bigIntToUnpaddedBuffer)(this.maxFeePerGas),
            (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
            this.to !== undefined ? this.to.buf : Buffer.from([]),
            (0, util_1.bigIntToUnpaddedBuffer)(this.value),
            this.data,
            this.accessList,
            this.v !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
            this.r !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
            this.s !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([]),
        ];
    }
    /**
     * Returns the serialized encoding of the EIP-1559 transaction.
     *
     * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS])`
     *
     * Note that in contrast to the legacy tx serialization format this is not
     * valid RLP any more due to the raw tx type preceding and concatenated to
     * the RLP encoding of the values.
     */
    serialize() {
        const base = this.raw();
        return Buffer.concat([
            TRANSACTION_TYPE_BUFFER,
            Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base))),
        ]);
    }
    /**
     * Returns the serialized unsigned tx (hashed or raw), which can be used
     * to sign the transaction (e.g. for sending to a hardware wallet).
     *
     * Note: in contrast to the legacy tx the raw message format is already
     * serialized and doesn't need to be RLP encoded any more.
     *
     * ```javascript
     * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
     * ```
     *
     * @param hashMessage - Return hashed message if set to true (default: true)
     */
    getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 9);
        const message = Buffer.concat([
            TRANSACTION_TYPE_BUFFER,
            Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base))),
        ]);
        if (hashMessage) {
            return Buffer.from((0, keccak_1.keccak256)(message));
        }
        else {
            return message;
        }
    }
    /**
     * Computes a sha3-256 hash of the serialized tx.
     *
     * This method can only be used for signed txs (it throws otherwise).
     * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
     */
    hash() {
        if (!this.isSigned()) {
            const msg = this._errorMsg('Cannot call hash method if transaction is not signed');
            throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
            if (!this.cache.hash) {
                this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
            }
            return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
    }
    /**
     * Computes a sha3-256 hash which can be used to verify the signature
     */
    getMessageToVerifySignature() {
        return this.getMessageToSign();
    }
    /**
     * Returns the public key of the sender
     */
    getSenderPublicKey() {
        if (!this.isSigned()) {
            const msg = this._errorMsg('Cannot call this method if transaction is not signed');
            throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
            return (0, util_1.ecrecover)(msgHash, v + BigInt(27), // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s));
        }
        catch (e) {
            const msg = this._errorMsg('Invalid Signature');
            throw new Error(msg);
        }
    }
    _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return FeeMarketEIP1559Transaction.fromTxData({
            chainId: this.chainId,
            nonce: this.nonce,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas,
            maxFeePerGas: this.maxFeePerGas,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            accessList: this.accessList,
            v: v - BigInt(27),
            r: (0, util_1.bufferToBigInt)(r),
            s: (0, util_1.bufferToBigInt)(s),
        }, opts);
    }
    /**
     * Returns an object with the JSON representation of the transaction
     */
    toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
            chainId: (0, util_1.bigIntToHex)(this.chainId),
            nonce: (0, util_1.bigIntToHex)(this.nonce),
            maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),
            maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),
            gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
            to: this.to !== undefined ? this.to.toString() : undefined,
            value: (0, util_1.bigIntToHex)(this.value),
            data: '0x' + this.data.toString('hex'),
            accessList: accessListJSON,
            v: this.v !== undefined ? (0, util_1.bigIntToHex)(this.v) : undefined,
            r: this.r !== undefined ? (0, util_1.bigIntToHex)(this.r) : undefined,
            s: this.s !== undefined ? (0, util_1.bigIntToHex)(this.s) : undefined,
        };
    }
    /**
     * Return a compact error string representation of the object
     */
    errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
        return errorStr;
    }
    /**
     * Internal helper function to create an annotated error message
     *
     * @param msg Base error message
     * @hidden
     */
    _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
    }
}
exports.FeeMarketEIP1559Transaction = FeeMarketEIP1559Transaction;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip1559Transaction.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip2930Transaction.js", {"./baseTransaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\baseTransaction.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\util.js","@ethereumjs/rlp":"F:\\metamask-extension\\node_modules\\@ethereumjs\\rlp\\dist\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\keccak.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Ceip2930Transaction.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessListEIP2930Transaction = void 0;
const rlp_1 = require("@ethereumjs/rlp");
const util_1 = require("@ethereumjs/util");
const keccak_1 = require("ethereum-cryptography/keccak");
const baseTransaction_1 = require("./baseTransaction");
const util_2 = require("./util");
const TRANSACTION_TYPE = 1;
const TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex');
/**
 * Typed transaction with optional access lists
 *
 * - TransactionType: 1
 * - EIP: [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)
 */
class AccessListEIP2930Transaction extends baseTransaction_1.BaseTransaction {
    /**
     * This constructor takes the values, validates them, assigns them and freezes the object.
     *
     * It is not recommended to use this constructor directly. Instead use
     * the static factory methods to assist in creating a Transaction object from
     * varying data types.
     */
    constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        /**
         * The default HF if the tx type is active on that HF
         * or the first greater HF where the tx is active.
         *
         * @hidden
         */
        this.DEFAULT_HARDFORK = 'berlin';
        const { chainId, accessList, gasPrice } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        // EIP-2718 check is done in Common
        if (!this.common.isActivatedEIP(2930)) {
            throw new Error('EIP-2930 not enabled on Common');
        }
        this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
        // Populate the access list fields
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        // Verify the access list format.
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasPrice === '' ? '0x' : gasPrice));
        this._validateCannotExceedMaxInteger({
            gasPrice: this.gasPrice,
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
            const msg = this._errorMsg('gasLimit * gasPrice cannot exceed MAX_INTEGER');
            throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        if (this.common.isActivatedEIP(3860)) {
            (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        const freeze = opts?.freeze ?? true;
        if (freeze) {
            Object.freeze(this);
        }
    }
    /**
     * Instantiate a transaction from a data dictionary.
     *
     * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
     * v, r, s }
     *
     * Notes:
     * - `chainId` will be set automatically if not provided
     * - All parameters are optional and have some basic default values
     */
    static fromTxData(txData, opts = {}) {
        return new AccessListEIP2930Transaction(txData, opts);
    }
    /**
     * Instantiate a transaction from the serialized tx.
     *
     * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
     * signatureYParity (v), signatureR (r), signatureS (s)])`
     */
    static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
            throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized
                .slice(0, 1)
                .toString('hex')}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized.slice(1))));
        if (!Array.isArray(values)) {
            throw new Error('Invalid serialized tx input: must be array');
        }
        return AccessListEIP2930Transaction.fromValuesArray(values, opts);
    }
    /**
     * Create a transaction from a values array.
     *
     * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
     * signatureYParity (v), signatureR (r), signatureS (s)]`
     */
    static fromValuesArray(values, opts = {}) {
        if (values.length !== 8 && values.length !== 11) {
            throw new Error('Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).');
        }
        const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        const emptyAccessList = [];
        return new AccessListEIP2930Transaction({
            chainId: (0, util_1.bufferToBigInt)(chainId),
            nonce,
            gasPrice,
            gasLimit,
            to,
            value,
            data,
            accessList: accessList ?? emptyAccessList,
            v: v !== undefined ? (0, util_1.bufferToBigInt)(v) : undefined,
            r,
            s,
        }, opts);
    }
    /**
     * The amount of gas paid for the data in this tx
     */
    getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
            return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
            this.cache.dataFee = {
                value: cost,
                hardfork: this.common.hardfork(),
            };
        }
        return cost;
    }
    /**
     * The up front amount that an account must have for this transaction to be valid
     */
    getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
    }
    /**
     * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.
     *
     * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
     * signatureYParity (v), signatureR (r), signatureS (s)]`
     *
     * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block
     * with {@link Block.fromValuesArray}.
     *
     * For an unsigned tx this method uses the empty Buffer values for the
     * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
     * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.
     */
    raw() {
        return [
            (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
            (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
            (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
            (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
            this.to !== undefined ? this.to.buf : Buffer.from([]),
            (0, util_1.bigIntToUnpaddedBuffer)(this.value),
            this.data,
            this.accessList,
            this.v !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
            this.r !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
            this.s !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([]),
        ];
    }
    /**
     * Returns the serialized encoding of the EIP-2930 transaction.
     *
     * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
     * signatureYParity (v), signatureR (r), signatureS (s)])`
     *
     * Note that in contrast to the legacy tx serialization format this is not
     * valid RLP any more due to the raw tx type preceding and concatenated to
     * the RLP encoding of the values.
     */
    serialize() {
        const base = this.raw();
        return Buffer.concat([
            TRANSACTION_TYPE_BUFFER,
            Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base))),
        ]);
    }
    /**
     * Returns the serialized unsigned tx (hashed or raw), which can be used
     * to sign the transaction (e.g. for sending to a hardware wallet).
     *
     * Note: in contrast to the legacy tx the raw message format is already
     * serialized and doesn't need to be RLP encoded any more.
     *
     * ```javascript
     * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
     * ```
     *
     * @param hashMessage - Return hashed message if set to true (default: true)
     */
    getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 8);
        const message = Buffer.concat([
            TRANSACTION_TYPE_BUFFER,
            Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base))),
        ]);
        if (hashMessage) {
            return Buffer.from((0, keccak_1.keccak256)(message));
        }
        else {
            return message;
        }
    }
    /**
     * Computes a sha3-256 hash of the serialized tx.
     *
     * This method can only be used for signed txs (it throws otherwise).
     * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
     */
    hash() {
        if (!this.isSigned()) {
            const msg = this._errorMsg('Cannot call hash method if transaction is not signed');
            throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
            if (!this.cache.hash) {
                this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
            }
            return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
    }
    /**
     * Computes a sha3-256 hash which can be used to verify the signature
     */
    getMessageToVerifySignature() {
        return this.getMessageToSign();
    }
    /**
     * Returns the public key of the sender
     */
    getSenderPublicKey() {
        if (!this.isSigned()) {
            const msg = this._errorMsg('Cannot call this method if transaction is not signed');
            throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
            return (0, util_1.ecrecover)(msgHash, v + BigInt(27), // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s));
        }
        catch (e) {
            const msg = this._errorMsg('Invalid Signature');
            throw new Error(msg);
        }
    }
    _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return AccessListEIP2930Transaction.fromTxData({
            chainId: this.chainId,
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            accessList: this.accessList,
            v: v - BigInt(27),
            r: (0, util_1.bufferToBigInt)(r),
            s: (0, util_1.bufferToBigInt)(s),
        }, opts);
    }
    /**
     * Returns an object with the JSON representation of the transaction
     */
    toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
            chainId: (0, util_1.bigIntToHex)(this.chainId),
            nonce: (0, util_1.bigIntToHex)(this.nonce),
            gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
            gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
            to: this.to !== undefined ? this.to.toString() : undefined,
            value: (0, util_1.bigIntToHex)(this.value),
            data: '0x' + this.data.toString('hex'),
            accessList: accessListJSON,
            v: this.v !== undefined ? (0, util_1.bigIntToHex)(this.v) : undefined,
            r: this.r !== undefined ? (0, util_1.bigIntToHex)(this.r) : undefined,
            s: this.s !== undefined ? (0, util_1.bigIntToHex)(this.s) : undefined,
        };
    }
    /**
     * Return a compact error string representation of the object
     */
    errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        // Keep ? for this.accessList since this otherwise causes Hardhat E2E tests to fail
        errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`;
        return errorStr;
    }
    /**
     * Internal helper function to create an annotated error message
     *
     * @param msg Base error message
     * @hidden
     */
    _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
    }
}
exports.AccessListEIP2930Transaction = AccessListEIP2930Transaction;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip2930Transaction.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip4844Transaction.js", {"./baseTransaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\baseTransaction.js","./constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\constants.js","./kzg/kzg":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\kzg\\kzg.js","./types":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\types.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\util.js","./utils/blobHelpers":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\utils\\blobHelpers.js","@chainsafe/ssz":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\keccak.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Ceip4844Transaction.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobEIP4844Transaction = void 0;
const ssz_1 = require("@chainsafe/ssz");
const util_1 = require("@ethereumjs/util");
const keccak_1 = require("ethereum-cryptography/keccak");
const baseTransaction_1 = require("./baseTransaction");
const constants_1 = require("./constants");
const kzg_1 = require("./kzg/kzg");
const types_1 = require("./types");
const util_2 = require("./util");
const blobHelpers_1 = require("./utils/blobHelpers");
const TRANSACTION_TYPE = 0x05;
const TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex');
const validateBlobTransactionNetworkWrapper = (versionedHashes, blobs, commitments, kzgProof, version) => {
    if (!(versionedHashes.length === blobs.length && blobs.length === commitments.length)) {
        throw new Error('Number of versionedHashes, blobs, and commitments not all equal');
    }
    try {
        kzg_1.kzg.verifyAggregateKzgProof(blobs, commitments, kzgProof);
    }
    catch (e) {
        throw new Error('KZG proof cannot be verified from blobs/commitments');
    }
    for (let x = 0; x < versionedHashes.length; x++) {
        const computedVersionedHash = (0, blobHelpers_1.computeVersionedHash)(commitments[x], version);
        if (!(0, ssz_1.byteArrayEquals)(computedVersionedHash, versionedHashes[x])) {
            throw new Error(`commitment for blob at index ${x} does not match versionedHash`);
        }
    }
};
/**
 * Typed transaction with a new gas fee market mechanism for transactions that include "blobs" of data
 *
 * - TransactionType: 5
 * - EIP: [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)
 */
class BlobEIP4844Transaction extends baseTransaction_1.BaseTransaction {
    /**
     * This constructor takes the values, validates them, assigns them and freezes the object.
     *
     * It is not recommended to use this constructor directly. Instead use
     * the static constructors or factory methods to assist in creating a Transaction object from
     * varying data types.
     */
    constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas, maxFeePerDataGas } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (this.common.isActivatedEIP(1559) === false) {
            throw new Error('EIP-1559 not enabled on Common');
        }
        if (this.common.isActivatedEIP(4844) === false) {
            throw new Error('EIP-4844 not enabled on Common');
        }
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        // Populate the access list fields
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        // Verify the access list format.
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === '' ? '0x' : maxFeePerGas));
        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === '' ? '0x' : maxPriorityFeePerGas));
        this._validateCannotExceedMaxInteger({
            maxFeePerGas: this.maxFeePerGas,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas,
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {
            const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)');
            throw new Error(msg);
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
            const msg = this._errorMsg('maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)');
            throw new Error(msg);
        }
        this.maxFeePerDataGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)((maxFeePerDataGas ?? '') === '' ? '0x' : maxFeePerDataGas));
        this.versionedHashes = (txData.versionedHashes ?? []).map((vh) => (0, util_1.toBuffer)(vh));
        this._validateYParity();
        this._validateHighS();
        if (this.common.isActivatedEIP(3860)) {
            (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        for (const hash of this.versionedHashes) {
            if (hash.length !== 32) {
                const msg = this._errorMsg('versioned hash is invalid length');
                throw new Error(msg);
            }
            if (BigInt(hash[0]) !== this.common.paramByEIP('sharding', 'blobCommitmentVersionKzg', 4844)) {
                const msg = this._errorMsg('versioned hash does not start with KZG commitment version');
                throw new Error(msg);
            }
        }
        if (this.versionedHashes.length > constants_1.LIMIT_BLOBS_PER_TX) {
            const msg = this._errorMsg(`tx can contain at most ${constants_1.LIMIT_BLOBS_PER_TX} blobs`);
            throw new Error(msg);
        }
        this.blobs = txData.blobs?.map((blob) => (0, util_1.toBuffer)(blob));
        this.kzgCommitments = txData.kzgCommitments?.map((commitment) => (0, util_1.toBuffer)(commitment));
        this.aggregateKzgProof = (0, util_1.toBuffer)(txData.kzgProof);
        const freeze = opts?.freeze ?? true;
        if (freeze) {
            Object.freeze(this);
        }
    }
    static fromTxData(txData, opts) {
        return new BlobEIP4844Transaction(txData, opts);
    }
    /**
     * Creates the minimal representation of a blob transaction from the network wrapper version.
     * The minimal representation is used when adding transactions to an execution payload/block
     * @param txData a {@link BlobEIP4844Transaction} containing optional blobs/kzg commitments
     * @param opts - dictionary of {@link TxOptions}
     * @returns the "minimal" representation of a BlobEIP4844Transaction (i.e. transaction object minus blobs and kzg commitments)
     */
    static minimalFromNetworkWrapper(txData, opts) {
        const tx = BlobEIP4844Transaction.fromTxData({
            ...txData,
            ...{ blobs: undefined, kzgCommitments: undefined, kzgProof: undefined },
        }, opts);
        return tx;
    }
    /**
     * Creates a transaction from the network encoding of a blob transaction (with blobs/commitments/proof)
     * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper
     * @param opts any TxOptions defined
     * @returns a BlobEIP4844Transaction
     * @throws if no KZG library is loaded -- using the `initKzg` helper method -- or if `opts.common` not provided
     */
    static fromSerializedBlobTxNetworkWrapper(serialized, opts) {
        if (!opts || !opts.common) {
            throw new Error('common instance required to validate versioned hashes');
        }
        // Validate network wrapper
        const wrapper = types_1.BlobNetworkTransactionWrapper.deserialize(serialized.slice(1));
        const decodedTx = wrapper.tx.message;
        const version = Number(opts.common.paramByEIP('sharding', 'blobCommitmentVersionKzg', 4844));
        validateBlobTransactionNetworkWrapper(decodedTx.blobVersionedHashes, wrapper.blobs, wrapper.blobKzgs, wrapper.kzgAggregatedProof, version);
        const accessList = [];
        for (const listItem of decodedTx.accessList) {
            const address = Buffer.from(listItem.address);
            const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));
            const accessListItem = [address, storageKeys];
            accessList.push(accessListItem);
        }
        const to = decodedTx.to.value === null
            ? undefined
            : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(decodedTx.to.value)));
        const versionedHashes = decodedTx.blobVersionedHashes.map((el) => Buffer.from(el));
        const commitments = wrapper.blobKzgs.map((el) => Buffer.from(el));
        const blobs = wrapper.blobs.map((el) => Buffer.from(el));
        const txData = {
            ...decodedTx,
            ...{
                versionedHashes,
                accessList,
                to,
                blobs,
                kzgCommitments: commitments,
                kzgProof: Buffer.from(wrapper.kzgAggregatedProof),
                r: wrapper.tx.signature.r,
                s: wrapper.tx.signature.s,
                v: BigInt(wrapper.tx.signature.yParity),
                gasLimit: decodedTx.gas,
                maxFeePerGas: decodedTx.maxFeePerGas,
                maxPriorityFeePerGas: decodedTx.maxPriorityFeePerGas,
            },
        };
        return new BlobEIP4844Transaction(txData, opts);
    }
    /**
     * Creates a transaction from the "minimal" encoding of a blob transaction (without blobs/commitments/kzg proof)
     * @param serialized a buffer representing a serialized signed blob transaction
     * @param opts any TxOptions defined
     * @returns a BlobEIP4844Transaction
     */
    static fromSerializedTx(serialized, opts) {
        const decoded = types_1.SignedBlobTransactionType.deserialize(serialized.slice(1));
        const tx = decoded.message;
        const accessList = [];
        for (const listItem of tx.accessList) {
            const address = Buffer.from(listItem.address);
            const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));
            const accessListItem = [address, storageKeys];
            accessList.push(accessListItem);
        }
        const to = tx.to.value === null ? undefined : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(tx.to.value)));
        const versionedHashes = tx.blobVersionedHashes.map((el) => Buffer.from(el));
        const txData = {
            ...tx,
            ...{
                versionedHashes,
                to,
                accessList,
                r: decoded.signature.r,
                s: decoded.signature.s,
                v: BigInt(decoded.signature.yParity),
                gasLimit: decoded.message.gas,
            },
        };
        return new BlobEIP4844Transaction(txData, opts);
    }
    /**
     * The up front amount that an account must have for this transaction to be valid
     * @param baseFee The base fee of the block (will be set to 0 if not provided)
     */
    getUpfrontCost(baseFee = BigInt(0)) {
        const prio = this.maxPriorityFeePerGas;
        const maxBase = this.maxFeePerGas - baseFee;
        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
        const gasPrice = inclusionFeePerGas + baseFee;
        return this.gasLimit * gasPrice + this.value;
    }
    /**
     * This method is not implemented for blob transactions as the `raw` method is used exclusively with
     * rlp encoding and these transactions use SSZ for serialization.
     */
    raw() {
        throw new Error('Method not implemented.');
    }
    toValue() {
        const to = {
            selector: this.to !== undefined ? 1 : 0,
            value: this.to?.toBuffer() ?? null,
        };
        return {
            message: {
                chainId: this.common.chainId(),
                nonce: this.nonce,
                maxPriorityFeePerGas: this.maxPriorityFeePerGas,
                maxFeePerGas: this.maxFeePerGas,
                gas: this.gasLimit,
                to,
                value: this.value,
                data: this.data,
                accessList: this.accessList.map((listItem) => {
                    return { address: listItem[0], storageKeys: listItem[1] };
                }),
                blobVersionedHashes: this.versionedHashes,
                maxFeePerDataGas: this.maxFeePerDataGas,
            },
            // TODO: Decide how to serialize an unsigned transaction
            signature: {
                r: this.r ?? BigInt(0),
                s: this.s ?? BigInt(0),
                yParity: this.v === BigInt(1) ? true : false,
            },
        };
    }
    /**
     * Serialize a blob transaction to the execution payload variant
     * @returns the minimum (execution payload) serialization of a signed transaction
     */
    serialize() {
        const sszEncodedTx = types_1.SignedBlobTransactionType.serialize(this.toValue());
        return Buffer.concat([TRANSACTION_TYPE_BUFFER, sszEncodedTx]);
    }
    /**
     * @returns the serialized form of a blob transaction in the network wrapper format (used for gossipping mempool transactions over devp2p)
     */
    serializeNetworkWrapper() {
        if (this.blobs === undefined ||
            this.kzgCommitments === undefined ||
            this.aggregateKzgProof === undefined) {
            throw new Error('cannot serialize network wrapper without blobs, KZG commitments and aggregate KZG proof provided');
        }
        const to = {
            selector: this.to !== undefined ? 1 : 0,
            value: this.to?.toBuffer() ?? null,
        };
        const blobArrays = this.blobs?.map((blob) => Uint8Array.from(blob)) ?? [];
        const serializedTxWrapper = types_1.BlobNetworkTransactionWrapper.serialize({
            blobs: blobArrays,
            blobKzgs: this.kzgCommitments?.map((commitment) => Uint8Array.from(commitment)) ?? [],
            tx: { ...(0, util_2.blobTxToNetworkWrapperDataFormat)(this), ...to },
            kzgAggregatedProof: Uint8Array.from(this.aggregateKzgProof ?? []),
        });
        return Buffer.concat([Buffer.from([0x05]), serializedTxWrapper]);
    }
    getMessageToSign(_hashMessage) {
        return this.unsignedHash();
    }
    /**
     * Returns the hash of a blob transaction
     */
    unsignedHash() {
        const serializedTx = types_1.BlobTransactionType.serialize(this.toValue().message);
        return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([TRANSACTION_TYPE_BUFFER, serializedTx])));
    }
    hash() {
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
    }
    getMessageToVerifySignature() {
        return this.getMessageToSign();
    }
    /**
     * Returns the public key of the sender
     */
    getSenderPublicKey() {
        if (!this.isSigned()) {
            const msg = this._errorMsg('Cannot call this method if transaction is not signed');
            throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
            return (0, util_1.ecrecover)(msgHash, v + BigInt(27), // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s));
        }
        catch (e) {
            const msg = this._errorMsg('Invalid Signature');
            throw new Error(msg);
        }
    }
    toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
            chainId: (0, util_1.bigIntToHex)(this.chainId),
            nonce: (0, util_1.bigIntToHex)(this.nonce),
            maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),
            maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),
            gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
            to: this.to !== undefined ? this.to.toString() : undefined,
            value: (0, util_1.bigIntToHex)(this.value),
            data: '0x' + this.data.toString('hex'),
            accessList: accessListJSON,
            v: this.v !== undefined ? (0, util_1.bigIntToHex)(this.v) : undefined,
            r: this.r !== undefined ? (0, util_1.bigIntToHex)(this.r) : undefined,
            s: this.s !== undefined ? (0, util_1.bigIntToHex)(this.s) : undefined,
            maxFeePerDataGas: (0, util_1.bigIntToHex)(this.maxFeePerDataGas),
            versionedHashes: this.versionedHashes.map((hash) => (0, util_1.bufferToHex)(hash)),
        };
    }
    _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return BlobEIP4844Transaction.fromTxData({
            chainId: this.chainId,
            nonce: this.nonce,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas,
            maxFeePerGas: this.maxFeePerGas,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            accessList: this.accessList,
            v: v - BigInt(27),
            r: (0, util_1.bufferToBigInt)(r),
            s: (0, util_1.bufferToBigInt)(s),
            maxFeePerDataGas: this.maxFeePerDataGas,
            versionedHashes: this.versionedHashes,
            blobs: this.blobs,
            kzgCommitments: this.kzgCommitments,
            kzgProof: this.aggregateKzgProof,
        }, opts);
    }
    /**
     * Return a compact error string representation of the object
     */
    errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
        return errorStr;
    }
    /**
     * Internal helper function to create an annotated error message
     *
     * @param msg Base error message
     * @hidden
     */
    _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
    }
    /**
     * @returns the number of blobs included with this transaction
     */
    numBlobs() {
        return this.versionedHashes.length;
    }
}
exports.BlobEIP4844Transaction = BlobEIP4844Transaction;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip4844Transaction.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\fromRpc.js", {"@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5CfromRpc.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeTxParams = void 0;
const util_1 = require("@ethereumjs/util");
const normalizeTxParams = (_txParams) => {
    const txParams = Object.assign({}, _txParams);
    txParams.gasLimit = (0, util_1.toType)(txParams.gasLimit ?? txParams.gas, util_1.TypeOutput.BigInt);
    txParams.data = txParams.data === undefined ? txParams.input : txParams.data;
    // check and convert gasPrice and value params
    txParams.gasPrice = txParams.gasPrice !== undefined ? BigInt(txParams.gasPrice) : undefined;
    txParams.value = txParams.value !== undefined ? BigInt(txParams.value) : undefined;
    // strict byte length checking
    txParams.to =
        txParams.to !== null && txParams.to !== undefined
            ? (0, util_1.setLengthLeft)((0, util_1.toBuffer)(txParams.to), 20)
            : null;
    txParams.v = (0, util_1.toType)(txParams.v, util_1.TypeOutput.BigInt);
    return txParams;
};
exports.normalizeTxParams = normalizeTxParams;
//# sourceMappingURL=fromRpc.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\fromRpc.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\index.js", {"./eip1559Transaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip1559Transaction.js","./eip2930Transaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip2930Transaction.js","./eip4844Transaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip4844Transaction.js","./kzg/kzg":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\kzg\\kzg.js","./legacyTransaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\legacyTransaction.js","./transactionFactory":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\transactionFactory.js","./types":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\types.js","./utils/blobHelpers":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\utils\\blobHelpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeVersionedHash = exports.TransactionFactory = exports.Transaction = exports.kzg = exports.initKZG = exports.BlobEIP4844Transaction = exports.AccessListEIP2930Transaction = exports.FeeMarketEIP1559Transaction = void 0;
var eip1559Transaction_1 = require("./eip1559Transaction");
Object.defineProperty(exports, "FeeMarketEIP1559Transaction", { enumerable: true, get: function () { return eip1559Transaction_1.FeeMarketEIP1559Transaction; } });
var eip2930Transaction_1 = require("./eip2930Transaction");
Object.defineProperty(exports, "AccessListEIP2930Transaction", { enumerable: true, get: function () { return eip2930Transaction_1.AccessListEIP2930Transaction; } });
var eip4844Transaction_1 = require("./eip4844Transaction");
Object.defineProperty(exports, "BlobEIP4844Transaction", { enumerable: true, get: function () { return eip4844Transaction_1.BlobEIP4844Transaction; } });
var kzg_1 = require("./kzg/kzg");
Object.defineProperty(exports, "initKZG", { enumerable: true, get: function () { return kzg_1.initKZG; } });
Object.defineProperty(exports, "kzg", { enumerable: true, get: function () { return kzg_1.kzg; } });
var legacyTransaction_1 = require("./legacyTransaction");
Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return legacyTransaction_1.Transaction; } });
var transactionFactory_1 = require("./transactionFactory");
Object.defineProperty(exports, "TransactionFactory", { enumerable: true, get: function () { return transactionFactory_1.TransactionFactory; } });
__exportStar(require("./types"), exports);
var blobHelpers_1 = require("./utils/blobHelpers");
Object.defineProperty(exports, "computeVersionedHash", { enumerable: true, get: function () { return blobHelpers_1.computeVersionedHash; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\kzg\\kzg.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Ckzg%5Ckzg.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initKZG = exports.kzg = void 0;
function kzgNotLoaded() {
    throw Error('kzg library not loaded');
}
// eslint-disable-next-line import/no-mutable-exports
exports.kzg = {
    freeTrustedSetup: kzgNotLoaded,
    loadTrustedSetup: kzgNotLoaded,
    blobToKzgCommitment: kzgNotLoaded,
    computeAggregateKzgProof: kzgNotLoaded,
    verifyKzgProof: kzgNotLoaded,
    verifyAggregateKzgProof: kzgNotLoaded,
};
/**
 * @param kzgLib a KZG implementation (defaults to c-kzg)
 * @param trustedSetupPath the full path (e.g. "/home/linux/devnet4.txt") to a kzg trusted setup text file
 */
function initKZG(kzgLib, trustedSetupPath) {
    exports.kzg = kzgLib;
    exports.kzg.loadTrustedSetup(trustedSetupPath);
}
exports.initKZG = initKZG;
//# sourceMappingURL=kzg.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\kzg\\kzg.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\legacyTransaction.js", {"./baseTransaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\baseTransaction.js","./types":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\types.js","./util":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\util.js","@ethereumjs/rlp":"F:\\metamask-extension\\node_modules\\@ethereumjs\\rlp\\dist\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\keccak.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5ClegacyTransaction.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const rlp_1 = require("@ethereumjs/rlp");
const util_1 = require("@ethereumjs/util");
const keccak_1 = require("ethereum-cryptography/keccak");
const baseTransaction_1 = require("./baseTransaction");
const types_1 = require("./types");
const util_2 = require("./util");
const TRANSACTION_TYPE = 0;
function meetsEIP155(_v, chainId) {
    const v = Number(_v);
    const chainIdDoubled = Number(chainId) * 2;
    return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
}
/**
 * An Ethereum non-typed (legacy) transaction
 */
class Transaction extends baseTransaction_1.BaseTransaction {
    /**
     * This constructor takes the values, validates them, assigns them and freezes the object.
     *
     * It is not recommended to use this constructor directly. Instead use
     * the static factory methods to assist in creating a Transaction object from
     * varying data types.
     */
    constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.common = this._validateTxV(this.v, opts.common);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.gasPrice === '' ? '0x' : txData.gasPrice));
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
            const msg = this._errorMsg('gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)');
            throw new Error(msg);
        }
        this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.common.gteHardfork('spuriousDragon')) {
            if (!this.isSigned()) {
                this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
            }
            else {
                // EIP155 spec:
                // If block.number >= 2,675,000 and v = CHAIN_ID * 2 + 35 or v = CHAIN_ID * 2 + 36
                // then when computing the hash of a transaction for purposes of signing or recovering
                // instead of hashing only the first six elements (i.e. nonce, gasprice, startgas, to, value, data)
                // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0.
                // v and chain ID meet EIP-155 conditions
                if (meetsEIP155(this.v, this.common.chainId())) {
                    this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
                }
            }
        }
        if (this.common.isActivatedEIP(3860)) {
            (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        const freeze = opts?.freeze ?? true;
        if (freeze) {
            Object.freeze(this);
        }
    }
    /**
     * Instantiate a transaction from a data dictionary.
     *
     * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }
     *
     * Notes:
     * - All parameters are optional and have some basic default values
     */
    static fromTxData(txData, opts = {}) {
        return new Transaction(txData, opts);
    }
    /**
     * Instantiate a transaction from the serialized tx.
     *
     * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
     */
    static fromSerializedTx(serialized, opts = {}) {
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
            throw new Error('Invalid serialized tx input. Must be array');
        }
        return this.fromValuesArray(values, opts);
    }
    /**
     * Create a transaction from a values array.
     *
     * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
     */
    static fromValuesArray(values, opts = {}) {
        // If length is not 6, it has length 9. If v/r/s are empty Buffers, it is still an unsigned transaction
        // This happens if you get the RLP data from `raw()`
        if (values.length !== 6 && values.length !== 9) {
            throw new Error('Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).');
        }
        const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        return new Transaction({
            nonce,
            gasPrice,
            gasLimit,
            to,
            value,
            data,
            v,
            r,
            s,
        }, opts);
    }
    /**
     * Returns a Buffer Array of the raw Buffers of the legacy transaction, in order.
     *
     * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
     *
     * For legacy txs this is also the correct format to add transactions
     * to a block with {@link Block.fromValuesArray} (use the `serialize()` method
     * for typed txs).
     *
     * For an unsigned tx this method returns the empty Buffer values
     * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant
     * representation have a look at {@link Transaction.getMessageToSign}.
     */
    raw() {
        return [
            (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
            (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
            (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
            this.to !== undefined ? this.to.buf : Buffer.from([]),
            (0, util_1.bigIntToUnpaddedBuffer)(this.value),
            this.data,
            this.v !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
            this.r !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
            this.s !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([]),
        ];
    }
    /**
     * Returns the serialized encoding of the legacy transaction.
     *
     * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
     *
     * For an unsigned tx this method uses the empty Buffer values for the
     * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
     * representation for external signing use {@link Transaction.getMessageToSign}.
     */
    serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw())));
    }
    _getMessageToSign() {
        const values = [
            (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
            (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
            (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
            this.to !== undefined ? this.to.buf : Buffer.from([]),
            (0, util_1.bigIntToUnpaddedBuffer)(this.value),
            this.data,
        ];
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
            values.push((0, util_1.toBuffer)(this.common.chainId()));
            values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
            values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
        }
        return values;
    }
    getMessageToSign(hashMessage = true) {
        const message = this._getMessageToSign();
        if (hashMessage) {
            return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
        }
        else {
            return message;
        }
    }
    /**
     * The amount of gas paid for the data in this tx
     */
    getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
            return this.cache.dataFee.value;
        }
        if (Object.isFrozen(this)) {
            this.cache.dataFee = {
                value: super.getDataFee(),
                hardfork: this.common.hardfork(),
            };
        }
        return super.getDataFee();
    }
    /**
     * The up front amount that an account must have for this transaction to be valid
     */
    getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
    }
    /**
     * Computes a sha3-256 hash of the serialized tx.
     *
     * This method can only be used for signed txs (it throws otherwise).
     * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
     */
    hash() {
        if (!this.isSigned()) {
            const msg = this._errorMsg('Cannot call hash method if transaction is not signed');
            throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
            if (!this.cache.hash) {
                this.cache.hash = Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
            }
            return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
    }
    /**
     * Computes a sha3-256 hash which can be used to verify the signature
     */
    getMessageToVerifySignature() {
        if (!this.isSigned()) {
            const msg = this._errorMsg('This transaction is not signed');
            throw new Error(msg);
        }
        const message = this._getMessageToSign();
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
    }
    /**
     * Returns the public key of the sender
     */
    getSenderPublicKey() {
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
            return (0, util_1.ecrecover)(msgHash, v, (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s), this.supports(types_1.Capability.EIP155ReplayProtection) ? this.common.chainId() : undefined);
        }
        catch (e) {
            const msg = this._errorMsg('Invalid Signature');
            throw new Error(msg);
        }
    }
    /**
     * Process the v, r, s values from the `sign` method of the base transaction.
     */
    _processSignature(v, r, s) {
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
            v += this.common.chainId() * BigInt(2) + BigInt(8);
        }
        const opts = { ...this.txOptions, common: this.common };
        return Transaction.fromTxData({
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            v,
            r: (0, util_1.bufferToBigInt)(r),
            s: (0, util_1.bufferToBigInt)(s),
        }, opts);
    }
    /**
     * Returns an object with the JSON representation of the transaction.
     */
    toJSON() {
        return {
            nonce: (0, util_1.bigIntToHex)(this.nonce),
            gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
            gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
            to: this.to !== undefined ? this.to.toString() : undefined,
            value: (0, util_1.bigIntToHex)(this.value),
            data: '0x' + this.data.toString('hex'),
            v: this.v !== undefined ? (0, util_1.bigIntToHex)(this.v) : undefined,
            r: this.r !== undefined ? (0, util_1.bigIntToHex)(this.r) : undefined,
            s: this.s !== undefined ? (0, util_1.bigIntToHex)(this.s) : undefined,
        };
    }
    /**
     * Validates tx's `v` value
     */
    _validateTxV(_v, common) {
        let chainIdBigInt;
        const v = _v !== undefined ? Number(_v) : undefined;
        // Check for valid v values in the scope of a signed legacy tx
        if (v !== undefined) {
            // v is 1. not matching the EIP-155 chainId included case and...
            // v is 2. not matching the classic v=27 or v=28 case
            if (v < 37 && v !== 27 && v !== 28) {
                throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
            }
        }
        // No unsigned tx and EIP-155 activated and chain ID included
        if (v !== undefined &&
            v !== 0 &&
            (!common || common.gteHardfork('spuriousDragon')) &&
            v !== 27 &&
            v !== 28) {
            if (common) {
                if (!meetsEIP155(BigInt(v), common.chainId())) {
                    throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
                }
            }
            else {
                // Derive the original chain ID
                let numSub;
                if ((v - 35) % 2 === 0) {
                    numSub = 35;
                }
                else {
                    numSub = 36;
                }
                // Use derived chain ID to create a proper Common
                chainIdBigInt = BigInt(v - numSub) / BigInt(2);
            }
        }
        return this._getCommon(common, chainIdBigInt);
    }
    /**
     * Return a compact error string representation of the object
     */
    errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice}`;
        return errorStr;
    }
    /**
     * Internal helper function to create an annotated error message
     *
     * @param msg Base error message
     * @hidden
     */
    _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
    }
}
exports.Transaction = Transaction;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\legacyTransaction.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\transactionFactory.js", {"../../../../../is-buffer/index.js":"F:\\metamask-extension\\node_modules\\is-buffer\\index.js","./eip1559Transaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip1559Transaction.js","./eip2930Transaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip2930Transaction.js","./eip4844Transaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\eip4844Transaction.js","./fromRpc":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\fromRpc.js","./legacyTransaction":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\legacyTransaction.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@ethersproject/providers":"F:\\metamask-extension\\node_modules\\@ethersproject\\providers\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5CtransactionFactory.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionFactory = void 0;
const util_1 = require("@ethereumjs/util");
const providers_1 = require("@ethersproject/providers");
const eip1559Transaction_1 = require("./eip1559Transaction");
const eip2930Transaction_1 = require("./eip2930Transaction");
const eip4844Transaction_1 = require("./eip4844Transaction");
const fromRpc_1 = require("./fromRpc");
const legacyTransaction_1 = require("./legacyTransaction");
class TransactionFactory {
    // It is not possible to instantiate a TransactionFactory object.
    constructor() { }
    /**
     * Create a transaction from a `txData` object
     *
     * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
     * @param txOptions - Options to pass on to the constructor of the transaction
     */
    static fromTxData(txData, txOptions = {}) {
        if (!('type' in txData) || txData.type === undefined) {
            // Assume legacy transaction
            return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
        }
        else {
            const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));
            if (txType === 0) {
                return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
            }
            else if (txType === 1) {
                return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);
            }
            else if (txType === 2) {
                return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
            }
            else if (txType === 5) {
                return eip4844Transaction_1.BlobEIP4844Transaction.fromTxData(txData, txOptions);
            }
            else {
                throw new Error(`Tx instantiation with type ${txType} not supported`);
            }
        }
    }
    /**
     * This method tries to decode serialized data.
     *
     * @param data - The data Buffer
     * @param txOptions - The transaction options
     */
    static fromSerializedData(data, txOptions = {}) {
        if (data[0] <= 0x7f) {
            // Determine the type.
            switch (data[0]) {
                case 1:
                    return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
                case 2:
                    return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
                case 5:
                    return eip4844Transaction_1.BlobEIP4844Transaction.fromSerializedTx(data, txOptions);
                default:
                    throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
            }
        }
        else {
            return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);
        }
    }
    /**
     * When decoding a BlockBody, in the transactions field, a field is either:
     * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))
     * A Buffer[] (Legacy Transaction)
     * This method returns the right transaction.
     *
     * @param data - A Buffer or Buffer[]
     * @param txOptions - The transaction options
     */
    static fromBlockBodyData(data, txOptions = {}) {
        if (Buffer.isBuffer(data)) {
            return this.fromSerializedData(data, txOptions);
        }
        else if (Array.isArray(data)) {
            // It is a legacy transaction
            return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);
        }
        else {
            throw new Error('Cannot decode transaction: unknown type input');
        }
    }
    /**
     *  Method to retrieve a transaction from the provider
     * @param provider - An Ethers JsonRPCProvider
     * @param txHash - Transaction hash
     * @param txOptions - The transaction options
     * @returns the transaction specified by `txHash`
     */
    static async fromEthersProvider(provider, txHash, txOptions) {
        const prov = typeof provider === 'string' ? new providers_1.JsonRpcProvider(provider) : provider;
        const txData = await prov.send('eth_getTransactionByHash', [txHash]);
        const normedTx = (0, fromRpc_1.normalizeTxParams)(txData);
        return TransactionFactory.fromTxData(normedTx, txOptions);
    }
}
exports.TransactionFactory = TransactionFactory;

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\transactionFactory.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\types.js", {"./constants":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\constants.js","@chainsafe/ssz":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@chainsafe\\ssz\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobNetworkTransactionWrapper = exports.KZGProofType = exports.KZGCommitmentType = exports.SignedBlobTransactionType = exports.ECDSASignatureType = exports.BlobTransactionType = exports.AccessTupleType = exports.AddressType = exports.isAccessList = exports.isAccessListBuffer = exports.Capability = void 0;
const ssz_1 = require("@chainsafe/ssz");
const constants_1 = require("./constants");
const Bytes20 = new ssz_1.ByteVectorType(20);
const Bytes32 = new ssz_1.ByteVectorType(32);
const Bytes48 = new ssz_1.ByteVectorType(48);
const Uint64 = new ssz_1.UintBigintType(8);
const Uint256 = new ssz_1.UintBigintType(32);
/**
 * Can be used in conjunction with {@link Transaction.supports}
 * to query on tx capabilities
 */
var Capability;
(function (Capability) {
    /**
     * Tx supports EIP-155 replay protection
     * See: [155](https://eips.ethereum.org/EIPS/eip-155) Replay Attack Protection EIP
     */
    Capability[Capability["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
    /**
     * Tx supports EIP-1559 gas fee market mechanism
     * See: [1559](https://eips.ethereum.org/EIPS/eip-1559) Fee Market EIP
     */
    Capability[Capability["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
    /**
     * Tx is a typed transaction as defined in EIP-2718
     * See: [2718](https://eips.ethereum.org/EIPS/eip-2718) Transaction Type EIP
     */
    Capability[Capability["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
    /**
     * Tx supports access list generation as defined in EIP-2930
     * See: [2930](https://eips.ethereum.org/EIPS/eip-2930) Access Lists EIP
     */
    Capability[Capability["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
})(Capability = exports.Capability || (exports.Capability = {}));
function isAccessListBuffer(input) {
    if (input.length === 0) {
        return true;
    }
    const firstItem = input[0];
    if (Array.isArray(firstItem)) {
        return true;
    }
    return false;
}
exports.isAccessListBuffer = isAccessListBuffer;
function isAccessList(input) {
    return !isAccessListBuffer(input); // This is exactly the same method, except the output is negated.
}
exports.isAccessList = isAccessList;
/** EIP4844 types */
exports.AddressType = Bytes20; // SSZ encoded address
// SSZ encoded container for address and storage keys
exports.AccessTupleType = new ssz_1.ContainerType({
    address: exports.AddressType,
    storageKeys: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE),
});
// SSZ encoded blob transaction
exports.BlobTransactionType = new ssz_1.ContainerType({
    chainId: Uint256,
    nonce: Uint64,
    maxPriorityFeePerGas: Uint256,
    maxFeePerGas: Uint256,
    gas: Uint64,
    to: new ssz_1.UnionType([new ssz_1.NoneType(), exports.AddressType]),
    value: Uint256,
    data: new ssz_1.ByteListType(constants_1.MAX_CALLDATA_SIZE),
    accessList: new ssz_1.ListCompositeType(exports.AccessTupleType, constants_1.MAX_ACCESS_LIST_SIZE),
    maxFeePerDataGas: Uint256,
    blobVersionedHashes: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE),
});
// SSZ encoded ECDSA Signature
exports.ECDSASignatureType = new ssz_1.ContainerType({
    yParity: new ssz_1.BooleanType(),
    r: Uint256,
    s: Uint256,
});
// SSZ encoded signed blob transaction
exports.SignedBlobTransactionType = new ssz_1.ContainerType({
    message: exports.BlobTransactionType,
    signature: exports.ECDSASignatureType,
});
// SSZ encoded KZG Commitment/Proof (48 bytes)
exports.KZGCommitmentType = Bytes48;
exports.KZGProofType = exports.KZGCommitmentType;
// SSZ encoded blob network transaction wrapper
exports.BlobNetworkTransactionWrapper = new ssz_1.ContainerType({
    tx: exports.SignedBlobTransactionType,
    blobKzgs: new ssz_1.ListCompositeType(exports.KZGCommitmentType, constants_1.MAX_TX_WRAP_KZG_COMMITMENTS),
    blobs: new ssz_1.ListCompositeType(new ssz_1.ByteVectorType(constants_1.FIELD_ELEMENTS_PER_BLOB * constants_1.BYTES_PER_FIELD_ELEMENT), constants_1.LIMIT_BLOBS_PER_TX),
    kzgAggregatedProof: exports.KZGProofType,
});
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\types.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\util.js", {"./types":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\types.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Cutil.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blobTxToNetworkWrapperDataFormat = exports.AccessLists = exports.checkMaxInitCodeSize = void 0;
const util_1 = require("@ethereumjs/util");
const types_1 = require("./types");
function checkMaxInitCodeSize(common, length) {
    const maxInitCodeSize = common.param('vm', 'maxInitCodeSize');
    if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
        throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param('vm', 'maxInitCodeSize')}`);
    }
}
exports.checkMaxInitCodeSize = checkMaxInitCodeSize;
class AccessLists {
    static getAccessListData(accessList) {
        let AccessListJSON;
        let bufferAccessList;
        if ((0, types_1.isAccessList)(accessList)) {
            AccessListJSON = accessList;
            const newAccessList = [];
            for (let i = 0; i < accessList.length; i++) {
                const item = accessList[i];
                const addressBuffer = (0, util_1.toBuffer)(item.address);
                const storageItems = [];
                for (let index = 0; index < item.storageKeys.length; index++) {
                    storageItems.push((0, util_1.toBuffer)(item.storageKeys[index]));
                }
                newAccessList.push([addressBuffer, storageItems]);
            }
            bufferAccessList = newAccessList;
        }
        else {
            bufferAccessList = accessList ?? [];
            // build the JSON
            const json = [];
            for (let i = 0; i < bufferAccessList.length; i++) {
                const data = bufferAccessList[i];
                const address = (0, util_1.bufferToHex)(data[0]);
                const storageKeys = [];
                for (let item = 0; item < data[1].length; item++) {
                    storageKeys.push((0, util_1.bufferToHex)(data[1][item]));
                }
                const jsonItem = {
                    address,
                    storageKeys,
                };
                json.push(jsonItem);
            }
            AccessListJSON = json;
        }
        return {
            AccessListJSON,
            accessList: bufferAccessList,
        };
    }
    static verifyAccessList(accessList) {
        for (let key = 0; key < accessList.length; key++) {
            const accessListItem = accessList[key];
            const address = accessListItem[0];
            const storageSlots = accessListItem[1];
            if (accessListItem[2] !== undefined) {
                throw new Error('Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.');
            }
            if (address.length !== 20) {
                throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes');
            }
            for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
                if (storageSlots[storageSlot].length !== 32) {
                    throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes');
                }
            }
        }
    }
    static getAccessListJSON(accessList) {
        const accessListJSON = [];
        for (let index = 0; index < accessList.length; index++) {
            const item = accessList[index];
            const JSONItem = {
                address: '0x' + (0, util_1.setLengthLeft)(item[0], 20).toString('hex'),
                storageKeys: [],
            };
            const storageSlots = item[1];
            for (let slot = 0; slot < storageSlots.length; slot++) {
                const storageSlot = storageSlots[slot];
                JSONItem.storageKeys.push('0x' + (0, util_1.setLengthLeft)(storageSlot, 32).toString('hex'));
            }
            accessListJSON.push(JSONItem);
        }
        return accessListJSON;
    }
    static getDataFeeEIP2930(accessList, common) {
        const accessListStorageKeyCost = common.param('gasPrices', 'accessListStorageKeyCost');
        const accessListAddressCost = common.param('gasPrices', 'accessListAddressCost');
        let slots = 0;
        for (let index = 0; index < accessList.length; index++) {
            const item = accessList[index];
            const storageSlots = item[1];
            slots += storageSlots.length;
        }
        const addresses = accessList.length;
        return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
    }
}
exports.AccessLists = AccessLists;
const blobTxToNetworkWrapperDataFormat = (tx) => {
    const to = {
        selector: tx.to !== undefined ? 1 : 0,
        value: tx.to?.toBuffer() ?? null,
    };
    return {
        message: {
            chainId: tx.common.chainId(),
            nonce: tx.nonce,
            maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
            maxFeePerGas: tx.maxFeePerGas,
            gas: tx.gasLimit,
            to,
            value: tx.value,
            data: tx.data,
            accessList: tx.accessList.map((listItem) => {
                return { address: listItem[0], storageKeys: listItem[1] };
            }),
            blobVersionedHashes: tx.versionedHashes,
            maxFeePerDataGas: tx.maxFeePerDataGas,
        },
        // If transaction is unsigned, signature fields will be initialized to zeroes
        signature: {
            r: tx.r ?? BigInt(0),
            s: tx.s ?? BigInt(0),
            yParity: tx.v === BigInt(1) ? true : false,
        },
    };
};
exports.blobTxToNetworkWrapperDataFormat = blobTxToNetworkWrapperDataFormat;
//# sourceMappingURL=util.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\util.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\utils\\blobHelpers.js", {"../kzg/kzg":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\kzg\\kzg.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/sha256":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\sha256.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cdist%5Cutils%5CblobHelpers.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commitmentsToVersionedHashes = exports.computeVersionedHash = exports.blobsToCommitments = exports.getBlobs = void 0;
const sha256_1 = require("ethereum-cryptography/sha256");
const kzg_1 = require("../kzg/kzg");
/**
 * These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git
 */
const BYTES_PER_FIELD_ELEMENT = 32;
const FIELD_ELEMENTS_PER_BLOB = 4096;
const USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
const MAX_BLOBS_PER_TX = 2;
const MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;
const BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;
function get_padded(data, blobs_len) {
    const pdata = Buffer.alloc(blobs_len * USEFUL_BYTES_PER_BLOB);
    const datalen = Buffer.byteLength(data);
    pdata.fill(data, 0, datalen);
    pdata[datalen] = 0x80;
    return pdata;
}
function get_blob(data) {
    const blob = Buffer.alloc(BLOB_SIZE, 'binary');
    for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {
        const chunk = Buffer.alloc(32, 'binary');
        chunk.fill(data.subarray(i * 31, (i + 1) * 31), 0, 31);
        blob.fill(chunk, i * 32, (i + 1) * 32);
    }
    return blob;
}
const getBlobs = (input) => {
    const data = Buffer.from(input, 'binary');
    const len = Buffer.byteLength(data);
    if (len === 0) {
        throw Error('invalid blob data');
    }
    if (len > MAX_USEFUL_BYTES_PER_TX) {
        throw Error('blob data is too large');
    }
    const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);
    const pdata = get_padded(data, blobs_len);
    const blobs = [];
    for (let i = 0; i < blobs_len; i++) {
        const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);
        const blob = get_blob(chunk);
        blobs.push(blob);
    }
    return blobs;
};
exports.getBlobs = getBlobs;
const blobsToCommitments = (blobs) => {
    const commitments = [];
    for (const blob of blobs) {
        commitments.push(Buffer.from(kzg_1.kzg.blobToKzgCommitment(blob)));
    }
    return commitments;
};
exports.blobsToCommitments = blobsToCommitments;
/**
 * Converts a vector commitment for a given data blob to its versioned hash.  For 4844, this version
 * number will be 0x01 for KZG vector commitments but could be different if future vector commitment
 * types are introduced
 * @param commitment a vector commitment to a blob
 * @param blobCommitmentVersion the version number corresponding to the type of vector commitment
 * @returns a versioned hash corresponding to a given blob vector commitment
 */
const computeVersionedHash = (commitment, blobCommitmentVersion) => {
    const computedVersionedHash = new Uint8Array(32);
    computedVersionedHash.set([blobCommitmentVersion], 0);
    computedVersionedHash.set((0, sha256_1.sha256)(commitment).slice(1), 1);
    return computedVersionedHash;
};
exports.computeVersionedHash = computeVersionedHash;
/**
 * Generate an array of versioned hashes from corresponding kzg commitments
 * @param commitments array of kzg commitments
 * @returns array of versioned hashes
 * Note: assumes KZG commitments (version 1 version hashes)
 */
const commitmentsToVersionedHashes = (commitments) => {
    const hashes = [];
    for (const commitment of commitments) {
        hashes.push(Buffer.from((0, exports.computeVersionedHash)(commitment, 0x01)));
    }
    return hashes;
};
exports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\dist\\utils\\blobHelpers.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\goerli.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Cgoerli.json
      return function (require, module, exports) {
module.exports={
    "name": "goerli",
    "chainId": 5,
    "networkId": 5,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "poa",
        "algorithm": "clique",
        "clique": {
            "period": 15,
            "epoch": 30000
        }
    },
    "comment": "Cross-client PoA test network",
    "url": "https://github.com/goerli/testnet",
    "genesis": {
        "timestamp": "0x5c51a607",
        "gasLimit": 10485760,
        "difficulty": 1,
        "nonce": "0x0000000000000000",
        "extraData": "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "homestead",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "tangerineWhistle",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "spuriousDragon",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "byzantium",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "constantinople",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "petersburg",
            "block": 0,
            "forkHash": "0xa3f5ab08"
        },
        {
            "name": "istanbul",
            "block": 1561651,
            "forkHash": "0xc25efa5c"
        },
        {
            "name": "berlin",
            "block": 4460644,
            "forkHash": "0x757a1c47"
        },
        {
            "name": "london",
            "block": 5062605,
            "forkHash": "0xb8c6299d"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
            "name": "merge",
            "ttd": "10790000",
            "block": 7382819,
            "forkHash": "0xb8c6299d"
        },
        {
            "name": "mergeForkIdTransition",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "timestamp": "1678832736",
            "forkHash": "0xf9843abf"
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "51.141.78.53",
            "port": 30303,
            "id": "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
            "location": "",
            "comment": "Upstream bootnode 1"
        },
        {
            "ip": "13.93.54.137",
            "port": 30303,
            "id": "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
            "location": "",
            "comment": "Upstream bootnode 2"
        },
        {
            "ip": "94.237.54.114",
            "port": 30313,
            "id": "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
            "location": "",
            "comment": "Upstream bootnode 3"
        },
        {
            "ip": "18.218.250.66",
            "port": 30313,
            "id": "b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",
            "location": "",
            "comment": "Upstream bootnode 4"
        },
        {
            "ip": "3.11.147.67",
            "port": 30303,
            "id": "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
            "location": "",
            "comment": "Ethereum Foundation bootnode"
        },
        {
            "ip": "51.15.116.226",
            "port": 30303,
            "id": "a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",
            "location": "",
            "comment": "Goerli Initiative bootnode"
        },
        {
            "ip": "51.15.119.157",
            "port": 30303,
            "id": "807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",
            "location": "",
            "comment": "Goerli Initiative bootnode"
        },
        {
            "ip": "51.15.119.157",
            "port": 40303,
            "id": "a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",
            "location": "",
            "comment": "Goerli Initiative bootnode"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\goerli.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\mainnet.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Cmainnet.json
      return function (require, module, exports) {
module.exports={
    "name": "mainnet",
    "chainId": 1,
    "networkId": 1,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "pow",
        "algorithm": "ethash",
        "ethash": {}
    },
    "comment": "The Ethereum main chain",
    "url": "https://ethstats.net/",
    "genesis": {
        "gasLimit": 5000,
        "difficulty": 17179869184,
        "nonce": "0x0000000000000042",
        "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0xfc64ec04"
        },
        {
            "name": "homestead",
            "block": 1150000,
            "forkHash": "0x97c2c34c"
        },
        {
            "name": "dao",
            "block": 1920000,
            "forkHash": "0x91d1f948"
        },
        {
            "name": "tangerineWhistle",
            "block": 2463000,
            "forkHash": "0x7a64da13"
        },
        {
            "name": "spuriousDragon",
            "block": 2675000,
            "forkHash": "0x3edd5b10"
        },
        {
            "name": "byzantium",
            "block": 4370000,
            "forkHash": "0xa00bc324"
        },
        {
            "name": "constantinople",
            "block": 7280000,
            "forkHash": "0x668db0af"
        },
        {
            "name": "petersburg",
            "block": 7280000,
            "forkHash": "0x668db0af"
        },
        {
            "name": "istanbul",
            "block": 9069000,
            "forkHash": "0x879d6e30"
        },
        {
            "name": "muirGlacier",
            "block": 9200000,
            "forkHash": "0xe029e991"
        },
        {
            "name": "berlin",
            "block": 12244000,
            "forkHash": "0x0eb440f6"
        },
        {
            "name": "london",
            "block": 12965000,
            "forkHash": "0xb715077d"
        },
        {
            "name": "arrowGlacier",
            "block": 13773000,
            "forkHash": "0x20c327fc"
        },
        {
            "name": "grayGlacier",
            "block": 15050000,
            "forkHash": "0xf0afd0e3"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
            "name": "merge",
            "ttd": "58750000000000000000000",
            "block": 15537394,
            "forkHash": "0xf0afd0e3"
        },
        {
            "name": "mergeForkIdTransition",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "timestamp": "1681338455",
            "forkHash": "0xdce96c2d"
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "18.138.108.67",
            "port": 30303,
            "id": "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
            "location": "ap-southeast-1-001",
            "comment": "bootnode-aws-ap-southeast-1-001"
        },
        {
            "ip": "3.209.45.79",
            "port": 30303,
            "id": "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
            "location": "us-east-1-001",
            "comment": "bootnode-aws-us-east-1-001"
        },
        {
            "ip": "65.108.70.101",
            "port": 30303,
            "id": "2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc",
            "location": "eu-west-1-001",
            "comment": "bootnode-hetzner-hel"
        },
        {
            "ip": "157.90.35.166",
            "port": 30303,
            "id": "4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052",
            "location": "eu-central-1-001",
            "comment": "bootnode-hetzner-fsn"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\mainnet.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\rinkeby.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Crinkeby.json
      return function (require, module, exports) {
module.exports={
    "name": "rinkeby",
    "chainId": 4,
    "networkId": 4,
    "defaultHardfork": "london",
    "consensus": {
        "type": "poa",
        "algorithm": "clique",
        "clique": {
            "period": 15,
            "epoch": 30000
        }
    },
    "comment": "PoA test network",
    "url": "https://www.rinkeby.io",
    "genesis": {
        "timestamp": "0x58ee40ba",
        "gasLimit": 4700000,
        "difficulty": 1,
        "nonce": "0x0000000000000000",
        "extraData": "0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0x3b8e0691"
        },
        {
            "name": "homestead",
            "block": 1,
            "forkHash": "0x60949295"
        },
        {
            "name": "tangerineWhistle",
            "block": 2,
            "forkHash": "0x8bde40dd"
        },
        {
            "name": "spuriousDragon",
            "block": 3,
            "forkHash": "0xcb3a64bb"
        },
        {
            "name": "byzantium",
            "block": 1035301,
            "forkHash": "0x8d748b57"
        },
        {
            "name": "constantinople",
            "block": 3660663,
            "forkHash": "0xe49cab14"
        },
        {
            "name": "petersburg",
            "block": 4321234,
            "forkHash": "0xafec6b27"
        },
        {
            "name": "istanbul",
            "block": 5435345,
            "forkHash": "0xcbdb8838"
        },
        {
            "name": "berlin",
            "block": 8290928,
            "forkHash": "0x6910c8bd"
        },
        {
            "name": "london",
            "block": 8897988,
            "forkHash": "0x8e29f2f3"
        },
        {
            "name": "merge",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "forkHash": null
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "52.169.42.101",
            "port": 30303,
            "id": "a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",
            "location": "",
            "comment": "IE"
        },
        {
            "ip": "52.3.158.184",
            "port": 30303,
            "id": "343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",
            "location": "",
            "comment": "INFURA"
        },
        {
            "ip": "159.89.28.211",
            "port": 30303,
            "id": "b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",
            "location": "",
            "comment": "AKASHA"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\rinkeby.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\ropsten.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Cropsten.json
      return function (require, module, exports) {
module.exports={
    "name": "ropsten",
    "chainId": 3,
    "networkId": 3,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "pow",
        "algorithm": "ethash",
        "ethash": {}
    },
    "comment": "PoW test network",
    "url": "https://github.com/ethereum/ropsten",
    "genesis": {
        "gasLimit": 16777216,
        "difficulty": 1048576,
        "nonce": "0x0000000000000042",
        "extraData": "0x3535353535353535353535353535353535353535353535353535353535353535"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0x30c7ddbc"
        },
        {
            "name": "homestead",
            "block": 0,
            "forkHash": "0x30c7ddbc"
        },
        {
            "name": "tangerineWhistle",
            "block": 0,
            "forkHash": "0x30c7ddbc"
        },
        {
            "name": "spuriousDragon",
            "block": 10,
            "forkHash": "0x63760190"
        },
        {
            "name": "byzantium",
            "block": 1700000,
            "forkHash": "0x3ea159c7"
        },
        {
            "name": "constantinople",
            "block": 4230000,
            "forkHash": "0x97b544f3"
        },
        {
            "name": "petersburg",
            "block": 4939394,
            "forkHash": "0xd6e2149b"
        },
        {
            "name": "istanbul",
            "block": 6485846,
            "forkHash": "0x4bc66396"
        },
        {
            "name": "muirGlacier",
            "block": 7117117,
            "forkHash": "0x6727ef90"
        },
        {
            "name": "berlin",
            "block": 9812189,
            "forkHash": "0xa157d377"
        },
        {
            "name": "london",
            "block": 10499401,
            "forkHash": "0x7119b6b3"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
            "name": "merge",
            "ttd": "50000000000000000",
            "block": null,
            "forkHash": "0x7119b6b3"
        },
        {
            "name": "mergeForkIdTransition",
            "block": null,
            "forkHash": null
        },
        {
            "name": "shanghai",
            "block": null,
            "forkHash": null
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "52.176.7.10",
            "port": 30303,
            "id": "30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",
            "location": "",
            "comment": "US-Azure geth"
        },
        {
            "ip": "52.176.100.77",
            "port": 30303,
            "id": "865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",
            "location": "",
            "comment": "US-Azure parity"
        },
        {
            "ip": "52.232.243.152",
            "port": 30303,
            "id": "6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",
            "location": "",
            "comment": "Parity"
        },
        {
            "ip": "192.81.208.223",
            "port": 30303,
            "id": "94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",
            "location": "",
            "comment": "@gpip"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\ropsten.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\sepolia.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cchains%5Csepolia.json
      return function (require, module, exports) {
module.exports={
    "name": "sepolia",
    "chainId": 11155111,
    "networkId": 11155111,
    "defaultHardfork": "merge",
    "consensus": {
        "type": "pow",
        "algorithm": "ethash",
        "ethash": {}
    },
    "comment": "PoW test network to replace Ropsten",
    "url": "https://github.com/ethereum/go-ethereum/pull/23730",
    "genesis": {
        "timestamp": "0x6159af19",
        "gasLimit": 30000000,
        "difficulty": 131072,
        "nonce": "0x0000000000000000",
        "extraData": "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
    },
    "hardforks": [
        {
            "name": "chainstart",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "homestead",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "tangerineWhistle",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "spuriousDragon",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "byzantium",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "constantinople",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "petersburg",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "istanbul",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "muirGlacier",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "berlin",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "london",
            "block": 0,
            "forkHash": "0xfe3366e7"
        },
        {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
            "name": "merge",
            "ttd": "17000000000000000",
            "block": 1450409,
            "forkHash": "0xfe3366e7"
        },
        {
            "name": "mergeForkIdTransition",
            "block": 1735371,
            "forkHash": "0xb96cbd13"
        },
        {
            "name": "shanghai",
            "block": null,
            "timestamp": "1677557088",
            "forkHash": "0xf7f9bc08"
        }
    ],
    "bootstrapNodes": [
        {
            "ip": "18.168.182.86",
            "port": 30303,
            "id": "9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",
            "location": "",
            "comment": "geth"
        },
        {
            "ip": "52.14.151.177",
            "port": 30303,
            "id": "ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",
            "location": "",
            "comment": "besu"
        },
        {
            "ip": "165.22.196.173",
            "port": 30303,
            "id": "ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",
            "location": "",
            "comment": "EF"
        },
        {
            "ip": "65.108.95.67",
            "port": 30303,
            "id": "075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",
            "location": "",
            "comment": "lodestar"
        }
    ],
    "dnsNetworks": [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
    ]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\sepolia.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\common.js", {"./chains/goerli.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\goerli.json","./chains/mainnet.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\mainnet.json","./chains/rinkeby.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\rinkeby.json","./chains/ropsten.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\ropsten.json","./chains/sepolia.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\chains\\sepolia.json","./eips":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\index.js","./enums":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\enums.js","./hardforks":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\index.js","./utils":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","crc-32":"F:\\metamask-extension\\node_modules\\crc-32\\crc32.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ccommon.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Common = void 0;
const util_1 = require("@ethereumjs/util");
const crc_32_1 = require("crc-32");
const events_1 = require("events");
const goerli = require("./chains/goerli.json");
const mainnet = require("./chains/mainnet.json");
const rinkeby = require("./chains/rinkeby.json");
const ropsten = require("./chains/ropsten.json");
const sepolia = require("./chains/sepolia.json");
const eips_1 = require("./eips");
const enums_1 = require("./enums");
const hardforks_1 = require("./hardforks");
const utils_1 = require("./utils");
/**
 * Common class to access chain and hardfork parameters and to provide
 * a unified and shared view on the network and hardfork state.
 *
 * Use the {@link Common.custom} static constructor for creating simple
 * custom chain {@link Common} objects (more complete custom chain setups
 * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).
 */
class Common extends events_1.EventEmitter {
    constructor(opts) {
        super();
        this._eips = [];
        this._customChains = opts.customChains ?? [];
        this._chainParams = this.setChain(opts.chain);
        this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;
        // Assign hardfork changes in the sequence of the applied hardforks
        this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
            hf.name,
            hardforks_1.hardforks[hf.name],
        ]);
        this._hardfork = this.DEFAULT_HARDFORK;
        if (opts.hardfork !== undefined) {
            this.setHardfork(opts.hardfork);
        }
        if (opts.eips) {
            this.setEIPs(opts.eips);
        }
    }
    /**
     * Creates a {@link Common} object for a custom chain, based on a standard one.
     *
     * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden
     * in a provided {@link chainParamsOrName} dictionary. Some usage example:
     *
     * ```javascript
     * Common.custom({chainId: 123})
     * ```
     *
     * There are also selected supported custom chains which can be initialized by using one of the
     * {@link CustomChains} for {@link chainParamsOrName}, e.g.:
     *
     * ```javascript
     * Common.custom(CustomChains.MaticMumbai)
     * ```
     *
     * Note that these supported custom chains only provide some base parameters (usually the chain and
     * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with
     * the `@ethereumjs/tx` library to a Layer-2 chain).
     *
     * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain
     * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others
     */
    static custom(chainParamsOrName, opts = {}) {
        const baseChain = opts.baseChain ?? 'mainnet';
        const standardChainParams = { ...Common._getChainParams(baseChain) };
        standardChainParams['name'] = 'custom-chain';
        if (typeof chainParamsOrName !== 'string') {
            return new Common({
                chain: {
                    ...standardChainParams,
                    ...chainParamsOrName,
                },
                ...opts,
            });
        }
        else {
            if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {
                return Common.custom({
                    name: enums_1.CustomChain.PolygonMainnet,
                    chainId: 137,
                    networkId: 137,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {
                return Common.custom({
                    name: enums_1.CustomChain.PolygonMumbai,
                    chainId: 80001,
                    networkId: 80001,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {
                return Common.custom({
                    name: enums_1.CustomChain.ArbitrumRinkebyTestnet,
                    chainId: 421611,
                    networkId: 421611,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {
                return Common.custom({
                    name: enums_1.CustomChain.ArbitrumOne,
                    chainId: 42161,
                    networkId: 42161,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {
                return Common.custom({
                    name: enums_1.CustomChain.xDaiChain,
                    chainId: 100,
                    networkId: 100,
                }, opts);
            }
            if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {
                return Common.custom({
                    name: enums_1.CustomChain.OptimisticKovan,
                    chainId: 69,
                    networkId: 69,
                }, 
                // Optimism has not implemented the London hardfork yet (targeting Q1.22)
                { hardfork: enums_1.Hardfork.Berlin, ...opts });
            }
            if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {
                return Common.custom({
                    name: enums_1.CustomChain.OptimisticEthereum,
                    chainId: 10,
                    networkId: 10,
                }, 
                // Optimism has not implemented the London hardfork yet (targeting Q1.22)
                { hardfork: enums_1.Hardfork.Berlin, ...opts });
            }
            throw new Error(`Custom chain ${chainParamsOrName} not supported`);
        }
    }
    /**
     * Static method to load and set common from a geth genesis json
     * @param genesisJson json of geth configuration
     * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance
     * @returns Common
     */
    static fromGethGenesis(genesisJson, { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }) {
        const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);
        const common = new Common({
            chain: genesisParams.name ?? 'custom',
            customChains: [genesisParams],
            eips,
            hardfork: hardfork ?? genesisParams.hardfork,
        });
        if (genesisHash !== undefined) {
            common.setForkHashes(genesisHash);
        }
        return common;
    }
    /**
     * Static method to determine if a {@link chainId} is supported as a standard chain
     * @param chainId bigint id (`1`) of a standard chain
     * @returns boolean
     */
    static isSupportedChainId(chainId) {
        const initializedChains = this._getInitializedChains();
        return Boolean(initializedChains['names'][chainId.toString()]);
    }
    static _getChainParams(chain, customChains) {
        const initializedChains = this._getInitializedChains(customChains);
        if (typeof chain === 'number' || typeof chain === 'bigint') {
            chain = chain.toString();
            if (initializedChains['names'][chain]) {
                const name = initializedChains['names'][chain];
                return initializedChains[name];
            }
            throw new Error(`Chain with ID ${chain} not supported`);
        }
        if (initializedChains[chain] !== undefined) {
            return initializedChains[chain];
        }
        throw new Error(`Chain with name ${chain} not supported`);
    }
    /**
     * Sets the chain
     * @param chain String ('mainnet') or Number (1) chain representation.
     *              Or, a Dictionary of chain parameters for a private network.
     * @returns The dictionary with parameters set as chain
     */
    setChain(chain) {
        if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {
            this._chainParams = Common._getChainParams(chain, this._customChains);
        }
        else if (typeof chain === 'object') {
            if (this._customChains.length > 0) {
                throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');
            }
            const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];
            for (const param of required) {
                if (!(param in chain)) {
                    throw new Error(`Missing required chain parameter: ${param}`);
                }
            }
            this._chainParams = chain;
        }
        else {
            throw new Error('Wrong input format');
        }
        for (const hf of this.hardforks()) {
            if (hf.block === undefined) {
                throw new Error(`Hardfork cannot have undefined block number`);
            }
        }
        return this._chainParams;
    }
    /**
     * Sets the hardfork to get params for
     * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum
     */
    setHardfork(hardfork) {
        let existing = false;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if (hfChanges[0] === hardfork) {
                if (this._hardfork !== hardfork) {
                    this._hardfork = hardfork;
                    this.emit('hardforkChanged', hardfork);
                }
                existing = true;
            }
        }
        if (!existing) {
            throw new Error(`Hardfork with name ${hardfork} not supported`);
        }
    }
    /**
     * Returns the hardfork based on the block number or an optional
     * total difficulty (Merge HF) provided.
     *
     * An optional TD takes precedence in case the corresponding HF block
     * is set to `null` or otherwise needs to match (if not an error
     * will be thrown).
     *
     * @param blockNumber
     * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)
     * @param timestamp: timestamp in seconds at which block was/is to be minted
     * @returns The name of the HF
     */
    getHardforkByBlockNumber(blockNumber, td, timestamp) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);
        timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number);
        // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)
        const hfs = this.hardforks().filter((hf) => hf.block !== null || (hf.ttd !== null && hf.ttd !== undefined) || hf.timestamp !== undefined);
        const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
        const doubleTTDHF = hfs
            .slice(mergeIndex + 1)
            .findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
        if (doubleTTDHF >= 0) {
            throw Error(`More than one merge hardforks found with ttd specified`);
        }
        // Find the first hardfork that has a block number greater than `blockNumber`
        // (skips the merge hardfork since it cannot have a block number specified).
        // If timestamp is not provided, it also skips timestamps hardforks to continue
        // discovering/checking number hardforks.
        let hfIndex = hfs.findIndex((hf) => (hf.block !== null && hf.block > blockNumber) ||
            (timestamp !== undefined && Number(hf.timestamp) > timestamp));
        if (hfIndex === -1) {
            // all hardforks apply, set hfIndex to the last one as that's the candidate
            hfIndex = hfs.length;
        }
        else if (hfIndex === 0) {
            // cannot have a case where a block number is before all applied hardforks
            // since the chain has to start with a hardfork
            throw Error('Must have at least one hardfork at block 0');
        }
        // If timestamp is not provided, we need to rollback to the last hf with block or ttd
        if (timestamp === undefined) {
            const stepBack = hfs
                .slice(0, hfIndex)
                .reverse()
                .findIndex((hf) => hf.block !== null || hf.ttd !== undefined);
            hfIndex = hfIndex - stepBack;
        }
        // Move hfIndex one back to arrive at candidate hardfork
        hfIndex = hfIndex - 1;
        // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number
        // hardforks. so it will now be needed to rollback
        if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {
            // We're on the merge hardfork.  Let's check the TTD
            if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {
                // Merge ttd greater than current td so we're on hardfork before merge
                hfIndex -= 1;
            }
        }
        else {
            if (mergeIndex >= 0 && td !== undefined && td !== null) {
                if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
                    throw Error('Maximum HF determined by total difficulty is lower than the block number HF');
                }
                else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
                    throw Error('HF determined by block number is lower than the minimum total difficulty HF');
                }
            }
        }
        const hfStartIndex = hfIndex;
        // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp
        // This won't anyway be the case with Merge hfs
        for (; hfIndex < hfs.length - 1; hfIndex++) {
            // break out if hfIndex + 1 is not scheduled at hfIndex
            if (hfs[hfIndex].block !== hfs[hfIndex + 1].block ||
                hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
                break;
            }
        }
        if (timestamp) {
            const minTimeStamp = hfs
                .slice(0, hfStartIndex)
                .reduce((acc, hf) => Math.max(Number(hf.timestamp ?? '0'), acc), 0);
            if (minTimeStamp > timestamp) {
                throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
            }
            const maxTimeStamp = hfs
                .slice(hfIndex + 1)
                .reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);
            if (maxTimeStamp < timestamp) {
                throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
            }
        }
        const hardfork = hfs[hfIndex];
        return hardfork.name;
    }
    /**
     * Sets a new hardfork based on the block number or an optional
     * total difficulty (Merge HF) provided.
     *
     * An optional TD takes precedence in case the corresponding HF block
     * is set to `null` or otherwise needs to match (if not an error
     * will be thrown).
     *
     * @param blockNumber
     * @param td
     * @param timestamp
     * @returns The name of the HF set
     */
    setHardforkByBlockNumber(blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        this.setHardfork(hardfork);
        return hardfork;
    }
    /**
     * Internal helper function, returns the params for the given hardfork for the chain set
     * @param hardfork Hardfork name
     * @returns Dictionary with hardfork params or null if hardfork not on chain
     */
    _getHardfork(hardfork) {
        const hfs = this.hardforks();
        for (const hf of hfs) {
            if (hf['name'] === hardfork)
                return hf;
        }
        return null;
    }
    /**
     * Sets the active EIPs
     * @param eips
     */
    setEIPs(eips = []) {
        for (const eip of eips) {
            if (!(eip in eips_1.EIPs)) {
                throw new Error(`${eip} not supported`);
            }
            const minHF = this.gteHardfork(eips_1.EIPs[eip]['minimumHardfork']);
            if (!minHF) {
                throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
            }
            if (eips_1.EIPs[eip].requiredEIPs !== undefined) {
                for (const elem of eips_1.EIPs[eip].requiredEIPs) {
                    if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
                        throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
                    }
                }
            }
        }
        this._eips = eips;
    }
    /**
     * Returns a parameter for the current chain setup
     *
     * If the parameter is present in an EIP, the EIP always takes precedence.
     * Otherwise the parameter if taken from the latest applied HF with
     * a change on the respective parameter.
     *
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @returns The value requested or `BigInt(0)` if not found
     */
    param(topic, name) {
        // TODO: consider the case that different active EIPs
        // can change the same parameter
        let value;
        for (const eip of this._eips) {
            value = this.paramByEIP(topic, name, eip);
            if (value !== undefined)
                return value;
        }
        return this.paramByHardfork(topic, name, this._hardfork);
    }
    /**
     * Returns the parameter corresponding to a hardfork
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param hardfork Hardfork name
     * @returns The value requested or `BigInt(0)` if not found
     */
    paramByHardfork(topic, name, hardfork) {
        let value = null;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            // EIP-referencing HF file (e.g. berlin.json)
            if ('eips' in hfChanges[1]) {
                const hfEIPs = hfChanges[1]['eips'];
                for (const eip of hfEIPs) {
                    const valueEIP = this.paramByEIP(topic, name, eip);
                    value = typeof valueEIP === 'bigint' ? valueEIP : value;
                }
                // Parameter-inlining HF file (e.g. istanbul.json)
            }
            else {
                if (hfChanges[1][topic] === undefined) {
                    throw new Error(`Topic ${topic} not defined`);
                }
                if (hfChanges[1][topic][name] !== undefined) {
                    value = hfChanges[1][topic][name].v;
                }
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return BigInt(value ?? 0);
    }
    /**
     * Returns a parameter corresponding to an EIP
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param eip Number of the EIP
     * @returns The value requested or `undefined` if not found
     */
    paramByEIP(topic, name, eip) {
        if (!(eip in eips_1.EIPs)) {
            throw new Error(`${eip} not supported`);
        }
        const eipParams = eips_1.EIPs[eip];
        if (!(topic in eipParams)) {
            throw new Error(`Topic ${topic} not defined`);
        }
        if (eipParams[topic][name] === undefined) {
            return undefined;
        }
        const value = eipParams[topic][name].v;
        return BigInt(value);
    }
    /**
     * Returns a parameter for the hardfork active on block number or
     * optional provided total difficulty (Merge HF)
     * @param topic Parameter topic
     * @param name Parameter name
     * @param blockNumber Block number
     * @param td Total difficulty
     *    * @returns The value requested or `BigInt(0)` if not found
     */
    paramByBlock(topic, name, blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        return this.paramByHardfork(topic, name, hardfork);
    }
    /**
     * Checks if an EIP is activated by either being included in the EIPs
     * manually passed in with the {@link CommonOpts.eips} or in a
     * hardfork currently being active
     *
     * Note: this method only works for EIPs being supported
     * by the {@link CommonOpts.eips} constructor option
     * @param eip
     */
    isActivatedEIP(eip) {
        if (this.eips().includes(eip)) {
            return true;
        }
        for (const hfChanges of this.HARDFORK_CHANGES) {
            const hf = hfChanges[1];
            if (this.gteHardfork(hf['name']) && 'eips' in hf) {
                if (hf['eips'].includes(eip)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Checks if set or provided hardfork is active on block number
     * @param hardfork Hardfork name or null (for HF set)
     * @param blockNumber
     * @returns True if HF is active on block number
     */
    hardforkIsActiveOnBlock(hardfork, blockNumber) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const hfBlock = this.hardforkBlock(hardfork);
        if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
            return true;
        }
        return false;
    }
    /**
     * Alias to hardforkIsActiveOnBlock when hardfork is set
     * @param blockNumber
     * @returns True if HF is active on block number
     */
    activeOnBlock(blockNumber) {
        return this.hardforkIsActiveOnBlock(null, blockNumber);
    }
    /**
     * Sequence based check if given or set HF1 is greater than or equal HF2
     * @param hardfork1 Hardfork name or null (if set)
     * @param hardfork2 Hardfork name
     * @param opts Hardfork options
     * @returns True if HF1 gte HF2
     */
    hardforkGteHardfork(hardfork1, hardfork2) {
        hardfork1 = hardfork1 ?? this._hardfork;
        const hardforks = this.hardforks();
        let posHf1 = -1, posHf2 = -1;
        let index = 0;
        for (const hf of hardforks) {
            if (hf['name'] === hardfork1)
                posHf1 = index;
            if (hf['name'] === hardfork2)
                posHf2 = index;
            index += 1;
        }
        return posHf1 >= posHf2 && posHf2 !== -1;
    }
    /**
     * Alias to hardforkGteHardfork when hardfork is set
     * @param hardfork Hardfork name
     * @returns True if hardfork set is greater than hardfork provided
     */
    gteHardfork(hardfork) {
        return this.hardforkGteHardfork(null, hardfork);
    }
    /**
     * Returns the hardfork change block for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number or null if unscheduled
     */
    hardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const block = this._getHardfork(hardfork)?.['block'];
        if (block === undefined || block === null) {
            return null;
        }
        return BigInt(block);
    }
    hardforkTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const timestamp = this._getHardfork(hardfork)?.['timestamp'];
        if (timestamp === undefined || timestamp === null) {
            return null;
        }
        return BigInt(timestamp);
    }
    /**
     * Returns the hardfork change block for eip
     * @param eip EIP number
     * @returns Block number or null if unscheduled
     */
    eipBlock(eip) {
        for (const hfChanges of this.HARDFORK_CHANGES) {
            const hf = hfChanges[1];
            if ('eips' in hf) {
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                if (hf['eips'].includes(eip)) {
                    return this.hardforkBlock(hfChanges[0]);
                }
            }
        }
        return null;
    }
    /**
     * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Total difficulty or null if no set
     */
    hardforkTTD(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const ttd = this._getHardfork(hardfork)?.['ttd'];
        if (ttd === undefined || ttd === null) {
            return null;
        }
        return BigInt(ttd);
    }
    /**
     * True if block number provided is the hardfork (given or set) change block
     * @param blockNumber Number of the block to check
     * @param hardfork Hardfork name, optional if HF set
     * @returns True if blockNumber is HF block
     * @deprecated
     */
    isHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const block = this.hardforkBlock(hardfork);
        return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false;
    }
    /**
     * Returns the change block for the next hardfork after the hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block timestamp, number or null if not available
     */
    nextHardforkBlockOrTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const hfs = this.hardforks();
        let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
        // If the current hardfork is merge, go one behind as merge hf is not part of these
        // calcs even if the merge hf block is set
        if (hardfork === enums_1.Hardfork.Merge) {
            hfIndex -= 1;
        }
        // Hardfork not found
        if (hfIndex < 0) {
            return null;
        }
        let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;
        currHfTimeOrBlock =
            currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined
                ? Number(currHfTimeOrBlock)
                : null;
        const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
            let hfTimeOrBlock = hf.timestamp ?? hf.block;
            hfTimeOrBlock =
                hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;
            return (hf.name !== enums_1.Hardfork.Merge &&
                hfTimeOrBlock !== null &&
                hfTimeOrBlock !== undefined &&
                hfTimeOrBlock !== currHfTimeOrBlock);
        });
        // If no next hf found with valid block or timestamp return null
        if (nextHf === undefined) {
            return null;
        }
        const nextHfBlock = nextHf.timestamp ?? nextHf.block;
        if (nextHfBlock === null || nextHfBlock === undefined) {
            return null;
        }
        return BigInt(nextHfBlock);
    }
    /**
     * Returns the change block for the next hardfork after the hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number or null if not available
     * @deprecated
     */
    nextHardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        let hfBlock = this.hardforkBlock(hardfork);
        // If this is a merge hardfork with block not set, then we fallback to previous hardfork
        // to find the nextHardforkBlock
        if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {
            const hfs = this.hardforks();
            const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
            if (mergeIndex < 0) {
                throw Error(`Merge hardfork should have been found`);
            }
            hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
        }
        if (hfBlock === null) {
            return null;
        }
        // Next fork block number or null if none available
        // Logic: if accumulator is still null and on the first occurrence of
        // a block greater than the current hfBlock set the accumulator,
        // pass on the accumulator as the final result from this time on
        const nextHfBlock = this.hardforks().reduce((acc, hf) => {
            // We need to ignore the merge block in our next hardfork calc
            const block = BigInt(hf.block === null || (hf.ttd !== undefined && hf.ttd !== null) ? 0 : hf.block);
            // Typescript can't seem to follow that the hfBlock is not null at this point
            return block > hfBlock && acc === null ? block : acc;
        }, null);
        return nextHfBlock;
    }
    /**
     * True if block number provided is the hardfork change block following the hardfork given or set
     * @param blockNumber Number of the block to check
     * @param hardfork Hardfork name, optional if HF set
     * @returns True if blockNumber is HF block
     * @deprecated
     */
    isNextHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const nextHardforkBlock = this.nextHardforkBlock(hardfork);
        return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
    }
    /**
     * Internal helper function to calculate a fork hash
     * @param hardfork Hardfork name
     * @param genesisHash Genesis block hash of the chain
     * @returns Fork hash as hex string
     */
    _calcForkHash(hardfork, genesisHash) {
        let hfBuffer = Buffer.alloc(0);
        let prevBlockOrTime = 0;
        for (const hf of this.hardforks()) {
            const { block, timestamp, name } = hf;
            // Timestamp to be used for timestamp based hfs even if we may bundle
            // block number with them retrospectively
            let blockOrTime = timestamp ?? block;
            blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
            // Skip for chainstart (0), not applied HFs (null) and
            // when already applied on same blockOrTime HFs
            // and on the merge since forkhash doesn't change on merge hf
            if (typeof blockOrTime === 'number' &&
                blockOrTime !== 0 &&
                blockOrTime !== prevBlockOrTime &&
                name !== enums_1.Hardfork.Merge) {
                const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex');
                hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);
                prevBlockOrTime = blockOrTime;
            }
            if (hf.name === hardfork)
                break;
        }
        const inputBuffer = Buffer.concat([genesisHash, hfBuffer]);
        // CRC32 delivers result as signed (negative) 32-bit integer,
        // convert to hex string
        const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString('hex');
        return `0x${forkhash}`;
    }
    /**
     * Returns an eth/64 compliant fork hash (EIP-2124)
     * @param hardfork Hardfork name, optional if HF set
     * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated
     */
    forkHash(hardfork, genesisHash) {
        hardfork = hardfork ?? this._hardfork;
        const data = this._getHardfork(hardfork);
        if (data === null ||
            (data?.block === null && data?.timestamp === undefined && data?.ttd === undefined)) {
            const msg = 'No fork hash calculation possible for future hardfork';
            throw new Error(msg);
        }
        if (data?.forkHash !== null && data?.forkHash !== undefined) {
            return data.forkHash;
        }
        if (!genesisHash)
            throw new Error('genesisHash required for forkHash calculation');
        return this._calcForkHash(hardfork, genesisHash);
    }
    /**
     *
     * @param forkHash Fork hash as a hex string
     * @returns Array with hardfork data (name, block, forkHash)
     */
    hardforkForForkHash(forkHash) {
        const resArray = this.hardforks().filter((hf) => {
            return hf.forkHash === forkHash;
        });
        return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
    }
    /**
     * Sets any missing forkHashes on the passed-in {@link Common} instance
     * @param common The {@link Common} to set the forkHashes for
     * @param genesisHash The genesis block hash
     */
    setForkHashes(genesisHash) {
        for (const hf of this.hardforks()) {
            const blockOrTime = hf.timestamp ?? hf.block;
            if ((hf.forkHash === null || hf.forkHash === undefined) &&
                ((blockOrTime !== null && blockOrTime !== undefined) || typeof hf.ttd !== 'undefined')) {
                hf.forkHash = this.forkHash(hf.name, genesisHash);
            }
        }
    }
    /**
     * Returns the Genesis parameters of the current chain
     * @returns Genesis dictionary
     */
    genesis() {
        return this._chainParams.genesis;
    }
    /**
     * Returns the hardforks for current chain
     * @returns {Array} Array with arrays of hardforks
     */
    hardforks() {
        return this._chainParams.hardforks;
    }
    /**
     * Returns bootstrap nodes for the current chain
     * @returns {Dictionary} Dict with bootstrap nodes
     */
    bootstrapNodes() {
        return this._chainParams.bootstrapNodes;
    }
    /**
     * Returns DNS networks for the current chain
     * @returns {String[]} Array of DNS ENR urls
     */
    dnsNetworks() {
        return this._chainParams.dnsNetworks;
    }
    /**
     * Returns the hardfork set
     * @returns Hardfork name
     */
    hardfork() {
        return this._hardfork;
    }
    /**
     * Returns the Id of current chain
     * @returns chain Id
     */
    chainId() {
        return BigInt(this._chainParams.chainId);
    }
    /**
     * Returns the name of current chain
     * @returns chain name (lower case)
     */
    chainName() {
        return this._chainParams.name;
    }
    /**
     * Returns the Id of current network
     * @returns network Id
     */
    networkId() {
        return BigInt(this._chainParams.networkId);
    }
    /**
     * Returns the active EIPs
     * @returns List of EIPs
     */
    eips() {
        return this._eips;
    }
    /**
     * Returns the consensus type of the network
     * Possible values: "pow"|"poa"|"pos"
     *
     * Note: This value can update along a Hardfork.
     */
    consensusType() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if ('consensus' in hfChanges[1]) {
                value = hfChanges[1]['consensus']['type'];
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return value ?? this._chainParams['consensus']['type'];
    }
    /**
     * Returns the concrete consensus implementation
     * algorithm or protocol for the network
     * e.g. "ethash" for "pow" consensus type,
     * "clique" for "poa" consensus type or
     * "casper" for "pos" consensus type.
     *
     * Note: This value can update along a Hardfork.
     */
    consensusAlgorithm() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if ('consensus' in hfChanges[1]) {
                value = hfChanges[1]['consensus']['algorithm'];
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return value ?? this._chainParams['consensus']['algorithm'];
    }
    /**
     * Returns a dictionary with consensus configuration
     * parameters based on the consensus algorithm
     *
     * Expected returns (parameters must be present in
     * the respective chain json files):
     *
     * ethash: empty object
     * clique: period, epoch
     * casper: empty object
     *
     * Note: This value can update along a Hardfork.
     */
    consensusConfig() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
            if ('consensus' in hfChanges[1]) {
                // The config parameter is named after the respective consensus algorithm
                value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']];
            }
            if (hfChanges[0] === hardfork)
                break;
        }
        return (value ?? this._chainParams['consensus'][this.consensusAlgorithm()] ?? {});
    }
    /**
     * Returns a deep copy of this {@link Common} instance.
     */
    copy() {
        const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        copy.removeAllListeners();
        return copy;
    }
    static _getInitializedChains(customChains) {
        const names = {};
        for (const [name, id] of Object.entries(enums_1.Chain)) {
            names[id] = name.toLowerCase();
        }
        const chains = { mainnet, ropsten, rinkeby, goerli, sepolia };
        if (customChains) {
            for (const chain of customChains) {
                const { name } = chain;
                names[chain.chainId.toString()] = name;
                chains[name] = chain;
            }
        }
        chains.names = names;
        return chains;
    }
}
exports.Common = Common;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\common.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\1153.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C1153.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-1153",
    "number": 1153,
    "comment": "Transient Storage",
    "url": "https://eips.ethereum.org/EIPS/eip-1153",
    "status": "Review",
    "minimumHardfork": "chainstart",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {
        "tstore": {
            "v": 100,
            "d": "Base fee of the TSTORE opcode"
        },
        "tload": {
            "v": 100,
            "d": "Base fee of the TLOAD opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\1153.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\1559.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C1559.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-1559",
    "number": 1559,
    "comment": "Fee market change for ETH 1.0 chain",
    "url": "https://eips.ethereum.org/EIPS/eip-1559",
    "status": "Final",
    "minimumHardfork": "berlin",
    "requiredEIPs": [2930],
    "gasConfig": {
        "baseFeeMaxChangeDenominator": {
            "v": 8,
            "d": "Maximum base fee change denominator"
        },
        "elasticityMultiplier": {
            "v": 2,
            "d": "Maximum block gas target elasticity"
        },
        "initialBaseFee": {
            "v": 1000000000,
            "d": "Initial base fee on first EIP1559 block"
        }
    },
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\1559.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2315.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2315.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2315",
    "number": 2315,
    "comment": "Simple subroutines for the EVM",
    "url": "https://eips.ethereum.org/EIPS/eip-2315",
    "status": "Draft",
    "minimumHardfork": "istanbul",
    "gasConfig": {},
    "gasPrices": {
        "beginsub": {
            "v": 2,
            "d": "Base fee of the BEGINSUB opcode"
        },
        "returnsub": {
            "v": 5,
            "d": "Base fee of the RETURNSUB opcode"
        },
        "jumpsub": {
            "v": 10,
            "d": "Base fee of the JUMPSUB opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2315.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2537.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2537.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2537",
    "number": 2537,
    "comment": "BLS12-381 precompiles",
    "url": "https://eips.ethereum.org/EIPS/eip-2537",
    "status": "Draft",
    "minimumHardfork": "chainstart",
    "gasConfig": {},
    "gasPrices": {
        "Bls12381G1AddGas": {
            "v": 600,
            "d": "Gas cost of a single BLS12-381 G1 addition precompile-call"
        },
        "Bls12381G1MulGas": {
            "v": 12000,
            "d": "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
        },
        "Bls12381G2AddGas": {
            "v": 4500,
            "d": "Gas cost of a single BLS12-381 G2 addition precompile-call"
        },
        "Bls12381G2MulGas": {
            "v": 55000,
            "d": "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
        },
        "Bls12381PairingBaseGas": {
            "v": 115000,
            "d": "Base gas cost of BLS12-381 pairing check"
        },
        "Bls12381PairingPerPairGas": {
            "v": 23000,
            "d": "Per-pair gas cost of BLS12-381 pairing check"
        },
        "Bls12381MapG1Gas": {
            "v": 5500,
            "d": "Gas cost of BLS12-381 map field element to G1"
        },
        "Bls12381MapG2Gas": {
            "v": 110000,
            "d": "Gas cost of BLS12-381 map field element to G2"
        },
        "Bls12381MultiExpGasDiscount": {
            "v": [
                [1, 1200],
                [2, 888],
                [3, 764],
                [4, 641],
                [5, 594],
                [6, 547],
                [7, 500],
                [8, 453],
                [9, 438],
                [10, 423],
                [11, 408],
                [12, 394],
                [13, 379],
                [14, 364],
                [15, 349],
                [16, 334],
                [17, 330],
                [18, 326],
                [19, 322],
                [20, 318],
                [21, 314],
                [22, 310],
                [23, 306],
                [24, 302],
                [25, 298],
                [26, 294],
                [27, 289],
                [28, 285],
                [29, 281],
                [30, 277],
                [31, 273],
                [32, 269],
                [33, 268],
                [34, 266],
                [35, 265],
                [36, 263],
                [37, 262],
                [38, 260],
                [39, 259],
                [40, 257],
                [41, 256],
                [42, 254],
                [43, 253],
                [44, 251],
                [45, 250],
                [46, 248],
                [47, 247],
                [48, 245],
                [49, 244],
                [50, 242],
                [51, 241],
                [52, 239],
                [53, 238],
                [54, 236],
                [55, 235],
                [56, 233],
                [57, 232],
                [58, 231],
                [59, 229],
                [60, 228],
                [61, 226],
                [62, 225],
                [63, 223],
                [64, 222],
                [65, 221],
                [66, 220],
                [67, 219],
                [68, 219],
                [69, 218],
                [70, 217],
                [71, 216],
                [72, 216],
                [73, 215],
                [74, 214],
                [75, 213],
                [76, 213],
                [77, 212],
                [78, 211],
                [79, 211],
                [80, 210],
                [81, 209],
                [82, 208],
                [83, 208],
                [84, 207],
                [85, 206],
                [86, 205],
                [87, 205],
                [88, 204],
                [89, 203],
                [90, 202],
                [91, 202],
                [92, 201],
                [93, 200],
                [94, 199],
                [95, 199],
                [96, 198],
                [97, 197],
                [98, 196],
                [99, 196],
                [100, 195],
                [101, 194],
                [102, 193],
                [103, 193],
                [104, 192],
                [105, 191],
                [106, 191],
                [107, 190],
                [108, 189],
                [109, 188],
                [110, 188],
                [111, 187],
                [112, 186],
                [113, 185],
                [114, 185],
                [115, 184],
                [116, 183],
                [117, 182],
                [118, 182],
                [119, 181],
                [120, 180],
                [121, 179],
                [122, 179],
                [123, 178],
                [124, 177],
                [125, 176],
                [126, 176],
                [127, 175],
                [128, 174]
            ],
            "d": "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2537.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2565.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2565.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2565",
    "number": 2565,
    "comment": "ModExp gas cost",
    "url": "https://eips.ethereum.org/EIPS/eip-2565",
    "status": "Final",
    "minimumHardfork": "byzantium",
    "gasConfig": {},
    "gasPrices": {
        "modexpGquaddivisor": {
            "v": 3,
            "d": "Gquaddivisor from modexp precompile for gas calculation"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2565.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2718.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2718.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2718",
    "comment": "Typed Transaction Envelope",
    "url": "https://eips.ethereum.org/EIPS/eip-2718",
    "status": "Final",
    "minimumHardfork": "chainstart",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2718.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2929.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2929.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2929",
    "comment": "Gas cost increases for state access opcodes",
    "url": "https://eips.ethereum.org/EIPS/eip-2929",
    "status": "Final",
    "minimumHardfork": "chainstart",
    "gasConfig": {},
    "gasPrices": {
        "coldsload": {
            "v": 2100,
            "d": "Gas cost of the first read of storage from a given location (per transaction)"
        },
        "coldaccountaccess": {
            "v": 2600,
            "d": "Gas cost of the first read of a given address (per transaction)"
        },
        "warmstorageread": {
            "v": 100,
            "d": "Gas cost of reading storage locations which have already loaded 'cold'"
        },
        "sstoreCleanGasEIP2200": {
            "v": 2900,
            "d": "Once per SSTORE operation from clean non-zero to something else"
        },
        "sstoreNoopGasEIP2200": {
            "v": 100,
            "d": "Once per SSTORE operation if the value doesn't change"
        },
        "sstoreDirtyGasEIP2200": {
            "v": 100,
            "d": "Once per SSTORE operation if a dirty value is changed"
        },
        "sstoreInitRefundEIP2200": {
            "v": 19900,
            "d": "Once per SSTORE operation for resetting to the original zero value"
        },
        "sstoreCleanRefundEIP2200": {
            "v": 4900,
            "d": "Once per SSTORE operation for resetting to the original non-zero value"
        },
        "call": {
            "v": 0,
            "d": "Base fee of the CALL opcode"
        },
        "callcode": {
            "v": 0,
            "d": "Base fee of the CALLCODE opcode"
        },
        "delegatecall": {
            "v": 0,
            "d": "Base fee of the DELEGATECALL opcode"
        },
        "staticcall": {
            "v": 0,
            "d": "Base fee of the STATICCALL opcode"
        },
        "balance": {
            "v": 0,
            "d": "Base fee of the BALANCE opcode"
        },
        "extcodesize": {
            "v": 0,
            "d": "Base fee of the EXTCODESIZE opcode"
        },
        "extcodecopy": {
            "v": 0,
            "d": "Base fee of the EXTCODECOPY opcode"
        },
        "extcodehash": {
            "v": 0,
            "d": "Base fee of the EXTCODEHASH opcode"
        },
        "sload": {
            "v": 0,
            "d": "Base fee of the SLOAD opcode"
        },
        "sstore": {
            "v": 0,
            "d": "Base fee of the SSTORE opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2929.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2930.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C2930.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-2930",
    "comment": "Optional access lists",
    "url": "https://eips.ethereum.org/EIPS/eip-2930",
    "status": "Final",
    "minimumHardfork": "istanbul",
    "requiredEIPs": [2718, 2929],
    "gasConfig": {},
    "gasPrices": {
        "accessListStorageKeyCost": {
            "v": 1900,
            "d": "Gas cost per storage key in an Access List transaction"
        },
        "accessListAddressCost": {
            "v": 2400,
            "d": "Gas cost per storage key in an Access List transaction"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2930.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3074.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3074.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3074",
    "number": 3074,
    "comment": "AUTH and AUTHCALL opcodes",
    "url": "https://eips.ethereum.org/EIPS/eip-3074",
    "status": "Review",
    "minimumHardfork": "london",
    "gasConfig": {},
    "gasPrices": {
        "auth": {
            "v": 3100,
            "d": "Gas cost of the AUTH opcode"
        },
        "authcall": {
            "v": 0,
            "d": "Gas cost of the AUTHCALL opcode"
        },
        "authcallValueTransfer": {
            "v": 6700,
            "d": "Paid for CALL when the value transfer is non-zero"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3074.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3198.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3198.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3198",
    "number": 3198,
    "comment": "BASEFEE opcode",
    "url": "https://eips.ethereum.org/EIPS/eip-3198",
    "status": "Final",
    "minimumHardfork": "london",
    "gasConfig": {},
    "gasPrices": {
        "basefee": {
            "v": 2,
            "d": "Gas cost of the BASEFEE opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3198.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3529.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3529.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3529",
    "comment": "Reduction in refunds",
    "url": "https://eips.ethereum.org/EIPS/eip-3529",
    "status": "Final",
    "minimumHardfork": "berlin",
    "requiredEIPs": [2929],
    "gasConfig": {
        "maxRefundQuotient": {
            "v": 5,
            "d": "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
    },
    "gasPrices": {
        "selfdestructRefund": {
            "v": 0,
            "d": "Refunded following a selfdestruct operation"
        },
        "sstoreClearRefundEIP2200": {
            "v": 4800,
            "d": "Once per SSTORE operation for clearing an originally existing storage slot"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3529.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3540.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3540.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3540",
    "number": 3540,
    "comment": "EVM Object Format (EOF) v1",
    "url": "https://eips.ethereum.org/EIPS/eip-3540",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [3541],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3540.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3541.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3541.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3541",
    "comment": "Reject new contracts starting with the 0xEF byte",
    "url": "https://eips.ethereum.org/EIPS/eip-3541",
    "status": "Final",
    "minimumHardfork": "berlin",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3541.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3554.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3554.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3554",
    "comment": "Reduction in refunds",
    "url": "Difficulty Bomb Delay to December 1st 2021",
    "status": "Final",
    "minimumHardfork": "muirGlacier",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 9500000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3554.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3607.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3607.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3607",
    "number": 3607,
    "comment": "Reject transactions from senders with deployed code",
    "url": "https://eips.ethereum.org/EIPS/eip-3607",
    "status": "Final",
    "minimumHardfork": "chainstart",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3607.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3651.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3651.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3651",
    "number": 3198,
    "comment": "Warm COINBASE",
    "url": "https://eips.ethereum.org/EIPS/eip-3651",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [2929],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3651.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3670.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3670.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3670",
    "number": 3670,
    "comment": "EOF - Code Validation",
    "url": "https://eips.ethereum.org/EIPS/eip-3670",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [3540],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3670.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3675.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3675.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3675",
    "number": 3675,
    "comment": "Upgrade consensus to Proof-of-Stake",
    "url": "https://eips.ethereum.org/EIPS/eip-3675",
    "status": "Final",
    "minimumHardfork": "london",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3675.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3855.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3855.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3855",
    "number": 3855,
    "comment": "PUSH0 instruction",
    "url": "https://eips.ethereum.org/EIPS/eip-3855",
    "status": "Review",
    "minimumHardfork": "chainstart",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {
        "push0": {
            "v": 2,
            "d": "Base fee of the PUSH0 opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3855.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3860.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C3860.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-3860",
    "number": 3860,
    "comment": "Limit and meter initcode",
    "url": "https://eips.ethereum.org/EIPS/eip-3860",
    "status": "Review",
    "minimumHardfork": "spuriousDragon",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {
        "initCodeWordCost": {
            "v": 2,
            "d": "Gas to pay for each word (32 bytes) of initcode when creating a contract"
        }
    },
    "vm": {
        "maxInitCodeSize": {
            "v": 49152,
            "d": "Maximum length of initialization code when creating a contract"
        }
    },
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3860.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4345.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4345.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4345",
    "number": 4345,
    "comment": "Difficulty Bomb Delay to June 2022",
    "url": "https://eips.ethereum.org/EIPS/eip-4345",
    "status": "Final",
    "minimumHardfork": "london",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 10700000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4345.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4399.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4399.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4399",
    "number": 4399,
    "comment": "Supplant DIFFICULTY opcode with PREVRANDAO",
    "url": "https://eips.ethereum.org/EIPS/eip-4399",
    "status": "Review",
    "minimumHardfork": "london",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4399.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4844.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4844.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4844",
    "number": 4844,
    "comment": "Shard Blob Transactions",
    "url": "https://eips.ethereum.org/EIPS/eip-4844",
    "status": "Draft",
    "minimumHardfork": "merge",
    "requiredEIPs": [1559, 2718, 2930, 4895],
    "gasConfig": {
        "dataGasPerBlob": {
            "v": 131072,
            "d": "The base fee for data gas per blob"
        },
        "targetDataGasPerBlock": {
            "v": 262144,
            "d": "The target data gas consumed per block"
        },
        "maxDataGasPerBlock": {
            "v": 524288,
            "d": "The max data gas allowable per block"
        },
        "dataGasPriceUpdateFraction": {
            "v": 2225652,
            "d": "The denominator used in the exponential when calculating a data gas price"
        }
    },
    "gasPrices": {
        "simpleGasPerBlob": {
            "v": 12000,
            "d": "The basic gas fee for each blob"
        },
        "minDataGasPrice": {
            "v": 1,
            "d": "The minimum fee per data gas"
        },
        "kzgPointEvaluationGasPrecompilePrice": {
            "v": 50000,
            "d": "The fee associated with the point evaluation precompile"
        },
        "datahash": {
            "v": 3,
            "d": "Base fee of the DATAHASH opcode"
        }
    },
    "sharding": {
        "blobCommitmentVersionKzg": {
            "v": 1,
            "d": "The number indicated a versioned hash is a KZG commitment"
        },
        "fieldElementsPerBlob": {
            "v": 4096,
            "d": "The number of field elements allowed per blob"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4844.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4895.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C4895.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-4895",
    "number": 4895,
    "comment": "Beacon chain push withdrawals as operations",
    "url": "https://eips.ethereum.org/EIPS/eip-4895",
    "status": "Review",
    "minimumHardfork": "merge",
    "requiredEIPs": [],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4895.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\5133.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5C5133.json
      return function (require, module, exports) {
module.exports={
    "name": "EIP-5133",
    "number": 5133,
    "comment": "Delaying Difficulty Bomb to mid-September 2022",
    "url": "https://eips.ethereum.org/EIPS/eip-5133",
    "status": "Draft",
    "minimumHardfork": "grayGlacier",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 11400000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\5133.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\index.js", {"./1153.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\1153.json","./1559.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\1559.json","./2315.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2315.json","./2537.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2537.json","./2565.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2565.json","./2718.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2718.json","./2929.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2929.json","./2930.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\2930.json","./3074.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3074.json","./3198.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3198.json","./3529.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3529.json","./3540.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3540.json","./3541.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3541.json","./3554.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3554.json","./3607.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3607.json","./3651.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3651.json","./3670.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3670.json","./3675.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3675.json","./3855.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3855.json","./3860.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\3860.json","./4345.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4345.json","./4399.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4399.json","./4844.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4844.json","./4895.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\4895.json","./5133.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\5133.json"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ceips%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIPs = void 0;
exports.EIPs = {
    1153: require('./1153.json'),
    1559: require('./1559.json'),
    2315: require('./2315.json'),
    2537: require('./2537.json'),
    2565: require('./2565.json'),
    2718: require('./2718.json'),
    2929: require('./2929.json'),
    2930: require('./2930.json'),
    3074: require('./3074.json'),
    3198: require('./3198.json'),
    3529: require('./3529.json'),
    3540: require('./3540.json'),
    3541: require('./3541.json'),
    3554: require('./3554.json'),
    3607: require('./3607.json'),
    3651: require('./3651.json'),
    3670: require('./3670.json'),
    3675: require('./3675.json'),
    3855: require('./3855.json'),
    3860: require('./3860.json'),
    4345: require('./4345.json'),
    4399: require('./4399.json'),
    4844: require('./4844.json'),
    4895: require('./4895.json'),
    5133: require('./5133.json'),
};
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\eips\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\enums.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cenums.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomChain = exports.ConsensusAlgorithm = exports.ConsensusType = exports.Hardfork = exports.Chain = void 0;
var Chain;
(function (Chain) {
    Chain[Chain["Mainnet"] = 1] = "Mainnet";
    Chain[Chain["Ropsten"] = 3] = "Ropsten";
    Chain[Chain["Rinkeby"] = 4] = "Rinkeby";
    Chain[Chain["Goerli"] = 5] = "Goerli";
    Chain[Chain["Sepolia"] = 11155111] = "Sepolia";
})(Chain = exports.Chain || (exports.Chain = {}));
var Hardfork;
(function (Hardfork) {
    Hardfork["Chainstart"] = "chainstart";
    Hardfork["Homestead"] = "homestead";
    Hardfork["Dao"] = "dao";
    Hardfork["TangerineWhistle"] = "tangerineWhistle";
    Hardfork["SpuriousDragon"] = "spuriousDragon";
    Hardfork["Byzantium"] = "byzantium";
    Hardfork["Constantinople"] = "constantinople";
    Hardfork["Petersburg"] = "petersburg";
    Hardfork["Istanbul"] = "istanbul";
    Hardfork["MuirGlacier"] = "muirGlacier";
    Hardfork["Berlin"] = "berlin";
    Hardfork["London"] = "london";
    Hardfork["ArrowGlacier"] = "arrowGlacier";
    Hardfork["GrayGlacier"] = "grayGlacier";
    Hardfork["MergeForkIdTransition"] = "mergeForkIdTransition";
    Hardfork["Merge"] = "merge";
    Hardfork["Shanghai"] = "shanghai";
    Hardfork["ShardingForkDev"] = "shardingFork";
})(Hardfork = exports.Hardfork || (exports.Hardfork = {}));
var ConsensusType;
(function (ConsensusType) {
    ConsensusType["ProofOfStake"] = "pos";
    ConsensusType["ProofOfWork"] = "pow";
    ConsensusType["ProofOfAuthority"] = "poa";
})(ConsensusType = exports.ConsensusType || (exports.ConsensusType = {}));
var ConsensusAlgorithm;
(function (ConsensusAlgorithm) {
    ConsensusAlgorithm["Ethash"] = "ethash";
    ConsensusAlgorithm["Clique"] = "clique";
    ConsensusAlgorithm["Casper"] = "casper";
})(ConsensusAlgorithm = exports.ConsensusAlgorithm || (exports.ConsensusAlgorithm = {}));
var CustomChain;
(function (CustomChain) {
    /**
     * Polygon (Matic) Mainnet
     *
     * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
     */
    CustomChain["PolygonMainnet"] = "polygon-mainnet";
    /**
     * Polygon (Matic) Mumbai Testnet
     *
     * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
     */
    CustomChain["PolygonMumbai"] = "polygon-mumbai";
    /**
     * Arbitrum Rinkeby Testnet
     *
     * - [Documentation](https://developer.offchainlabs.com/docs/public_testnet)
     */
    CustomChain["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
    /**
     * Arbitrum One - mainnet for Arbitrum roll-up
     *
     * - [Documentation](https://developer.offchainlabs.com/public-chains)
     */
    CustomChain["ArbitrumOne"] = "arbitrum-one";
    /**
     * xDai EVM sidechain with a native stable token
     *
     * - [Documentation](https://www.xdaichain.com/)
     */
    CustomChain["xDaiChain"] = "x-dai-chain";
    /**
     * Optimistic Kovan - testnet for Optimism roll-up
     *
     * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)
     */
    CustomChain["OptimisticKovan"] = "optimistic-kovan";
    /**
     * Optimistic Ethereum - mainnet for Optimism roll-up
     *
     * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)
     */
    CustomChain["OptimisticEthereum"] = "optimistic-ethereum";
})(CustomChain = exports.CustomChain || (exports.CustomChain = {}));
//# sourceMappingURL=enums.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\enums.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\arrowGlacier.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CarrowGlacier.json
      return function (require, module, exports) {
module.exports={
    "name": "arrowGlacier",
    "comment": "HF to delay the difficulty bomb",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
    "status": "Final",
    "eips": [4345],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\arrowGlacier.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\berlin.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cberlin.json
      return function (require, module, exports) {
module.exports={
    "name": "berlin",
    "comment": "HF targeted for July 2020 following the Muir Glacier HF",
    "url": "https://eips.ethereum.org/EIPS/eip-2070",
    "status": "Final",
    "eips": [2565, 2929, 2718, 2930]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\berlin.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\byzantium.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cbyzantium.json
      return function (require, module, exports) {
module.exports={
    "name": "byzantium",
    "comment": "Hardfork with new precompiles, instructions and other protocol changes",
    "url": "https://eips.ethereum.org/EIPS/eip-609",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "modexpGquaddivisor": {
            "v": 20,
            "d": "Gquaddivisor from modexp precompile for gas calculation"
        },
        "ecAdd": {
            "v": 500,
            "d": "Gas costs for curve addition precompile"
        },
        "ecMul": {
            "v": 40000,
            "d": "Gas costs for curve multiplication precompile"
        },
        "ecPairing": {
            "v": 100000,
            "d": "Base gas costs for curve pairing precompile"
        },
        "ecPairingWord": {
            "v": 80000,
            "d": "Gas costs regarding curve pairing precompile input length"
        },
        "revert": {
            "v": 0,
            "d": "Base fee of the REVERT opcode"
        },
        "staticcall": {
            "v": 700,
            "d": "Base fee of the STATICCALL opcode"
        },
        "returndatasize": {
            "v": 2,
            "d": "Base fee of the RETURNDATASIZE opcode"
        },
        "returndatacopy": {
            "v": 3,
            "d": "Base fee of the RETURNDATACOPY opcode"
        }
    },
    "vm": {},
    "pow": {
        "minerReward": {
            "v": "3000000000000000000",
            "d": "the amount a miner get rewarded for mining a block"
        },
        "difficultyBombDelay": {
            "v": 3000000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\byzantium.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\chainstart.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cchainstart.json
      return function (require, module, exports) {
module.exports={
    "name": "chainstart",
    "comment": "Start of the Ethereum main chain",
    "url": "",
    "status": "",
    "gasConfig": {
        "minGasLimit": {
            "v": 5000,
            "d": "Minimum the gas limit may ever be"
        },
        "gasLimitBoundDivisor": {
            "v": 1024,
            "d": "The bound divisor of the gas limit, used in update calculations"
        },
        "maxRefundQuotient": {
            "v": 2,
            "d": "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
    },
    "gasPrices": {
        "base": {
            "v": 2,
            "d": "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
        },
        "tierStep": {
            "v": [0, 2, 3, 5, 8, 10, 20],
            "d": "Once per operation, for a selection of them"
        },
        "exp": {
            "v": 10,
            "d": "Base fee of the EXP opcode"
        },
        "expByte": {
            "v": 10,
            "d": "Times ceil(log256(exponent)) for the EXP instruction"
        },
        "sha3": {
            "v": 30,
            "d": "Base fee of the SHA3 opcode"
        },
        "sha3Word": {
            "v": 6,
            "d": "Once per word of the SHA3 operation's data"
        },
        "sload": {
            "v": 50,
            "d": "Base fee of the SLOAD opcode"
        },
        "sstoreSet": {
            "v": 20000,
            "d": "Once per SSTORE operation if the zeroness changes from zero"
        },
        "sstoreReset": {
            "v": 5000,
            "d": "Once per SSTORE operation if the zeroness does not change from zero"
        },
        "sstoreRefund": {
            "v": 15000,
            "d": "Once per SSTORE operation if the zeroness changes to zero"
        },
        "jumpdest": {
            "v": 1,
            "d": "Base fee of the JUMPDEST opcode"
        },
        "log": {
            "v": 375,
            "d": "Base fee of the LOG opcode"
        },
        "logData": {
            "v": 8,
            "d": "Per byte in a LOG* operation's data"
        },
        "logTopic": {
            "v": 375,
            "d": "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
        },
        "create": {
            "v": 32000,
            "d": "Base fee of the CREATE opcode"
        },
        "call": {
            "v": 40,
            "d": "Base fee of the CALL opcode"
        },
        "callStipend": {
            "v": 2300,
            "d": "Free gas given at beginning of call"
        },
        "callValueTransfer": {
            "v": 9000,
            "d": "Paid for CALL when the value transfor is non-zero"
        },
        "callNewAccount": {
            "v": 25000,
            "d": "Paid for CALL when the destination address didn't exist prior"
        },
        "selfdestructRefund": {
            "v": 24000,
            "d": "Refunded following a selfdestruct operation"
        },
        "memory": {
            "v": 3,
            "d": "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
        },
        "quadCoeffDiv": {
            "v": 512,
            "d": "Divisor for the quadratic particle of the memory cost equation"
        },
        "createData": {
            "v": 200,
            "d": ""
        },
        "tx": {
            "v": 21000,
            "d": "Per transaction. NOTE: Not payable on data of calls between transactions"
        },
        "txCreation": {
            "v": 32000,
            "d": "The cost of creating a contract via tx"
        },
        "txDataZero": {
            "v": 4,
            "d": "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
        },
        "txDataNonZero": {
            "v": 68,
            "d": "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        "copy": {
            "v": 3,
            "d": "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
        },
        "ecRecover": {
            "v": 3000,
            "d": ""
        },
        "sha256": {
            "v": 60,
            "d": ""
        },
        "sha256Word": {
            "v": 12,
            "d": ""
        },
        "ripemd160": {
            "v": 600,
            "d": ""
        },
        "ripemd160Word": {
            "v": 120,
            "d": ""
        },
        "identity": {
            "v": 15,
            "d": ""
        },
        "identityWord": {
            "v": 3,
            "d": ""
        },
        "stop": {
            "v": 0,
            "d": "Base fee of the STOP opcode"
        },
        "add": {
            "v": 3,
            "d": "Base fee of the ADD opcode"
        },
        "mul": {
            "v": 5,
            "d": "Base fee of the MUL opcode"
        },
        "sub": {
            "v": 3,
            "d": "Base fee of the SUB opcode"
        },
        "div": {
            "v": 5,
            "d": "Base fee of the DIV opcode"
        },
        "sdiv": {
            "v": 5,
            "d": "Base fee of the SDIV opcode"
        },
        "mod": {
            "v": 5,
            "d": "Base fee of the MOD opcode"
        },
        "smod": {
            "v": 5,
            "d": "Base fee of the SMOD opcode"
        },
        "addmod": {
            "v": 8,
            "d": "Base fee of the ADDMOD opcode"
        },
        "mulmod": {
            "v": 8,
            "d": "Base fee of the MULMOD opcode"
        },
        "signextend": {
            "v": 5,
            "d": "Base fee of the SIGNEXTEND opcode"
        },
        "lt": {
            "v": 3,
            "d": "Base fee of the LT opcode"
        },
        "gt": {
            "v": 3,
            "d": "Base fee of the GT opcode"
        },
        "slt": {
            "v": 3,
            "d": "Base fee of the SLT opcode"
        },
        "sgt": {
            "v": 3,
            "d": "Base fee of the SGT opcode"
        },
        "eq": {
            "v": 3,
            "d": "Base fee of the EQ opcode"
        },
        "iszero": {
            "v": 3,
            "d": "Base fee of the ISZERO opcode"
        },
        "and": {
            "v": 3,
            "d": "Base fee of the AND opcode"
        },
        "or": {
            "v": 3,
            "d": "Base fee of the OR opcode"
        },
        "xor": {
            "v": 3,
            "d": "Base fee of the XOR opcode"
        },
        "not": {
            "v": 3,
            "d": "Base fee of the NOT opcode"
        },
        "byte": {
            "v": 3,
            "d": "Base fee of the BYTE opcode"
        },
        "address": {
            "v": 2,
            "d": "Base fee of the ADDRESS opcode"
        },
        "balance": {
            "v": 20,
            "d": "Base fee of the BALANCE opcode"
        },
        "origin": {
            "v": 2,
            "d": "Base fee of the ORIGIN opcode"
        },
        "caller": {
            "v": 2,
            "d": "Base fee of the CALLER opcode"
        },
        "callvalue": {
            "v": 2,
            "d": "Base fee of the CALLVALUE opcode"
        },
        "calldataload": {
            "v": 3,
            "d": "Base fee of the CALLDATALOAD opcode"
        },
        "calldatasize": {
            "v": 2,
            "d": "Base fee of the CALLDATASIZE opcode"
        },
        "calldatacopy": {
            "v": 3,
            "d": "Base fee of the CALLDATACOPY opcode"
        },
        "codesize": {
            "v": 2,
            "d": "Base fee of the CODESIZE opcode"
        },
        "codecopy": {
            "v": 3,
            "d": "Base fee of the CODECOPY opcode"
        },
        "gasprice": {
            "v": 2,
            "d": "Base fee of the GASPRICE opcode"
        },
        "extcodesize": {
            "v": 20,
            "d": "Base fee of the EXTCODESIZE opcode"
        },
        "extcodecopy": {
            "v": 20,
            "d": "Base fee of the EXTCODECOPY opcode"
        },
        "blockhash": {
            "v": 20,
            "d": "Base fee of the BLOCKHASH opcode"
        },
        "coinbase": {
            "v": 2,
            "d": "Base fee of the COINBASE opcode"
        },
        "timestamp": {
            "v": 2,
            "d": "Base fee of the TIMESTAMP opcode"
        },
        "number": {
            "v": 2,
            "d": "Base fee of the NUMBER opcode"
        },
        "difficulty": {
            "v": 2,
            "d": "Base fee of the DIFFICULTY opcode"
        },
        "gaslimit": {
            "v": 2,
            "d": "Base fee of the GASLIMIT opcode"
        },
        "pop": {
            "v": 2,
            "d": "Base fee of the POP opcode"
        },
        "mload": {
            "v": 3,
            "d": "Base fee of the MLOAD opcode"
        },
        "mstore": {
            "v": 3,
            "d": "Base fee of the MSTORE opcode"
        },
        "mstore8": {
            "v": 3,
            "d": "Base fee of the MSTORE8 opcode"
        },
        "sstore": {
            "v": 0,
            "d": "Base fee of the SSTORE opcode"
        },
        "jump": {
            "v": 8,
            "d": "Base fee of the JUMP opcode"
        },
        "jumpi": {
            "v": 10,
            "d": "Base fee of the JUMPI opcode"
        },
        "pc": {
            "v": 2,
            "d": "Base fee of the PC opcode"
        },
        "msize": {
            "v": 2,
            "d": "Base fee of the MSIZE opcode"
        },
        "gas": {
            "v": 2,
            "d": "Base fee of the GAS opcode"
        },
        "push": {
            "v": 3,
            "d": "Base fee of the PUSH opcode"
        },
        "dup": {
            "v": 3,
            "d": "Base fee of the DUP opcode"
        },
        "swap": {
            "v": 3,
            "d": "Base fee of the SWAP opcode"
        },
        "callcode": {
            "v": 40,
            "d": "Base fee of the CALLCODE opcode"
        },
        "return": {
            "v": 0,
            "d": "Base fee of the RETURN opcode"
        },
        "invalid": {
            "v": 0,
            "d": "Base fee of the INVALID opcode"
        },
        "selfdestruct": {
            "v": 0,
            "d": "Base fee of the SELFDESTRUCT opcode"
        }
    },
    "vm": {
        "stackLimit": {
            "v": 1024,
            "d": "Maximum size of VM stack allowed"
        },
        "callCreateDepth": {
            "v": 1024,
            "d": "Maximum depth of call/create stack"
        },
        "maxExtraDataSize": {
            "v": 32,
            "d": "Maximum size extra data may be after Genesis"
        }
    },
    "pow": {
        "minimumDifficulty": {
            "v": 131072,
            "d": "The minimum that the difficulty may ever be"
        },
        "difficultyBoundDivisor": {
            "v": 2048,
            "d": "The bound divisor of the difficulty, used in the update calculations"
        },
        "durationLimit": {
            "v": 13,
            "d": "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
        },
        "epochDuration": {
            "v": 30000,
            "d": "Duration between proof-of-work epochs"
        },
        "timebombPeriod": {
            "v": 100000,
            "d": "Exponential difficulty timebomb period"
        },
        "minerReward": {
            "v": "5000000000000000000",
            "d": "the amount a miner get rewarded for mining a block"
        },
        "difficultyBombDelay": {
            "v": 0,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\chainstart.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\constantinople.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cconstantinople.json
      return function (require, module, exports) {
module.exports={
    "name": "constantinople",
    "comment": "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
    "url": "https://eips.ethereum.org/EIPS/eip-1013",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "netSstoreNoopGas": {
            "v": 200,
            "d": "Once per SSTORE operation if the value doesn't change"
        },
        "netSstoreInitGas": {
            "v": 20000,
            "d": "Once per SSTORE operation from clean zero"
        },
        "netSstoreCleanGas": {
            "v": 5000,
            "d": "Once per SSTORE operation from clean non-zero"
        },
        "netSstoreDirtyGas": {
            "v": 200,
            "d": "Once per SSTORE operation from dirty"
        },
        "netSstoreClearRefund": {
            "v": 15000,
            "d": "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        "netSstoreResetRefund": {
            "v": 4800,
            "d": "Once per SSTORE operation for resetting to the original non-zero value"
        },
        "netSstoreResetClearRefund": {
            "v": 19800,
            "d": "Once per SSTORE operation for resetting to the original zero value"
        },
        "shl": {
            "v": 3,
            "d": "Base fee of the SHL opcode"
        },
        "shr": {
            "v": 3,
            "d": "Base fee of the SHR opcode"
        },
        "sar": {
            "v": 3,
            "d": "Base fee of the SAR opcode"
        },
        "extcodehash": {
            "v": 400,
            "d": "Base fee of the EXTCODEHASH opcode"
        },
        "create2": {
            "v": 32000,
            "d": "Base fee of the CREATE2 opcode"
        }
    },
    "vm": {},
    "pow": {
        "minerReward": {
            "v": "2000000000000000000",
            "d": "The amount a miner gets rewarded for mining a block"
        },
        "difficultyBombDelay": {
            "v": 5000000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\constantinople.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\dao.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cdao.json
      return function (require, module, exports) {
module.exports={
    "name": "dao",
    "comment": "DAO rescue hardfork",
    "url": "https://eips.ethereum.org/EIPS/eip-779",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\dao.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\grayGlacier.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CgrayGlacier.json
      return function (require, module, exports) {
module.exports={
    "name": "grayGlacier",
    "comment": "Delaying the difficulty bomb to Mid September 2022",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
    "status": "Draft",
    "eips": [5133],
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\grayGlacier.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\homestead.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Chomestead.json
      return function (require, module, exports) {
module.exports={
    "name": "homestead",
    "comment": "Homestead hardfork with protocol and network changes",
    "url": "https://eips.ethereum.org/EIPS/eip-606",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "delegatecall": {
            "v": 40,
            "d": "Base fee of the DELEGATECALL opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\homestead.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\index.js", {"./arrowGlacier.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\arrowGlacier.json","./berlin.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\berlin.json","./byzantium.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\byzantium.json","./chainstart.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\chainstart.json","./constantinople.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\constantinople.json","./dao.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\dao.json","./grayGlacier.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\grayGlacier.json","./homestead.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\homestead.json","./istanbul.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\istanbul.json","./london.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\london.json","./merge.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\merge.json","./mergeForkIdTransition.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\mergeForkIdTransition.json","./muirGlacier.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\muirGlacier.json","./petersburg.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\petersburg.json","./shanghai.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\shanghai.json","./sharding.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\sharding.json","./spuriousDragon.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\spuriousDragon.json","./tangerineWhistle.json":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\tangerineWhistle.json"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hardforks = void 0;
exports.hardforks = {
    chainstart: require('./chainstart.json'),
    homestead: require('./homestead.json'),
    dao: require('./dao.json'),
    tangerineWhistle: require('./tangerineWhistle.json'),
    spuriousDragon: require('./spuriousDragon.json'),
    byzantium: require('./byzantium.json'),
    constantinople: require('./constantinople.json'),
    petersburg: require('./petersburg.json'),
    istanbul: require('./istanbul.json'),
    muirGlacier: require('./muirGlacier.json'),
    berlin: require('./berlin.json'),
    london: require('./london.json'),
    shanghai: require('./shanghai.json'),
    arrowGlacier: require('./arrowGlacier.json'),
    grayGlacier: require('./grayGlacier.json'),
    mergeForkIdTransition: require('./mergeForkIdTransition.json'),
    merge: require('./merge.json'),
    shardingFork: require('./sharding.json'),
};
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\istanbul.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cistanbul.json
      return function (require, module, exports) {
module.exports={
    "name": "istanbul",
    "comment": "HF targeted for December 2019 following the Constantinople/Petersburg HF",
    "url": "https://eips.ethereum.org/EIPS/eip-1679",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "blake2Round": {
            "v": 1,
            "d": "Gas cost per round for the Blake2 F precompile"
        },
        "ecAdd": {
            "v": 150,
            "d": "Gas costs for curve addition precompile"
        },
        "ecMul": {
            "v": 6000,
            "d": "Gas costs for curve multiplication precompile"
        },
        "ecPairing": {
            "v": 45000,
            "d": "Base gas costs for curve pairing precompile"
        },
        "ecPairingWord": {
            "v": 34000,
            "d": "Gas costs regarding curve pairing precompile input length"
        },
        "txDataNonZero": {
            "v": 16,
            "d": "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        "sstoreSentryGasEIP2200": {
            "v": 2300,
            "d": "Minimum gas required to be present for an SSTORE call, not consumed"
        },
        "sstoreNoopGasEIP2200": {
            "v": 800,
            "d": "Once per SSTORE operation if the value doesn't change"
        },
        "sstoreDirtyGasEIP2200": {
            "v": 800,
            "d": "Once per SSTORE operation if a dirty value is changed"
        },
        "sstoreInitGasEIP2200": {
            "v": 20000,
            "d": "Once per SSTORE operation from clean zero to non-zero"
        },
        "sstoreInitRefundEIP2200": {
            "v": 19200,
            "d": "Once per SSTORE operation for resetting to the original zero value"
        },
        "sstoreCleanGasEIP2200": {
            "v": 5000,
            "d": "Once per SSTORE operation from clean non-zero to something else"
        },
        "sstoreCleanRefundEIP2200": {
            "v": 4200,
            "d": "Once per SSTORE operation for resetting to the original non-zero value"
        },
        "sstoreClearRefundEIP2200": {
            "v": 15000,
            "d": "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        "balance": {
            "v": 700,
            "d": "Base fee of the BALANCE opcode"
        },
        "extcodehash": {
            "v": 700,
            "d": "Base fee of the EXTCODEHASH opcode"
        },
        "chainid": {
            "v": 2,
            "d": "Base fee of the CHAINID opcode"
        },
        "selfbalance": {
            "v": 5,
            "d": "Base fee of the SELFBALANCE opcode"
        },
        "sload": {
            "v": 800,
            "d": "Base fee of the SLOAD opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\istanbul.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\london.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Clondon.json
      return function (require, module, exports) {
module.exports={
    "name": "london",
    "comment": "HF targeted for July 2021 following the Berlin fork",
    "url": "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
    "status": "Final",
    "eips": [1559, 3198, 3529, 3541]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\london.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\merge.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cmerge.json
      return function (require, module, exports) {
module.exports={
    "name": "merge",
    "comment": "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
    "status": "Final",
    "consensus": {
        "type": "pos",
        "algorithm": "casper",
        "casper": {}
    },
    "eips": [3675, 4399]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\merge.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\mergeForkIdTransition.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CmergeForkIdTransition.json
      return function (require, module, exports) {
module.exports={
    "name": "mergeForkIdTransition",
    "comment": "Pre-merge hardfork to fork off non-upgraded clients",
    "url": "https://eips.ethereum.org/EIPS/eip-3675",
    "status": "Draft",
    "eips": []
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\mergeForkIdTransition.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\muirGlacier.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CmuirGlacier.json
      return function (require, module, exports) {
module.exports={
    "name": "muirGlacier",
    "comment": "HF to delay the difficulty bomb",
    "url": "https://eips.ethereum.org/EIPS/eip-2384",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {},
    "vm": {},
    "pow": {
        "difficultyBombDelay": {
            "v": 9000000,
            "d": "the amount of blocks to delay the difficulty bomb with"
        }
    }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\muirGlacier.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\petersburg.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cpetersburg.json
      return function (require, module, exports) {
module.exports={
    "name": "petersburg",
    "comment": "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
    "url": "https://eips.ethereum.org/EIPS/eip-1716",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "netSstoreNoopGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreInitGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreCleanGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreDirtyGas": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreClearRefund": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreResetRefund": {
            "v": null,
            "d": "Removed along EIP-1283"
        },
        "netSstoreResetClearRefund": {
            "v": null,
            "d": "Removed along EIP-1283"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\petersburg.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\shanghai.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Cshanghai.json
      return function (require, module, exports) {
module.exports={
    "name": "shanghai",
    "comment": "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
    "url": "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
    "status": "Final",
    "eips": [3651, 3855, 3860, 4895]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\shanghai.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\sharding.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5Csharding.json
      return function (require, module, exports) {
module.exports={
    "name": "shardingFork",
    "comment": "Internal hardfork to test proto-danksharding (do not use in production)",
    "url": "https://eips.ethereum.org/EIPS/eip-4844",
    "status": "Experimental",
    "eips": [4844]
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\sharding.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\spuriousDragon.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CspuriousDragon.json
      return function (require, module, exports) {
module.exports={
    "name": "spuriousDragon",
    "comment": "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
    "url": "https://eips.ethereum.org/EIPS/eip-607",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "expByte": {
            "v": 50,
            "d": "Times ceil(log256(exponent)) for the EXP instruction"
        }
    },
    "vm": {
        "maxCodeSize": {
            "v": 24576,
            "d": "Maximum length of contract code"
        }
    },
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\spuriousDragon.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\tangerineWhistle.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Chardforks%5CtangerineWhistle.json
      return function (require, module, exports) {
module.exports={
    "name": "tangerineWhistle",
    "comment": "Hardfork with gas cost changes for IO-heavy operations",
    "url": "https://eips.ethereum.org/EIPS/eip-608",
    "status": "Final",
    "gasConfig": {},
    "gasPrices": {
        "sload": {
            "v": 200,
            "d": "Once per SLOAD operation"
        },
        "call": {
            "v": 700,
            "d": "Once per CALL operation & message call transaction"
        },
        "extcodesize": {
            "v": 700,
            "d": "Base fee of the EXTCODESIZE opcode"
        },
        "extcodecopy": {
            "v": 700,
            "d": "Base fee of the EXTCODECOPY opcode"
        },
        "balance": {
            "v": 400,
            "d": "Base fee of the BALANCE opcode"
        },
        "delegatecall": {
            "v": 700,
            "d": "Base fee of the DELEGATECALL opcode"
        },
        "callcode": {
            "v": 700,
            "d": "Base fee of the CALLCODE opcode"
        },
        "selfdestruct": {
            "v": 5000,
            "d": "Base fee of the SELFDESTRUCT opcode"
        }
    },
    "vm": {},
    "pow": {}
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\hardforks\\tangerineWhistle.json",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\index.js", {"./common":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\common.js","./enums":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\enums.js","./types":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\types.js","./utils":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./common"), exports);
__exportStar(require("./enums"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\types.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\utils.js", {"./enums":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\enums.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5C@ethereumjs%5Ctx%5Cnode_modules%5C@ethereumjs%5Ccommon%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGethGenesis = void 0;
const util_1 = require("@ethereumjs/util");
const enums_1 = require("./enums");
/**
 * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally
 * @param nonce string parsed from the Geth genesis file
 * @returns nonce as a 0x-prefixed 8 byte string
 */
function formatNonce(nonce) {
    if (!nonce || nonce === '0x0') {
        return '0x0000000000000000';
    }
    if ((0, util_1.isHexPrefixed)(nonce)) {
        return '0x' + (0, util_1.stripHexPrefix)(nonce).padStart(16, '0');
    }
    return '0x' + nonce.padStart(16, '0');
}
/**
 * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object
 * @param json object representing the Geth genesis file
 * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition
 * hardfork, which by default is post merge as with the merged eth networks but could also come
 * before merge like in kiln genesis
 * @returns genesis parameters in a `CommonOpts` compliant object
 */
function parseGethParams(json, mergeForkIdPostMerge = true) {
    const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas, } = json;
    let { extraData, timestamp, nonce } = json;
    const genesisTimestamp = Number(timestamp);
    const { chainId } = config;
    // geth is not strictly putting empty fields with a 0x prefix
    if (extraData === '') {
        extraData = '0x';
    }
    // geth may use number for timestamp
    if (!(0, util_1.isHexPrefixed)(timestamp)) {
        timestamp = (0, util_1.intToHex)(parseInt(timestamp));
    }
    // geth may not give us a nonce strictly formatted to an 8 byte hex string
    if (nonce.length !== 18) {
        nonce = formatNonce(nonce);
    }
    // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time
    // but have different configuration parameters in geth genesis parameters
    if (config.eip155Block !== config.eip158Block) {
        throw new Error('EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork');
    }
    const params = {
        name,
        chainId,
        networkId: chainId,
        genesis: {
            timestamp,
            gasLimit: parseInt(gasLimit),
            difficulty: parseInt(difficulty),
            nonce,
            extraData,
            mixHash,
            coinbase,
            baseFeePerGas,
        },
        hardfork: undefined,
        hardforks: [],
        bootstrapNodes: [],
        consensus: config.clique !== undefined
            ? {
                type: 'poa',
                algorithm: 'clique',
                clique: {
                    // The recent geth genesis seems to be using blockperiodseconds
                    // and epochlength for clique specification
                    // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ
                    period: config.clique.period ?? config.clique.blockperiodseconds,
                    epoch: config.clique.epoch ?? config.clique.epochlength,
                },
            }
            : {
                type: 'pow',
                algorithm: 'ethash',
                ethash: {},
            },
    };
    const forkMap = {
        [enums_1.Hardfork.Homestead]: { name: 'homesteadBlock' },
        [enums_1.Hardfork.Dao]: { name: 'daoForkBlock' },
        [enums_1.Hardfork.TangerineWhistle]: { name: 'eip150Block' },
        [enums_1.Hardfork.SpuriousDragon]: { name: 'eip155Block' },
        [enums_1.Hardfork.Byzantium]: { name: 'byzantiumBlock' },
        [enums_1.Hardfork.Constantinople]: { name: 'constantinopleBlock' },
        [enums_1.Hardfork.Petersburg]: { name: 'petersburgBlock' },
        [enums_1.Hardfork.Istanbul]: { name: 'istanbulBlock' },
        [enums_1.Hardfork.MuirGlacier]: { name: 'muirGlacierBlock' },
        [enums_1.Hardfork.Berlin]: { name: 'berlinBlock' },
        [enums_1.Hardfork.London]: { name: 'londonBlock' },
        [enums_1.Hardfork.MergeForkIdTransition]: { name: 'mergeForkBlock', postMerge: mergeForkIdPostMerge },
        [enums_1.Hardfork.Shanghai]: { name: 'shanghaiTime', postMerge: true, isTimestamp: true },
        [enums_1.Hardfork.ShardingForkDev]: { name: 'shardingForkTime', postMerge: true, isTimestamp: true },
    };
    // forkMapRev is the map from config field name to Hardfork
    const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
        acc[forkMap[elem].name] = elem;
        return acc;
    }, {});
    const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null);
    params.hardforks = configHardforkNames
        .map((nameBlock) => ({
        name: forkMapRev[nameBlock],
        block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number'
            ? null
            : config[nameBlock],
        timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number'
            ? config[nameBlock]
            : undefined,
    }))
        .filter((fork) => fork.block !== null || fork.timestamp !== undefined);
    params.hardforks.sort(function (a, b) {
        return (a.block ?? Infinity) - (b.block ?? Infinity);
    });
    params.hardforks.sort(function (a, b) {
        return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);
    });
    if (config.terminalTotalDifficulty !== undefined) {
        // Following points need to be considered for placement of merge hf
        // - Merge hardfork can't be placed at genesis
        // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals
        // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL
        //   necessary for e.g. withdrawals
        const mergeConfig = {
            name: enums_1.Hardfork.Merge,
            ttd: config.terminalTotalDifficulty,
            block: null,
        };
        // Merge hardfork has to be placed before first hardfork that is dependent on merge
        const postMergeIndex = params.hardforks.findIndex((hf) => forkMap[hf.name]?.postMerge === true);
        if (postMergeIndex !== -1) {
            params.hardforks.splice(postMergeIndex, 0, mergeConfig);
        }
        else {
            params.hardforks.push(mergeConfig);
        }
    }
    const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;
    params.hardfork = latestHardfork?.name;
    params.hardforks.unshift({ name: enums_1.Hardfork.Chainstart, block: 0 });
    return params;
}
/**
 * Parses a genesis.json exported from Geth into parameters for Common instance
 * @param json representing the Geth genesis file
 * @param name optional chain name
 * @returns parsed params
 */
function parseGethGenesis(json, name, mergeForkIdPostMerge) {
    try {
        if (['config', 'difficulty', 'gasLimit', 'alloc'].some((field) => !(field in json))) {
            throw new Error('Invalid format, expected geth genesis fields missing');
        }
        if (name !== undefined) {
            json.name = name;
        }
        return parseGethParams(json, mergeForkIdPostMerge);
    }
    catch (e) {
        throw new Error(`Error parsing parameters file: ${e.message}`);
    }
}
exports.parseGethGenesis = parseGethGenesis;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>@ethereumjs/common",file:"node_modules\\gridplus-sdk\\node_modules\\@ethereumjs\\tx\\node_modules\\@ethereumjs\\common\\dist\\utils.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\bech32\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cbech32%5Cdist%5Cindex.js
      return function (require, module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>bech32",file:"node_modules\\gridplus-sdk\\node_modules\\bech32\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cbignumber.js%5Cbignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.1.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>bignumber.js",file:"node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\keccak.js", {"./utils":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\utils.js","@noble/hashes/sha3":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("./utils");
exports.keccak224 = (0, utils_1.wrapHash)(sha3_1.keccak_224);
exports.keccak256 = (() => {
    const k = (0, utils_1.wrapHash)(sha3_1.keccak_256);
    k.create = sha3_1.keccak_256.create;
    return k;
})();
exports.keccak384 = (0, utils_1.wrapHash)(sha3_1.keccak_384);
exports.keccak512 = (0, utils_1.wrapHash)(sha3_1.keccak_512);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\keccak.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_assert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography>@noble/hashes",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_sha2.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","./utils.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_sha2.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA2 = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography>@noble/hashes",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_sha2.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_u64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography>@noble/hashes",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5CcryptoBrowser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography>@noble/hashes",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha256.js", {"./_sha2.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_sha2.js","./utils.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Csha256.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha256 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography>@noble/hashes",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha256.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","./_u64.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js","./utils.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Csha3.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography>@noble/hashes",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js", {"@noble/hashes/crypto":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Cutils.js
      return function (require, module, exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}
exports.randomBytes = randomBytes;

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography>@noble/hashes",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\sha256.js", {"./utils":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\utils.js","@noble/hashes/sha256":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha256.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Csha256.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha256 = void 0;
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("./utils");
exports.sha256 = (0, utils_1.wrapHash)(sha256_1.sha256);

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\sha256.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\utils.js", {"@noble/hashes/_assert":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","@noble/hashes/utils":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cethereum-cryptography%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
// buf.toString('hex') -> toHex(buf)
const _assert_1 = __importDefault(require("@noble/hashes/_assert"));
const utils_1 = require("@noble/hashes/utils");
const assertBool = _assert_1.default.bool;
exports.assertBool = assertBool;
const assertBytes = _assert_1.default.bytes;
exports.assertBytes = assertBytes;
var utils_2 = require("@noble/hashes/utils");
Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
exports.bytesToUtf8 = bytesToUtf8;
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, utils_1.hexToBytes)(sliced);
}
exports.hexToBytes = hexToBytes;
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equalsBytes = equalsBytes;
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
    };
}
exports.wrapHash = wrapHash;
exports.crypto = (() => {
    const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>@ethereumjs/tx>ethereum-cryptography",file:"node_modules\\gridplus-sdk\\node_modules\\ethereum-cryptography\\utils.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js", {"_process":"F:\\metamask-extension\\node_modules\\process\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cjs-sha3%5Csrc%5Csha3.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      define(function () {
        return methods;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>js-sha3",file:"node_modules\\gridplus-sdk\\node_modules\\js-sha3\\src\\sha3.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\rlp\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Crlp%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.decode = exports.encode = void 0;
/**
 * RLP Encoding based on https://eth.wiki/en/fundamentals/rlp
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        const buf = concatBytes(...output);
        return concatBytes(encodeLength(buf.length, 192), buf);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
exports.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
exports.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
exports.utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes,
};
const RLP = { encode, decode };
exports.default = RLP;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>rlp",file:"node_modules\\gridplus-sdk\\node_modules\\rlp\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\elliptic.js", {"./lib":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Csecp256k1%5Celliptic.js
      return function (require, module, exports) {
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>secp256k1",file:"node_modules\\gridplus-sdk\\node_modules\\secp256k1\\elliptic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\lib\\elliptic.js", {"elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Csecp256k1%5Clib%5Celliptic.js
      return function (require, module, exports) {
const EC = require('elliptic').ec

const ec = new EC('secp256k1')
const ecparams = ec.curve

// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
const BN = ecparams.n.constructor

function loadCompressedPublicKey (first, xbuf) {
  let x = new BN(xbuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xbuf, ybuf) {
  let x = new BN(xbuf)
  let y = new BN(ybuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  const x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (pubkey) {
  // length should be validated in interface
  const first = pubkey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (pubkey.length !== 33) return null
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (pubkey.length !== 65) return null
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
    default:
      return null
  }
}

function savePublicKey (output, point) {
  const pubkey = point.encode(null, output.length === 33)
  // Loop should be faster because we do not need create extra Uint8Array
  // output.set(new Uint8Array(pubkey))
  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]
}

module.exports = {
  contextRandomize () {
    return 0
  },

  privateKeyVerify (seckey) {
    const bn = new BN(seckey)
    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
  },

  privateKeyNegate (seckey) {
    const bn = new BN(seckey)
    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)
    seckey.set(negate)
    return 0
  },

  privateKeyTweakAdd (seckey, tweak) {
    const bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0) return 1

    bn.iadd(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
    if (bn.isZero()) return 1

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  privateKeyTweakMul (seckey, tweak) {
    let bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    bn.imul(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  publicKeyVerify (pubkey) {
    const pair = loadPublicKey(pubkey)
    return pair === null ? 1 : 0
  },

  publicKeyCreate (output, seckey) {
    const bn = new BN(seckey)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    const point = ec.keyFromPrivate(seckey).getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyConvert (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyNegate (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    point.y = point.y.redNeg()
    savePublicKey(output, point)

    return 0
  },

  publicKeyCombine (output, pubkeys) {
    const pairs = new Array(pubkeys.length)
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i])
      if (pairs[i] === null) return 1
    }

    let point = pairs[0].getPublic()
    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakAdd (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0) return 2

    const point = pair.getPublic().add(ecparams.g.mul(tweak))
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakMul (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

    const point = pair.getPublic().mul(tweak)
    savePublicKey(output, point)

    return 0
  },

  signatureNormalize (sig) {
    const r = new BN(sig.subarray(0, 32))
    const s = new BN(sig.subarray(32, 64))
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)
    }

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport (obj, sig) {
    const sigR = sig.subarray(0, 32)
    const sigS = sig.subarray(32, 64)
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

    const { output } = obj

    // Prepare R
    let r = output.subarray(4, 4 + 33)
    r[0] = 0x00
    r.set(sigR, 1)

    let lenR = 33
    let posR = 0
    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

    r = r.subarray(posR)
    if (r[0] & 0x80) return 1
    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

    // Prepare S
    let s = output.subarray(6 + 33, 6 + 33 + 33)
    s[0] = 0x00
    s.set(sigS, 1)

    let lenS = 33
    let posS = 0
    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

    s = s.subarray(posS)
    if (s[0] & 0x80) return 1
    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

    // Set output length for return
    obj.outputlen = 6 + lenR + lenS

    // Output in specified format
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    output[0] = 0x30
    output[1] = obj.outputlen - 2
    output[2] = 0x02
    output[3] = r.length
    output.set(r, 4)
    output[4 + lenR] = 0x02
    output[5 + lenR] = s.length
    output.set(s, 6 + lenR)

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport (output, sig) {
    if (sig.length < 8) return 1
    if (sig.length > 72) return 1
    if (sig[0] !== 0x30) return 1
    if (sig[1] !== sig.length - 2) return 1
    if (sig[2] !== 0x02) return 1

    const lenR = sig[3]
    if (lenR === 0) return 1
    if (5 + lenR >= sig.length) return 1
    if (sig[4 + lenR] !== 0x02) return 1

    const lenS = sig[5 + lenR]
    if (lenS === 0) return 1
    if ((6 + lenR + lenS) !== sig.length) return 1

    if (sig[4] & 0x80) return 1
    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

    if (sig[lenR + 6] & 0x80) return 1
    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

    let sigR = sig.subarray(4, 4 + lenR)
    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)
    if (sigR.length > 32) return 1

    let sigS = sig.subarray(6 + lenR)
    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)
    if (sigS.length > 32) throw new Error('S length is too long')

    let r = new BN(sigR)
    if (r.cmp(ecparams.n) >= 0) r = new BN(0)

    let s = new BN(sig.subarray(6 + lenR))
    if (s.cmp(ecparams.n) >= 0) s = new BN(0)

    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)
    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)

    return 0
  },

  ecdsaSign (obj, message, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data, counter)

        const isValid = nonce instanceof Uint8Array && nonce.length === 32
        if (!isValid) throw new Error('This is the way')

        return new BN(nonce)
      }
    }

    const d = new BN(seckey)
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

    let sig
    try {
      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })
    } catch (err) {
      return 1
    }

    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)
    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)
    obj.recid = sig.recoveryParam

    return 0
  },

  ecdsaVerify (sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

    const pair = loadPublicKey(pubkey)
    if (pair === null) return 2

    const point = pair.getPublic()
    const isValid = ec.verify(msg32, sigObj, point)
    return isValid ? 0 : 3
  },

  ecdsaRecover (output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

    if (sigr.isZero() || sigs.isZero()) return 2

    // Can throw `throw new Error('Unable to find sencond key candinate');`
    let point
    try {
      point = ec.recoverPubKey(msg32, sigObj, recid)
    } catch (err) {
      return 2
    }

    savePublicKey(output, point)

    return 0
  },

  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const scalar = new BN(seckey)
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

    const point = pair.getPublic().mul(scalar)

    if (hashfn === undefined) {
      const data = point.encode(null, true)
      const sha256 = ec.hash().update(data).digest()
      for (let i = 0; i < 32; ++i) output[i] = sha256[i]
    } else {
      if (!xbuf) xbuf = new Uint8Array(32)
      const x = point.getX().toArray('be', 32)
      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]

      if (!ybuf) ybuf = new Uint8Array(32)
      const y = point.getY().toArray('be', 32)
      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]

      const hash = hashfn(xbuf, ybuf, data)

      const isValid = hash instanceof Uint8Array && hash.length === output.length
      if (!isValid) return 2

      output.set(hash)
    }

    return 0
  }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>secp256k1",file:"node_modules\\gridplus-sdk\\node_modules\\secp256k1\\lib\\elliptic.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\secp256k1\\lib\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Csecp256k1%5Clib%5Cindex.js
      return function (require, module, exports) {
const errors = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD:
    'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)'
}

function assert (cond, msg) {
  if (!cond) throw new Error(msg)
}

function isUint8Array (name, value, length) {
  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)

  if (length !== undefined) {
    if (Array.isArray(length)) {
      const numbers = length.join(', ')
      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`
      assert(length.includes(value.length), msg)
    } else {
      const msg = `Expected ${name} to be an Uint8Array with length ${length}`
      assert(value.length === length, msg)
    }
  }
}

function isCompressed (value) {
  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')
}

function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
  if (typeof output === 'function') output = output(length)
  isUint8Array('output', output, length)
  return output
}

function toTypeString (value) {
  return Object.prototype.toString.call(value).slice(8, -1)
}

module.exports = (secp256k1) => {
  return {
    contextRandomize (seed) {
      assert(
        seed === null || seed instanceof Uint8Array,
        'Expected seed to be an Uint8Array or null'
      )
      if (seed !== null) isUint8Array('seed', seed, 32)

      switch (secp256k1.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
      }
    },

    privateKeyVerify (seckey) {
      isUint8Array('private key', seckey, 32)

      return secp256k1.privateKeyVerify(seckey) === 0
    },

    privateKeyNegate (seckey) {
      isUint8Array('private key', seckey, 32)

      switch (secp256k1.privateKeyNegate(seckey)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    privateKeyTweakAdd (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    privateKeyTweakMul (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    publicKeyVerify (pubkey) {
      isUint8Array('public key', pubkey, [33, 65])

      return secp256k1.publicKeyVerify(pubkey) === 0
    },

    publicKeyCreate (seckey, compressed = true, output) {
      isUint8Array('private key', seckey, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCreate(output, seckey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SECKEY_INVALID)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyConvert (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyConvert(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyNegate (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyNegate(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyCombine (pubkeys, compressed = true, output) {
      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')
      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')
      for (const pubkey of pubkeys) {
        isUint8Array('public key', pubkey, [33, 65])
      }
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_COMBINE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    signatureNormalize (sig) {
      isUint8Array('signature', sig, 64)

      switch (secp256k1.signatureNormalize(sig)) {
        case 0:
          return sig
        case 1:
          throw new Error(errors.SIG_PARSE)
      }
    },

    signatureExport (sig, output) {
      isUint8Array('signature', sig, 64)
      output = getAssertedOutput(output, 72)

      const obj = { output, outputlen: 72 }
      switch (secp256k1.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen)
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    signatureImport (sig, output) {
      isUint8Array('signature', sig)
      output = getAssertedOutput(output, 64)

      switch (secp256k1.signatureImport(output, sig)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaSign (msg32, seckey, options = {}, output) {
      isUint8Array('message', msg32, 32)
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')
      output = getAssertedOutput(output, 64)

      const obj = { signature: output, recid: null }
      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj
        case 1:
          throw new Error(errors.SIGN)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaVerify (sig, msg32, pubkey) {
      isUint8Array('signature', sig, 64)
      isUint8Array('message', msg32, 32)
      isUint8Array('public key', pubkey, [33, 65])

      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true
        case 3:
          return false
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_PARSE)
      }
    },

    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
      isUint8Array('signature', sig, 64)
      assert(
        toTypeString(recid) === 'Number' &&
          recid >= 0 &&
          recid <= 3,
        'Expected recovery id to be a Number within interval [0, 3]'
      )
      isUint8Array('message', msg32, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.RECOVER)
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdh (pubkey, seckey, options = {}, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.hashfn !== undefined) {
        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')
        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)
        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)
        isUint8Array('output', output)
      } else {
        output = getAssertedOutput(output, 32)
      }

      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.ECDH)
      }
    }
  }
}

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>secp256k1",file:"node_modules\\gridplus-sdk\\node_modules\\secp256k1\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\index.js", {"./nil.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\nil.js","./parse.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\stringify.js","./v1.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v1.js","./v3.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v3.js","./v4.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v4.js","./v5.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v5.js","./validate.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\validate.js","./version.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\version.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\md5-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cmd5-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\md5-browser.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\native-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cnative-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default = {
  randomUUID
};
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\native-browser.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\nil.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cnil.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\nil.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\parse.js", {"./validate.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cparse.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\parse.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\regex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cregex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\regex.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\rng-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Crng-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\rng-browser.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\sha1-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Csha1-browser.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\sha1-browser.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\stringify.js", {"./validate.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cstringify.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.unsafeStringify = unsafeStringify;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\stringify.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v1.js", {"./rng.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cv1.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = require("./stringify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.unsafeStringify)(b);
}

var _default = v1;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v1.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v3.js", {"./md5.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\md5-browser.js","./v35.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cv3.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v3.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v35.js", {"./parse.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\parse.js","./stringify.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cv35.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URL = exports.DNS = void 0;
exports.default = v35;

var _stringify = require("./stringify.js");

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;

    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.unsafeStringify)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v35.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v4.js", {"./native.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\native-browser.js","./rng.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\rng-browser.js","./stringify.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cv4.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _native = _interopRequireDefault(require("./native.js"));

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = require("./stringify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  if (_native.default.randomUUID && !buf && !options) {
    return _native.default.randomUUID();
  }

  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.unsafeStringify)(rnds);
}

var _default = v4;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v4.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v5.js", {"./sha1.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\sha1-browser.js","./v35.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v35.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cv5.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\v5.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\validate.js", {"./regex.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\regex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cvalidate.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\validate.js",}],
["F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\version.js", {"./validate.js":"F:\\metamask-extension\\node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cgridplus-sdk%5Cnode_modules%5Cuuid%5Cdist%5Cversion.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.slice(14, 15), 16);
}

var _default = version;
exports.default = _default;
      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>uuid",file:"node_modules\\gridplus-sdk\\node_modules\\uuid\\dist\\version.js",}],
["F:\\metamask-extension\\node_modules\\int64-buffer\\int64-buffer.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cint64-buffer%5Cint64-buffer.js
      return function (require, module, exports) {
(function (Buffer){(function (){
// int64-buffer.js

/*jshint -W018 */ // Confusing use of '!'.
/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.
/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?

var Uint64BE, Int64BE, Uint64LE, Int64LE;

!function(exports) {
  // constants

  var UNDEFINED = "undefined";
  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;
  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;
  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;
  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
  var isArray = Array.isArray || _isArray;
  var BIT32 = 4294967296;
  var BIT24 = 16777216;

  // storage class

  var storage; // Array;

  // generate classes

  Uint64BE = factory("Uint64BE", true, true);
  Int64BE = factory("Int64BE", true, false);
  Uint64LE = factory("Uint64LE", false, true);
  Int64LE = factory("Int64LE", false, false);

  // class factory

  function factory(name, bigendian, unsigned) {
    var posH = bigendian ? 0 : 4;
    var posL = bigendian ? 4 : 0;
    var pos0 = bigendian ? 0 : 3;
    var pos1 = bigendian ? 1 : 2;
    var pos2 = bigendian ? 2 : 1;
    var pos3 = bigendian ? 3 : 0;
    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
    var proto = Int64.prototype;
    var isName = "is" + name;
    var _isInt64 = "_" + isName;

    // properties
    proto.buffer = void 0;
    proto.offset = 0;
    proto[_isInt64] = true;

    // methods
    proto.toNumber = toNumber;
    proto.toString = toString;
    proto.toJSON = toNumber;
    proto.toArray = toArray;

    // add .toBuffer() method only when Buffer available
    if (BUFFER) proto.toBuffer = toBuffer;

    // add .toArrayBuffer() method only when Uint8Array available
    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;

    // isUint64BE, isInt64BE
    Int64[isName] = isInt64;

    // CommonJS
    exports[name] = Int64;

    return Int64;

    // constructor
    function Int64(buffer, offset, value, raddix) {
      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);
      return init(this, buffer, offset, value, raddix);
    }

    // isUint64BE, isInt64BE
    function isInt64(b) {
      return !!(b && b[_isInt64]);
    }

    // initializer
    function init(that, buffer, offset, value, raddix) {
      if (UINT8ARRAY && ARRAYBUFFER) {
        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);
        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);
      }

      // Int64BE() style
      if (!buffer && !offset && !value && !storage) {
        // shortcut to initialize with zero
        that.buffer = newArray(ZERO, 0);
        return;
      }

      // Int64BE(value, raddix) style
      if (!isValidBuffer(buffer, offset)) {
        var _storage = storage || Array;
        raddix = offset;
        value = buffer;
        offset = 0;
        buffer = (storage === BUFFER) ? BUFFER.alloc(8) : new _storage(8);
      }

      that.buffer = buffer;
      that.offset = offset |= 0;

      // Int64BE(buffer, offset) style
      if (UNDEFINED === typeof value) return;

      // Int64BE(buffer, offset, value, raddix) style
      if ("string" === typeof value) {
        fromString(buffer, offset, value, raddix || 10);
      } else if (isValidBuffer(value, raddix)) {
        fromArray(buffer, offset, value, raddix);
      } else if ("number" === typeof raddix) {
        writeInt32(buffer, offset + posH, value); // high
        writeInt32(buffer, offset + posL, raddix); // low
      } else if (value > 0) {
        fromPositive(buffer, offset, value); // positive
      } else if (value < 0) {
        fromNegative(buffer, offset, value); // negative
      } else {
        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others
      }
    }

    function fromString(buffer, offset, str, raddix) {
      var pos = 0;
      var len = str.length;
      var high = 0;
      var low = 0;
      if (str[0] === "-") pos++;
      var sign = pos;
      while (pos < len) {
        var chr = parseInt(str[pos++], raddix);
        if (!(chr >= 0)) break; // NaN
        low = low * raddix + chr;
        high = high * raddix + Math.floor(low / BIT32);
        low %= BIT32;
      }
      if (sign) {
        high = ~high;
        if (low) {
          low = BIT32 - low;
        } else {
          high++;
        }
      }
      writeInt32(buffer, offset + posH, high);
      writeInt32(buffer, offset + posL, low);
    }

    function toNumber() {
      var buffer = this.buffer;
      var offset = this.offset;
      var high = readInt32(buffer, offset + posH);
      var low = readInt32(buffer, offset + posL);
      if (!unsigned) high |= 0; // a trick to get signed
      return high ? (high * BIT32 + low) : low;
    }

    function toString(radix) {
      var buffer = this.buffer;
      var offset = this.offset;
      var high = readInt32(buffer, offset + posH);
      var low = readInt32(buffer, offset + posL);
      var str = "";
      var sign = !unsigned && (high & 0x80000000);
      if (sign) {
        high = ~high;
        low = BIT32 - low;
      }
      radix = radix || 10;
      while (1) {
        var mod = (high % radix) * BIT32 + low;
        high = Math.floor(high / radix);
        low = Math.floor(mod / radix);
        str = (mod % radix).toString(radix) + str;
        if (!high && !low) break;
      }
      if (sign) {
        str = "-" + str;
      }
      return str;
    }

    function writeInt32(buffer, offset, value) {
      buffer[offset + pos3] = value & 255;
      value = value >> 8;
      buffer[offset + pos2] = value & 255;
      value = value >> 8;
      buffer[offset + pos1] = value & 255;
      value = value >> 8;
      buffer[offset + pos0] = value & 255;
    }

    function readInt32(buffer, offset) {
      return (buffer[offset + pos0] * BIT24) +
        (buffer[offset + pos1] << 16) +
        (buffer[offset + pos2] << 8) +
        buffer[offset + pos3];
    }
  }

  function toArray(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    storage = null; // Array

    if (raw !== false && isArray(buffer)) {
      return (buffer.length === 8) ? buffer : buffer.slice(offset, offset + 8);
    }

    return newArray(buffer, offset);
  }

  function toBuffer(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    storage = BUFFER;

    if (raw !== false && BUFFER.isBuffer(buffer)) {
      return (buffer.length === 8) ? buffer : buffer.slice(offset, offset + 8);
    }

    // Buffer.from(arraybuffer) available since Node v4.5.0
    // https://nodejs.org/en/blog/release/v4.5.0/
    return BUFFER.from(toArrayBuffer.call(this, raw));
  }

  function toArrayBuffer(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    var arrbuf = buffer.buffer;
    storage = UINT8ARRAY;

    // arrbuf.slice() ignores buffer.offset until Node v8.0.0
    if (raw !== false && !buffer.offset && (arrbuf instanceof ARRAYBUFFER)) {
      return (arrbuf.byteLength === 8) ? arrbuf : arrbuf.slice(offset, offset + 8);
    }

    var dest = new UINT8ARRAY(8);
    fromArray(dest, 0, buffer, offset);
    return dest.buffer;
  }

  function isValidBuffer(buffer, offset) {
    var len = buffer && buffer.length;
    offset |= 0;
    return len && (offset + 8 <= len) && ("string" !== typeof buffer[offset]);
  }

  function fromArray(destbuf, destoff, srcbuf, srcoff) {
    destoff |= 0;
    srcoff |= 0;
    for (var i = 0; i < 8; i++) {
      destbuf[destoff++] = srcbuf[srcoff++] & 255;
    }
  }

  function newArray(buffer, offset) {
    return Array.prototype.slice.call(buffer, offset, offset + 8);
  }

  function fromPositiveBE(buffer, offset, value) {
    var pos = offset + 8;
    while (pos > offset) {
      buffer[--pos] = value & 255;
      value /= 256;
    }
  }

  function fromNegativeBE(buffer, offset, value) {
    var pos = offset + 8;
    value++;
    while (pos > offset) {
      buffer[--pos] = ((-value) & 255) ^ 255;
      value /= 256;
    }
  }

  function fromPositiveLE(buffer, offset, value) {
    var end = offset + 8;
    while (offset < end) {
      buffer[offset++] = value & 255;
      value /= 256;
    }
  }

  function fromNegativeLE(buffer, offset, value) {
    var end = offset + 8;
    value++;
    while (offset < end) {
      buffer[offset++] = ((-value) & 255) ^ 255;
      value /= 256;
    }
  }

  // https://github.com/retrofox/is-array
  function _isArray(val) {
    return !!val && "[object Array]" == Object.prototype.toString.call(val);
  }

}(typeof exports === 'object' && typeof exports.nodeName !== 'string' ? exports : (this || {}));

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>int64-buffer",file:"node_modules\\int64-buffer\\int64-buffer.js",}],
["F:\\metamask-extension\\node_modules\\is-retry-allowed\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cis-retry-allowed%5Cindex.js
      return function (require, module, exports) {
'use strict';

const denyList = new Set([
	'ENOTFOUND',
	'ENETUNREACH',

	// SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328
	'UNABLE_TO_GET_ISSUER_CERT',
	'UNABLE_TO_GET_CRL',
	'UNABLE_TO_DECRYPT_CERT_SIGNATURE',
	'UNABLE_TO_DECRYPT_CRL_SIGNATURE',
	'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',
	'CERT_SIGNATURE_FAILURE',
	'CRL_SIGNATURE_FAILURE',
	'CERT_NOT_YET_VALID',
	'CERT_HAS_EXPIRED',
	'CRL_NOT_YET_VALID',
	'CRL_HAS_EXPIRED',
	'ERROR_IN_CERT_NOT_BEFORE_FIELD',
	'ERROR_IN_CERT_NOT_AFTER_FIELD',
	'ERROR_IN_CRL_LAST_UPDATE_FIELD',
	'ERROR_IN_CRL_NEXT_UPDATE_FIELD',
	'OUT_OF_MEM',
	'DEPTH_ZERO_SELF_SIGNED_CERT',
	'SELF_SIGNED_CERT_IN_CHAIN',
	'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',
	'UNABLE_TO_VERIFY_LEAF_SIGNATURE',
	'CERT_CHAIN_TOO_LONG',
	'CERT_REVOKED',
	'INVALID_CA',
	'PATH_LENGTH_EXCEEDED',
	'INVALID_PURPOSE',
	'CERT_UNTRUSTED',
	'CERT_REJECTED',
	'HOSTNAME_MISMATCH'
]);

// TODO: Use `error?.code` when targeting Node.js 14
module.exports = error => !denyList.has(error && error.code);

      };
    };
  }
  }
}, {package:"is-retry-allowed",file:"node_modules\\is-retry-allowed\\index.js",}],
["F:\\metamask-extension\\node_modules\\iso-url\\index.js", {"./src/relative":"F:\\metamask-extension\\node_modules\\iso-url\\src\\relative.js","./src/url":"F:\\metamask-extension\\node_modules\\iso-url\\src\\url-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ciso-url%5Cindex.js
      return function (require, module, exports) {
'use strict';

const {
    URLWithLegacySupport,
    format,
    URLSearchParams,
    defaultBase
} = require('./src/url');
const relative = require('./src/relative');

module.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams,
    format,
    relative,
    defaultBase
};

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>borc>iso-url",file:"node_modules\\iso-url\\index.js",}],
["F:\\metamask-extension\\node_modules\\iso-url\\src\\relative.js", {"./url":"F:\\metamask-extension\\node_modules\\iso-url\\src\\url-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ciso-url%5Csrc%5Crelative.js
      return function (require, module, exports) {
'use strict';

const { URLWithLegacySupport, format } = require('./url');

module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location.protocol ?
        location.protocol.replace(':', '') :
        'http';

    // Check protocol map
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';
    let urlParsed;

    try {
        urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
        urlParsed = {};
    }

    const base = Object.assign({}, location, {
        protocol: protocol || urlParsed.protocol,
        host: location.host || urlParsed.host
    });

    return new URLWithLegacySupport(url, format(base)).toString();
};

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>borc>iso-url",file:"node_modules\\iso-url\\src\\relative.js",}],
["F:\\metamask-extension\\node_modules\\iso-url\\src\\url-browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ciso-url%5Csrc%5Curl-browser.js
      return function (require, module, exports) {
'use strict';

const defaultBase = self.location ?
    self.location.protocol + '//' + self.location.host :
    '';
const URL = self.URL;

class URLWithLegacySupport {
    constructor(url = '', base = defaultBase) {
        this.super = new URL(url, base);
        this.path = this.pathname + this.search;
        this.auth =
            this.username && this.password ?
                this.username + ':' + this.password :
                null;

        this.query =
            this.search && this.search.startsWith('?') ?
                this.search.slice(1) :
                null;
    }

    get hash() {
        return this.super.hash;
    }
    get host() {
        return this.super.host;
    }
    get hostname() {
        return this.super.hostname;
    }
    get href() {
        return this.super.href;
    }
    get origin() {
        return this.super.origin;
    }
    get password() {
        return this.super.password;
    }
    get pathname() {
        return this.super.pathname;
    }
    get port() {
        return this.super.port;
    }
    get protocol() {
        return this.super.protocol;
    }
    get search() {
        return this.super.search;
    }
    get searchParams() {
        return this.super.searchParams;
    }
    get username() {
        return this.super.username;
    }

    set hash(hash) {
        this.super.hash = hash;
    }
    set host(host) {
        this.super.host = host;
    }
    set hostname(hostname) {
        this.super.hostname = hostname;
    }
    set href(href) {
        this.super.href = href;
    }
    set origin(origin) {
        this.super.origin = origin;
    }
    set password(password) {
        this.super.password = password;
    }
    set pathname(pathname) {
        this.super.pathname = pathname;
    }
    set port(port) {
        this.super.port = port;
    }
    set protocol(protocol) {
        this.super.protocol = protocol;
    }
    set search(search) {
        this.super.search = search;
    }
    set searchParams(searchParams) {
        this.super.searchParams = searchParams;
    }
    set username(username) {
        this.super.username = username;
    }

    createObjectURL(o) {
        return this.super.createObjectURL(o);
    }
    revokeObjectURL(o) {
        this.super.revokeObjectURL(o);
    }
    toJSON() {
        return this.super.toJSON();
    }
    toString() {
        return this.super.toString();
    }
    format() {
        return this.toString();
    }
}

function format(obj) {
    if (typeof obj === 'string') {
        const url = new URL(obj);

        return url.toString();
    }

    if (!(obj instanceof URL)) {
        const userPass =
            obj.username && obj.password ?
                `${obj.username}:${obj.password}@` :
                '';
        const auth = obj.auth ? obj.auth + '@' : '';
        const port = obj.port ? ':' + obj.port : '';
        const protocol = obj.protocol ? obj.protocol + '//' : '';
        const host = obj.host || '';
        const hostname = obj.hostname || '';
        const search = obj.search || (obj.query ? '?' + obj.query : '');
        const hash = obj.hash || '';
        const pathname = obj.pathname || '';
        const path = obj.path || pathname + search;

        return `${protocol}${userPass || auth}${host ||
            hostname + port}${path}${hash}`;
    }
}

module.exports = {
    URLWithLegacySupport,
    URLSearchParams: self.URLSearchParams,
    defaultBase,
    format
};

      };
    };
  }
  }
}, {package:"eth-lattice-keyring>gridplus-sdk>borc>iso-url",file:"node_modules\\iso-url\\src\\url-browser.js",}],
["F:\\metamask-extension\\node_modules\\isomorphic-fetch\\fetch-npm-browserify.js", {"whatwg-fetch":"F:\\metamask-extension\\node_modules\\whatwg-fetch\\dist\\fetch.umd.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cisomorphic-fetch%5Cfetch-npm-browserify.js
      return function (require, module, exports) {
// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
require('whatwg-fetch');
module.exports = self.fetch.bind(self);

      };
    };
  }
  }
}, {package:"@metamask/smart-transactions-controller>isomorphic-fetch",file:"node_modules\\isomorphic-fetch\\fetch-npm-browserify.js",}],
["F:\\metamask-extension\\node_modules\\join-component\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjoin-component%5Cindex.js
      return function (require, module, exports) {

/**
 * Join `arr` with the trailing `str` defaulting to "and",
 * and `sep` string defaulting to ", ".
 *
 * @param {Array} arr
 * @param {String} str
 * @param {String} sep
 * @return {String}
 * @api public
 */

module.exports = function(arr, str, sep){
  str = str || 'and';
  sep = sep || ', ';

  if (arr.length < 2) return arr[0] || '';

  var oxford = str.slice(0, 2) === sep;

  if (!oxford) {
    str = ' ' + str;
  } else if (arr.length == 2) {
    str = str.slice(1);
  }

  return arr.slice(0, -1).join(sep) + str + ' ' + arr[arr.length - 1];
};

      };
    };
  }
  }
}, {package:"@segment/loosely-validate-event>join-component",file:"node_modules\\join-component\\index.js",}],
["F:\\metamask-extension\\node_modules\\js-base64\\base64.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjs-base64%5Cbase64.js
      return function (require, module, exports) {
(function (Buffer){(function (){


//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
;(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
        ? define(factory) :
        // cf. https://github.com/dankogai/js-base64/issues/119
        (function() {
            // existing version for noConflict()
            const _Base64 = global.Base64;
            const gBase64 = factory();
            gBase64.noConflict = () => {
                global.Base64 = _Base64;
                return gBase64;
            };
            if (global.Meteor) { // Meteor.js
                Base64 = gBase64;
            }
            global.Base64 = gBase64;
        })();
}((typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
        : this
), function() {
    'use strict';

/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.6.1';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasatob = typeof atob === 'function';
const _hasbtoa = typeof btoa === 'function';
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = [...b64ch];
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
const _mkUriSafe = (src) => src
    .replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_')
    .replace(/=+$/m, '');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = _hasbtoa ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/=+$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins,
};

    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(k => gBase64.Base64[k] = gBase64[k]);
    return gBase64;
}));



}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>js-base64",file:"node_modules\\js-base64\\base64.js",}],
["F:\\metamask-extension\\node_modules\\json-rpc-middleware-stream\\dist\\createEngineStream.js", {"readable-stream":"F:\\metamask-extension\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjson-rpc-middleware-stream%5Cdist%5CcreateEngineStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
/**
 * Takes a JsonRpcEngine and returns a Duplex stream wrapping it.
 *
 * @param opts - Options bag.
 * @param opts.engine - The JsonRpcEngine to wrap in a stream.
 * @returns The stream wrapping the engine.
 */
function createEngineStream(opts) {
    if (!opts || !opts.engine) {
        throw new Error('Missing engine parameter!');
    }
    const { engine } = opts;
    const stream = new readable_stream_1.Duplex({ objectMode: true, read: () => undefined, write });
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            stream.push(message);
        });
    }
    return stream;
    /**
     * Write a JSON-RPC request to the stream.
     *
     * @param req - The JSON-rpc request.
     * @param _encoding - The stream encoding, not used.
     * @param cb - The stream write callback.
     */
    function write(req, _encoding, cb) {
        engine.handle(req, (_err, res) => {
            stream.push(res);
        });
        cb();
    }
}
exports.default = createEngineStream;
//# sourceMappingURL=createEngineStream.js.map
      };
    };
  }
  }
}, {package:"json-rpc-middleware-stream",file:"node_modules\\json-rpc-middleware-stream\\dist\\createEngineStream.js",}],
["F:\\metamask-extension\\node_modules\\json-rpc-middleware-stream\\dist\\createStreamMiddleware.js", {"@metamask/safe-event-emitter":"F:\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js","readable-stream":"F:\\metamask-extension\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjson-rpc-middleware-stream%5Cdist%5CcreateStreamMiddleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const readable_stream_1 = require("readable-stream");
/**
 * Creates a JsonRpcEngine middleware with an associated Duplex stream and
 * EventEmitter. The middleware, and by extension stream, assume that middleware
 * parameters are properly formatted. No runtime type checking or validation is
 * performed.
 *
 * @param options - Configuration options for middleware.
 * @returns The event emitter, middleware, and stream.
 */
function createStreamMiddleware(options = {}) {
    const idMap = {}; // TODO: replace with actual Map
    const stream = new readable_stream_1.Duplex({
        objectMode: true,
        read: () => undefined,
        write: processMessage,
    });
    const events = new safe_event_emitter_1.default();
    const middleware = (req, res, next, end) => {
        // write req to stream
        sendToStream(req);
        // register request on id map
        idMap[req.id] = { req, res, next, end };
    };
    return { events, middleware, stream };
    /**
     * Forwards JSON-RPC request to the stream.
     *
     * @param req - The JSON-RPC request object.
     */
    function sendToStream(req) {
        // TODO: limiting retries could be implemented here
        stream.push(req);
    }
    /**
     * Writes a JSON-RPC object to the stream.
     *
     * @param res - The JSON-RPC response object.
     * @param _encoding - The stream encoding, not used.
     * @param cb - The stream write callback.
     */
    function processMessage(res, _encoding, cb) {
        let err = null;
        try {
            const isNotification = !res.id;
            if (isNotification) {
                processNotification(res);
            }
            else {
                processResponse(res);
            }
        }
        catch (_err) {
            err = _err;
        }
        // continue processing stream
        cb(err);
    }
    /**
     * Processes a JSON-RPC response.
     *
     * @param res - The response to process.
     */
    function processResponse(res) {
        const context = idMap[res.id];
        if (!context) {
            console.warn(`StreamMiddleware - Unknown response id "${res.id}"`);
            return;
        }
        delete idMap[res.id];
        // copy whole res onto original res
        Object.assign(context.res, res);
        // run callback on empty stack,
        // prevent internal stream-handler from catching errors
        setTimeout(context.end);
    }
    /**
     * Processes a JSON-RPC notification.
     *
     * @param notif - The notification to process.
     */
    function processNotification(notif) {
        if ((options === null || options === void 0 ? void 0 : options.retryOnMessage) && notif.method === options.retryOnMessage) {
            retryStuckRequests();
        }
        events.emit('notification', notif);
    }
    /**
     * Retry pending requests.
     */
    function retryStuckRequests() {
        Object.values(idMap).forEach(({ req, retryCount = 0 }) => {
            // Avoid retrying requests without an id - they cannot have matching responses so retry logic doesn't apply
            // Check for retry count below ensure that a request is not retried more than 3 times
            if (!req.id) {
                return;
            }
            if (retryCount >= 3) {
                throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${req.id}"`);
            }
            idMap[req.id].retryCount = retryCount + 1;
            sendToStream(req);
        });
    }
}
exports.default = createStreamMiddleware;
//# sourceMappingURL=createStreamMiddleware.js.map
      };
    };
  }
  }
}, {package:"json-rpc-middleware-stream",file:"node_modules\\json-rpc-middleware-stream\\dist\\createStreamMiddleware.js",}],
["F:\\metamask-extension\\node_modules\\json-rpc-middleware-stream\\dist\\index.js", {"./createEngineStream":"F:\\metamask-extension\\node_modules\\json-rpc-middleware-stream\\dist\\createEngineStream.js","./createStreamMiddleware":"F:\\metamask-extension\\node_modules\\json-rpc-middleware-stream\\dist\\createStreamMiddleware.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjson-rpc-middleware-stream%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStreamMiddleware = exports.createEngineStream = void 0;
const createEngineStream_1 = __importDefault(require("./createEngineStream"));
exports.createEngineStream = createEngineStream_1.default;
const createStreamMiddleware_1 = __importDefault(require("./createStreamMiddleware"));
exports.createStreamMiddleware = createStreamMiddleware_1.default;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"json-rpc-middleware-stream",file:"node_modules\\json-rpc-middleware-stream\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\json-stable-stringify\\index.js", {"jsonify":"F:\\metamask-extension\\node_modules\\jsonify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjson-stable-stringify%5Cindex.js
      return function (require, module, exports) {
'use strict';

var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

var isArray = Array.isArray || function (x) {
	return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
	var has = Object.prototype.hasOwnProperty || function () { return true; };
	var keys = [];
	for (var key in obj) {
		if (has.call(obj, key)) { keys.push(key); }
	}
	return keys;
};

module.exports = function (obj, opts) {
	if (!opts) { opts = {}; }
	if (typeof opts === 'function') { opts = { cmp: opts }; }
	var space = opts.space || '';
	if (typeof space === 'number') { space = Array(space + 1).join(' '); }
	var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;
	var replacer = opts.replacer || function (key, value) { return value; };

	var cmp = opts.cmp && (function (f) {
		return function (node) {
			return function (a, b) {
				var aobj = { key: a, value: node[a] };
				var bobj = { key: b, value: node[b] };
				return f(aobj, bobj);
			};
		};
	}(opts.cmp));

	var seen = [];
	return (function stringify(parent, key, node, level) {
		var indent = space ? '\n' + new Array(level + 1).join(space) : '';
		var colonSeparator = space ? ': ' : ':';

		if (node && node.toJSON && typeof node.toJSON === 'function') {
			node = node.toJSON();
		}

		node = replacer.call(parent, key, node);

		if (node === undefined) {
			return;
		}
		if (typeof node !== 'object' || node === null) {
			return json.stringify(node);
		}
		if (isArray(node)) {
			var out = [];
			for (var i = 0; i < node.length; i++) {
				var item = stringify(node, i, node[i], level + 1) || json.stringify(null);
				out.push(indent + space + item);
			}
			return '[' + out.join(',') + indent + ']';
		}

		if (seen.indexOf(node) !== -1) {
			if (cycles) { return json.stringify('__cycle__'); }
			throw new TypeError('Converting circular structure to JSON');
		} else { seen.push(node); }

		var keys = objectKeys(node).sort(cmp && cmp(node));
		var out = [];
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			var value = stringify(node, key, node[key], level + 1);

			if (!value) { continue; }

			var keyValue = json.stringify(key)
					+ colonSeparator
					+ value;

			out.push(indent + space + keyValue);
		}
		seen.splice(seen.indexOf(node), 1);
		return '{' + out.join(',') + indent + '}';

	}({ '': obj }, '', obj, 0));
};

      };
    };
  }
  }
}, {package:"lavamoat>json-stable-stringify",file:"node_modules\\json-stable-stringify\\index.js",}],
["F:\\metamask-extension\\node_modules\\jsonify\\index.js", {"./lib/parse":"F:\\metamask-extension\\node_modules\\jsonify\\lib\\parse.js","./lib/stringify":"F:\\metamask-extension\\node_modules\\jsonify\\lib\\stringify.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsonify%5Cindex.js
      return function (require, module, exports) {
'use strict';

exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

      };
    };
  }
  }
}, {package:"lavamoat>json-stable-stringify>jsonify",file:"node_modules\\jsonify\\index.js",}],
["F:\\metamask-extension\\node_modules\\jsonify\\lib\\parse.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsonify%5Clib%5Cparse.js
      return function (require, module, exports) {
'use strict';

var at; // The index of the current character
var ch; // The current character
var escapee = {
	'"': '"',
	'\\': '\\',
	'/': '/',
	b: '\b',
	f: '\f',
	n: '\n',
	r: '\r',
	t: '\t'
};
var text;

// Call error when something is wrong.
function error(m) {
	throw {
		name: 'SyntaxError',
		message: m,
		at: at,
		text: text
	};
}

function next(c) {
	// If a c parameter is provided, verify that it matches the current character.
	if (c && c !== ch) {
		error("Expected '" + c + "' instead of '" + ch + "'");
	}

	// Get the next character. When there are no more characters, return the empty string.

	ch = text.charAt(at);
	at += 1;
	return ch;
}

function number() {
	// Parse a number value.
	var num;
	var str = '';

	if (ch === '-') {
		str = '-';
		next('-');
	}
	while (ch >= '0' && ch <= '9') {
		str += ch;
		next();
	}
	if (ch === '.') {
		str += '.';
		while (next() && ch >= '0' && ch <= '9') {
			str += ch;
		}
	}
	if (ch === 'e' || ch === 'E') {
		str += ch;
		next();
		if (ch === '-' || ch === '+') {
			str += ch;
			next();
		}
		while (ch >= '0' && ch <= '9') {
			str += ch;
			next();
		}
	}
	num = Number(str);
	if (!isFinite(num)) {
		error('Bad number');
	}
	return num;
}

function string() {
	// Parse a string value.
	var hex;
	var i;
	var str = '';
	var uffff;

	// When parsing for string values, we must look for " and \ characters.
	if (ch === '"') {
		while (next()) {
			if (ch === '"') {
				next();
				return str;
			} else if (ch === '\\') {
				next();
				if (ch === 'u') {
					uffff = 0;
					for (i = 0; i < 4; i += 1) {
						hex = parseInt(next(), 16);
						if (!isFinite(hex)) {
							break;
						}
						uffff = (uffff * 16) + hex;
					}
					str += String.fromCharCode(uffff);
				} else if (typeof escapee[ch] === 'string') {
					str += escapee[ch];
				} else {
					break;
				}
			} else {
				str += ch;
			}
		}
	}
	error('Bad string');
}

// Skip whitespace.
function white() {
	while (ch && ch <= ' ') {
		next();
	}
}

// true, false, or null.
function word() {
	switch (ch) {
		case 't':
			next('t');
			next('r');
			next('u');
			next('e');
			return true;
		case 'f':
			next('f');
			next('a');
			next('l');
			next('s');
			next('e');
			return false;
		case 'n':
			next('n');
			next('u');
			next('l');
			next('l');
			return null;
		default:
			error("Unexpected '" + ch + "'");
	}
}

// Parse an array value.
function array() {
	var arr = [];

	if (ch === '[') {
		next('[');
		white();
		if (ch === ']') {
			next(']');
			return arr; // empty array
		}
		while (ch) {
			arr.push(value()); // eslint-disable-line no-use-before-define
			white();
			if (ch === ']') {
				next(']');
				return arr;
			}
			next(',');
			white();
		}
	}
	error('Bad array');
}

// Parse an object value.
function object() {
	var key;
	var obj = {};

	if (ch === '{') {
		next('{');
		white();
		if (ch === '}') {
			next('}');
			return obj; // empty object
		}
		while (ch) {
			key = string();
			white();
			next(':');
			if (Object.prototype.hasOwnProperty.call(obj, key)) {
				error('Duplicate key "' + key + '"');
			}
			obj[key] = value(); // eslint-disable-line no-use-before-define
			white();
			if (ch === '}') {
				next('}');
				return obj;
			}
			next(',');
			white();
		}
	}
	error('Bad object');
}

// Parse a JSON value. It could be an object, an array, a string, a number, or a word.
function value() {
	white();
	switch (ch) {
		case '{':
			return object();
		case '[':
			return array();
		case '"':
			return string();
		case '-':
			return number();
		default:
			return ch >= '0' && ch <= '9' ? number() : word();
	}
}

// Return the json_parse function. It will have access to all of the above functions and variables.
module.exports = function (source, reviver) {
	var result;

	text = source;
	at = 0;
	ch = ' ';
	result = value();
	white();
	if (ch) {
		error('Syntax error');
	}

	// If there is a reviver function, we recursively walk the new structure,
	// passing each name/value pair to the reviver function for possible
	// transformation, starting with a temporary root object that holds the result
	// in an empty key. If there is not a reviver function, we simply return the
	// result.

	return typeof reviver === 'function' ? (function walk(holder, key) {
		var k;
		var v;
		var val = holder[key];
		if (val && typeof val === 'object') {
			for (k in value) {
				if (Object.prototype.hasOwnProperty.call(val, k)) {
					v = walk(val, k);
					if (typeof v === 'undefined') {
						delete val[k];
					} else {
						val[k] = v;
					}
				}
			}
		}
		return reviver.call(holder, key, val);
	}({ '': result }, '')) : result;
};

      };
    };
  }
  }
}, {package:"lavamoat>json-stable-stringify>jsonify",file:"node_modules\\jsonify\\lib\\parse.js",}],
["F:\\metamask-extension\\node_modules\\jsonify\\lib\\stringify.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsonify%5Clib%5Cstringify.js
      return function (require, module, exports) {
'use strict';

var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
var gap;
var indent;
var meta = { // table of character substitutions
	'\b': '\\b',
	'\t': '\\t',
	'\n': '\\n',
	'\f': '\\f',
	'\r': '\\r',
	'"': '\\"',
	'\\': '\\\\'
};
var rep;

function quote(string) {
	// If the string contains no control characters, no quote characters, and no
	// backslash characters, then we can safely slap some quotes around it.
	// Otherwise we must also replace the offending characters with safe escape sequences.

	escapable.lastIndex = 0;
	return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
		var c = meta[a];
		return typeof c === 'string' ? c
			: '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	}) + '"' : '"' + string + '"';
}

function str(key, holder) {
	// Produce a string from holder[key].
	var i; // The loop counter.
	var k; // The member key.
	var v; // The member value.
	var length;
	var mind = gap;
	var partial;
	var value = holder[key];

	// If the value has a toJSON method, call it to obtain a replacement value.
	if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
		value = value.toJSON(key);
	}

	// If we were called with a replacer function, then call the replacer to obtain a replacement value.
	if (typeof rep === 'function') {
		value = rep.call(holder, key, value);
	}

	// What happens next depends on the value's type.
	switch (typeof value) {
		case 'string':
			return quote(value);

		case 'number':
			// JSON numbers must be finite. Encode non-finite numbers as null.
			return isFinite(value) ? String(value) : 'null';

		case 'boolean':
		case 'null':
			// If the value is a boolean or null, convert it to a string. Note:
			// typeof null does not produce 'null'. The case is included here in
			// the remote chance that this gets fixed someday.
			return String(value);

		case 'object':
			if (!value) {
				return 'null';
			}
			gap += indent;
			partial = [];

			// Array.isArray
			if (Object.prototype.toString.apply(value) === '[object Array]') {
				length = value.length;
				for (i = 0; i < length; i += 1) {
					partial[i] = str(i, value) || 'null';
				}

				// Join all of the elements together, separated with commas, and wrap them in brackets.
				v = partial.length === 0 ? '[]' : gap
					? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
					: '[' + partial.join(',') + ']';
				gap = mind;
				return v;
			}

			// If the replacer is an array, use it to select the members to be stringified.
			if (rep && typeof rep === 'object') {
				length = rep.length;
				for (i = 0; i < length; i += 1) {
					k = rep[i];
					if (typeof k === 'string') {
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			} else {
				// Otherwise, iterate through all of the keys in the object.
				for (k in value) {
					if (Object.prototype.hasOwnProperty.call(value, k)) {
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			}

			// Join all of the member texts together, separated with commas, and wrap them in braces.

			v = partial.length === 0 ? '{}' : gap
				? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
				: '{' + partial.join(',') + '}';
			gap = mind;
			return v;
		default:
	}
}

module.exports = function (value, replacer, space) {
	var i;
	gap = '';
	indent = '';

	// If the space parameter is a number, make an indent string containing that many spaces.
	if (typeof space === 'number') {
		for (i = 0; i < space; i += 1) {
			indent += ' ';
		}
	} else if (typeof space === 'string') {
		// If the space parameter is a string, it will be used as the indent string.
		indent = space;
	}

	// If there is a replacer, it must be a function or an array. Otherwise, throw an error.
	rep = replacer;
	if (
		replacer
		&& typeof replacer !== 'function'
		&& (typeof replacer !== 'object' || typeof replacer.length !== 'number')
	) {
		throw new Error('JSON.stringify');
	}

	// Make a fake root object containing our value under the key of ''.
	// Return the result of stringifying the value.
	return str('', { '': value });
};

      };
    };
  }
  }
}, {package:"lavamoat>json-stable-stringify>jsonify",file:"node_modules\\jsonify\\lib\\stringify.js",}],
["F:\\metamask-extension\\node_modules\\jsonschema\\lib\\attribute.js", {"./helpers":"F:\\metamask-extension\\node_modules\\jsonschema\\lib\\helpers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsonschema%5Clib%5Cattribute.js
      return function (require, module, exports) {
'use strict';

var helpers = require('./helpers');

/** @type ValidatorResult */
var ValidatorResult = helpers.ValidatorResult;
/** @type SchemaError */
var SchemaError = helpers.SchemaError;

var attribute = {};

attribute.ignoreProperties = {
  // informative properties
  'id': true,
  'default': true,
  'description': true,
  'title': true,
  // arguments to other properties
  'exclusiveMinimum': true,
  'exclusiveMaximum': true,
  'additionalItems': true,
  // special-handled properties
  '$schema': true,
  '$ref': true,
  'extends': true
};

/**
 * @name validators
 */
var validators = attribute.validators = {};

/**
 * Validates whether the instance if of a certain type
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.type = function validateType (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var types = Array.isArray(schema.type) ? schema.type : [schema.type];
  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
    var list = types.map(function (v) {
      return v.id && ('<' + v.id + '>') || (v+'');
    });
    result.addError({
      name: 'type',
      argument: list,
      message: "is not of a type(s) " + list,
    });
  }
  return result;
};

function testSchema(instance, options, ctx, callback, schema){
  var res = this.validateSchema(instance, schema, options, ctx);
  if (! res.valid && callback instanceof Function) {
    callback(res);
  }
  return res.valid;
}

/**
 * Validates whether the instance matches some of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.anyOf = function validateAnyOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var inner = new ValidatorResult(instance, schema, options, ctx);
  if (!Array.isArray(schema.anyOf)){
    throw new SchemaError("anyOf must be an array");
  }
  if (!schema.anyOf.some(
    testSchema.bind(
      this, instance, options, ctx, function(res){inner.importErrors(res);}
      ))) {
    var list = schema.anyOf.map(function (v, i) {
      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
    });
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'anyOf',
      argument: list,
      message: "is not any of " + list.join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance matches every given schema
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.allOf = function validateAllOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.allOf)){
    throw new SchemaError("allOf must be an array");
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var self = this;
  schema.allOf.forEach(function(v, i){
    var valid = self.validateSchema(instance, v, options, ctx);
    if(!valid.valid){
      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
      result.addError({
        name: 'allOf',
        argument: { id: msg, length: valid.errors.length, valid: valid },
        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',
      });
      result.importErrors(valid);
    }
  });
  return result;
};

/**
 * Validates whether the instance matches exactly one of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.oneOf = function validateOneOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.oneOf)){
    throw new SchemaError("oneOf must be an array");
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var inner = new ValidatorResult(instance, schema, options, ctx);
  var count = schema.oneOf.filter(
    testSchema.bind(
      this, instance, options, ctx, function(res) {inner.importErrors(res);}
      ) ).length;
  var list = schema.oneOf.map(function (v, i) {
    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
  });
  if (count!==1) {
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'oneOf',
      argument: list,
      message: "is not exactly one from " + list.join(','),
    });
  }
  return result;
};

/**
 * Validates properties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.properties = function validateProperties (instance, schema, options, ctx) {
  if(instance === undefined || !(instance instanceof Object)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var properties = schema.properties || {};
  for (var property in properties) {
    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, properties[property], options, ctx);
    }

    var prop = (instance || undefined) && instance[property];
    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
  return result;
};

/**
 * Test a specific property within in instance against the additionalProperties schema attribute
 * This ignores properties with definitions in the properties schema attribute, but no other attributes.
 * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)
 * @private
 * @return {boolean}
 */
function testAdditionalProperty (instance, schema, options, ctx, property, result) {
  if (schema.properties && schema.properties[property] !== undefined) {
    return;
  }
  if (schema.additionalProperties === false) {
    result.addError({
      name: 'additionalProperties',
      argument: property,
      message: "additionalProperty " + JSON.stringify(property) + " exists in instance when not allowed",
    });
  } else {
    var additionalProperties = schema.additionalProperties || {};

    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, additionalProperties, options, ctx);
    }

    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
}

/**
 * Validates patternProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {
  if(instance === undefined) return;
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var patternProperties = schema.patternProperties || {};

  for (var property in instance) {
    var test = true;
    for (var pattern in patternProperties) {
      var expr = new RegExp(pattern);
      if (!expr.test(property)) {
        continue;
      }
      test = false;

      if (typeof options.preValidateProperty == 'function') {
        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);
      }

      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));
      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
      result.importErrors(res);
    }
    if (test) {
      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
    }
  }

  return result;
};

/**
 * Validates additionalProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {
  if(instance === undefined) return;
  if(!this.types.object(instance)) return;
  // if patternProperties is defined then we'll test when that one is called instead
  if (schema.patternProperties) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  for (var property in instance) {
    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minProperties = function validateMinProperties (instance, schema, options, ctx) {
  if (!instance || typeof instance !== 'object') {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length >= schema.minProperties)) {
    result.addError({
      name: 'minProperties',
      argument: schema.minProperties,
      message: "does not meet minimum property length of " + schema.minProperties,
    })
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {
  if (!instance || typeof instance !== 'object') {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length <= schema.maxProperties)) {
    result.addError({
      name: 'maxProperties',
      argument: schema.maxProperties,
      message: "does not meet maximum property length of " + schema.maxProperties,
    });
  }
  return result;
};

/**
 * Validates items when instance is an array
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.items = function validateItems (instance, schema, options, ctx) {
  if (!Array.isArray(instance)) {
    return null;
  }
  var self = this;
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (instance === undefined || !schema.items) {
    return result;
  }
  instance.every(function (value, i) {
    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;
    if (items === undefined) {
      return true;
    }
    if (items === false) {
      result.addError({
        name: 'items',
        message: "additionalItems not permitted",
      });
      return false;
    }
    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));
    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;
    result.importErrors(res);
    return true;
  });
  return result;
};

/**
 * Validates minimum and exclusiveMinimum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minimum = function validateMinimum (instance, schema, options, ctx) {
  if (typeof instance !== 'number') {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var valid = true;
  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
    valid = instance > schema.minimum;
  } else {
    valid = instance >= schema.minimum;
  }
  if (!valid) {
    result.addError({
      name: 'minimum',
      argument: schema.minimum,
      message: "must have a minimum value of " + schema.minimum,
    });
  }
  return result;
};

/**
 * Validates maximum and exclusiveMaximum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maximum = function validateMaximum (instance, schema, options, ctx) {
  if (typeof instance !== 'number') {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  var valid;
  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
    valid = instance < schema.maximum;
  } else {
    valid = instance <= schema.maximum;
  }
  if (!valid) {
    result.addError({
      name: 'maximum',
      argument: schema.maximum,
      message: "must have a maximum value of " + schema.maximum,
    });
  }
  return result;
};

/**
 * Perform validation for multipleOf and divisibleBy, which are essentially the same.
 * @param instance
 * @param schema
 * @param validationType
 * @param errorMessage
 * @returns {String|null}
 */
var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {
  if (typeof instance !== 'number') {
    return null;
  }

  var validationArgument = schema[validationType];
  if (validationArgument == 0) {
    throw new SchemaError(validationType + " cannot be zero");
  }

  var result = new ValidatorResult(instance, schema, options, ctx);

  var instanceDecimals = helpers.getDecimalPlaces(instance);
  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);

  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);
  var multiplier = Math.pow(10, maxDecimals);

  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
    result.addError({
      name: validationType,
      argument:  validationArgument,
      message: errorMessage + JSON.stringify(validationArgument)
    });
  }

  return result;
};

/**
 * Validates divisibleBy when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {
 return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
};

/**
 * Validates multipleOf when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {
  return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
};

/**
 * Validates whether the instance value is present.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.required = function validateRequired (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (instance === undefined && schema.required === true) {
    // A boolean form is implemented for reverse-compatability with schemas written against older drafts
    result.addError({
      name: 'required',
      message: "is required"
    });
  } else if (instance && typeof instance==='object' && Array.isArray(schema.required)) {
    schema.required.forEach(function(n){
      if(instance[n]===undefined){
        result.addError({
          name: 'required',
          argument: n,
          message: "requires property " + JSON.stringify(n),
        });
      }
    });
  }
  return result;
};

/**
 * Validates whether the instance value matches the regular expression, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.pattern = function validatePattern (instance, schema, options, ctx) {
  if (typeof instance !== 'string') {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!instance.match(schema.pattern)) {
    result.addError({
      name: 'pattern',
      argument: schema.pattern,
      message: "does not match pattern " + JSON.stringify(schema.pattern),
    });
  }
  return result;
};

/**
 * Validates whether the instance value is of a certain defined format or a custom
 * format.
 * The following formats are supported for string types:
 *   - date-time
 *   - date
 *   - time
 *   - ip-address
 *   - ipv6
 *   - uri
 *   - color
 *   - host-name
 *   - alpha
 *   - alpha-numeric
 *   - utc-millisec
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {String|null}
 */
validators.format = function validateFormat (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
    result.addError({
      name: 'format',
      argument: schema.format,
      message: "does not conform to the " + JSON.stringify(schema.format) + " format",
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minLength = function validateMinLength (instance, schema, options, ctx) {
  if (!(typeof instance === 'string')) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length >= schema.minLength)) {
    result.addError({
      name: 'minLength',
      argument: schema.minLength,
      message: "does not meet minimum length of " + schema.minLength,
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxLength = function validateMaxLength (instance, schema, options, ctx) {
  if (!(typeof instance === 'string')) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length <= schema.maxLength)) {
    result.addError({
      name: 'maxLength',
      argument: schema.maxLength,
      message: "does not meet maximum length of " + schema.maxLength,
    });
  }
  return result;
};

/**
 * Validates whether instance contains at least a minimum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minItems = function validateMinItems (instance, schema, options, ctx) {
  if (!Array.isArray(instance)) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length >= schema.minItems)) {
    result.addError({
      name: 'minItems',
      argument: schema.minItems,
      message: "does not meet minimum length of " + schema.minItems,
    });
  }
  return result;
};

/**
 * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxItems = function validateMaxItems (instance, schema, options, ctx) {
  if (!Array.isArray(instance)) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!(instance.length <= schema.maxItems)) {
    result.addError({
      name: 'maxItems',
      argument: schema.maxItems,
      message: "does not meet maximum length of " + schema.maxItems,
    });
  }
  return result;
};

/**
 * Validates that every item in an instance array is unique, when instance is an array
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!Array.isArray(instance)) {
    return result;
  }
  function testArrays (v, i, a) {
    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {
      return false;
    }
    return true;
  }
  if (!instance.every(testArrays)) {
    result.addError({
      name: 'uniqueItems',
      message: "contains duplicate item",
    });
  }
  return result;
};

/**
 * Deep compares arrays for duplicates
 * @param v
 * @param i
 * @param a
 * @private
 * @return {boolean}
 */
function testArrays (v, i, a) {
  var j, len = a.length;
  for (j = i + 1, len; j < len; j++) {
    if (helpers.deepCompareStrict(v, a[j])) {
      return false;
    }
  }
  return true;
}

/**
 * Validates whether there are no duplicates, when the instance is an Array.
 * @param instance
 * @return {String|null}
 */
validators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {
  if (!Array.isArray(instance)) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!instance.every(testArrays)) {
    result.addError({
      name: 'uniqueItems',
      message: "contains duplicate item",
    });
  }
  return result;
};

/**
 * Validate for the presence of dependency properties, if the instance is an object.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.dependencies = function validateDependencies (instance, schema, options, ctx) {
  if (!instance || typeof instance != 'object') {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  for (var property in schema.dependencies) {
    if (instance[property] === undefined) {
      continue;
    }
    var dep = schema.dependencies[property];
    var childContext = ctx.makeChild(dep, property);
    if (typeof dep == 'string') {
      dep = [dep];
    }
    if (Array.isArray(dep)) {
      dep.forEach(function (prop) {
        if (instance[prop] === undefined) {
          result.addError({
            // FIXME there's two different "dependencies" errors here with slightly different outputs
            // Can we make these the same? Or should we create different error types?
            name: 'dependencies',
            argument: childContext.propertyPath,
            message: "property " + prop + " not found, required by " + childContext.propertyPath,
          });
        }
      });
    } else {
      var res = this.validateSchema(instance, dep, options, childContext);
      if(result.instance !== res.instance) result.instance = res.instance;
      if (res && res.errors.length) {
        result.addError({
          name: 'dependencies',
          argument: childContext.propertyPath,
          message: "does not meet dependency required by " + childContext.propertyPath,
        });
        result.importErrors(res);
      }
    }
  }
  return result;
};

/**
 * Validates whether the instance value is one of the enumerated values.
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['enum'] = function validateEnum (instance, schema, options, ctx) {
  if (!Array.isArray(schema['enum'])) {
    throw new SchemaError("enum expects an array", schema);
  }
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {
    result.addError({
      name: 'enum',
      argument: schema['enum'],
      message: "is not one of enum values: " + schema['enum'].join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance exactly matches a given value
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['const'] = function validateEnum (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!helpers.deepCompareStrict(schema['const'], instance)) {
    result.addError({
      name: 'const',
      argument: schema['const'],
      message: "does not exactly match expected constant: " + schema['const'],
    });
  }
  return result;
};

/**
 * Validates whether the instance if of a prohibited type.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {
  var self = this;
  if(instance===undefined) return null;
  var result = new ValidatorResult(instance, schema, options, ctx);
  var notTypes = schema.not || schema.disallow;
  if(!notTypes) return null;
  if(!Array.isArray(notTypes)) notTypes=[notTypes];
  notTypes.forEach(function (type) {
    if (self.testType(instance, schema, options, ctx, type)) {
      var schemaId = type && type.id && ('<' + type.id + '>') || type;
      result.addError({
        name: 'not',
        argument: schemaId,
        message: "is of prohibited type " + schemaId,
      });
    }
  });
  return result;
};

module.exports = attribute;

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>jsonschema",file:"node_modules\\jsonschema\\lib\\attribute.js",}],
["F:\\metamask-extension\\node_modules\\jsonschema\\lib\\helpers.js", {"url":"F:\\metamask-extension\\node_modules\\url\\url.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsonschema%5Clib%5Chelpers.js
      return function (require, module, exports) {
'use strict';

var uri = require('url');

var ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {
  if (propertyPath) {
    this.property = propertyPath;
  }
  if (message) {
    this.message = message;
  }
  if (schema) {
    if (schema.id) {
      this.schema = schema.id;
    } else {
      this.schema = schema;
    }
  }
  if (instance) {
    this.instance = instance;
  }
  this.name = name;
  this.argument = argument;
  this.stack = this.toString();
};

ValidationError.prototype.toString = function toString() {
  return this.property + ' ' + this.message;
};

var ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {
  this.instance = instance;
  this.schema = schema;
  this.propertyPath = ctx.propertyPath;
  this.errors = [];
  this.throwError = options && options.throwError;
  this.disableFormat = options && options.disableFormat === true;
};

ValidatorResult.prototype.addError = function addError(detail) {
  var err;
  if (typeof detail == 'string') {
    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);
  } else {
    if (!detail) throw new Error('Missing error detail');
    if (!detail.message) throw new Error('Missing error message');
    if (!detail.name) throw new Error('Missing validator type');
    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);
  }

  if (this.throwError) {
    throw err;
  }
  this.errors.push(err);
  return err;
};

ValidatorResult.prototype.importErrors = function importErrors(res) {
  if (typeof res == 'string' || (res && res.validatorType)) {
    this.addError(res);
  } else if (res && res.errors) {
    Array.prototype.push.apply(this.errors, res.errors);
  }
};

function stringizer (v,i){
  return i+': '+v.toString()+'\n';
}
ValidatorResult.prototype.toString = function toString(res) {
  return this.errors.map(stringizer).join('');
};

Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
  return !this.errors.length;
} });

/**
 * Describes a problem with a Schema which prevents validation of an instance
 * @name SchemaError
 * @constructor
 */
var SchemaError = exports.SchemaError = function SchemaError (msg, schema) {
  this.message = msg;
  this.schema = schema;
  Error.call(this, msg);
  Error.captureStackTrace(this, SchemaError);
};
SchemaError.prototype = Object.create(Error.prototype,
  { constructor: {value: SchemaError, enumerable: false}
  , name: {value: 'SchemaError', enumerable: false}
  });

var SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {
  this.schema = schema;
  this.options = options;
  this.propertyPath = propertyPath;
  this.base = base;
  this.schemas = schemas;
};

SchemaContext.prototype.resolve = function resolve (target) {
  return uri.resolve(this.base, target);
};

SchemaContext.prototype.makeChild = function makeChild(schema, propertyName){
  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);
  var base = uri.resolve(this.base, schema.id||'');
  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));
  if(schema.id && !ctx.schemas[base]){
    ctx.schemas[base] = schema;
  }
  return ctx;
}

var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
  'date-time': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
  'date': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,

  'email': /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
  'ipv6': /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/,

  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,

  // hostname regex from: http://stackoverflow.com/a/1420225/5628
  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,

  'alpha': /^[a-zA-Z]+$/,
  'alphanumeric': /^[a-zA-Z0-9]+$/,
  'utc-millisec': function (input) {
    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
  },
  'regex': function (input) {
    var result = true;
    try {
      new RegExp(input);
    } catch (e) {
      result = false;
    }
    return result;
  },
  'style': /\s*(.+?):\s*([^;]+);?/g,
  'phone': /^\+(?:[0-9] ?){6,14}[0-9]$/
};

FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];

exports.isFormat = function isFormat (input, format, validator) {
  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {
    if (FORMAT_REGEXPS[format] instanceof RegExp) {
      return FORMAT_REGEXPS[format].test(input);
    }
    if (typeof FORMAT_REGEXPS[format] === 'function') {
      return FORMAT_REGEXPS[format](input);
    }
  } else if (validator && validator.customFormats &&
      typeof validator.customFormats[format] === 'function') {
    return validator.customFormats[format](input);
  }
  return true;
};

var makeSuffix = exports.makeSuffix = function makeSuffix (key) {
  key = key.toString();
  // This function could be capable of outputting valid a ECMAScript string, but the
  // resulting code for testing which form to use would be tens of thousands of characters long
  // That means this will use the name form for some illegal forms
  if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
    return '.' + key;
  }
  if (key.match(/^\d+$/)) {
    return '[' + key + ']';
  }
  return '[' + JSON.stringify(key) + ']';
};

exports.deepCompareStrict = function deepCompareStrict (a, b) {
  if (typeof a !== typeof b) {
    return false;
  }
  if (a instanceof Array) {
    if (!(b instanceof Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every(function (v, i) {
      return deepCompareStrict(a[i], b[i]);
    });
  }
  if (typeof a === 'object') {
    if (!a || !b) {
      return a === b;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    return aKeys.every(function (v) {
      return deepCompareStrict(a[v], b[v]);
    });
  }
  return a === b;
};

function deepMerger (target, dst, e, i) {
  if (typeof e === 'object') {
    dst[i] = deepMerge(target[i], e)
  } else {
    if (target.indexOf(e) === -1) {
      dst.push(e)
    }
  }
}

function copyist (src, dst, key) {
  dst[key] = src[key];
}

function copyistWithDeepMerge (target, src, dst, key) {
  if (typeof src[key] !== 'object' || !src[key]) {
    dst[key] = src[key];
  }
  else {
    if (!target[key]) {
      dst[key] = src[key];
    } else {
      dst[key] = deepMerge(target[key], src[key])
    }
  }
}

function deepMerge (target, src) {
  var array = Array.isArray(src);
  var dst = array && [] || {};

  if (array) {
    target = target || [];
    dst = dst.concat(target);
    src.forEach(deepMerger.bind(null, target, dst));
  } else {
    if (target && typeof target === 'object') {
      Object.keys(target).forEach(copyist.bind(null, target, dst));
    }
    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
  }

  return dst;
};

module.exports.deepMerge = deepMerge;

/**
 * Validates instance against the provided schema
 * Implements URI+JSON Pointer encoding, e.g. "%7e"="~0"=>"~", "~1"="%2f"=>"/"
 * @param o
 * @param s The path to walk o along
 * @return any
 */
exports.objectGetPath = function objectGetPath(o, s) {
  var parts = s.split('/').slice(1);
  var k;
  while (typeof (k=parts.shift()) == 'string') {
    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));
    if (!(n in o)) return;
    o = o[n];
  }
  return o;
};

function pathEncoder (v) {
  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');
}
/**
 * Accept an Array of property names and return a JSON Pointer URI fragment
 * @param Array a
 * @return {String}
 */
exports.encodePath = function encodePointer(a){
	// ~ must be encoded explicitly because hacks
	// the slash is encoded by encodeURIComponent
	return a.map(pathEncoder).join('');
};


/**
 * Calculate the number of decimal places a number uses
 * We need this to get correct results out of multipleOf and divisibleBy
 * when either figure is has decimal places, due to IEEE-754 float issues.
 * @param number
 * @returns {number}
 */
exports.getDecimalPlaces = function getDecimalPlaces(number) {

  var decimalPlaces = 0;
  if (isNaN(number)) return decimalPlaces;

  if (typeof number !== 'number') {
    number = Number(number);
  }

  var parts = number.toString().split('e');
  if (parts.length === 2) {
    if (parts[1][0] !== '-') {
      return decimalPlaces;
    } else {
      decimalPlaces = Number(parts[1].slice(1));
    }
  }

  var decimalParts = parts[0].split('.');
  if (decimalParts.length === 2) {
    decimalPlaces += decimalParts[1].length;
  }

  return decimalPlaces;
};


      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>jsonschema",file:"node_modules\\jsonschema\\lib\\helpers.js",}],
["F:\\metamask-extension\\node_modules\\jsonschema\\lib\\index.js", {"./helpers":"F:\\metamask-extension\\node_modules\\jsonschema\\lib\\helpers.js","./validator":"F:\\metamask-extension\\node_modules\\jsonschema\\lib\\validator.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsonschema%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict';

var Validator = module.exports.Validator = require('./validator');

module.exports.ValidatorResult = require('./helpers').ValidatorResult;
module.exports.ValidationError = require('./helpers').ValidationError;
module.exports.SchemaError = require('./helpers').SchemaError;

module.exports.validate = function (instance, schema, options) {
  var v = new Validator();
  return v.validate(instance, schema, options);
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>jsonschema",file:"node_modules\\jsonschema\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\jsonschema\\lib\\validator.js", {"./attribute":"F:\\metamask-extension\\node_modules\\jsonschema\\lib\\attribute.js","./helpers":"F:\\metamask-extension\\node_modules\\jsonschema\\lib\\helpers.js","url":"F:\\metamask-extension\\node_modules\\url\\url.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cjsonschema%5Clib%5Cvalidator.js
      return function (require, module, exports) {
'use strict';

var urilib = require('url');

var attribute = require('./attribute');
var helpers = require('./helpers');
var ValidatorResult = helpers.ValidatorResult;
var SchemaError = helpers.SchemaError;
var SchemaContext = helpers.SchemaContext;

/**
 * Creates a new Validator object
 * @name Validator
 * @constructor
 */
var Validator = function Validator () {
  // Allow a validator instance to override global custom formats or to have their
  // own custom formats.
  this.customFormats = Object.create(Validator.prototype.customFormats);
  this.schemas = {};
  this.unresolvedRefs = [];

  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.
  this.types = Object.create(types);
  this.attributes = Object.create(attribute.validators);
};

// Allow formats to be registered globally.
Validator.prototype.customFormats = {};

// Hint at the presence of a property
Validator.prototype.schemas = null;
Validator.prototype.types = null;
Validator.prototype.attributes = null;
Validator.prototype.unresolvedRefs = null;

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param schema
 * @param urn
 * @return {Object}
 */
Validator.prototype.addSchema = function addSchema (schema, uri) {
  if (!schema) {
    return null;
  }
  var ourUri = uri || schema.id;
  this.addSubSchema(ourUri, schema);
  if (ourUri) {
    this.schemas[ourUri] = schema;
  }
  return this.schemas[ourUri];
};

Validator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {
  if(!schema || typeof schema!='object') return;
  // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined
  if(schema.$ref){
    var resolvedUri = urilib.resolve(baseuri, schema.$ref);
    // Only mark unknown schemas as unresolved
    if (this.schemas[resolvedUri] === undefined) {
      this.schemas[resolvedUri] = null;
      this.unresolvedRefs.push(resolvedUri);
    }
    return;
  }
  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);
  var ourBase = ourUri || baseuri;
  if (ourUri) {
    if(this.schemas[ourUri]){
      if(!helpers.deepCompareStrict(this.schemas[ourUri], schema)){
        throw new Error('Schema <'+schema+'> already exists with different definition');
      }
      return this.schemas[ourUri];
    }
    this.schemas[ourUri] = schema;
    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');
    this.schemas[documentUri] = schema;
  }
  this.addSubSchemaArray(ourBase, ((schema.items instanceof Array)?schema.items:[schema.items]));
  this.addSubSchemaArray(ourBase, ((schema.extends instanceof Array)?schema.extends:[schema.extends]));
  this.addSubSchema(ourBase, schema.additionalItems);
  this.addSubSchemaObject(ourBase, schema.properties);
  this.addSubSchema(ourBase, schema.additionalProperties);
  this.addSubSchemaObject(ourBase, schema.definitions);
  this.addSubSchemaObject(ourBase, schema.patternProperties);
  this.addSubSchemaObject(ourBase, schema.dependencies);
  this.addSubSchemaArray(ourBase, schema.disallow);
  this.addSubSchemaArray(ourBase, schema.allOf);
  this.addSubSchemaArray(ourBase, schema.anyOf);
  this.addSubSchemaArray(ourBase, schema.oneOf);
  this.addSubSchema(ourBase, schema.not);
  return this.schemas[ourUri];
};

Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
  if(!(schemas instanceof Array)) return;
  for(var i=0; i<schemas.length; i++){
    this.addSubSchema(baseuri, schemas[i]);
  }
};

Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
  if(!schemas || typeof schemas!='object') return;
  for(var p in schemas){
    this.addSubSchema(baseuri, schemas[p]);
  }
};



/**
 * Sets all the schemas of the Validator instance.
 * @param schemas
 */
Validator.prototype.setSchemas = function setSchemas (schemas) {
  this.schemas = schemas;
};

/**
 * Returns the schema of a certain urn
 * @param urn
 */
Validator.prototype.getSchema = function getSchema (urn) {
  return this.schemas[urn];
};

/**
 * Validates instance against the provided schema
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {Array}
 */
Validator.prototype.validate = function validate (instance, schema, options, ctx) {
  if (!options) {
    options = {};
  }
  var propertyName = options.propertyName || 'instance';
  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI
  var base = urilib.resolve(options.base||'/', schema.id||'');
  if(!ctx){
    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));
    if (!ctx.schemas[base]) {
      ctx.schemas[base] = schema;
    }
  }
  if (schema) {
    var result = this.validateSchema(instance, schema, options, ctx);
    if (!result) {
      throw new Error('Result undefined');
    }
    return result;
  }
  throw new SchemaError('no schema specified', schema);
};

/**
* @param Object schema
* @return mixed schema uri or false
*/
function shouldResolve(schema) {
  var ref = (typeof schema === 'string') ? schema : schema.$ref;
  if (typeof ref=='string') return ref;
  return false;
}

/**
 * Validates an instance against the schema (the actual work horse)
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @private
 * @return {ValidatorResult}
 */
Validator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);
  if (!schema) {
    throw new Error("schema is undefined");
  }

  if (schema['extends']) {
    if (schema['extends'] instanceof Array) {
      var schemaobj = {schema: schema, ctx: ctx};
      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));
      schema = schemaobj.schema;
      schemaobj.schema = null;
      schemaobj.ctx = null;
      schemaobj = null;
    } else {
      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));
    }
  }

  var switchSchema;
  if (switchSchema = shouldResolve(schema)) {
    var resolved = this.resolve(schema, switchSchema, ctx);
    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);
    return this.validateSchema(instance, resolved.subschema, options, subctx);
  }

  var skipAttributes = options && options.skipAttributes || [];
  // Validate each schema attribute against the instance
  for (var key in schema) {
    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
      var validatorErr = null;
      var validator = this.attributes[key];
      if (validator) {
        validatorErr = validator.call(this, instance, schema, options, ctx);
      } else if (options.allowUnknownAttributes === false) {
        // This represents an error with the schema itself, not an invalid instance
        throw new SchemaError("Unsupported attribute: " + key, schema);
      }
      if (validatorErr) {
        result.importErrors(validatorErr);
      }
    }
  }

  if (typeof options.rewrite == 'function') {
    var value = options.rewrite.call(this, instance, schema, options, ctx);
    result.instance = value;
  }
  return result;
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {
  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
}

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.superResolve = function superResolve (schema, ctx) {
  var ref;
  if(ref = shouldResolve(schema)) {
    return this.resolve(schema, ref, ctx).subschema;
  }
  return schema;
}

/**
* @private
* @param Object schema
* @param Object switchSchema
* @param SchemaContext ctx
* @return Object resolved schemas {subschema:String, switchSchema: String}
* @throws SchemaError
*/
Validator.prototype.resolve = function resolve (schema, switchSchema, ctx) {
  switchSchema = ctx.resolve(switchSchema);
  // First see if the schema exists under the provided URI
  if (ctx.schemas[switchSchema]) {
    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};
  }
  // Else try walking the property pointer
  var parsed = urilib.parse(switchSchema);
  var fragment = parsed && parsed.hash;
  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
  if (!document || !ctx.schemas[document]) {
    throw new SchemaError("no such schema <" + switchSchema + ">", schema);
  }
  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
  if(subschema===undefined){
    throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
  }
  return {subschema: subschema, switchSchema: switchSchema};
};

/**
 * Tests whether the instance if of a certain type.
 * @private
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @param type
 * @return {boolean}
 */
Validator.prototype.testType = function validateType (instance, schema, options, ctx, type) {
  if (typeof this.types[type] == 'function') {
    return this.types[type].call(this, instance);
  }
  if (type && typeof type == 'object') {
    var res = this.validateSchema(instance, type, options, ctx);
    return res === undefined || !(res && res.errors.length);
  }
  // Undefined or properties not on the list are acceptable, same as not being defined
  return true;
};

var types = Validator.prototype.types = {};
types.string = function testString (instance) {
  return typeof instance == 'string';
};
types.number = function testNumber (instance) {
  // isFinite returns false for NaN, Infinity, and -Infinity
  return typeof instance == 'number' && isFinite(instance);
};
types.integer = function testInteger (instance) {
  return (typeof instance == 'number') && instance % 1 === 0;
};
types.boolean = function testBoolean (instance) {
  return typeof instance == 'boolean';
};
types.array = function testArray (instance) {
  return Array.isArray(instance);
};
types['null'] = function testNull (instance) {
  return instance === null;
};
types.date = function testDate (instance) {
  return instance instanceof Date;
};
types.any = function testAny (instance) {
  return true;
};
types.object = function testObject (instance) {
  // TODO: fix this - see #15
  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);
};

module.exports = Validator;

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>jsonschema",file:"node_modules\\jsonschema\\lib\\validator.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseInRange.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseInRange.js
      return function (require, module, exports) {
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * The base implementation of `_.inRange` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */
function baseInRange(number, start, end) {
  return number >= nativeMin(start, end) && number < nativeMax(start, end);
}

module.exports = baseInRange;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseInRange.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_baseTrim.js", {"./_trimmedEndIndex":"F:\\metamask-extension\\node_modules\\lodash\\_trimmedEndIndex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_baseTrim.js
      return function (require, module, exports) {
var trimmedEndIndex = require('./_trimmedEndIndex');

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_baseTrim.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\_trimmedEndIndex.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5C_trimmedEndIndex.js
      return function (require, module, exports) {
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\_trimmedEndIndex.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\inRange.js", {"./_baseInRange":"F:\\metamask-extension\\node_modules\\lodash\\_baseInRange.js","./toFinite":"F:\\metamask-extension\\node_modules\\lodash\\toFinite.js","./toNumber":"F:\\metamask-extension\\node_modules\\lodash\\toNumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CinRange.js
      return function (require, module, exports) {
var baseInRange = require('./_baseInRange'),
    toFinite = require('./toFinite'),
    toNumber = require('./toNumber');

/**
 * Checks if `n` is between `start` and up to, but not including, `end`. If
 * `end` is not specified, it's set to `start` with `start` then set to `0`.
 * If `start` is greater than `end` the params are swapped to support
 * negative ranges.
 *
 * @static
 * @memberOf _
 * @since 3.3.0
 * @category Number
 * @param {number} number The number to check.
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 * @see _.range, _.rangeRight
 * @example
 *
 * _.inRange(3, 2, 4);
 * // => true
 *
 * _.inRange(4, 8);
 * // => true
 *
 * _.inRange(4, 2);
 * // => false
 *
 * _.inRange(2, 2);
 * // => false
 *
 * _.inRange(1.2, 2);
 * // => true
 *
 * _.inRange(5.2, 4);
 * // => false
 *
 * _.inRange(-3, -2, -6);
 * // => true
 */
function inRange(number, start, end) {
  start = toFinite(start);
  if (end === undefined) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  number = toNumber(number);
  return baseInRange(number, start, end);
}

module.exports = inRange;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\inRange.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isEmpty.js", {"./_baseKeys":"F:\\metamask-extension\\node_modules\\lodash\\_baseKeys.js","./_getTag":"F:\\metamask-extension\\node_modules\\lodash\\_getTag.js","./_isPrototype":"F:\\metamask-extension\\node_modules\\lodash\\_isPrototype.js","./isArguments":"F:\\metamask-extension\\node_modules\\lodash\\isArguments.js","./isArray":"F:\\metamask-extension\\node_modules\\lodash\\isArray.js","./isArrayLike":"F:\\metamask-extension\\node_modules\\lodash\\isArrayLike.js","./isBuffer":"F:\\metamask-extension\\node_modules\\lodash\\isBuffer.js","./isTypedArray":"F:\\metamask-extension\\node_modules\\lodash\\isTypedArray.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisEmpty.js
      return function (require, module, exports) {
var baseKeys = require('./_baseKeys'),
    getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isPrototype = require('./_isPrototype'),
    isTypedArray = require('./isTypedArray');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isEmpty.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\isInteger.js", {"./toInteger":"F:\\metamask-extension\\node_modules\\lodash\\toInteger.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CisInteger.js
      return function (require, module, exports) {
var toInteger = require('./toInteger');

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

module.exports = isInteger;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\isInteger.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\toFinite.js", {"./toNumber":"F:\\metamask-extension\\node_modules\\lodash\\toNumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CtoFinite.js
      return function (require, module, exports) {
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\toFinite.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\toInteger.js", {"./toFinite":"F:\\metamask-extension\\node_modules\\lodash\\toFinite.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CtoInteger.js
      return function (require, module, exports) {
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\toInteger.js",}],
["F:\\metamask-extension\\node_modules\\lodash\\toNumber.js", {"./_baseTrim":"F:\\metamask-extension\\node_modules\\lodash\\_baseTrim.js","./isObject":"F:\\metamask-extension\\node_modules\\lodash\\isObject.js","./isSymbol":"F:\\metamask-extension\\node_modules\\lodash\\isSymbol.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clodash%5CtoNumber.js
      return function (require, module, exports) {
var baseTrim = require('./_baseTrim'),
    isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

      };
    };
  }
  }
}, {package:"lodash",file:"node_modules\\lodash\\toNumber.js",}],
["F:\\metamask-extension\\node_modules\\long\\src\\long.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Clong%5Csrc%5Clong.js
      return function (require, module, exports) {
module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>long",file:"node_modules\\long\\src\\long.js",}],
["F:\\metamask-extension\\node_modules\\multibase\\src\\base.js", {"./util":"F:\\metamask-extension\\node_modules\\multibase\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
'use strict'

const { encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__("./types").BaseName} BaseName */
/** @typedef {__import__("./types").BaseCode} BaseCode */

/**
 * Class to encode/decode in the supported Bases
 *
 */
class Base {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor (name, code, factory, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = encodeText(this.code)
    this.alphabet = alphabet
    this.codec = factory(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.codec.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.codec.decode(string)
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multibase",file:"node_modules\\multibase\\src\\base.js",}],
["F:\\metamask-extension\\node_modules\\multibase\\src\\constants.js", {"./base.js":"F:\\metamask-extension\\node_modules\\multibase\\src\\base.js","./rfc4648":"F:\\metamask-extension\\node_modules\\multibase\\src\\rfc4648.js","./util":"F:\\metamask-extension\\node_modules\\multibase\\src\\util.js","@multiformats/base-x":"F:\\metamask-extension\\node_modules\\@multiformats\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

const baseX = require('@multiformats/base-x')
const Base = require('./base.js')
const { rfc4648 } = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__('./types').Codec} Codec */
/** @typedef {__import__('./types').BaseName} BaseName */
/** @typedef {__import__('./types').BaseCode} BaseCode */

/** @type {CodecFactory} */
const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

/** @type {Record<BaseName,Base>} */
const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, /** @type {Record<BaseName,Base>} */({}))

/** @type {Record<BaseCode,Base>} */
const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, /** @type {Record<BaseCode,Base>} */({}))

module.exports = {
  names,
  codes
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multibase",file:"node_modules\\multibase\\src\\constants.js",}],
["F:\\metamask-extension\\node_modules\\multibase\\src\\index.js", {"./constants":"F:\\metamask-extension\\node_modules\\multibase\\src\\constants.js","./util":"F:\\metamask-extension\\node_modules\\multibase\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultibase%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 */
'use strict'

const constants = require('./constants')
const { encodeText, decodeText, concat } = require('./util')

/** @typedef {__import__('./base')} Base */
/** @typedef {__import__("./types").BaseNameOrCode} BaseNameOrCode */
/** @typedef {__import__("./types").BaseCode} BaseCode */
/** @typedef {__import__("./types").BaseName} BaseName */

/**
 * Create a new Uint8Array with the multibase varint+code.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded Uint8Array')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  return concat([codeBuf, buf], codeBuf.length + buf.length)
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)
  const data = encodeText(enc.encode(buf))

  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(/** @type {BaseCode} */(data[0]))
  return enc.decode(data.substring(1))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(/** @type {BaseCode} */(data[0]))
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {BaseNameOrCode} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {BaseNameOrCode} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */(nameOrCode))) {
    return constants.names[/** @type {BaseName} */(nameOrCode)]
  } else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */(nameOrCode))) {
    return constants.codes[/** @type {BaseCode} */(nameOrCode)]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(/** @type {BaseCode} */(data[0]))
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
const names = Object.freeze(constants.names)
const codes = Object.freeze(constants.codes)
exports.names = names
exports.codes = codes

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multibase",file:"node_modules\\multibase\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\multibase\\src\\rfc4648.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultibase%5Csrc%5Crfc4648.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./types').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
const rfc4648 = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

module.exports = { rfc4648 }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multibase",file:"node_modules\\multibase\\src\\rfc4648.js",}],
["F:\\metamask-extension\\node_modules\\multibase\\src\\util.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmultibase%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */
function concat (arrs, length) {
  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrs) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = { decodeText, encodeText, concat }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multibase",file:"node_modules\\multibase\\src\\util.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\decode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cdecode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec>varint",file:"node_modules\\multicodec\\node_modules\\varint\\decode.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\encode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cencode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec>varint",file:"node_modules\\multicodec\\node_modules\\varint\\encode.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\index.js", {"./decode.js":"F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\decode.js","./encode.js":"F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\encode.js","./length.js":"F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\length.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cindex.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec>varint",file:"node_modules\\multicodec\\node_modules\\varint\\index.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\length.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Clength.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec>varint",file:"node_modules\\multicodec\\node_modules\\varint\\length.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\src\\generated-table.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Csrc%5Cgenerated-table.js
      return function (require, module, exports) {
// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */
'use strict'

/**
 * @type {__import__('./generated-types').NameCodeMap}
 */
const baseTable = Object.freeze({
  'identity': 0x00,
  'cidv1': 0x01,
  'cidv2': 0x02,
  'cidv3': 0x03,
  'ip4': 0x04,
  'tcp': 0x06,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'dccp': 0x21,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'ip6': 0x29,
  'ip6zone': 0x2a,
  'path': 0x2f,
  'multicodec': 0x30,
  'multihash': 0x31,
  'multiaddr': 0x32,
  'multibase': 0x33,
  'dns': 0x35,
  'dns4': 0x36,
  'dns6': 0x37,
  'dnsaddr': 0x38,
  'protobuf': 0x50,
  'cbor': 0x51,
  'raw': 0x55,
  'dbl-sha2-256': 0x56,
  'rlp': 0x60,
  'bencode': 0x63,
  'dag-pb': 0x70,
  'dag-cbor': 0x71,
  'libp2p-key': 0x72,
  'git-raw': 0x78,
  'torrent-info': 0x7b,
  'torrent-file': 0x7c,
  'leofcoin-block': 0x81,
  'leofcoin-tx': 0x82,
  'leofcoin-pr': 0x83,
  'sctp': 0x84,
  'dag-jose': 0x85,
  'dag-cose': 0x86,
  'eth-block': 0x90,
  'eth-block-list': 0x91,
  'eth-tx-trie': 0x92,
  'eth-tx': 0x93,
  'eth-tx-receipt-trie': 0x94,
  'eth-tx-receipt': 0x95,
  'eth-state-trie': 0x96,
  'eth-account-snapshot': 0x97,
  'eth-storage-trie': 0x98,
  'bitcoin-block': 0xb0,
  'bitcoin-tx': 0xb1,
  'bitcoin-witness-commitment': 0xb2,
  'zcash-block': 0xc0,
  'zcash-tx': 0xc1,
  'docid': 0xce,
  'stellar-block': 0xd0,
  'stellar-tx': 0xd1,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'decred-block': 0xe0,
  'decred-tx': 0xe1,
  'ipld-ns': 0xe2,
  'ipfs-ns': 0xe3,
  'swarm-ns': 0xe4,
  'ipns-ns': 0xe5,
  'zeronet': 0xe6,
  'secp256k1-pub': 0xe7,
  'bls12_381-g1-pub': 0xea,
  'bls12_381-g2-pub': 0xeb,
  'x25519-pub': 0xec,
  'ed25519-pub': 0xed,
  'bls12_381-g1g2-pub': 0xee,
  'dash-block': 0xf0,
  'dash-tx': 0xf1,
  'swarm-manifest': 0xfa,
  'swarm-feed': 0xfb,
  'udp': 0x0111,
  'p2p-webrtc-star': 0x0113,
  'p2p-webrtc-direct': 0x0114,
  'p2p-stardust': 0x0115,
  'p2p-circuit': 0x0122,
  'dag-json': 0x0129,
  'udt': 0x012d,
  'utp': 0x012e,
  'unix': 0x0190,
  'thread': 0x0196,
  'p2p': 0x01a5,
  'ipfs': 0x01a5,
  'https': 0x01bb,
  'onion': 0x01bc,
  'onion3': 0x01bd,
  'garlic64': 0x01be,
  'garlic32': 0x01bf,
  'tls': 0x01c0,
  'quic': 0x01cc,
  'ws': 0x01dd,
  'wss': 0x01de,
  'p2p-websocket-star': 0x01df,
  'http': 0x01e0,
  'json': 0x0200,
  'messagepack': 0x0201,
  'libp2p-peer-record': 0x0301,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'p256-pub': 0x1200,
  'p384-pub': 0x1201,
  'p521-pub': 0x1202,
  'ed448-pub': 0x1203,
  'x448-pub': 0x1204,
  'ed25519-priv': 0x1300,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402,
  'zeroxcert-imprint-256': 0xce11,
  'fil-commitment-unsealed': 0xf101,
  'fil-commitment-sealed': 0xf102,
  'holochain-adr-v0': 0x807124,
  'holochain-adr-v1': 0x817124,
  'holochain-key-v0': 0x947124,
  'holochain-key-v1': 0x957124,
  'holochain-sig-v0': 0xa27124,
  'holochain-sig-v1': 0xa37124,
  'skynet-ns': 0xb19910
})

module.exports = { baseTable }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec",file:"node_modules\\multicodec\\src\\generated-table.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\src\\index.js", {"./maps":"F:\\metamask-extension\\node_modules\\multicodec\\src\\maps.js","./util":"F:\\metamask-extension\\node_modules\\multicodec\\src\\util.js","uint8arrays/concat":"F:\\metamask-extension\\node_modules\\uint8arrays\\concat.js","varint":"F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecCode} CodecCode */

const varint = require('varint')
const uint8ArrayConcat = require('uint8arrays/concat')
const util = require('./util')
const { nameToVarint, constantToCode, nameToCode, codeToName } = require('./maps')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (nameToVarint[multicodecStrOrCode]) {
      prefix = nameToVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }

  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(/** @type {Buffer} */(data))
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec name of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getNameFromData (prefixedData) {
  const code = /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))
  const name = codeToName[code]
  if (name === undefined) {
    throw new Error(`Code "${code}" not found`)
  }
  return name
}

/**
 * Get the codec name from a code.
 *
 * @param {CodecCode} codec
 * @returns {CodecName}
 */
function getNameFromCode (codec) {
  return codeToName[codec]
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecCode}
 */
function getCodeFromName (name) {
  const code = nameToCode[name]
  if (code === undefined) {
    throw new Error(`Codec "${name}" not found`)
  }
  return code
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */
function getCodeFromData (prefixedData) {
  return /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} name
 * @returns {Uint8Array}
 */
function getVarintFromName (name) {
  const code = nameToVarint[name]
  if (code === undefined) {
    throw new Error(`Codec "${name}" not found`)
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecCode} code
 * @returns {Uint8Array}
 */
function getVarintFromCode (code) {
  return util.varintEncode(code)
}

/**
 * Get the codec name of the prefixed data.
 *
 * @deprecated use getNameFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  return getNameFromData(prefixedData)
}

/**
 * Get the codec name from a code.
 *
 * @deprecated use getNameFromCode instead.
 * @param {CodecCode} codec
 * @returns {CodecName}
 */
function getName (codec) {
  return getNameFromCode(codec)
}

/**
 * Get the code of the codec
 *
 * @deprecated use getCodeFromName instead.
 * @param {CodecName} name
 * @returns {CodecCode}
 */
function getNumber (name) {
  return getCodeFromName(name)
}

/**
 * Get the code of the prefixed data.
 *
 * @deprecated use getCodeFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */
function getCode (prefixedData) {
  return getCodeFromData(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @deprecated use getVarintFromName instead.
 * @param {CodecName} name
 * @returns {Uint8Array}
 */
function getCodeVarint (name) {
  return getVarintFromName(name)
}

/**
 * Get the varint of a code.
 *
 * @deprecated use getVarintFromCode instead.
 * @param {CodecCode} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return Array.from(getVarintFromCode(code))
}

module.exports = {
  addPrefix,
  rmPrefix,
  getNameFromData,
  getNameFromCode,
  getCodeFromName,
  getCodeFromData,
  getVarintFromName,
  getVarintFromCode,
  // Deprecated
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  // Make the constants top-level constants
  ...constantToCode,
  // Export the maps
  nameToVarint,
  nameToCode,
  codeToName
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec",file:"node_modules\\multicodec\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\src\\maps.js", {"./generated-table":"F:\\metamask-extension\\node_modules\\multicodec\\src\\generated-table.js","./util":"F:\\metamask-extension\\node_modules\\multicodec\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Csrc%5Cmaps.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').ConstantCodeMap} ConstantCodeMap */
/** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */
/** @typedef {__import__('./generated-types').CodeNameMap} CodeNameMap */
/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecConstant} CodecConstant */

const { baseTable } = require('./generated-table')
const varintEncode = require('./util').varintEncode

const nameToVarint = /** @type {NameUint8ArrayMap} */ ({})
const constantToCode = /** @type {ConstantCodeMap} */({})
const codeToName = /** @type {CodeNameMap} */({})

// eslint-disable-next-line guard-for-in
for (const name in baseTable) {
  const codecName = /** @type {CodecName} */(name)
  const code = baseTable[codecName]
  nameToVarint[codecName] = varintEncode(code)

  const constant = /** @type {CodecConstant} */(codecName.toUpperCase().replace(/-/g, '_'))
  constantToCode[constant] = code

  if (!codeToName[code]) {
    codeToName[code] = codecName
  }
}

Object.freeze(nameToVarint)
Object.freeze(constantToCode)
Object.freeze(codeToName)
const nameToCode = Object.freeze(baseTable)
module.exports = {
  nameToVarint,
  constantToCode,
  nameToCode,
  codeToName
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec",file:"node_modules\\multicodec\\src\\maps.js",}],
["F:\\metamask-extension\\node_modules\\multicodec\\src\\util.js", {"uint8arrays/from-string":"F:\\metamask-extension\\node_modules\\uint8arrays\\from-string.js","uint8arrays/to-string":"F:\\metamask-extension\\node_modules\\uint8arrays\\to-string.js","varint":"F:\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cmulticodec%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

/**
 * @param {Uint8Array} buf
 */
function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

/**
 * @param {number} num
 */
function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

/**
 * @param {Uint8Array} input
 */
function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

/**
 * @param {number} num
 */
function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>multicodec",file:"node_modules\\multicodec\\src\\util.js",}],
["F:\\metamask-extension\\node_modules\\nanoid\\index.browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cnanoid%5Cindex.browser.js
      return function (require, module, exports) {
// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

if ("development" !== 'production') {
  // All bundlers will remove this block in production bundle
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
      'If you don’t need unpredictable IDs, you can use `nanoid/non-secure`. ' +
      'For secure ID install `expo-random` locally and use `nanoid/async`.'
    )
  }
  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {
    throw new Error(
      'Your browser does not have secure random generator. ' +
      'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}

var crypto = self.crypto || self.msCrypto

// This alphabet uses a-z A-Z 0-9 _- symbols.
// Symbols are generated for smaller size.
// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA
var url = '-_'
// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).
var i = 36
while (i--) {
  // 36 is radix. Number.prototype.toString(36) returns number
  // in Base36 representation. Base36 is like hex, but it uses 0–9 and a-z.
  url += i.toString(36)
}
// Loop from 36 to 10 (from Z to A in Base36).
i = 36
while (i-- - 10) {
  url += i.toString(36).toUpperCase()
}

module.exports = function (size) {
  var id = ''
  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))
  i = size || 21

  // Compact alternative for `for (var i = 0; i < size; i++)`
  while (i--) {
    // We can’t use bytes bigger than the alphabet. 63 is 00111111 bitmask.
    // This mask reduces random byte 0-255 to 0-63 values.
    // There is no need in `|| ''` and `* 1.6` hacks in here,
    // because bitmask trim bytes exact to alphabet size.
    id += url[bytes[i] & 63]
  }
  return id
}

      };
    };
  }
  }
}, {package:"nanoid",file:"node_modules\\nanoid\\index.browser.js",}],
["F:\\metamask-extension\\node_modules\\node-fetch\\browser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cnode-fetch%5Cbrowser.js
      return function (require, module, exports) {
"use strict";

// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var globalObject = getGlobal();

module.exports = exports = globalObject.fetch;

// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
	exports.default = globalObject.fetch.bind(globalObject);
}

exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;

      };
    };
  }
  }
}, {package:"node-fetch",file:"node_modules\\node-fetch\\browser.js",}],
["F:\\metamask-extension\\node_modules\\nonce-tracker\\index.js", {"assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","await-semaphore":"F:\\metamask-extension\\node_modules\\await-semaphore\\index.js","ethjs-query":"F:\\metamask-extension\\node_modules\\ethjs-query\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cnonce-tracker%5Cindex.js
      return function (require, module, exports) {
const EthQuery = require('ethjs-query')
const assert = require('assert')
const Mutex = require('await-semaphore').Mutex
/**
  @param opts {Object}
    @param {Object} opts.provider a ethereum provider
    @param {Function} opts.getPendingTransactions a function that returns an array of txMeta
    whosee status is `submitted`
    @param {Function} opts.getConfirmedTransactions a function that returns an array of txMeta
    whose status is `confirmed`
  @class
*/
class NonceTracker {

  constructor ({ provider, blockTracker, getPendingTransactions, getConfirmedTransactions }) {
    this.provider = provider
    this.blockTracker = blockTracker
    this.ethQuery = new EthQuery(provider)
    this.getPendingTransactions = getPendingTransactions
    this.getConfirmedTransactions = getConfirmedTransactions
    this.lockMap = {}
  }

  /**
    @returns {Promise<Object>} with the key releaseLock (the gloabl mutex)
  */
  async getGlobalLock () {
    const globalMutex = this._lookupMutex('global')
    // await global mutex free
    const releaseLock = await globalMutex.acquire()
    return { releaseLock }
  }

  /**
   * @typedef NonceDetails
   * @property {number} highestLocallyConfirmed - A hex string of the highest nonce on a confirmed transaction.
   * @property {number} nextNetworkNonce - The next nonce suggested by the eth_getTransactionCount method.
   * @property {number} highestSuggested - The maximum between the other two, the number returned.
   */

  /**
  this will return an object with the `nextNonce` `nonceDetails`, and the releaseLock
  Note: releaseLock must be called after adding a signed tx to pending transactions (or discarding).

  @param address {string} the hex string for the address whose nonce we are calculating
  @returns {Promise<NonceDetails>}
  */
  async getNonceLock (address) {
    // await global mutex free
    await this._globalMutexFree()
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address)
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {}
      const networkNonceResult = await this._getNetworkNextNonce(address)
      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address)
      const nextNetworkNonce = networkNonceResult.nonce
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed)

      const pendingTxs = this.getPendingTransactions(address)
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested) || 0

      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce,
      }
      nonceDetails.local = localNonceResult
      nonceDetails.network = networkNonceResult

      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce)
      assert(Number.isInteger(nextNonce), `nonce-tracker - nextNonce is not an integer - got: (${typeof nextNonce}) "${nextNonce}"`)

      // return nonce and release cb
      return { nextNonce, nonceDetails, releaseLock }
    } catch (err) {
      // release lock if we encounter an error
      releaseLock()
      throw err
    }
  }

  async _globalMutexFree () {
    const globalMutex = this._lookupMutex('global')
    const releaseLock = await globalMutex.acquire()
    releaseLock()
  }

  async _takeMutex (lockId) {
    const mutex = this._lookupMutex(lockId)
    const releaseLock = await mutex.acquire()
    return releaseLock
  }

  _lookupMutex (lockId) {
    let mutex = this.lockMap[lockId]
    if (!mutex) {
      mutex = new Mutex()
      this.lockMap[lockId] = mutex
    }
    return mutex
  }

  async _getNetworkNextNonce (address) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const blockNumber = await this.blockTracker.getLatestBlock()
    const baseCountBN = await this.ethQuery.getTransactionCount(address, blockNumber)
    const baseCount = baseCountBN.toNumber()
    assert(Number.isInteger(baseCount), `nonce-tracker - baseCount is not an integer - got: (${typeof baseCount}) "${baseCount}"`)
    const nonceDetails = { blockNumber, baseCount }
    return { name: 'network', nonce: baseCount, details: nonceDetails }
  }

  _getHighestLocallyConfirmed (address) {
    const confirmedTransactions = this.getConfirmedTransactions(address)
    const highest = this._getHighestNonce(confirmedTransactions)
    return Number.isInteger(highest) ? highest + 1 : 0
  }

  _getHighestNonce (txList) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })
    const highestNonce = Math.max.apply(null, nonces)
    return highestNonce
  }

  /**
    @typedef {object} highestContinuousFrom
    @property {string} - name the name for how the nonce was calculated based on the data used
    @property {number} - nonce the next suggested nonce
    @property {object} - details the provided starting nonce that was used (for debugging)
  */
  /**
    @param txList {array} - list of txMeta's
    @param startPoint {number} - the highest known locally confirmed nonce
    @returns {highestContinuousFrom}
  */
  _getHighestContinuousFrom (txList, startPoint) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })

    let highest = startPoint
    while (nonces.includes(highest)) {
      highest++
    }

    return { name: 'local', nonce: highest, details: { startPoint, highest } }
  }

}

module.exports = NonceTracker

      };
    };
  }
  }
}, {package:"nonce-tracker",file:"node_modules\\nonce-tracker\\index.js",}],
["F:\\metamask-extension\\node_modules\\obs-store\\index.js", {"safe-event-emitter":"F:\\metamask-extension\\node_modules\\safe-event-emitter\\index.js","xtend":"F:\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cobs-store%5Cindex.js
      return function (require, module, exports) {
'use strict'

const extend = require('xtend')
const SafeEventEmitter = require('safe-event-emitter')

class ObservableStore extends SafeEventEmitter {

  constructor (initState = {}) {
    super()
    // set init state
    this._state = initState
  }

  // wrapper around internal getState
  getState () {
    return this._getState()
  }
  
  // wrapper around internal putState
  putState (newState) {
    this._putState(newState)
    this.emit('update', newState)
  }

  updateState (partialState) {
    // if non-null object, merge
    if (partialState && typeof partialState === 'object') {
      const state = this.getState()
      const newState = Object.assign({}, state, partialState)
      this.putState(newState)
    // if not object, use new value
    } else {
      this.putState(partialState)
    }
  }

  // subscribe to changes
  subscribe (handler) {
    this.on('update', handler)
  }

  // unsubscribe to changes
  unsubscribe (handler) {
    this.removeListener('update', handler)
  }

  //
  // private
  //

  // read from persistence
  _getState () {
    return this._state
  }

  // write to persistence
  _putState (newState) {
    this._state = newState
  }

}

module.exports = ObservableStore

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>obs-store",file:"node_modules\\obs-store\\index.js",}],
["F:\\metamask-extension\\node_modules\\parse-uri\\src\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cparse-uri%5Csrc%5Cindex.js
      return function (require, module, exports) {
'use strict'

module.exports = (str, opts = {}) => {
  if (!str) return undefined

  const o = {
    key: [
      'source',
      'protocol',
      'authority',
      'userInfo',
      'user',
      'password',
      'host',
      'port',
      'relative',
      'path',
      'directory',
      'file',
      'query',
      'anchor'
    ],
    q: {
      name: 'queryKey',
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }

  const m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)
  const uri = {}
  let i = 14

  while (i--) uri[o.key[i]] = m[i] || ''

  uri[o.q.name] = {}
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) uri[o.q.name][$1] = $2
  })

  return uri
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>parse-uri",file:"node_modules\\parse-uri\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\light.js", {"./src/index-light":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\index-light.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Clight.js
      return function (require, module, exports) {
// light library entry point.

"use strict";
module.exports = require("./src/index-light");
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\light.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\converter.js", {"./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cconverter.js
      return function (require, module, exports) {
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require("./enum"),
    util = require("./util");

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\converter.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\decoder.js", {"./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./types":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\types.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cdecoder.js
      return function (require, module, exports) {
"use strict";
module.exports = decoder;

var Enum    = require("./enum"),
    types   = require("./types"),
    util    = require("./util");

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\decoder.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\encoder.js", {"./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./types":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\types.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cencoder.js
      return function (require, module, exports) {
"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\encoder.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js", {"./namespace":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\namespace.js","./object":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\object.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cenum.js
      return function (require, module, exports) {
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require("./namespace"),
    util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\enum.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\field.js", {"./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./object":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\object.js","./types":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\types.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cfield.js
      return function (require, module, exports) {
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    if (rule === "proto3_optional") {
        rule = "optional";
    }
    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\field.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\index-light.js", {"./converter":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\converter.js","./decoder":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\decoder.js","./encoder":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\encoder.js","./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./field":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\field.js","./index-minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\index-minimal.js","./mapfield":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\mapfield.js","./message":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\message.js","./method":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\method.js","./namespace":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\namespace.js","./object":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\object.js","./oneof":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\oneof.js","./root":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\root.js","./service":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\service.js","./type":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\type.js","./types":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\types.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js","./verifier":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\verifier.js","./wrappers":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\wrappers.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cindex-light.js
      return function (require, module, exports) {
"use strict";
var protobuf = module.exports = require("./index-minimal");

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require("./encoder");
protobuf.decoder          = require("./decoder");
protobuf.verifier         = require("./verifier");
protobuf.converter        = require("./converter");

// Reflection
protobuf.ReflectionObject = require("./object");
protobuf.Namespace        = require("./namespace");
protobuf.Root             = require("./root");
protobuf.Enum             = require("./enum");
protobuf.Type             = require("./type");
protobuf.Field            = require("./field");
protobuf.OneOf            = require("./oneof");
protobuf.MapField         = require("./mapfield");
protobuf.Service          = require("./service");
protobuf.Method           = require("./method");

// Runtime
protobuf.Message          = require("./message");
protobuf.wrappers         = require("./wrappers");

// Utility
protobuf.types            = require("./types");
protobuf.util             = require("./util");

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\index-light.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\index-minimal.js", {"./reader":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\reader.js","./reader_buffer":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\reader_buffer.js","./roots":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\roots.js","./rpc":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\rpc.js","./util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js","./writer":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\writer.js","./writer_buffer":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\writer_buffer.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cindex-minimal.js
      return function (require, module, exports) {
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\index-minimal.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\mapfield.js", {"./field":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\field.js","./types":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\types.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cmapfield.js
      return function (require, module, exports) {
"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\mapfield.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\message.js", {"./util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cmessage.js
      return function (require, module, exports) {
"use strict";
module.exports = Message;

var util = require("./util/minimal");

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\message.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\method.js", {"./object":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\object.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cmethod.js
      return function (require, module, exports) {
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require("./util");

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Options properly parsed into an object
     */
    this.parsedOptions = parsedOptions;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 * @property {string} comment Method comments
 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined,
        "parsedOptions"  , this.parsedOptions,
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\method.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\namespace.js", {"./field":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\field.js","./object":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\object.js","./oneof":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\oneof.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cnamespace.js
      return function (require, module, exports) {
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require("./field"),
    OneOf    = require("./oneof"),
    util     = require("./util");

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\namespace.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\object.js", {"./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cobject.js
      return function (require, module, exports) {
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\object.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\oneof.js", {"./field":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\field.js","./object":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\object.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Coneof.js
      return function (require, module, exports) {
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require("./object");
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require("./field"),
    util  = require("./util");

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\oneof.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\reader.js", {"./util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Creader.js
      return function (require, module, exports) {
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\reader.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\reader_buffer.js", {"./reader":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\reader.js","./util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Creader_buffer.js
      return function (require, module, exports) {
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\reader_buffer.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\root.js", {"./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./field":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\field.js","./namespace":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\namespace.js","./oneof":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\oneof.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Croot.js
      return function (require, module, exports) {
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\root.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\roots.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Croots.js
      return function (require, module, exports) {
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\roots.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\rpc.js", {"./rpc/service":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\rpc\\service.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Crpc.js
      return function (require, module, exports) {
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\rpc.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\rpc\\service.js", {"../util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Crpc%5Cservice.js
      return function (require, module, exports) {
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\rpc\\service.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\service.js", {"./method":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\method.js","./namespace":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\namespace.js","./rpc":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\rpc.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cservice.js
      return function (require, module, exports) {
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require("./namespace");
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require("./method"),
    util   = require("./util"),
    rpc    = require("./rpc");

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\service.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\type.js", {"./converter":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\converter.js","./decoder":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\decoder.js","./encoder":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\encoder.js","./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./field":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\field.js","./mapfield":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\mapfield.js","./message":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\message.js","./namespace":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\namespace.js","./oneof":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\oneof.js","./reader":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\reader.js","./service":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\service.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js","./verifier":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\verifier.js","./wrappers":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\wrappers.js","./writer":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\writer.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Ctype.js
      return function (require, module, exports) {
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\type.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\types.js", {"./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Ctypes.js
      return function (require, module, exports) {
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require("./util");

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\types.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js", {"./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./root":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\root.js","./roots":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\roots.js","./type":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\type.js","./util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js","@protobufjs/codegen":"F:\\metamask-extension\\node_modules\\@protobufjs\\codegen\\index.js","@protobufjs/fetch":"F:\\metamask-extension\\node_modules\\@protobufjs\\fetch\\index.js","@protobufjs/path":"F:\\metamask-extension\\node_modules\\@protobufjs\\path\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cutil.js
      return function (require, module, exports) {
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (part === "__proto__") {
          return dst;
        }
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    }
});

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\util.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\longbits.js", {"../util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cutil%5Clongbits.js
      return function (require, module, exports) {
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\util\\longbits.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZXRoZXJldW0uanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZnVuY3Rpb25zL2FkZEt2UmVjb3Jkcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9mdW5jdGlvbnMvY29ubmVjdC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9mdW5jdGlvbnMvZmV0Y2hBY3RpdmVXYWxsZXQuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZnVuY3Rpb25zL2ZldGNoRW5jRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9mdW5jdGlvbnMvZ2V0QWRkcmVzc2VzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2Z1bmN0aW9ucy9nZXRLdlJlY29yZHMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZnVuY3Rpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2Z1bmN0aW9ucy9wYWlyLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2Z1bmN0aW9ucy9yZW1vdmVLdlJlY29yZHMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZnVuY3Rpb25zL3NpZ24uanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZ2VuZXJpY1NpZ25pbmcuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvcHJvdG9jb2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvcHJvdG9jb2wvbGF0dGljZUNvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9wcm90b2NvbC9zZWN1cmVNZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9zaGFyZWQvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L3NoYXJlZC9mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3Qvc2hhcmVkL3ByZWRpY2F0ZXMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3Qvc2hhcmVkL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9zaGFyZWQvdmFsaWRhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlL2xpYi9naW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWUvbGliL2hhc2guanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlL2xpYi9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlL2xpYi9wYWNrZWROb2RlLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlL2xpYi9wcm9vZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZS9saWIvcHJvb2YvbXVsdGkuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWUvbGliL3Byb29mL3NpbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZS9saWIvcHJvb2YvdHJlZU9mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZS9saWIvcHJvb2YvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZS9saWIvc3VidHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZS9saWIvdHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZS9saWIvemVyb05vZGUuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvYnJhbmNoTm9kZVN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi90eXBlL2Fic3RyYWN0LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3R5cGUvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS9hcnJheUJhc2ljLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3R5cGUvYXJyYXlDb21wb3NpdGUuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS9iYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi90eXBlL2JpdEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3R5cGUvYml0TGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi90eXBlL2JpdFZlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi90eXBlL2Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS9ieXRlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS9ieXRlTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi90eXBlL2J5dGVWZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS9jb21wb3NpdGUuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS9jb250YWluZXIuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS9jb250YWluZXJOb2RlU3RydWN0LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3R5cGUvbGlzdEJhc2ljLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3R5cGUvbGlzdENvbXBvc2l0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi90eXBlL25vbmUuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS91aW50LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3R5cGUvdW5pb24uanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdHlwZS92ZWN0b3JCYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi90eXBlL3ZlY3RvckNvbXBvc2l0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi91dGlsL2J5dGVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi91dGlsL21lcmtsZWl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi91dGlsL25hbWVkLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3V0aWwvcHJvb2YvdHJlZVBvc3RQcm9jZXNzRnJvbVByb29mTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi91dGlsL3plcm9zLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3ZhbHVlL2JpdEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3ZpZXdEVS9hYnN0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi92aWV3RFUvYXJyYXlCYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi92aWV3RFUvYXJyYXlDb21wb3NpdGUuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdmlld0RVL2JpdEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3ZpZXdEVS9jb250YWluZXIuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdmlld0RVL2NvbnRhaW5lck5vZGVTdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdmlld0RVL2xpc3RCYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi92aWV3RFUvbGlzdENvbXBvc2l0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi92aWV3L2Fic3RyYWN0LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3ZpZXcvYXJyYXlCYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BjaGFpbnNhZmUvc3N6L2xpYi92aWV3L2FycmF5Q29tcG9zaXRlLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3ZpZXcvYml0QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdmlldy9jb250YWluZXIuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AY2hhaW5zYWZlL3Nzei9saWIvdmlldy9jb250YWluZXJOb2RlU3RydWN0LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3ZpZXcvbGlzdEJhc2ljLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGNoYWluc2FmZS9zc3ovbGliL3ZpZXcvbGlzdENvbXBvc2l0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2NoYWlucy9nb2VybGkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2NoYWlucy9tYWlubmV0Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9jaGFpbnMvcmlua2VieS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvY2hhaW5zL3JvcHN0ZW4uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2NoYWlucy9zZXBvbGlhLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzExNTMuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvMTU1OS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy8yMzE1Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzI1MzcuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvMjU2NS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy8yNzE4Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzI5MjkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvMjkzMC5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy8zMDc0Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzMxOTguanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvMzUyOS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy8zNTQwLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM1NDEuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvMzU1NC5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy8zNjA3Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM2NTEuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvMzY3MC5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy8zNjc1Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM4NTUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvMzg2MC5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy80MzQ1Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzQzOTkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvNDg0NC5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvZWlwcy80ODk1Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzUxMzMuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VpcHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9lbnVtcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9hcnJvd0dsYWNpZXIuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9iZXJsaW4uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9ieXphbnRpdW0uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9jaGFpbnN0YXJ0Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3MvY29uc3RhbnRpbm9wbGUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9kYW8uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9ncmF5R2xhY2llci5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2hvbWVzdGVhZC5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2lzdGFuYnVsLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3MvbG9uZG9uLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3MvbWVyZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9tZXJnZUZvcmtJZFRyYW5zaXRpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9tdWlyR2xhY2llci5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL3BldGVyc2J1cmcuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9zaGFuZ2hhaS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL3NoYXJkaW5nLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3Mvc3B1cmlvdXNEcmFnb24uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy90YW5nZXJpbmVXaGlzdGxlLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9kaXN0L2Jhc2VUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L2Rpc3QvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvZGlzdC9laXAxNTU5VHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9kaXN0L2VpcDI5MzBUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L2Rpc3QvZWlwNDg0NFRyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvZGlzdC9mcm9tUnBjLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L2Rpc3Qva3pnL2t6Zy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L2Rpc3QvbGVnYWN5VHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9kaXN0L3RyYW5zYWN0aW9uRmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L2Rpc3QvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9kaXN0L3V0aWwuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9kaXN0L3V0aWxzL2Jsb2JIZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2NoYWlucy9nb2VybGkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9jaGFpbnMvbWFpbm5ldC5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2NoYWlucy9yaW5rZWJ5Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvY2hhaW5zL3JvcHN0ZW4uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9jaGFpbnMvc2Vwb2xpYS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzExNTMuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzE1NTkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzIzMTUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzI1MzcuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzI1NjUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzI3MTguanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzI5MjkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzI5MzAuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzMwNzQuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzMxOTguanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM1MjkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM1NDAuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM1NDEuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM1NTQuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM2MDcuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM2NTEuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM2NzAuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM2NzUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM4NTUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzM4NjAuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzQzNDUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzQzOTkuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzQ4NDQuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzQ4OTUuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzLzUxMzMuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9laXBzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2VudW1zLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9hcnJvd0dsYWNpZXIuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3MvYmVybGluLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2J5emFudGl1bS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9jaGFpbnN0YXJ0Lmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2NvbnN0YW50aW5vcGxlLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2Rhby5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9ncmF5R2xhY2llci5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9ob21lc3RlYWQuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2lzdGFuYnVsLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaGFyZGZvcmtzL2xvbmRvbi5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9tZXJnZS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9tZXJnZUZvcmtJZFRyYW5zaXRpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3MvbXVpckdsYWNpZXIuanNvbiIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC9oYXJkZm9ya3MvcGV0ZXJzYnVyZy5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9zaGFuZ2hhaS5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9zaGFyZGluZy5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy9zcHVyaW91c0RyYWdvbi5qc29uIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL2NvbW1vbi9kaXN0L2hhcmRmb3Jrcy90YW5nZXJpbmVXaGlzdGxlLmpzb24iLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvY29tbW9uL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9iZWNoMzIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ccm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NoYTI1Ni5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL2pzLXNoYTMvc3JjL3NoYTMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9ybHAvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvZWxsaXB0aWMuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L21kNS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L25hdGl2ZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L25pbC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9yZWdleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9ybmctYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy91dWlkL2Rpc3Qvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YxLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzNS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2ludDY0LWJ1ZmZlci9pbnQ2NC1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvaXMtcmV0cnktYWxsb3dlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc28tdXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3JlbGF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3VybC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtZmV0Y2gvZmV0Y2gtbnBtLWJyb3dzZXJpZnkuanMiLCJub2RlX21vZHVsZXMvam9pbi1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbS9kaXN0L2NyZWF0ZUVuZ2luZVN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbS9kaXN0L2NyZWF0ZVN0cmVhbU1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvYXR0cmlidXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzb25zY2hlbWEvbGliL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvdmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluUmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3RyaW1tZWRFbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW5SYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNJbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzIiwibm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvcmZjNDY0OC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2dlbmVyYXRlZC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9tYXBzLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LmJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL25vbmNlLXRyYWNrZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JzLXN0b3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXVyaS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9saWdodC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9jb252ZXJ0ZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9lbmNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VudW0uanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZmllbGQuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbGlnaHQuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tYXBmaWVsZC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tZXNzYWdlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9uYW1lc3BhY2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3NlcnZpY2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNqOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNwNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzNVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDL1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNwNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5MkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDaHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdDBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDclVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzN5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJiYWNrZ3JvdW5kLTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBVQkxJQyA9IGV4cG9ydHMuRVRIX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQID0gZXhwb3J0cy5NQVhfQ0hBSU5fSURfQllURVMgPSBleHBvcnRzLkhBTkRMRV9MQVJHRVJfQ0hBSU5fSUQgPSBleHBvcnRzLkhBUkRFTkVEX09GRlNFVCA9IGV4cG9ydHMuVkVSU0lPTl9CWVRFID0gZXhwb3J0cy5SRVFVRVNUX1RZUEVfQllURSA9IGV4cG9ydHMuc2lnbmluZ1NjaGVtYSA9IGV4cG9ydHMuZXRoTXNnUHJvdG9jb2wgPSBleHBvcnRzLmFkZHJlc3NTaXplcyA9IGV4cG9ydHMuRVhURVJOQUxfTkVUV09SS1NfQllfQ0hBSU5fSURfVVJMID0gZXhwb3J0cy5ORVRXT1JLU19CWV9DSEFJTl9JRCA9IGV4cG9ydHMuTUFYX0FERFIgPSBleHBvcnRzLkNVUlJFTkNJRVMgPSBleHBvcnRzLkJBU0VfVVJMID0gZXhwb3J0cy5CSVBfQ09OU1RBTlRTID0gZXhwb3J0cy5nZXRGd1ZlcnNpb25Db25zdCA9IGV4cG9ydHMuQVNDSUlfUkVHRVggPSBleHBvcnRzLkxFREdFUl9MRUdBQ1lfREVSSVZBVElPTiA9IGV4cG9ydHMuTEVER0VSX0xJVkVfREVSSVZBVElPTiA9IGV4cG9ydHMuU09MQU5BX0RFUklWQVRJT04gPSBleHBvcnRzLkJUQ19XUkFQUEVEX1NFR1dJVF9ERVJJVkFUSU9OID0gZXhwb3J0cy5CVENfU0VHV0lUX0RFUklWQVRJT04gPSBleHBvcnRzLkJUQ19MRUdBQ1lfREVSSVZBVElPTiA9IGV4cG9ydHMuREVGQVVMVF9FVEhfREVSSVZBVElPTiA9IGV4cG9ydHMuREVGQVVMVF9BQ1RJVkVfV0FMTEVUUyA9IGV4cG9ydHMuRU1QVFlfV0FMTEVUX1VJRCA9IGV4cG9ydHMuRVhURVJOQUwgPSB2b2lkIDA7XG52YXIgbGF0dGljZUNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vcHJvdG9jb2wvbGF0dGljZUNvbnN0YW50c1wiKTtcbi8qKlxuICogRXh0ZXJuYWxseSBleHBvcnRlZCBjb25zdGFudHMgdXNlZCBmb3IgYnVpbGRpbmcgcmVxdWVzdHNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5FWFRFUk5BTCA9IHtcbiAgICAvLyBPcHRpb25hbCBmbGFncyBmb3IgYGdldEFkZHJlc3Nlc2BcbiAgICBHRVRfQUREUl9GTEFHUzoge1xuICAgICAgICBTRUNQMjU2SzFfUFVCOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuc2VjcDI1NmsxUHVia2V5LFxuICAgICAgICBFRDI1NTE5X1BVQjogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLmVkMjU1MTlQdWJrZXksXG4gICAgICAgIEJMUzEyXzM4MV9HMV9QVUI6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlR2V0QWRkcmVzc2VzRmxhZy5ibHMxMl8zODFQdWJrZXksXG4gICAgfSxcbiAgICAvLyBPcHRpb25zIGZvciBidWlsZGluZyBnZW5lcmFsIHNpZ25pbmcgcmVxdWVzdHNcbiAgICBTSUdOSU5HOiB7XG4gICAgICAgIEhBU0hFUzoge1xuICAgICAgICAgICAgTk9ORTogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTaWduSGFzaC5ub25lLFxuICAgICAgICAgICAgS0VDQ0FLMjU2OiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25IYXNoLmtlY2NhazI1NixcbiAgICAgICAgICAgIFNIQTI1NjogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTaWduSGFzaC5zaGEyNTYsXG4gICAgICAgIH0sXG4gICAgICAgIENVUlZFUzoge1xuICAgICAgICAgICAgU0VDUDI1NksxOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25DdXJ2ZS5zZWNwMjU2azEsXG4gICAgICAgICAgICBFRDI1NTE5OiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25DdXJ2ZS5lZDI1NTE5LFxuICAgICAgICAgICAgQkxTMTJfMzgxX0cyOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25DdXJ2ZS5ibHMxMl8zODEsXG4gICAgICAgIH0sXG4gICAgICAgIEVOQ09ESU5HUzoge1xuICAgICAgICAgICAgTk9ORTogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTaWduRW5jb2Rpbmcubm9uZSxcbiAgICAgICAgICAgIFNPTEFOQTogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTaWduRW5jb2Rpbmcuc29sYW5hLFxuICAgICAgICAgICAgRVZNOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25FbmNvZGluZy5ldm0sXG4gICAgICAgICAgICBFVEhfREVQT1NJVDogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTaWduRW5jb2RpbmcuZXRoX2RlcG9zaXQsXG4gICAgICAgIH0sXG4gICAgICAgIEJMU19EU1Q6IHtcbiAgICAgICAgICAgIEJMU19EU1RfTlVMOiBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNpZ25CbHNEc3QuTlVMLFxuICAgICAgICAgICAgQkxTX0RTVF9QT1A6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2lnbkJsc0RzdC5QT1AsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBPcHRpb25zIGZvciBleHBvcnRpbmcgZW5jcnlwdGVkIGRhdGFcbiAgICBFTkNfREFUQToge1xuICAgICAgICBTQ0hFTUFTOiB7XG4gICAgICAgICAgICBCTFNfS0VZU1RPUkVfRUlQMjMzNV9QQktERl9WNDogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VFbmNEYXRhU2NoZW1hLmVpcDIzMzUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBFVEhfQ09OU0VOU1VTX1NQRUM6IHtcbiAgICAgICAgTkVUV09SS1M6IHtcbiAgICAgICAgICAgIE1BSU5ORVRfR0VORVNJUzoge1xuICAgICAgICAgICAgICAgIG5ldHdvcmtOYW1lOiAnbWFpbm5ldCcsXG4gICAgICAgICAgICAgICAgZm9ya1ZlcnNpb246IEJ1ZmZlci5hbGxvYyg0KSxcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSByb290IGJlY2F1c2UgdGhlcmUgd2VyZSBubyB2YWxpZGF0b3JzIGF0IGdlbmVzaXNcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzUm9vdDogQnVmZmVyLmFsbG9jKDMyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIERPTUFJTlM6IHtcbiAgICAgICAgICAgIERFUE9TSVQ6IEJ1ZmZlci5mcm9tKCcwMzAwMDAwMCcsICdoZXgnKSxcbiAgICAgICAgICAgIFZPTFVOVEFSWV9FWElUOiBCdWZmZXIuZnJvbSgnMDQwMDAwMDAnLCAnaGV4JyksXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5leHBvcnRzLlBVQkxJQyA9IGV4cG9ydHMuRVhURVJOQUw7XG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIElOVEVSTkFMIENPTlNUQU5UU1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKiogQGludGVybmFsICovXG52YXIgYWRkcmVzc1NpemVzID0ge1xuICAgIEJUQzogMjAsXG4gICAgRVRIOiAyMCwgLy8gMjAgYnl0ZSBhZGRyZXNzIG5vdCBpbmNsdWRpbmcgMHggcHJlZml4XG59O1xuZXhwb3J0cy5hZGRyZXNzU2l6ZXMgPSBhZGRyZXNzU2l6ZXM7XG4vKiogQGludGVybmFsICovXG52YXIgQ1VSUkVOQ0lFUyA9IHtcbiAgICBFVEg6ICdFVEgnLFxuICAgIEJUQzogJ0JUQycsXG4gICAgRVRIX01TRzogJ0VUSF9NU0cnLFxufTtcbmV4cG9ydHMuQ1VSUkVOQ0lFUyA9IENVUlJFTkNJRVM7XG4vKiogQGludGVybmFsICovXG4vLyBUSElTIE5FRURTIFRPIEJFIEEgUFJPVE9DT0wgQ09OU1RBTlQgVE9PXG52YXIgc2lnbmluZ1NjaGVtYSA9IHtcbiAgICBCVENfVFJBTlNGRVI6IDAsXG4gICAgRVRIX1RSQU5TRkVSOiAxLFxuICAgIEVSQzIwX1RSQU5TRkVSOiAyLFxuICAgIEVUSF9NU0c6IDMsXG4gICAgRVhUUkFfREFUQTogNCxcbiAgICBHRU5FUkFMX1NJR05JTkc6IDUsXG59O1xuZXhwb3J0cy5zaWduaW5nU2NoZW1hID0gc2lnbmluZ1NjaGVtYTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwOyAvLyBIYXJkZW5lZCBvZmZzZXRcbmV4cG9ydHMuSEFSREVORURfT0ZGU0VUID0gSEFSREVORURfT0ZGU0VUO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEJJUF9DT05TVEFOVFMgPSB7XG4gICAgUFVSUE9TRVM6IHtcbiAgICAgICAgRVRIOiBIQVJERU5FRF9PRkZTRVQgKyA0NCxcbiAgICAgICAgQlRDX0xFR0FDWTogSEFSREVORURfT0ZGU0VUICsgNDQsXG4gICAgICAgIEJUQ19XUkFQUEVEX1NFR1dJVDogSEFSREVORURfT0ZGU0VUICsgNDksXG4gICAgICAgIEJUQ19TRUdXSVQ6IEhBUkRFTkVEX09GRlNFVCArIDg0LFxuICAgIH0sXG4gICAgQ09JTlM6IHtcbiAgICAgICAgRVRIOiBIQVJERU5FRF9PRkZTRVQgKyA2MCxcbiAgICAgICAgQlRDOiBIQVJERU5FRF9PRkZTRVQsXG4gICAgICAgIEJUQ19URVNUTkVUOiBIQVJERU5FRF9PRkZTRVQgKyAxLFxuICAgIH0sXG59O1xuZXhwb3J0cy5CSVBfQ09OU1RBTlRTID0gQklQX0NPTlNUQU5UUztcbi8qKiBAaW50ZXJuYWwgRm9yIGFsbCBIU00tYm91bmQgcmVxdWVzdHMgKi9cbnZhciBSRVFVRVNUX1RZUEVfQllURSA9IDB4MDI7XG5leHBvcnRzLlJFUVVFU1RfVFlQRV9CWVRFID0gUkVRVUVTVF9UWVBFX0JZVEU7XG4vKiogQGludGVybmFsICovXG52YXIgVkVSU0lPTl9CWVRFID0gMTtcbmV4cG9ydHMuVkVSU0lPTl9CWVRFID0gVkVSU0lPTl9CWVRFO1xuLyoqIEBpbnRlcm5hbCBDaGFpbklkIHZhbHVlIHRvIHNpZ25pZnkgbGFyZ2VyIGNoYWluSUQgaXMgaW4gZGF0YSBidWZmZXIgKi9cbnZhciBIQU5ETEVfTEFSR0VSX0NIQUlOX0lEID0gMjU1O1xuZXhwb3J0cy5IQU5ETEVfTEFSR0VSX0NIQUlOX0lEID0gSEFORExFX0xBUkdFUl9DSEFJTl9JRDtcbi8qKiBAaW50ZXJuYWwgTWF4IG51bWJlciBvZiBieXRlcyB0byBjb250YWluIGxhcmdlciBjaGFpbklEIGluIGRhdGEgYnVmZmVyICovXG52YXIgTUFYX0NIQUlOX0lEX0JZVEVTID0gODtcbmV4cG9ydHMuTUFYX0NIQUlOX0lEX0JZVEVTID0gTUFYX0NIQUlOX0lEX0JZVEVTO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEJBU0VfVVJMID0gJ2h0dHBzOi8vc2lnbmluZy5ncmlkcGwudXMnO1xuZXhwb3J0cy5CQVNFX1VSTCA9IEJBU0VfVVJMO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEVJUDcxMl9BQklfTEFUVElDRV9GV19UWVBFX01BUCA9IHtcbiAgICBhZGRyZXNzOiAxLFxuICAgIGJvb2w6IDIsXG4gICAgdWludDg6IDMsXG4gICAgdWludDE2OiA0LFxuICAgIHVpbnQyNDogNSxcbiAgICB1aW50MzI6IDYsXG4gICAgdWludDQwOiA3LFxuICAgIHVpbnQ0ODogOCxcbiAgICB1aW50NTY6IDksXG4gICAgdWludDY0OiAxMCxcbiAgICB1aW50NzI6IDExLFxuICAgIHVpbnQ4MDogMTIsXG4gICAgdWludDg4OiAxMyxcbiAgICB1aW50OTY6IDE0LFxuICAgIHVpbnQxMDQ6IDE1LFxuICAgIHVpbnQxMTI6IDE2LFxuICAgIHVpbnQxMjA6IDE3LFxuICAgIHVpbnQxMjg6IDE4LFxuICAgIHVpbnQxMzY6IDE5LFxuICAgIHVpbnQxNDQ6IDIwLFxuICAgIHVpbnQxNTI6IDIxLFxuICAgIHVpbnQxNjA6IDIyLFxuICAgIHVpbnQxNjg6IDIzLFxuICAgIHVpbnQxNzY6IDI0LFxuICAgIHVpbnQxODQ6IDI1LFxuICAgIHVpbnQxOTI6IDI2LFxuICAgIHVpbnQyMDA6IDI3LFxuICAgIHVpbnQyMDg6IDI4LFxuICAgIHVpbnQyMTY6IDI5LFxuICAgIHVpbnQyMjQ6IDMwLFxuICAgIHVpbnQyMzI6IDMxLFxuICAgIHVpbnQyNDA6IDMyLFxuICAgIHVpbnQyNDg6IDMzLFxuICAgIHVpbnQyNTY6IDM0LFxuICAgIGludDg6IDM1LFxuICAgIGludDE2OiAzNixcbiAgICBpbnQyNDogMzcsXG4gICAgaW50MzI6IDM4LFxuICAgIGludDQwOiAzOSxcbiAgICBpbnQ0ODogNDAsXG4gICAgaW50NTY6IDQxLFxuICAgIGludDY0OiA0MixcbiAgICBpbnQ3MjogNDMsXG4gICAgaW50ODA6IDQ0LFxuICAgIGludDg4OiA0NSxcbiAgICBpbnQ5NjogNDYsXG4gICAgaW50MTA0OiA0NyxcbiAgICBpbnQxMTI6IDQ4LFxuICAgIGludDEyMDogNDksXG4gICAgaW50MTI4OiA1MCxcbiAgICBpbnQxMzY6IDUxLFxuICAgIGludDE0NDogNTIsXG4gICAgaW50MTUyOiA1MyxcbiAgICBpbnQxNjA6IDU0LFxuICAgIGludDE2ODogNTUsXG4gICAgaW50MTc2OiA1NixcbiAgICBpbnQxODQ6IDU3LFxuICAgIGludDE5MjogNTgsXG4gICAgaW50MjAwOiA1OSxcbiAgICBpbnQyMDg6IDYwLFxuICAgIGludDIxNjogNjEsXG4gICAgaW50MjI0OiA2MixcbiAgICBpbnQyMzI6IDYzLFxuICAgIGludDI0MDogNjQsXG4gICAgaW50MjQ4OiA2NSxcbiAgICBpbnQyNTY6IDY2LFxuICAgIHVpbnQ6IDY3LFxuICAgIGJ5dGVzMTogNjksXG4gICAgYnl0ZXMyOiA3MCxcbiAgICBieXRlczM6IDcxLFxuICAgIGJ5dGVzNDogNzIsXG4gICAgYnl0ZXM1OiA3MyxcbiAgICBieXRlczY6IDc0LFxuICAgIGJ5dGVzNzogNzUsXG4gICAgYnl0ZXM4OiA3NixcbiAgICBieXRlczk6IDc3LFxuICAgIGJ5dGVzMTA6IDc4LFxuICAgIGJ5dGVzMTE6IDc5LFxuICAgIGJ5dGVzMTI6IDgwLFxuICAgIGJ5dGVzMTM6IDgxLFxuICAgIGJ5dGVzMTQ6IDgyLFxuICAgIGJ5dGVzMTU6IDgzLFxuICAgIGJ5dGVzMTY6IDg0LFxuICAgIGJ5dGVzMTc6IDg1LFxuICAgIGJ5dGVzMTg6IDg2LFxuICAgIGJ5dGVzMTk6IDg3LFxuICAgIGJ5dGVzMjA6IDg4LFxuICAgIGJ5dGVzMjE6IDg5LFxuICAgIGJ5dGVzMjI6IDkwLFxuICAgIGJ5dGVzMjM6IDkxLFxuICAgIGJ5dGVzMjQ6IDkyLFxuICAgIGJ5dGVzMjU6IDkzLFxuICAgIGJ5dGVzMjY6IDk0LFxuICAgIGJ5dGVzMjc6IDk1LFxuICAgIGJ5dGVzMjg6IDk2LFxuICAgIGJ5dGVzMjk6IDk3LFxuICAgIGJ5dGVzMzA6IDk4LFxuICAgIGJ5dGVzMzE6IDk5LFxuICAgIGJ5dGVzMzI6IDEwMCxcbiAgICBieXRlczogMTAxLFxuICAgIHN0cmluZzogMTAyLFxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBFVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRUlQNzEyX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQKSwgeyB0dXBsZTE6IDEwMywgdHVwbGUyOiAxMDQsIHR1cGxlMzogMTA1LCB0dXBsZTQ6IDEwNiwgdHVwbGU1OiAxMDcsIHR1cGxlNjogMTA4LCB0dXBsZTc6IDEwOSwgdHVwbGU4OiAxMTAsIHR1cGxlOTogMTExLCB0dXBsZTEwOiAxMTIsIHR1cGxlMTE6IDExMywgdHVwbGUxMjogMTE0LCB0dXBsZTEzOiAxMTUsIHR1cGxlMTQ6IDExNiwgdHVwbGUxNTogMTE3LCB0dXBsZTE2OiAxMTgsIHR1cGxlMTc6IDExOSB9KTtcbmV4cG9ydHMuRVRIX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQID0gRVRIX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGV0aE1zZ1Byb3RvY29sID0ge1xuICAgIFNJR05fUEVSU09OQUw6IHtcbiAgICAgICAgc3RyOiAnc2lnblBlcnNvbmFsJyxcbiAgICAgICAgZW51bUlkeDogMCwgLy8gRW51bSBpbmRleCBvZiB0aGlzIHByb3RvY29sIGluIExhdHRpY2UgZmlybXdhcmVcbiAgICB9LFxuICAgIFRZUEVEX0RBVEE6IHtcbiAgICAgICAgc3RyOiAndHlwZWREYXRhJyxcbiAgICAgICAgZW51bUlkeDogMSxcbiAgICAgICAgcmF3RGF0YU1heExlbjogMTYyOSxcbiAgICAgICAgdHlwZUNvZGVzOiBFSVA3MTJfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAsIC8vIEVudW0gaW5kaWNlcyBvZiBkYXRhIHR5cGVzIGluIExhdHRpY2UgZmlybXdhcmVcbiAgICB9LFxufTtcbmV4cG9ydHMuZXRoTXNnUHJvdG9jb2wgPSBldGhNc2dQcm90b2NvbDtcbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGdldEZ3VmVyc2lvbkNvbnN0KHYpIHtcbiAgICB2YXIgYyA9IHtcbiAgICAgICAgZXh0cmFEYXRhRnJhbWVTejogMCxcbiAgICAgICAgZXh0cmFEYXRhTWF4RnJhbWVzOiAwLFxuICAgICAgICBnZW5lcmljU2lnbmluZzoge30sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBndGUodiwgZXhwKSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCBgdmAgZmllbGRzIGNvbWUgaW4gYXMgW2ZpeHxtaW5vcnxtYWpvcl1cbiAgICAgICAgcmV0dXJuICh2WzJdID4gZXhwWzBdIHx8XG4gICAgICAgICAgICAodlsyXSA9PT0gZXhwWzBdICYmIHZbMV0gPiBleHBbMV0pIHx8XG4gICAgICAgICAgICAodlsyXSA9PT0gZXhwWzBdICYmIHZbMV0gPT09IGV4cFsxXSAmJiB2WzBdID4gZXhwWzJdKSB8fFxuICAgICAgICAgICAgKHZbMl0gPT09IGV4cFswXSAmJiB2WzFdID09PSBleHBbMV0gJiYgdlswXSA9PT0gZXhwWzJdKSk7XG4gICAgfVxuICAgIC8vIFZlcnkgb2xkIGxlZ2FjeSB2ZXJzaW9ucyBkbyBub3QgZ2l2ZSBhIHZlcnNpb24gbnVtYmVyXG4gICAgdmFyIGxlZ2FjeSA9IHYubGVuZ3RoID09PSAwO1xuICAgIC8vIEJBU0UgRklFTERTXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFZhcmlvdXMgc2l6ZSBjb25zdGFudHMgaGF2ZSBjaGFuZ2VkIG9uIHRoZSBmaXJtd2FyZSBzaWRlIG92ZXIgdGltZSBhbmRcbiAgICAvLyBhcmUgY2FwdHVyZWQgaGVyZVxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDRdKSkge1xuICAgICAgICAvLyA+PTAuMTAuM1xuICAgICAgICBjLnJlcU1heERhdGFTeiA9IDE2Nzg7XG4gICAgICAgIGMuZXRoTWF4R2FzUHJpY2UgPSAyMDAwMDAwMDAwMDAwMDsgLy8gMjAwMDAgZ3dlaVxuICAgICAgICBjLmFkZHJGbGFnc0FsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDBdKSkge1xuICAgICAgICAvLyA+PTAuMTAuMFxuICAgICAgICBjLnJlcU1heERhdGFTeiA9IDE2Nzg7XG4gICAgICAgIGMuZXRoTWF4R2FzUHJpY2UgPSAyMDAwMDAwMDAwMDAwMDsgLy8gMjAwMDAgZ3dlaVxuICAgICAgICBjLmFkZHJGbGFnc0FsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTGVnYWN5IG9yIDwwLjEwLjBcbiAgICAgICAgYy5yZXFNYXhEYXRhU3ogPSAxMTUyO1xuICAgICAgICBjLmV0aE1heEdhc1ByaWNlID0gNTAwMDAwMDAwMDAwOyAvLyA1MDAgZ3dlaVxuICAgICAgICBjLmFkZHJGbGFnc0FsbG93ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlc2UgdHJhbnNmb3JtYXRpb25zIGFwcGx5IHRvIGFsbCB2ZXJzaW9ucy4gVGhlIHN1YnRyYWN0aW9uXG4gICAgLy8gb2YgMTI4IGJ5dGVzIGFjY291bnRzIGZvciBtZXRhZGF0YSBhbmQgaXMgZm9yIGxlZ2FjeSByZWFzb25zLlxuICAgIC8vIEZvciBhbGwgbW9kZXJuIHZlcnNpb25zLCB0aGVzZSBhcmUgMTU1MCBieXRlcy5cbiAgICAvLyBOT1RFOiBOb24tbGVnYWN5IEVUSCB0eHMgKGUuZy4gRUlQMTU1OSkgd2lsbCBzaHJpbmtcbiAgICAvLyB0aGlzIG51bWJlci5cbiAgICAvLyBTZWUgYEVUSF9CQVNFX1RYX01BWF9EQVRBX1NaYCBhbmQgYEVUSF9NQVhfQkFTRV9NU0dfU1pgIGluIGZpcm13YXJlXG4gICAgYy5ldGhNYXhEYXRhU3ogPSBjLnJlcU1heERhdGFTeiAtIDEyODtcbiAgICBjLmV0aE1heE1zZ1N6ID0gYy5ldGhNYXhEYXRhU3o7XG4gICAgLy8gTWF4IG51bWJlciBvZiBwYXJhbXMgaW4gYW4gRUlQNzEyIHR5cGUuIFRoaXMgd2FzIGFkZGVkIHRvIGZpcm13YXJlXG4gICAgLy8gdG8gYXZvaWQgYmxvd2luZyBzdGFjayBzaXplLlxuICAgIGMuZWlwNzEyTWF4VHlwZVBhcmFtcyA9IDE4O1xuICAgIC8vIC0tLS0tXG4gICAgLy8gRVhUUkEgRklFTERTIEFEREVEIElOIExBVEVSIEZJUk1XQVJFIFZFUlNJT05TXG4gICAgLy8gLS0tLS1cbiAgICAvLyAtLS0gVjAuMTAuWCAtLS1cbiAgICAvLyBWMC4xMC40IGludHJvZHVjZWQgdGhlIGFiaWxpdHkgdG8gc2VuZCBzaWduaW5nIHJlcXVlc3RzIG92ZXIgbXVsdGlwbGVcbiAgICAvLyBkYXRhIGZyYW1lcyAoaS5lLiBpbiBtdWx0aXBsZSByZXF1ZXN0cylcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCA0XSkpIHtcbiAgICAgICAgYy5leHRyYURhdGFGcmFtZVN6ID0gMTUwMDsgLy8gMTUwMCBieXRlcyBwZXIgZnJhbWUgb2YgZXh0cmFEYXRhIGFsbG93ZWRcbiAgICAgICAgYy5leHRyYURhdGFNYXhGcmFtZXMgPSAxOyAvLyAxIGZyYW1lIG9mIGV4dHJhRGF0YSBhbGxvd2VkXG4gICAgfVxuICAgIC8vIFYwLjEwLjUgYWRkZWQgdGhlIGFiaWxpdHkgdG8gdXNlIGZsZXhpYmxlIGFkZHJlc3MgcGF0aCBzaXplcywgd2hpY2hcbiAgICAvLyBjaGFuZ2VzIHRoZSBgZ2V0QWRkcmVzc2AgQVBJLiBJdCBhbHNvIGFkZGVkIHN1cHBvcnQgZm9yIEVJUDcxMlxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDVdKSkge1xuICAgICAgICBjLnZhckFkZHJQYXRoU3pBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgYy5laXA3MTJTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBWMC4xMC44IGFsbG93cyBhIHVzZXIgdG8gc2lnbiBhIHByZWhhc2hlZCB0cmFuc2FjdGlvbiBpZiB0aGUgcGF5bG9hZFxuICAgIC8vIGlzIHRvbyBiaWdcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCA4XSkpIHtcbiAgICAgICAgYy5wcmVoYXNoQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIFYwLjEwLjEwIGFsbG93cyBhIHVzZXIgdG8gc2lnbiBhIHByZWhhc2hlZCBFVEggbWVzc2FnZSBpZiBwYXlsb2FkIHRvbyBiaWdcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCAxMF0pKSB7XG4gICAgICAgIGMuZXRoTXNnUHJlSGFzaEFsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyAtLS0gMC4xMS5YIC0tLVxuICAgIC8vIFYwLjExLjAgYWxsb3dzIG5ldyBFVEggdHJhbnNhY3Rpb24gdHlwZXNcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDExLCAwXSkpIHtcbiAgICAgICAgYy5hbGxvd2VkRXRoVHhUeXBlcyA9IFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAyLCAvLyBlaXAxNTU5XG4gICAgICAgIF07XG4gICAgICAgIC8vIFRoaXMgdmVyc2lvbiBhZGRlZCBleHRyYSBkYXRhIGZpZWxkcyB0byB0aGUgRVRIIHR4XG4gICAgICAgIGMuZXRoTWF4RGF0YVN6IC09IDEwO1xuICAgICAgICBjLmV0aE1heE1zZ1N6ID0gYy5ldGhNYXhEYXRhU3o7XG4gICAgfVxuICAgIC8vIFYwLjExLjIgY2hhbmdlZCBob3cgbWVzc2FnZXMgYXJlIGRpc3BsYXllZC4gRm9yIHBlcnNvbmFsX3NpZ24gbWVzc2FnZXNcbiAgICAvLyB3ZSBub3cgd3JpdGUgdGhlIGhlYWRlciAoYFNpZ25lcjogPHBhdGg+YCkgaW50byB0aGUgbWFpbiBib2R5IG9mIHRoZSBzY3JlZW4uXG4gICAgLy8gVGhpcyBtZWFucyBwZXJzb25hbCBzaWduIG1lc3NhZ2UgbWF4IHNpemUgaXMgc2xpZ2h0bHkgc21hbGxlciB0aGFuIGZvclxuICAgIC8vIEVJUDcxMiBtZXNzYWdlcyBiZWNhdXNlIGluIHRoZSBsYXR0ZXIgY2FzZSB0aGVyZSBpcyBubyBoZWFkZXJcbiAgICAvLyBOb3RlIHRoYXQgYDxwYXRoPmAgaGFzIG1heCBzaXplIG9mIDYyIGJ5dGVzIChgbS9YL1gvLi4uYClcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDExLCAyXSkpIHtcbiAgICAgICAgYy5wZXJzb25hbFNpZ25IZWFkZXJTeiA9IDcyO1xuICAgIH1cbiAgICAvLyAtLS0gVjAuMTIuWCAtLS1cbiAgICAvLyBWMC4xMi4wIGFkZGVkIGFuIEFQSSBmb3IgY3JlYXRpbmcsIHJlbW92aW5nLCBhbmQgZmV0Y2hpbmcga2V5LXZhbCBmaWxlXG4gICAgLy8gcmVjb3Jkcy4gRm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIFNESywgd2Ugb25seSBob29rIGludG8gb25lIHR5cGUgb2Yga3ZcbiAgICAvLyBmaWxlOiBhZGRyZXNzIG5hbWVzLlxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTIsIDBdKSkge1xuICAgICAgICBjLmt2QWN0aW9uc0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICBjLmt2S2V5TWF4U3RyU3ogPSA2MztcbiAgICAgICAgYy5rdlZhbE1heFN0clN6ID0gNjM7XG4gICAgICAgIGMua3ZBY3Rpb25NYXhOdW0gPSAxMDtcbiAgICAgICAgYy5rdlJlbW92ZU1heE51bSA9IDEwMDtcbiAgICB9XG4gICAgLy8gLS0tIFYwLjEzLlggLS0tXG4gICAgLy8gVjAuMTMuMCBhZGRlZCBuYXRpdmUgc2Vnd2l0IGFkZHJlc3NlcyBhbmQgZml4ZWQgYSBidWcgaW4gZXhwb3J0aW5nXG4gICAgLy8gbGVnYWN5IGJpdGNvaW4gYWRkcmVzc2VzXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMywgMF0pKSB7XG4gICAgICAgIGMuYWxsb3dCdGNMZWdhY3lBbmRTZWd3aXRBZGRycyA9IHRydWU7XG4gICAgICAgIC8vIFJhbmRvbSBhZGRyZXNzIHRvIGJlIHVzZWQgd2hlbiB0cnlpbmcgdG8gZGVwbG95IGEgY29udHJhY3RcbiAgICAgICAgYy5jb250cmFjdERlcGxveUtleSA9ICcweDA4MDAyZTBmZWM4ZTZhY2YwMDgzNWY0M2M5NzY0ZjczNjRmYTNmNDInO1xuICAgIH1cbiAgICAvLyAtLS0gVjAuMTQuWCAtLS1cbiAgICAvLyBWMC4xNC4wIGFkZGVkIHN1cHBvcnQgZm9yIGEgbW9yZSByb2J1c3QgQVBJIGFyb3VuZCBBQkkgZGVmaW5pdGlvbnNcbiAgICAvLyBhbmQgZ2VuZXJpYyBzaWduaW5nIGZ1bmN0aW9uYWxpdHlcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDE0LCAwXSkpIHtcbiAgICAgICAgLy8gU2l6ZSBvZiBgY2F0ZWdvcnlgIGJ1ZmZlci4gSW5jbHVzaXZlIG9mIG51bGwgdGVybWluYXRvciBieXRlLlxuICAgICAgICBjLmFiaUNhdGVnb3J5U3ogPSAzMjtcbiAgICAgICAgYy5hYmlNYXhSbXYgPSAyMDA7IC8vIE1heCBudW1iZXIgb2YgQUJJIGRlZnMgdGhhdCBjYW4gYmUgcmVtb3ZlZCB3aXRoXG4gICAgICAgIC8vIGEgc2luZ2xlIHJlcXVlc3RcbiAgICAgICAgLy8gU2VlIGBzaXplb2YoR2VuZXJpY1NpZ25pbmdSZXF1ZXN0X3QpYCBpbiBmaXJtd2FyZVxuICAgICAgICBjLmdlbmVyaWNTaWduaW5nLmJhc2VSZXFTeiA9IDE1NTI7XG4gICAgICAgIC8vIFNlZSBgR0VORVJJQ19TSUdOSU5HX0JBU0VfTVNHX1NaYCBpbiBmaXJtd2FyZVxuICAgICAgICBjLmdlbmVyaWNTaWduaW5nLmJhc2VEYXRhU3ogPSAxNTE5O1xuICAgICAgICBjLmdlbmVyaWNTaWduaW5nLmhhc2hUeXBlcyA9IGV4cG9ydHMuRVhURVJOQUwuU0lHTklORy5IQVNIRVM7XG4gICAgICAgIGMuZ2VuZXJpY1NpZ25pbmcuY3VydmVUeXBlcyA9IGV4cG9ydHMuRVhURVJOQUwuU0lHTklORy5DVVJWRVM7XG4gICAgICAgIGMuZ2VuZXJpY1NpZ25pbmcuZW5jb2RpbmdUeXBlcyA9IHtcbiAgICAgICAgICAgIE5PTkU6IGV4cG9ydHMuRVhURVJOQUwuU0lHTklORy5FTkNPRElOR1MuTk9ORSxcbiAgICAgICAgICAgIFNPTEFOQTogZXhwb3J0cy5FWFRFUk5BTC5TSUdOSU5HLkVOQ09ESU5HUy5TT0xBTkEsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFN1cHBvcnRlZCBmbGFncyBmb3IgYGdldEFkZHJlc3Nlc2BcbiAgICAgICAgYy5nZXRBZGRyZXNzRmxhZ3MgPSBbXG4gICAgICAgICAgICBleHBvcnRzLkVYVEVSTkFMLkdFVF9BRERSX0ZMQUdTLkVEMjU1MTlfUFVCLFxuICAgICAgICAgICAgZXhwb3J0cy5FWFRFUk5BTC5HRVRfQUREUl9GTEFHUy5TRUNQMjU2SzFfUFVCLFxuICAgICAgICBdO1xuICAgICAgICAvLyBXZSB1cGRhdGVkIHRoZSBtYXggbnVtYmVyIG9mIHBhcmFtcyBpbiBFSVA3MTIgdHlwZXNcbiAgICAgICAgYy5laXA3MTJNYXhUeXBlUGFyYW1zID0gMzY7XG4gICAgfVxuICAgIC8vIERFUFJFQ0FURURcbiAgICAvLyBWMC4xNC4xIEFkZGVkIHRoZSBUZXJyYSBkZWNvZGVyXG4gICAgLy8gaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxNCwgMV0pKSB7XG4gICAgLy8gICBjLmdlbmVyaWNTaWduaW5nLmVuY29kaW5nVHlwZXMuVEVSUkEgPSBFWFRFUk5BTC5TSUdOSU5HLkVOQ09ESU5HUy5URVJSQTtcbiAgICAvLyB9XG4gICAgLy8gLS0tIFYwLjE1LlggLS0tXG4gICAgLy8gVjAuMTUuMCBhZGRlZCBhbiBFVk0gZGVjb2RlciBhbmQgcmVtb3ZlZCB0aGUgbGVnYWN5IEVUSCBzaWduaW5nIHBhdGh3YXlcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDE1LCAwXSkpIHtcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5lbmNvZGluZ1R5cGVzLkVWTSA9IGV4cG9ydHMuRVhURVJOQUwuU0lHTklORy5FTkNPRElOR1MuRVZNO1xuICAgICAgICAvLyBXZSBub3cgdXNlIHRoZSBnZW5lcmFsIHNpZ25pbmcgZGF0YSBmaWVsZCBhcyB0aGUgYmFzZVxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSBOT1QgcmVtb3ZlZCB0aGUgRVRIX01TRyB0eXBlIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBub3QgY2hhbmdlIGV0aE1heE1zZ1N6XG4gICAgICAgIGMuZXRoTWF4RGF0YVN6ID0gMTU1MCAtIDMxO1xuICAgICAgICAvLyBNYXggYnVmZmVyIHNpemUgZm9yIGdldC9hZGQgZGVjb2RlciByZXF1ZXN0c1xuICAgICAgICBjLm1heERlY29kZXJCdWZTeiA9IDE2MDA7XG4gICAgICAgIC8vIENvZGUgdXNlZCB0byB3cml0ZSBhIGNhbGxkYXRhIGRlY29kZXJcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5jYWxsZGF0YURlY29kaW5nID0ge1xuICAgICAgICAgICAgcmVzZXJ2ZWQ6IDI4OTU3MjgsXG4gICAgICAgICAgICBtYXhTejogMTAyNCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gLS0tIFYwLjE3LlggLS0tXG4gICAgLy8gVjAuMTcuMCBhZGRlZCBzdXBwb3J0IGZvciBCTFMxMi0zODEtRzEgcHVia2V5cyBhbmQgRzIgc2lnc1xuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTcsIDBdKSkge1xuICAgICAgICBjLmdldEFkZHJlc3NGbGFncy5wdXNoKGV4cG9ydHMuRVhURVJOQUwuR0VUX0FERFJfRkxBR1MuQkxTMTJfMzgxX0cxX1BVQik7XG4gICAgICAgIGMuZ2VuZXJpY1NpZ25pbmcuZW5jb2RpbmdUeXBlcy5FVEhfREVQT1NJVCA9IGV4cG9ydHMuRVhURVJOQUwuU0lHTklORy5FTkNPRElOR1MuRVRIX0RFUE9TSVQ7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuZXhwb3J0cy5nZXRGd1ZlcnNpb25Db25zdCA9IGdldEZ3VmVyc2lvbkNvbnN0O1xuLyoqIEBpbnRlcm5hbCAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBBU0NJSV9SRUdFWCA9IC9eW1xceDAwLVxceDdGXSskLztcbmV4cG9ydHMuQVNDSUlfUkVHRVggPSBBU0NJSV9SRUdFWDtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBFWFRFUk5BTF9ORVRXT1JLU19CWV9DSEFJTl9JRF9VUkwgPSAnaHR0cHM6Ly9ncmlkcGx1cy5naXRodWIuaW8vY2hhaW5zL2NoYWlucy5qc29uJztcbmV4cG9ydHMuRVhURVJOQUxfTkVUV09SS1NfQllfQ0hBSU5fSURfVVJMID0gRVhURVJOQUxfTkVUV09SS1NfQllfQ0hBSU5fSURfVVJMO1xuLyoqIEBpbnRlcm5hbCAtIE1heCBudW1iZXIgb2YgYWRkcmVzc2VzIHRvIGZldGNoICovXG52YXIgTUFYX0FERFIgPSAxMDtcbmV4cG9ydHMuTUFYX0FERFIgPSBNQVhfQUREUjtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBORVRXT1JLU19CWV9DSEFJTl9JRCA9IHtcbiAgICAxOiB7XG4gICAgICAgIG5hbWU6ICdldGhlcmV1bScsXG4gICAgICAgIGJhc2VVcmw6ICdodHRwczovL2FwaS5ldGhlcnNjYW4uaW8nLFxuICAgICAgICBhcGlSb3V0ZTogJ2FwaT9tb2R1bGU9Y29udHJhY3QmYWN0aW9uPWdldGFiaScsXG4gICAgfSxcbiAgICAxMzc6IHtcbiAgICAgICAgbmFtZTogJ3BvbHlnb24nLFxuICAgICAgICBiYXNlVXJsOiAnaHR0cHM6Ly9hcGkucG9seWdvbnNjYW4uY29tJyxcbiAgICAgICAgYXBpUm91dGU6ICdhcGk/bW9kdWxlPWNvbnRyYWN0JmFjdGlvbj1nZXRhYmknLFxuICAgIH0sXG4gICAgNTY6IHtcbiAgICAgICAgbmFtZTogJ2JpbmFuY2UnLFxuICAgICAgICBiYXNlVXJsOiAnaHR0cHM6Ly9hcGkuYnNjc2Nhbi5jb20nLFxuICAgICAgICBhcGlSb3V0ZTogJ2FwaT9tb2R1bGU9Y29udHJhY3QmYWN0aW9uPWdldGFiaScsXG4gICAgfSxcbiAgICA0MjIyMDoge1xuICAgICAgICBuYW1lOiAnY2VsbycsXG4gICAgICAgIGJhc2VVcmw6ICdodHRwczovL2FwaS5jZWxvc2Nhbi5pbycsXG4gICAgICAgIGFwaVJvdXRlOiAnYXBpP21vZHVsZT1jb250cmFjdCZhY3Rpb249Z2V0YWJpJyxcbiAgICB9LFxuICAgIDQzMTE0OiB7XG4gICAgICAgIG5hbWU6ICdhdmFsYW5jaGUnLFxuICAgICAgICBiYXNlVXJsOiAnaHR0cHM6Ly9hcGkuc25vd3RyYWNlLmlvJyxcbiAgICAgICAgYXBpUm91dGU6ICdhcGk/bW9kdWxlPWNvbnRyYWN0JmFjdGlvbj1nZXRhYmknLFxuICAgIH0sXG59O1xuZXhwb3J0cy5ORVRXT1JLU19CWV9DSEFJTl9JRCA9IE5FVFdPUktTX0JZX0NIQUlOX0lEO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5FTVBUWV9XQUxMRVRfVUlEID0gQnVmZmVyLmFsbG9jKDMyKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydHMuREVGQVVMVF9BQ1RJVkVfV0FMTEVUUyA9IHtcbiAgICBpbnRlcm5hbDoge1xuICAgICAgICB1aWQ6IGV4cG9ydHMuRU1QVFlfV0FMTEVUX1VJRCxcbiAgICAgICAgZXh0ZXJuYWw6IGZhbHNlLFxuICAgICAgICBuYW1lOiBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGNhcGFiaWxpdGllczogMCxcbiAgICB9LFxuICAgIGV4dGVybmFsOiB7XG4gICAgICAgIHVpZDogZXhwb3J0cy5FTVBUWV9XQUxMRVRfVUlELFxuICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgbmFtZTogQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IDAsXG4gICAgfSxcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkRFRkFVTFRfRVRIX0RFUklWQVRJT04gPSBbXG4gICAgSEFSREVORURfT0ZGU0VUICsgNDQsXG4gICAgSEFSREVORURfT0ZGU0VUICsgNjAsXG4gICAgSEFSREVORURfT0ZGU0VULFxuICAgIDAsXG4gICAgMCxcbl07XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkJUQ19MRUdBQ1lfREVSSVZBVElPTiA9IFtcbiAgICBIQVJERU5FRF9PRkZTRVQgKyA0NCxcbiAgICBIQVJERU5FRF9PRkZTRVQgKyAwLFxuICAgIEhBUkRFTkVEX09GRlNFVCxcbiAgICAwLFxuICAgIDAsXG5dO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5CVENfU0VHV0lUX0RFUklWQVRJT04gPSBbXG4gICAgSEFSREVORURfT0ZGU0VUICsgODQsXG4gICAgSEFSREVORURfT0ZGU0VULFxuICAgIEhBUkRFTkVEX09GRlNFVCxcbiAgICAwLFxuICAgIDAsXG5dO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5CVENfV1JBUFBFRF9TRUdXSVRfREVSSVZBVElPTiA9IFtcbiAgICBIQVJERU5FRF9PRkZTRVQgKyA0OSxcbiAgICBIQVJERU5FRF9PRkZTRVQsXG4gICAgSEFSREVORURfT0ZGU0VULFxuICAgIDAsXG4gICAgMCxcbl07XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLlNPTEFOQV9ERVJJVkFUSU9OID0gW1xuICAgIEhBUkRFTkVEX09GRlNFVCArIDQ0LFxuICAgIEhBUkRFTkVEX09GRlNFVCArIDUwMSxcbiAgICBIQVJERU5FRF9PRkZTRVQsXG5dO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5MRURHRVJfTElWRV9ERVJJVkFUSU9OID0gW1xuICAgIEhBUkRFTkVEX09GRlNFVCArIDQ5LFxuICAgIEhBUkRFTkVEX09GRlNFVCArIDYwLFxuICAgIEhBUkRFTkVEX09GRlNFVCxcbiAgICAwLFxuICAgIDAsXG5dO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5MRURHRVJfTEVHQUNZX0RFUklWQVRJT04gPSBbXG4gICAgSEFSREVORURfT0ZGU0VUICsgNDksXG4gICAgSEFSREVORURfT0ZGU0VUICsgNjAsXG4gICAgSEFSREVORURfT0ZGU0VULFxuICAgIDAsXG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBVdGlscyBmb3IgRXRoZXJldW0gdHJhbnNhY3Rpb25zLiBUaGlzIGlzIGVmZmVjaXR2ZWx5IGEgc2hpbSBvZiBldGhlcmV1bWpzLXV0aWwsIHdoaWNoXG4vLyBkb2VzIG5vdCBoYXZlIGJyb3dzZXIgKG9yLCBieSBwcm94eSwgUmVhY3QtTmF0aXZlKSBzdXBwb3J0LlxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL2NvbW1vblwiKTtcbnZhciB0eF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpO1xudmFyIGJpZ251bWJlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIikpO1xudmFyIGJvcmNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm9yY1wiKSk7XG4vL0B0cy1leHBlY3QtZXJyb3IgLSBUaGlzIHRoaXJkLXBhcnR5IHBhY2thZ2UgaXMgbm90IHR5cGVkIHByb3Blcmx5XG52YXIgZXRoX2VpcDcxMl91dGlsX2Jyb3dzZXJfMSA9IHJlcXVpcmUoXCJldGgtZWlwNzEyLXV0aWwtYnJvd3NlclwiKTtcbnZhciBqc19zaGEzXzEgPSByZXF1aXJlKFwianMtc2hhM1wiKTtcbnZhciBybHBfMSA9IHJlcXVpcmUoXCJybHBcIik7XG52YXIgc2VjcDI1NmsxXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInNlY3AyNTZrMVwiKSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgYnVpbGRFdGhlcmV1bU1zZ1JlcXVlc3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0LnBheWxvYWQgfHwgIWlucHV0LnByb3RvY29sIHx8ICFpbnB1dC5zaWduZXJQYXRoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYHBheWxvYWRgLCBgc2lnbmVyUGF0aGAsIGFuZCBgcHJvdG9jb2xgIGFyZ3VtZW50cyBpbiB0aGUgbWVzc3NhZ2UgcmVxdWVzdCcpO1xuICAgIGlmIChpbnB1dC5zaWduZXJQYXRoLmxlbmd0aCA+IDUgfHwgaW5wdXQuc2lnbmVyUGF0aC5sZW5ndGggPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgc2lnbmVyIHBhdGggd2l0aCAyLTUgaW5kaWNlcycpO1xuICAgIHZhciByZXEgPSB7XG4gICAgICAgIHNjaGVtYTogcHJvdG9jb2xfMS5MYXR0aWNlU2lnblNjaGVtYS5ldGhlcmV1bU1zZyxcbiAgICAgICAgcGF5bG9hZDogbnVsbCxcbiAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICBtc2c6IG51bGwsIC8vIFNhdmUgdGhlIGJ1ZmZlcmVkIG1lc3NhZ2UgZm9yIGxhdGVyXG4gICAgfTtcbiAgICBzd2l0Y2ggKGlucHV0LnByb3RvY29sKSB7XG4gICAgICAgIGNhc2UgJ3NpZ25QZXJzb25hbCc6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQZXJzb25hbFNpZ25SZXF1ZXN0KHJlcSwgaW5wdXQpO1xuICAgICAgICBjYXNlICdlaXA3MTInOlxuICAgICAgICAgICAgaWYgKCFpbnB1dC5md0NvbnN0YW50cy5laXA3MTJTdXBwb3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFSVA3MTIgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIExhdHRpY2UgZmlybXdhcmUgdmVyc2lvbi4gUGxlYXNlIHVwZ3JhZGUuJyk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRFSVA3MTJSZXF1ZXN0KHJlcSwgaW5wdXQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbCcpO1xuICAgIH1cbn07XG52YXIgdmFsaWRhdGVFdGhlcmV1bU1zZ1Jlc3BvbnNlID0gZnVuY3Rpb24gKHJlcywgcmVxKSB7XG4gICAgdmFyIHNpZ25lciA9IHJlcy5zaWduZXIsIHNpZyA9IHJlcy5zaWc7XG4gICAgdmFyIGlucHV0ID0gcmVxLmlucHV0LCBtc2cgPSByZXEubXNnLCBfYSA9IHJlcS5wcmVoYXNoLCBwcmVoYXNoID0gX2EgPT09IHZvaWQgMCA/IG51bGwgOiBfYTtcbiAgICBpZiAoaW5wdXQucHJvdG9jb2wgPT09ICdzaWduUGVyc29uYWwnKSB7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSBjdXJyZW50bHkgaGFyZGNvZGluZyBuZXR3b3JrSUQ9MSBhbmQgdXNlRUlQMTU1PWZhbHNlIGJ1dCB0aGVzZVxuICAgICAgICAvLyAgICAgICBtYXkgYmUgY29uZmlndXJhYmxlIGluIGZ1dHVyZSB2ZXJzaW9uc1xuICAgICAgICB2YXIgaGFzaF8xID0gcHJlaGFzaFxuICAgICAgICAgICAgPyBwcmVoYXNoXG4gICAgICAgICAgICA6IEJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtnZXRfcGVyc29uYWxfc2lnbl9wcmVmaXgobXNnLmxlbmd0aCksIG1zZ10pKSwgJ2hleCcpO1xuICAgICAgICAvLyBHZXQgcmVjb3ZlcnkgcGFyYW0gd2l0aCBhIGB2YCB2YWx1ZSBvZiBbMjcsMjhdIGJ5IHNldHRpbmcgYHVzZUVJUDE1NT1mYWxzZWBcbiAgICAgICAgcmV0dXJuIGFkZFJlY292ZXJ5UGFyYW0oaGFzaF8xLCBzaWcsIHNpZ25lciwge1xuICAgICAgICAgICAgY2hhaW5JZDogMSxcbiAgICAgICAgICAgIHVzZUVJUDE1NTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnB1dC5wcm90b2NvbCA9PT0gJ2VpcDcxMicpIHtcbiAgICAgICAgdmFyIGVuY29kZWQgPSBldGhfZWlwNzEyX3V0aWxfYnJvd3Nlcl8xLlR5cGVkRGF0YVV0aWxzLmhhc2gocmVxLmlucHV0LnBheWxvYWQpO1xuICAgICAgICB2YXIgZGlnZXN0ID0gcHJlaGFzaCA/IHByZWhhc2ggOiBlbmNvZGVkO1xuICAgICAgICAvLyBHZXQgcmVjb3ZlcnkgcGFyYW0gd2l0aCBhIGB2YCB2YWx1ZSBvZiBbMjcsMjhdIGJ5IHNldHRpbmcgYHVzZUVJUDE1NT1mYWxzZWBcbiAgICAgICAgcmV0dXJuIGFkZFJlY292ZXJ5UGFyYW0oZGlnZXN0LCBzaWcsIHNpZ25lciwgeyB1c2VFSVAxNTU6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbCcpO1xuICAgIH1cbn07XG52YXIgYnVpbGRFdGhlcmV1bVR4UmVxdWVzdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIF9hID0gZGF0YS5jaGFpbklkLCBjaGFpbklkID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYTtcbiAgICAgICAgdmFyIHNpZ25lclBhdGggPSBkYXRhLnNpZ25lclBhdGgsIF9iID0gZGF0YS5laXAxNTUsIGVpcDE1NSA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2IsIGZ3Q29uc3RhbnRzID0gZGF0YS5md0NvbnN0YW50cywgX2MgPSBkYXRhLnR5cGUsIHR5cGUgPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jO1xuICAgICAgICB2YXIgY29udHJhY3REZXBsb3lLZXkgPSBmd0NvbnN0YW50cy5jb250cmFjdERlcGxveUtleSwgZXh0cmFEYXRhRnJhbWVTeiA9IGZ3Q29uc3RhbnRzLmV4dHJhRGF0YUZyYW1lU3osIGV4dHJhRGF0YU1heEZyYW1lcyA9IGZ3Q29uc3RhbnRzLmV4dHJhRGF0YU1heEZyYW1lcywgcHJlaGFzaEFsbG93ZWQgPSBmd0NvbnN0YW50cy5wcmVoYXNoQWxsb3dlZDtcbiAgICAgICAgdmFyIEVYVFJBX0RBVEFfQUxMT1dFRCA9IGV4dHJhRGF0YUZyYW1lU3ogPiAwICYmIGV4dHJhRGF0YU1heEZyYW1lcyA+IDA7XG4gICAgICAgIHZhciBNQVhfQkFTRV9EQVRBX1NaID0gZndDb25zdGFudHMuZXRoTWF4RGF0YVN6O1xuICAgICAgICB2YXIgVkFSX1BBVEhfU1ogPSBmd0NvbnN0YW50cy52YXJBZGRyUGF0aFN6QWxsb3dlZDtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrczpcbiAgICAgICAgLy8gVGhlcmUgYXJlIGEgaGFuZGZ1bCBvZiBuYW1lZCBjaGFpbnMgd2UgYWxsb3cgdGhlIHVzZXIgdG8gcmVmZXJlbmNlIChgY2hhaW5JZHNgKVxuICAgICAgICAvLyBDdXN0b20gY2hhaW5JRHMgc2hvdWxkIGJlIGVpdGhlciBudW1lcmljYWwgb3IgaGV4IHN0cmluZ3NcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFpbklkICE9PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgaXNWYWxpZENoYWluSWRIZXhOdW1TdHIoY2hhaW5JZCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gY2hhaW5JZHNbY2hhaW5JZF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgbm90IGEgY3VzdG9tIGNoYWluSUQgYW5kIHdlIGNhbm5vdCBmaW5kIHRoZSBuYW1lIG9mIGl0LCBleGl0XG4gICAgICAgIGlmICghY2hhaW5JZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY2hhaW4gSUQgb3IgbmFtZScpO1xuICAgICAgICAvLyBTYW5pdHkgY2hlY2sgb24gc2lnbmVQYXRoXG4gICAgICAgIGlmICghc2lnbmVyUGF0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYHNpZ25lclBhdGhgIG5vdCBwcm92aWRlZCcpO1xuICAgICAgICAvLyBJcyB0aGlzIGEgY29udHJhY3QgZGVwbG95bWVudD9cbiAgICAgICAgaWYgKGRhdGEudG8gPT09IG51bGwgJiYgIWNvbnRyYWN0RGVwbG95S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGRlcGxveW1lbnQgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSB5b3VyIExhdHRpY2UgZmlybXdhcmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzRGVwbG95bWVudCA9IGRhdGEudG8gPT09IG51bGwgJiYgY29udHJhY3REZXBsb3lLZXk7XG4gICAgICAgIC8vIFdlIHN1cHBvcnQgZWlwMTU1OSBhbmQgZWlwMjkzMCB0eXBlcyAoYXMgd2VsbCBhcyBsZWdhY3kpXG4gICAgICAgIHZhciBlaXAxNTU5SXNBbGxvd2VkID0gZndDb25zdGFudHMuYWxsb3dlZEV0aFR4VHlwZXMgJiZcbiAgICAgICAgICAgIGZ3Q29uc3RhbnRzLmFsbG93ZWRFdGhUeFR5cGVzLmluZGV4T2YoMikgPiAtMTtcbiAgICAgICAgdmFyIGVpcDI5MzBJc0FsbG93ZWQgPSBmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlcyAmJlxuICAgICAgICAgICAgZndDb25zdGFudHMuYWxsb3dlZEV0aFR4VHlwZXMuaW5kZXhPZigxKSA+IC0xO1xuICAgICAgICB2YXIgaXNFaXAxNTU5ID0gZWlwMTU1OUlzQWxsb3dlZCAmJiAodHlwZSA9PT0gMiB8fCB0eXBlID09PSAnZWlwMTU1OScpO1xuICAgICAgICB2YXIgaXNFaXAyOTMwID0gZWlwMjkzMElzQWxsb3dlZCAmJiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSAnZWlwMjkzMCcpO1xuICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiAhaXNFaXAxNTU5ICYmICFpc0VpcDI5MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEV0aGVyZXVtIHRyYW5zYWN0aW9uIHR5cGUnKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgRUlQMTU1IGdpdmVuIHRoZSBjaGFpbklELlxuICAgICAgICAvLyBJZiB3ZSBhcmUgZXhwbGljaXRseSB0b2xkIHRvIHVzZSBlaXAxNTUsIHdlIHdpbGwgdXNlIGl0LiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHdlIHdpbGwgbG9vayB1cCBpZiB0aGUgc3BlY2lmaWVkIGNoYWluSWQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgY2hhaW5cbiAgICAgICAgLy8gdGhhdCBkb2VzIG5vdCB1c2UgRUlQMTU1IGJ5IGRlZmF1bHQuIE5vdGUgdGhhdCBtb3N0IGRvIHVzZSBFSVAxNTUuXG4gICAgICAgIHZhciB1c2VFSVAxNTUgPSBjaGFpblVzZXNFSVAxNTUoY2hhaW5JZCk7XG4gICAgICAgIGlmIChlaXAxNTUgIT09IG51bGwgJiYgdHlwZW9mIGVpcDE1NSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB1c2VFSVAxNTUgPSBlaXAxNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFaXAxNTU5IHx8IGlzRWlwMjkzMCkge1xuICAgICAgICAgICAgLy8gTmV3ZXIgdHJhbnNhY3Rpb24gdHlwZXMgZG8gbm90IHVzZSBFSVAxNTUgc2luY2UgdGhlIGNoYWluSWQgaXMgc2VyaWFsaXplZFxuICAgICAgICAgICAgdXNlRUlQMTU1ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFjayBmb3IgbWV0YW1hc2ssIHdoaWNoIHNlbmRzIHZhbHVlPW51bGwgZm9yIDAgRVRIIHRyYW5zYWN0aW9uc1xuICAgICAgICBpZiAoIWRhdGEudmFsdWUpXG4gICAgICAgICAgICBkYXRhLnZhbHVlID0gMDtcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAxLiBCVUlMRCBUSEUgUkFXIFRYIEZPUiBGVVRVUkUgUkxQIEVOQ09ESU5HXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRW5zdXJlIGFsbCBmaWVsZHMgYXJlIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzXG4gICAgICAgIHZhciByYXdUeCA9IFtdO1xuICAgICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb24gYnVmZmVyIGFycmF5XG4gICAgICAgIHZhciBjaGFpbklkQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoY2hhaW5JZCk7XG4gICAgICAgIHZhciBub25jZUJ5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEubm9uY2UpO1xuICAgICAgICB2YXIgZ2FzUHJpY2VCeXRlcyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGdhc0xpbWl0Qnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS5nYXNMaW1pdCk7XG4gICAgICAgIC8vIEhhbmRsZSBjb250cmFjdCBkZXBsb3ltZW50IChpbmRpY2F0ZWQgYnkgYHRvYCBiZWluZyBgbnVsbGApXG4gICAgICAgIC8vIEZvciBjb250cmFjdCBkZXBsb3ltZW50IHdlIHdyaXRlIGEgMjAtYnl0ZSBrZXkgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgLy8gYnVmZmVyLCB3aGljaCBnZXRzIHN3YXBwZWQgZm9yIGFuIGVtcHR5IGJ1ZmZlciBpbiBmaXJtd2FyZS5cbiAgICAgICAgdmFyIHRvUmxwRWxlbSA9IHZvaWQgMCwgdG9CeXRlcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzRGVwbG95bWVudCkge1xuICAgICAgICAgICAgdG9SbHBFbGVtID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICAgICAgdG9CeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShjb250cmFjdERlcGxveUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JscEVsZW0gPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS50byk7XG4gICAgICAgICAgICB0b0J5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEudG8pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUJ5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEudmFsdWUpO1xuICAgICAgICB2YXIgZGF0YUJ5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEuZGF0YSk7XG4gICAgICAgIGlmIChpc0VpcDE1NTkgfHwgaXNFaXAyOTMwKSB7XG4gICAgICAgICAgICAvLyBFSVAxNTU5IGFuZCBFSVAyOTMwIHRyYW5zYWN0aW9ucyBoYXZlIGEgY2hhaW5JRCBmaWVsZFxuICAgICAgICAgICAgcmF3VHgucHVzaChjaGFpbklkQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJhd1R4LnB1c2gobm9uY2VCeXRlcyk7XG4gICAgICAgIHZhciBtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzID0gdm9pZCAwLCBtYXhGZWVQZXJHYXNCeXRlcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzRWlwMTU1OSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQMTU1OSB0cmFuc2FjdGlvbnMgbXVzdCBpbmNsdWRlIGBtYXhQcmlvcml0eUZlZVBlckdhc2AnKTtcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgICAgICByYXdUeC5wdXNoKG1heFByaW9yaXR5RmVlUGVyR2FzQnl0ZXMpO1xuICAgICAgICAgICAgbWF4RmVlUGVyR2FzQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS5tYXhGZWVQZXJHYXMpO1xuICAgICAgICAgICAgcmF3VHgucHVzaChtYXhGZWVQZXJHYXNCeXRlcyk7XG4gICAgICAgICAgICAvLyBFSVAxNTU5IHJlbmFtZWQgXCJnYXNQcmljZVwiIHRvIFwibWF4RmVlUGVyR2FzXCIsIGJ1dCBmaXJtd2FyZSBzdGlsbFxuICAgICAgICAgICAgLy8gdXNlcyBgZ2FzUHJpY2VgIGluIHRoZSBzdHJ1Y3QsIHNvIHVwZGF0ZSB0aGF0IHZhbHVlIGhlcmUuXG4gICAgICAgICAgICBnYXNQcmljZUJ5dGVzID0gbWF4RmVlUGVyR2FzQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFSVAxNTU5IHRyYW5zYWN0aW9ucyBkbyBub3QgaGF2ZSB0aGUgZ2FzUHJpY2UgZmllbGRcbiAgICAgICAgICAgIGdhc1ByaWNlQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS5nYXNQcmljZSk7XG4gICAgICAgICAgICByYXdUeC5wdXNoKGdhc1ByaWNlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJhd1R4LnB1c2goZ2FzTGltaXRCeXRlcyk7XG4gICAgICAgIHJhd1R4LnB1c2godG9SbHBFbGVtKTtcbiAgICAgICAgcmF3VHgucHVzaCh2YWx1ZUJ5dGVzKTtcbiAgICAgICAgcmF3VHgucHVzaChkYXRhQnl0ZXMpO1xuICAgICAgICAvLyBXZSBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzTGlzdCBpbiBmaXJtd2FyZSBzbyB3ZSBuZWVkIHRvIHByZWhhc2ggaWZcbiAgICAgICAgLy8gdGhlIGxpc3QgaXMgbm9uLW51bGxcbiAgICAgICAgdmFyIFBSRUhBU0hfRlJPTV9BQ0NFU1NfTElTVF8xID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0VpcDE1NTkgfHwgaXNFaXAyOTMwKSB7XG4gICAgICAgICAgICB2YXIgYWNjZXNzTGlzdF8xID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmFjY2Vzc0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5hY2Nlc3NMaXN0LmZvckVhY2goZnVuY3Rpb24gKGxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtLnN0b3JhZ2VLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKCgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3RfMS5wdXNoKFsoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikobGlzdEl0ZW0uYWRkcmVzcyksIGtleXNdKTtcbiAgICAgICAgICAgICAgICAgICAgUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmF3VHgucHVzaChhY2Nlc3NMaXN0XzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVzZUVJUDE1NSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gQWRkIGVtcHR5IHYscixzIHZhbHVlcyBmb3IgRUlQMTU1IGxlZ2FjeSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIHJhd1R4LnB1c2goY2hhaW5JZEJ5dGVzKTsgLy8gdiAod2hpY2ggaXMgdGhlIHNhbWUgYXMgY2hhaW5JZCBpbiBFSVAxNTUgdHhzKVxuICAgICAgICAgICAgcmF3VHgucHVzaCgoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikobnVsbCkpOyAvLyByXG4gICAgICAgICAgICByYXdUeC5wdXNoKCgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShudWxsKSk7IC8vIHNcbiAgICAgICAgfVxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDIuIEJVSUxEIFRIRSBMQVRUSUNFIFJFUVVFU1QgUEFZTE9BRFxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBFVEhfVFhfTk9OX0RBVEFfU1ogPSAxMjI7IC8vIEFjY291bnRzIGZvciBtZXRhZGF0YSBhbmQgbm9uLWRhdGEgcGFyYW1zXG4gICAgICAgIHZhciB0eFJlcVBheWxvYWQgPSBCdWZmZXIuYWxsb2MoTUFYX0JBU0VfREFUQV9TWiArIEVUSF9UWF9OT05fREFUQV9TWik7XG4gICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICAvLyAxLiBFSVAxNTUgc3dpdGNoIGFuZCBjaGFpbklEXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQ4KE51bWJlcih1c2VFSVAxNTUpLCBvZmYpO1xuICAgICAgICBvZmYrKztcbiAgICAgICAgLy8gTk9URTogT3JpZ2luYWxseSB3ZSBkZXNpZ25lZCBmb3IgYSAxLWJ5dGUgY2hhaW5JRCwgYnV0IG1vZGVybiByb2xsdXAgY2hhaW5zIHVzZSBtdWNoIGxhcmdlclxuICAgICAgICAvLyBjaGFpbklEIHZhbHVlcy4gVG8gYWNjb3VudCBmb3IgdGhlc2UsIHdlIHdpbGwgcHV0IHRoZSBjaGFpbklEIGludG8gdGhlIGBkYXRhYCBidWZmZXIgaWYgaXRcbiAgICAgICAgLy8gaXMgPj0yNTUuIFZhbHVlcyB1cCB0byBVSU5UNjRfTUFYIHdpbGwgYmUgYWxsb3dlZC5cbiAgICAgICAgdmFyIGNoYWluSWRCdWYgPSB2b2lkIDA7XG4gICAgICAgIHZhciBjaGFpbklkQnVmU3ogPSAwO1xuICAgICAgICBpZiAodXNlQ2hhaW5JZEJ1ZmZlcihjaGFpbklkKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2hhaW5JZEJ1ZiA9IGdldENoYWluSWRCdWYoY2hhaW5JZCk7XG4gICAgICAgICAgICBjaGFpbklkQnVmU3ogPSBjaGFpbklkQnVmLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjaGFpbklkQnVmU3ogPiBjb25zdGFudHNfMS5NQVhfQ0hBSU5fSURfQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFpbklEIHByb3ZpZGVkIGlzIHRvbyBsYXJnZS4nKTtcbiAgICAgICAgICAgIC8vIFNpZ25hbCB0byBMYXR0aWNlIGZpcm13YXJlIHRoYXQgaXQgbmVlZHMgdG8gcmVhZCB0aGUgY2hhaW5JZCBmcm9tIHRoZSB0eC5kYXRhIGJ1ZmZlclxuICAgICAgICAgICAgdHhSZXFQYXlsb2FkLndyaXRlVUludDgoY29uc3RhbnRzXzEuSEFORExFX0xBUkdFUl9DSEFJTl9JRCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIGNoYWluSURzIDwyNTUsIHdyaXRlIGl0IHRvIHRoZSBjaGFpbklkIHU4IHNsb3QgaW4gdGhlIG1haW4gdHggYnVmZmVyXG4gICAgICAgICAgICBjaGFpbklkQnVmID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKGNoYWluSWRCdWYubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgcGFyc2luZyBjaGFpbklEJyk7XG4gICAgICAgICAgICBjaGFpbklkQnVmLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IGNoYWluSWRCdWYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIDIuIFNpZ25lciBQYXRoXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBzaWduZXJQYXRoQnVmID0gKDAsIHV0aWxfMS5idWlsZFNpZ25lclBhdGhCdWYpKHNpZ25lclBhdGgsIFZBUl9QQVRIX1NaKTtcbiAgICAgICAgc2lnbmVyUGF0aEJ1Zi5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IHNpZ25lclBhdGhCdWYubGVuZ3RoO1xuICAgICAgICAvLyAzLiBFVEggVFggcmVxdWVzdCBkYXRhXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGlmIChub25jZUJ5dGVzLmxlbmd0aCA+IDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmNlIHRvbyBsYXJnZScpO1xuICAgICAgICBub25jZUJ5dGVzLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYgKyAoNCAtIG5vbmNlQnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICBpZiAoZ2FzUHJpY2VCeXRlcy5sZW5ndGggPiA4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYXMgcHJpY2UgdG9vIGxhcmdlJyk7XG4gICAgICAgIGdhc1ByaWNlQnl0ZXMuY29weSh0eFJlcVBheWxvYWQsIG9mZiArICg4IC0gZ2FzUHJpY2VCeXRlcy5sZW5ndGgpKTtcbiAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIGlmIChnYXNMaW1pdEJ5dGVzLmxlbmd0aCA+IDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhcyBsaW1pdCB0b28gbGFyZ2UnKTtcbiAgICAgICAgZ2FzTGltaXRCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDQgLSBnYXNMaW1pdEJ5dGVzLmxlbmd0aCkpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgaWYgKHRvQnl0ZXMubGVuZ3RoICE9PSAyMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBgdG9gIGFkZHJlc3MnKTtcbiAgICAgICAgdG9CeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDIwO1xuICAgICAgICBpZiAodmFsdWVCeXRlcy5sZW5ndGggPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgdG9vIGxhcmdlJyk7XG4gICAgICAgIHZhbHVlQnl0ZXMuY29weSh0eFJlcVBheWxvYWQsIG9mZiArICgzMiAtIHZhbHVlQnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgIG9mZiArPSAzMjtcbiAgICAgICAgLy8gRXh0cmEgVHggZGF0YSBjb21lcyBiZWZvcmUgYGRhdGFgIGluIHRoZSBzdHJ1Y3RcbiAgICAgICAgdmFyIFBSRUhBU0hfVU5TVVBQT1JURUQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZ3Q29uc3RhbnRzLmFsbG93ZWRFdGhUeFR5cGVzKSB7XG4gICAgICAgICAgICAvLyBTb21lIHR5cGVzIG1heSBub3QgYmUgc3VwcG9ydGVkIGJ5IGZpcm13YXJlLCBzbyB3ZSB3aWxsIG5lZWQgdG8gcHJlaGFzaFxuICAgICAgICAgICAgaWYgKFBSRUhBU0hfRlJPTV9BQ0NFU1NfTElTVF8xKSB7XG4gICAgICAgICAgICAgICAgUFJFSEFTSF9VTlNVUFBPUlRFRCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OChQUkVIQVNIX1VOU1VQUE9SVEVEID8gMSA6IDAsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgICAgIC8vIEVJUDE1NTkgJiBFSVAyOTMwIHN0cnVjdCB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoaXNFaXAxNTU5KSB7XG4gICAgICAgICAgICAgICAgdHhSZXFQYXlsb2FkLndyaXRlVUludDgoMiwgb2ZmKTtcbiAgICAgICAgICAgICAgICBvZmYgKz0gMTsgLy8gRWlwMTU1OSB0eXBlIGVudW0gdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcy5sZW5ndGggPiA4KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFByaW9yaXR5RmVlUGVyR2FzQnl0ZXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDggLSBtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIG9mZiArPSA4OyAvLyBTa2lwIEVJUDE1NTkgcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0VpcDI5MzApIHtcbiAgICAgICAgICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OCgxLCBvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSAxOyAvLyBFaXAyOTMwIHR5cGUgZW51bSB2YWx1ZVxuICAgICAgICAgICAgICAgIG9mZiArPSA4OyAvLyBTa2lwIEVJUDE1NTkgcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmYgKz0gOTsgLy8gU2tpcCBFSVAxNTU5IGFuZCBFSVAyOTMwIHBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSByZXF1ZXN0cywgd2hpY2ggd2lsbCBmb2xsb3ctdXAgdHJhbnNhY3Rpb24gcmVxdWVzdHMsIGlmIHN1cHBvcnRlZC9hcHBsaWNhYmxlXG4gICAgICAgIHZhciBleHRyYURhdGFQYXlsb2Fkc18xID0gW107XG4gICAgICAgIHZhciBwcmVoYXNoID0gbnVsbDtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBidWZmZXIsIHByZWZpeCB3aXRoIGNoYWluSWQgKGlmIG5lZWRlZCkgYW5kIGFkZCBkYXRhIHNsaWNlXG4gICAgICAgIHZhciBkYXRhU3ogPSBkYXRhQnl0ZXMubGVuZ3RoIHx8IDA7XG4gICAgICAgIHZhciBjaGFpbklkRXh0cmFTeiA9IGNoYWluSWRCdWZTeiA+IDAgPyBjaGFpbklkQnVmU3ogKyAxIDogMDtcbiAgICAgICAgdmFyIGRhdGFUb0NvcHkgPSBCdWZmZXIuYWxsb2MoZGF0YVN6ICsgY2hhaW5JZEV4dHJhU3opO1xuICAgICAgICBpZiAoY2hhaW5JZEV4dHJhU3ogPiAwKSB7XG4gICAgICAgICAgICBkYXRhVG9Db3B5LndyaXRlVUludDgoY2hhaW5JZEJ1ZlN6LCAwKTtcbiAgICAgICAgICAgIGNoYWluSWRCdWYuY29weShkYXRhVG9Db3B5LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhQnl0ZXMuY29weShkYXRhVG9Db3B5LCBjaGFpbklkRXh0cmFTeik7XG4gICAgICAgIGlmIChkYXRhU3ogPiBNQVhfQkFTRV9EQVRBX1NaKSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgc2l6ZXMgYW5kIHJ1biB0aHJvdWdoIHNhbml0eSBjaGVja3NcbiAgICAgICAgICAgIHZhciB0b3RhbFN6ID0gZGF0YVN6ICsgY2hhaW5JZEV4dHJhU3o7XG4gICAgICAgICAgICB2YXIgbWF4U3pBbGxvd2VkID0gTUFYX0JBU0VfREFUQV9TWiArIGV4dHJhRGF0YU1heEZyYW1lcyAqIGV4dHJhRGF0YUZyYW1lU3o7XG4gICAgICAgICAgICBpZiAocHJlaGFzaEFsbG93ZWQgJiYgdG90YWxTeiA+IG1heFN6QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgcGF5bG9hZCBpcyB0b28gbGFyZ2UgdG8gc2VuZCwgYnV0IHRoZSBMYXR0aWNlIGFsbG93cyBhIHByZWhhc2hlZCBtZXNzYWdlLCBkbyB0aGF0XG4gICAgICAgICAgICAgICAgcHJlaGFzaCA9IEJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UocmF3VHgsIHR5cGUpKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFFWFRSQV9EQVRBX0FMTE9XRUQgfHxcbiAgICAgICAgICAgICAgICAgICAgKEVYVFJBX0RBVEFfQUxMT1dFRCAmJiB0b3RhbFN6ID4gbWF4U3pBbGxvd2VkKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBmaWVsZCB0b28gbGFyZ2UgKGdvdCBcIi5jb25jYXQoZGF0YUJ5dGVzLmxlbmd0aCwgXCI7IG11c3QgYmUgPD1cIikuY29uY2F0KG1heFN6QWxsb3dlZCAtIGNoYWluSWRFeHRyYVN6LCBcIiBieXRlcylcIikpO1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IG92ZXJmbG93IGRhdGEgaW50byBleHRyYURhdGEgZnJhbWVzXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lc18xID0gKDAsIHV0aWxfMS5zcGxpdEZyYW1lcykoZGF0YVRvQ29weS5zbGljZShNQVhfQkFTRV9EQVRBX1NaKSwgZXh0cmFEYXRhRnJhbWVTeik7XG4gICAgICAgICAgICAgICAgZnJhbWVzXzEuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN6TEUgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgICAgICAgICAgICAgIHN6TEUud3JpdGVVSW50MzJMRShmcmFtZS5sZW5ndGgsIDApO1xuICAgICAgICAgICAgICAgICAgICBleHRyYURhdGFQYXlsb2Fkc18xLnB1c2goQnVmZmVyLmNvbmNhdChbc3pMRSwgZnJhbWVdKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUFJFSEFTSF9VTlNVUFBPUlRFRCkge1xuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHVuc3VwcG9ydGVkIGluIGZpcm13YXJlIGJ1dCB3ZSB3YW50IHRvIGFsbG93IHN1Y2ggdHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgLy8gd2UgcHJlaGFzaCB0aGUgbWVzc2FnZSBoZXJlLlxuICAgICAgICAgICAgcHJlaGFzaCA9IEJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UocmF3VHgsIHR5cGUpKSwgJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIHRoZSBkYXRhIHNpemUgKGRvZXMgKk5PVCogaW5jbHVkZSB0aGUgY2hhaW5JZCBidWZmZXIsIGlmIHRoYXQgZXhpc3RzKVxuICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50MTZCRShkYXRhQnl0ZXMubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgLy8gQ29weSBpbiB0aGUgY2hhaW5JZCBidWZmZXIgaWYgbmVlZGVkXG4gICAgICAgIGlmIChjaGFpbklkQnVmU3ogPiAwKSB7XG4gICAgICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OChjaGFpbklkQnVmU3osIG9mZik7XG4gICAgICAgICAgICBvZmYrKztcbiAgICAgICAgICAgIGNoYWluSWRCdWYuY29weSh0eFJlcVBheWxvYWQsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gY2hhaW5JZEJ1ZlN6O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvcHkgdGhlIGZpcnN0IHNsaWNlIG9mIHRoZSBkYXRhIGl0c2VsZi4gSWYgdGhpcyBwYXlsb2FkIGhhcyBiZWVuIHByZS1oYXNoZWQsIGluY2x1ZGUgaXRcbiAgICAgICAgLy8gaW4gdGhlIGBkYXRhYCBmaWVsZC4gVGhpcyB3aWxsIHJlc3VsdCBpbiBhIGRpZmZlcmVudCBMYXR0aWNlIHNjcmVlbiBiZWluZyBkcmF3bi5cbiAgICAgICAgaWYgKHByZWhhc2gpIHtcbiAgICAgICAgICAgIHByZWhhc2guY29weSh0eFJlcVBheWxvYWQsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gTUFYX0JBU0VfREFUQV9TWjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFCeXRlcy5zbGljZSgwLCBNQVhfQkFTRV9EQVRBX1NaKS5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSBNQVhfQkFTRV9EQVRBX1NaO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdUeDogcmF3VHgsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgcGF5bG9hZDogdHhSZXFQYXlsb2FkLnNsaWNlKDAsIG9mZiksXG4gICAgICAgICAgICBleHRyYURhdGFQYXlsb2FkczogZXh0cmFEYXRhUGF5bG9hZHNfMSxcbiAgICAgICAgICAgIHNjaGVtYTogcHJvdG9jb2xfMS5MYXR0aWNlU2lnblNjaGVtYS5ldGhlcmV1bSxcbiAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgICAgICAgICB1c2VFSVAxNTU6IHVzZUVJUDE1NSxcbiAgICAgICAgICAgIHNpZ25lclBhdGg6IHNpZ25lclBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbn07XG4vLyBGcm9tIGV0aGVyZXVtanMtdXRpbFxuZnVuY3Rpb24gc3RyaXBaZXJvcyhhKSB7XG4gICAgdmFyIGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbi8vIEdpdmVuIGEgNjQtYnl0ZSBzaWduYXR1cmUgW3Isc10gd2UgbmVlZCB0byBmaWd1cmUgb3V0IHRoZSB2IHZhbHVlXG4vLyBhbmQgYXR0YWggdGhlIGZ1bGwgc2lnbmF0dXJlIHRvIHRoZSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uIHBheWxvYWRcbnZhciBidWlsZEV0aFJhd1R4ID0gZnVuY3Rpb24gKHR4LCBzaWcsIGFkZHJlc3MpIHtcbiAgICAvLyBSTFAtZW5jb2RlIHRoZSBkYXRhIHdlIHNlbnQgdG8gdGhlIGxhdHRpY2VcbiAgICB2YXIgaGFzaCA9IEJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UodHgucmF3VHgsIHR4LnR5cGUpKSwgJ2hleCcpO1xuICAgIHZhciBuZXdTaWcgPSBhZGRSZWNvdmVyeVBhcmFtKGhhc2gsIHNpZywgYWRkcmVzcywgdHgpO1xuICAgIC8vIFVzZSB0aGUgc2lnbmF0dXJlIHRvIGdlbmVyYXRlIGEgbmV3IHJhdyB0cmFuc2FjdGlvbiBwYXlsb2FkXG4gICAgLy8gU3RyaXAgdGhlIGxhc3QgMyBpdGVtcyBhbmQgcmVwbGFjZSB0aGVtIHdpdGggc2lnbmF0dXJlIGNvbXBvbmVudHNcbiAgICB2YXIgbmV3UmF3VHggPSB0eC51c2VFSVAxNTUgPyB0eC5yYXdUeC5zbGljZSgwLCAtMykgOiB0eC5yYXdUeDtcbiAgICBuZXdSYXdUeC5wdXNoKG5ld1NpZy52KTtcbiAgICAvLyBQZXIgYGV0aGVyZXVtanMtdHhgLCBSTFAgZW5jb2Rpbmcgc2hvdWxkIGluY2x1ZGUgc2lnbmF0dXJlIGNvbXBvbmVudHMgdy8gc3RyaXBwZWQgemVyb3NcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL2V0aGVyZXVtanMtdHgvYmxvYi9tYXN0ZXIvc3JjL3RyYW5zYWN0aW9uLnRzI0wxODdcbiAgICBuZXdSYXdUeC5wdXNoKHN0cmlwWmVyb3MobmV3U2lnLnIpKTtcbiAgICBuZXdSYXdUeC5wdXNoKHN0cmlwWmVyb3MobmV3U2lnLnMpKTtcbiAgICB2YXIgcmxwRW5jb2RlZFdpdGhTaWcgPSBCdWZmZXIuZnJvbSgoMCwgcmxwXzEuZW5jb2RlKShuZXdSYXdUeCkpO1xuICAgIGlmICh0eC50eXBlKSB7XG4gICAgICAgIHJscEVuY29kZWRXaXRoU2lnID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBCdWZmZXIuZnJvbShbdHgudHlwZV0pLFxuICAgICAgICAgICAgcmxwRW5jb2RlZFdpdGhTaWcsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4geyByYXdUeDogcmxwRW5jb2RlZFdpdGhTaWcudG9TdHJpbmcoJ2hleCcpLCBzaWdXaXRoVjogbmV3U2lnIH07XG59O1xuLy8gQXR0YWNoIGEgcmVjb3ZlcnkgcGFyYW1ldGVyIHRvIGEgc2lnbmF0dXJlIGJ5IGJydXRlLWZvcmNpbmcgRUNSZWNvdmVyXG5mdW5jdGlvbiBhZGRSZWNvdmVyeVBhcmFtKGhhc2hCdWYsIHNpZywgYWRkcmVzcywgdHhEYXRhKSB7XG4gICAgaWYgKHR4RGF0YSA9PT0gdm9pZCAwKSB7IHR4RGF0YSA9IHt9OyB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gUmVidWlsZCB0aGUga2VjY2FrMjU2IGhhc2ggaGVyZSBzbyB3ZSBjYW4gYGVjcmVjb3ZlcmBcbiAgICAgICAgdmFyIGhhc2hfMiA9IG5ldyBVaW50OEFycmF5KGhhc2hCdWYpO1xuICAgICAgICB2YXIgdiA9IDA7XG4gICAgICAgIC8vIEZpeCBzaWduYXR1cmUgY29tcG9uZW5ldCBsZW5ndGhzIHRvIDMyIGJ5dGVzIGVhY2hcbiAgICAgICAgdmFyIHIgPSAoMCwgdXRpbF8xLmZpeExlbikoc2lnLnIsIDMyKTtcbiAgICAgICAgc2lnLnIgPSByO1xuICAgICAgICB2YXIgcyA9ICgwLCB1dGlsXzEuZml4TGVuKShzaWcucywgMzIpO1xuICAgICAgICBzaWcucyA9IHM7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVjb3ZlcnkgcGFyYW1cbiAgICAgICAgdmFyIHJzID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChbciwgc10pKTtcbiAgICAgICAgdmFyIHB1YmtleSA9IHNlY3AyNTZrMV8xLmRlZmF1bHQuZWNkc2FSZWNvdmVyKHJzLCB2LCBoYXNoXzIsIGZhbHNlKS5zbGljZSgxKTtcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGB2YCB2YWx1ZSBpcyBhIG1hdGNoLCByZXR1cm4gdGhlIHNpZyFcbiAgICAgICAgaWYgKHB1YlRvQWRkclN0cihwdWJrZXkpID09PSBhZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSkge1xuICAgICAgICAgICAgc2lnLnYgPSBnZXRSZWNvdmVyeVBhcmFtKHYsIHR4RGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IHRoZSBvdGhlciBgdmAgdmFsdWVcbiAgICAgICAgdiA9IDE7XG4gICAgICAgIHB1YmtleSA9IHNlY3AyNTZrMV8xLmRlZmF1bHQuZWNkc2FSZWNvdmVyKHJzLCB2LCBoYXNoXzIsIGZhbHNlKS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHB1YlRvQWRkclN0cihwdWJrZXkpID09PSBhZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSkge1xuICAgICAgICAgICAgc2lnLnYgPSBnZXRSZWNvdmVyeVBhcmFtKHYsIHR4RGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbmVpdGhlciBpcyBhIG1hdGNoLCB3ZSBzaG91bGQgcmV0dXJuIGFuIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRXRoZXJldW0gc2lnbmF0dXJlIHJldHVybmVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgfVxufVxuLy8gQ29udmVydCBhbiBSTFAtc2VyaWFsaXplZCB0cmFuc2FjdGlvbiAocGx1cyBzaWduYXR1cmUpIGludG8gYSB0cmFuc2FjdGlvbiBoYXNoXG52YXIgaGFzaFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHNlcmlhbGl6ZWRUeCkge1xuICAgIHJldHVybiAoMCwganNfc2hhM18xLmtlY2NhazI1NikoQnVmZmVyLmZyb20oc2VyaWFsaXplZFR4LCAnaGV4JykpO1xufTtcbi8vIFJldHVybnMgYWRkcmVzcyBzdHJpbmcgZ2l2ZW4gcHVibGljIGtleSBidWZmZXJcbmZ1bmN0aW9uIHB1YlRvQWRkclN0cihwdWIpIHtcbiAgICByZXR1cm4gKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKHB1Yikuc2xpY2UoLTQwKTtcbn1cbi8vIENvbnZlcnQgYSAwLzEgYHZgIGludG8gYSByZWNvdmVyeSBwYXJhbTpcbi8vICogRm9yIG5vbi1FSVAxNTUgdHJhbnNhY3Rpb25zLCByZXR1cm4gYDI3ICsgdmBcbi8vICogRm9yIEVJUDE1NSB0cmFuc2FjdGlvbnMsIHJldHVybiBgKENIQUlOX0lEKjIpICsgMzUgKyB2YFxuZnVuY3Rpb24gZ2V0UmVjb3ZlcnlQYXJhbSh2LCB0eERhdGEpIHtcbiAgICBpZiAodHhEYXRhID09PSB2b2lkIDApIHsgdHhEYXRhID0ge307IH1cbiAgICB2YXIgY2hhaW5JZCA9IHR4RGF0YS5jaGFpbklkLCB1c2VFSVAxNTUgPSB0eERhdGEudXNlRUlQMTU1LCB0eXBlID0gdHhEYXRhLnR5cGU7XG4gICAgLy8gRm9yIEVJUDE1NTkgYW5kIEVJUDI5MzAgdHJhbnNhY3Rpb25zLCB3ZSB3YW50IHRoZSByZWNvdmVyeVBhcmFtICgwIG9yIDEpXG4gICAgLy8gcmF0aGVyIHRoYW4gdGhlIGB2YCB2YWx1ZSBiZWNhdXNlIHRoZSBgY2hhaW5JZGAgaXMgYWxyZWFkeSBpbmNsdWRlZCBpbiB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBwYXlsb2FkLlxuICAgIGlmICh0eXBlID09PSAxIHx8IHR5cGUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKSh2LCB0cnVlKTsgLy8gMCBvciAxLCB3aXRoIDAgZXhwZWN0ZWQgYXMgYW4gZW1wdHkgYnVmZmVyXG4gICAgfVxuICAgIGVsc2UgaWYgKGZhbHNlID09PSB1c2VFSVAxNTUgfHwgY2hhaW5JZCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBGb3IgRVRIIG1lc3NhZ2VzIGFuZCBub24tRUlQMTU1IGNoYWlucyB0aGUgc2V0IHNob3VsZCBiZSBbMjcsIDI4XSBmb3IgYHZgXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh2KS5wbHVzKDI3KS50b1N0cmluZygxNiksICdoZXgnKTtcbiAgICB9XG4gICAgLy8gV2Ugd2lsbCB1c2UgRUlQMTU1IGluIG1vc3QgY2FzZXMuIENvbnZlcnQgdiB0byBhIGJpZ251bSBhbmQgb3BlcmF0ZSBvbiBpdC5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIHByb3RvY29sIGNhbGxzIGZvciB2ID0gKENIQUlOX0lEKjIpICsgMzUvMzYsIHdoZXJlIDM1IG9yIDM2XG4gICAgLy8gaXMgZGVjaWRlZCBvbiBiYXNlZCBvbiB0aGUgZWNyZWNvdmVyIHJlc3VsdC4gYHZgIGlzIHBhc3NlZCBpbiBhcyBlaXRoZXIgMCBvciAxXG4gICAgLy8gc28gd2UgYWRkIDM1IHRvIHRoYXQuXG4gICAgdmFyIGNoYWluSWRCdWYgPSBnZXRDaGFpbklkQnVmKGNoYWluSWQpO1xuICAgIHZhciBjaGFpbklkQk4gPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChjaGFpbklkQnVmLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoXCIweFwiLmNvbmNhdChjaGFpbklkQk4udGltZXMoMikucGx1cygzNSkucGx1cyh2KS50b1N0cmluZygxNikpKTtcbn1cbnZhciBjaGFpbklkcyA9IHtcbiAgICBtYWlubmV0OiAxLFxuICAgIHJvcHRzdGVuOiAzLFxuICAgIHJpbmtlYnk6IDQsXG4gICAga292YW46IDQyLFxuICAgIGdvZXJsaTogNSxcbn07XG4vLyBHZXQgYSBidWZmZXIgY29udGFpbmluZyB0aGUgY2hhaW5JZCB2YWx1ZS5cbi8vIFJldHVybnMgYSAxLCAyLCA0LCBvciA4IGJ5dGUgYnVmZmVyIHdpdGggdGhlIGNoYWluSWQgZW5jb2RlZCBpbiBiaWcgZW5kaWFuXG5mdW5jdGlvbiBnZXRDaGFpbklkQnVmKGNoYWluSWQpIHtcbiAgICB2YXIgYjtcbiAgICAvLyBJZiBvdXIgY2hhaW5JRCBpcyBhIGhleCBzdHJpbmcsIHdlIGNhbiBjb252ZXJ0IGl0IHRvIGEgaGV4XG4gICAgLy8gYnVmZmVyIGRpcmVjdGx5XG4gICAgaWYgKHRydWUgPT09IGlzVmFsaWRDaGFpbklkSGV4TnVtU3RyKGNoYWluSWQpKVxuICAgICAgICBiID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGNoYWluSWQpO1xuICAgIC8vIElmIG91ciBjaGFpbklEIGlzIGEgYmFzZS0xMCBudW1iZXIsIHBhcnNlIHdpdGggYmlnbnVtYmVyLmpzIGFuZCBjb252ZXJ0IHRvIGhleCBidWZmZXJcbiAgICBlbHNlXG4gICAgICAgIGIgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoXCIweFwiLmNvbmNhdChuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChjaGFpbklkKS50b1N0cmluZygxNikpKTtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBpcyBhbiBhbGxvd2VkIHNpemVcbiAgICBpZiAoYi5sZW5ndGggPiA4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYWluSUQgcHJvdmlkZWQgaXMgdG9vIGxhcmdlLicpO1xuICAgIC8vIElmIHRoaXMgbWF0Y2hlcyBhIHUxNiwgdTMyLCBvciB1NjQgc2l6ZSwgcmV0dXJuIGl0IG5vd1xuICAgIGlmIChiLmxlbmd0aCA8PSAyIHx8IGIubGVuZ3RoID09PSA0IHx8IGIubGVuZ3RoID09PSA4KVxuICAgICAgICByZXR1cm4gYjtcbiAgICAvLyBGb3Igb3RoZXIgc2l6ZSBidWZmZXJzLCB3ZSBuZWVkIHRvIHBhY2sgaW50byB1MzIgb3IgdTY0IGJlZm9yZSByZXR1cm5pbmc7XG4gICAgdmFyIGJ1ZjtcbiAgICBpZiAoYi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICBidWYud3JpdGVVSW50MzJCRShjaGFpbklkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYi5sZW5ndGggPD0gOCkge1xuICAgICAgICBidWYgPSBCdWZmZXIuYWxsb2MoOCk7XG4gICAgICAgIGIuY29weShidWYsIDggLSBiLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG4vLyBEZXRlcm1pbmUgaWYgdGhlIGNoYWluIHVzZXMgRUlQMTU1IGJ5IGRlZmF1bHQsIGJhc2VkIG9uIHRoZSBjaGFpbklEXG5mdW5jdGlvbiBjaGFpblVzZXNFSVAxNTUoY2hhaW5JRCkge1xuICAgIHN3aXRjaCAoY2hhaW5JRCkge1xuICAgICAgICBjYXNlIDM6IC8vIHJvcHN0ZW5cbiAgICAgICAgY2FzZSA0OiAvLyByaW5rZWJ5XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgMTogLy8gbWFpbm5ldFxuICAgICAgICBjYXNlIDQyOiAvLyBrb3ZhblxuICAgICAgICBjYXNlIDU6IC8vIGdvZXJsaVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gYWxsIG90aGVycyBzaG91bGQgdXNlIGVpcDE1NVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLy8gRGV0ZXJtaW5lIGlmIGEgdmFsaWQgbnVtYmVyIHdhcyBwYXNzZWQgaW4gYXMgYSBoZXggc3RyaW5nXG5mdW5jdGlvbiBpc1ZhbGlkQ2hhaW5JZEhleE51bVN0cihzKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzLnNsaWNlKDAsIDIpICE9PSAnMHgnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGIgPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChzLCAxNik7XG4gICAgICAgIHJldHVybiBiLmlzTmFOKCkgPT09IGZhbHNlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyBJZiB0aGlzIGlzIGEgbnVibWVyIHRoYXQgZml0cyBpbiBvbmUgYnl0ZSwgd2UgZG9uJ3QgbmVlZCB0byBhZGQgaXRcbi8vIHRvIHRoZSBgZGF0YWAgYnVmZmVyIG9mIHRoZSBtYWluIHRyYW5zYWN0aW9uLlxuLy8gTm90ZSB0aGUgb25lIGVkZ2UgY2FzZTogd2Ugc3RpbGwgbmVlZCB0byB1c2UgdGhlIGBkYXRhYCBmaWVsZCBmb3IgY2hhaW5JRD0yNTUuXG5mdW5jdGlvbiB1c2VDaGFpbklkQnVmZmVyKGlkKSB7XG4gICAgdmFyIGJ1ZiA9IGdldENoYWluSWRCdWYoaWQpO1xuICAgIGlmIChidWYubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50OCgwKSA9PT0gMjU1O1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYnVpbGRQZXJzb25hbFNpZ25SZXF1ZXN0KHJlcSwgaW5wdXQpIHtcbiAgICB2YXIgTUFYX0JBU0VfTVNHX1NaID0gaW5wdXQuZndDb25zdGFudHMuZXRoTWF4TXNnU3o7XG4gICAgdmFyIFZBUl9QQVRIX1NaID0gaW5wdXQuZndDb25zdGFudHMudmFyQWRkclBhdGhTekFsbG93ZWQ7XG4gICAgdmFyIEwgPSAyNCArIE1BWF9CQVNFX01TR19TWiArIDQ7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgcmVxLnBheWxvYWQgPSBCdWZmZXIuYWxsb2MoTCk7XG4gICAgcmVxLnBheWxvYWQud3JpdGVVSW50OChjb25zdGFudHNfMS5ldGhNc2dQcm90b2NvbC5TSUdOX1BFUlNPTkFMLCAwKTtcbiAgICBvZmYgKz0gMTtcbiAgICAvLyBXcml0ZSB0aGUgc2lnbmVyIHBhdGggaW50byB0aGUgYnVmZmVyXG4gICAgdmFyIHNpZ25lclBhdGhCdWYgPSAoMCwgdXRpbF8xLmJ1aWxkU2lnbmVyUGF0aEJ1ZikoaW5wdXQuc2lnbmVyUGF0aCwgVkFSX1BBVEhfU1opO1xuICAgIHNpZ25lclBhdGhCdWYuY29weShyZXEucGF5bG9hZCwgb2ZmKTtcbiAgICBvZmYgKz0gc2lnbmVyUGF0aEJ1Zi5sZW5ndGg7XG4gICAgLy8gV3JpdGUgdGhlIHBheWxvYWQgYnVmZmVyLiBUaGUgcGF5bG9hZCBjYW4gY29tZSBpbiBlaXRoZXIgYXMgYSBidWZmZXIgb3IgYXMgYSBzdHJpbmdcbiAgICB2YXIgcGF5bG9hZCA9IGlucHV0LnBheWxvYWQ7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBoZXggc3RyaW5nXG4gICAgdmFyIGRpc3BsYXlIZXggPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGlucHV0LnBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChpbnB1dC5wYXlsb2FkLnNsaWNlKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGlucHV0LnBheWxvYWQpO1xuICAgICAgICAgICAgZGlzcGxheUhleCA9XG4gICAgICAgICAgICAgICAgZmFsc2UgPT09XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50c18xLkFTQ0lJX1JFR0VYLnRlc3QoQnVmZmVyLmZyb20oaW5wdXQucGF5bG9hZC5zbGljZSgyKSwgJ2hleCcpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZhbHNlID09PSAoMCwgdXRpbF8xLmlzQXNjaWlTdHIpKGlucHV0LnBheWxvYWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5LCB0aGUgTGF0dGljZSBjYW4gb25seSBkaXNwbGF5IEFTQ0lJIHN0cmluZ3MuJyk7XG4gICAgICAgICAgICBwYXlsb2FkID0gQnVmZmVyLmZyb20oaW5wdXQucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0LmRpc3BsYXlIZXggPT09ICdib29sZWFuJykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgYnVmZmVyIGFuZCB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIHdoZXRoZXIgb3Igbm90IHRoaXNcbiAgICAgICAgLy8gaXMgYSBoZXggYnVmZmVyIHdpdGggdGhlIG9wdGlvbmFsIGFyZ3VtZW50LCB3cml0ZSB0aGF0XG4gICAgICAgIGRpc3BsYXlIZXggPSBpbnB1dC5kaXNwbGF5SGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkZXRlcm1pbmUgaWYgdGhpcyBidWZmZXIgaXMgYW4gQVNDSUkgc3RyaW5nLiBJZiBpdCBpcywgc2V0IGBkaXNwbGF5SGV4YCBhY2NvcmRpbmdseS5cbiAgICAgICAgLy8gTk9URTogVEhJUyBNRUFOUyBUSEFUIE5PTi1BU0NJSSBTVFJJTkdTIFdJTEwgRElTUExBWSBBUyBIRVggU0lOQ0UgV0UgQ0FOTk9UIEtOT1cgSUYgVEhFIFJFUVVFU1RFUlxuICAgICAgICAvLyAgICAgICAgRVhQRUNURUQgTk9OLUFTQ0lJIENIQVJBQ1RFUlMgVE8gRElTUExBWSBJTiBBIFNUUklOR1xuICAgICAgICAvLyBUT0RPOiBEZXZlbG9wIGEgbW9yZSBlbGVnYW50IHNvbHV0aW9uIGZvciB0aGlzXG4gICAgICAgIGlmICghaW5wdXQucGF5bG9hZC50b1N0cmluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaW5wdXQgZGF0YSB0eXBlJyk7XG4gICAgICAgIGRpc3BsYXlIZXggPSBmYWxzZSA9PT0gY29uc3RhbnRzXzEuQVNDSUlfUkVHRVgudGVzdChpbnB1dC5wYXlsb2FkLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB2YXIgZndDb25zdCA9IGlucHV0LmZ3Q29uc3RhbnRzO1xuICAgIHZhciBtYXhTekFsbG93ZWQgPSBNQVhfQkFTRV9NU0dfU1ogKyBmd0NvbnN0LmV4dHJhRGF0YU1heEZyYW1lcyAqIGZ3Q29uc3QuZXh0cmFEYXRhRnJhbWVTejtcbiAgICBpZiAoZndDb25zdC5wZXJzb25hbFNpZ25IZWFkZXJTeikge1xuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgcGVyc29uYWxfc2lnbiBoZWFkZXIgc3RyaW5nXG4gICAgICAgIG1heFN6QWxsb3dlZCAtPSBmd0NvbnN0LnBlcnNvbmFsU2lnbkhlYWRlclN6O1xuICAgIH1cbiAgICBpZiAoZndDb25zdC5ldGhNc2dQcmVIYXNoQWxsb3dlZCAmJiBwYXlsb2FkLmxlbmd0aCA+IG1heFN6QWxsb3dlZCkge1xuICAgICAgICAvLyBJZiB0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgZml0IGFuZCBwcmUtaGFzaGluZyBpcyBhbGxvd2VkLCBkbyB0aGF0XG4gICAgICAgIHJlcS5wYXlsb2FkLndyaXRlVUludDgoZGlzcGxheUhleCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgIHJlcS5wYXlsb2FkLndyaXRlVUludDE2TEUocGF5bG9hZC5sZW5ndGgsIG9mZik7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICB2YXIgcHJlaGFzaCA9IEJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtnZXRfcGVyc29uYWxfc2lnbl9wcmVmaXgocGF5bG9hZC5sZW5ndGgpLCBwYXlsb2FkXSkpLCAnaGV4Jyk7XG4gICAgICAgIHByZWhhc2guY29weShyZXEucGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgcmVxLnByZWhhc2ggPSBwcmVoYXNoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiBmaXQgdGhlIHBheWxvYWQuXG4gICAgICAgIC8vIEZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSByZXF1ZXN0cywgd2hpY2ggd2lsbCBmb2xsb3ctdXAgdHJhbnNhY3Rpb24gcmVxdWVzdHMsIGlmIHN1cHBvcnRlZC9hcHBsaWNhYmxlXG4gICAgICAgIHZhciBleHRyYURhdGFQYXlsb2FkcyA9IGdldEV4dHJhRGF0YShwYXlsb2FkLCBpbnB1dCk7XG4gICAgICAgIC8vIFdyaXRlIHRoZSBwYXlsb2FkIGFuZCBtZXRhZGF0YSBpbnRvIG91ciBidWZmZXJcbiAgICAgICAgcmVxLmV4dHJhRGF0YVBheWxvYWRzID0gZXh0cmFEYXRhUGF5bG9hZHM7XG4gICAgICAgIHJlcS5tc2cgPSBwYXlsb2FkO1xuICAgICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQ4KGRpc3BsYXlIZXgsIG9mZik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQxNkxFKHBheWxvYWQubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgcGF5bG9hZC5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xufVxuZnVuY3Rpb24gYnVpbGRFSVA3MTJSZXF1ZXN0KHJlcSwgaW5wdXQpIHtcbiAgICB2YXIgX2EgPSBpbnB1dC5md0NvbnN0YW50cywgZXRoTWF4TXNnU3ogPSBfYS5ldGhNYXhNc2dTeiwgdmFyQWRkclBhdGhTekFsbG93ZWQgPSBfYS52YXJBZGRyUGF0aFN6QWxsb3dlZCwgZWlwNzEyTWF4VHlwZVBhcmFtcyA9IF9hLmVpcDcxMk1heFR5cGVQYXJhbXM7XG4gICAgdmFyIFRZUEVEX0RBVEEgPSBjb25zdGFudHNfMS5ldGhNc2dQcm90b2NvbC5UWVBFRF9EQVRBO1xuICAgIHZhciBMID0gMjQgKyBldGhNYXhNc2dTeiArIDQ7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgcmVxLnBheWxvYWQgPSBCdWZmZXIuYWxsb2MoTCk7XG4gICAgcmVxLnBheWxvYWQud3JpdGVVSW50OChUWVBFRF9EQVRBLmVudW1JZHgsIDApO1xuICAgIG9mZiArPSAxO1xuICAgIC8vIFdyaXRlIHRoZSBzaWduZXIgcGF0aFxuICAgIHZhciBzaWduZXJQYXRoQnVmID0gKDAsIHV0aWxfMS5idWlsZFNpZ25lclBhdGhCdWYpKGlucHV0LnNpZ25lclBhdGgsIHZhckFkZHJQYXRoU3pBbGxvd2VkKTtcbiAgICBzaWduZXJQYXRoQnVmLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gICAgb2ZmICs9IHNpZ25lclBhdGhCdWYubGVuZ3RoO1xuICAgIC8vIFBhcnNlL2NsZWFuIHRoZSBFSVA3MTIgcGF5bG9hZCwgc2VyaWFsaXplIHdpdGggQ0JPUiwgYW5kIHdyaXRlIHRvIHRoZSBwYXlsb2FkXG4gICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0LnBheWxvYWQpKTtcbiAgICBpZiAoIWRhdGEucHJpbWFyeVR5cGUgfHwgIWRhdGEudHlwZXNbZGF0YS5wcmltYXJ5VHlwZV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJpbWFyeVR5cGUgbXVzdCBiZSBzcGVjaWZpZWQgYW5kIHRoZSB0eXBlIG11c3QgYmUgaW5jbHVkZWQuJyk7XG4gICAgaWYgKCFkYXRhLm1lc3NhZ2UgfHwgIWRhdGEuZG9tYWluKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgYW5kIGRvbWFpbiBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICBpZiAoMCA+IE9iamVjdC5rZXlzKGRhdGEudHlwZXMpLmluZGV4T2YoJ0VJUDcxMkRvbWFpbicpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VJUDcxMkRvbWFpbiB0eXBlIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgICAvLyBQYXJzZSB0aGUgcGF5bG9hZCB0byBlbnN1cmUgd2UgaGF2ZSB2YWxpZCBFSVA3MTIgZGF0YSB0eXBlcyBhbmQgdGhhdFxuICAgIC8vIHRoZXkgYXJlIGVuY29kZWQgc3VjaCB0aGF0IExhdHRpY2UgZmlybXdhcmUgY2FuIHBhcnNlIHRoZW0uXG4gICAgLy8gV2UgbmVlZCB0d28gZGlmZmVyZW50IGVuY29kaW5nczogb25lIHRvIHNlbmQgdG8gdGhlIExhdHRpY2UgaW4gYSBmb3JtYXQgdGhhdCBwbGF5c1xuICAgIC8vIG5pY2VseSB3aXRoIG91ciBmaXJtd2FyZSBDQk9SIGRlY29kZXIuIFRoZSBvdGhlciBpcyBmb3JtYXR0ZWQgdG8gYmUgY29uc3VtYWJsZSBieVxuICAgIC8vIG91ciBFSVA3MTIgdmFsaWRhdGlvbiBtb2R1bGUuXG4gICAgaW5wdXQucGF5bG9hZC5tZXNzYWdlID0gcGFyc2VFSVA3MTJNc2coSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLm1lc3NhZ2UpKSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLnByaW1hcnlUeXBlKSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YS50eXBlcykpLCB0cnVlKTtcbiAgICBpbnB1dC5wYXlsb2FkLmRvbWFpbiA9IHBhcnNlRUlQNzEyTXNnKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YS5kb21haW4pKSwgJ0VJUDcxMkRvbWFpbicsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YS50eXBlcykpLCB0cnVlKTtcbiAgICBkYXRhLmRvbWFpbiA9IHBhcnNlRUlQNzEyTXNnKGRhdGEuZG9tYWluLCAnRUlQNzEyRG9tYWluJywgZGF0YS50eXBlcywgZmFsc2UpO1xuICAgIGRhdGEubWVzc2FnZSA9IHBhcnNlRUlQNzEyTXNnKGRhdGEubWVzc2FnZSwgZGF0YS5wcmltYXJ5VHlwZSwgZGF0YS50eXBlcywgZmFsc2UpO1xuICAgIC8vIE5vdyBidWlsZCB0aGUgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSBMYXR0aWNlXG4gICAgdmFyIHBheWxvYWQgPSBCdWZmZXIuZnJvbShib3JjXzEuZGVmYXVsdC5lbmNvZGUoZGF0YSkpO1xuICAgIHZhciBmd0NvbnN0ID0gaW5wdXQuZndDb25zdGFudHM7XG4gICAgdmFyIG1heFN6QWxsb3dlZCA9IGV0aE1heE1zZ1N6ICsgZndDb25zdC5leHRyYURhdGFNYXhGcmFtZXMgKiBmd0NvbnN0LmV4dHJhRGF0YUZyYW1lU3o7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcHJlaGFzaFxuICAgIHZhciBzaG91bGRQcmVoYXNoID0gcGF5bG9hZC5sZW5ndGggPiBtYXhTekFsbG93ZWQ7XG4gICAgT2JqZWN0LmtleXMoZGF0YS50eXBlcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoZGF0YS50eXBlc1trXS5sZW5ndGggPiBlaXA3MTJNYXhUeXBlUGFyYW1zKSB7XG4gICAgICAgICAgICBzaG91bGRQcmVoYXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmd0NvbnN0LmV0aE1zZ1ByZUhhc2hBbGxvd2VkICYmIHNob3VsZFByZWhhc2gpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBzZW5kLCBidXQgdGhlIExhdHRpY2UgYWxsb3dzIGEgcHJlaGFzaGVkIG1lc3NhZ2UsIGRvIHRoYXRcbiAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50MTZMRShwYXlsb2FkLmxlbmd0aCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIHZhciBwcmVoYXNoID0gZXRoX2VpcDcxMl91dGlsX2Jyb3dzZXJfMS5UeXBlZERhdGFVdGlscy5oYXNoKHJlcS5pbnB1dC5wYXlsb2FkKTtcbiAgICAgICAgdmFyIHByZWhhc2hCdWYgPSBCdWZmZXIuZnJvbShwcmVoYXNoKTtcbiAgICAgICAgcHJlaGFzaEJ1Zi5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgICAgICByZXEucHJlaGFzaCA9IHByZWhhc2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZXh0cmFEYXRhUGF5bG9hZHMgPSBnZXRFeHRyYURhdGEocGF5bG9hZCwgaW5wdXQpO1xuICAgICAgICByZXEuZXh0cmFEYXRhUGF5bG9hZHMgPSBleHRyYURhdGFQYXlsb2FkcztcbiAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50MTZMRShwYXlsb2FkLmxlbmd0aCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIHBheWxvYWQuY29weShyZXEucGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IHBheWxvYWQubGVuZ3RoO1xuICAgICAgICAvLyBTbGljZSBvdXQgdGhlIHBhcnQgb2YgdGhlIGJ1ZmZlciB0aGF0IHdlIGRpZG4ndCB1c2UuXG4gICAgICAgIHJlcS5wYXlsb2FkID0gcmVxLnBheWxvYWQuc2xpY2UoMCwgb2ZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbn1cbmZ1bmN0aW9uIGdldEV4dHJhRGF0YShwYXlsb2FkLCBpbnB1dCkge1xuICAgIHZhciBfYSA9IGlucHV0LmZ3Q29uc3RhbnRzLCBldGhNYXhNc2dTeiA9IF9hLmV0aE1heE1zZ1N6LCBleHRyYURhdGFGcmFtZVN6ID0gX2EuZXh0cmFEYXRhRnJhbWVTeiwgZXh0cmFEYXRhTWF4RnJhbWVzID0gX2EuZXh0cmFEYXRhTWF4RnJhbWVzO1xuICAgIHZhciBNQVhfQkFTRV9NU0dfU1ogPSBldGhNYXhNc2dTejtcbiAgICB2YXIgRVhUUkFfREFUQV9BTExPV0VEID0gZXh0cmFEYXRhRnJhbWVTeiA+IDAgJiYgZXh0cmFEYXRhTWF4RnJhbWVzID4gMDtcbiAgICB2YXIgZXh0cmFEYXRhUGF5bG9hZHMgPSBbXTtcbiAgICBpZiAocGF5bG9hZC5sZW5ndGggPiBNQVhfQkFTRV9NU0dfU1opIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpemVzIGFuZCBydW4gdGhyb3VnaCBzYW5pdHkgY2hlY2tzXG4gICAgICAgIHZhciBtYXhTekFsbG93ZWQgPSBNQVhfQkFTRV9NU0dfU1ogKyBleHRyYURhdGFNYXhGcmFtZXMgKiBleHRyYURhdGFGcmFtZVN6O1xuICAgICAgICBpZiAoIUVYVFJBX0RBVEFfQUxMT1dFRClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgbWVzc2FnZSBpcyBcIi5jb25jYXQocGF5bG9hZC5sZW5ndGgsIFwiIGJ5dGVzLCBidXQgY2FuIG9ubHkgYmUgYSBtYXhpbXVtIG9mIFwiKS5jb25jYXQoTUFYX0JBU0VfTVNHX1NaKSk7XG4gICAgICAgIGVsc2UgaWYgKEVYVFJBX0RBVEFfQUxMT1dFRCAmJiBwYXlsb2FkLmxlbmd0aCA+IG1heFN6QWxsb3dlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgbWVzc2FnZSBpcyBcIi5jb25jYXQocGF5bG9hZC5sZW5ndGgsIFwiIGJ5dGVzLCBidXQgY2FuIG9ubHkgYmUgYSBtYXhpbXVtIG9mIFwiKS5jb25jYXQobWF4U3pBbGxvd2VkKSk7XG4gICAgICAgIC8vIFNwbGl0IG92ZXJmbG93IGRhdGEgaW50byBleHRyYURhdGEgZnJhbWVzXG4gICAgICAgIHZhciBmcmFtZXNfMiA9ICgwLCB1dGlsXzEuc3BsaXRGcmFtZXMpKHBheWxvYWQuc2xpY2UoTUFYX0JBU0VfTVNHX1NaKSwgZXh0cmFEYXRhRnJhbWVTeik7XG4gICAgICAgIGZyYW1lc18yLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3pMRSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgIHN6TEUud3JpdGVVSW50MzJMRShmcmFtZS5sZW5ndGgsIDApO1xuICAgICAgICAgICAgZXh0cmFEYXRhUGF5bG9hZHMucHVzaChCdWZmZXIuY29uY2F0KFtzekxFLCBmcmFtZV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBleHRyYURhdGFQYXlsb2Fkcztcbn1cbmZ1bmN0aW9uIHBhcnNlRUlQNzEyTXNnKG1zZywgdHlwZU5hbWUsIHR5cGVzLCBmb3JKU1BhcnNlcikge1xuICAgIGlmIChmb3JKU1BhcnNlciA9PT0gdm9pZCAwKSB7IGZvckpTUGFyc2VyID0gZmFsc2U7IH1cbiAgICB2YXIgdHlwZSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICB0eXBlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlzQXJyYXlUeXBlID0gaXRlbS50eXBlLmluZGV4T2YoJ1snKSA+IC0xO1xuICAgICAgICB2YXIgc2luZ3VsYXJUeXBlID0gaXNBcnJheVR5cGVcbiAgICAgICAgICAgID8gaXRlbS50eXBlLnNsaWNlKDAsIGl0ZW0udHlwZS5pbmRleE9mKCdbJykpXG4gICAgICAgICAgICA6IGl0ZW0udHlwZTtcbiAgICAgICAgdmFyIGlzQ3VzdG9tVHlwZSA9IE9iamVjdC5rZXlzKHR5cGVzKS5pbmRleE9mKHNpbmd1bGFyVHlwZSkgPiAtMTtcbiAgICAgICAgaWYgKGlzQ3VzdG9tVHlwZSAmJiBBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAgICAgICAgIC8vIEZvciBjdXN0b20gdHlwZXMgd2UgbmVlZCB0byBqdW1wIGludG8gdGhlIGBtc2dgIHVzaW5nIHRoZSBrZXkgKG5hbWUgb2YgdHlwZSkgYW5kXG4gICAgICAgICAgICAvLyBwYXJzZSB0aGF0IGVudGlyZSBzdWItc3RydWN0IGFzIGlmIGl0IHdlcmUgYSBtZXNzYWdlLlxuICAgICAgICAgICAgLy8gV2Ugd2lsbCByZWN1cnNlIGludG8gc3ViLXN0cnVjdHMgdW50aWwgd2UgcmVhY2ggYSBsZXZlbCB3aGVyZSBldmVyeSBpdGVtIGlzIGFuXG4gICAgICAgICAgICAvLyBlbGVtZW50YXJ5IChpLmUuIG5vbi1jdXN0b20pIHR5cGUuXG4gICAgICAgICAgICAvLyBGb3IgYXJyYXlzLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBlYWNoIG1lc3NhZ2UgaXRlbS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXNnW2ldW2l0ZW0ubmFtZV0gPSBwYXJzZUVJUDcxMk1zZyhtc2dbaV1baXRlbS5uYW1lXSwgc2luZ3VsYXJUeXBlLCB0eXBlcywgZm9ySlNQYXJzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ3VzdG9tVHlwZSkge1xuICAgICAgICAgICAgLy8gTm90IGFuIGFycmF5IG1lYW5zIHdlIGNhbiBqdW1wIGRpcmVjdGx5IGludG8gdGhlIHN1Yi1zdHJ1Y3QgdG8gY29udmVydFxuICAgICAgICAgICAgbXNnW2l0ZW0ubmFtZV0gPSBwYXJzZUVJUDcxMk1zZyhtc2dbaXRlbS5uYW1lXSwgc2luZ3VsYXJUeXBlLCB0eXBlcywgZm9ySlNQYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhcnJheSBmb3IgdGhpcyBwYXJ0aWN1bGFyIHR5cGUgYW5kIHRoZSB0eXBlIHdlIGFyZSBwYXJzaW5nXG4gICAgICAgICAgICAvLyBpcyAqbm90KiBhIGN1c3RvbSB0eXBlLCBsb29wIHRocm91Z2ggdGhlIGFycmF5IGVsZW1lbnRzIGFuZCBjb252ZXJ0IHRoZSB0eXBlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXlUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgdHlwZSBpcyBpdHNlbGYgYW4gYXJyYXksIGxvb3AgdGhyb3VnaCB0aG9zZSBlbGVtZW50cyBhbmQgcGFyc2UgaW5kaXZpZHVhbGx5LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgbm90IHJlYWNoYWJsZSBmb3IgY3VzdG9tIHR5cGVzIHNvIHdlIGFzc3VtZSB0aGVzZSBhcmUgYXJyYXlzIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRhcnkgdHlwZXMuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbXNnW2ldW2l0ZW0ubmFtZV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tpXVtpdGVtLm5hbWVdW2pdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpXVtpdGVtLm5hbWVdW2pdLCBzaW5ndWxhclR5cGUsIGZvckpTUGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9uLWFycmF5cyBwYXJzZSArIHJlcGxhY2Ugb25lIHZhbHVlIGZvciB0aGUgZWxlbWVudGFyeSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIG1zZ1tpXVtpdGVtLm5hbWVdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpXVtpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIGZvckpTUGFyc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheVR5cGUpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gZWxlbWVudGFyeSBhcnJheSB0eXBlIGFuZCBhIG5vbi1hcnJheSBtZXNzYWdlIGxldmVsLFxuICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggdGhlIGFycmF5IGFuZCBwYXJzZSArIHJlcGxhY2UgIGVhY2ggaXRlbSBpbmRpdmlkdWFsbHkuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZ1tpdGVtLm5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXNnW2l0ZW0ubmFtZV1baV0gPSBwYXJzZUVJUDcxMkl0ZW0obXNnW2l0ZW0ubmFtZV1baV0sIHNpbmd1bGFyVHlwZSwgZm9ySlNQYXJzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHNpbmd1bGFyIGVsZW1lbnRhcnkgdHlwZSwgc2ltcGx5IHBhcnNlICsgcmVwbGFjZS5cbiAgICAgICAgICAgIG1zZ1tpdGVtLm5hbWVdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIGZvckpTUGFyc2VyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtc2c7XG59XG5mdW5jdGlvbiBwYXJzZUVJUDcxMkl0ZW0oZGF0YSwgdHlwZSwgZm9ySlNQYXJzZXIpIHtcbiAgICBpZiAoZm9ySlNQYXJzZXIgPT09IHZvaWQgMCkgeyBmb3JKU1BhcnNlciA9IGZhbHNlOyB9XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgLy8gVmFyaWFibGUgc2l6ZWQgYnl0ZXMgbmVlZCB0byBiZSBidWZmZXIgdHlwZVxuICAgICAgICBkYXRhID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEpO1xuICAgICAgICBpZiAoZm9ySlNQYXJzZXIpIHtcbiAgICAgICAgICAgIC8vIEZvciBFSVA3MTIgZW5jb2RpbmcgbW9kdWxlIGl0J3MgZWFzaWVyIHRvIGVuY29kZSBoZXggc3RyaW5nc1xuICAgICAgICAgICAgZGF0YSA9IFwiMHhcIi5jb25jYXQoZGF0YS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc2xpY2UoMCwgNSkgPT09ICdieXRlcycpIHtcbiAgICAgICAgLy8gRml4ZWQgc2l6ZXMgYnl0ZXMgbmVlZCB0byBiZSBidWZmZXIgdHlwZS4gV2UgYWxzbyBhZGQgc29tZSBzYW5pdHkgY2hlY2tzLlxuICAgICAgICB2YXIgbkJ5dGVzID0gcGFyc2VJbnQodHlwZS5zbGljZSg1KSk7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gbkJ5dGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KHR5cGUsIFwiIHR5cGUsIGJ1dCBnb3QgXCIpLmNvbmNhdChkYXRhLmxlbmd0aCwgXCIgYnl0ZXNcIikpO1xuICAgICAgICBpZiAoZm9ySlNQYXJzZXIpIHtcbiAgICAgICAgICAgIC8vIEZvciBFSVA3MTIgZW5jb2RpbmcgbW9kdWxlIGl0J3MgZWFzaWVyIHRvIGVuY29kZSBoZXggc3RyaW5nc1xuICAgICAgICAgICAgZGF0YSA9IFwiMHhcIi5jb25jYXQoZGF0YS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICAvLyBBZGRyZXNzIG11c3QgYmUgYSAyMCBieXRlIGJ1ZmZlclxuICAgICAgICBkYXRhID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEpO1xuICAgICAgICAvLyBFZGdlIGNhc2UgdG8gaGFuZGxlIHRoZSAwLWFkZHJlc3NcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmFsbG9jKDIwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IDIwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWRkcmVzcyB0eXBlIG11c3QgYmUgMjAgYnl0ZXMsIGJ1dCBnb3QgXCIuY29uY2F0KGRhdGEubGVuZ3RoLCBcIiBieXRlc1wiKSk7XG4gICAgICAgIC8vIEZvciBFSVA3MTIgZW5jb2RpbmcgbW9kdWxlIGl0J3MgZWFzaWVyIHRvIGVuY29kZSBoZXggc3RyaW5nc1xuICAgICAgICBpZiAoZm9ySlNQYXJzZXIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBcIjB4XCIuY29uY2F0KGRhdGEudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjb25zdGFudHNfMS5ldGhNc2dQcm90b2NvbC5UWVBFRF9EQVRBLnR5cGVDb2Rlc1t0eXBlXSAmJlxuICAgICAgICAodHlwZS5pbmRleE9mKCd1aW50JykgPiAtMSB8fCB0eXBlLmluZGV4T2YoJ2ludCcpID4gLTEpKSB7XG4gICAgICAgIHZhciBiID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEpO1xuICAgICAgICAvLyBFZGdlIGNhc2UgdG8gaGFuZGxlIDAtdmFsdWUgYmlnbnVtc1xuICAgICAgICBpZiAoYi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGIgPSBCdWZmZXIuZnJvbSgnMDAnLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVWludDI1NnMgc2hvdWxkIGJlIGVuY29kZWQgYXMgYmlnbnVtcy5cbiAgICAgICAgaWYgKGZvckpTUGFyc2VyKSB7XG4gICAgICAgICAgICAvLyBGb3IgRUlQNzEyIGVuY29kaW5nIGluIHRoaXMgbW9kdWxlIHdlIG5lZWQgc3RyaW5ncyB0byByZXByZXNlbnQgdGhlIG51bWJlcnNcbiAgICAgICAgICAgIGRhdGEgPSBcIjB4XCIuY29uY2F0KGIudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGBiaWdudW1iZXIuanNgIGlzIG5lZWRlZCBmb3IgYGNib3JgIGVuY29kaW5nLCB3aGljaCBnZXRzIHNlbnQgdG8gdGhlIExhdHRpY2UgYW5kIHBsYXlzXG4gICAgICAgICAgICAvLyBuaWNlbHkgd2l0aCBpdHMgZmlybXdhcmUgY2JvciBsaWIuXG4gICAgICAgICAgICAvLyBOT1RFOiBJZiB3ZSBpbnN0YW50aWF0ZSBhIGBiaWdudW1iZXIuanNgIG9iamVjdCwgaXQgd2lsbCBub3QgbWF0Y2ggd2hhdCBgYm9yY2AgY3JlYXRlc1xuICAgICAgICAgICAgLy8gd2hlbiBydW4gaW5zaWRlIG9mIHRoZSBicm93c2VyIChpLmUuIE1ldGFNYXNrKS4gVGh1cyB3ZSBpbnRyb2R1Y2UgdGhpcyBoYWNrIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gd2UgYXJlIGNyZWF0aW5nIGEgY29tcGF0aWJsZSB0eXBlLlxuICAgICAgICAgICAgLy8gVE9ETzogRmluZCBhbm90aGVyIGNib3IgbGliIHRoYXQgaXMgY29tcGF0YWlibGUgd2l0aCB0aGUgZmlybXdhcmUncyBsaWIgaW4gYSBicm93c2VyXG4gICAgICAgICAgICAvLyBjb250ZXh0LiBUaGlzIGlzIHN1cnByaXNpbmdseSBkaWZmaWN1bHQgLSBJIHRyaWVkIHNldmVyYWwgbGlicyBhbmQgb25seSBjYm9yL2JvcmMgaGF2ZVxuICAgICAgICAgICAgLy8gd29ya2VkIChib3JjIGlzIGEgc3VwcG9zZWRseSBcImJyb3dzZXIgY29tcGF0aWJsZVwiIHZlcnNpb24gb2YgY2JvcilcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgYm9yY18xLmRlZmF1bHQuRW5jb2RlcigpLnNlbWFudGljVHlwZXNbMV1bMF0oYi50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgLy8gQm9vbGVhbnMgbmVlZCB0byBiZSBjYXN0IHRvIGEgdThcbiAgICAgICAgZGF0YSA9IGRhdGEgPT09IHRydWUgPyAxIDogMDtcbiAgICB9XG4gICAgLy8gT3RoZXIgdHlwZXMgZG9uJ3QgbmVlZCB0byBiZSBtb2RpZmllZFxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gZ2V0X3BlcnNvbmFsX3NpZ25fcHJlZml4KEwpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXCJcXHUwMDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCIuY29uY2F0KEwudG9TdHJpbmcoKSksICd1dGYtOCcpO1xufVxuZnVuY3Rpb24gZ2V0X3JscF9lbmNvZGVkX3ByZWltYWdlKHJhd1R4LCB0eFR5cGUpIHtcbiAgICBpZiAodHhUeXBlKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbdHhUeXBlXSksIEJ1ZmZlci5mcm9tKCgwLCBybHBfMS5lbmNvZGUpKHJhd1R4KSldKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgcmxwXzEuZW5jb2RlKShyYXdUeCkpO1xuICAgIH1cbn1cbi8vID09PT09PVxuLy8gVEVNUE9SQVJZIEJSSURHRVxuLy8gV2UgYXJlIG1pZ3JhdGluZyBmcm9tIGFsbCBsZWdhY3kgc2lnbmluZyBwYXRocyB0byBhIHNpbmdsZSBnZW5lcmljXG4vLyBzaWduaW5nIHJvdXRlLiBJZiB1c2VycyBhcmUgYXR0ZW1wdGluZyBhIGxlZ2FjeSB0cmFuc2FjdGlvbiByZXF1ZXN0XG4vLyBhZ2FpbnN0IGEgTGF0dGljZSBvbiBmaXJtd2FyZSB2MC4xNS4wIGFuZCBhYm92ZSwgd2UgbmVlZCB0byBjb252ZXJ0XG4vLyB0aGF0IHRvIGEgZ2VuZXJpYyBzaWduaW5nIHJlcXVlc3QuXG4vL1xuLy8gTk9URTogT25jZSB3ZSBkZXByZWNhdGUsIHdlIHdpbGwgcmVtb3ZlIHRoaXMgZW50aXJlIGZpbGVcbi8vID09PT09PVxudmFyIGV0aENvbnZlcnRMZWdhY3lUb0dlbmVyaWNSZXEgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgdmFyIGNvbW1vbjtcbiAgICBpZiAoIXJlcS5jaGFpbklkIHx8ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShyZXEuY2hhaW5JZCkudG9TdHJpbmcoJ2hleCcpID09PSAnMDEnKSB7XG4gICAgICAgIGNvbW1vbiA9IG5ldyBjb21tb25fMS5Db21tb24oeyBjaGFpbjogY29tbW9uXzEuQ2hhaW4uTWFpbm5ldCwgaGFyZGZvcms6IGNvbW1vbl8xLkhhcmRmb3JrLkxvbmRvbiB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vdCBldmVyeSBuZXR3b3JrIHdpbGwgc3VwcG9ydCB0aGVzZSBFSVBzIGJ1dCB3ZSB3aWxsIGFsbG93XG4gICAgICAgIC8vIHNpZ25pbmcgb2YgdHJhbnNhY3Rpb25zIHVzaW5nIHRoZW1cbiAgICAgICAgY29tbW9uID0gY29tbW9uXzEuQ29tbW9uLmN1c3RvbSh7IGNoYWluSWQ6IE51bWJlcihyZXEuY2hhaW5JZCkgfSwgeyBoYXJkZm9yazogY29tbW9uXzEuSGFyZGZvcmsuTG9uZG9uLCBlaXBzOiBbMTU1OSwgMjkzMF0gfSk7XG4gICAgfVxuICAgIHZhciB0eCA9IHR4XzEuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEocmVxLCB7IGNvbW1vbjogY29tbW9uIH0pO1xuICAgIC8vIEdldCB0aGUgcmF3IHRyYW5zYWN0aW9uIHBheWxvYWQgdG8gYmUgaGFzaGVkIGFuZCBzaWduZWQuXG4gICAgLy8gRGlmZmVyZW50IGBAZXRoZXJldW1qcy90eGAgVHJhbnNhY3Rpb24gb2JqZWN0IHR5cGVzIGhhdmVcbiAgICAvLyBzbGlnaHRseSBkaWZmZXJlbnQgQVBJcyBhcm91bmQgdGhpcy5cbiAgICBpZiAocmVxLnR5cGUpIHtcbiAgICAgICAgLy8gTmV3ZXIgdHJhbnNhY3Rpb24gdHlwZXNcbiAgICAgICAgcmV0dXJuIHR4LmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTGVnYWN5IHRyYW5zYWN0aW9uIHR5cGVcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBybHBfMS5lbmNvZGUpKHR4LmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpKSk7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBidWlsZEV0aGVyZXVtTXNnUmVxdWVzdDogYnVpbGRFdGhlcmV1bU1zZ1JlcXVlc3QsXG4gICAgdmFsaWRhdGVFdGhlcmV1bU1zZ1Jlc3BvbnNlOiB2YWxpZGF0ZUV0aGVyZXVtTXNnUmVzcG9uc2UsXG4gICAgYnVpbGRFdGhlcmV1bVR4UmVxdWVzdDogYnVpbGRFdGhlcmV1bVR4UmVxdWVzdCxcbiAgICBidWlsZEV0aFJhd1R4OiBidWlsZEV0aFJhd1R4LFxuICAgIGhhc2hUcmFuc2FjdGlvbjogaGFzaFRyYW5zYWN0aW9uLFxuICAgIGNoYWluSWRzOiBjaGFpbklkcyxcbiAgICBlbnN1cmVIZXhCdWZmZXI6IHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIsXG4gICAgZXRoQ29udmVydExlZ2FjeVRvR2VuZXJpY1JlcTogZXRoQ29udmVydExlZ2FjeVRvR2VuZXJpY1JlcSxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZUFkZEt2UmVjb3Jkc1JlcXVlc3QgPSBleHBvcnRzLnZhbGlkYXRlQWRkS3ZSZXF1ZXN0ID0gZXhwb3J0cy5hZGRLdlJlY29yZHMgPSB2b2lkIDA7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ZhbGlkYXRvcnNcIik7XG4vKipcbiAqIGBhZGRLdlJlY29yZHNgIHRha2VzIGluIGEgc2V0IG9mIGtleS12YWx1ZSByZWNvcmRzIGFuZCBzZW5kcyBhIHJlcXVlc3QgdG8gYWRkIHRoZW0gdG8gdGhlXG4gKiBMYXR0aWNlLlxuICogQGNhdGVnb3J5IExhdHRpY2VcbiAqIEByZXR1cm5zIEEgY2FsbGJhY2sgd2l0aCBhbiBlcnJvciBvciBudWxsLlxuICovXG5mdW5jdGlvbiBhZGRLdlJlY29yZHMoX2EpIHtcbiAgICB2YXIgY2xpZW50ID0gX2EuY2xpZW50LCByZWNvcmRzID0gX2EucmVjb3JkcywgdHlwZSA9IF9hLnR5cGUsIGNhc2VTZW5zaXRpdmUgPSBfYS5jYXNlU2Vuc2l0aXZlO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCB1cmwsIHNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cywgZGF0YSwgX2MsIGRlY3J5cHRlZERhdGEsIG5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50KShjbGllbnQpLCB1cmwgPSBfYi51cmwsIHNoYXJlZFNlY3JldCA9IF9iLnNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViID0gX2IuZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cyA9IF9iLmZ3Q29uc3RhbnRzO1xuICAgICAgICAgICAgICAgICAgICAoMCwgZXhwb3J0cy52YWxpZGF0ZUFkZEt2UmVxdWVzdCkoeyByZWNvcmRzOiByZWNvcmRzLCBmd0NvbnN0YW50czogZndDb25zdGFudHMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoMCwgZXhwb3J0cy5lbmNvZGVBZGRLdlJlY29yZHNSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzOiByZWNvcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmd0NvbnN0YW50czogZndDb25zdGFudHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvdG9jb2xfMS5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcHJvdG9jb2xfMS5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuYWRkS3ZSZWNvcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBfZC5zZW50KCksIGRlY3J5cHRlZERhdGEgPSBfYy5kZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIgPSBfYy5uZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBuZXdFcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGVjcnlwdGVkRGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hZGRLdlJlY29yZHMgPSBhZGRLdlJlY29yZHM7XG52YXIgdmFsaWRhdGVBZGRLdlJlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcmVjb3JkcyA9IF9hLnJlY29yZHMsIGZ3Q29uc3RhbnRzID0gX2EuZndDb25zdGFudHM7XG4gICAgKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZUt2UmVjb3JkcykocmVjb3JkcywgZndDb25zdGFudHMpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVBZGRLdlJlcXVlc3QgPSB2YWxpZGF0ZUFkZEt2UmVxdWVzdDtcbnZhciBlbmNvZGVBZGRLdlJlY29yZHNSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHJlY29yZHMgPSBfYS5yZWNvcmRzLCB0eXBlID0gX2EudHlwZSwgY2FzZVNlbnNpdGl2ZSA9IF9hLmNhc2VTZW5zaXRpdmUsIGZ3Q29uc3RhbnRzID0gX2EuZndDb25zdGFudHM7XG4gICAgdmFyIHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoMSArIDEzOSAqIGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKTtcbiAgICBwYXlsb2FkLndyaXRlVUludDgoT2JqZWN0LmtleXMocmVjb3JkcykubGVuZ3RoLCAwKTtcbiAgICB2YXIgb2ZmID0gMTtcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2tleSA9IF9hWzBdLCBfdmFsID0gX2FbMV07XG4gICAgICAgIHZhciBfYiA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVLdlJlY29yZCkoeyBrZXk6IF9rZXksIHZhbDogX3ZhbCB9LCBmd0NvbnN0YW50cyksIGtleSA9IF9iLmtleSwgdmFsID0gX2IudmFsO1xuICAgICAgICAvLyBTa2lwIHRoZSBJRCBwb3J0aW9uLiBUaGlzIHdpbGwgZ2V0IGFkZGVkIGJ5IGZpcm13YXJlLlxuICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoMCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRSh0eXBlLCBvZmYpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KGNhc2VTZW5zaXRpdmUgPyAxIDogMCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50OChTdHJpbmcoa2V5KS5sZW5ndGggKyAxLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgQnVmZmVyLmZyb20oU3RyaW5nKGtleSkpLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IGZ3Q29uc3RhbnRzLmt2S2V5TWF4U3RyU3ogKyAxO1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDgoU3RyaW5nKHZhbCkubGVuZ3RoICsgMSwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgIEJ1ZmZlci5mcm9tKFN0cmluZyh2YWwpKS5jb3B5KHBheWxvYWQsIG9mZik7XG4gICAgICAgIG9mZiArPSBmd0NvbnN0YW50cy5rdlZhbE1heFN0clN6ICsgMTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5leHBvcnRzLmVuY29kZUFkZEt2UmVjb3Jkc1JlcXVlc3QgPSBlbmNvZGVBZGRLdlJlY29yZHNSZXF1ZXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVDb25uZWN0UmVzcG9uc2UgPSBleHBvcnRzLnZhbGlkYXRlQ29ubmVjdFJlcXVlc3QgPSBleHBvcnRzLmNvbm5lY3QgPSB2b2lkIDA7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ByZWRpY2F0ZXNcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3V0aWxpdGllc1wiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ZhbGlkYXRvcnNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBjb25uZWN0KF9hKSB7XG4gICAgdmFyIGNsaWVudCA9IF9hLmNsaWVudCwgaWQgPSBfYS5pZDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYiwgZGV2aWNlSWQsIGtleSwgYmFzZVVybCwgdXJsLCByZXNwUGF5bG9hZERhdGEsIF9jLCBpc1BhaXJlZCwgZndWZXJzaW9uLCBhY3RpdmVXYWxsZXRzLCBlcGhlbWVyYWxQdWI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9iID0gKDAsIGV4cG9ydHMudmFsaWRhdGVDb25uZWN0UmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjbGllbnQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogY2xpZW50LmJhc2VVcmwsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBkZXZpY2VJZCA9IF9iLmRldmljZUlkLCBrZXkgPSBfYi5rZXksIGJhc2VVcmwgPSBfYi5iYXNlVXJsO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChiYXNlVXJsLCBcIi9cIikuY29uY2F0KGRldmljZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3RvY29sXzEuY29ubmVjdFNlY3VyZVJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IGNsaWVudC5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwUGF5bG9hZERhdGEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBleHBvcnRzLmRlY29kZUNvbm5lY3RSZXNwb25zZSkocmVzcFBheWxvYWREYXRhLCBrZXkpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2Quc2VudCgpLCBpc1BhaXJlZCA9IF9jLmlzUGFpcmVkLCBmd1ZlcnNpb24gPSBfYy5md1ZlcnNpb24sIGFjdGl2ZVdhbGxldHMgPSBfYy5hY3RpdmVXYWxsZXRzLCBlcGhlbWVyYWxQdWIgPSBfYy5lcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjbGllbnQgc3RhdGUgd2l0aCByZXNwb25zZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IGRldmljZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFpcmVkOiBpc1BhaXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ3VmVyc2lvbjogZndWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlV2FsbGV0czogYWN0aXZlV2FsbGV0cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlzUGFpcmVkICYmICEoMCwgcHJlZGljYXRlc18xLmRvZXNGZXRjaFdhbGxldHNPbkxvYWQpKGNsaWVudC5nZXRGd1ZlcnNpb24oKSkpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY2xpZW50LmZldGNoQWN0aXZlV2FsbGV0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgd2UgYXJlIHBhaXJlZCBvciBub3QuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlICpub3QqIGFscmVhZHkgcGFpcmVkLCB0aGUgTGF0dGljZSBpcyBub3cgaW5cbiAgICAgICAgICAgICAgICAvLyBwYWlyaW5nIG1vZGUgYW5kIGV4cGVjdHMgYSBgZmluYWxpemVQYWlyaW5nYCBlbmNyeXB0ZWRcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGFzIGEgZm9sbG93IHVwLlxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpc1BhaXJlZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcbnZhciB2YWxpZGF0ZUNvbm5lY3RSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGRldmljZUlkID0gX2EuZGV2aWNlSWQsIGtleSA9IF9hLmtleSwgYmFzZVVybCA9IF9hLmJhc2VVcmw7XG4gICAgdmFyIHZhbGlkRGV2aWNlSWQgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlRGV2aWNlSWQpKGRldmljZUlkKTtcbiAgICB2YXIgdmFsaWRLZXkgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlS2V5KShrZXkpO1xuICAgIHZhciB2YWxpZEJhc2VVcmwgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlQmFzZVVybCkoYmFzZVVybCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGV2aWNlSWQ6IHZhbGlkRGV2aWNlSWQsXG4gICAgICAgIGtleTogdmFsaWRLZXksXG4gICAgICAgIGJhc2VVcmw6IHZhbGlkQmFzZVVybCxcbiAgICB9O1xufTtcbmV4cG9ydHMudmFsaWRhdGVDb25uZWN0UmVxdWVzdCA9IHZhbGlkYXRlQ29ubmVjdFJlcXVlc3Q7XG4vKipcbiAqIGBkZWNvZGVDb25uZWN0UmVzcG9uc2VgIHdpbGwgY2FsbCBgU3RhcnRQYWlyaW5nTW9kZWAgb24gdGhlIGRldmljZSwgd2hpY2ggZ2l2ZXMgdGhlIHVzZXIgNjAgc2Vjb25kcyB0b1xuICogZmluYWxpemUgdGhlIHBhaXJpbmcuIFRoaXMgd2lsbCByZXR1cm4gYW4gZXBoZW1lcmFsIHB1YmxpYyBrZXksIHdoaWNoIGlzIG5lZWRlZCBmb3IgdGhlIG5leHRcbiAqIHJlcXVlc3QuXG4gKiAtIElmIHRoZSBkZXZpY2UgaXMgYWxyZWFkeSBwYWlyZWQsIHRoaXMgZXBoZW1QdWIgaXMgc2ltcGx5IHVzZWQgdG8gZW5jcnlwdCB0aGUgbmV4dCByZXF1ZXN0LlxuICogLSBJZiB0aGUgZGV2aWNlIGlzIG5vdCBwYWlyZWQsIGl0IGlzIG5lZWRlZCB0byBwYWlyIHRoZSBkZXZpY2Ugd2l0aGluIDYwIHNlY29uZHMuXG4gKiBAY2F0ZWdvcnkgRGV2aWNlIFJlc3BvbnNlXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIHRydWUgaWYgd2UgYXJlIHBhaXJlZCB0byB0aGUgZGV2aWNlIGFscmVhZHlcbiAqL1xudmFyIGRlY29kZUNvbm5lY3RSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSwga2V5KSB7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGlzUGFpcmVkID0gcmVzcG9uc2UucmVhZFVJbnQ4KG9mZikgPT09IHByb3RvY29sXzEuUHJvdG9jb2xDb25zdGFudHMucGFpcmluZ1N0YXR1cy5wYWlyZWQ7XG4gICAgb2ZmKys7XG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgcGFpcmVkLCB3ZSBnZXQgdGhlIG5leHQgZXBoZW1lcmFsIGtleVxuICAgIHZhciBwdWIgPSByZXNwb25zZS5zbGljZShvZmYsIG9mZiArIDY1KS50b1N0cmluZygnaGV4Jyk7XG4gICAgb2ZmICs9IDY1OyAvLyBTZXQgdGhlIHB1YmxpYyBrZXlcbiAgICB2YXIgZXBoZW1lcmFsUHViID0gKDAsIHV0aWxfMS5nZXRQMjU2S2V5UGFpckZyb21QdWIpKHB1Yik7XG4gICAgLy8gR3JhYiB0aGUgZmlybXdhcmUgdmVyc2lvbiAod2lsbCBiZSAwLWxlbmd0aCBmb3Igb2xkZXIgZncgdmVyc2lvbnMpIEl0IGlzIG9mIGZvcm1hdFxuICAgIC8vIHxmaXh8bWlub3J8bWFqb3J8cmVzZXJ2ZWR8XG4gICAgdmFyIGZ3VmVyc2lvbiA9IHJlc3BvbnNlLnNsaWNlKG9mZiwgb2ZmICsgNCk7XG4gICAgb2ZmICs9IDQ7XG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgcGFpcmVkLCB0aGUgcmVzcG9uc2Ugd2lsbCBpbmNsdWRlIHNvbWUgZW5jcnlwdGVkIGRhdGEgYWJvdXQgdGhlIGN1cnJlbnRcbiAgICAvLyB3YWxsZXRzIFRoaXMgZGF0YSB3YXMgYWRkZWQgaW4gTGF0dGljZSBmaXJtd2FyZSB2MC4xNC4xXG4gICAgaWYgKGlzUGFpcmVkKSB7XG4gICAgICAgIC8vVE9ETyAmJiB0aGlzLl9md1ZlcnNpb25HVEUoMCwgMTQsIDEpKSB7XG4gICAgICAgIC8vIExhdGVyIHZlcnNpb25zIG9mIGZpcm13YXJlIGFkZGVkIHdhbGxldCBpbmZvXG4gICAgICAgIHZhciBlbmNXYWxsZXREYXRhID0gcmVzcG9uc2Uuc2xpY2Uob2ZmLCBvZmYgKyAxNjApO1xuICAgICAgICBvZmYgKz0gMTYwO1xuICAgICAgICB2YXIgc2hhcmVkU2VjcmV0ID0gKDAsIHV0aWxpdGllc18xLmdldFNoYXJlZFNlY3JldCkoa2V5LCBlcGhlbWVyYWxQdWIpO1xuICAgICAgICB2YXIgZGVjV2FsbGV0RGF0YSA9ICgwLCB1dGlsXzEuYWVzMjU2X2RlY3J5cHQpKGVuY1dhbGxldERhdGEsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgIC8vIFNhbml0eSBjaGVjayB0byBtYWtlIHN1cmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgZGVjcnlwdGVkIGRhdGEgaXMgZW1wdHkuIFRoZSBsYXN0IDIgYnl0ZXNcbiAgICAgICAgLy8gYXJlIEFFUyBwYWRkaW5nXG4gICAgICAgIGlmIChkZWNXYWxsZXREYXRhW2RlY1dhbGxldERhdGEubGVuZ3RoIC0gMl0gIT09IDAgfHxcbiAgICAgICAgICAgIGRlY1dhbGxldERhdGFbZGVjV2FsbGV0RGF0YS5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byBMYXR0aWNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3RpdmVXYWxsZXRzID0gKDAsIHV0aWxpdGllc18xLnBhcnNlV2FsbGV0cykoZGVjV2FsbGV0RGF0YSk7XG4gICAgICAgIHJldHVybiB7IGlzUGFpcmVkOiBpc1BhaXJlZCwgZndWZXJzaW9uOiBmd1ZlcnNpb24sIGFjdGl2ZVdhbGxldHM6IGFjdGl2ZVdhbGxldHMsIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViIH07XG4gICAgfVxuICAgIC8vIHJldHVybiB0aGUgc3RhdGUgb2Ygb3VyIHBhaXJpbmdcbiAgICByZXR1cm4geyBpc1BhaXJlZDogaXNQYWlyZWQsIGZ3VmVyc2lvbjogZndWZXJzaW9uLCBhY3RpdmVXYWxsZXRzOiB1bmRlZmluZWQsIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViIH07XG59O1xuZXhwb3J0cy5kZWNvZGVDb25uZWN0UmVzcG9uc2UgPSBkZWNvZGVDb25uZWN0UmVzcG9uc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUZldGNoQWN0aXZlV2FsbGV0UmVzcG9uc2UgPSBleHBvcnRzLmZldGNoQWN0aXZlV2FsbGV0ID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4uL3Byb3RvY29sXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbi8qKlxuICogRmV0Y2ggdGhlIGFjdGl2ZSB3YWxsZXQgaW4gdGhlIGRldmljZS5cbiAqXG4gKiBUaGUgTGF0dGljZSBoYXMgdHdvIHdhbGxldCBpbnRlcmZhY2VzOiBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwuIElmIGEgU2FmZUNhcmQgaXMgaW5zZXJ0ZWQgYW5kXG4gKiB1bmxvY2tlZCwgdGhlIGV4dGVybmFsIGludGVyZmFjZSBpcyBjb25zaWRlcmVkIFwiYWN0aXZlXCIgYW5kIHRoaXMgd2lsbCByZXR1cm4gaXRzIHtAbGluayBXYWxsZXR9XG4gKiBkYXRhLiBPdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gdGhlIGluZm8gZm9yIHRoZSBpbnRlcm5hbCBMYXR0aWNlIHdhbGxldC5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hBY3RpdmVXYWxsZXQoX2EpIHtcbiAgICB2YXIgY2xpZW50ID0gX2EuY2xpZW50O1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCB1cmwsIHNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViLCBfYywgZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViLCBhY3RpdmVXYWxsZXRzLCB2YWxpZEFjdGl2ZVdhbGxldHM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9iID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZUNvbm5lY3RlZENsaWVudCkoY2xpZW50KSwgdXJsID0gX2IudXJsLCBzaGFyZWRTZWNyZXQgPSBfYi5zaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiA9IF9iLmVwaGVtZXJhbFB1YjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3RvY29sXzEuZW5jcnlwdGVkU2VjdXJlUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcHJvdG9jb2xfMS5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0V2FsbGV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTZWNyZXQ6IHNoYXJlZFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IGVwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2Quc2VudCgpLCBkZWNyeXB0ZWREYXRhID0gX2MuZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViID0gX2MubmV3RXBoZW1lcmFsUHViO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVXYWxsZXRzID0gKDAsIGV4cG9ydHMuZGVjb2RlRmV0Y2hBY3RpdmVXYWxsZXRSZXNwb25zZSkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkQWN0aXZlV2FsbGV0cyA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVBY3RpdmVXYWxsZXRzKShhY3RpdmVXYWxsZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IG5ld0VwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVdhbGxldHM6IHZhbGlkQWN0aXZlV2FsbGV0cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2YWxpZEFjdGl2ZVdhbGxldHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hBY3RpdmVXYWxsZXQgPSBmZXRjaEFjdGl2ZVdhbGxldDtcbnZhciBkZWNvZGVGZXRjaEFjdGl2ZVdhbGxldFJlc3BvbnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBSZWFkIHRoZSBleHRlcm5hbCB3YWxsZXQgZGF0YSBmaXJzdC4gSWYgaXQgaXMgbm9uLW51bGwsIHRoZSBleHRlcm5hbCB3YWxsZXQgd2lsbCBiZSB0aGVcbiAgICAvLyBhY3RpdmUgd2FsbGV0IG9mIHRoZSBkZXZpY2UgYW5kIHdlIHNob3VsZCBzYXZlIGl0LiBJZiB0aGUgZXh0ZXJuYWwgd2FsbGV0IGlzIGJsYW5rLCBpdCBtZWFuc1xuICAgIC8vIHRoZXJlIGlzIG5vIGNhcmQgcHJlc2VudCBhbmQgd2Ugc2hvdWxkIHNhdmUgYW5kIHVzZSB0aGUgaW50ZXJhbCB3YWxsZXQuIElmIGJvdGggd2FsbGV0cyBhcmVcbiAgICAvLyBlbXB0eSwgaXQgbWVhbnMgdGhlIGRldmljZSBzdGlsbCBuZWVkcyB0byBiZSBzZXQgdXAuXG4gICAgdmFyIHdhbGxldERlc2NyaXB0b3JMZW4gPSA3MTtcbiAgICAvLyBJbnRlcm5hbCBmaXJzdFxuICAgIHZhciBhY3RpdmVXYWxsZXRzID0ge1xuICAgICAgICBpbnRlcm5hbDoge1xuICAgICAgICAgICAgdWlkOiBjb25zdGFudHNfMS5FTVBUWV9XQUxMRVRfVUlELFxuICAgICAgICAgICAgZXh0ZXJuYWw6IGZhbHNlLFxuICAgICAgICAgICAgbmFtZTogQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiAwLFxuICAgICAgICB9LFxuICAgICAgICBleHRlcm5hbDoge1xuICAgICAgICAgICAgdWlkOiBjb25zdGFudHNfMS5FTVBUWV9XQUxMRVRfVUlELFxuICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICBuYW1lOiBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IDAsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBhY3RpdmVXYWxsZXRzLmludGVybmFsLnVpZCA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAzMik7XG4gICAgYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC5jYXBhYmlsaXRpZXMgPSBkYXRhLnJlYWRVSW50MzJCRShvZmYgKyAzMik7XG4gICAgYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC5uYW1lID0gZGF0YS5zbGljZShvZmYgKyAzNiwgb2ZmICsgd2FsbGV0RGVzY3JpcHRvckxlbik7XG4gICAgLy8gT2Zmc2V0IHRoZSBmaXJzdCBpdGVtXG4gICAgb2ZmICs9IHdhbGxldERlc2NyaXB0b3JMZW47XG4gICAgLy8gRXh0ZXJuYWxcbiAgICBhY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZCA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAzMik7XG4gICAgYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5jYXBhYmlsaXRpZXMgPSBkYXRhLnJlYWRVSW50MzJCRShvZmYgKyAzMik7XG4gICAgYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5uYW1lID0gZGF0YS5zbGljZShvZmYgKyAzNiwgb2ZmICsgd2FsbGV0RGVzY3JpcHRvckxlbik7XG4gICAgcmV0dXJuIGFjdGl2ZVdhbGxldHM7XG59O1xuZXhwb3J0cy5kZWNvZGVGZXRjaEFjdGl2ZVdhbGxldFJlc3BvbnNlID0gZGVjb2RlRmV0Y2hBY3RpdmVXYWxsZXRSZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlRmV0Y2hFbmNEYXRhID0gZXhwb3J0cy5lbmNvZGVGZXRjaEVuY0RhdGFSZXF1ZXN0ID0gZXhwb3J0cy52YWxpZGF0ZUZldGNoRW5jRGF0YVJlcXVlc3QgPSBleHBvcnRzLmZldGNoRW5jRGF0YSA9IHZvaWQgMDtcbi8qKlxuICogRXhwb3J0IGVuY3J5cHRlZCBkYXRhIGZyb20gdGhlIExhdHRpY2UuIERhdGEgbXVzdCBjb25mb3JtXG4gKiB0byBrbm93biBzY2hlbWEsIGUuZy4gRUlQMjMzNSBkZXJpdmVkIHByaXZrZXkgZXhwb3J0LlxuICovXG52YXIgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi4vcHJvdG9jb2xcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3V0aWxpdGllc1wiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ZhbGlkYXRvcnNcIik7XG52YXIgRU5DX0RBVEEgPSBjb25zdGFudHNfMS5FWFRFUk5BTC5FTkNfREFUQTtcbnZhciBFTkNfREFUQV9FUlJfU1RSID0gJ1Vua25vd24gZW5jcnlwdGVkIGRhdGEgZXhwb3J0IHR5cGUgcmVxdWVzdGVkLiBFeGl0aW5nLic7XG52YXIgRU5DX0RBVEFfUkVRX0RBVEFfU1ogPSAxMDI1O1xudmFyIEVOQ19EQVRBX1JFU1BfU1ogPSB7XG4gICAgRUlQMjMzNToge1xuICAgICAgICBDSVBIRVJURVhUOiAzMixcbiAgICAgICAgU0FMVDogMzIsXG4gICAgICAgIENIRUNLU1VNOiAzMixcbiAgICAgICAgSVY6IDE2LFxuICAgICAgICBQVUJLRVk6IDQ4LFxuICAgIH0sXG59O1xuZnVuY3Rpb24gZmV0Y2hFbmNEYXRhKF9hKSB7XG4gICAgdmFyIGNsaWVudCA9IF9hLmNsaWVudCwgc2NoZW1hID0gX2Euc2NoZW1hLCBwYXJhbXMgPSBfYS5wYXJhbXM7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2IsIHVybCwgc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIsIGZ3VmVyc2lvbiwgYWN0aXZlV2FsbGV0LCBkYXRhLCBfYywgZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYiA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVDb25uZWN0ZWRDbGllbnQpKGNsaWVudCksIHVybCA9IF9iLnVybCwgc2hhcmVkU2VjcmV0ID0gX2Iuc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIgPSBfYi5lcGhlbWVyYWxQdWIsIGZ3VmVyc2lvbiA9IF9iLmZ3VmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlV2FsbGV0ID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZVdhbGxldCkoY2xpZW50LmdldEFjdGl2ZVdhbGxldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMudmFsaWRhdGVGZXRjaEVuY0RhdGFSZXF1ZXN0KSh7IHBhcmFtczogcGFyYW1zIH0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gKDAsIGV4cG9ydHMuZW5jb2RlRmV0Y2hFbmNEYXRhUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ3VmVyc2lvbjogZndWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlV2FsbGV0OiBhY3RpdmVXYWxsZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvdG9jb2xfMS5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcHJvdG9jb2xfMS5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZmV0Y2hFbmNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBfZC5zZW50KCksIGRlY3J5cHRlZERhdGEgPSBfYy5kZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIgPSBfYy5uZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBuZXdFcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGV4cG9ydHMuZGVjb2RlRmV0Y2hFbmNEYXRhKSh7IGRhdGE6IGRlY3J5cHRlZERhdGEsIHNjaGVtYTogc2NoZW1hLCBwYXJhbXM6IHBhcmFtcyB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEVuY0RhdGEgPSBmZXRjaEVuY0RhdGE7XG52YXIgdmFsaWRhdGVGZXRjaEVuY0RhdGFSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBhcmFtcyA9IF9hLnBhcmFtcztcbiAgICAvLyBWYWxpZGF0ZSBkZXJpdmF0aW9uIHBhdGhcbiAgICAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlU3RhcnRQYXRoKShwYXJhbXMucGF0aCk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZUZldGNoRW5jRGF0YVJlcXVlc3QgPSB2YWxpZGF0ZUZldGNoRW5jRGF0YVJlcXVlc3Q7XG52YXIgZW5jb2RlRmV0Y2hFbmNEYXRhUmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzY2hlbWEgPSBfYS5zY2hlbWEsIHBhcmFtcyA9IF9hLnBhcmFtcywgZndWZXJzaW9uID0gX2EuZndWZXJzaW9uLCBhY3RpdmVXYWxsZXQgPSBfYS5hY3RpdmVXYWxsZXQ7XG4gICAgLy8gQ2hlY2sgZmlybXdhcmUgdmVyc2lvblxuICAgIGlmIChmd1ZlcnNpb24ubWFqb3IgPCAxICYmIGZ3VmVyc2lvbi5taW5vciA8IDE3KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlybXdhcmUgdmVyc2lvbiA+PXYwLjE3LjAgaXMgcmVxdWlyZWQgZm9yIGVuY3J5cHRlZCBkYXRhIGV4cG9ydC4nKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHBhcmFtcyBkZXBlbmRpbmcgb24gd2hhdCB0eXBlIG9mIGRhdGEgaXMgYmVpbmcgZXhwb3J0ZWRcbiAgICBpZiAoc2NoZW1hID09PSBFTkNfREFUQS5TQ0hFTUFTLkJMU19LRVlTVE9SRV9FSVAyMzM1X1BCS0RGX1Y0KSB7XG4gICAgICAgIC8vIFNldCB0aGUgd2FsbGV0IFVJRCB0byB0aGUgY2xpZW50J3MgY3VycmVudCBhY3RpdmUgd2FsbGV0XG4gICAgICAgIHBhcmFtcy53YWxsZXRVSUQgPSBhY3RpdmVXYWxsZXQudWlkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVOQ19EQVRBX0VSUl9TVFIpO1xuICAgIH1cbiAgICAvLyBCdWlsZCB0aGUgcGF5bG9hZCBkYXRhXG4gICAgdmFyIHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoRU5DX0RBVEFfUkVRX0RBVEFfU1opO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChzY2hlbWEsIG9mZik7XG4gICAgb2ZmICs9IDE7XG4gICAgaWYgKHNjaGVtYSA9PT0gRU5DX0RBVEEuU0NIRU1BUy5CTFNfS0VZU1RPUkVfRUlQMjMzNV9QQktERl9WNCkge1xuICAgICAgICBwYXJhbXMud2FsbGV0VUlELmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IHBhcmFtcy53YWxsZXRVSUQubGVuZ3RoO1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDgocGFyYW1zLnBhdGgubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDw9IHBhcmFtcy5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRShwYXJhbXMucGF0aFtpXSwgb2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuYykge1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHBhcmFtcy5jLCBvZmYpO1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFTkNfREFUQV9FUlJfU1RSKTtcbiAgICB9XG59O1xuZXhwb3J0cy5lbmNvZGVGZXRjaEVuY0RhdGFSZXF1ZXN0ID0gZW5jb2RlRmV0Y2hFbmNEYXRhUmVxdWVzdDtcbnZhciBkZWNvZGVGZXRjaEVuY0RhdGEgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIHNjaGVtYSA9IF9hLnNjaGVtYSwgcGFyYW1zID0gX2EucGFyYW1zO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChzY2hlbWEgPT09IEVOQ19EQVRBLlNDSEVNQVMuQkxTX0tFWVNUT1JFX0VJUDIzMzVfUEJLREZfVjQpIHtcbiAgICAgICAgdmFyIHJlc3BEYXRhID0ge307XG4gICAgICAgIHZhciBfYiA9IEVOQ19EQVRBX1JFU1BfU1ouRUlQMjMzNSwgQ0lQSEVSVEVYVCA9IF9iLkNJUEhFUlRFWFQsIFNBTFQgPSBfYi5TQUxULCBDSEVDS1NVTSA9IF9iLkNIRUNLU1VNLCBJViA9IF9iLklWLCBQVUJLRVkgPSBfYi5QVUJLRVk7XG4gICAgICAgIHZhciBleHBlY3RlZFN6ID0gNCArIC8vIGl0ZXJhdGlvbnMgPSB1MzJcbiAgICAgICAgICAgIENJUEhFUlRFWFQgK1xuICAgICAgICAgICAgU0FMVCArXG4gICAgICAgICAgICBDSEVDS1NVTSArXG4gICAgICAgICAgICBJViArXG4gICAgICAgICAgICBQVUJLRVk7XG4gICAgICAgIHZhciBkYXRhU3ogPSBkYXRhLnJlYWRVSW50MzJMRShvZmYpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgaWYgKGRhdGFTeiAhPT0gZXhwZWN0ZWRTeikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgcmV0dXJuZWQgZnJvbSBMYXR0aWNlLiBFeHBlY3RlZCBFSVAyMzM1IGRhdGEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcERhdGEuaXRlcmF0aW9ucyA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZik7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICByZXNwRGF0YS5jaXBoZXJUZXh0ID0gZGF0YS5zbGljZShvZmYsIG9mZiArIENJUEhFUlRFWFQpO1xuICAgICAgICBvZmYgKz0gQ0lQSEVSVEVYVDtcbiAgICAgICAgcmVzcERhdGEuc2FsdCA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBTQUxUKTtcbiAgICAgICAgb2ZmICs9IFNBTFQ7XG4gICAgICAgIHJlc3BEYXRhLmNoZWNrc3VtID0gZGF0YS5zbGljZShvZmYsIG9mZiArIENIRUNLU1VNKTtcbiAgICAgICAgb2ZmICs9IENIRUNLU1VNO1xuICAgICAgICByZXNwRGF0YS5pdiA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBJVik7XG4gICAgICAgIG9mZiArPSBJVjtcbiAgICAgICAgcmVzcERhdGEucHVia2V5ID0gZGF0YS5zbGljZShvZmYsIG9mZiArIFBVQktFWSk7XG4gICAgICAgIG9mZiArPSBQVUJLRVk7XG4gICAgICAgIHJldHVybiBmb3JtYXRFSVAyMzM1RXhwb3J0RGF0YShyZXNwRGF0YSwgcGFyYW1zLnBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVOQ19EQVRBX0VSUl9TVFIpO1xuICAgIH1cbn07XG5leHBvcnRzLmRlY29kZUZldGNoRW5jRGF0YSA9IGRlY29kZUZldGNoRW5jRGF0YTtcbnZhciBmb3JtYXRFSVAyMzM1RXhwb3J0RGF0YSA9IGZ1bmN0aW9uIChyZXNwLCBwYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSByZXNwLml0ZXJhdGlvbnMsIHNhbHQgPSByZXNwLnNhbHQsIGNoZWNrc3VtID0gcmVzcC5jaGVja3N1bSwgaXYgPSByZXNwLml2LCBjaXBoZXJUZXh0ID0gcmVzcC5jaXBoZXJUZXh0LCBwdWJrZXkgPSByZXNwLnB1YmtleTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICd2ZXJzaW9uJzogNCxcbiAgICAgICAgICAgICd1dWlkJzogKDAsIHV1aWRfMS52NCkoKSxcbiAgICAgICAgICAgICdwYXRoJzogKDAsIHV0aWxpdGllc18xLmdldFBhdGhTdHIpKHBhdGgpLFxuICAgICAgICAgICAgJ3B1YmtleSc6IHB1YmtleS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAnY3J5cHRvJzoge1xuICAgICAgICAgICAgICAgICdrZGYnOiB7XG4gICAgICAgICAgICAgICAgICAgICdmdW5jdGlvbic6ICdwYmtkZjInLFxuICAgICAgICAgICAgICAgICAgICAncGFyYW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RrbGVuJzogMzIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYyc6IGl0ZXJhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJmJzogJ2htYWMtc2hhMjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzYWx0Jzogc2FsdC50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdtZXNzYWdlJzogJydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdjaGVja3N1bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJzogJ3NoYTI1NicsXG4gICAgICAgICAgICAgICAgICAgICdwYXJhbXMnOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiBjaGVja3N1bS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnY2lwaGVyJzoge1xuICAgICAgICAgICAgICAgICAgICAnZnVuY3Rpb24nOiAnYWVzLTEyOC1jdHInLFxuICAgICAgICAgICAgICAgICAgICAncGFyYW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2l2JzogaXYudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZSc6IGNpcGhlclRleHQudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gZm9ybWF0IEVJUDIzMzUgcmV0dXJuIGRhdGE6IFwiLmNvbmNhdChlcnIudG9TdHJpbmcoKSkpO1xuICAgIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUdldEFkZHJlc3Nlc1Jlc3BvbnNlID0gZXhwb3J0cy5lbmNvZGVHZXRBZGRyZXNzZXNSZXF1ZXN0ID0gZXhwb3J0cy52YWxpZGF0ZUdldEFkZHJlc3Nlc1JlcXVlc3QgPSBleHBvcnRzLmdldEFkZHJlc3NlcyA9IHZvaWQgMDtcbnZhciBiaXR3aXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpdHdpc2VcIikpO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi4vcHJvdG9jb2xcIik7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC92YWxpZGF0b3JzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBgZ2V0QWRkcmVzc2VzYCB0YWtlcyBhIHN0YXJ0aW5nIHBhdGggYW5kIGEgbnVtYmVyIHRvIGdldCB0aGUgYWRkcmVzc2VzIG9yIHB1YmxpYyBrZXlzIGFzc29jaWF0ZWRcbiAqIHdpdGggdGhlIGFjdGl2ZSB3YWxsZXQuXG4gKiBAY2F0ZWdvcnkgTGF0dGljZVxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIG9yIHB1YmxpYyBrZXlzLlxuICovXG5mdW5jdGlvbiBnZXRBZGRyZXNzZXMoX2EpIHtcbiAgICB2YXIgY2xpZW50ID0gX2EuY2xpZW50LCBfc3RhcnRQYXRoID0gX2Euc3RhcnRQYXRoLCBfbiA9IF9hLm4sIF9mbGFnID0gX2EuZmxhZztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYiwgdXJsLCBzaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiwgZndDb25zdGFudHMsIGFjdGl2ZVdhbGxldCwgX2MsIHN0YXJ0UGF0aCwgbiwgZmxhZywgZGF0YSwgX2QsIGRlY3J5cHRlZERhdGEsIG5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50KShjbGllbnQpLCB1cmwgPSBfYi51cmwsIHNoYXJlZFNlY3JldCA9IF9iLnNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViID0gX2IuZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cyA9IF9iLmZ3Q29uc3RhbnRzO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVXYWxsZXQgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlV2FsbGV0KShjbGllbnQuZ2V0QWN0aXZlV2FsbGV0KCkpO1xuICAgICAgICAgICAgICAgICAgICBfYyA9ICgwLCBleHBvcnRzLnZhbGlkYXRlR2V0QWRkcmVzc2VzUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXRoOiBfc3RhcnRQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbjogX24sXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnOiBfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgfSksIHN0YXJ0UGF0aCA9IF9jLnN0YXJ0UGF0aCwgbiA9IF9jLm4sIGZsYWcgPSBfYy5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gKDAsIGV4cG9ydHMuZW5jb2RlR2V0QWRkcmVzc2VzUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXRoOiBzdGFydFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZzogZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldDogYWN0aXZlV2FsbGV0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3RvY29sXzEuZW5jcnlwdGVkU2VjdXJlUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFR5cGU6IHByb3RvY29sXzEuTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmdldEFkZHJlc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTZWNyZXQ6IHNoYXJlZFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IGVwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9kID0gX2Uuc2VudCgpLCBkZWNyeXB0ZWREYXRhID0gX2QuZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViID0gX2QubmV3RXBoZW1lcmFsUHViO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogbmV3RXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCBleHBvcnRzLmRlY29kZUdldEFkZHJlc3Nlc1Jlc3BvbnNlKShkZWNyeXB0ZWREYXRhLCBmbGFnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRBZGRyZXNzZXMgPSBnZXRBZGRyZXNzZXM7XG52YXIgdmFsaWRhdGVHZXRBZGRyZXNzZXNSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHN0YXJ0UGF0aCA9IF9hLnN0YXJ0UGF0aCwgbiA9IF9hLm4sIGZsYWcgPSBfYS5mbGFnO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0UGF0aDogKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZVN0YXJ0UGF0aCkoc3RhcnRQYXRoKSxcbiAgICAgICAgbjogKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZU5BZGRyZXNzZXMpKG4pLFxuICAgICAgICBmbGFnOiAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlSXNVSW50NCkoZmxhZyksXG4gICAgfTtcbn07XG5leHBvcnRzLnZhbGlkYXRlR2V0QWRkcmVzc2VzUmVxdWVzdCA9IHZhbGlkYXRlR2V0QWRkcmVzc2VzUmVxdWVzdDtcbnZhciBlbmNvZGVHZXRBZGRyZXNzZXNSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciBzdGFydFBhdGggPSBfYS5zdGFydFBhdGgsIG4gPSBfYS5uLCBmbGFnID0gX2EuZmxhZywgZndDb25zdGFudHMgPSBfYS5md0NvbnN0YW50cywgd2FsbGV0ID0gX2Eud2FsbGV0O1xuICAgIHZhciBmbGFncyA9IGZ3Q29uc3RhbnRzLmdldEFkZHJlc3NGbGFncyB8fCBbXTtcbiAgICB2YXIgaXNQdWJrZXlPbmx5ID0gZmxhZ3MuaW5kZXhPZihmbGFnKSA+IC0xICYmXG4gICAgICAgIChmbGFnID09PSBwcm90b2NvbF8xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLmVkMjU1MTlQdWJrZXkgfHxcbiAgICAgICAgICAgIGZsYWcgPT09IHByb3RvY29sXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuc2VjcDI1NmsxUHVia2V5IHx8XG4gICAgICAgICAgICBmbGFnID09PSBwcm90b2NvbF8xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLmJsczEyXzM4MVB1YmtleSk7XG4gICAgaWYgKCFpc1B1YmtleU9ubHkgJiYgISgwLCB1dGlsXzEuaXNWYWxpZEFzc2V0UGF0aCkoc3RhcnRQYXRoLCBmd0NvbnN0YW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXJpdmF0aW9uIHBhdGggb3IgZmxhZyBpcyBub3Qgc3VwcG9ydGVkLiBUcnkgdXBkYXRpbmcgTGF0dGljZSBmaXJtd2FyZS4nKTtcbiAgICB9XG4gICAgdmFyIHN6ID0gMzIgKyAyMCArIDE7IC8vIHdhbGxldFVJRCArIDUgdTMyIGluZGljZXMgKyBjb3VudC9mbGFnXG4gICAgaWYgKGZ3Q29uc3RhbnRzLnZhckFkZHJQYXRoU3pBbGxvd2VkKSB7XG4gICAgICAgIHN6ICs9IDE7IC8vIHBhdGhEZXB0aFxuICAgIH1cbiAgICBlbHNlIGlmIChzdGFydFBhdGgubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBMYXR0aWNlIGZpcm13YXJlIG9ubHkgc3VwcG9ydHMgZGVyaXZhdGlvbiBwYXRocyB3aXRoIDUgaW5kaWNlcy4gUGxlYXNlIHVwZ3JhZGUuJyk7XG4gICAgfVxuICAgIHZhciBwYXlsb2FkID0gQnVmZmVyLmFsbG9jKHN6KTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB3YWxsZXQudWlkLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICBvZmYgKz0gMzI7XG4gICAgLy8gQnVpbGQgdGhlIHN0YXJ0IHBhdGggKDV4IHUzMiBpbmRpY2VzKVxuICAgIGlmIChmd0NvbnN0YW50cy52YXJBZGRyUGF0aFN6QWxsb3dlZCkge1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDgoc3RhcnRQYXRoLmxlbmd0aCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDE7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgIGlmIChpIDw9IHN0YXJ0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWxfMSA9IChfYiA9IHN0YXJ0UGF0aFtpXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJCRSh2YWxfMSwgb2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gNDtcbiAgICB9XG4gICAgLy8gU3BlY2lmeSB0aGUgbnVtYmVyIG9mIHN1YnNlcXVlbnQgYWRkcmVzc2VzIHRvIHJlcXVlc3QuIFdlIGFsc28gYWxsb3cgdGhlIHVzZXIgdG8gc2tpcCB0aGVcbiAgICAvLyBjYWNoZSBhbmQgcmVxdWVzdCBhbnkgYWRkcmVzcyByZWxhdGVkIHRvIHRoZSBhc3NldCBpbiB0aGUgd2FsbGV0LlxuICAgIHZhciB2YWwsIGZsYWdWYWwgPSAwO1xuICAgIGlmIChmd0NvbnN0YW50cy5hZGRyRmxhZ3NBbGxvd2VkKSB7XG4gICAgICAgIC8vIEEgNC1iaXQgZmxhZyBjYW4gYmUgdXNlZCBmb3Igbm9uLXN0YW5kYXJkIGFkZHJlc3MgcmVxdWVzdHMgQ2xpZW50IG5lZWRzIHRvIGJlIGNvbWJpbmVkIHdpdGhcbiAgICAgICAgLy8gYG5gIGFzIGEgNCBiaXQgdmFsdWVcbiAgICAgICAgZmxhZ1ZhbCA9XG4gICAgICAgICAgICBmd0NvbnN0YW50cy5nZXRBZGRyZXNzRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICBmd0NvbnN0YW50cy5nZXRBZGRyZXNzRmxhZ3MuaW5kZXhPZihmbGFnKSA+IC0xXG4gICAgICAgICAgICAgICAgPyBmbGFnXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICB2YXIgZmxhZ0JpdHMgPSBiaXR3aXNlXzEuZGVmYXVsdC5uaWJibGUucmVhZChmbGFnVmFsKTtcbiAgICAgICAgdmFyIGNvdW50Qml0cyA9IGJpdHdpc2VfMS5kZWZhdWx0Lm5pYmJsZS5yZWFkKG4pO1xuICAgICAgICB2YWwgPSBiaXR3aXNlXzEuZGVmYXVsdC5ieXRlLndyaXRlKGZsYWdCaXRzLmNvbmNhdChjb3VudEJpdHMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFZlcnkgb2xkIGZpcm13YXJlIGRvZXMgbm90IHN1cHBvcnQgY2xpZW50IGZsYWcuIFdlIGNhbiBkZXByZWNhdGUgY2xpZW50IHNvb24uXG4gICAgICAgIHZhbCA9IG47XG4gICAgfVxuICAgIHBheWxvYWQud3JpdGVVSW50OCh2YWwsIG9mZik7XG4gICAgb2ZmKys7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuZXhwb3J0cy5lbmNvZGVHZXRBZGRyZXNzZXNSZXF1ZXN0ID0gZW5jb2RlR2V0QWRkcmVzc2VzUmVxdWVzdDtcbi8qKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFkZHJlc3Mgc3RyaW5ncyBvciBwdWJrZXkgYnVmZmVyc1xuICovXG52YXIgZGVjb2RlR2V0QWRkcmVzc2VzUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSwgZmxhZykge1xuICAgIHZhciBvZmYgPSAwO1xuICAgIC8vIExvb2sgZm9yIGFkZHJlc3NlcyB1bnRpbCB3ZSByZWFjaCB0aGUgZW5kIChhIDQgYnl0ZSBjaGVja3N1bSlcbiAgICB2YXIgYWRkcnMgPSBbXTtcbiAgICAvLyBQdWJrZXlzIGFyZSBmb3JtYXR0ZWQgZGlmZmVyZW50bHkgaW4gdGhlIHJlc3BvbnNlXG4gICAgdmFyIGFyZVB1YmtleXMgPSBmbGFnID09PSBwcm90b2NvbF8xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLnNlY3AyNTZrMVB1YmtleSB8fFxuICAgICAgICBmbGFnID09PSBwcm90b2NvbF8xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLmVkMjU1MTlQdWJrZXkgfHxcbiAgICAgICAgZmxhZyA9PT0gcHJvdG9jb2xfMS5MYXR0aWNlR2V0QWRkcmVzc2VzRmxhZy5ibHMxMl8zODFQdWJrZXk7XG4gICAgaWYgKGFyZVB1YmtleXMpIHtcbiAgICAgICAgb2ZmICs9IDE7IC8vIHNraXAgdWludDggcmVwcmVzZW50aW5nIHB1YmtleSB0eXBlXG4gICAgfVxuICAgIHZhciByZXNwRGF0YUxlbmd0aCA9IHByb3RvY29sXzEuUHJvdG9jb2xDb25zdGFudHMubXNnU2l6ZXMuc2VjdXJlLmRhdGEucmVzcG9uc2UuZW5jcnlwdGVkW3Byb3RvY29sXzEuTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmdldEFkZHJlc3Nlc107XG4gICAgd2hpbGUgKG9mZiA8IHJlc3BEYXRhTGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcmVQdWJrZXlzKSB7XG4gICAgICAgICAgICAvLyBQdWJrZXlzIGFyZSBzaG9ydGVyIGFuZCBhcmUgcmV0dXJuZWQgYXMgYnVmZmVyc1xuICAgICAgICAgICAgdmFyIHB1YkJ5dGVzID0gZGF0YS5zbGljZShvZmYsIG9mZiArIDY1KTtcbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gcHViQnl0ZXMuZXZlcnkoZnVuY3Rpb24gKGJ5dGUpIHsgcmV0dXJuIGJ5dGUgPT09IDB4MDA7IH0pO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5ICYmIGZsYWcgPT09IHByb3RvY29sXzEuTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWcuZWQyNTUxOVB1YmtleSkge1xuICAgICAgICAgICAgICAgIC8vIEVEMjU1MTkgcHVia2V5cyBhcmUgMzIgYnl0ZXNcbiAgICAgICAgICAgICAgICBhZGRycy5wdXNoKHB1YkJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNFbXB0eSAmJiBmbGFnID09PSBwcm90b2NvbF8xLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnLmJsczEyXzM4MVB1YmtleSkge1xuICAgICAgICAgICAgICAgIC8vIEJMUzEyXzM4MV9HMSBrZXlzIGFyZSA0OCBieXRlc1xuICAgICAgICAgICAgICAgIGFkZHJzLnB1c2gocHViQnl0ZXMuc2xpY2UoMCwgNDgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBvdGhlciByZXR1cm5lZCBwdWJrZXlzIGFyZSBFQ0MsIG9yIDY1IGJ5dGVzIE5vdGUgdGhhdCB3ZSByZXR1cm4gZnVsbFxuICAgICAgICAgICAgICAgIC8vICh1bmNvbXByZXNzZWQpIEVDQyBwdWJrZXlzXG4gICAgICAgICAgICAgICAgYWRkcnMucHVzaChwdWJCeXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gNjU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIGRlYWxpbmcgd2l0aCBhZGRyZXNzIHN0cmluZ3NcbiAgICAgICAgICAgIHZhciBhZGRyQnl0ZXMgPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgcHJvdG9jb2xfMS5Qcm90b2NvbENvbnN0YW50cy5hZGRyU3RyTGVuKTtcbiAgICAgICAgICAgIG9mZiArPSBwcm90b2NvbF8xLlByb3RvY29sQ29uc3RhbnRzLmFkZHJTdHJMZW47XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIFVURi04IHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICB2YXIgbGVuID0gYWRkckJ5dGVzLmluZGV4T2YoMCk7IC8vIEZpcnN0IDAgaXMgdGhlIG51bGwgdGVybWluYXRvclxuICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICBhZGRycy5wdXNoKGFkZHJCeXRlcy5zbGljZSgwLCBsZW4pLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhZGRycztcbn07XG5leHBvcnRzLmRlY29kZUdldEFkZHJlc3Nlc1Jlc3BvbnNlID0gZGVjb2RlR2V0QWRkcmVzc2VzUmVzcG9uc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUdldEt2UmVjb3Jkc1Jlc3BvbnNlID0gZXhwb3J0cy5lbmNvZGVHZXRLdlJlY29yZHNSZXF1ZXN0ID0gZXhwb3J0cy52YWxpZGF0ZUdldEt2UmVxdWVzdCA9IGV4cG9ydHMuZ2V0S3ZSZWNvcmRzID0gdm9pZCAwO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi4vcHJvdG9jb2xcIik7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZShcIi4uL3NoYXJlZC92YWxpZGF0b3JzXCIpO1xuZnVuY3Rpb24gZ2V0S3ZSZWNvcmRzKF9hKSB7XG4gICAgdmFyIGNsaWVudCA9IF9hLmNsaWVudCwgX3R5cGUgPSBfYS50eXBlLCBfbiA9IF9hLm4sIF9zdGFydCA9IF9hLnN0YXJ0O1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCB1cmwsIHNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cywgX2MsIHR5cGUsIG4sIHN0YXJ0LCBkYXRhLCBfZCwgZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYiA9ICgwLCB2YWxpZGF0b3JzXzEudmFsaWRhdGVDb25uZWN0ZWRDbGllbnQpKGNsaWVudCksIHVybCA9IF9iLnVybCwgc2hhcmVkU2VjcmV0ID0gX2Iuc2hhcmVkU2VjcmV0LCBlcGhlbWVyYWxQdWIgPSBfYi5lcGhlbWVyYWxQdWIsIGZ3Q29uc3RhbnRzID0gX2IuZndDb25zdGFudHM7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gKDAsIGV4cG9ydHMudmFsaWRhdGVHZXRLdlJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbjogX24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzLFxuICAgICAgICAgICAgICAgICAgICB9KSwgdHlwZSA9IF9jLnR5cGUsIG4gPSBfYy5uLCBzdGFydCA9IF9jLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gKDAsIGV4cG9ydHMuZW5jb2RlR2V0S3ZSZWNvcmRzUmVxdWVzdCkoeyB0eXBlOiB0eXBlLCBuOiBuLCBzdGFydDogc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm90b2NvbF8xLmVuY3J5cHRlZFNlY3VyZVJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBwcm90b2NvbF8xLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5nZXRLdlJlY29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfZCA9IF9lLnNlbnQoKSwgZGVjcnlwdGVkRGF0YSA9IF9kLmRlY3J5cHRlZERhdGEsIG5ld0VwaGVtZXJhbFB1YiA9IF9kLm5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IG5ld0VwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgZXhwb3J0cy5kZWNvZGVHZXRLdlJlY29yZHNSZXNwb25zZSkoZGVjcnlwdGVkRGF0YSwgZndDb25zdGFudHMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldEt2UmVjb3JkcyA9IGdldEt2UmVjb3JkcztcbnZhciB2YWxpZGF0ZUdldEt2UmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBmd0NvbnN0YW50cyA9IF9hLmZ3Q29uc3RhbnRzLCBuID0gX2EubiwgdHlwZSA9IF9hLnR5cGUsIHN0YXJ0ID0gX2Euc3RhcnQ7XG4gICAgaWYgKCFmd0NvbnN0YW50cy5rdkFjdGlvbnNBbGxvd2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgZmlybXdhcmUuJyk7XG4gICAgfVxuICAgIGlmICghbiB8fCBuIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHJlcXVlc3QgYXQgbGVhc3Qgb25lIHJlY29yZC4nKTtcbiAgICB9XG4gICAgaWYgKG4gPiBmd0NvbnN0YW50cy5rdkFjdGlvbk1heE51bSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbWF5IG9ubHkgcmVxdWVzdCB1cCB0byBcIi5jb25jYXQoZndDb25zdGFudHMua3ZBY3Rpb25NYXhOdW0sIFwiIHJlY29yZHMgYXQgb25jZS5cIikpO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gMCAmJiAhdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSB0eXBlLicpO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgIT09IDAgJiYgIXN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIHR5cGUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cywgbjogbiwgdHlwZTogdHlwZSwgc3RhcnQ6IHN0YXJ0IH07XG59O1xuZXhwb3J0cy52YWxpZGF0ZUdldEt2UmVxdWVzdCA9IHZhbGlkYXRlR2V0S3ZSZXF1ZXN0O1xudmFyIGVuY29kZUdldEt2UmVjb3Jkc1JlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIG4gPSBfYS5uLCBzdGFydCA9IF9hLnN0YXJ0O1xuICAgIHZhciBwYXlsb2FkID0gQnVmZmVyLmFsbG9jKDkpO1xuICAgIHBheWxvYWQud3JpdGVVSW50MzJMRSh0eXBlLCAwKTtcbiAgICBwYXlsb2FkLndyaXRlVUludDgobiwgNCk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHN0YXJ0LCA1KTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5leHBvcnRzLmVuY29kZUdldEt2UmVjb3Jkc1JlcXVlc3QgPSBlbmNvZGVHZXRLdlJlY29yZHNSZXF1ZXN0O1xudmFyIGRlY29kZUdldEt2UmVjb3Jkc1Jlc3BvbnNlID0gZnVuY3Rpb24gKGRhdGEsIGZ3Q29uc3RhbnRzKSB7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIG5Ub3RhbCA9IGRhdGEucmVhZFVJbnQzMkJFKG9mZik7XG4gICAgb2ZmICs9IDQ7XG4gICAgdmFyIG5GZXRjaGVkID0gcGFyc2VJbnQoZGF0YS5zbGljZShvZmYsIG9mZiArIDEpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgIG9mZiArPSAxO1xuICAgIGlmIChuRmV0Y2hlZCA+IGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHJlY29yZHMgZmV0Y2hlZC4gRmlybXdhcmUgZXJyb3IuJyk7XG4gICAgdmFyIHJlY29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5GZXRjaGVkOyBpKyspIHtcbiAgICAgICAgdmFyIHIgPSB7fTtcbiAgICAgICAgci5pZCA9IGRhdGEucmVhZFVJbnQzMkJFKG9mZik7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICByLnR5cGUgPSBkYXRhLnJlYWRVSW50MzJCRShvZmYpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgci5jYXNlU2Vuc2l0aXZlID1cbiAgICAgICAgICAgIHBhcnNlSW50KGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAxKS50b1N0cmluZygnaGV4JyksIDE2KSA9PT0gMVxuICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICB2YXIga2V5U3ogPSBwYXJzZUludChkYXRhLnNsaWNlKG9mZiwgb2ZmICsgMSkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICByLmtleSA9IGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBrZXlTeiAtIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgIG9mZiArPSBmd0NvbnN0YW50cy5rdktleU1heFN0clN6ICsgMTtcbiAgICAgICAgdmFyIHZhbFN6ID0gcGFyc2VJbnQoZGF0YS5zbGljZShvZmYsIG9mZiArIDEpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgci52YWwgPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgdmFsU3ogLSAxKS50b1N0cmluZygpO1xuICAgICAgICBvZmYgKz0gZndDb25zdGFudHMua3ZWYWxNYXhTdHJTeiArIDE7XG4gICAgICAgIHJlY29yZHMucHVzaChyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVjb3JkczogcmVjb3JkcyxcbiAgICAgICAgdG90YWw6IG5Ub3RhbCxcbiAgICAgICAgZmV0Y2hlZDogbkZldGNoZWQsXG4gICAgfTtcbn07XG5leHBvcnRzLmRlY29kZUdldEt2UmVjb3Jkc1Jlc3BvbnNlID0gZGVjb2RlR2V0S3ZSZWNvcmRzUmVzcG9uc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FkZEt2UmVjb3Jkc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29ubmVjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmV0Y2hFbmNEYXRhXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZXRjaEFjdGl2ZVdhbGxldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZ2V0QWRkcmVzc2VzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nZXRLdlJlY29yZHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhaXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlbW92ZUt2UmVjb3Jkc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnblwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZVBhaXJSZXF1ZXN0ID0gZXhwb3J0cy5wYWlyID0gdm9pZCAwO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi4vcHJvdG9jb2xcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3V0aWxpdGllc1wiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ZhbGlkYXRvcnNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIElmIGEgcGFpcmluZyBzZWNyZXQgaXMgcHJvdmlkZWQsIGBwYWlyYCB1c2VzIGl0IHRvIHNpZ24gYSBoYXNoIG9mIHRoZSBwdWJsaWMga2V5LCBuYW1lLCBhbmRcbiAqIHBhaXJpbmcgc2VjcmV0LiBJdCB0aGVuIHNlbmRzIHRoZSBuYW1lIGFuZCBzaWduYXR1cmUgdG8gdGhlIGRldmljZS4gSWYgbm8gcGFpcmluZyBzZWNyZXQgaXNcbiAqIHByb3ZpZGVkLCBgcGFpcmAgc2VuZHMgYSB6ZXJvLWxlbmd0aCBuYW1lIGJ1ZmZlciB0byB0aGUgZGV2aWNlLlxuICogQGNhdGVnb3J5IExhdHRpY2VcbiAqIEByZXR1cm5zIFRoZSBhY3RpdmUgd2FsbGV0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcGFpcihfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQsIHBhaXJpbmdTZWNyZXQgPSBfYS5wYWlyaW5nU2VjcmV0O1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCB1cmwsIHNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViLCBhcHBOYW1lLCBrZXksIGRhdGEsIG5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50KShjbGllbnQpLCB1cmwgPSBfYi51cmwsIHNoYXJlZFNlY3JldCA9IF9iLnNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViID0gX2IuZXBoZW1lcmFsUHViLCBhcHBOYW1lID0gX2IuYXBwTmFtZSwga2V5ID0gX2Iua2V5O1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gKDAsIGV4cG9ydHMuZW5jb2RlUGFpclJlcXVlc3QpKHsgcGFpcmluZ1NlY3JldDogcGFpcmluZ1NlY3JldCwga2V5OiBrZXksIGFwcE5hbWU6IGFwcE5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm90b2NvbF8xLmVuY3J5cHRlZFNlY3VyZVJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBwcm90b2NvbF8xLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5maW5hbGl6ZVBhaXJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBlcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBuZXdFcGhlbWVyYWxQdWIgPSAoX2Muc2VudCgpKS5uZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBuZXdFcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BhaXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNsaWVudC5mZXRjaEFjdGl2ZVdhbGxldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNsaWVudC5oYXNBY3RpdmVXYWxsZXQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5wYWlyID0gcGFpcjtcbnZhciBlbmNvZGVQYWlyUmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBrZXkgPSBfYS5rZXksIHBhaXJpbmdTZWNyZXQgPSBfYS5wYWlyaW5nU2VjcmV0LCBhcHBOYW1lID0gX2EuYXBwTmFtZTtcbiAgICAvLyBCdWlsZCB0aGUgcGF5bG9hZCBkYXRhXG4gICAgdmFyIHB1YktleUJ5dGVzID0gKDAsIHV0aWxpdGllc18xLmdldFB1YktleUJ5dGVzKShrZXkpO1xuICAgIHZhciBuYW1lQnVmID0gQnVmZmVyLmFsbG9jKDI1KTtcbiAgICBpZiAocGFpcmluZ1NlY3JldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIElmIGEgcGFpcmluZyBzZWNyZXQgb2YgemVybyBsZW5ndGggaXMgcGFzc2VkIGluLCBpdCB1c3VhbGx5IGluZGljYXRlcyB3ZSB3YW50IHRvIGNhbmNlbFxuICAgICAgICAvLyB0aGUgcGFpcmluZyBhdHRlbXB0LiBJbiB0aGlzIGNhc2Ugd2UgcGFzcyBhIHplcm8tbGVuZ3RoIG5hbWUgYnVmZmVyIHNvIHRoZSBmaXJtd2FyZSBjYW5cbiAgICAgICAgLy8ga25vdyBub3QgdG8gZHJhdyB0aGUgZXJyb3Igc2NyZWVuLiBOb3RlIHRoYXQgd2Ugc3RpbGwgZXhwZWN0IGFuIGVycm9yIHRvIGNvbWUgYmFja1xuICAgICAgICAvLyAoUkVTUF9FUlJfUEFJUl9GQUlMKVxuICAgICAgICBuYW1lQnVmLndyaXRlKGFwcE5hbWUpO1xuICAgIH1cbiAgICB2YXIgaGFzaCA9ICgwLCB1dGlsXzEuZ2VuZXJhdGVBcHBTZWNyZXQpKHB1YktleUJ5dGVzLCBuYW1lQnVmLCBCdWZmZXIuZnJvbShwYWlyaW5nU2VjcmV0KSk7XG4gICAgdmFyIHNpZyA9IGtleS5zaWduKGhhc2gpOyAvLyByZXR1cm5zIGFuIGFycmF5LCBub3QgYSBidWZmZXJcbiAgICB2YXIgZGVyU2lnID0gKDAsIHV0aWxfMS50b1BhZGRlZERFUikoc2lnKTtcbiAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5jb25jYXQoW25hbWVCdWYsIGRlclNpZ10pO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcbmV4cG9ydHMuZW5jb2RlUGFpclJlcXVlc3QgPSBlbmNvZGVQYWlyUmVxdWVzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlUmVtb3ZlS3ZSZWNvcmRzUmVxdWVzdCA9IGV4cG9ydHMudmFsaWRhdGVSZW1vdmVLdlJlcXVlc3QgPSBleHBvcnRzLnJlbW92ZUt2UmVjb3JkcyA9IHZvaWQgMDtcbnZhciBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4uL3Byb3RvY29sXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbi8qKlxuICogYHJlbW92ZUt2UmVjb3Jkc2AgdGFrZXMgaW4gYW4gYXJyYXkgb2YgaWRzIGFuZCBzZW5kcyBhIHJlcXVlc3QgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgTGF0dGljZS5cbiAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gKiBAcmV0dXJucyBBIGNhbGxiYWNrIHdpdGggYW4gZXJyb3Igb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlS3ZSZWNvcmRzKF9hKSB7XG4gICAgdmFyIGNsaWVudCA9IF9hLmNsaWVudCwgX3R5cGUgPSBfYS50eXBlLCBfaWRzID0gX2EuaWRzO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCB1cmwsIHNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cywgX2MsIHR5cGUsIGlkcywgZGF0YSwgX2QsIGRlY3J5cHRlZERhdGEsIG5ld0VwaGVtZXJhbFB1YjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50KShjbGllbnQpLCB1cmwgPSBfYi51cmwsIHNoYXJlZFNlY3JldCA9IF9iLnNoYXJlZFNlY3JldCwgZXBoZW1lcmFsUHViID0gX2IuZXBoZW1lcmFsUHViLCBmd0NvbnN0YW50cyA9IF9iLmZ3Q29uc3RhbnRzO1xuICAgICAgICAgICAgICAgICAgICBfYyA9ICgwLCBleHBvcnRzLnZhbGlkYXRlUmVtb3ZlS3ZSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmd0NvbnN0YW50czogZndDb25zdGFudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkczogX2lkcyxcbiAgICAgICAgICAgICAgICAgICAgfSksIHR5cGUgPSBfYy50eXBlLCBpZHMgPSBfYy5pZHM7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoMCwgZXhwb3J0cy5lbmNvZGVSZW1vdmVLdlJlY29yZHNSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRzOiBpZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmd0NvbnN0YW50czogZndDb25zdGFudHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvdG9jb2xfMS5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcHJvdG9jb2xfMS5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUucmVtb3ZlS3ZSZWNvcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBfZS5zZW50KCksIGRlY3J5cHRlZERhdGEgPSBfZC5kZWNyeXB0ZWREYXRhLCBuZXdFcGhlbWVyYWxQdWIgPSBfZC5uZXdFcGhlbWVyYWxQdWI7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsUHViOiBuZXdFcGhlbWVyYWxQdWIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGVjcnlwdGVkRGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZW1vdmVLdlJlY29yZHMgPSByZW1vdmVLdlJlY29yZHM7XG52YXIgdmFsaWRhdGVSZW1vdmVLdlJlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZndDb25zdGFudHMgPSBfYS5md0NvbnN0YW50cywgdHlwZSA9IF9hLnR5cGUsIGlkcyA9IF9hLmlkcztcbiAgICBpZiAoIWZ3Q29uc3RhbnRzLmt2QWN0aW9uc0FsbG93ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSBmaXJtd2FyZS4nKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlkcykgfHwgaWRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBpbmNsdWRlIG9uZSBvciBtb3JlIGBpZHNgIHRvIHJlbW92ZWQuJyk7XG4gICAgfVxuICAgIGlmIChpZHMubGVuZ3RoID4gZndDb25zdGFudHMua3ZSZW1vdmVNYXhOdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSB1cCB0byBcIi5jb25jYXQoZndDb25zdGFudHMua3ZSZW1vdmVNYXhOdW0sIFwiIHJlY29yZHMgbWF5IGJlIHJlbW92ZWQgYXQgb25jZS5cIikpO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gMCAmJiAhdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSB0eXBlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBpZHM6IGlkcyB9O1xufTtcbmV4cG9ydHMudmFsaWRhdGVSZW1vdmVLdlJlcXVlc3QgPSB2YWxpZGF0ZVJlbW92ZUt2UmVxdWVzdDtcbnZhciBlbmNvZGVSZW1vdmVLdlJlY29yZHNSZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZ3Q29uc3RhbnRzID0gX2EuZndDb25zdGFudHMsIHR5cGUgPSBfYS50eXBlLCBpZHMgPSBfYS5pZHM7XG4gICAgdmFyIHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoNSArIDQgKiBmd0NvbnN0YW50cy5rdlJlbW92ZU1heE51bSk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHR5cGUsIDApO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChpZHMubGVuZ3RoLCA0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBwYXJzZUludChpZHNbaV0pO1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoaWQsIDUgKyA0ICogaSk7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkO1xufTtcbmV4cG9ydHMuZW5jb2RlUmVtb3ZlS3ZSZWNvcmRzUmVxdWVzdCA9IGVuY29kZVJlbW92ZUt2UmVjb3Jkc1JlcXVlc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVNpZ25SZXNwb25zZSA9IGV4cG9ydHMuZW5jb2RlU2lnblJlcXVlc3QgPSBleHBvcnRzLnNpZ24gPSB2b2lkIDA7XG52YXIgaGFzaF9qc18xID0gcmVxdWlyZShcImhhc2guanNcIik7XG52YXIgYml0Y29pbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9iaXRjb2luXCIpKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgZXRoZXJldW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXRoZXJldW1cIikpO1xudmFyIGdlbmVyaWNTaWduaW5nXzEgPSByZXF1aXJlKFwiLi4vZ2VuZXJpY1NpZ25pbmdcIik7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciBmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvZnVuY3Rpb25zXCIpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogYHNpZ25gIGJ1aWxkcyBhbmQgc2VuZHMgYSByZXF1ZXN0IGZvciBzaWduaW5nIHRvIHRoZSBkZXZpY2UuXG4gKiBAY2F0ZWdvcnkgTGF0dGljZVxuICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIGRldmljZS5cbiAqL1xuZnVuY3Rpb24gc2lnbihfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQsIGRhdGEgPSBfYS5kYXRhLCBjdXJyZW5jeSA9IF9hLmN1cnJlbmN5LCBjYWNoZWREYXRhID0gX2EuY2FjaGVkRGF0YSwgbmV4dENvZGUgPSBfYS5uZXh0Q29kZTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYiwgdXJsLCBzaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiwgZndDb25zdGFudHMsIHdhbGxldCwgX2MsIHJlcXVlc3REYXRhLCBpc0dlbmVyaWMsIF9kLCBwYXlsb2FkLCBoYXNFeHRyYVBheWxvYWRzLCBfZSwgZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViLCBkZWNvZGVkUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9iID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZUNvbm5lY3RlZENsaWVudCkoY2xpZW50KSwgdXJsID0gX2IudXJsLCBzaGFyZWRTZWNyZXQgPSBfYi5zaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiA9IF9iLmVwaGVtZXJhbFB1YiwgZndDb25zdGFudHMgPSBfYi5md0NvbnN0YW50cztcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gKDAsIHZhbGlkYXRvcnNfMS52YWxpZGF0ZVdhbGxldCkoY2xpZW50LmdldEFjdGl2ZVdhbGxldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSAoMCwgZnVuY3Rpb25zXzEuYnVpbGRUcmFuc2FjdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSksIHJlcXVlc3REYXRhID0gX2MucmVxdWVzdERhdGEsIGlzR2VuZXJpYyA9IF9jLmlzR2VuZXJpYztcbiAgICAgICAgICAgICAgICAgICAgX2QgPSAoMCwgZXhwb3J0cy5lbmNvZGVTaWduUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0OiB3YWxsZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YTogcmVxdWVzdERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWREYXRhOiBjYWNoZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENvZGU6IG5leHRDb2RlLFxuICAgICAgICAgICAgICAgICAgICB9KSwgcGF5bG9hZCA9IF9kLnBheWxvYWQsIGhhc0V4dHJhUGF5bG9hZHMgPSBfZC5oYXNFeHRyYVBheWxvYWRzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvdG9jb2xfMS5lbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogcHJvdG9jb2xfMS5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTZWNyZXQ6IHNoYXJlZFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IGVwaGVtZXJhbFB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9lID0gX2Yuc2VudCgpLCBkZWNyeXB0ZWREYXRhID0gX2UuZGVjcnlwdGVkRGF0YSwgbmV3RXBoZW1lcmFsUHViID0gX2UubmV3RXBoZW1lcmFsUHViO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogbmV3RXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyByZXF1ZXN0IGhhcyBtdWx0aXBsZSBwYXlsb2Fkcywgd2UgbmVlZCB0byByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIG1ha2UgdGhlIG5leHQgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgY2hhaW5lZCB0byB0aGUgZmlyc3QgcmVxdWVzdCB1c2luZyBgbmV4dENvZGVgXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNFeHRyYVBheWxvYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2xpZW50LnNpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZERhdGE6IHJlcXVlc3REYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29kZTogZGVjcnlwdGVkRGF0YS5zbGljZSgwLCA4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZFJlc3BvbnNlID0gKDAsIGV4cG9ydHMuZGVjb2RlU2lnblJlc3BvbnNlKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0dlbmVyaWM6IGlzR2VuZXJpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkZWNvZGVkUmVzcG9uc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2lnbiA9IHNpZ247XG52YXIgZW5jb2RlU2lnblJlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IsIF9jLCBfZDtcbiAgICB2YXIgZndDb25zdGFudHMgPSBfYS5md0NvbnN0YW50cywgd2FsbGV0ID0gX2Eud2FsbGV0LCByZXF1ZXN0RGF0YSA9IF9hLnJlcXVlc3REYXRhLCBjYWNoZWREYXRhID0gX2EuY2FjaGVkRGF0YSwgbmV4dENvZGUgPSBfYS5uZXh0Q29kZTtcbiAgICB2YXIgcmVxUGF5bG9hZCwgc2NoZW1hO1xuICAgIGlmIChjYWNoZWREYXRhICYmIG5leHRDb2RlKSB7XG4gICAgICAgIHJlcXVlc3REYXRhID0gY2FjaGVkRGF0YTtcbiAgICAgICAgcmVxUGF5bG9hZCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgbmV4dENvZGUsXG4gICAgICAgICAgICByZXF1ZXN0RGF0YS5leHRyYURhdGFQYXlsb2Fkcy5zaGlmdCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgc2NoZW1hID0gcHJvdG9jb2xfMS5MYXR0aWNlU2lnblNjaGVtYS5leHRyYURhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXFQYXlsb2FkID0gcmVxdWVzdERhdGEucGF5bG9hZDtcbiAgICAgICAgc2NoZW1hID0gcmVxdWVzdERhdGEuc2NoZW1hO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYygyICsgZndDb25zdGFudHMucmVxTWF4RGF0YVN6KTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaGFzRXh0cmFQYXlsb2FkcyA9IHJlcXVlc3REYXRhLmV4dHJhRGF0YVBheWxvYWRzICYmXG4gICAgICAgIE51bWJlcihyZXF1ZXN0RGF0YS5leHRyYURhdGFQYXlsb2Fkcy5sZW5ndGggPiAwKTtcbiAgICBwYXlsb2FkLndyaXRlVUludDgoaGFzRXh0cmFQYXlsb2Fkcywgb2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICAvLyBDb3B5IHJlcXVlc3Qgc2NoZW1hIChlLmcuIEVUSCBvciBCVEMgdHJhbnNmZXIpXG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KHNjaGVtYSwgb2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICAvLyBDb3B5IHRoZSB3YWxsZXQgVUlEXG4gICAgKF9iID0gd2FsbGV0LnVpZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICBvZmYgKz0gKF9kID0gKF9jID0gd2FsbGV0LnVpZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMDtcbiAgICAvLyBCdWlsZCBkYXRhIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHJlcXVlc3RcbiAgICByZXFQYXlsb2FkLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICByZXR1cm4geyBwYXlsb2FkOiBwYXlsb2FkLCBoYXNFeHRyYVBheWxvYWRzOiBoYXNFeHRyYVBheWxvYWRzIH07XG59O1xuZXhwb3J0cy5lbmNvZGVTaWduUmVxdWVzdCA9IGVuY29kZVNpZ25SZXF1ZXN0O1xudmFyIGRlY29kZVNpZ25SZXNwb25zZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0LCBpc0dlbmVyaWMgPSBfYS5pc0dlbmVyaWMsIGN1cnJlbmN5ID0gX2EuY3VycmVuY3k7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGRlclNpZ0xlbiA9IDc0OyAvLyBERVIgc2lnbmF0dXJlcyBhcmUgNzQgYnl0ZXNcbiAgICBpZiAoY3VycmVuY3kgPT09IGNvbnN0YW50c18xLkNVUlJFTkNJRVMuQlRDKSB7XG4gICAgICAgIHZhciBidGNSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdmFyIHBraExlbiA9IDIwOyAvLyBQdWJrZXloYXNoZXMgYXJlIDIwIGJ5dGVzXG4gICAgICAgIHZhciBzaWdzTGVuID0gNzQwOyAvLyBVcCB0byAxMHggREVSIHNpZ25hdHVyZXNcbiAgICAgICAgdmFyIGNoYW5nZVZlcnNpb24gPSBiaXRjb2luXzEuZGVmYXVsdC5nZXRBZGRyZXNzRm9ybWF0KGJ0Y1JlcXVlc3Qub3JpZ0RhdGEuY2hhbmdlUGF0aCk7XG4gICAgICAgIHZhciBjaGFuZ2VQdWJLZXlIYXNoID0gZGF0YS5zbGljZShvZmYsIG9mZiArIHBraExlbik7XG4gICAgICAgIG9mZiArPSBwa2hMZW47XG4gICAgICAgIHZhciBjaGFuZ2VSZWNpcGllbnQgPSBiaXRjb2luXzEuZGVmYXVsdC5nZXRCaXRjb2luQWRkcmVzcyhjaGFuZ2VQdWJLZXlIYXNoLCBjaGFuZ2VWZXJzaW9uKTtcbiAgICAgICAgdmFyIGNvbXByZXNzZWRQdWJMZW5ndGggPSAzMzsgLy8gU2l6ZSBvZiBjb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICAgICAgdmFyIHB1YmtleXMgPSBbXTtcbiAgICAgICAgdmFyIHNpZ3MgPSBbXTtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICAvLyBQYXJzZSB0aGUgc2lnbmF0dXJlIGZvciBlYWNoIG91dHB1dCAtLSB0aGV5IGFyZSByZXR1cm5lZCBpbiB0aGUgc2VyaWFsaXplZCBwYXlsb2FkIGluIGZvcm1cbiAgICAgICAgLy8gW3B1YmtleSwgc2lnXSBUaGVyZSBpcyBvbmUgc2lnbmF0dXJlIHBlciBvdXRwdXRcbiAgICAgICAgd2hpbGUgKG9mZiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBFeGl0IG91dCBpZiB3ZSBoYXZlIHNlZW4gYWxsIHRoZSByZXR1cm5lZCBzaWdzIGFuZCBwdWJrZXlzXG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZdICE9PSAweDMwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGdyYWIgYW5vdGhlciBzZXQgTm90ZSB0aGF0IGFsbCBERVIgc2lncyByZXR1cm5lZCBmaWxsIHRoZSBtYXhpbXVtIDc0IGJ5dGVcbiAgICAgICAgICAgIC8vIGJ1ZmZlciwgYnV0IGFsc28gY29udGFpbiBhIGxlbmd0aCBhdCBvZmYrMSwgd2hpY2ggd2UgdXNlIHRvIHBhcnNlIHRoZSBub24temVybyBkYXRhLlxuICAgICAgICAgICAgLy8gRmlyc3QgZ2V0IHRoZSBzaWduYXR1cmUgZnJvbSBpdHMgc2xvdFxuICAgICAgICAgICAgdmFyIHNpZ1N0YXJ0ID0gb2ZmO1xuICAgICAgICAgICAgdmFyIHNpZ0VuZCA9IG9mZiArIDIgKyBkYXRhW29mZiArIDFdO1xuICAgICAgICAgICAgc2lncy5wdXNoKGRhdGEuc2xpY2Uoc2lnU3RhcnQsIHNpZ0VuZCkpO1xuICAgICAgICAgICAgb2ZmICs9IGRlclNpZ0xlbjtcbiAgICAgICAgICAgIC8vIE5leHQsIHNoaWZ0IGJ5IHRoZSBmdWxsIHNldCBvZiBzaWduYXR1cmVzIHRvIGhpdCB0aGUgcmVzcGVjdGl2ZSBwdWJrZXkgTk9URTogVGhlIGRhdGFcbiAgICAgICAgICAgIC8vIHJldHVybmVkIGlzOiBbPHNpZzA+LCA8c2lnMT4sIC4uLiA8c2lnOT5dWzxwdWJrZXkwPiwgPHB1YmtleTE+LCAuLi4gPHB1YmtleTk+XVxuICAgICAgICAgICAgdmFyIHB1YlN0YXJ0ID0gbiAqIGNvbXByZXNzZWRQdWJMZW5ndGggKyBzaWdzTGVuO1xuICAgICAgICAgICAgdmFyIHB1YkVuZCA9IChuICsgMSkgKiBjb21wcmVzc2VkUHViTGVuZ3RoICsgc2lnc0xlbjtcbiAgICAgICAgICAgIHB1YmtleXMucHVzaChkYXRhLnNsaWNlKHB1YlN0YXJ0LCBwdWJFbmQpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvZmZzZXQgdG8gaGl0IHRoZSBuZXh0IHNpZ25hdHVyZSBzbG90XG4gICAgICAgICAgICBuICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbGQgdGhlIHRyYW5zYWN0aW9uIGRhdGEgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICB2YXIgcHJlU2VyaWFsaXplZERhdGEgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8vIEZpcnN0IG91dHB1dCBjb21lcyBmcm9tIHJlcXVlc3QgZHRhXG4gICAgICAgIHByZVNlcmlhbGl6ZWREYXRhLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogYnRjUmVxdWVzdC5vcmlnRGF0YS52YWx1ZSxcbiAgICAgICAgICAgIHJlY2lwaWVudDogYnRjUmVxdWVzdC5vcmlnRGF0YS5yZWNpcGllbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKChfYiA9IGJ0Y1JlcXVlc3QuY2hhbmdlRGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZhbHVlKSAmJiBidGNSZXF1ZXN0LmNoYW5nZURhdGEudmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAvLyBTZWNvbmQgb3V0cHV0IGNvbWVzIGZyb20gY2hhbmdlIGRhdGFcbiAgICAgICAgICAgIHByZVNlcmlhbGl6ZWREYXRhLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGJ0Y1JlcXVlc3QuY2hhbmdlRGF0YS52YWx1ZSxcbiAgICAgICAgICAgICAgICByZWNpcGllbnQ6IGNoYW5nZVJlY2lwaWVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgaW5wdXRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJlU2VyaWFsaXplZERhdGEuaW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGhhc2g6IGJ0Y1JlcXVlc3Qub3JpZ0RhdGEucHJldk91dHNbaV0udHhIYXNoLFxuICAgICAgICAgICAgICAgIGluZGV4OiBidGNSZXF1ZXN0Lm9yaWdEYXRhLnByZXZPdXRzW2ldLmluZGV4LFxuICAgICAgICAgICAgICAgIHNpZzogc2lnc1tpXSxcbiAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YmtleXNbaV0sXG4gICAgICAgICAgICAgICAgc2lnbmVyUGF0aDogYnRjUmVxdWVzdC5vcmlnRGF0YS5wcmV2T3V0c1tpXS5zaWduZXJQYXRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSwgc2VyaWFsaXplIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICB2YXIgc2VyaWFsaXplZFR4ID0gYml0Y29pbl8xLmRlZmF1bHQuc2VyaWFsaXplVHgocHJlU2VyaWFsaXplZERhdGEpO1xuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgdHJhbnNhY3Rpb24gaGFzaCBzbyB0aGUgdXNlciBjYW4gbG9vayB0aGlzIHRyYW5zYWN0aW9uIHVwIGxhdGVyXG4gICAgICAgIHZhciBwcmVJbWFnZVR4SGFzaCA9IHNlcmlhbGl6ZWRUeDtcbiAgICAgICAgdmFyIHR4SGFzaFByZSA9IEJ1ZmZlci5mcm9tKCgwLCBoYXNoX2pzXzEuc2hhMjU2KSgpLnVwZGF0ZShCdWZmZXIuZnJvbShwcmVJbWFnZVR4SGFzaCwgJ2hleCcpKS5kaWdlc3QoJ2hleCcpLCAnaGV4Jyk7XG4gICAgICAgIC8vIEFkZCBleHRyYSBkYXRhIGZvciBkZWJ1Z2dpbmcvbG9va3VwIHB1cnBvc2VzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eDogc2VyaWFsaXplZFR4LFxuICAgICAgICAgICAgdHhIYXNoOiAoMCwgaGFzaF9qc18xLnNoYTI1NikoKS51cGRhdGUodHhIYXNoUHJlKS5kaWdlc3QoJ2hleCcpLFxuICAgICAgICAgICAgY2hhbmdlUmVjaXBpZW50OiBjaGFuZ2VSZWNpcGllbnQsXG4gICAgICAgICAgICBzaWdzOiBzaWdzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW5jeSA9PT0gY29uc3RhbnRzXzEuQ1VSUkVOQ0lFUy5FVEggJiYgIWlzR2VuZXJpYykge1xuICAgICAgICB2YXIgc2lnID0gKDAsIHV0aWxfMS5wYXJzZURFUikoZGF0YS5zbGljZShvZmYsIG9mZiArIDIgKyBkYXRhW29mZiArIDFdKSk7XG4gICAgICAgIG9mZiArPSBkZXJTaWdMZW47XG4gICAgICAgIHZhciBldGhBZGRyID0gZGF0YS5zbGljZShvZmYsIG9mZiArIDIwKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBgdmAgcGFyYW0gYW5kIGFkZCBpdCB0byB0aGUgc2lnIGJlZm9yZSByZXR1cm5pbmdcbiAgICAgICAgdmFyIF9jID0gZXRoZXJldW1fMS5kZWZhdWx0LmJ1aWxkRXRoUmF3VHgocmVxdWVzdCwgc2lnLCBldGhBZGRyKSwgcmF3VHggPSBfYy5yYXdUeCwgc2lnV2l0aFYgPSBfYy5zaWdXaXRoVjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4OiBcIjB4XCIuY29uY2F0KHJhd1R4KSxcbiAgICAgICAgICAgIHR4SGFzaDogXCIweFwiLmNvbmNhdChldGhlcmV1bV8xLmRlZmF1bHQuaGFzaFRyYW5zYWN0aW9uKHJhd1R4KSksXG4gICAgICAgICAgICBzaWc6IHtcbiAgICAgICAgICAgICAgICB2OiBzaWdXaXRoVi52LFxuICAgICAgICAgICAgICAgIHI6IHNpZ1dpdGhWLnIudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIHM6IHNpZ1dpdGhWLnMudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25lcjogZXRoQWRkcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VycmVuY3kgPT09IGNvbnN0YW50c18xLkNVUlJFTkNJRVMuRVRIX01TRykge1xuICAgICAgICB2YXIgc2lnID0gKDAsIHV0aWxfMS5wYXJzZURFUikoZGF0YS5zbGljZShvZmYsIG9mZiArIDIgKyBkYXRhW29mZiArIDFdKSk7XG4gICAgICAgIG9mZiArPSBkZXJTaWdMZW47XG4gICAgICAgIHZhciBzaWduZXIgPSBkYXRhLnNsaWNlKG9mZiwgb2ZmICsgMjApO1xuICAgICAgICB2YXIgdmFsaWRhdGVkU2lnID0gZXRoZXJldW1fMS5kZWZhdWx0LnZhbGlkYXRlRXRoZXJldW1Nc2dSZXNwb25zZSh7IHNpZ25lcjogc2lnbmVyLCBzaWc6IHNpZyB9LCByZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZzoge1xuICAgICAgICAgICAgICAgIHY6IHZhbGlkYXRlZFNpZy52LFxuICAgICAgICAgICAgICAgIHI6IHZhbGlkYXRlZFNpZy5yLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICBzOiB2YWxpZGF0ZWRTaWcucy50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmVyOiBzaWduZXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBHZW5lcmljIHNpZ25pbmcgcmVxdWVzdFxuICAgICAgICByZXR1cm4gKDAsIGdlbmVyaWNTaWduaW5nXzEucGFyc2VHZW5lcmljU2lnbmluZ1Jlc3BvbnNlKShkYXRhLCBvZmYsIHJlcXVlc3QpO1xuICAgIH1cbn07XG5leHBvcnRzLmRlY29kZVNpZ25SZXNwb25zZSA9IGRlY29kZVNpZ25SZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbmNvZGVkUGF5bG9hZCA9IGV4cG9ydHMucGFyc2VHZW5lcmljU2lnbmluZ1Jlc3BvbnNlID0gZXhwb3J0cy5idWlsZEdlbmVyaWNTaWduaW5nTXNnUmVxdWVzdCA9IHZvaWQgMDtcbi8qKlxuR2VuZXJpYyBzaWduaW5nIG1vZHVsZS4gQW55IHBheWxvYWQgY2FuIGJlIHNlbnQgdG8gdGhlIExhdHRpY2UgYW5kXG53aWxsIGJlIGRpc3BsYXllZCBpbiBmdWxsIChub3RlIHRoYXQgXFxuIGFuZCBcXHQgY2hhcmFjdGVycyB3aWxsIGJlXG5kaXNwbGF5ZWQgYXMgbGluZSBicmVha3MgYW5kIHRhYnMgb24gdGhlIHNjcmVlbikuXG5cblRoaXMgcGF5bG9hZCBzaG91bGQgYmUgY291cGxlZCB3aXRoOlxuKiBTaWduZXIncyBCSVA0NCBwYXRoXG4qIEN1cnZlIG9uIHdoaWNoIHRvIGRlcml2ZSB0aGUgc2lnbmluZyBrZXlcbiogSGFzaCBmdW5jdGlvbiB0byB1c2Ugb24gdGhlIG1lc3NhZ2VcbiovXG52YXIgc2hhXzEgPSByZXF1aXJlKFwiaGFzaC5qcy9saWIvaGFzaC9zaGFcIik7XG52YXIganNfc2hhM18xID0gcmVxdWlyZShcImpzLXNoYTNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGJ1aWxkR2VuZXJpY1NpZ25pbmdNc2dSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSkge1xuICAgIHZhciBzaWduZXJQYXRoID0gcmVxLnNpZ25lclBhdGgsIGN1cnZlVHlwZSA9IHJlcS5jdXJ2ZVR5cGUsIGhhc2hUeXBlID0gcmVxLmhhc2hUeXBlLCBfYSA9IHJlcS5lbmNvZGluZ1R5cGUsIGVuY29kaW5nVHlwZSA9IF9hID09PSB2b2lkIDAgPyBudWxsIDogX2EsIF9iID0gcmVxLmRlY29kZXIsIGRlY29kZXIgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBfYyA9IHJlcS5vbWl0UHVia2V5LCBvbWl0UHVia2V5ID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIGZ3Q29uc3RhbnRzID0gcmVxLmZ3Q29uc3RhbnRzLCBfZCA9IHJlcS5ibHNEc3QsIGJsc0RzdCA9IF9kID09PSB2b2lkIDAgPyBpbmRleF8xLkNvbnN0YW50cy5TSUdOSU5HLkJMU19EU1QuQkxTX0RTVF9OVUwgOiBfZDtcbiAgICB2YXIgZXh0cmFEYXRhRnJhbWVTeiA9IGZ3Q29uc3RhbnRzLmV4dHJhRGF0YUZyYW1lU3osIGV4dHJhRGF0YU1heEZyYW1lcyA9IGZ3Q29uc3RhbnRzLmV4dHJhRGF0YU1heEZyYW1lcywgcHJlaGFzaEFsbG93ZWQgPSBmd0NvbnN0YW50cy5wcmVoYXNoQWxsb3dlZCwgZ2VuZXJpY1NpZ25pbmcgPSBmd0NvbnN0YW50cy5nZW5lcmljU2lnbmluZywgdmFyQWRkclBhdGhTekFsbG93ZWQgPSBmd0NvbnN0YW50cy52YXJBZGRyUGF0aFN6QWxsb3dlZDtcbiAgICB2YXIgY3VydmVUeXBlcyA9IGdlbmVyaWNTaWduaW5nLmN1cnZlVHlwZXMsIGVuY29kaW5nVHlwZXMgPSBnZW5lcmljU2lnbmluZy5lbmNvZGluZ1R5cGVzLCBoYXNoVHlwZXMgPSBnZW5lcmljU2lnbmluZy5oYXNoVHlwZXMsIGJhc2VEYXRhU3ogPSBnZW5lcmljU2lnbmluZy5iYXNlRGF0YVN6LCBiYXNlUmVxU3ogPSBnZW5lcmljU2lnbmluZy5iYXNlUmVxU3osIGNhbGxkYXRhRGVjb2RpbmcgPSBnZW5lcmljU2lnbmluZy5jYWxsZGF0YURlY29kaW5nO1xuICAgIHZhciBlbmNvZGVkUGF5bG9hZCA9ICgwLCBleHBvcnRzLmdldEVuY29kZWRQYXlsb2FkKShyZXEucGF5bG9hZCwgZW5jb2RpbmdUeXBlLCBlbmNvZGluZ1R5cGVzKTtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVkUGF5bG9hZC5lbmNvZGluZztcbiAgICB2YXIgcGF5bG9hZEJ1ZiA9IGVuY29kZWRQYXlsb2FkLnBheWxvYWRCdWY7XG4gICAgdmFyIG9yaWdQYXlsb2FkQnVmID0gcGF5bG9hZEJ1ZjtcbiAgICB2YXIgcGF5bG9hZERhdGFTeiA9IHBheWxvYWRCdWYubGVuZ3RoO1xuICAgIC8vIFNpemUgb2YgZGF0YSBwYXlsb2FkIHRoYXQgY2FuIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdC9iYXNlIHJlcXVlc3RcbiAgICB2YXIgbWF4RXhwYW5kZWRTeiA9IGJhc2VEYXRhU3ogKyBleHRyYURhdGFNYXhGcmFtZXMgKiBleHRyYURhdGFGcmFtZVN6O1xuICAgIC8vIFNhbml0eSBjaGVja3NcbiAgICBpZiAoIXBheWxvYWREYXRhU3opIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXlsb2FkIGNvdWxkIG5vdCBiZSBoYW5kbGVkLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICghZ2VuZXJpY1NpZ25pbmcgfHxcbiAgICAgICAgIWV4dHJhRGF0YUZyYW1lU3ogfHxcbiAgICAgICAgIWV4dHJhRGF0YU1heEZyYW1lcyB8fFxuICAgICAgICAhcHJlaGFzaEFsbG93ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSB5b3VyIExhdHRpY2UgZmlybXdhcmUuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEoMCwgdXRpbF8xLmV4aXN0c0luKShjdXJ2ZVR5cGUsIGN1cnZlVHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY3VydmUgdHlwZS4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoISgwLCB1dGlsXzEuZXhpc3RzSW4pKGhhc2hUeXBlLCBoYXNoVHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaGFzaCB0eXBlLicpO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGRlY29kZXIgYXR0YWNoZWQgdG8gb3VyIHBheWxvYWQsIGFkZCBpdCB0b1xuICAgIC8vIHRoZSBkYXRhIGZpZWxkIG9mIHRoZSByZXF1ZXN0LlxuICAgIHZhciBoYXNEZWNvZGVyID0gKGRlY29kZXIgJiYgY2FsbGRhdGFEZWNvZGluZyAmJiBkZWNvZGVyLmxlbmd0aCA8PSBjYWxsZGF0YURlY29kaW5nLm1heFN6KTtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIHBheWxvYWQgQU5EIGRlY29kZXIgZGF0YSBmaXRzIGluIHRoZSBmaXJtd2FyZSBidWZmZXIuXG4gICAgLy8gSWYgaXQgZG9lc24ndCwgd2UgY2FuJ3QgaW5jbHVkZSB0aGUgZGVjb2RlciBiZWNhdXNlIHRoZSBwYXlsb2FkIHdpbGwgbGlrZWx5XG4gICAgLy8gYmUgcHJlLWhhc2hlZCBhbmQgdGhlIGRlY29kZXIgZGF0YSBpc24ndCBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIHNpZ24uXG4gICAgdmFyIGRlY29kZXJGaXRzID0gKGhhc0RlY29kZXIgJiYgcGF5bG9hZEJ1Zi5sZW5ndGggKyBkZWNvZGVyLmxlbmd0aCA8PSBtYXhFeHBhbmRlZFN6KTtcbiAgICBpZiAoaGFzRGVjb2RlciAmJiBkZWNvZGVyRml0cykge1xuICAgICAgICB2YXIgZGVjb2RlckJ1ZiA9IEJ1ZmZlci5hbGxvYyg4ICsgZGVjb2Rlci5sZW5ndGgpO1xuICAgICAgICAvLyBGaXJzdCB3cml0ZSB0aCByZXNlcnZlZCB3b3JkXG4gICAgICAgIGRlY29kZXJCdWYud3JpdGVVSW50MzJMRShjYWxsZGF0YURlY29kaW5nLnJlc2VydmVkLCAwKTtcbiAgICAgICAgLy8gVGhlbiB3cml0ZSBzaXplLCB0aGVuIHRoZSBkYXRhXG4gICAgICAgIGRlY29kZXJCdWYud3JpdGVVSW50MzJMRShkZWNvZGVyLmxlbmd0aCwgNCk7XG4gICAgICAgIEJ1ZmZlci5mcm9tKGRlY29kZXIpLmNvcHkoZGVjb2RlckJ1ZiwgOCk7XG4gICAgICAgIHBheWxvYWRCdWYgPSBCdWZmZXIuY29uY2F0KFtwYXlsb2FkQnVmLCBkZWNvZGVyQnVmXSk7XG4gICAgfVxuICAgIC8vIEVkMjU1MTkgc3BlY2lmaWMgc2FuaXR5IGNoZWNrc1xuICAgIGlmIChjdXJ2ZVR5cGUgPT09IGN1cnZlVHlwZXMuRUQyNTUxOSkge1xuICAgICAgICBpZiAoaGFzaFR5cGUgIT09IGhhc2hUeXBlcy5OT05FKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25pbmcgb24gZWQyNTUxOSByZXF1aXJlcyB1bmhhc2hlZCBtZXNzYWdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmVyUGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIGlmIChpZHggPCBjb25zdGFudHNfMS5IQVJERU5FRF9PRkZTRVQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25pbmcgb24gZWQyNTUxOSByZXF1aXJlcyBhbGwgc2lnbmVyIHBhdGggaW5kaWNlcyBiZSBoYXJkZW5lZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEJMUzEyXzM4MSBzcGVjaWZpYyBwcm9jZXNzaW5nXG4gICAgZWxzZSBpZiAoY3VydmVUeXBlID09PSBjdXJ2ZVR5cGVzLkJMUzEyXzM4MV9HMikge1xuICAgICAgICAvLyBGb3IgQkxTIHNpZ25pbmcgd2UgbmVlZCB0byBwcmVmaXggNCBieXRlcyB0byByZXByZXNlbnQgdGhlXG4gICAgICAgIC8vIGRvbWFpbiBzZXBhcmF0b3IgKERTVCkuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHdlIHVzZSB0aGUgZGVmYXVsdFxuICAgICAgICAvLyB2YWx1ZSBvZiBEU1RfTlVMLlxuICAgICAgICB2YXIgYmxzRHN0QnVmID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICBibHNEc3RCdWYud3JpdGVVSW50MzJMRShibHNEc3QpO1xuICAgICAgICBwYXlsb2FkQnVmID0gQnVmZmVyLmNvbmNhdChbYmxzRHN0QnVmLCBwYXlsb2FkQnVmXSk7XG4gICAgICAgIHBheWxvYWREYXRhU3ogKz0gYmxzRHN0QnVmLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gQnVpbGQgdGhlIHJlcXVlc3QgYnVmZmVyIHdpdGggbWV0YWRhdGEgYW5kIHRoZW4gdGhlIHBheWxvYWQgdG8gc2lnbi5cbiAgICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKGJhc2VSZXFTeik7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgYnVmLndyaXRlVUludDMyTEUoZW5jb2RpbmcsIG9mZik7XG4gICAgb2ZmICs9IDQ7XG4gICAgYnVmLndyaXRlVUludDgoaGFzaFR5cGUsIG9mZik7XG4gICAgb2ZmICs9IDE7XG4gICAgYnVmLndyaXRlVUludDgoY3VydmVUeXBlLCBvZmYpO1xuICAgIG9mZiArPSAxO1xuICAgIHZhciBzaWduZXJQYXRoQnVmID0gKDAsIHV0aWxfMS5idWlsZFNpZ25lclBhdGhCdWYpKHNpZ25lclBhdGgsIHZhckFkZHJQYXRoU3pBbGxvd2VkKTtcbiAgICBzaWduZXJQYXRoQnVmLmNvcHkoYnVmLCBvZmYpO1xuICAgIG9mZiArPSBzaWduZXJQYXRoQnVmLmxlbmd0aDtcbiAgICBidWYud3JpdGVVSW50OChvbWl0UHVia2V5ID8gMSA6IDAsIG9mZik7XG4gICAgb2ZmICs9IDE7XG4gICAgLy8gRmxvdyBkYXRhIGludG8gZXh0cmFEYXRhIHJlcXVlc3RzIGlmIGFwcGxpY2FibGVcbiAgICB2YXIgZXh0cmFEYXRhUGF5bG9hZHMgPSBbXTtcbiAgICB2YXIgcHJlaGFzaCA9IG51bGw7XG4gICAgdmFyIGRpZFByZWhhc2ggPSBmYWxzZTtcbiAgICBpZiAocGF5bG9hZEJ1Zi5sZW5ndGggPiBiYXNlRGF0YVN6KSB7XG4gICAgICAgIGlmIChwcmVoYXNoQWxsb3dlZCAmJiBwYXlsb2FkQnVmLmxlbmd0aCA+IG1heEV4cGFuZGVkU3opIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHByZWhhc2gsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgZnVsbCBwYXlsb2FkIHNpemVcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKHBheWxvYWRCdWYubGVuZ3RoLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgICAgICBkaWRQcmVoYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgdG8gcHJlaGFzaCwgb25seSBoYXNoIHRoZSBhY3R1YWwgcGF5bG9hZCBkYXRhLCBpLmUuIGV4Y2x1ZGVcbiAgICAgICAgICAgIC8vIGFueSBvcHRpb25hbCBjYWxsZGF0YSBkZWNvZGVyIGRhdGEuXG4gICAgICAgICAgICB2YXIgcGF5bG9hZERhdGEgPSBwYXlsb2FkQnVmLnNsaWNlKDAsIHBheWxvYWREYXRhU3opO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBzZW5kLCBidXQgdGhlIExhdHRpY2UgYWxsb3dzIGEgcHJlaGFzaGVkIG1lc3NhZ2UsIGRvIHRoYXRcbiAgICAgICAgICAgIGlmIChoYXNoVHlwZSA9PT0gaGFzaFR5cGVzLk5PTkUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBkb25lIGZvciBFRDI1NTE5IHNpZ25pbmcsIHdoaWNoIG11c3Qgc2lnbiB0aGUgZnVsbCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIHRvbyBsYXJnZSB0byBzZW5kIGFuZCBjb3VsZCBub3QgYmUgcHJlaGFzaGVkIChoYXNoVHlwZT1OT05FKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc2hUeXBlID09PSBoYXNoVHlwZXMuS0VDQ0FLMjU2KSB7XG4gICAgICAgICAgICAgICAgcHJlaGFzaCA9IEJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShwYXlsb2FkRGF0YSksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc2hUeXBlID09PSBoYXNoVHlwZXMuU0hBMjU2KSB7XG4gICAgICAgICAgICAgICAgcHJlaGFzaCA9IEJ1ZmZlci5mcm9tKCgwLCBzaGFfMS5zaGEyNTYpKCkudXBkYXRlKHBheWxvYWREYXRhKS5kaWdlc3QoJ2hleCcpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGhhc2ggdHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNwbGl0IG92ZXJmbG93IGRhdGEgaW50byBleHRyYURhdGEgZnJhbWVzXG4gICAgICAgICAgICB2YXIgZnJhbWVzXzEgPSAoMCwgdXRpbF8xLnNwbGl0RnJhbWVzKShwYXlsb2FkQnVmLnNsaWNlKGJhc2VEYXRhU3opLCBleHRyYURhdGFGcmFtZVN6KTtcbiAgICAgICAgICAgIGZyYW1lc18xLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN6TEUgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgICAgICAgICAgc3pMRS53cml0ZVVJbnQzMkxFKGZyYW1lLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICAgICAgZXh0cmFEYXRhUGF5bG9hZHMucHVzaChCdWZmZXIuY29uY2F0KFtzekxFLCBmcmFtZV0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGRpZG4ndCBwcmVoYXNoLCB3ZSBrbm93IHRoZSBmdWxsIHJlcXVlc3QgKGluY2x1ZGluZyBjYWxsZGF0YSBpbmZvKSBmaXRzLlxuICAgIC8vIFNldCB0aGUgcGF5bG9hZCBzaXplIHRvIG9ubHkgaW5jbHVkZSBtZXNzYWdlIGRhdGEuIFRoaXMgd2lsbCBpbmZvcm0gZmlybXdhcmVcbiAgICAvLyB3aGVyZSB0byBzbGljZSBvZmYgY2FsbGRhdGEgaW5mby5cbiAgICBpZiAoIWRpZFByZWhhc2gpIHtcbiAgICAgICAgYnVmLndyaXRlVUludDE2TEUocGF5bG9hZERhdGFTeiwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgfVxuICAgIC8vIElmIHRoZSBtZXNzYWdlIGhhZCB0byBiZSBwcmVoYXNoZWQsIHdlIHdpbGwgb25seSBjb3B5IHRoZSBoYXNoIGRhdGEgaW50byB0aGUgcmVxdWVzdC5cbiAgICAvLyBPdGhlcndpc2UgY29weSBhcyBtYW55IHBheWxvYWQgYnl0ZXMgaW50byB0aGUgcmVxdWVzdCBhcyBwb3NzaWJsZS4gRm9sbG93IHVwIGRhdGFcbiAgICAvLyBmcm9tIGBmcmFtZXNgIHdpbGwgY29tZSBpbiBmb2xsb3cgdXAgcmVxdWVzdHMuXG4gICAgdmFyIHRvQ29weSA9IHByZWhhc2ggPyBwcmVoYXNoIDogcGF5bG9hZEJ1ZjtcbiAgICB0b0NvcHkuY29weShidWYsIG9mZik7XG4gICAgLy8gUmV0dXJuIGFsbCB0aGUgbmVjZXNzYXJ5IGRhdGFcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXlsb2FkOiBidWYsXG4gICAgICAgIGV4dHJhRGF0YVBheWxvYWRzOiBleHRyYURhdGFQYXlsb2FkcyxcbiAgICAgICAgc2NoZW1hOiBwcm90b2NvbF8xLkxhdHRpY2VTaWduU2NoZW1hLmdlbmVyaWMsXG4gICAgICAgIGN1cnZlVHlwZTogY3VydmVUeXBlLFxuICAgICAgICBlbmNvZGluZ1R5cGU6IGVuY29kaW5nVHlwZSxcbiAgICAgICAgaGFzaFR5cGU6IGhhc2hUeXBlLFxuICAgICAgICBvbWl0UHVia2V5OiBvbWl0UHVia2V5LFxuICAgICAgICBvcmlnUGF5bG9hZEJ1Zjogb3JpZ1BheWxvYWRCdWYsXG4gICAgfTtcbn07XG5leHBvcnRzLmJ1aWxkR2VuZXJpY1NpZ25pbmdNc2dSZXF1ZXN0ID0gYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3Q7XG52YXIgcGFyc2VHZW5lcmljU2lnbmluZ1Jlc3BvbnNlID0gZnVuY3Rpb24gKHJlcywgb2ZmLCByZXEpIHtcbiAgICB2YXIgcGFyc2VkID0ge1xuICAgICAgICBwdWJrZXk6IG51bGwsXG4gICAgICAgIHNpZzogbnVsbCxcbiAgICB9O1xuICAgIC8vIFBhcnNlIEJJUDQ0IHBhdGhcbiAgICAvLyBQYXJzZSBwdWJrZXkgYW5kIHRoZW4gc2lnXG4gICAgaWYgKHJlcS5jdXJ2ZVR5cGUgPT09IGluZGV4XzEuQ29uc3RhbnRzLlNJR05JTkcuQ1VSVkVTLlNFQ1AyNTZLMSkge1xuICAgICAgICAvLyBIYW5kbGUgYEdwRWNjUHVia2V5MjU2X3RgXG4gICAgICAgIGlmICghcmVxLm9taXRQdWJrZXkpIHtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHJlcy5yZWFkVUludDgob2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSAweDAyIHx8IGNvbXByZXNzaW9uID09PSAweDAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHJlc3NlZCBrZXkgLSBvbmx5IGNvcHkgeFxuICAgICAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkgPSBCdWZmZXIuYWxsb2MoMzMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkud3JpdGVVSW50OChjb21wcmVzc2lvbiwgMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNsaWNlKG9mZiwgb2ZmICsgMzIpLmNvcHkocGFyc2VkLnB1YmtleSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wcmVzc2lvbiA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIC8vIFVuY29tcHJlc3NlZCBrZXlcbiAgICAgICAgICAgICAgICBwYXJzZWQucHVia2V5ID0gQnVmZmVyLmFsbG9jKDY1KTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucHVia2V5LndyaXRlVUludDgoY29tcHJlc3Npb24sIDApO1xuICAgICAgICAgICAgICAgIHJlcy5zbGljZShvZmYpLmNvcHkocGFyc2VkLnB1YmtleSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBjb21wcmVzc2lvbiBieXRlIGluIHNpZ25pbmcgcmVzcG9uc2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTa2lwIHB1YmtleSBzZWN0aW9uXG4gICAgICAgICAgICBvZmYgKz0gNjU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGBHcEVDRFNBU2lnX3RgXG4gICAgICAgIHBhcnNlZC5zaWcgPSAoMCwgdXRpbF8xLnBhcnNlREVSKShyZXMuc2xpY2Uob2ZmLCBvZmYgKyAyICsgcmVzW29mZiArIDFdKSk7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgbGVhZGluZyB6ZXJvcyBpbiBzaWduYXR1cmUgY29tcG9uZW50cyB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhlIHJlc3VsdCBpcyBhIDY0IGJ5dGUgc2lnXG4gICAgICAgIHBhcnNlZC5zaWcuciA9ICgwLCB1dGlsXzEuZml4TGVuKShwYXJzZWQuc2lnLnIsIDMyKTtcbiAgICAgICAgcGFyc2VkLnNpZy5zID0gKDAsIHV0aWxfMS5maXhMZW4pKHBhcnNlZC5zaWcucywgMzIpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIEVWTSByZXF1ZXN0LCB3ZSB3YW50IHRvIGFkZCBhIGB2YC4gT3RoZXIgcmVxdWVzdFxuICAgICAgICAvLyB0eXBlcyBkbyBub3QgcmVxdWlyZSB0aGlzIGFkZGl0aW9uYWwgc2lnbmF0dXJlIHBhcmFtLlxuICAgICAgICBpZiAocmVxLmVuY29kaW5nVHlwZSA9PT0gaW5kZXhfMS5Db25zdGFudHMuU0lHTklORy5FTkNPRElOR1MuRVZNKSB7XG4gICAgICAgICAgICB2YXIgdkJuID0gKDAsIHV0aWxfMS5nZXRWKShyZXEub3JpZ1BheWxvYWRCdWYsIHBhcnNlZCk7XG4gICAgICAgICAgICAvLyBOT1RFOiBGb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSByZWFzb25zIHdlIGFyZSByZXR1cm5pbmdcbiAgICAgICAgICAgIC8vIGEgQnVmZmVyIGZvciBgdmAgaGVyZS4gSW4gdGhlIGZ1dHVyZSwgd2Ugd2lsbCBzd2l0Y2ggdG9cbiAgICAgICAgICAgIC8vIHJldHVybmluZyBgdmAgYXMgYSBCTiBhbmQgYHJgLGBzYCBhcyBCdWZmZXJzICh0aGV5IGFyZSBoZXhcbiAgICAgICAgICAgIC8vIHN0cmluZ3MgcmlnaHQgbm93KS5cbiAgICAgICAgICAgIHBhcnNlZC5zaWcudiA9IHZCbi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcS5jdXJ2ZVR5cGUgPT09IGluZGV4XzEuQ29uc3RhbnRzLlNJR05JTkcuQ1VSVkVTLkVEMjU1MTkpIHtcbiAgICAgICAgaWYgKCFyZXEub21pdFB1YmtleSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGBHcEVkRFNBUHVia2V5X3RgXG4gICAgICAgICAgICBwYXJzZWQucHVia2V5ID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICAgICAgICAgIHJlcy5zbGljZShvZmYsIG9mZiArIDMyKS5jb3B5KHBhcnNlZC5wdWJrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSAzMjtcbiAgICAgICAgLy8gSGFuZGxlIGBHcEVkRFNBU2lnX3RgXG4gICAgICAgIHBhcnNlZC5zaWcgPSB7XG4gICAgICAgICAgICByOiByZXMuc2xpY2Uob2ZmLCBvZmYgKyAzMiksXG4gICAgICAgICAgICBzOiByZXMuc2xpY2Uob2ZmICsgMzIsIG9mZiArIDY0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVxLmN1cnZlVHlwZSA9PT0gaW5kZXhfMS5Db25zdGFudHMuU0lHTklORy5DVVJWRVMuQkxTMTJfMzgxX0cyKSB7XG4gICAgICAgIGlmICghcmVxLm9taXRQdWJrZXkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBgR3BCTFMxMl8zODFfRzFQdWJfdGBcbiAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkgPSBCdWZmZXIuYWxsb2MoNDgpO1xuICAgICAgICAgICAgcmVzLnNsaWNlKG9mZiwgb2ZmICsgNDgpLmNvcHkocGFyc2VkLnB1YmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDQ4O1xuICAgICAgICAvLyBIYW5kbGUgYEdwQkxTMTJfMzgxX0cyU2lnX3RgXG4gICAgICAgIHBhcnNlZC5zaWcgPSBCdWZmZXIuYWxsb2MoOTYpO1xuICAgICAgICByZXMuc2xpY2Uob2ZmLCBvZmYgKyA5NikuY29weShwYXJzZWQuc2lnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY3VydmUuJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuZXhwb3J0cy5wYXJzZUdlbmVyaWNTaWduaW5nUmVzcG9uc2UgPSBwYXJzZUdlbmVyaWNTaWduaW5nUmVzcG9uc2U7XG52YXIgZ2V0RW5jb2RlZFBheWxvYWQgPSBmdW5jdGlvbiAocGF5bG9hZCwgZW5jb2RpbmcsIGFsbG93ZWRFbmNvZGluZ3MpIHtcbiAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgIGVuY29kaW5nID0gaW5kZXhfMS5Db25zdGFudHMuU0lHTklORy5FTkNPRElOR1MuTk9ORTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBlbmNvZGluZyB0eXBlIHNwZWNpZmllZCBpcyBzdXBwb3J0ZWQgYnkgZmlybXdhcmVcbiAgICBpZiAoISgwLCB1dGlsXzEuZXhpc3RzSW4pKGVuY29kaW5nLCBhbGxvd2VkRW5jb2RpbmdzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG5vdCBzdXBwb3J0ZWQgYnkgTGF0dGljZSBmaXJtd2FyZS4gWW91IG1heSB3YW50IHRvIHVwZGF0ZS4nKTtcbiAgICB9XG4gICAgdmFyIHBheWxvYWRCdWY7XG4gICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGF5bG9hZCBpbmNsdWRlZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnICYmIHBheWxvYWQuc2xpY2UoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgcGF5bG9hZEJ1ZiA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuc2xpY2UoMiksICdoZXgnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBheWxvYWRCdWYgPSBCdWZmZXIuZnJvbShwYXlsb2FkKTtcbiAgICB9XG4gICAgLy8gQnVpbGQgdGhlIHJlcXVlc3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGVuY29kaW5nIHR5cGVcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXlsb2FkQnVmOiBwYXlsb2FkQnVmLFxuICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgfTtcbn07XG5leHBvcnRzLmdldEVuY29kZWRQYXlsb2FkID0gZ2V0RW5jb2RlZFBheWxvYWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VdGlscyA9IGV4cG9ydHMuQ29uc3RhbnRzID0gZXhwb3J0cy5DbGllbnQgPSBleHBvcnRzLkNhbGxkYXRhID0gdm9pZCAwO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi9jYWxsZGF0YS9pbmRleFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxkYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF8xLkNBTExEQVRBOyB9IH0pO1xudmFyIGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfMS5DbGllbnQ7IH0gfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdGFudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLkVYVEVSTkFMOyB9IH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbF8xLkVYVEVSTkFMOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FwaVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xhdHRpY2VDb25zdGFudHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlY3VyZU1lc3NhZ2VzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9hLCBfYiwgX2M7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb3RvY29sQ29uc3RhbnRzID0gZXhwb3J0cy5MYXR0aWNlRW5jRGF0YVNjaGVtYSA9IGV4cG9ydHMuTGF0dGljZVNpZ25CbHNEc3QgPSBleHBvcnRzLkxhdHRpY2VTaWduRW5jb2RpbmcgPSBleHBvcnRzLkxhdHRpY2VTaWduQ3VydmUgPSBleHBvcnRzLkxhdHRpY2VTaWduSGFzaCA9IGV4cG9ydHMuTGF0dGljZVNpZ25TY2hlbWEgPSBleHBvcnRzLkxhdHRpY2VHZXRBZGRyZXNzZXNGbGFnID0gZXhwb3J0cy5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUgPSBleHBvcnRzLkxhdHRpY2VNc2dUeXBlID0gZXhwb3J0cy5MYXR0aWNlUHJvdG9jb2xWZXJzaW9uID0gZXhwb3J0cy5MYXR0aWNlU2VjdXJlTXNnVHlwZSA9IGV4cG9ydHMuTGF0dGljZVJlc3BvbnNlQ29kZSA9IHZvaWQgMDtcbnZhciBMYXR0aWNlUmVzcG9uc2VDb2RlO1xuKGZ1bmN0aW9uIChMYXR0aWNlUmVzcG9uc2VDb2RlKSB7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wic3VjY2Vzc1wiXSA9IDBdID0gXCJzdWNjZXNzXCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wiaW52YWxpZE1zZ1wiXSA9IDEyOF0gPSBcImludmFsaWRNc2dcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJ1bnN1cHBvcnRlZFZlcnNpb25cIl0gPSAxMjldID0gXCJ1bnN1cHBvcnRlZFZlcnNpb25cIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJkZXZpY2VCdXN5XCJdID0gMTMwXSA9IFwiZGV2aWNlQnVzeVwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcInVzZXJUaW1lb3V0XCJdID0gMTMxXSA9IFwidXNlclRpbWVvdXRcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJ1c2VyRGVjbGluZWRcIl0gPSAxMzJdID0gXCJ1c2VyRGVjbGluZWRcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJwYWlyRmFpbGVkXCJdID0gMTMzXSA9IFwicGFpckZhaWxlZFwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcInBhaXJEaXNhYmxlZFwiXSA9IDEzNF0gPSBcInBhaXJEaXNhYmxlZFwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcInBlcm1pc3Npb25EaXNhYmxlZFwiXSA9IDEzNV0gPSBcInBlcm1pc3Npb25EaXNhYmxlZFwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcImludGVybmFsRXJyb3JcIl0gPSAxMzZdID0gXCJpbnRlcm5hbEVycm9yXCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wiZ2NlVGltZW91dFwiXSA9IDEzN10gPSBcImdjZVRpbWVvdXRcIjtcbiAgICBMYXR0aWNlUmVzcG9uc2VDb2RlW0xhdHRpY2VSZXNwb25zZUNvZGVbXCJ3cm9uZ1dhbGxldFwiXSA9IDEzOF0gPSBcIndyb25nV2FsbGV0XCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wiZGV2aWNlTG9ja2VkXCJdID0gMTM5XSA9IFwiZGV2aWNlTG9ja2VkXCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wiZGlzYWJsZWRcIl0gPSAxNDBdID0gXCJkaXNhYmxlZFwiO1xuICAgIExhdHRpY2VSZXNwb25zZUNvZGVbTGF0dGljZVJlc3BvbnNlQ29kZVtcImFscmVhZHlcIl0gPSAxNDFdID0gXCJhbHJlYWR5XCI7XG4gICAgTGF0dGljZVJlc3BvbnNlQ29kZVtMYXR0aWNlUmVzcG9uc2VDb2RlW1wiaW52YWxpZEVwaGVtSWRcIl0gPSAxNDJdID0gXCJpbnZhbGlkRXBoZW1JZFwiO1xufSkoTGF0dGljZVJlc3BvbnNlQ29kZSA9IGV4cG9ydHMuTGF0dGljZVJlc3BvbnNlQ29kZSB8fCAoZXhwb3J0cy5MYXR0aWNlUmVzcG9uc2VDb2RlID0ge30pKTtcbnZhciBMYXR0aWNlU2VjdXJlTXNnVHlwZTtcbihmdW5jdGlvbiAoTGF0dGljZVNlY3VyZU1zZ1R5cGUpIHtcbiAgICBMYXR0aWNlU2VjdXJlTXNnVHlwZVtMYXR0aWNlU2VjdXJlTXNnVHlwZVtcImNvbm5lY3RcIl0gPSAxXSA9IFwiY29ubmVjdFwiO1xuICAgIExhdHRpY2VTZWN1cmVNc2dUeXBlW0xhdHRpY2VTZWN1cmVNc2dUeXBlW1wiZW5jcnlwdGVkXCJdID0gMl0gPSBcImVuY3J5cHRlZFwiO1xufSkoTGF0dGljZVNlY3VyZU1zZ1R5cGUgPSBleHBvcnRzLkxhdHRpY2VTZWN1cmVNc2dUeXBlIHx8IChleHBvcnRzLkxhdHRpY2VTZWN1cmVNc2dUeXBlID0ge30pKTtcbnZhciBMYXR0aWNlUHJvdG9jb2xWZXJzaW9uO1xuKGZ1bmN0aW9uIChMYXR0aWNlUHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgTGF0dGljZVByb3RvY29sVmVyc2lvbltMYXR0aWNlUHJvdG9jb2xWZXJzaW9uW1widjFcIl0gPSAxXSA9IFwidjFcIjtcbn0pKExhdHRpY2VQcm90b2NvbFZlcnNpb24gPSBleHBvcnRzLkxhdHRpY2VQcm90b2NvbFZlcnNpb24gfHwgKGV4cG9ydHMuTGF0dGljZVByb3RvY29sVmVyc2lvbiA9IHt9KSk7XG52YXIgTGF0dGljZU1zZ1R5cGU7XG4oZnVuY3Rpb24gKExhdHRpY2VNc2dUeXBlKSB7XG4gICAgTGF0dGljZU1zZ1R5cGVbTGF0dGljZU1zZ1R5cGVbXCJyZXNwb25zZVwiXSA9IDBdID0gXCJyZXNwb25zZVwiO1xuICAgIExhdHRpY2VNc2dUeXBlW0xhdHRpY2VNc2dUeXBlW1wic2VjdXJlXCJdID0gMl0gPSBcInNlY3VyZVwiO1xufSkoTGF0dGljZU1zZ1R5cGUgPSBleHBvcnRzLkxhdHRpY2VNc2dUeXBlIHx8IChleHBvcnRzLkxhdHRpY2VNc2dUeXBlID0ge30pKTtcbnZhciBMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGU7XG4oZnVuY3Rpb24gKExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZSkge1xuICAgIExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbXCJmaW5hbGl6ZVBhaXJpbmdcIl0gPSAwXSA9IFwiZmluYWxpemVQYWlyaW5nXCI7XG4gICAgTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtcImdldEFkZHJlc3Nlc1wiXSA9IDFdID0gXCJnZXRBZGRyZXNzZXNcIjtcbiAgICBMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW1wic2lnblwiXSA9IDNdID0gXCJzaWduXCI7XG4gICAgTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtcImdldFdhbGxldHNcIl0gPSA0XSA9IFwiZ2V0V2FsbGV0c1wiO1xuICAgIExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbXCJnZXRLdlJlY29yZHNcIl0gPSA3XSA9IFwiZ2V0S3ZSZWNvcmRzXCI7XG4gICAgTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtcImFkZEt2UmVjb3Jkc1wiXSA9IDhdID0gXCJhZGRLdlJlY29yZHNcIjtcbiAgICBMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlW1wicmVtb3ZlS3ZSZWNvcmRzXCJdID0gOV0gPSBcInJlbW92ZUt2UmVjb3Jkc1wiO1xuICAgIExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbXCJmZXRjaEVuY3J5cHRlZERhdGFcIl0gPSAxMl0gPSBcImZldGNoRW5jcnlwdGVkRGF0YVwiO1xuICAgIExhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZVtMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGVbXCJ0ZXN0XCJdID0gMTNdID0gXCJ0ZXN0XCI7XG59KShMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUgPSBleHBvcnRzLkxhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZSB8fCAoZXhwb3J0cy5MYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUgPSB7fSkpO1xudmFyIExhdHRpY2VHZXRBZGRyZXNzZXNGbGFnO1xuKGZ1bmN0aW9uIChMYXR0aWNlR2V0QWRkcmVzc2VzRmxhZykge1xuICAgIExhdHRpY2VHZXRBZGRyZXNzZXNGbGFnW0xhdHRpY2VHZXRBZGRyZXNzZXNGbGFnW1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWdbTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWdbXCJzZWNwMjU2azFQdWJrZXlcIl0gPSAzXSA9IFwic2VjcDI1NmsxUHVia2V5XCI7XG4gICAgTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWdbTGF0dGljZUdldEFkZHJlc3Nlc0ZsYWdbXCJlZDI1NTE5UHVia2V5XCJdID0gNF0gPSBcImVkMjU1MTlQdWJrZXlcIjtcbiAgICBMYXR0aWNlR2V0QWRkcmVzc2VzRmxhZ1tMYXR0aWNlR2V0QWRkcmVzc2VzRmxhZ1tcImJsczEyXzM4MVB1YmtleVwiXSA9IDVdID0gXCJibHMxMl8zODFQdWJrZXlcIjtcbn0pKExhdHRpY2VHZXRBZGRyZXNzZXNGbGFnID0gZXhwb3J0cy5MYXR0aWNlR2V0QWRkcmVzc2VzRmxhZyB8fCAoZXhwb3J0cy5MYXR0aWNlR2V0QWRkcmVzc2VzRmxhZyA9IHt9KSk7XG52YXIgTGF0dGljZVNpZ25TY2hlbWE7XG4oZnVuY3Rpb24gKExhdHRpY2VTaWduU2NoZW1hKSB7XG4gICAgTGF0dGljZVNpZ25TY2hlbWFbTGF0dGljZVNpZ25TY2hlbWFbXCJiaXRjb2luXCJdID0gMF0gPSBcImJpdGNvaW5cIjtcbiAgICBMYXR0aWNlU2lnblNjaGVtYVtMYXR0aWNlU2lnblNjaGVtYVtcImV0aGVyZXVtXCJdID0gMV0gPSBcImV0aGVyZXVtXCI7XG4gICAgTGF0dGljZVNpZ25TY2hlbWFbTGF0dGljZVNpZ25TY2hlbWFbXCJldGhlcmV1bU1zZ1wiXSA9IDNdID0gXCJldGhlcmV1bU1zZ1wiO1xuICAgIExhdHRpY2VTaWduU2NoZW1hW0xhdHRpY2VTaWduU2NoZW1hW1wiZXh0cmFEYXRhXCJdID0gNF0gPSBcImV4dHJhRGF0YVwiO1xuICAgIExhdHRpY2VTaWduU2NoZW1hW0xhdHRpY2VTaWduU2NoZW1hW1wiZ2VuZXJpY1wiXSA9IDVdID0gXCJnZW5lcmljXCI7XG59KShMYXR0aWNlU2lnblNjaGVtYSA9IGV4cG9ydHMuTGF0dGljZVNpZ25TY2hlbWEgfHwgKGV4cG9ydHMuTGF0dGljZVNpZ25TY2hlbWEgPSB7fSkpO1xudmFyIExhdHRpY2VTaWduSGFzaDtcbihmdW5jdGlvbiAoTGF0dGljZVNpZ25IYXNoKSB7XG4gICAgTGF0dGljZVNpZ25IYXNoW0xhdHRpY2VTaWduSGFzaFtcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgIExhdHRpY2VTaWduSGFzaFtMYXR0aWNlU2lnbkhhc2hbXCJrZWNjYWsyNTZcIl0gPSAxXSA9IFwia2VjY2FrMjU2XCI7XG4gICAgTGF0dGljZVNpZ25IYXNoW0xhdHRpY2VTaWduSGFzaFtcInNoYTI1NlwiXSA9IDJdID0gXCJzaGEyNTZcIjtcbn0pKExhdHRpY2VTaWduSGFzaCA9IGV4cG9ydHMuTGF0dGljZVNpZ25IYXNoIHx8IChleHBvcnRzLkxhdHRpY2VTaWduSGFzaCA9IHt9KSk7XG52YXIgTGF0dGljZVNpZ25DdXJ2ZTtcbihmdW5jdGlvbiAoTGF0dGljZVNpZ25DdXJ2ZSkge1xuICAgIExhdHRpY2VTaWduQ3VydmVbTGF0dGljZVNpZ25DdXJ2ZVtcInNlY3AyNTZrMVwiXSA9IDBdID0gXCJzZWNwMjU2azFcIjtcbiAgICBMYXR0aWNlU2lnbkN1cnZlW0xhdHRpY2VTaWduQ3VydmVbXCJlZDI1NTE5XCJdID0gMV0gPSBcImVkMjU1MTlcIjtcbiAgICBMYXR0aWNlU2lnbkN1cnZlW0xhdHRpY2VTaWduQ3VydmVbXCJibHMxMl8zODFcIl0gPSAyXSA9IFwiYmxzMTJfMzgxXCI7XG59KShMYXR0aWNlU2lnbkN1cnZlID0gZXhwb3J0cy5MYXR0aWNlU2lnbkN1cnZlIHx8IChleHBvcnRzLkxhdHRpY2VTaWduQ3VydmUgPSB7fSkpO1xudmFyIExhdHRpY2VTaWduRW5jb2Rpbmc7XG4oZnVuY3Rpb24gKExhdHRpY2VTaWduRW5jb2RpbmcpIHtcbiAgICBMYXR0aWNlU2lnbkVuY29kaW5nW0xhdHRpY2VTaWduRW5jb2RpbmdbXCJub25lXCJdID0gMV0gPSBcIm5vbmVcIjtcbiAgICBMYXR0aWNlU2lnbkVuY29kaW5nW0xhdHRpY2VTaWduRW5jb2RpbmdbXCJzb2xhbmFcIl0gPSAyXSA9IFwic29sYW5hXCI7XG4gICAgTGF0dGljZVNpZ25FbmNvZGluZ1tMYXR0aWNlU2lnbkVuY29kaW5nW1wiZXZtXCJdID0gNF0gPSBcImV2bVwiO1xuICAgIExhdHRpY2VTaWduRW5jb2RpbmdbTGF0dGljZVNpZ25FbmNvZGluZ1tcImV0aF9kZXBvc2l0XCJdID0gNV0gPSBcImV0aF9kZXBvc2l0XCI7XG59KShMYXR0aWNlU2lnbkVuY29kaW5nID0gZXhwb3J0cy5MYXR0aWNlU2lnbkVuY29kaW5nIHx8IChleHBvcnRzLkxhdHRpY2VTaWduRW5jb2RpbmcgPSB7fSkpO1xudmFyIExhdHRpY2VTaWduQmxzRHN0O1xuKGZ1bmN0aW9uIChMYXR0aWNlU2lnbkJsc0RzdCkge1xuICAgIExhdHRpY2VTaWduQmxzRHN0W0xhdHRpY2VTaWduQmxzRHN0W1wiTlVMXCJdID0gMV0gPSBcIk5VTFwiO1xuICAgIExhdHRpY2VTaWduQmxzRHN0W0xhdHRpY2VTaWduQmxzRHN0W1wiUE9QXCJdID0gMl0gPSBcIlBPUFwiO1xufSkoTGF0dGljZVNpZ25CbHNEc3QgPSBleHBvcnRzLkxhdHRpY2VTaWduQmxzRHN0IHx8IChleHBvcnRzLkxhdHRpY2VTaWduQmxzRHN0ID0ge30pKTtcbnZhciBMYXR0aWNlRW5jRGF0YVNjaGVtYTtcbihmdW5jdGlvbiAoTGF0dGljZUVuY0RhdGFTY2hlbWEpIHtcbiAgICBMYXR0aWNlRW5jRGF0YVNjaGVtYVtMYXR0aWNlRW5jRGF0YVNjaGVtYVtcImVpcDIzMzVcIl0gPSAwXSA9IFwiZWlwMjMzNVwiO1xufSkoTGF0dGljZUVuY0RhdGFTY2hlbWEgPSBleHBvcnRzLkxhdHRpY2VFbmNEYXRhU2NoZW1hIHx8IChleHBvcnRzLkxhdHRpY2VFbmNEYXRhU2NoZW1hID0ge30pKTtcbmV4cG9ydHMuUHJvdG9jb2xDb25zdGFudHMgPSB7XG4gICAgLy8gTGF0dGljZSBmaXJtd2FyZSB1c2VzIGEgc3RhdGljIGluaXRpYWxpemF0aW9uIHZlY3RvciBmb3JcbiAgICAvLyBtZXNzYWdlIGVuY3J5cHRpb24vZGVjcnlwdGlvbi4gVGhpcyBpcyBnZW5lcmFsbHkgY29uc2lkZXJlZFxuICAgIC8vIGZpbmUgYmVjYXVzZSBlYWNoIGVuY3J5cHRpb24vZGVjcnlwdGlvbiB1c2VzIGEgdW5pcXVlIGVuY3J5cHRpb25cbiAgICAvLyBzZWNyZXQgKGRlcml2ZWQgZnJvbSB0aGUgcGVyLW1lc3NhZ2UgZXBoZW1lcmFsIGtleSBwYWlyKS5cbiAgICBhZXNJdjogW1xuICAgICAgICAweDZkLCAweDc5LCAweDczLCAweDY1LCAweDYzLCAweDcyLCAweDY1LCAweDc0LCAweDcwLCAweDYxLCAweDczLCAweDczLFxuICAgICAgICAweDc3LCAweDZmLCAweDcyLCAweDY0LFxuICAgIF0sXG4gICAgLy8gQ29uc3RhbnQgc2l6ZSBvZiBhZGRyZXNzIGJ1ZmZlcnMgZnJvbSB0aGUgTGF0dGljZS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaXplIGFsc28gY2FwdHVyZXMgcHVibGljIGtleXMgcmV0dXJuZWRcbiAgICAvLyBieSB0aGUgTGF0dGljZSAoYWRkcmVzc2VzID0gc3RyaW5ncywgcHVia2V5cyA9IGJ1ZmZlcnMpXG4gICAgYWRkclN0ckxlbjogMTI5LFxuICAgIC8vIFN0YXR1cyBvZiB0aGUgY2xpZW50J3MgcGFpcmluZyB3aXRoIHRoZSB0YXJnZXQgTGF0dGljZVxuICAgIHBhaXJpbmdTdGF0dXM6IHtcbiAgICAgICAgbm90UGFpcmVkOiAweDAwLFxuICAgICAgICBwYWlyZWQ6IDB4MDEsXG4gICAgfSxcbiAgICAvLyBSZXNwb25zZSB0eXBlcywgY29kZXMsIGFuZCBlcnJvciBtZXNzYWdlc1xuICAgIHJlc3BvbnNlTXNnOiAoX2EgPSB7fSxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5zdWNjZXNzXSA9ICcnLFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLmludmFsaWRNc2ddID0gJ0ludmFsaWQgUmVxdWVzdCcsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUudW5zdXBwb3J0ZWRWZXJzaW9uXSA9ICdVbnN1cHBvcnRlZCBWZXJzaW9uJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5kZXZpY2VCdXN5XSA9ICdEZXZpY2UgQnVzeScsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUudXNlclRpbWVvdXRdID0gJ1RpbWVvdXQgd2FpdGluZyBmb3IgdXNlcicsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUudXNlckRlY2xpbmVkXSA9ICdSZXF1ZXN0IGRlY2xpbmVkIGJ5IHVzZXInLFxuICAgICAgICBfYVtMYXR0aWNlUmVzcG9uc2VDb2RlLnBhaXJGYWlsZWRdID0gJ1BhaXJpbmcgZmFpbGVkJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5wYWlyRGlzYWJsZWRdID0gJ1BhaXJpbmcgaXMgY3VycmVudGx5IGRpc2FibGVkJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5wZXJtaXNzaW9uRGlzYWJsZWRdID0gJ0F1dG9tYXRlZCBzaWduaW5nIGlzIGN1cnJlbnRseSBkaXNhYmxlZCcsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUuaW50ZXJuYWxFcnJvcl0gPSAnRGV2aWNlIEVycm9yJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5nY2VUaW1lb3V0XSA9ICdEZXZpY2UgVGltZW91dCcsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUud3JvbmdXYWxsZXRdID0gJ0FjdGl2ZSB3YWxsZXQgZG9lcyBub3QgbWF0Y2ggcmVxdWVzdCcsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUuZGV2aWNlTG9ja2VkXSA9ICdEZXZpY2UgTG9ja2VkJyxcbiAgICAgICAgX2FbTGF0dGljZVJlc3BvbnNlQ29kZS5kaXNhYmxlZF0gPSAnRmVhdHVyZSBEaXNhYmxlZCcsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUuYWxyZWFkeV0gPSAnUmVjb3JkIGFscmVhZHkgZXhpc3RzIG9uIGRldmljZScsXG4gICAgICAgIF9hW0xhdHRpY2VSZXNwb25zZUNvZGUuaW52YWxpZEVwaGVtSWRdID0gJ1JlcXVlc3QgZmFpbGVkIC0gbmVlZHMgcmVzeW5jJyxcbiAgICAgICAgX2EpLFxuICAgIG1zZ1NpemVzOiB7XG4gICAgICAgIC8vIEdlbmVyYWwgbWVzc2FnZSBoZWFkZXIgc2l6ZS4gVmFsaWQgZm9yIGFsbCBMYXR0aWNlIG1lc3NhZ2VzXG4gICAgICAgIGhlYWRlcjogOCxcbiAgICAgICAgLy8gQ2hlY2tzdW0gbXVzdCBiZSBhcHBlbmRlZCB0byBlYWNoIG1lc3NhZ2VcbiAgICAgICAgY2hlY2tzdW06IDQsXG4gICAgICAgIC8vIExhdHRpY2Ugc2VjdXJlIG1lc3NhZ2UgY29uc3RhbnRzLiBBbGwgcmVxdWVzdHMgZnJvbSB0aGlzIFNES1xuICAgICAgICAvLyBhcmUgc2VjdXJlIG1lc3NhZ2VzLlxuICAgICAgICBzZWN1cmU6IHtcbiAgICAgICAgICAgIC8vIFNpemVzIG9mIGZ1bGwgcGF5bG9hZHMgZm9yIHNlY3VyZSBtZXNzYWdlc1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWyByZXF1ZXN0VHlwZSAoMSBieXRlKSB8IHB1YmtleSAoNjUgYnl0ZXMpIF1cbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdDogNjYsXG4gICAgICAgICAgICAgICAgICAgIC8vIFsgcmVxdWVzdFR5cGUgKDEgYnl0ZSkgfCBlcGhlbWVyYWxJZCAoNCBieXRlcykgfCBlbmNyeXB0ZWREYXRhICgxNzI4IGJ5dGVzKSBdXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZDogMTczMyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcmVzcG9uc2UgcGF5bG9hZCBhbHdheXMgaGFzIHN0YXR1cyBjb2RlIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGJ5dGUuIFRoaXMgYnl0ZSBpcyByZW1vdmVkIGFzIHBhcnQgb2YgYHJlcXVlc3RgLCBpbnNpZGVcbiAgICAgICAgICAgICAgICAvLyBgcGFyc2VMYXR0aWNlMVJlc3BvbnNlYC4gVGhlc2UgY29uc3RhbnRzIGluY2x1ZGUgdGhlIHN0YXR1c1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgYnl0ZS5cbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiAyMTUsXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY3J5cHRlZCByZXNwb25zZXMgYXJlIGFzIGZvbGxvd3M6XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuY3J5cHRlZERhdGEgKDE3MjgpIHwgZW1wdHkgKDE3MjgpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsYXR0ZXIgaGFsZiBpcyBlbXB0eSBkdWUgdG8gYW4gaW52YWxpZCB0eXBlIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gTGF0dGljZSBmaXJtd2FyZS4gKFNvbWVvbmUgbWFkZSBhIEMgYHN0cnVjdGAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBhIGB1bmlvbmAsIG9vcHMpLlxuICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWQ6IDM0NTcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTaXplcyBmb3IgZGF0YSBpbnNpZGUgc2VjdXJlIG1lc3NhZ2UgcGF5bG9hZHNcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAvLyBBbGwgcmVxdWVzdHMgYWxzbyBoYXZlIGEgYHJlcXVlc3RDb2RlYCwgd2hpY2ggaXMgb21pdHRlZFxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlc2UgY29uc3RhbnRzLlxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdDogNjUsXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZDogKF9iID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBlbmNyeXB0ZWQgcmVxdWVzdHMgYXJlIGVuY3J5cHRlZCBpbnRvIGEgMTcyOCBieXRlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZERhdGE6IDE3MjhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmRpdmlkdWFsIHJlcXVlc3QgdHlwZXMgaGF2ZSBkaWZmZXJlbnQgZGF0YSBzaXplcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5maW5hbGl6ZVBhaXJpbmddID0gOTksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYltMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0QWRkcmVzc2VzXSA9IDU0LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2JbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLnNpZ25dID0gMTY4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5nZXRXYWxsZXRzXSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYltMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0S3ZSZWNvcmRzXSA9IDksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYltMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuYWRkS3ZSZWNvcmRzXSA9IDEzOTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYltMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUucmVtb3ZlS3ZSZWNvcmRzXSA9IDQwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS5mZXRjaEVuY3J5cHRlZERhdGFdID0gMTAyNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW0xhdHRpY2VTZWN1cmVFbmNyeXB0ZWRSZXF1ZXN0VHlwZS50ZXN0XSA9IDUwNixcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEFsbCByZXNwb25zZXMgYWxzbyBoYXZlIGEgYHJlc3BvbnNlQ29kZWAsIHdoaWNoIGlzIG9taXR0ZWRcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZXNlIGNvbnN0YW50cy5cbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWQ6IChfYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWREYXRhOiAxNzI4XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBkZWNyeXB0ZWQsIHRoZSBkYXRhIHNpemUgb2YgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgcmVxdWVzdCB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogQWxsIHJlcXVlc3RzIGFsc28gaGF2ZSBlcGhlbWVyYWxQdWJsaWNLZXkgKDY1IGJ5dGVzKSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrc3VtICg0IGJ5dGVzKSwgd2hpY2ggYXJlIGV4Y2x1ZGVkIGZyb20gdGhlc2Ugc2l6ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZmluYWxpemVQYWlyaW5nXSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuZ2V0QWRkcmVzc2VzXSA9IDEyOTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tMYXR0aWNlU2VjdXJlRW5jcnlwdGVkUmVxdWVzdFR5cGUuc2lnbl0gPSAxMDkwLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmdldFdhbGxldHNdID0gMTQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmdldEt2UmVjb3Jkc10gPSAxMzk1LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmFkZEt2UmVjb3Jkc10gPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLnJlbW92ZUt2UmVjb3Jkc10gPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLmZldGNoRW5jcnlwdGVkRGF0YV0gPSAxNjA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbTGF0dGljZVNlY3VyZUVuY3J5cHRlZFJlcXVlc3RUeXBlLnRlc3RdID0gMTY0NixcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jcnlwdGVkU2VjdXJlUmVxdWVzdCA9IGV4cG9ydHMuY29ubmVjdFNlY3VyZVJlcXVlc3QgPSB2b2lkIDA7XG4vKipcbiAqIEFsbCBtZXNzYWdlcyBzZW50IHRvIHRoZSBMYXR0aWNlIGZyb20gdGhpcyBTREsgd2lsbCBiZVxuICogXCJzZWN1cmUgbWVzc2FnZXNcIiwgb2Ygd2hpY2ggdGhlcmUgYXJlIHR3byB0eXBlczpcbiAqXG4gKiAxLiBDb25uZWN0IHJlcXVlc3RzIGFyZSAqdW5lbmNyeXB0ZWQqIGFuZCBzZXJ2ZSB0byBlc3RhYmxpc2hcbiAqICAgIGEgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZSBTREsgQ2xpZW50IGluc3RhbmNlIGFuZCB0aGUgdGFyZ2V0XG4gKiAgICBMYXR0aWNlLiBJZiB0aGUgY2xpZW50IGlzIGFscmVhZHkgcGFpcmVkIHRvIHRoZSB0YXJnZXQgTGF0dGljZSxcbiAqICAgIHRoZSByZXNwb25zZSB3aWxsIGluZGljYXRlIHRoYXQuIElmIHRoZSBjbGllbnQgaGFzIG5ldmVyIHBhaXJlZFxuICogICAgd2l0aCB0aGlzIExhdHRpY2UsIHRoZSBMYXR0aWNlIHdpbGwgZ28gaW50byBcInBhaXJpbmcgbW9kZVwiIGFuZFxuICogICAgd2lsbCBleHBlY3QgYSBmb2xsb3cgdXAgYGZpbmFsaXplUGFpcmluZ2AgcmVxdWVzdCwgd2hpY2ggaXNcbiAqICAgIGFuIGVuY3J5cHRlZCByZXF1ZXN0LiBUaGlzIHdpbGwgcmV0dXJuIGFuIGVwaGVtZXJhbCBwdWJsaWMga2V5LFxuICogICAgd2hpY2ggaXMgdXNlZCB0byBlbmNyeXB0IHRoZSBuZXh0IHJlcXVlc3QuXG4gKiAyLiBFbmNyeXB0ZWQgcmVxdWVzdHMgYXJlICplbmNyeXB0ZWQqIChvYnZpb3VzbHkpIGFuZCBmcm9tIGEgTGF0dGljZVxuICogICAgcHJvdG9jb2wgcGVyc3BlY3RpdmUgdGhleSBhcmUgYWxsIGNvbnN0cnVjdGVkIHRoZSBzYW1lIHdheTpcbiAqICAgIGNyZWF0ZSBhIGJ1ZmZlciBvZiBgcGF5bG9hZGAgbGVuZ3RoIGFuZCBmaWxsIGl0IHdpdGggdW5lbmNyeXB0ZWRcbiAqICAgIGRhdGEsIHRoZW4gZW5jcnlwdCB0aGUgZW50aXJlIHBheWxvYWQgKG5vdCBqdXN0IHRoZSBkYXRhIHlvdSBmaWxsZWQpXG4gKiAgICB3aXRoIHRoZSBFQ0RIIHNlY3JldCBmb3JtZWQgZnJvbSB0aGUgbGFzdCBlcGhlbWVyYWwgcHVibGljIGtleS5cbiAqICAgIFRoZSByZXNwb25zZSB0byB0aGlzIHJlcXVlc3Qgd2lsbCBjb250YWluIGEgbmV3IGVwaGVtcmFsIHB1YmxpY1xuICogICAga2V5LCB3aGljaCB5b3Ugd2lsbCBuZWVkIGZvciB0aGUgbmV4dCBlbmNyeXB0ZWQgcmVxdWVzdC5cbiAqL1xudmFyIGxhdHRpY2VDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2xhdHRpY2VDb25zdGFudHNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Z1bmN0aW9uc1wiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3ZhbGlkYXRvcnNcIik7XG52YXIgbXNnU2l6ZXMgPSBsYXR0aWNlQ29uc3RhbnRzXzEuUHJvdG9jb2xDb25zdGFudHMubXNnU2l6ZXM7XG52YXIgc3pzID0gbXNnU2l6ZXMuc2VjdXJlO1xuLyoqXG4gKiBCdWlsZCBhbmQgbWFrZSBhIHJlcXVlc3QgdG8gY29ubmVjdCB0byBhIHNwZWNpZmljIExhdHRpY2VcbiAqIGJhc2VkIG9uIGl0cyBgZGV2aWNlSWRgLlxuICogQHBhcmFtIGRldmljZUlkIC0gRGV2aWNlIElEIGZvciB0aGUgdGFyZ2V0IExhdHRpY2UuIE11c3QgYmUgaW5cbiAqICAgICAgICAgICAgICAgICAgIHRoZSBzYW1lIGBjbGllbnQuYmFzZVVybGAgZG9tYWluIHRvIGJlIGZvdW5kLlxuICogQHJldHVybiB7QnVmZmVyfSAtIENvbm5lY3Rpb24gcmVzcG9uc2UgcGF5bG9hZCBkYXRhLCB3aGljaCBjb250YWluc1xuICogICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb25uZWN0ZWQgTGF0dGljZS5cbiAqL1xuZnVuY3Rpb24gY29ubmVjdFNlY3VyZVJlcXVlc3QoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsLCBwdWJrZXkgPSBfYS5wdWJrZXk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF5bG9hZERhdGEsIG1zZ0lkLCBtc2csIHJlc3A7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWREYXRhID0gc2VyaWFsaXplU2VjdXJlUmVxdWVzdENvbm5lY3RQYXlsb2FkRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1zZ0lkID0gKDAsIHV0aWxfMS5yYW5kb21CeXRlcykoNCk7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IHNlcmlhbGl6ZVNlY3VyZVJlcXVlc3RNc2cobXNnSWQsIGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2VjdXJlTXNnVHlwZS5jb25uZWN0LCBwYXlsb2FkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBmdW5jdGlvbnNfMS5yZXF1ZXN0KSh7IHVybDogdXJsLCBwYXlsb2FkOiBtc2cgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzcCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3AubGVuZ3RoICE9PSBzenMucGF5bG9hZC5yZXNwb25zZS5jb25uZWN0IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBMYXR0aWNlIHJlc3BvbnNlIG1lc3NhZ2Ugc2l6ZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb25uZWN0U2VjdXJlUmVxdWVzdCA9IGNvbm5lY3RTZWN1cmVSZXF1ZXN0O1xuLyoqXG4gKiBCdWlsZCBhbiBlbmNyeXB0ZWQgc2VjdXJlIHJlcXVlc3QgdXNpbmcgcmF3IGRhdGEsXG4gKiB0aGVuIHNlbmQgdGhhdCByZXF1ZXN0IHRvIHRoZSB0YXJnZXQgTGF0dGljZSwgaGFuZGxlXG4gKiB0aGUgcmVzcG9uc2UsIGFuZCByZXR1cm4gdGhlICpkZWNyeXB0ZWQqIHJlc3BvbnNlXG4gKiBwYXlsb2FkIGRhdGEuXG4gKiBBbHNvIHVwZGF0ZXMgZXBoZW1lcmFsIHB1YmxpYyBrZXkgaW4gdGhlIGNsaWVudC5cbiAqIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCBzZXZlcmFsIGxvY2FsIHV0aWwgZnVuY3Rpb25zLlxuICogQHBhcmFtIGRhdGEgLSBVbmVuY3J5cHRlZCByYXcgY2FsbGRhdGEgZm9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0gcmVxdWVzdFR5cGUgLSBUeXBlIG9mIGVuY3J5cHRlZCByZXF1ZXMgdG8gbWFrZVxuICogQHJldHVybiB7QnVmZmVyfSBEZWNyeXB0ZWQgcmVzcG9uc2UgZGF0YSAoZXhjbHVkaW5nIG1ldGFkYXRhKVxuICovXG5mdW5jdGlvbiBlbmNyeXB0ZWRTZWN1cmVSZXF1ZXN0KF9hKSB7XG4gICAgdmFyIGRhdGEgPSBfYS5kYXRhLCByZXF1ZXN0VHlwZSA9IF9hLnJlcXVlc3RUeXBlLCBzaGFyZWRTZWNyZXQgPSBfYS5zaGFyZWRTZWNyZXQsIGVwaGVtZXJhbFB1YiA9IF9hLmVwaGVtZXJhbFB1YiwgdXJsID0gX2EudXJsO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1zZ0lkLCBwYXlsb2FkRGF0YSwgbXNnLCByZXNwLCBlbmNQYXlsb2FkRGF0YTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgbXNnSWQgPSAoMCwgdXRpbF8xLnJhbmRvbUJ5dGVzKSg0KTtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZERhdGEgPSBzZXJpYWxpemVTZWN1cmVSZXF1ZXN0RW5jcnlwdGVkUGF5bG9hZERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiByZXF1ZXN0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBzZXJpYWxpemVTZWN1cmVSZXF1ZXN0TXNnKG1zZ0lkLCBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNlY3VyZU1zZ1R5cGUuZW5jcnlwdGVkLCBwYXlsb2FkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBmdW5jdGlvbnNfMS5yZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzcCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVzZXJpYWxpemUgdGhlIHJlc3BvbnNlIHBheWxvYWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcC5sZW5ndGggIT09IHN6cy5wYXlsb2FkLnJlc3BvbnNlLmVuY3J5cHRlZCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgTGF0dGljZSByZXNwb25zZSBtZXNzYWdlIHNpemUuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5jUGF5bG9hZERhdGEgPSByZXNwLnNsaWNlKDAsIHN6cy5kYXRhLnJlc3BvbnNlLmVuY3J5cHRlZC5lbmNyeXB0ZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGRlY3J5cHRlZCByZXNwb25zZSBwYXlsb2FkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRlY3J5cHRFbmNyeXB0ZWRMYXR0aWNlUmVzcG9uc2VEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNQYXlsb2FkRGF0YTogZW5jUGF5bG9hZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFR5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZFNlY3JldDogc2hhcmVkU2VjcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZW5jcnlwdGVkU2VjdXJlUmVxdWVzdCA9IGVuY3J5cHRlZFNlY3VyZVJlcXVlc3Q7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogU2VyaWFsaXplIGEgU2VjdXJlIFJlcXVlc3QgbWVzc2FnZSBmb3IgdGhlIExhdHRpY2UuXG4gKiBBbGwgb3V0Z29pbmcgU0RLIHJlcXVlc3RzIGFyZSBvZiB0aGlzIGZvcm0uXG4gKiBAcGFyYW0gbXNnSWQgLSBSYW5kb20gNCBieXRlcyBvZiBkYXRhIGZvciBpbnRlcm5hbGx5IHRyYWNraW5nIHRoaXMgbWVzc2FnZVxuICogQHBhcmFtIHNlY3VyZVJlcXVlc3RUeXBlIC0gMHgwMSBmb3IgY29ubmVjdCwgMHgwMiBmb3IgZW5jcnlwdGVkXG4gKiBAcGFyYW0gcGF5bG9hZERhdGEgLSBSZXF1ZXN0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn0gU2VyaWFsaXplZCBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gTGF0dGljZVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVTZWN1cmVSZXF1ZXN0TXNnKG1zZ0lkLCBzZWN1cmVSZXF1ZXN0VHlwZSwgcGF5bG9hZERhdGEpIHtcbiAgICAvLyBTYW5pdHkgY2hlY2sgcmVxdWVzdCBkYXRhXG4gICAgaWYgKG1zZ0lkLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21zZ0lkIG11c3QgYmUgZm91ciBieXRlcycpO1xuICAgIH1cbiAgICBpZiAoc2VjdXJlUmVxdWVzdFR5cGUgIT09IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlU2VjdXJlTXNnVHlwZS5jb25uZWN0ICYmXG4gICAgICAgIHNlY3VyZVJlcXVlc3RUeXBlICE9PSBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNlY3VyZU1zZ1R5cGUuZW5jcnlwdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXR0aWNlIHNlY3VyZSByZXF1ZXN0IHR5cGUnKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhlIGluY29taW5nIHBheWxvYWQgZGF0YSBzaXplLiBOb3RlIHRoYXQgdGhlIHBheWxvYWRcbiAgICAvLyBkYXRhIGlzIHByZXBlbmRlZCB3aXRoIGEgc2VjdXJlIHJlcXVlc3QgdHlwZSBieXRlLCBzbyB0aGVcbiAgICAvLyBwYXlsb2FkIGRhdGEgc2l6ZSBpcyBvbmUgbGVzcyB0aGFuIHRoZSBleHBlY3RlZCBzaXplLlxuICAgIHZhciBpc1ZhbGlkQ29ubmVjdFBheWxvYWREYXRhU3ogPSBzZWN1cmVSZXF1ZXN0VHlwZSA9PT0gbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VTZWN1cmVNc2dUeXBlLmNvbm5lY3QgJiZcbiAgICAgICAgcGF5bG9hZERhdGEubGVuZ3RoID09PSBzenMucGF5bG9hZC5yZXF1ZXN0LmNvbm5lY3QgLSAxO1xuICAgIHZhciBpc1ZhbGlkRW5jcnlwdGVkUGF5bG9hZERhdGFTeiA9IHNlY3VyZVJlcXVlc3RUeXBlID09PSBsYXR0aWNlQ29uc3RhbnRzXzEuTGF0dGljZVNlY3VyZU1zZ1R5cGUuZW5jcnlwdGVkICYmXG4gICAgICAgIHBheWxvYWREYXRhLmxlbmd0aCA9PT0gc3pzLnBheWxvYWQucmVxdWVzdC5lbmNyeXB0ZWQgLSAxO1xuICAgIC8vIEJ1aWxkIHBheWxvYWQgYW5kIHNpemVcbiAgICB2YXIgbXNnU3ogPSBtc2dTaXplcy5oZWFkZXIgKyBtc2dTaXplcy5jaGVja3N1bTtcbiAgICB2YXIgcGF5bG9hZExlbjtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IHNlY3VyZVJlcXVlc3RUeXBlLFxuICAgICAgICBkYXRhOiBwYXlsb2FkRGF0YSxcbiAgICB9O1xuICAgIGlmIChpc1ZhbGlkQ29ubmVjdFBheWxvYWREYXRhU3opIHtcbiAgICAgICAgcGF5bG9hZExlbiA9IHN6cy5wYXlsb2FkLnJlcXVlc3QuY29ubmVjdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNWYWxpZEVuY3J5cHRlZFBheWxvYWREYXRhU3opIHtcbiAgICAgICAgcGF5bG9hZExlbiA9IHN6cy5wYXlsb2FkLnJlcXVlc3QuZW5jcnlwdGVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdHRpY2Ugc2VjdXJlIHJlcXVlc3QgcGF5bG9hZCBzaXplJyk7XG4gICAgfVxuICAgIG1zZ1N6ICs9IHBheWxvYWRMZW47XG4gICAgLy8gQ29uc3RydWN0IHRoZSByZXF1ZXN0IGluIG9iamVjdCBmb3JtXG4gICAgdmFyIGhlYWRlciA9IHtcbiAgICAgICAgdmVyc2lvbjogbGF0dGljZUNvbnN0YW50c18xLkxhdHRpY2VQcm90b2NvbFZlcnNpb24udjEsXG4gICAgICAgIHR5cGU6IGxhdHRpY2VDb25zdGFudHNfMS5MYXR0aWNlTXNnVHlwZS5zZWN1cmUsXG4gICAgICAgIGlkOiBtc2dJZCxcbiAgICAgICAgbGVuOiBwYXlsb2FkTGVuLFxuICAgIH07XG4gICAgdmFyIHJlcSA9IHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgfTtcbiAgICAvLyBOb3cgc2VyaWFsaXplIHRoZSB3aG9sZSBtZXNzYWdlXG4gICAgLy8gSGVhZGVyIHwgcmVxdWVzdFR5cGUgfCBwYXlsb2FkRGF0YSB8IGNoZWNrc3VtXG4gICAgdmFyIG1zZyA9IEJ1ZmZlci5hbGxvYyhtc2dTeik7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgLy8gSGVhZGVyXG4gICAgbXNnLndyaXRlVUludDgocmVxLmhlYWRlci52ZXJzaW9uLCBvZmYpO1xuICAgIG9mZiArPSAxO1xuICAgIG1zZy53cml0ZVVJbnQ4KHJlcS5oZWFkZXIudHlwZSwgb2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICByZXEuaGVhZGVyLmlkLmNvcHkobXNnLCBvZmYpO1xuICAgIG9mZiArPSByZXEuaGVhZGVyLmlkLmxlbmd0aDtcbiAgICBtc2cud3JpdGVVSW50MTZCRShyZXEuaGVhZGVyLmxlbiwgb2ZmKTtcbiAgICBvZmYgKz0gMjtcbiAgICAvLyBQYXlsb2FkXG4gICAgbXNnLndyaXRlVUludDgocmVxLnBheWxvYWQucmVxdWVzdFR5cGUsIG9mZik7XG4gICAgb2ZmICs9IDE7XG4gICAgcmVxLnBheWxvYWQuZGF0YS5jb3B5KG1zZywgb2ZmKTtcbiAgICBvZmYgKz0gcmVxLnBheWxvYWQuZGF0YS5sZW5ndGg7XG4gICAgLy8gQ2hlY2tzdW1cbiAgICBtc2cud3JpdGVVSW50MzJCRSgoMCwgdXRpbF8xLmNoZWNrc3VtKShtc2cuc2xpY2UoMCwgb2ZmKSksIG9mZik7XG4gICAgb2ZmICs9IDQ7XG4gICAgaWYgKG9mZiAhPT0gbXNnU3opIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYnVpbGQgcmVxdWVzdCBtZXNzYWdlJyk7XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgb3VyIHNlcmlhbGl6ZWQgc2VjdXJlIG1lc3NhZ2UhXG4gICAgcmV0dXJuIG1zZztcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBTZXJpYWxpemUgcGF5bG9hZCBkYXRhIGZvciBhIExhdHRpY2Ugc2VjdXJlIHJlcXVlc3Q6IGNvbm5lY3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gLSAxNzAwIGJ5dGVzLCBvZiB3aGljaCBvbmx5IDY1IGFyZSB1c2VkXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNlY3VyZVJlcXVlc3RDb25uZWN0UGF5bG9hZERhdGEocGF5bG9hZERhdGEpIHtcbiAgICB2YXIgc2VyUGF5bG9hZERhdGEgPSBCdWZmZXIuYWxsb2Moc3pzLmRhdGEucmVxdWVzdC5jb25uZWN0KTtcbiAgICBwYXlsb2FkRGF0YS5wdWJrZXkuY29weShzZXJQYXlsb2FkRGF0YSwgMCk7XG4gICAgcmV0dXJuIHNlclBheWxvYWREYXRhO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFNlcmlhbGl6ZSBwYXlsb2FkIGRhdGEgZm9yIExhdHRpY2Ugc2VjdXJlIHJlcXVlc3Q6IGVuY3J5cHRlZFxuICogQHBhcmFtIGRhdGEgLSBSYXcgKHVuZW5jcnlwdGVkKSByZXF1ZXN0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn0gLSAxNzAwIGJ5dGVzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIHVzZWRcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplU2VjdXJlUmVxdWVzdEVuY3J5cHRlZFBheWxvYWREYXRhKF9hKSB7XG4gICAgdmFyIGRhdGEgPSBfYS5kYXRhLCByZXF1ZXN0VHlwZSA9IF9hLnJlcXVlc3RUeXBlLCBlcGhlbWVyYWxQdWIgPSBfYS5lcGhlbWVyYWxQdWIsIHNoYXJlZFNlY3JldCA9IF9hLnNoYXJlZFNlY3JldDtcbiAgICAvLyBTYW5pdHkgY2hlY2tzIHJlcXVlc3Qgc2l6ZVxuICAgIGlmIChkYXRhLmxlbmd0aCA+IHN6cy5kYXRhLnJlcXVlc3QuZW5jcnlwdGVkLmVuY3J5cHRlZERhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgcmVxdWVzdCBkYXRhIHRvbyBsYXJnZScpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHNoYXJlZCBzZWNyZXQuIEFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZXBoZW1lcmFsIHB1YiwgaW5kaWNhdGluZyB3ZSBuZWVkIHRvIHJlY29ubmVjdC5cbiAgICAoMCwgdmFsaWRhdG9yc18xLnZhbGlkYXRlRXBoZW1lcmFsUHViKShlcGhlbWVyYWxQdWIpO1xuICAgIC8vIFZhbGlkYXRlIHRoZSByZXF1ZXN0IGRhdGEgc2l6ZSBtYXRjaGVzIHRoZSBkZXNpcmVkIHJlcXVlc3RcbiAgICB2YXIgcmVxdWVzdERhdGFTaXplID0gc3pzLmRhdGEucmVxdWVzdC5lbmNyeXB0ZWRbcmVxdWVzdFR5cGVdO1xuICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gcmVxdWVzdERhdGFTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVxdWVzdCBkYXRhc2l6ZSAod2FudGVkIFwiLmNvbmNhdChyZXF1ZXN0RGF0YVNpemUsIFwiLCBnb3QgXCIpLmNvbmNhdChkYXRhLmxlbmd0aCwgXCIpXCIpKTtcbiAgICB9XG4gICAgLy8gQnVpbGQgdGhlIHByZS1lbmNyeXB0ZWQgZGF0YSBwYXlsb2FkLCB3aGljaCB2YXJpYWJsZSBzaXplZCBhbmQgb2YgZm9ybTpcbiAgICAvLyBlbmNyeXB0ZWRSZXF1ZXN0VHlwZSB8IGRhdGEgfCBjaGVja3N1bVxuICAgIHZhciBwcmVFbmNyeXB0ZWREYXRhID0gQnVmZmVyLmFsbG9jKDEgKyByZXF1ZXN0RGF0YVNpemUpO1xuICAgIHByZUVuY3J5cHRlZERhdGFbMF0gPSByZXF1ZXN0VHlwZTtcbiAgICBkYXRhLmNvcHkocHJlRW5jcnlwdGVkRGF0YSwgMSk7XG4gICAgdmFyIHByZUVuY3J5cHRlZERhdGFDaGVja3N1bSA9ICgwLCB1dGlsXzEuY2hlY2tzdW0pKHByZUVuY3J5cHRlZERhdGEpO1xuICAgIC8vIEVuY3J5cHQgdGhlIGRhdGEgaW50byBhIGZpeGVkIHNpemUgYnVmZmVyLiBUaGUgYnVmZmVyIHNpemUgc2hvdWxkXG4gICAgLy8gZXF1YWwgdG8gdGhlIGZ1bGwgbWVzc2FnZSByZXF1ZXN0IGxlc3MgdGhlIDQtYnl0ZSBlcGhlbWVyYWwgaWQuXG4gICAgdmFyIF9lbmNyeXB0ZWREYXRhID0gQnVmZmVyLmFsbG9jKHN6cy5kYXRhLnJlcXVlc3QuZW5jcnlwdGVkLmVuY3J5cHRlZERhdGEpO1xuICAgIHByZUVuY3J5cHRlZERhdGEuY29weShfZW5jcnlwdGVkRGF0YSwgMCk7XG4gICAgX2VuY3J5cHRlZERhdGEud3JpdGVVSW50MzJMRShwcmVFbmNyeXB0ZWREYXRhQ2hlY2tzdW0sIHByZUVuY3J5cHRlZERhdGEubGVuZ3RoKTtcbiAgICB2YXIgZW5jcnlwdGVkRGF0YSA9ICgwLCB1dGlsXzEuYWVzMjU2X2VuY3J5cHQpKF9lbmNyeXB0ZWREYXRhLCBzaGFyZWRTZWNyZXQpO1xuICAgIC8vIENhbGN1bGF0ZSBlcGhlbWVyYWwgSURcbiAgICB2YXIgZXBoZW1lcmFsSWQgPSAoMCwgZnVuY3Rpb25zXzEuZ2V0RXBoZW1lcmFsSWQpKHNoYXJlZFNlY3JldCk7XG4gICAgLy8gTm93IHdlIHdpbGwgc2VyaWFsaXplIHRoZSBwYXlsb2FkIGRhdGEuXG4gICAgdmFyIHNlclBheWxvYWREYXRhID0gQnVmZmVyLmFsbG9jKHN6cy5wYXlsb2FkLnJlcXVlc3QuZW5jcnlwdGVkIC0gMSk7XG4gICAgc2VyUGF5bG9hZERhdGEud3JpdGVVSW50MzJMRShlcGhlbWVyYWxJZCk7XG4gICAgZW5jcnlwdGVkRGF0YS5jb3B5KHNlclBheWxvYWREYXRhLCA0KTtcbiAgICByZXR1cm4gc2VyUGF5bG9hZERhdGE7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogRGVjcnlwdCB0aGUgcmVzcG9uc2UgZGF0YSBmcm9tIGFuIGVuY3J5cHRlZCByZXF1ZXN0LlxuICogQHBhcmFtIGVuY1BheWxvYWREYXRhIC0gRW5jcnlwdGVkIHBheWxvYWQgZGF0YSBpbiByZXNwb25zZVxuICogQHJldHVybiB7QnVmZmVyfSBEZWNyeXB0ZWQgcmVzcG9uc2UgZGF0YSAoZXhjbHVkaW5nIG1ldGFkYXRhKVxuICovXG5mdW5jdGlvbiBkZWNyeXB0RW5jcnlwdGVkTGF0dGljZVJlc3BvbnNlRGF0YShfYSkge1xuICAgIHZhciBlbmNQYXlsb2FkRGF0YSA9IF9hLmVuY1BheWxvYWREYXRhLCByZXF1ZXN0VHlwZSA9IF9hLnJlcXVlc3RUeXBlLCBzaGFyZWRTZWNyZXQgPSBfYS5zaGFyZWRTZWNyZXQ7XG4gICAgLy8gRGVjcnlwdCBkYXRhIHVzaW5nIHRoZSAqY3VycmVudCogc2hhcmVkIHNlY3JldFxuICAgIHZhciBkZWNEYXRhID0gKDAsIHV0aWxfMS5hZXMyNTZfZGVjcnlwdCkoZW5jUGF5bG9hZERhdGEsIHNoYXJlZFNlY3JldCk7XG4gICAgLy8gQnVsaWQgdGhlIG9iamVjdFxuICAgIHZhciBlcGhlbWVyYWxQdWJTeiA9IDY1OyAvLyBzZWNwMjU2cjEgcHVia2V5XG4gICAgdmFyIGNoZWNrc3VtT2Zmc2V0ID0gZXBoZW1lcmFsUHViU3ogKyBzenMuZGF0YS5yZXNwb25zZS5lbmNyeXB0ZWRbcmVxdWVzdFR5cGVdO1xuICAgIHZhciByZXNwRGF0YSA9IHtcbiAgICAgICAgZXBoZW1lcmFsUHViOiBkZWNEYXRhLnNsaWNlKDAsIGVwaGVtZXJhbFB1YlN6KSxcbiAgICAgICAgZGF0YTogZGVjRGF0YS5zbGljZShlcGhlbWVyYWxQdWJTeiwgY2hlY2tzdW1PZmZzZXQpLFxuICAgICAgICBjaGVja3N1bTogZGVjRGF0YS5yZWFkVUludDMyQkUoY2hlY2tzdW1PZmZzZXQpLFxuICAgIH07XG4gICAgLy8gVmFsaWRhdGUgdGhlIGNoZWNrc3VtXG4gICAgdmFyIHZhbGlkQ2hlY2tzdW0gPSAoMCwgdXRpbF8xLmNoZWNrc3VtKShkZWNEYXRhLnNsaWNlKDAsIGNoZWNrc3VtT2Zmc2V0KSk7XG4gICAgaWYgKHJlc3BEYXRhLmNoZWNrc3VtICE9PSB2YWxpZENoZWNrc3VtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hlY2tzdW0gbWlzbWF0Y2ggaW4gZGVjcnlwdGVkIExhdHRpY2UgZGF0YScpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGUgcmVzcG9uc2UgZGF0YSBzaXplXG4gICAgdmFyIHZhbGlkU3ogPSBzenMuZGF0YS5yZXNwb25zZS5lbmNyeXB0ZWRbcmVxdWVzdFR5cGVdO1xuICAgIGlmIChyZXNwRGF0YS5kYXRhLmxlbmd0aCAhPT0gdmFsaWRTeikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCByZXNwb25zZSBkYXRhIHJldHVybmVkIGZyb20gTGF0dGljZScpO1xuICAgIH1cbiAgICB2YXIgbmV3RXBoZW1lcmFsUHViID0gKDAsIHV0aWxfMS5nZXRQMjU2S2V5UGFpckZyb21QdWIpKHJlc3BEYXRhLmVwaGVtZXJhbFB1Yik7XG4gICAgLy8gUmV0dXJuZWQgdGhlIGRlY3J5cHRlZCBkYXRhXG4gICAgcmV0dXJuIHsgZGVjcnlwdGVkRGF0YTogcmVzcERhdGEuZGF0YSwgbmV3RXBoZW1lcmFsUHViOiBuZXdFcGhlbWVyYWxQdWIgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGF0dGljZVJlc3BvbnNlRXJyb3IgPSB2b2lkIDA7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9wcm90b2NvbFwiKTtcbnZhciBidWlsZExhdHRpY2VSZXNwb25zZUVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciByZXNwb25zZUNvZGUgPSBfYS5yZXNwb25zZUNvZGUsIGVycm9yTWVzc2FnZSA9IF9hLmVycm9yTWVzc2FnZTtcbiAgICB2YXIgbXNnID0gW107XG4gICAgaWYgKHJlc3BvbnNlQ29kZSkge1xuICAgICAgICBtc2cucHVzaChcIlwiLmNvbmNhdChwcm90b2NvbF8xLlByb3RvY29sQ29uc3RhbnRzLnJlc3BvbnNlTXNnW3Jlc3BvbnNlQ29kZV0pKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICBtc2cucHVzaCgnRXJyb3IgTWVzc2FnZTogJyk7XG4gICAgICAgIG1zZy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBtc2cuam9pbignXFxuJyk7XG59O1xudmFyIExhdHRpY2VSZXNwb25zZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXR0aWNlUmVzcG9uc2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXR0aWNlUmVzcG9uc2VFcnJvcihyZXNwb25zZUNvZGUsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGJ1aWxkTGF0dGljZVJlc3BvbnNlRXJyb3JNZXNzYWdlKHtcbiAgICAgICAgICAgIHJlc3BvbnNlQ29kZTogcmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlQ29kZSA9IHJlc3BvbnNlQ29kZTtcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ0xhdHRpY2VSZXNwb25zZUVycm9yJztcbiAgICAgICAgX3RoaXMucmVzcG9uc2VDb2RlID0gcmVzcG9uc2VDb2RlO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExhdHRpY2VSZXNwb25zZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5MYXR0aWNlUmVzcG9uc2VFcnJvciA9IExhdHRpY2VSZXNwb25zZUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RXBoZW1lcmFsSWQgPSBleHBvcnRzLnJldHJ5V3JhcHBlciA9IGV4cG9ydHMuYnVpbGRSZXRyeVdyYXBwZXIgPSBleHBvcnRzLnJlcXVlc3QgPSBleHBvcnRzLmJ1aWxkVHJhbnNhY3Rpb24gPSB2b2lkIDA7XG52YXIgc2hhXzEgPSByZXF1aXJlKFwiaGFzaC5qcy9saWIvaGFzaC9zaGFcIik7XG52YXIgYml0Y29pbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9iaXRjb2luXCIpKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgZXRoZXJldW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXRoZXJldW1cIikpO1xudmFyIGdlbmVyaWNTaWduaW5nXzEgPSByZXF1aXJlKFwiLi4vZ2VuZXJpY1NpZ25pbmdcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4vcHJlZGljYXRlc1wiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzXCIpO1xudmFyIGJ1aWxkVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAvLyBBbGwgdHJhbnNhY3Rpb24gcmVxdWVzdHMgbXVzdCBiZSBwdXQgaW50byB0aGUgc2FtZSBzaXplZCBidWZmZXIuIFRoaXMgY29tZXMgZnJvbVxuICAgIC8vIHNpemVvZihHcFRyYW5zYWN0aW9uUmVxdWVzdF90KSwgYnV0IG5vdGUgd2UgcmVtb3ZlIHRoZSAyLWJ5dGUgc2NoZW1hSWQgc2luY2UgaXQgaXMgbm90XG4gICAgLy8gcmV0dXJuZWQgZnJvbSBvdXIgcmVzb2x2ZXIuIE5vdGUgdGhhdCBkaWZmZXJlbnQgZmlybXdhcmUgdmVyc2lvbnMgbWF5IGhhdmUgZGlmZmVyZW50IGRhdGFcbiAgICAvLyBzaXplcy5cbiAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIGN1cnJlbmN5ID0gX2EuY3VycmVuY3ksIGZ3Q29uc3RhbnRzID0gX2EuZndDb25zdGFudHM7XG4gICAgLy8gVEVNUE9SQVJZIEJSSURHRSAtLSBERVBSRUNBVEUgTUUgSW4gdjAuMTUuMCBMYXR0aWNlIGZpcm13YXJlIHJlbW92ZWQgdGhlIGxlZ2FjeSBFVEhcbiAgICAvLyBzaWduaW5nIHBhdGgsIHNvIHdlIG5lZWQgdG8gY29udmVydCBzdWNoIHJlcXVlc3RzIHRvIGdlbmVyYWwgc2lnbmluZyByZXF1ZXN0cyB1c2luZyB0aGVcbiAgICAvLyBFVk0gZGVjb2Rlci4gTk9URTogTm90IGV2ZXJ5IHJlcXVlc3QgY2FuIGJlIGNvbnZlcnRlZCwgc28gdXNlcnMgc2hvdWxkIHN3aXRjaCB0byB1c2luZ1xuICAgIC8vIGdlbmVyYWwgc2lnbmluZyByZXF1ZXN0cyBmb3IgbmV3ZXIgZmlybXdhcmUgdmVyc2lvbnMuIEVJUDE1NTkgYW5kIEVJUDE1NSBsZWdhY3lcbiAgICAvLyByZXF1ZXN0cyB3aWxsIGNvbnZlcnQsIGJ1dCBvdGhlcnMgbWF5IG5vdC5cbiAgICBpZiAoY3VycmVuY3kgPT09ICdFVEgnICYmICgwLCBwcmVkaWNhdGVzXzEuc2hvdWxkVXNlRVZNTGVnYWN5Q29udmVydGVyKShmd0NvbnN0YW50cykpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIHRoZSBsZWdhY3kgRVRIIHNpZ25pbmcgcGF0aC4gVGhpcyB3aWxsIHNvb24gYmUgZGVwcmVjYXRlZC4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHN3aXRjaCB0byBnZW5lcmFsIHNpZ25pbmcgcmVxdWVzdC4nKTtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gZXRoZXJldW1fMS5kZWZhdWx0LmV0aENvbnZlcnRMZWdhY3lUb0dlbmVyaWNSZXEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBsZWdhY3kgcmVxdWVzdC4gUGxlYXNlIHN3aXRjaCB0byBhIGdlbmVyYWwgc2lnbmluZyAnICtcbiAgICAgICAgICAgICAgICAncmVxdWVzdC4gU2VlIGdyaWRwbHVzLXNkayBkb2NzIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICBmd0NvbnN0YW50czogZndDb25zdGFudHMsXG4gICAgICAgICAgICBlbmNvZGluZ1R5cGU6IGNvbnN0YW50c18xLkVYVEVSTkFMLlNJR05JTkcuRU5DT0RJTkdTLkVWTSxcbiAgICAgICAgICAgIGN1cnZlVHlwZTogY29uc3RhbnRzXzEuRVhURVJOQUwuU0lHTklORy5DVVJWRVMuU0VDUDI1NksxLFxuICAgICAgICAgICAgaGFzaFR5cGU6IGNvbnN0YW50c18xLkVYVEVSTkFMLlNJR05JTkcuSEFTSEVTLktFQ0NBSzI1NixcbiAgICAgICAgICAgIHNpZ25lclBhdGg6IGRhdGEuc2lnbmVyUGF0aCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0RGF0YTogKDAsIGdlbmVyaWNTaWduaW5nXzEuYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3QpKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyBmd0NvbnN0YW50czogZndDb25zdGFudHMgfSkpLFxuICAgICAgICAgICAgaXNHZW5lcmljOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW5jeSA9PT0gJ0VUSCcpIHtcbiAgICAgICAgLy8gTGVnYWN5IHNpZ25pbmcgcGF0aHdheSAtLSBzaG91bGQgZGVwcmVjYXRlIGluIHRoZSBmdXR1cmVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiBldGhlcmV1bV8xLmRlZmF1bHQuYnVpbGRFdGhlcmV1bVR4UmVxdWVzdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgZndDb25zdGFudHM6IGZ3Q29uc3RhbnRzIH0pKSxcbiAgICAgICAgICAgIGlzR2VuZXJpYzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbmN5ID09PSAnRVRIX01TRycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiBldGhlcmV1bV8xLmRlZmF1bHQuYnVpbGRFdGhlcmV1bU1zZ1JlcXVlc3QoX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyB9KSksXG4gICAgICAgICAgICBpc0dlbmVyaWM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW5jeSA9PT0gJ0JUQycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiBiaXRjb2luXzEuZGVmYXVsdC5idWlsZEJpdGNvaW5UeFJlcXVlc3QoX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyB9KSksXG4gICAgICAgICAgICBpc0dlbmVyaWM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZXF1ZXN0RGF0YTogKDAsIGdlbmVyaWNTaWduaW5nXzEuYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3QpKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyBmd0NvbnN0YW50czogZndDb25zdGFudHMgfSkpLFxuICAgICAgICBpc0dlbmVyaWM6IHRydWUsXG4gICAgfTtcbn07XG5leHBvcnRzLmJ1aWxkVHJhbnNhY3Rpb24gPSBidWlsZFRyYW5zYWN0aW9uO1xudmFyIHJlcXVlc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsLCBwYXlsb2FkID0gX2EucGF5bG9hZCwgX2IgPSBfYS50aW1lb3V0LCB0aW1lb3V0ID0gX2IgPT09IHZvaWQgMCA/IDYwMDAwIDogX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgdXRpbF8xLmZldGNoV2l0aFRpbWVvdXQpKHVybCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBkYXRhOiBwYXlsb2FkIH0pLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh2YWxpZGF0b3JzXzEudmFsaWRhdGVSZXF1ZXN0RXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5qc29uKCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBmb3JtYXR0aW5nIG9yIGdlbmVyaWMgSFRUUCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5IHx8ICFib2R5Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvZHkuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGNvZGUgXCIuY29uY2F0KGJvZHkuc3RhdHVzLCBcIjogXCIpLmNvbmNhdChib2R5Lm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSAoMCwgdXRpbF8xLnBhcnNlTGF0dGljZTFSZXNwb25zZSkoYm9keS5tZXNzYWdlKSwgZGF0YSA9IF9hLmRhdGEsIGVycm9yTWVzc2FnZSA9IF9hLmVycm9yTWVzc2FnZSwgcmVzcG9uc2VDb2RlID0gX2EucmVzcG9uc2VDb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlIHx8IHJlc3BvbnNlQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkxhdHRpY2VSZXNwb25zZUVycm9yKHJlc3BvbnNlQ29kZSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG4vKipcbiAqIGBzbGVlcCgpYCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIGEgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpOyB9KTtcbn1cbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBhbmQgYSBzZXQgb2YgcGFyYW1ldGVycywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0cnkgdGhlIG9yaWdpbmFsXG4gKiBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzIGEgbnVtYmVyIG9mIHRpbWVzXG4gKlxuICogQHBhcmFtIGNsaWVudCAtIGEge0BsaW5rIENsaWVudH0gaW5zdGFuY2UgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIHtAbGluayByZXRyeVdyYXBwZXJ9XG4gKiBAcGFyYW0gcmV0cmllcyAtIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgdGhlIGZ1bmN0aW9uIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm5zIGEge0BsaW5rIHJldHJ5V3JhcHBlcn0gZnVuY3Rpb24gZm9yIGhhbmRpbmcgcmV0cnkgbG9naWNcbiAqL1xudmFyIGJ1aWxkUmV0cnlXcmFwcGVyID0gZnVuY3Rpb24gKGNsaWVudCwgcmV0cmllcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZm4sIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMucmV0cnlXcmFwcGVyKSh7XG4gICAgICAgICAgICBmbjogZm4sXG4gICAgICAgICAgICBwYXJhbXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7IGNsaWVudDogY2xpZW50IH0pLFxuICAgICAgICAgICAgcmV0cmllczogcmV0cmllcyxcbiAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICB9KTtcbiAgICB9O1xufTtcbmV4cG9ydHMuYnVpbGRSZXRyeVdyYXBwZXIgPSBidWlsZFJldHJ5V3JhcHBlcjtcbi8qKlxuICogUmV0cmllcyBhIGZ1bmN0aW9uIGNhbGwgaWYgdGhlIGVycm9yIG1lc3NhZ2Ugb3IgcmVzcG9uc2UgY29kZSBpcyBwcmVzZW50IGFuZCB0aGUgbnVtYmVyIG9mXG4gKiByZXRyaWVzIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byByZXRyeVxuICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gcmV0cmllcyAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gY2xpZW50IC0gVGhlIHtAbGluayBDbGllbnR9IHRvIHVzZSBmb3Igc2lkZS1lZmZlY3RzXG4gKi9cbnZhciByZXRyeVdyYXBwZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZm4gPSBfYS5mbiwgcGFyYW1zID0gX2EucGFyYW1zLCByZXRyaWVzID0gX2EucmV0cmllcywgY2xpZW50ID0gX2EuY2xpZW50O1xuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZm4oX19hc3NpZ24oe30sIHBhcmFtcykpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UsIHJlc3BvbnNlQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyLmVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb2RlID0gZXJyLnJlc3BvbnNlQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKGVycm9yTWVzc2FnZSB8fCByZXNwb25zZUNvZGUpICYmIHJldHJpZXMpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgcHJlZGljYXRlc18xLmlzRGV2aWNlQnVzeSkocmVzcG9uc2VDb2RlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNsZWVwKDMwMDApXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoMCwgcHJlZGljYXRlc18xLmlzV3JvbmdXYWxsZXQpKHJlc3BvbnNlQ29kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjbGllbnQuc2tpcFJldHJ5T25Xcm9uZ1dhbGxldCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGllbnQuZmV0Y2hBY3RpdmVXYWxsZXQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgcHJlZGljYXRlc18xLmlzSW52YWxpZEVwaGVtZXJhbElkKShyZXNwb25zZUNvZGUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY2xpZW50LmNvbm5lY3QoY2xpZW50LmRldmljZUlkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCBleHBvcnRzLnJldHJ5V3JhcHBlcikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IGZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyaWVzOiByZXRyaWVzIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMucmV0cnlXcmFwcGVyID0gcmV0cnlXcmFwcGVyO1xuLyoqXG4gKiBHZXQgdGhlIGVwaGVtZXJhbCBpZCwgd2hpY2ggaXMgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHNoYXJlZCBzZWNyZXQgZ2VuZXJhdGVkIGZyb20gdGhlIGxvY2FsXG4gKiBwcml2YXRlIGtleSBhbmQgdGhlIGVwaGVtZXJhbCBwdWJsaWMga2V5IGZyb20gdGhlIGRldmljZS5cbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbnZhciBnZXRFcGhlbWVyYWxJZCA9IGZ1bmN0aW9uIChzaGFyZWRTZWNyZXQpIHtcbiAgICAvLyBFcGhlbUlkIGlzIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBoYXNoIG9mIHRoZSBzaGFyZWQgc2VjcmV0XG4gICAgdmFyIGhhc2ggPSBCdWZmZXIuZnJvbSgoMCwgc2hhXzEuc2hhMjU2KSgpLnVwZGF0ZShzaGFyZWRTZWNyZXQpLmRpZ2VzdCgnaGV4JyksICdoZXgnKTtcbiAgICByZXR1cm4gcGFyc2VJbnQoaGFzaC5zbGljZSgwLCA0KS50b1N0cmluZygnaGV4JyksIDE2KTtcbn07XG5leHBvcnRzLmdldEVwaGVtZXJhbElkID0gZ2V0RXBoZW1lcmFsSWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvdWxkVXNlRVZNTGVnYWN5Q29udmVydGVyID0gZXhwb3J0cy5kb2VzRmV0Y2hXYWxsZXRzT25Mb2FkID0gZXhwb3J0cy5pc0ludmFsaWRFcGhlbWVyYWxJZCA9IGV4cG9ydHMuaXNXcm9uZ1dhbGxldCA9IGV4cG9ydHMuaXNEZXZpY2VCdXN5ID0gdm9pZCAwO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi4vcHJvdG9jb2xcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG52YXIgaXNEZXZpY2VCdXN5ID0gZnVuY3Rpb24gKHJlc3BvbnNlQ29kZSkge1xuICAgIHJldHVybiByZXNwb25zZUNvZGUgPT09IHByb3RvY29sXzEuTGF0dGljZVJlc3BvbnNlQ29kZS5kZXZpY2VCdXN5IHx8XG4gICAgICAgIHJlc3BvbnNlQ29kZSA9PT0gcHJvdG9jb2xfMS5MYXR0aWNlUmVzcG9uc2VDb2RlLmdjZVRpbWVvdXQ7XG59O1xuZXhwb3J0cy5pc0RldmljZUJ1c3kgPSBpc0RldmljZUJ1c3k7XG52YXIgaXNXcm9uZ1dhbGxldCA9IGZ1bmN0aW9uIChyZXNwb25zZUNvZGUpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VDb2RlID09PSBwcm90b2NvbF8xLkxhdHRpY2VSZXNwb25zZUNvZGUud3JvbmdXYWxsZXQ7XG59O1xuZXhwb3J0cy5pc1dyb25nV2FsbGV0ID0gaXNXcm9uZ1dhbGxldDtcbnZhciBpc0ludmFsaWRFcGhlbWVyYWxJZCA9IGZ1bmN0aW9uIChyZXNwb25zZUNvZGUpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VDb2RlID09PSBwcm90b2NvbF8xLkxhdHRpY2VSZXNwb25zZUNvZGUuaW52YWxpZEVwaGVtSWQ7XG59O1xuZXhwb3J0cy5pc0ludmFsaWRFcGhlbWVyYWxJZCA9IGlzSW52YWxpZEVwaGVtZXJhbElkO1xudmFyIGRvZXNGZXRjaFdhbGxldHNPbkxvYWQgPSBmdW5jdGlvbiAoZndWZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsaXRpZXNfMS5pc0ZXU3VwcG9ydGVkKShmd1ZlcnNpb24sIHsgbWFqb3I6IDAsIG1pbm9yOiAxNCwgZml4OiAxIH0pO1xufTtcbmV4cG9ydHMuZG9lc0ZldGNoV2FsbGV0c09uTG9hZCA9IGRvZXNGZXRjaFdhbGxldHNPbkxvYWQ7XG52YXIgc2hvdWxkVXNlRVZNTGVnYWN5Q29udmVydGVyID0gZnVuY3Rpb24gKGZ3Q29uc3RhbnRzKSB7XG4gICAgcmV0dXJuIGZ3Q29uc3RhbnRzLmdlbmVyaWNTaWduaW5nICYmXG4gICAgICAgIGZ3Q29uc3RhbnRzLmdlbmVyaWNTaWduaW5nLmVuY29kaW5nVHlwZXMgJiZcbiAgICAgICAgZndDb25zdGFudHMuZ2VuZXJpY1NpZ25pbmcuZW5jb2RpbmdUeXBlcy5FVk07XG59O1xuZXhwb3J0cy5zaG91bGRVc2VFVk1MZWdhY3lDb252ZXJ0ZXIgPSBzaG91bGRVc2VFVk1MZWdhY3lDb252ZXJ0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGF0aFN0ciA9IGV4cG9ydHMuaXNGV1N1cHBvcnRlZCA9IGV4cG9ydHMucGFyc2VXYWxsZXRzID0gZXhwb3J0cy5nZXRTaGFyZWRTZWNyZXQgPSBleHBvcnRzLmdldFB1YktleUJ5dGVzID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbi8qKlxuICogR2V0IDY0IGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgcHVibGljIGtleSBUaGlzIGlzIHRoZSB1bmNvbXByZXNzZWQga2V5IHdpdGhvdXQgdGhlIGxlYWRpbmcgMDRcbiAqIGJ5dGVcbiAqIEBwYXJhbSBLZXlQYWlyIC0gLy9UT0RPIERlc2NyaWJlIHRoZSBrZXlwYWlyXG4gKiBAcGFyYW0gTEUgLSBXaGV0aGVyIHRvIHJldHVybiB0aGUgcHVibGljIGtleSBpbiBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cbiAqIEByZXR1cm5zIEEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIHB1YmxpYyBrZXkuXG4gKi9cbnZhciBnZXRQdWJLZXlCeXRlcyA9IGZ1bmN0aW9uIChrZXksIExFKSB7XG4gICAgaWYgKExFID09PSB2b2lkIDApIHsgTEUgPSBmYWxzZTsgfVxuICAgIHZhciBrID0ga2V5LmdldFB1YmxpYygpO1xuICAgIHZhciBwID0gay5lbmNvZGUoJ2hleCcpO1xuICAgIHZhciBwYiA9IEJ1ZmZlci5mcm9tKHAsICdoZXgnKTtcbiAgICBpZiAoTEUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gTmVlZCB0byBmbGlwIFggYW5kIFkgY29tcG9uZW50cyB0byBsaXR0bGUgZW5kaWFuXG4gICAgICAgIHZhciB4ID0gcGIuc2xpY2UoMSwgMzMpLnJldmVyc2UoKTtcbiAgICAgICAgdmFyIHkgPSBwYi5zbGljZSgzMywgNjUpLnJldmVyc2UoKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRPRE86IEZpbmQgb3V0IHdoeSBCdWZmZXIgd29uJ3QgYWNjZXB0IHBiWzBdXG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtwYlswXSwgeCwgeV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBiO1xuICAgIH1cbn07XG5leHBvcnRzLmdldFB1YktleUJ5dGVzID0gZ2V0UHViS2V5Qnl0ZXM7XG4vKipcbiAqIEdldCB0aGUgc2hhcmVkIHNlY3JldCwgZGVyaXZlZCB2aWEgRUNESCBmcm9tIHRoZSBsb2NhbCBwcml2YXRlIGtleSBhbmQgdGhlIGVwaGVtZXJhbCBwdWJsaWMga2V5XG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIEJ1ZmZlclxuICovXG52YXIgZ2V0U2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24gKGtleSwgZXBoZW1lcmFsUHViKSB7XG4gICAgLy8gT25jZSBldmVyeSB+MjU2IGF0dGVtcHRzLCB3ZSB3aWxsIGdldCBhIGtleSB0aGF0IHN0YXJ0cyB3aXRoIGEgYDAwYCBieXRlLCB3aGljaCBjYW4gbGVhZCB0b1xuICAgIC8vIHByb2JsZW1zIGluaXRpYWxpemluZyBBRVMgaWYgd2UgZG9uJ3QgZm9yY2UgYSAzMiBieXRlIEJFIGJ1ZmZlci5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oa2V5LmRlcml2ZShlcGhlbWVyYWxQdWIuZ2V0UHVibGljKCkpLnRvQXJyYXkoJ2JlJywgMzIpKTtcbn07XG5leHBvcnRzLmdldFNoYXJlZFNlY3JldCA9IGdldFNoYXJlZFNlY3JldDtcbi8vIEdpdmVuIGEgc2V0IG9mIHdhbGxldCBkYXRhLCB3aGljaCBjb250YWlucyB0d28gd2FsbGV0IGRlc2NyaXB0b3JzLCBwYXJzZSB0aGUgZGF0YSBhbmQgc2F2ZSBpdFxuLy8gdG8gbWVtb3J5XG52YXIgcGFyc2VXYWxsZXRzID0gZnVuY3Rpb24gKHdhbGxldERhdGEpIHtcbiAgICAvLyBSZWFkIHRoZSBleHRlcm5hbCB3YWxsZXQgZGF0YSBmaXJzdC4gSWYgaXQgaXMgbm9uLW51bGwsIHRoZSBleHRlcm5hbCB3YWxsZXQgd2lsbCBiZSB0aGVcbiAgICAvLyBhY3RpdmUgd2FsbGV0IG9mIHRoZSBkZXZpY2UgYW5kIHdlIHNob3VsZCBzYXZlIGl0LiBJZiB0aGUgZXh0ZXJuYWwgd2FsbGV0IGlzIGJsYW5rLCBpdCBtZWFuc1xuICAgIC8vIHRoZXJlIGlzIG5vIGNhcmQgcHJlc2VudCBhbmQgd2Ugc2hvdWxkIHNhdmUgYW5kIHVzZSB0aGUgaW50ZXJhbCB3YWxsZXQuIElmIGJvdGggd2FsbGV0cyBhcmVcbiAgICAvLyBlbXB0eSwgaXQgbWVhbnMgdGhlIGRldmljZSBzdGlsbCBuZWVkcyB0byBiZSBzZXQgdXAuXG4gICAgdmFyIHdhbGxldERlc2NyaXB0b3JMZW4gPSA3MTtcbiAgICAvLyBJbnRlcm5hbCBmaXJzdFxuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBhY3RpdmVXYWxsZXRzID0ge1xuICAgICAgICBpbnRlcm5hbDoge1xuICAgICAgICAgICAgdWlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZXJuYWw6IHtcbiAgICAgICAgICAgIHVpZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGFjdGl2ZVdhbGxldHMuaW50ZXJuYWwudWlkID0gd2FsbGV0RGF0YS5zbGljZShvZmYsIG9mZiArIDMyKTtcbiAgICAvLyBOT1RFOiBgY2FwYWJpbGl0aWVzYCBhbmQgYG5hbWVgIHdlcmUgZGVwcmVjYXRlZCBpbiBMYXR0aWNlIGZpcm13YXJlLlxuICAgIC8vIFRoZXkgbmV2ZXIgcHJvdmlkZWQgYW55IHJlYWwgaW5mb3JtYXRpb24sIGJ1dCBoYXZlIGJlZW4gYXJjaGl2ZWQgaGVyZVxuICAgIC8vIHNpbmNlIHRoZSByZXNwb25zZSBzaXplIGhhcyBiZWVuIHByZXNlcnZlZCBhbmQgd2UgbWF5IGJyaW5nIHRoZW0gYmFja1xuICAgIC8vIGluIGEgZGlmZmVyZW50IGZvcm0uXG4gICAgLy8gYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC5jYXBhYmlsaXRpZXMgPSB3YWxsZXREYXRhLnJlYWRVSW50MzJCRShvZmYgKyAzMik7XG4gICAgLy8gYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC5uYW1lID0gd2FsbGV0RGF0YS5zbGljZShcbiAgICAvLyBvZmYgKyAzNixcbiAgICAvLyBvZmYgKyB3YWxsZXREZXNjcmlwdG9yTGVuLFxuICAgIC8vICk7XG4gICAgLy8gT2Zmc2V0IHRoZSBmaXJzdCBpdGVtXG4gICAgb2ZmICs9IHdhbGxldERlc2NyaXB0b3JMZW47XG4gICAgLy8gRXh0ZXJuYWxcbiAgICBhY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZCA9IHdhbGxldERhdGEuc2xpY2Uob2ZmLCBvZmYgKyAzMik7XG4gICAgLy8gYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5jYXBhYmlsaXRpZXMgPSB3YWxsZXREYXRhLnJlYWRVSW50MzJCRShvZmYgKyAzMik7XG4gICAgLy8gYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5uYW1lID0gd2FsbGV0RGF0YS5zbGljZShcbiAgICAvLyBvZmYgKyAzNixcbiAgICAvLyBvZmYgKyB3YWxsZXREZXNjcmlwdG9yTGVuLFxuICAgIC8vICk7XG4gICAgcmV0dXJuIGFjdGl2ZVdhbGxldHM7XG59O1xuZXhwb3J0cy5wYXJzZVdhbGxldHMgPSBwYXJzZVdhbGxldHM7XG4vLyBEZXRlcm1pbmUgaWYgYSBwcm92aWRlZCBmaXJtd2FyZSB2ZXJzaW9uIG1hdGNoZXMgb3IgZXhjZWVkcyB0aGUgY3VycmVudCBmaXJtd2FyZSB2ZXJzaW9uXG52YXIgaXNGV1N1cHBvcnRlZCA9IGZ1bmN0aW9uIChmd1ZlcnNpb24sIHZlcnNpb25TdXBwb3J0ZWQpIHtcbiAgICB2YXIgbWFqb3IgPSBmd1ZlcnNpb24ubWFqb3IsIG1pbm9yID0gZndWZXJzaW9uLm1pbm9yLCBmaXggPSBmd1ZlcnNpb24uZml4O1xuICAgIHZhciBfbWFqb3IgPSB2ZXJzaW9uU3VwcG9ydGVkLm1ham9yLCBfbWlub3IgPSB2ZXJzaW9uU3VwcG9ydGVkLm1pbm9yLCBfZml4ID0gdmVyc2lvblN1cHBvcnRlZC5maXg7XG4gICAgcmV0dXJuIChtYWpvciA+IF9tYWpvciB8fFxuICAgICAgICAobWFqb3IgPj0gX21ham9yICYmIG1pbm9yID4gX21pbm9yKSB8fFxuICAgICAgICAobWFqb3IgPj0gX21ham9yICYmIG1pbm9yID49IF9taW5vciAmJiBmaXggPj0gX2ZpeCkpO1xufTtcbmV4cG9ydHMuaXNGV1N1cHBvcnRlZCA9IGlzRldTdXBwb3J0ZWQ7XG4vKipcbiAqIENvbnZlcnQgYSBzZXQgb2YgQklQMzkgcGF0aCBpbmRpY2VzIHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gcGF0aCAtIFNldCBvZiBpbmRpY2VzXG4gKi9cbnZhciBnZXRQYXRoU3RyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgcGF0aFN0ciA9ICdtJztcbiAgICBwYXRoLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICBpZiAoaWR4ID49IGNvbnN0YW50c18xLkhBUkRFTkVEX09GRlNFVCkge1xuICAgICAgICAgICAgcGF0aFN0ciArPSBcIi9cIi5jb25jYXQoaWR4IC0gY29uc3RhbnRzXzEuSEFSREVORURfT0ZGU0VULCBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoU3RyICs9IFwiL1wiLmNvbmNhdChpZHgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGhTdHI7XG59O1xuZXhwb3J0cy5nZXRQYXRoU3RyID0gZ2V0UGF0aFN0cjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkNEJ5dGVSZXNwb25zZSA9IGV4cG9ydHMuaXNWYWxpZEJsb2NrRXhwbG9yZXJSZXNwb25zZSA9IGV4cG9ydHMudmFsaWRhdGVLdlJlY29yZCA9IGV4cG9ydHMudmFsaWRhdGVLdlJlY29yZHMgPSBleHBvcnRzLnZhbGlkYXRlQWN0aXZlV2FsbGV0cyA9IGV4cG9ydHMudmFsaWRhdGVLZXkgPSBleHBvcnRzLnZhbGlkYXRlU2hhcmVkU2VjcmV0ID0gZXhwb3J0cy52YWxpZGF0ZUVwaGVtZXJhbFB1YiA9IGV4cG9ydHMudmFsaWRhdGVDb25uZWN0ZWRDbGllbnQgPSBleHBvcnRzLnZhbGlkYXRlV2FsbGV0ID0gZXhwb3J0cy52YWxpZGF0ZVJlcXVlc3RFcnJvciA9IGV4cG9ydHMudmFsaWRhdGVGd1ZlcnNpb24gPSBleHBvcnRzLnZhbGlkYXRlRndDb25zdGFudHMgPSBleHBvcnRzLnZhbGlkYXRlQmFzZVVybCA9IGV4cG9ydHMudmFsaWRhdGVVcmwgPSBleHBvcnRzLnZhbGlkYXRlQXBwTmFtZSA9IGV4cG9ydHMudmFsaWRhdGVEZXZpY2VJZCA9IGV4cG9ydHMudmFsaWRhdGVTdGFydFBhdGggPSBleHBvcnRzLnZhbGlkYXRlTkFkZHJlc3NlcyA9IGV4cG9ydHMudmFsaWRhdGVJc1VJbnQ0ID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBpc0VtcHR5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpKTtcbnZhciB2YWxpZGF0ZUlzVUludDQgPSBmdW5jdGlvbiAobikge1xuICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgISgwLCB1dGlsXzEuaXNVSW50NCkobikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCAxNSBpbmNsdXNpdmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuZXhwb3J0cy52YWxpZGF0ZUlzVUludDQgPSB2YWxpZGF0ZUlzVUludDQ7XG52YXIgdmFsaWRhdGVOQWRkcmVzc2VzID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAoIW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbnVtYmVyIG9mIGFkZHJlc3NlcyBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG4gICAgaWYgKG4gPiBjb25zdGFudHNfMS5NQVhfQUREUikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbWF5IG9ubHkgcmVxdWVzdCBcIi5jb25jYXQoY29uc3RhbnRzXzEuTUFYX0FERFIsIFwiIGFkZHJlc3NlcyBhdCBvbmNlLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufTtcbmV4cG9ydHMudmFsaWRhdGVOQWRkcmVzc2VzID0gdmFsaWRhdGVOQWRkcmVzc2VzO1xudmFyIHZhbGlkYXRlU3RhcnRQYXRoID0gZnVuY3Rpb24gKHN0YXJ0UGF0aCkge1xuICAgIGlmICghc3RhcnRQYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhcnQgcGF0aCBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoc3RhcnRQYXRoLmxlbmd0aCA8IDEgfHwgc3RhcnRQYXRoLmxlbmd0aCA+IDUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IGluY2x1ZGUgYmV0d2VlbiAxIGFuZCA1IGluZGljZXMnKTtcbiAgICByZXR1cm4gc3RhcnRQYXRoO1xufTtcbmV4cG9ydHMudmFsaWRhdGVTdGFydFBhdGggPSB2YWxpZGF0ZVN0YXJ0UGF0aDtcbnZhciB2YWxpZGF0ZURldmljZUlkID0gZnVuY3Rpb24gKGRldmljZUlkKSB7XG4gICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRldmljZSBJRCBoYXMgYmVlbiBzdG9yZWQuIFBsZWFzZSBjb25uZWN0IHdpdGggeW91ciBkZXZpY2UgSUQgZmlyc3QuJyk7XG4gICAgfVxuICAgIHJldHVybiBkZXZpY2VJZDtcbn07XG5leHBvcnRzLnZhbGlkYXRlRGV2aWNlSWQgPSB2YWxpZGF0ZURldmljZUlkO1xudmFyIHZhbGlkYXRlQXBwTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG4gICAgaWYgKG5hbWUubGVuZ3RoIDwgNSB8fCBuYW1lLmxlbmd0aCA+IDI0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsZW5ndGggZm9yIG5hbWUgcHJvdmlkZWQuIE11c3QgYmUgNS0yNCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG5leHBvcnRzLnZhbGlkYXRlQXBwTmFtZSA9IHZhbGlkYXRlQXBwTmFtZTtcbnZhciB2YWxpZGF0ZVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIHJlY29ubmVjdC4nKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFVSTCh1cmwpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVUkwgcHJvdmlkZWQuIFBsZWFzZSB1c2UgYSB2YWxpZCBVUkwuJyk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVVybCA9IHZhbGlkYXRlVXJsO1xudmFyIHZhbGlkYXRlQmFzZVVybCA9IGZ1bmN0aW9uIChiYXNlVXJsKSB7XG4gICAgaWYgKCFiYXNlVXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFzZSBVUkwgaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG5ldyBVUkwoYmFzZVVybCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEJhc2UgVVJMIHByb3ZpZGVkLiBQbGVhc2UgdXNlIGEgdmFsaWQgVVJMLicpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVVybDtcbn07XG5leHBvcnRzLnZhbGlkYXRlQmFzZVVybCA9IHZhbGlkYXRlQmFzZVVybDtcbnZhciB2YWxpZGF0ZUZ3Q29uc3RhbnRzID0gZnVuY3Rpb24gKGZ3Q29uc3RhbnRzKSB7XG4gICAgaWYgKCFmd0NvbnN0YW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zpcm13YXJlIGNvbnN0YW50cyBkbyBub3QgZXhpc3QuIFBsZWFzZSByZWNvbm5lY3QuJyk7XG4gICAgfVxuICAgIHJldHVybiBmd0NvbnN0YW50cztcbn07XG5leHBvcnRzLnZhbGlkYXRlRndDb25zdGFudHMgPSB2YWxpZGF0ZUZ3Q29uc3RhbnRzO1xudmFyIHZhbGlkYXRlRndWZXJzaW9uID0gZnVuY3Rpb24gKGZ3VmVyc2lvbikge1xuICAgIGlmICghZndWZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlybXdhcmUgdmVyc2lvbiBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIHJlY29ubmVjdC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmd1ZlcnNpb24uZml4ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgZndWZXJzaW9uLm1pbm9yICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgZndWZXJzaW9uLm1ham9yICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zpcm13YXJlIHZlcnNpb24gaW1wcm9wZXJseSBmb3JtYXR0ZWQuIFBsZWFzZSByZWNvbm5lY3QuJyk7XG4gICAgfVxuICAgIHJldHVybiBmd1ZlcnNpb247XG59O1xuZXhwb3J0cy52YWxpZGF0ZUZ3VmVyc2lvbiA9IHZhbGlkYXRlRndWZXJzaW9uO1xudmFyIHZhbGlkYXRlUmVxdWVzdEVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBpc1RpbWVvdXQgPSBlcnIuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcgJiYgZXJyLmVycm5vID09PSAnRVRJTUUnO1xuICAgIGlmIChpc1RpbWVvdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW1lb3V0IHdhaXRpbmcgZm9yIGRldmljZS4gUGxlYXNlIGVuc3VyZSBpdCBpcyBjb25uZWN0ZWQgdG8gdGhlIGludGVybmV0IGFuZCB0cnkgYWdhaW4gaW4gYSBtaW51dGUuJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBtYWtlIHJlcXVlc3QgdG8gZGV2aWNlOlxcblwiLmNvbmNhdChlcnIubWVzc2FnZSkpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVSZXF1ZXN0RXJyb3IgPSB2YWxpZGF0ZVJlcXVlc3RFcnJvcjtcbnZhciB2YWxpZGF0ZVdhbGxldCA9IGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICBpZiAoIXdhbGxldCB8fCB3YWxsZXQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgd2FsbGV0LicpO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0O1xufTtcbmV4cG9ydHMudmFsaWRhdGVXYWxsZXQgPSB2YWxpZGF0ZVdhbGxldDtcbnZhciB2YWxpZGF0ZUNvbm5lY3RlZENsaWVudCA9IGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICB2YXIgYXBwTmFtZSA9ICgwLCBleHBvcnRzLnZhbGlkYXRlQXBwTmFtZSkoY2xpZW50LmdldEFwcE5hbWUoKSk7XG4gICAgdmFyIGVwaGVtZXJhbFB1YiA9ICgwLCBleHBvcnRzLnZhbGlkYXRlRXBoZW1lcmFsUHViKShjbGllbnQuZXBoZW1lcmFsUHViKTtcbiAgICB2YXIgc2hhcmVkU2VjcmV0ID0gKDAsIGV4cG9ydHMudmFsaWRhdGVTaGFyZWRTZWNyZXQpKGNsaWVudC5zaGFyZWRTZWNyZXQpO1xuICAgIHZhciB1cmwgPSAoMCwgZXhwb3J0cy52YWxpZGF0ZVVybCkoY2xpZW50LnVybCk7XG4gICAgdmFyIGZ3Q29uc3RhbnRzID0gKDAsIGV4cG9ydHMudmFsaWRhdGVGd0NvbnN0YW50cykoY2xpZW50LmdldEZ3Q29uc3RhbnRzKCkpO1xuICAgIHZhciBmd1ZlcnNpb24gPSAoMCwgZXhwb3J0cy52YWxpZGF0ZUZ3VmVyc2lvbikoY2xpZW50LmdldEZ3VmVyc2lvbigpKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gS2V5IGlzIHByaXZhdGVcbiAgICB2YXIga2V5ID0gKDAsIGV4cG9ydHMudmFsaWRhdGVLZXkpKGNsaWVudC5rZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFwcE5hbWU6IGFwcE5hbWUsXG4gICAgICAgIGVwaGVtZXJhbFB1YjogZXBoZW1lcmFsUHViLFxuICAgICAgICBzaGFyZWRTZWNyZXQ6IHNoYXJlZFNlY3JldCxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGZ3Q29uc3RhbnRzOiBmd0NvbnN0YW50cyxcbiAgICAgICAgZndWZXJzaW9uOiBmd1ZlcnNpb24sXG4gICAgICAgIGtleToga2V5LFxuICAgIH07XG59O1xuZXhwb3J0cy52YWxpZGF0ZUNvbm5lY3RlZENsaWVudCA9IHZhbGlkYXRlQ29ubmVjdGVkQ2xpZW50O1xudmFyIHZhbGlkYXRlRXBoZW1lcmFsUHViID0gZnVuY3Rpb24gKGVwaGVtZXJhbFB1Yikge1xuICAgIGlmICghZXBoZW1lcmFsUHViKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYGVwaGVtZXJhbFB1YmAgKGVwaGVtZXJhbCBwdWJsaWMga2V5KSBpcyByZXF1aXJlZC4gUGxlYXNlIHJlY29ubmVjdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVwaGVtZXJhbFB1Yjtcbn07XG5leHBvcnRzLnZhbGlkYXRlRXBoZW1lcmFsUHViID0gdmFsaWRhdGVFcGhlbWVyYWxQdWI7XG52YXIgdmFsaWRhdGVTaGFyZWRTZWNyZXQgPSBmdW5jdGlvbiAoc2hhcmVkU2VjcmV0KSB7XG4gICAgaWYgKCFzaGFyZWRTZWNyZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFyZWQgc2VjcmV0IHJlcXVpcmVkLiBQbGVhc2UgcmVjb25uZWN0LicpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVkU2VjcmV0O1xufTtcbmV4cG9ydHMudmFsaWRhdGVTaGFyZWRTZWNyZXQgPSB2YWxpZGF0ZVNoYXJlZFNlY3JldDtcbnZhciB2YWxpZGF0ZUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBpcyByZXF1aXJlZC4gUGxlYXNlIHJlY29ubmVjdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn07XG5leHBvcnRzLnZhbGlkYXRlS2V5ID0gdmFsaWRhdGVLZXk7XG52YXIgdmFsaWRhdGVBY3RpdmVXYWxsZXRzID0gZnVuY3Rpb24gKGFjdGl2ZVdhbGxldHMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKCFhY3RpdmVXYWxsZXRzIHx8XG4gICAgICAgICgoKF9iID0gKF9hID0gYWN0aXZlV2FsbGV0cyA9PT0gbnVsbCB8fCBhY3RpdmVXYWxsZXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVXYWxsZXRzLmludGVybmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudWlkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXF1YWxzKGNvbnN0YW50c18xLkVNUFRZX1dBTExFVF9VSUQpKSAmJlxuICAgICAgICAgICAgKChfZCA9IChfYyA9IGFjdGl2ZVdhbGxldHMgPT09IG51bGwgfHwgYWN0aXZlV2FsbGV0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlV2FsbGV0cy5leHRlcm5hbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVpZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmVxdWFscyhjb25zdGFudHNfMS5FTVBUWV9XQUxMRVRfVUlEKSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHdhbGxldC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVdhbGxldHM7XG59O1xuZXhwb3J0cy52YWxpZGF0ZUFjdGl2ZVdhbGxldHMgPSB2YWxpZGF0ZUFjdGl2ZVdhbGxldHM7XG52YXIgdmFsaWRhdGVLdlJlY29yZHMgPSBmdW5jdGlvbiAocmVjb3JkcywgZndDb25zdGFudHMpIHtcbiAgICBpZiAoIWZ3Q29uc3RhbnRzIHx8ICFmd0NvbnN0YW50cy5rdkFjdGlvbnNBbGxvd2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgZmlybXdhcmUuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZWNvcmRzICE9PSAnb2JqZWN0JyB8fCBPYmplY3Qua2V5cyhyZWNvcmRzKS5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9yIG1vcmUga2V5LXZhbHVlIG1hcHBpbmcgbXVzdCBiZSBwcm92aWRlZCBpbiBgcmVjb3Jkc2AgcGFyYW0uJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5rZXlzKHJlY29yZHMpLmxlbmd0aCA+IGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBtYW55IGtleXMgcHJvdmlkZWQuIFBsZWFzZSBvbmx5IHByb3ZpZGUgdXAgdG8gXCIuY29uY2F0KGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtLCBcIi5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5leHBvcnRzLnZhbGlkYXRlS3ZSZWNvcmRzID0gdmFsaWRhdGVLdlJlY29yZHM7XG52YXIgdmFsaWRhdGVLdlJlY29yZCA9IGZ1bmN0aW9uIChfYSwgZndDb25zdGFudHMpIHtcbiAgICB2YXIga2V5ID0gX2Eua2V5LCB2YWwgPSBfYS52YWw7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIFN0cmluZyhrZXkpLmxlbmd0aCA+IGZ3Q29uc3RhbnRzLmt2S2V5TWF4U3RyU3opIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IFwiLmNvbmNhdChrZXksIFwiIHRvbyBsYXJnZS4gTXVzdCBiZSA8PVwiKS5jb25jYXQoZndDb25zdGFudHMua3ZLZXlNYXhTdHJTeiwgXCIgY2hhcmFjdGVycy5cIikpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICBTdHJpbmcodmFsKS5sZW5ndGggPiBmd0NvbnN0YW50cy5rdlZhbE1heFN0clN6KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIFwiLmNvbmNhdCh2YWwsIFwiIHRvbyBsYXJnZS4gTXVzdCBiZSA8PVwiKS5jb25jYXQoZndDb25zdGFudHMua3ZWYWxNYXhTdHJTeiwgXCIgY2hhcmFjdGVycy5cIikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChTdHJpbmcoa2V5KS5sZW5ndGggPT09IDAgfHwgU3RyaW5nKHZhbCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5cyBhbmQgdmFsdWVzIG11c3QgYmUgPjAgY2hhcmFjdGVycy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWNvbnN0YW50c18xLkFTQ0lJX1JFR0VYLnRlc3Qoa2V5KSB8fCAhY29uc3RhbnRzXzEuQVNDSUlfUkVHRVgudGVzdCh2YWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICByZXR1cm4geyBrZXk6IGtleSwgdmFsOiB2YWwgfTtcbn07XG5leHBvcnRzLnZhbGlkYXRlS3ZSZWNvcmQgPSB2YWxpZGF0ZUt2UmVjb3JkO1xudmFyIGlzVmFsaWRCbG9ja0V4cGxvcmVyUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEucmVzdWx0KTtcbiAgICAgICAgcmV0dXJuICEoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKHJlc3VsdCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5leHBvcnRzLmlzVmFsaWRCbG9ja0V4cGxvcmVyUmVzcG9uc2UgPSBpc1ZhbGlkQmxvY2tFeHBsb3JlclJlc3BvbnNlO1xudmFyIGlzVmFsaWQ0Qnl0ZVJlc3BvbnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoZGF0YS5yZXN1bHRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNWYWxpZDRCeXRlUmVzcG9uc2UgPSBpc1ZhbGlkNEJ5dGVSZXNwb25zZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FWFRFUk5BTCA9IGV4cG9ydHMuZ2V0ViA9IGV4cG9ydHMuZ2VuZXJhdGVBcHBTZWNyZXQgPSBleHBvcnRzLmZldGNoQ2FsbGRhdGFEZWNvZGVyID0gZXhwb3J0cy5mZXRjaFdpdGhUaW1lb3V0ID0gZXhwb3J0cy5zZWxlY3REZWZGcm9tNGJ5dGVBQkkgPSBleHBvcnRzLmlzVUludDQgPSBleHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy5leGlzdHNJbiA9IGV4cG9ydHMuaXNBc2NpaVN0ciA9IGV4cG9ydHMuYnVpbGRTaWduZXJQYXRoQnVmID0gZXhwb3J0cy5nZXRQMjU2S2V5UGFpckZyb21QdWIgPSBleHBvcnRzLmdldFAyNTZLZXlQYWlyID0gZXhwb3J0cy5wYXJzZURFUiA9IGV4cG9ydHMuYWVzMjU2X2RlY3J5cHQgPSBleHBvcnRzLmFlczI1Nl9lbmNyeXB0ID0gZXhwb3J0cy5maXhMZW4gPSBleHBvcnRzLmVuc3VyZUhleEJ1ZmZlciA9IGV4cG9ydHMuc3BsaXRGcmFtZXMgPSBleHBvcnRzLmlzVmFsaWRBc3NldFBhdGggPSBleHBvcnRzLnRvUGFkZGVkREVSID0gZXhwb3J0cy5jaGVja3N1bSA9IGV4cG9ydHMucGFyc2VMYXR0aWNlMVJlc3BvbnNlID0gdm9pZCAwO1xuLy8gU3RhdGljIHV0aWxpdHkgZnVuY3Rpb25zXG52YXIgdHhfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy90eFwiKTtcbnZhciBhZXNfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYWVzLWpzXCIpKTtcbnZhciBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbnZhciBibl9qc18xID0gcmVxdWlyZShcImJuLmpzXCIpO1xudmFyIGNyY18zMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcmMtMzJcIikpO1xudmFyIGVsbGlwdGljXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVsbGlwdGljXCIpKTtcbnZhciBzaGFfMSA9IHJlcXVpcmUoXCJoYXNoLmpzL2xpYi9oYXNoL3NoYVwiKTtcbnZhciBqc19zaGEzXzEgPSByZXF1aXJlKFwianMtc2hhM1wiKTtcbnZhciBpblJhbmdlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pblJhbmdlXCIpKTtcbnZhciBpc0ludGVnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzSW50ZWdlclwiKSk7XG52YXIgcmxwXzEgPSByZXF1aXJlKFwicmxwXCIpO1xudmFyIHNlY3AyNTZrMV8xID0gcmVxdWlyZShcInNlY3AyNTZrMVwiKTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIHByb3RvY29sXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbFwiKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi9zaGFyZWQvdmFsaWRhdG9yc1wiKTtcbnZhciBDT0lOUyA9IGNvbnN0YW50c18xLkJJUF9DT05TVEFOVFMuQ09JTlMsIFBVUlBPU0VTID0gY29uc3RhbnRzXzEuQklQX0NPTlNUQU5UUy5QVVJQT1NFUztcbnZhciBFQyA9IGVsbGlwdGljXzEuZGVmYXVsdC5lYztcbnZhciBlYztcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExBVFRJQ0UgVVRJTFNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBAaW50ZXJuYWwgUGFyc2UgYSByZXNwb25zZSBmcm9tIHRoZSBMYXR0aWNlMSAqL1xudmFyIHBhcnNlTGF0dGljZTFSZXNwb25zZSA9IGZ1bmN0aW9uIChyKSB7XG4gICAgdmFyIHBhcnNlZCA9IHtcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBudWxsLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgIH07XG4gICAgdmFyIGIgPSBCdWZmZXIuZnJvbShyLCAnaGV4Jyk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgLy8gR2V0IHByb3RvY29sIHZlcnNpb25cbiAgICB2YXIgcHJvdG9WZXIgPSBiLnJlYWRVSW50OChvZmYpO1xuICAgIG9mZisrO1xuICAgIGlmIChwcm90b1ZlciAhPT0gY29uc3RhbnRzXzEuVkVSU0lPTl9CWVRFKSB7XG4gICAgICAgIHBhcnNlZC5lcnJvck1lc3NhZ2UgPSAnSW5jb3JyZWN0IHByb3RvY29sIHZlcnNpb24uIFBsZWFzZSB1cGRhdGUgeW91ciBTREsnO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHR5cGUgb2YgcmVzcG9uc2VcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIDB4MDBcbiAgICB2YXIgbXNnVHlwZSA9IGIucmVhZFVJbnQ4KG9mZik7XG4gICAgb2ZmKys7XG4gICAgaWYgKG1zZ1R5cGUgIT09IDB4MDApIHtcbiAgICAgICAgcGFyc2VkLmVycm9yTWVzc2FnZSA9ICdJbmNvcnJlY3QgcmVzcG9uc2UgZnJvbSBMYXR0aWNlMSc7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgcGF5bG9hZFxuICAgIGIucmVhZFVJbnQzMkJFKG9mZik7XG4gICAgb2ZmICs9IDQ7IC8vIEZpcnN0IDQgYnl0ZXMgaXMgdGhlIGlkLCBidXQgd2UgZG9uJ3QgbmVlZCB0aGF0IGFueW1vcmVcbiAgICB2YXIgbGVuID0gYi5yZWFkVUludDE2QkUob2ZmKTtcbiAgICBvZmYgKz0gMjtcbiAgICB2YXIgcGF5bG9hZCA9IGIuc2xpY2Uob2ZmLCBvZmYgKyBsZW4pO1xuICAgIG9mZiArPSBsZW47XG4gICAgLy8gR2V0IHJlc3BvbnNlIGNvZGVcbiAgICB2YXIgcmVzcG9uc2VDb2RlID0gcGF5bG9hZC5yZWFkVUludDgoMCk7XG4gICAgaWYgKHJlc3BvbnNlQ29kZSAhPT0gcHJvdG9jb2xfMS5MYXR0aWNlUmVzcG9uc2VDb2RlLnN1Y2Nlc3MpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IHByb3RvY29sXzEuUHJvdG9jb2xDb25zdGFudHMucmVzcG9uc2VNc2dbcmVzcG9uc2VDb2RlXTtcbiAgICAgICAgcGFyc2VkLmVycm9yTWVzc2FnZSA9IFwiW0xhdHRpY2VdIFwiLmNvbmNhdChlcnJNc2cgPyBlcnJNc2cgOiAnVW5rbm93biBFcnJvcicpO1xuICAgICAgICBwYXJzZWQucmVzcG9uc2VDb2RlID0gcmVzcG9uc2VDb2RlO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyc2VkLmRhdGEgPSBwYXlsb2FkLnNsaWNlKDEsIHBheWxvYWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gVmVyaWZ5IGNoZWNrc3VtXG4gICAgdmFyIGNzID0gYi5yZWFkVUludDMyQkUob2ZmKTtcbiAgICB2YXIgZXhwZWN0ZWRDcyA9ICgwLCBleHBvcnRzLmNoZWNrc3VtKShiLnNsaWNlKDAsIGIubGVuZ3RoIC0gNCkpO1xuICAgIGlmIChjcyAhPT0gZXhwZWN0ZWRDcykge1xuICAgICAgICBwYXJzZWQuZXJyb3JNZXNzYWdlID0gJ0ludmFsaWQgY2hlY2tzdW0gZnJvbSBkZXZpY2UgcmVzcG9uc2UnO1xuICAgICAgICBwYXJzZWQuZGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuZXhwb3J0cy5wYXJzZUxhdHRpY2UxUmVzcG9uc2UgPSBwYXJzZUxhdHRpY2UxUmVzcG9uc2U7XG4vKiogQGludGVybmFsICovXG52YXIgY2hlY2tzdW0gPSBmdW5jdGlvbiAoeCkge1xuICAgIC8vIGNyYzMyIHJldHVybnMgYSBzaWduZWQgaW50ZWdlciAtIG5lZWQgdG8gY2FzdCBpdCB0byB1bnNpZ25lZFxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHVzZXMgdGhlIGRlZmF1bHQgMHhlZGI4ODMyMCBwb2x5bm9taWFsXG4gICAgcmV0dXJuIGNyY18zMl8xLmRlZmF1bHQuYnVmKHgpID4+PiAwOyAvLyBOZWVkIHRoaXMgdG8gYmUgYSB1aW50LCBoZW5jZSB0aGUgYml0IHNoaWZ0XG59O1xuZXhwb3J0cy5jaGVja3N1bSA9IGNoZWNrc3VtO1xuLy8gR2V0IGEgNzQtYnl0ZSBwYWRkZWQgREVSLWVuY29kZWQgc2lnbmF0dXJlIGJ1ZmZlclxuLy8gYHNpZ2AgbXVzdCBiZSB0aGUgc2lnbmF0dXJlIG91dHB1dCBmcm9tIGVsbGlwdGljLmpzXG4vKiogQGludGVybmFsICovXG52YXIgdG9QYWRkZWRERVIgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgLy8gV2UgdXNlIDc0IGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhIERFUiBzaWduYXR1cmUuIEFsbCBzaWdzIG11c3RcbiAgICAvLyBiZSByaWdodC1wYWRkZWQgd2l0aCB6ZXJvcyBzbyB0aGF0IHRoaXMgY2FuIGJlIGEgZml4ZWQgc2l6ZSBmaWVsZFxuICAgIHZhciBiID0gQnVmZmVyLmFsbG9jKDc0KTtcbiAgICB2YXIgZHMgPSBCdWZmZXIuZnJvbShzaWcudG9ERVIoKSk7XG4gICAgZHMuY29weShiKTtcbiAgICByZXR1cm4gYjtcbn07XG5leHBvcnRzLnRvUGFkZGVkREVSID0gdG9QYWRkZWRERVI7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUUkFOU0FDVElPTiBVVElMU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGlzVmFsaWRBc3NldFBhdGggPSBmdW5jdGlvbiAocGF0aCwgZndDb25zdGFudHMpIHtcbiAgICB2YXIgYWxsb3dlZFB1cnBvc2VzID0gW1xuICAgICAgICBQVVJQT1NFUy5FVEgsXG4gICAgICAgIFBVUlBPU0VTLkJUQ19MRUdBQ1ksXG4gICAgICAgIFBVUlBPU0VTLkJUQ19XUkFQUEVEX1NFR1dJVCxcbiAgICAgICAgUFVSUE9TRVMuQlRDX1NFR1dJVCxcbiAgICBdO1xuICAgIHZhciBhbGxvd2VkQ29pbnMgPSBbQ09JTlMuRVRILCBDT0lOUy5CVEMsIENPSU5TLkJUQ19URVNUTkVUXTtcbiAgICAvLyBUaGVzZSBjb2luIHR5cGVzIHdlcmUgZ2l2ZW4gdG8gdXMgYnkgTXlDcnlwdG8uIFRoZXkgc2hvdWxkIGJlIGFsbG93ZWQsIGJ1dCB3ZSBleHBlY3RcbiAgICAvLyBhbiBFdGhlcmV1bS10eXBlIGFkZHJlc3Mgd2l0aCB0aGVzZSBjb2luIHR5cGVzLlxuICAgIC8vIFRoZXNlIGFsbCB1c2UgU0xJUDQ0OiBodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kXG4gICAgdmFyIGFsbG93ZWRNeUNyeXB0b0NvaW5zID0gW1xuICAgICAgICA2MCwgNjEsIDk2NiwgNzAwLCA5MDA2LCA5MDAwLCAxMDA3LCA1NTMsIDE3OCwgMTM3LCAzNzMxMCwgMTA4LCA0MCwgODg5LFxuICAgICAgICAxOTg3LCA4MjAsIDYwNjAsIDE2MjAsIDEzMTMxMTQsIDc2LCAyNDY1MjksIDI0Njc4NSwgMTAwMSwgMjI3LCA5MTYsIDQ2NCxcbiAgICAgICAgMjIyMSwgMzQ0LCA3Mzc5OSwgMjQ2LFxuICAgIF07XG4gICAgLy8gTWFrZSBzdXJlIGZpcm13YXJlIHN1cHBvcnRzIHRoaXMgQml0Y29pbiBwYXRoXG4gICAgdmFyIGlzQml0Y29pbiA9IHBhdGhbMV0gPT09IENPSU5TLkJUQyB8fCBwYXRoWzFdID09PSBDT0lOUy5CVENfVEVTVE5FVDtcbiAgICB2YXIgaXNCaXRjb2luTm9uV3JhcHBlZFNlZ3dpdCA9IGlzQml0Y29pbiAmJiBwYXRoWzBdICE9PSBQVVJQT1NFUy5CVENfV1JBUFBFRF9TRUdXSVQ7XG4gICAgaWYgKGlzQml0Y29pbk5vbldyYXBwZWRTZWd3aXQgJiYgIWZ3Q29uc3RhbnRzLmFsbG93QnRjTGVnYWN5QW5kU2Vnd2l0QWRkcnMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBwYXRoIGlzIG90aGVyd2lzZSB2YWxpZFxuICAgIHJldHVybiAoYWxsb3dlZFB1cnBvc2VzLmluZGV4T2YocGF0aFswXSkgPj0gMCAmJlxuICAgICAgICAoYWxsb3dlZENvaW5zLmluZGV4T2YocGF0aFsxXSkgPj0gMCB8fFxuICAgICAgICAgICAgYWxsb3dlZE15Q3J5cHRvQ29pbnMuaW5kZXhPZihwYXRoWzFdIC0gY29uc3RhbnRzXzEuSEFSREVORURfT0ZGU0VUKSA+IDApKTtcbn07XG5leHBvcnRzLmlzVmFsaWRBc3NldFBhdGggPSBpc1ZhbGlkQXNzZXRQYXRoO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIHNwbGl0RnJhbWVzID0gZnVuY3Rpb24gKGRhdGEsIGZyYW1lU3opIHtcbiAgICB2YXIgZnJhbWVzID0gW107XG4gICAgdmFyIG4gPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyBmcmFtZVN6KTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBmcmFtZXMucHVzaChkYXRhLnNsaWNlKG9mZiwgb2ZmICsgZnJhbWVTeikpO1xuICAgICAgICBvZmYgKz0gZnJhbWVTejtcbiAgICB9XG4gICAgcmV0dXJuIGZyYW1lcztcbn07XG5leHBvcnRzLnNwbGl0RnJhbWVzID0gc3BsaXRGcmFtZXM7XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBpc0Jhc2UxME51bVN0cih4KSB7XG4gICAgdmFyIGJuID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoeCkudG9GaXhlZCgpLnNwbGl0KCcuJykuam9pbignJyk7XG4gICAgdmFyIHMgPSBuZXcgU3RyaW5nKHgpO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgSlMgbmF0aXZlIGBTdHJpbmcoKWAgbG9zZXMgcHJlY2lzaW9uIGZvciBsYXJnZSBudW1iZXJzLCBidXQgd2Ugb25seVxuICAgIC8vIHdhbnQgdG8gdmFsaWRhdGUgdGhlIGJhc2Ugb2YgdGhlIG51bWJlciBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IGZhciBvdXQgcHJlY2lzaW9uLlxuICAgIHJldHVybiBibi5zbGljZSgwLCA4KSA9PT0gcy5zbGljZSgwLCA4KTtcbn1cbi8qKiBAaW50ZXJuYWwgRW5zdXJlIGEgcGFyYW0gaXMgcmVwcmVzZW50ZWQgYnkgYSBidWZmZXIgKi9cbnZhciBlbnN1cmVIZXhCdWZmZXIgPSBmdW5jdGlvbiAoeCwgemVyb0lzTnVsbCkge1xuICAgIGlmICh6ZXJvSXNOdWxsID09PSB2b2lkIDApIHsgemVyb0lzTnVsbCA9IHRydWU7IH1cbiAgICB0cnkge1xuICAgICAgICAvLyBGb3IgbnVsbCB2YWx1ZXMsIHJldHVybiBhIDAtc2l6ZWQgYnVmZmVyLiBGb3IgbW9zdCBzaXR1YXRpb25zIHdlIGFzc3VtZVxuICAgICAgICAvLyAwIHNob3VsZCBiZSByZXByZXNlbnRlZCB3aXRoIGEgemVyby1sZW5ndGggYnVmZmVyIChlLmcuIGZvciBSTFAtYnVpbGRpbmdcbiAgICAgICAgLy8gdHhzKSwgYnV0IGl0IGNhbiBhbHNvIGJlIHRyZWF0ZWQgYXMgYSAxLWJ5dGUgYnVmZmVyIChgMDBgKSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHggPT09IG51bGwgfHwgKHggPT09IDAgJiYgemVyb0lzTnVsbCA9PT0gdHJ1ZSkpXG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB2YXIgaXNOdW1iZXIgPSB0eXBlb2YgeCA9PT0gJ251bWJlcicgfHwgaXNCYXNlMTBOdW1TdHIoeCk7XG4gICAgICAgIC8vIE90aGVyd2lzZSB0cnkgdG8gZ2V0IHRoaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZ1xuICAgICAgICBpZiAoaXNOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBudW1iZXIgb3IgYSBiYXNlLTEwIG51bWJlciBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gaGV4XG4gICAgICAgICAgICB4ID0gXCJcIi5jb25jYXQobmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoeCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgeC5zbGljZSgwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICAgICAgeCA9IHguc2xpY2UoMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0geC50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgubGVuZ3RoICUgMiA+IDApXG4gICAgICAgICAgICB4ID0gXCIwXCIuY29uY2F0KHgpO1xuICAgICAgICBpZiAoeCA9PT0gJzAwJyAmJiAhaXNOdW1iZXIpXG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oeCwgJ2hleCcpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IFwiLmNvbmNhdCh4LnRvU3RyaW5nKCksIFwiIHRvIGhleCBidWZmZXIgKFwiKS5jb25jYXQoZXJyLnRvU3RyaW5nKCksIFwiKVwiKSk7XG4gICAgfVxufTtcbmV4cG9ydHMuZW5zdXJlSGV4QnVmZmVyID0gZW5zdXJlSGV4QnVmZmVyO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGZpeExlbiA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xufTtcbmV4cG9ydHMuZml4TGVuID0gZml4TGVuO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1JZUFRPIFVUSUxTXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogQGludGVybmFsICovXG52YXIgYWVzMjU2X2VuY3J5cHQgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgdmFyIGl2ID0gQnVmZmVyLmZyb20ocHJvdG9jb2xfMS5Qcm90b2NvbENvbnN0YW50cy5hZXNJdik7XG4gICAgdmFyIGFlc0NiYyA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jYmMoa2V5LCBpdik7XG4gICAgdmFyIHBhZGRlZERhdGEgPSBkYXRhLmxlbmd0aCAlIDE2ID09PSAwID8gZGF0YSA6IGFlc19qc18xLmRlZmF1bHQucGFkZGluZy5wa2NzNy5wYWQoZGF0YSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFlc0NiYy5lbmNyeXB0KHBhZGRlZERhdGEpKTtcbn07XG5leHBvcnRzLmFlczI1Nl9lbmNyeXB0ID0gYWVzMjU2X2VuY3J5cHQ7XG4vKiogQGludGVybmFsICovXG52YXIgYWVzMjU2X2RlY3J5cHQgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgdmFyIGl2ID0gQnVmZmVyLmZyb20ocHJvdG9jb2xfMS5Qcm90b2NvbENvbnN0YW50cy5hZXNJdik7XG4gICAgdmFyIGFlc0NiYyA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jYmMoa2V5LCBpdik7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFlc0NiYy5kZWNyeXB0KGRhdGEpKTtcbn07XG5leHBvcnRzLmFlczI1Nl9kZWNyeXB0ID0gYWVzMjU2X2RlY3J5cHQ7XG4vLyBEZWNvZGUgYSBERVIgc2lnbmF0dXJlLiBSZXR1cm5zIHNpZ25hdHVyZSBvYmplY3Qge3IsIHMgfSBvciBudWxsIGlmIHRoZXJlIGlzIGFuIGVycm9yXG4vKiogQGludGVybmFsICovXG52YXIgcGFyc2VERVIgPSBmdW5jdGlvbiAoc2lnQnVmKSB7XG4gICAgaWYgKHNpZ0J1ZlswXSAhPT0gMHgzMCB8fCBzaWdCdWZbMl0gIT09IDB4MDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY29kZSBERVIgc2lnbmF0dXJlJyk7XG4gICAgdmFyIG9mZiA9IDM7XG4gICAgdmFyIHJMZW4gPSBzaWdCdWZbb2ZmXTtcbiAgICBvZmYrKztcbiAgICB2YXIgciA9IHNpZ0J1Zi5zbGljZShvZmYsIG9mZiArIHJMZW4pO1xuICAgIG9mZiArPSByTGVuO1xuICAgIGlmIChzaWdCdWZbb2ZmXSAhPT0gMHgwMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjb2RlIERFUiBzaWduYXR1cmUnKTtcbiAgICBvZmYrKztcbiAgICB2YXIgc0xlbiA9IHNpZ0J1ZltvZmZdO1xuICAgIG9mZisrO1xuICAgIHZhciBzID0gc2lnQnVmLnNsaWNlKG9mZiwgb2ZmICsgc0xlbik7XG4gICAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTtcbmV4cG9ydHMucGFyc2VERVIgPSBwYXJzZURFUjtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBnZXRQMjU2S2V5UGFpciA9IGZ1bmN0aW9uIChwcml2KSB7XG4gICAgaWYgKGVjID09PSB1bmRlZmluZWQpXG4gICAgICAgIGVjID0gbmV3IEVDKCdwMjU2Jyk7XG4gICAgcmV0dXJuIGVjLmtleUZyb21Qcml2YXRlKHByaXYsICdoZXgnKTtcbn07XG5leHBvcnRzLmdldFAyNTZLZXlQYWlyID0gZ2V0UDI1NktleVBhaXI7XG4vKiogQGludGVybmFsICovXG52YXIgZ2V0UDI1NktleVBhaXJGcm9tUHViID0gZnVuY3Rpb24gKHB1Yikge1xuICAgIGlmIChlYyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBlYyA9IG5ldyBFQygncDI1NicpO1xuICAgIHJldHVybiBlYy5rZXlGcm9tUHVibGljKHB1YiwgJ2hleCcpO1xufTtcbmV4cG9ydHMuZ2V0UDI1NktleVBhaXJGcm9tUHViID0gZ2V0UDI1NktleVBhaXJGcm9tUHViO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGJ1aWxkU2lnbmVyUGF0aEJ1ZiA9IGZ1bmN0aW9uIChzaWduZXJQYXRoLCB2YXJBZGRyUGF0aFN6QWxsb3dlZCkge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoMjQpO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmICh2YXJBZGRyUGF0aFN6QWxsb3dlZCAmJiBzaWduZXJQYXRoLmxlbmd0aCA+IDUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmVyIHBhdGggbXVzdCBiZSA8PTUgaW5kaWNlcy4nKTtcbiAgICBpZiAoIXZhckFkZHJQYXRoU3pBbGxvd2VkICYmIHNpZ25lclBhdGgubGVuZ3RoICE9PSA1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgTGF0dGljZSBmaXJtd2FyZSBvbmx5IHN1cHBvcnRzIDUtaW5kZXggZGVyaXZhdGlvbiBwYXRocy4gUGxlYXNlIHVwZ3JhZGUuJyk7XG4gICAgYnVmLndyaXRlVUludDMyTEUoc2lnbmVyUGF0aC5sZW5ndGgsIG9mZik7XG4gICAgb2ZmICs9IDQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCBzaWduZXJQYXRoLmxlbmd0aClcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKHNpZ25lclBhdGhbaV0sIG9mZik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKDAsIG9mZik7XG4gICAgICAgIG9mZiArPSA0O1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydHMuYnVpbGRTaWduZXJQYXRoQnVmID0gYnVpbGRTaWduZXJQYXRoQnVmO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT1RIRVIgVVRJTFNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBpc0FzY2lpU3RyID0gZnVuY3Rpb24gKHN0ciwgYWxsb3dGb3JtYXRDaGFycykge1xuICAgIGlmIChhbGxvd0Zvcm1hdENoYXJzID09PSB2b2lkIDApIHsgYWxsb3dGb3JtYXRDaGFycyA9IGZhbHNlOyB9XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV4dHJhQ2hhcnMgPSBhbGxvd0Zvcm1hdENoYXJzID9cbiAgICAgICAgW1xuICAgICAgICAgICAgMHgwMDIwLFxuICAgICAgICAgICAgMHgwMDBhLCAvLyBOZXcgbGluZVxuICAgICAgICBdIDogW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGV4dHJhQ2hhcnMuaW5kZXhPZihjKSA8IDAgJiYgKGMgPCAweDAwMjAgfHwgYyA+IDB4MDA3ZikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnRzLmlzQXNjaWlTdHIgPSBpc0FzY2lpU3RyO1xuLyoqIEBpbnRlcm5hbCBDaGVjayBpZiBhIHZhbHVlIGV4aXN0cyBpbiBhbiBvYmplY3QuIE9ubHkgY2hlY2tzIGZpcnN0IGxldmVsIG9mIGtleXMuICovXG52YXIgZXhpc3RzSW4gPSBmdW5jdGlvbiAodmFsLCBvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9ialtrZXldID09PSB2YWw7IH0pO1xufTtcbmV4cG9ydHMuZXhpc3RzSW4gPSBleGlzdHNJbjtcbi8qKiBAaW50ZXJuYWwgQ3JlYXRlIGEgYnVmZmVyIG9mIHNpemUgYG5gIGFuZCBmaWxsIGl0IHdpdGggcmFuZG9tIGRhdGEgKi9cbnZhciByYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBidWZbaV0gPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbi8qKiBAaW50ZXJuYWwgYGlzVUludDRgIGFjY2VwdHMgYSBudW1iZXIgYW5kIHJldHVybnMgdHJ1ZSBpZiBpdCBpcyBhIFVJbnQ0ICovXG52YXIgaXNVSW50NCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiAoMCwgaXNJbnRlZ2VyXzEuZGVmYXVsdCkobikgJiYgKDAsIGluUmFuZ2VfMS5kZWZhdWx0KShuLCAwLCAxNik7IH07XG5leHBvcnRzLmlzVUludDQgPSBpc1VJbnQ0O1xuLyoqXG4gKiBGZXRjaGVzIGFuIGV4dGVybmFsIEpTT04gZmlsZSBjb250YWluaW5nIG5ldHdvcmtzIGluZGV4ZWQgYnkgY2hhaW4gaWQgZnJvbSBhIEdyaWRQbHVzIHJlcG8sIGFuZFxuICogcmV0dXJucyB0aGUgcGFyc2VkIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGZldGNoRXh0ZXJuYWxOZXR3b3JrRm9yQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keSwgZXJyXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKGNvbnN0YW50c18xLkVYVEVSTkFMX05FVFdPUktTX0JZX0NIQUlOX0lEX1VSTClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuanNvbigpOyB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJvZHlbY2hhaW5JZF1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGZXRjaGluZyBleHRlcm5hbCBuZXR3b3JrcyBmYWlsZWQuXFxuJywgZXJyXzEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIFVSTCBmb3IgZmV0Y2hpbmcgY2FsbGRhdGEgZnJvbSBibG9jayBleHBsb3JlcnMgZm9yIGFueSBzdXBwb3J0ZWQgY2hhaW5zXG4gKiAqL1xuZnVuY3Rpb24gYnVpbGRVcmxGb3JTdXBwb3J0ZWRDaGFpbkFuZEFkZHJlc3MoX2EpIHtcbiAgICB2YXIgc3VwcG9ydGVkQ2hhaW4gPSBfYS5zdXBwb3J0ZWRDaGFpbiwgYWRkcmVzcyA9IF9hLmFkZHJlc3M7XG4gICAgdmFyIGJhc2VVcmwgPSBzdXBwb3J0ZWRDaGFpbi5iYXNlVXJsO1xuICAgIHZhciBhcGlSb3V0ZSA9IHN1cHBvcnRlZENoYWluLmFwaVJvdXRlO1xuICAgIHZhciB1cmxXaXRoUm91dGUgPSBcIlwiLmNvbmNhdChiYXNlVXJsLCBcIi9cIikuY29uY2F0KGFwaVJvdXRlLCBcIiZhZGRyZXNzPVwiKS5jb25jYXQoYWRkcmVzcyk7XG4gICAgdmFyIGFwaUtleSA9IG51bGw7XG4gICAgdmFyIGFwaUtleVBhcmFtID0gYXBpS2V5ID8gXCImYXBpS2V5PVwiLmNvbmNhdChudWxsKSA6ICcnO1xuICAgIHJldHVybiB1cmxXaXRoUm91dGUgKyBhcGlLZXlQYXJhbTtcbn1cbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIEFCSSBkYXRhIG9iamVjdHMgYW5kIGEgc2VsZWN0b3IsIGFuZCByZXR1cm5zIHRoZSBlYXJsaWVzdCBBQkkgZGF0YSBvYmplY3QgdGhhdFxuICogbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdERlZkZyb200Ynl0ZUFCSShhYmlEYXRhLCBzZWxlY3Rvcikge1xuICAgIGlmIChhYmlEYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBUaGVyZSBhcmUgbXVsdGlwbGUgcmVzdWx0cy4gVXNpbmcgdGhlIGZpcnN0IG9uZS4nKTtcbiAgICB9XG4gICAgdmFyIGRlZjtcbiAgICBhYmlEYXRhXG4gICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhVGltZSA9IG5ldyBEYXRlKGEuY3JlYXRlZF9hdCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgYlRpbWUgPSBuZXcgRGF0ZShiLmNyZWF0ZWRfYXQpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIGFUaW1lIC0gYlRpbWU7XG4gICAgfSlcbiAgICAgICAgLmZpbmQoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmID0gXzEuQ2FsbGRhdGEuRVZNLnBhcnNlcnMucGFyc2VDYW5vbmljYWxOYW1lKHNlbGVjdG9yLCByZXN1bHQudGV4dF9zaWduYXR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuICEhZGVmO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkZWYpIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgZGVmaW5pdGlvbiBmb3Igc2VsZWN0b3InKTtcbiAgICB9XG59XG5leHBvcnRzLnNlbGVjdERlZkZyb200Ynl0ZUFCSSA9IHNlbGVjdERlZkZyb200Ynl0ZUFCSTtcbmZ1bmN0aW9uIGZldGNoV2l0aFRpbWVvdXQodXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIHRpbWVvdXQsIGNvbnRyb2xsZXIsIHRpbWVvdXRJZCwgcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9hID0gb3B0aW9ucy50aW1lb3V0LCB0aW1lb3V0ID0gX2EgPT09IHZvaWQgMCA/IDgwMDAgOiBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sbGVyLmFib3J0KCk7IH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaCh1cmwsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFdpdGhUaW1lb3V0ID0gZmV0Y2hXaXRoVGltZW91dDtcbmZ1bmN0aW9uIGZldGNoQW5kQ2FjaGUodXJsLCBvcHRzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FjaGUsIHJlcXVlc3QsIG1hdGNoLCByZXNwb25zZSwgcmVzcG9uc2VDbG9uZSwgZGF0YSwgZXJyXzI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMTEsICwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZ2xvYmFsVGhpcy5jYWNoZXMgJiYgZ2xvYmFsVGhpcy5SZXF1ZXN0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNhY2hlcy5vcGVuKCdncC1jYWxsZGF0YScpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY2FjaGUubWF0Y2gocmVxdWVzdCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbWF0Y2hdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2gocmVxdWVzdCwgb3B0cyldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2Uub2sgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgoMCwgdmFsaWRhdG9yc18xLmlzVmFsaWRCbG9ja0V4cGxvcmVyUmVzcG9uc2UpKGRhdGEpIHx8ICgwLCB2YWxpZGF0b3JzXzEuaXNWYWxpZDRCeXRlUmVzcG9uc2UpKGRhdGEpKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjYWNoZS5wdXQocmVxdWVzdCwgcmVzcG9uc2VDbG9uZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0cyldO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMiAvKnJldHVybiovLCBmZXRjaCh1cmwsIG9wdHMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgZXJyXzIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyXzIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJfMjtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWRDaGFpbkRhdGEoYWRkcmVzcywgc3VwcG9ydGVkQ2hhaW4pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHVybCA9IGJ1aWxkVXJsRm9yU3VwcG9ydGVkQ2hhaW5BbmRBZGRyZXNzKHsgYWRkcmVzczogYWRkcmVzcywgc3VwcG9ydGVkQ2hhaW46IHN1cHBvcnRlZENoYWluIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZldGNoQW5kQ2FjaGUodXJsKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuanNvbigpOyB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSAmJiBib2R5LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgcmVzcG9uc2Ugd2FzIG1hbGZvcm1lZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZXRjaGluZyBkYXRhIGZyb20gZXh0ZXJuYWwgbmV0d29yayBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmV0Y2g0Ynl0ZURhdGEoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly93d3cuNGJ5dGUuZGlyZWN0b3J5L2FwaS92MS9zaWduYXR1cmVzLz9oZXhfc2lnbmF0dXJlPTB4XCIuY29uY2F0KHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2godXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5qc29uKCk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSAmJiBib2R5LnJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHkucmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzdWx0cyBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZXRjaGluZyBkYXRhIGZyb20gNGJ5dGUgZmFpbGVkOiBcIi5jb25jYXQoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZURlZihkZWYpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHJscF8xLmVuY29kZSkoZGVmKSk7XG59XG4vKipcbiAqIFBvc3QtcHJvY2VzcyBmZXRjaGVkIEFCSSBkZWZpbml0aW9uLlxuICogQHBhcmFtIGRlZiAtIENhbGxkYXRhIGRlY29kZXIgZGF0YSBkZWZpbml0aW9uIGZvciBjYWxsaW5nIGZ1bmN0aW9uXG4gKiBAcGFyYW0gY2FsbGRhdGEgLSBSYXcgdHJhbnNhY3Rpb24gY2FsbGRhdGFcbiAqIEByZXR1cm4gLSBVcGRhdGVkIGBkZWZgXG4gKi9cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzRGVmKGRlZiwgY2FsbGRhdGEpIHtcbiAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXN0ZWRDYWxsZGF0YSwgbmVzdGVkRGVmcywgX2MsIF9lLCBpLCBfZiwgX2csIGosIF9oLCBfaiwgZV8yXzEsIF9rLCBfbCwgZV8xXzEsIG5ld0RlZjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfbSkge1xuICAgICAgICAgICAgc3dpdGNoIChfbS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkQ2FsbGRhdGEgPSBfMS5DYWxsZGF0YS5FVk0ucHJvY2Vzc29ycy5nZXROZXN0ZWRDYWxsZGF0YShkZWYsIGNhbGxkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVwbGFjZU5lc3RlZERlZnMobmVzdGVkQ2FsbGRhdGEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZERlZnMgPSBfbS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9tLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9tLnRyeXMucHVzaChbMiwgMjIsIDIzLCAyOF0pO1xuICAgICAgICAgICAgICAgICAgICBfYyA9IF9fYXN5bmNWYWx1ZXMobmVzdGVkRGVmcy5lbnRyaWVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBfbS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2UgPSBfbS5zZW50KCksICFfZS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjFdO1xuICAgICAgICAgICAgICAgICAgICBpID0gX2UudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkobmVzdGVkRGVmc1tpXSkgJiYgdHlwZW9mIG5lc3RlZERlZnNbaV1bMF0gIT09ICdzdHJpbmcnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgICAgICBfbS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfbS50cnlzLnB1c2goWzUsIDExLCAxMiwgMTddKTtcbiAgICAgICAgICAgICAgICAgICAgX2YgPSAoZV8yID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKG5lc3RlZERlZnNbaV0uZW50cmllcygpKSk7XG4gICAgICAgICAgICAgICAgICAgIF9tLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9mLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfZyA9IF9tLnNlbnQoKSwgIV9nLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGogPSBfZy52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobmVzdGVkRGVmc1tpXVtqXSAhPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICBfaCA9IG5lc3RlZERlZnNbaV07XG4gICAgICAgICAgICAgICAgICAgIF9qID0gajtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9zdFByb2Nlc3NEZWYobmVzdGVkRGVmc1tpXVtqXSwgQnVmZmVyLmZyb20obmVzdGVkQ2FsbGRhdGFbaV1bal0uc2xpY2UoMiksICdoZXgnKSldO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2hbX2pdID0gX20uc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfbS5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgZV8yXzEgPSBfbS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBfbS50cnlzLnB1c2goWzEyLCAsIDE1LCAxNl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfZyAmJiAhX2cuZG9uZSAmJiAoX2IgPSBfZi5yZXR1cm4pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5jYWxsKF9mKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgX20uc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfbS5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxNjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobmVzdGVkRGVmc1tpXSAhPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDIwXTtcbiAgICAgICAgICAgICAgICAgICAgX2sgPSBuZXN0ZWREZWZzO1xuICAgICAgICAgICAgICAgICAgICBfbCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHBvc3RQcm9jZXNzRGVmKG5lc3RlZERlZnNbaV0sIEJ1ZmZlci5mcm9tKG5lc3RlZENhbGxkYXRhW2ldLnNsaWNlKDIpLCAnaGV4JykpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICBfa1tfbF0gPSBfbS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9tLmxhYmVsID0gMjA7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSAyMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMjhdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX20uc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyOF07XG4gICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgX20udHJ5cy5wdXNoKFsyMywgLCAyNiwgMjddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2UgJiYgIV9lLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDI1XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChfYyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgIF9tLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX20ubGFiZWwgPSAyNTtcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiByZXR1cm4gWzMgLypicmVhayovLCAyN107XG4gICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVmID0gXzEuQ2FsbGRhdGEuRVZNLnByb2Nlc3NvcnMucmVwbGFjZU5lc3RlZERlZnMoZGVmLCBuZXN0ZWREZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ld0RlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBHaXZlbiBhIHNldCBvZiBwb3NzaWJsZSBuZXN0ZWQgZGVmcywgc2xpY2Ugb3V0IHNlbGVjdG9ycyBhbmQgbG9vayB1cFxuICogZGVmaW5pdGlvbnMgb24gNGJ5dGUuXG4gKiBAcGFyYW0gcG9zc05lc3RlZERlZnMgLSByZXN1bHQgb2YgYGdldFBvc3NpYmxlTmVzdGVkRGVmc2AgcHJvY2Vzc29yXG4gKiBAcmV0dXJuIEFycmF5IGNvbnRhaW5pbmcgY2FsbGRhdGEgZGVjb2RpbmcgZGF0YSBmb3IgZWFjaCBwYXJhbWV0ZXJcbiAqICAgICAgICAgIHRoYXQgaGFkIGEgcG9zc2libGUgbmVzdGVkIGRlZi4gSWYgdGhlcmUgd2FzIG5vIHBvc3NpYmxlXG4gKiAgICAgICAgICBuZXN0ZWQgZGVmIG9yIGlmIGEgZGVmIGNvdWxkIG5vdCBiZSBmZXRjaGVkIGZyb20gNGJ5dGUsIHRoZVxuICogICAgICAgICAgYXJyYXkgaXRlbSB3aWxsIGJlIGBudWxsYC4gSW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgcG9zc2libGVcbiAqICAgICAgICAgIGRlZnMgYmVoaW5kIG9uZSBwYXJhbSAoZS5nLiBtdWx0aWNhbGwgcGF0dGVybiksIEFMTCBuZXN0ZWRcbiAqICAgICAgICAgIGl0ZW1zIG11c3QgaGF2ZSBkZWZzIGFzc29jaWF0ZWQgb3IgdGhlIGl0ZW0gd2lsbCBtYXAgdG8gYVxuICogICAgICAgICAgc2luZ2xlIGBudWxsYCB2YWx1ZSBpbiB0aGUgcmV0dXJuIGFycmF5LlxuICpcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZU5lc3RlZERlZnMocG9zc05lc3RlZERlZnMpIHtcbiAgICB2YXIgcG9zc05lc3RlZERlZnNfMSwgcG9zc05lc3RlZERlZnNfMV8xO1xuICAgIHZhciBlXzMsIF9hLCBlXzQsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5lc3RlZERlZnMsIGQsIF9uZXN0ZWREZWZzLCBzaG91bGRJbmNsdWRlLCBkXzEsIGRfMV8xLCBfZCwgX25lc3RlZFNlbGVjdG9yLCBfbmVzdGVkQWJpLCBfbmVzdGVkRGVmLCBlcnJfMywgZV80XzEsIG5lc3RlZFNlbGVjdG9yLCBuZXN0ZWRBYmksIG5lc3RlZERlZiwgZXJyXzQsIGVfM18xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWREZWZzID0gW107XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgMjYsIDI3LCAzMl0pO1xuICAgICAgICAgICAgICAgICAgICBwb3NzTmVzdGVkRGVmc18xID0gX19hc3luY1ZhbHVlcyhwb3NzTmVzdGVkRGVmcyk7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHBvc3NOZXN0ZWREZWZzXzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBvc3NOZXN0ZWREZWZzXzFfMSA9IF9jLnNlbnQoKSwgIXBvc3NOZXN0ZWREZWZzXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjVdO1xuICAgICAgICAgICAgICAgICAgICBkID0gcG9zc05lc3RlZERlZnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkICE9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICAgICAgX25lc3RlZERlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbNCwgMTIsIDEzLCAxOF0pO1xuICAgICAgICAgICAgICAgICAgICBkXzEgPSAoZV80ID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKGQpKTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgZF8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShkXzFfMSA9IF9jLnNlbnQoKSwgIWRfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbNywgOSwgLCAxMF0pO1xuICAgICAgICAgICAgICAgICAgICBfbmVzdGVkU2VsZWN0b3IgPSBfZC5zbGljZSgyLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoNGJ5dGVEYXRhKF9uZXN0ZWRTZWxlY3RvcildO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX25lc3RlZEFiaSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX25lc3RlZERlZiA9IHNlbGVjdERlZkZyb200Ynl0ZUFCSShfbmVzdGVkQWJpLCBfbmVzdGVkU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBfbmVzdGVkRGVmcy5wdXNoKF9uZXN0ZWREZWYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBlcnJfMyA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfbmVzdGVkRGVmcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGVfNF8xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzQgPSB7IGVycm9yOiBlXzRfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxMywgLCAxNiwgMTddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZF8xXzEgJiYgIWRfMV8xLmRvbmUgJiYgKF9iID0gZF8xLnJldHVybikpKSByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLmNhbGwoZF8xKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxNzogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmcy5wdXNoKF9uZXN0ZWREZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZERlZnMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxOSwgMjEsICwgMjJdKTtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkU2VsZWN0b3IgPSBkLnNsaWNlKDIsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2g0Ynl0ZURhdGEobmVzdGVkU2VsZWN0b3IpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRBYmkgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZERlZiA9IHNlbGVjdERlZkZyb200Ynl0ZUFCSShuZXN0ZWRBYmksIG5lc3RlZFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmcy5wdXNoKG5lc3RlZERlZik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDIyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICBlcnJfNCA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkRGVmcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyMl07XG4gICAgICAgICAgICAgICAgY2FzZSAyMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMjRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZERlZnMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyNDtcbiAgICAgICAgICAgICAgICBjYXNlIDI0OiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiByZXR1cm4gWzMgLypicmVhayovLCAzMl07XG4gICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgZV8zXzEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDMyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzI3LCAsIDMwLCAzMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwb3NzTmVzdGVkRGVmc18xXzEgJiYgIXBvc3NOZXN0ZWREZWZzXzFfMS5kb25lICYmIChfYSA9IHBvc3NOZXN0ZWREZWZzXzEucmV0dXJuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDI5XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChwb3NzTmVzdGVkRGVmc18xKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI5O1xuICAgICAgICAgICAgICAgIGNhc2UgMjk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDMxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAzMTogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDMyOiBcbiAgICAgICAgICAgICAgICAvLyBGb3IgYWxsIG5lc3RlZCBkZWZzLCByZXBsYWNlIHRoZSBcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmVzdGVkRGVmc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRVhURVJOQUwgVVRJTFNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogIEZldGNoZXMgY2FsbGRhdGEgZnJvbSBhIHJlbW90ZSBzY2FubmVyIGJhc2VkIG9uIHRoZSB0cmFuc2FjdGlvbidzIGBjaGFpbklkYFxuICovXG5mdW5jdGlvbiBmZXRjaENhbGxkYXRhRGVjb2RlcihfZGF0YSwgdG8sIF9jaGFpbklkLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzSGV4U3RyaW5nLCBkYXRhLCBzZWxlY3RvciwgY2hhaW5JZCwgY2FjaGVkTmV0d29yaywgc3VwcG9ydGVkQ2hhaW4sIF9hLCBhYmlfMSwgcGFyc2VkQWJpLCBkZWZfMSwgZXJyXzUsIGFiaSwgZGVmLCBlcnJfNjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCAxNSwgLCAxNl0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGlmIHRoZXJlIGlzIG5vIGRhdGEuIFRoZSAyIGNvbWVzIGZyb20gdGhlIDB4IHByZWZpeCwgYnV0IGEgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgd2lsbCBjb25maXJtIHRoYXQgdGhlcmUgYXJlIGF0IGxlYXN0IDQgYnl0ZXMgb2YgZGF0YSBpbiB0aGUgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kYXRhIHx8IF9kYXRhLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBlaXRoZXIgdW5kZWZpbmVkIG9yIGxlc3MgdGhhbiB0d28gYnl0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0hleFN0cmluZyA9IHR5cGVvZiBfZGF0YSA9PT0gJ3N0cmluZycgJiYgX2RhdGEuc2xpY2UoMCwgMikgPT09ICcweCc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBpc0hleFN0cmluZyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShfZGF0YS5zbGljZSgyKSwgJ2hleCcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvciAtIEJ1ZmZlciBkb2Vzbid0IHJlY29nbml6ZSBVaW50OEFycmF5IHR5cGUgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKF9kYXRhLCAnaGV4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgNCBieXRlcyBvZiBkYXRhIHRvIGRlZmluZSB0aGUgc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IEJ1ZmZlci5mcm9tKGRhdGEuc2xpY2UoMCwgNCkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IE51bWJlcihfY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZE5ldHdvcmsgPSBjb25zdGFudHNfMS5ORVRXT1JLU19CWV9DSEFJTl9JRFtjaGFpbklkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoZWROZXR3b3JrKSByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBjYWNoZWROZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoRXh0ZXJuYWxOZXR3b3JrRm9yQ2hhaW5JZChjaGFpbklkKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkQ2hhaW4gPSBfYTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs0LCAxMCwgLCAxMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRlZENoYWluKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hTdXBwb3J0ZWRDaGFpbkRhdGEodG8sIHN1cHBvcnRlZENoYWluKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBhYmlfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQWJpID0gXzEuQ2FsbGRhdGEuRVZNLnBhcnNlcnMucGFyc2VTb2xpZGl0eUpTT05BQkkoc2VsZWN0b3IsIGFiaV8xKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmXzEgPSBwYXJzZWRBYmkuZGVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY3Vyc2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3N0UHJvY2Vzc0RlZihkZWZfMSwgZGF0YSldO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgZGVmXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovLCB7IGFiaTogYWJpXzEsIGRlZjogZW5jb2RlRGVmKGRlZl8xKSB9XTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHRocm93IG5ldyBFcnJvcihcIkNoYWluIChpZDogXCIuY29uY2F0KGNoYWluSWQsIFwiKSBpcyBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBlcnJfNSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycl81Lm1lc3NhZ2UsICdcXG4nLCAnRmFsbGluZyBiYWNrIHRvIDRieXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaDRieXRlRGF0YShzZWxlY3RvcildO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGFiaSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gc2VsZWN0RGVmRnJvbTRieXRlQUJJKGFiaSwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY3Vyc2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9zdFByb2Nlc3NEZWYoZGVmLCBkYXRhKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovLCB7IGFiaTogYWJpLCBkZWY6IGVuY29kZURlZihkZWYpIH1dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIGVycl82ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGZXRjaGluZyBjYWxsZGF0YSBmYWlsZWQ6IFwiLmNvbmNhdChlcnJfNi5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBkZWY6IG51bGwsIGFiaTogbnVsbCB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoQ2FsbGRhdGFEZWNvZGVyID0gZmV0Y2hDYWxsZGF0YURlY29kZXI7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhcHBsaWNhdGlvbiBzZWNyZXQgZm9yIHVzZSBpbiBtYWludGFpbmluZyBjb25uZWN0aW9uIHRvIGRldmljZS5cbiAqIEBwYXJhbSBkZXZpY2VJZCAtIFRoZSBkZXZpY2UgSUQgb2YgdGhlIGRldmljZSB5b3Ugd2FudCB0byBnZW5lcmF0ZSBhIHRva2VuIGZvci5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCBlbnRlcmVkIHdoZW4gY29ubmVjdGluZyB0byB0aGUgZGV2aWNlLlxuICogQHBhcmFtIGFwcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24uXG4gKiBAcmV0dXJucyBhbiBhcHBsaWNhdGlvbiBzZWNyZXQgYXMgYSBCdWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xudmFyIGdlbmVyYXRlQXBwU2VjcmV0ID0gZnVuY3Rpb24gKGRldmljZUlkLCBwYXNzd29yZCwgYXBwTmFtZSkge1xuICAgIHZhciBkZXZpY2VJZEJ1ZmZlciA9IHR5cGVvZiBkZXZpY2VJZCA9PT0gJ3N0cmluZycgPyBCdWZmZXIuZnJvbShkZXZpY2VJZCkgOiBkZXZpY2VJZDtcbiAgICB2YXIgcGFzc3dvcmRCdWZmZXIgPSB0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnID8gQnVmZmVyLmZyb20ocGFzc3dvcmQpIDogcGFzc3dvcmQ7XG4gICAgdmFyIGFwcE5hbWVCdWZmZXIgPSB0eXBlb2YgYXBwTmFtZSA9PT0gJ3N0cmluZycgPyBCdWZmZXIuZnJvbShhcHBOYW1lKSA6IGFwcE5hbWU7XG4gICAgdmFyIHByZUltYWdlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGRldmljZUlkQnVmZmVyLFxuICAgICAgICBwYXNzd29yZEJ1ZmZlcixcbiAgICAgICAgYXBwTmFtZUJ1ZmZlcixcbiAgICBdKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHNoYV8xLnNoYTI1NikoKS51cGRhdGUocHJlSW1hZ2UpLmRpZ2VzdCgnaGV4JyksICdoZXgnKTtcbn07XG5leHBvcnRzLmdlbmVyYXRlQXBwU2VjcmV0ID0gZ2VuZXJhdGVBcHBTZWNyZXQ7XG4vKipcbiAqIEdlbmVyaWMgc2lnbmluZyBkb2VzIG5vdCByZXR1cm4gYSBgdmAgdmFsdWUgbGlrZSBsZWdhY3kgRVRIIHNpZ25pbmcgcmVxdWVzdHMgZGlkLlxuICogR2V0IHRoZSBgdmAgY29tcG9uZW50IG9mIHRoZSBzaWduYXR1cmUgYXMgd2VsbCBhcyBhbiBgaW5pdFZgXG4gKiBwYXJhbWV0ZXIsIHdoaWNoIGlzIHdoYXQgeW91IG5lZWQgdG8gdXNlIHRvIHJlLWNyZWF0ZSBhbiBgQGV0aGVyZXVtanMvdHhgXG4gKiBvYmplY3QuIFRoZXJlIGlzIGEgbG90IG9mIHRlY2ggZGVidCBpbiBgQGV0aGVyZXVtanMvdHhgIHdoaWNoIGFsc29cbiAqIGluaGVyaXRzIHRoZSB0ZWNoIGRlYnQgb2YgZXRoZXJldW1qcy11dGlsLlxuICogMS4gIFRoZSBsZWdhY3kgYFRyYW5zYWN0aW9uYCB0eXBlIGNhbiBjYWxsIGBfcHJvY2Vzc1NpZ25hdHVyZWAgd2l0aCB0aGUgcmVndWxhclxuICogICAgIGB2YCB2YWx1ZS5cbiAqIDIuICBOZXdlciB0cmFuc2FjdGlvbiB0eXBlcyBzdWNoIGFzIGBGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb25gIHdpbGwgc3VidHJhY3RcbiAqICAgICAyNyBmcm9tIHRoZSBgdmAgdGhhdCBnZXRzIHBhc3NlZCBpbiwgc28gd2UgbmVlZCB0byBhZGQgYDI3YCB0byBjcmVhdGUgYGluaXRWYFxuICogQHBhcmFtIHR4IC0gQW4gQGV0aGVyZXVtanMvdHggVHJhbnNhY3Rpb24gb2JqZWN0IG9yIEJ1ZmZlciAoc2VyaWFsaXplZCB0eClcbiAqIEBwYXJhbSByZXNwIC0gcmVzcG9uc2UgZnJvbSBMYXR0aWNlLiBDYW4gYmUgZWl0aGVyIGxlZ2FjeSBvciBnZW5lcmljIHNpZ25pbmcgdmFyaWV0eVxuICogQHJldHVybnMgYm4uanMgQk4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGB2YCBwYXJhbVxuICovXG52YXIgZ2V0ViA9IGZ1bmN0aW9uICh0eCwgcmVzcCkge1xuICAgIHZhciBjaGFpbklkLCBoYXNoLCB0eXBlO1xuICAgIHZhciB0eElzQnVmID0gQnVmZmVyLmlzQnVmZmVyKHR4KTtcbiAgICBpZiAodHhJc0J1Zikge1xuICAgICAgICBoYXNoID0gQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKHR4KSwgJ2hleCcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGxlZ2FjeVR4QXJyYXkgPSAoMCwgcmxwXzEuZGVjb2RlKSh0eCk7XG4gICAgICAgICAgICBpZiAobGVnYWN5VHhBcnJheS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBTaXggaXRlbSBhcnJheSBtZWFucyB0aGlzIGlzIGEgcHJlLUVJUDE1NSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBgdmAgcGFyYW0gaXMgdGhlIGBjaGFpbklkYFxuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBuZXcgYm5fanNfMS5CTihsZWdhY3lUeEFycmF5WzZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExlZ2FjeSB0eCA9IHR5cGUgMFxuICAgICAgICAgICAgdHlwZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSB0eXBlZCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdHhPYmogPSB0eF8xLlRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tU2VyaWFsaXplZERhdGEodHgpO1xuICAgICAgICAgICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvciAtLSBBY2Nlc3NpbmcgcHJpdmF0ZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eE9iai5fdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBSTFAgZGVjb2RlIGFuZCBjYW4ndCBoeWRyYXRlIGFuIEBldGhlcmV1bWpzL3R4IG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IHdoYXQgdGhpcyBpcyBhbmQgc2hvdWxkIGFib3J0LlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlY292ZXIgVi4gQmFkIHRyYW5zYWN0aW9uIGRhdGEuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEBldGhlcmV1bWpzL3R4IG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgdHlwZSA9IHR4Ll90eXBlO1xuICAgICAgICBoYXNoID0gdHlwZSA/XG4gICAgICAgICAgICB0eC5nZXRNZXNzYWdlVG9TaWduKHRydWUpIDogLy8gbmV3ZXIgdHggdHlwZXNcbiAgICAgICAgICAgICgwLCBybHBfMS5lbmNvZGUpKHR4LmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpKTsgLy8gbGVnYWN5IHR4XG4gICAgICAgIGlmICh0eC5zdXBwb3J0cyh0eF8xLkNhcGFiaWxpdHkuRUlQMTU1UmVwbGF5UHJvdGVjdGlvbikpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSB0eC5jb21tb24uY2hhaW5JZEJOKCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcnMgPSBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KFtyZXNwLnNpZy5yLCByZXNwLnNpZy5zXSkpO1xuICAgIHZhciBwdWJrZXkgPSBuZXcgVWludDhBcnJheShyZXNwLnB1YmtleSk7XG4gICAgdmFyIHJlY292ZXJ5MCA9ICgwLCBzZWNwMjU2azFfMS5lY2RzYVJlY292ZXIpKHJzLCAwLCBoYXNoLCBmYWxzZSk7XG4gICAgdmFyIHJlY292ZXJ5MSA9ICgwLCBzZWNwMjU2azFfMS5lY2RzYVJlY292ZXIpKHJzLCAxLCBoYXNoLCBmYWxzZSk7XG4gICAgdmFyIHB1YmtleVN0ciA9IEJ1ZmZlci5mcm9tKHB1YmtleSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHZhciByZWNvdmVyeTBTdHIgPSBCdWZmZXIuZnJvbShyZWNvdmVyeTApLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB2YXIgcmVjb3ZlcnkxU3RyID0gQnVmZmVyLmZyb20ocmVjb3ZlcnkxKS50b1N0cmluZygnaGV4Jyk7XG4gICAgdmFyIHJlY292ZXJ5O1xuICAgIGlmIChwdWJrZXlTdHIgPT09IHJlY292ZXJ5MFN0cikge1xuICAgICAgICByZWNvdmVyeSA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHB1YmtleVN0ciA9PT0gcmVjb3ZlcnkxU3RyKSB7XG4gICAgICAgIHJlY292ZXJ5ID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHdlIGZhaWwgYSBzZWNvbmQgdGltZSwgZXhpdCBoZXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWNvdmVyIFYgcGFyYW1ldGVyLiBCYWQgc2lnbmF0dXJlIG9yIHRyYW5zYWN0aW9uIGRhdGEuJyk7XG4gICAgfVxuICAgIC8vIE5ld2VyIHRyYW5zYWN0aW9uIHR5cGVzIGp1c3QgdXNlIHRoZSBbMCwgMV0gdmFsdWVcbiAgICBpZiAodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuQk4ocmVjb3ZlcnkpO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBjaGFpbiBJRCwgdGhpcyBpcyBhIHByZS1FSVAxNTUgdHhcbiAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLkJOKHJlY292ZXJ5KS5hZGRuKDI3KTtcbiAgICB9XG4gICAgLy8gRUlQMTU1IHJlcGxheSBwcm90ZWN0aW9uIGlzIGluY2x1ZGVkIGluIHRoZSBgdmAgcGFyYW1cbiAgICAvLyBhbmQgdXNlcyB0aGUgY2hhaW5JZCB2YWx1ZS5cbiAgICByZXR1cm4gY2hhaW5JZC5tdWxuKDIpLmFkZG4oMzUpLmFkZG4ocmVjb3ZlcnkpO1xufTtcbmV4cG9ydHMuZ2V0ViA9IGdldFY7XG4vKiogQGludGVybmFsICovXG5leHBvcnRzLkVYVEVSTkFMID0ge1xuICAgIGZldGNoQ2FsbGRhdGFEZWNvZGVyOiBmZXRjaENhbGxkYXRhRGVjb2RlcixcbiAgICBnZW5lcmF0ZUFwcFNlY3JldDogZXhwb3J0cy5nZW5lcmF0ZUFwcFNlY3JldCxcbiAgICBnZXRWOiBleHBvcnRzLmdldFYsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdpbmRleENoaWxkID0gZXhwb3J0cy5naW5kZXhQYXJlbnQgPSBleHBvcnRzLmdpbmRleFNpYmxpbmcgPSBleHBvcnRzLmNvbmNhdEdpbmRpY2VzID0gZXhwb3J0cy5nZXRHaW5kZXhCaXRzID0gZXhwb3J0cy5naW5kZXhJdGVyYXRvciA9IGV4cG9ydHMuZ2V0R2luZGljZXNBdERlcHRoID0gZXhwb3J0cy5pdGVyYXRlQXREZXB0aCA9IGV4cG9ydHMuY291bnRUb0RlcHRoID0gZXhwb3J0cy5jb252ZXJ0R2luZGV4VG9CaXRzdHJpbmcgPSBleHBvcnRzLnRvR2luZGV4Qml0c3RyaW5nID0gZXhwb3J0cy50b0dpbmRleCA9IGV4cG9ydHMuYml0SW5kZXhCaWdJbnQgPSB2b2lkIDA7XG5mdW5jdGlvbiBiaXRJbmRleEJpZ0ludCh2KSB7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMikubGVuZ3RoIC0gMTtcbn1cbmV4cG9ydHMuYml0SW5kZXhCaWdJbnQgPSBiaXRJbmRleEJpZ0ludDtcbmZ1bmN0aW9uIHRvR2luZGV4KGRlcHRoLCBpbmRleCkge1xuICAgIGNvbnN0IGFuY2hvciA9IEJpZ0ludCgxKSA8PCBCaWdJbnQoZGVwdGgpO1xuICAgIGlmIChpbmRleCA+PSBhbmNob3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCAke2luZGV4fSB0b28gbGFyZ2UgZm9yIGRlcHRoICR7ZGVwdGh9YCk7XG4gICAgfVxuICAgIHJldHVybiBhbmNob3IgfCBpbmRleDtcbn1cbmV4cG9ydHMudG9HaW5kZXggPSB0b0dpbmRleDtcbmZ1bmN0aW9uIHRvR2luZGV4Qml0c3RyaW5nKGRlcHRoLCBpbmRleCkge1xuICAgIGNvbnN0IHN0ciA9IGluZGV4ID8gTnVtYmVyKGluZGV4KS50b1N0cmluZygyKSA6IFwiXCI7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBkZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCB0b28gbGFyZ2UgZm9yIGRlcHRoXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiMVwiICsgc3RyLnBhZFN0YXJ0KGRlcHRoLCBcIjBcIik7XG4gICAgfVxufVxuZXhwb3J0cy50b0dpbmRleEJpdHN0cmluZyA9IHRvR2luZGV4Qml0c3RyaW5nO1xuZnVuY3Rpb24gY29udmVydEdpbmRleFRvQml0c3RyaW5nKGdpbmRleCkge1xuICAgIGlmICh0eXBlb2YgZ2luZGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChnaW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfR0lOREVYKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2luZGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGdpbmRleCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9HSU5ERVgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnaW5kZXgudG9TdHJpbmcoMik7XG4gICAgfVxufVxuZXhwb3J0cy5jb252ZXJ0R2luZGV4VG9CaXRzdHJpbmcgPSBjb252ZXJ0R2luZGV4VG9CaXRzdHJpbmc7XG4vLyBHZXQgdGhlIGRlcHRoIChyb290IHN0YXJ0aW5nIGF0IDApIG5lY2Vzc2FyeSB0byBjb3ZlciBhIHN1YnRyZWUgb2YgYGNvdW50YCBlbGVtZW50cy5cbi8vIChpbiBvdXQpOiAoMCAwKSwgKDEgMCksICgyIDEpLCAoMyAyKSwgKDQgMiksICg1IDMpLCAoNiAzKSwgKDcgMyksICg4IDMpLCAoOSA0KVxuZnVuY3Rpb24gY291bnRUb0RlcHRoKGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAoY291bnQgLSBCaWdJbnQoMSkpLnRvU3RyaW5nKDIpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY291bnRUb0RlcHRoID0gY291bnRUb0RlcHRoO1xuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggR2luZGV4ZXMgYXQgYSBjZXJ0YWluIGRlcHRoXG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdGVBdERlcHRoKGRlcHRoLCBzdGFydEluZGV4LCBjb3VudCkge1xuICAgIGNvbnN0IGFuY2hvciA9IEJpZ0ludCgxKSA8PCBCaWdJbnQoZGVwdGgpO1xuICAgIGlmIChzdGFydEluZGV4ICsgY291bnQgPiBhbmNob3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGZvciBkZXB0aFwiKTtcbiAgICB9XG4gICAgbGV0IGkgPSB0b0dpbmRleChkZXB0aCwgc3RhcnRJbmRleCk7XG4gICAgY29uc3QgbGFzdCA9IGkgKyBjb3VudDtcbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLml0ZXJhdGVBdERlcHRoID0gaXRlcmF0ZUF0RGVwdGg7XG4vKipcbiAqIFJldHVybiBHaW5kZXhlcyBhdCBhIGNlcnRhaW4gZGVwdGhcbiAqL1xuZnVuY3Rpb24gZ2V0R2luZGljZXNBdERlcHRoKGRlcHRoLCBzdGFydEluZGV4LCBjb3VudCkge1xuICAgIGNvbnN0IGFuY2hvciA9IEJpZ0ludCgxKSA8PCBCaWdJbnQoZGVwdGgpO1xuICAgIGlmIChzdGFydEluZGV4ICsgY291bnQgPiBhbmNob3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGZvciBkZXB0aFwiKTtcbiAgICB9XG4gICAgbGV0IGdpbmRleCA9IHRvR2luZGV4KGRlcHRoLCBCaWdJbnQoc3RhcnRJbmRleCkpO1xuICAgIGNvbnN0IGdpbmRpY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGdpbmRpY2VzLnB1c2goZ2luZGV4KyspO1xuICAgIH1cbiAgICByZXR1cm4gZ2luZGljZXM7XG59XG5leHBvcnRzLmdldEdpbmRpY2VzQXREZXB0aCA9IGdldEdpbmRpY2VzQXREZXB0aDtcbmNvbnN0IEVSUl9JTlZBTElEX0dJTkRFWCA9IFwiSW52YWxpZCBnaW5kZXhcIjtcbmZ1bmN0aW9uIGdpbmRleEl0ZXJhdG9yKGdpbmRleCkge1xuICAgIGxldCBiaXRzdHJpbmc7XG4gICAgaWYgKHR5cGVvZiBnaW5kZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKCFnaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfR0lOREVYKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRzdHJpbmcgPSBnaW5kZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZ2luZGV4IDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX0dJTkRFWCk7XG4gICAgICAgIH1cbiAgICAgICAgYml0c3RyaW5nID0gZ2luZGV4LnRvU3RyaW5nKDIpO1xuICAgIH1cbiAgICBsZXQgaSA9IDE7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IGJpdHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaXQgPSBOdW1iZXIoYml0c3RyaW5nW2ldKTtcbiAgICAgICAgaSsrO1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGJpdCB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4geyBuZXh0IH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlbWFpbmluZ0JpdExlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBiaXRzdHJpbmcubGVuZ3RoIC0gaTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5naW5kZXhJdGVyYXRvciA9IGdpbmRleEl0ZXJhdG9yO1xuZnVuY3Rpb24gZ2V0R2luZGV4Qml0cyhnaW5kZXgpIHtcbiAgICBsZXQgYml0c3RyaW5nO1xuICAgIGlmICh0eXBlb2YgZ2luZGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghZ2luZGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX0dJTkRFWCk7XG4gICAgICAgIH1cbiAgICAgICAgYml0c3RyaW5nID0gZ2luZGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGdpbmRleCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9HSU5ERVgpO1xuICAgICAgICB9XG4gICAgICAgIGJpdHN0cmluZyA9IGdpbmRleC50b1N0cmluZygyKTtcbiAgICB9XG4gICAgY29uc3QgYml0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYml0c3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJpdHMucHVzaChOdW1iZXIoYml0c3RyaW5nW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBiaXRzO1xufVxuZXhwb3J0cy5nZXRHaW5kZXhCaXRzID0gZ2V0R2luZGV4Qml0cztcbi8qKlxuICogQ29uY2F0ZW5hdGUgR2VuZXJhbGl6ZWQgSW5kaWNlc1xuICogR2l2ZW4gZ2VuZXJhbGl6ZWQgaW5kaWNlcyBpMSBmb3IgQSAtPiBCLCBpMiBmb3IgQiAtPiBDIC4uLi4gaV9uIGZvciBZIC0+IFosIHJldHVybnNcbiAqIHRoZSBnZW5lcmFsaXplZCBpbmRleCBmb3IgQSAtPiBaLlxuICovXG5mdW5jdGlvbiBjb25jYXRHaW5kaWNlcyhnaW5kaWNlcykge1xuICAgIHJldHVybiBCaWdJbnQoZ2luZGljZXMucmVkdWNlKChhY2MsIGdpbmRleCkgPT4gYWNjICsgZ2luZGV4LnRvU3RyaW5nKDIpLnNsaWNlKDEpLCBcIjBiMVwiKSk7XG59XG5leHBvcnRzLmNvbmNhdEdpbmRpY2VzID0gY29uY2F0R2luZGljZXM7XG5mdW5jdGlvbiBnaW5kZXhTaWJsaW5nKGdpbmRleCkge1xuICAgIHJldHVybiBnaW5kZXggXiBCaWdJbnQoMSk7XG59XG5leHBvcnRzLmdpbmRleFNpYmxpbmcgPSBnaW5kZXhTaWJsaW5nO1xuZnVuY3Rpb24gZ2luZGV4UGFyZW50KGdpbmRleCkge1xuICAgIHJldHVybiBnaW5kZXggLyBCaWdJbnQoMik7XG59XG5leHBvcnRzLmdpbmRleFBhcmVudCA9IGdpbmRleFBhcmVudDtcbmZ1bmN0aW9uIGdpbmRleENoaWxkKGdpbmRleCwgcmlnaHRDaGlsZCkge1xuICAgIHJldHVybiBnaW5kZXggKiBCaWdJbnQoMikgKyBCaWdJbnQocmlnaHRDaGlsZCk7XG59XG5leHBvcnRzLmdpbmRleENoaWxkID0gZ2luZGV4Q2hpbGQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNIYXNoT2JqZWN0ID0gZXhwb3J0cy51aW50OEFycmF5VG9IYXNoT2JqZWN0ID0gZXhwb3J0cy5oYXNoT2JqZWN0VG9VaW50OEFycmF5ID0gZXhwb3J0cy5oYXNoVHdvT2JqZWN0cyA9IGV4cG9ydHMuaGFzaCA9IHZvaWQgMDtcbmNvbnN0IGFzX3NoYTI1Nl8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvYXMtc2hhMjU2XCIpO1xuY29uc3QgaW5wdXQgPSBuZXcgVWludDhBcnJheSg2NCk7XG4vKipcbiAqIEhhc2ggdHdvIDMyIGJ5dGUgYXJyYXlzXG4gKi9cbmZ1bmN0aW9uIGhhc2goYSwgYikge1xuICAgIGlucHV0LnNldChhLCAwKTtcbiAgICBpbnB1dC5zZXQoYiwgMzIpO1xuICAgIHJldHVybiBhc19zaGEyNTZfMS5kaWdlc3Q2NChpbnB1dCk7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuLyoqXG4gKiBIYXNoIDIgb2JqZWN0cywgZWFjaCBzdG9yZSA4IG51bWJlcnMgKGVxdWl2YWxlbnQgdG8gVWludDhBcnJheSgzMikpXG4gKi9cbmZ1bmN0aW9uIGhhc2hUd29PYmplY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYXNfc2hhMjU2XzEuZGlnZXN0NjRIYXNoT2JqZWN0cyhhLCBiKTtcbn1cbmV4cG9ydHMuaGFzaFR3b09iamVjdHMgPSBoYXNoVHdvT2JqZWN0cztcbmZ1bmN0aW9uIGhhc2hPYmplY3RUb1VpbnQ4QXJyYXkob2JqKSB7XG4gICAgY29uc3QgYnl0ZUFyciA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICBhc19zaGEyNTZfMS5oYXNoT2JqZWN0VG9CeXRlQXJyYXkob2JqLCBieXRlQXJyLCAwKTtcbiAgICByZXR1cm4gYnl0ZUFycjtcbn1cbmV4cG9ydHMuaGFzaE9iamVjdFRvVWludDhBcnJheSA9IGhhc2hPYmplY3RUb1VpbnQ4QXJyYXk7XG5mdW5jdGlvbiB1aW50OEFycmF5VG9IYXNoT2JqZWN0KGJ5dGVBcnIpIHtcbiAgICByZXR1cm4gYXNfc2hhMjU2XzEuYnl0ZUFycmF5VG9IYXNoT2JqZWN0KGJ5dGVBcnIpO1xufVxuZXhwb3J0cy51aW50OEFycmF5VG9IYXNoT2JqZWN0ID0gdWludDhBcnJheVRvSGFzaE9iamVjdDtcbmZ1bmN0aW9uIGlzSGFzaE9iamVjdChoYXNoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBoYXNoLmxlbmd0aCA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc0hhc2hPYmplY3QgPSBpc0hhc2hPYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dpbmRleFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbm9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFja2VkTm9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvb2ZcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N1YnRyZWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyZWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3plcm9Ob2RlXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iaXR3aXNlT3JOb2RlSCA9IGV4cG9ydHMuc2V0Tm9kZUggPSBleHBvcnRzLmdldE5vZGVIID0gZXhwb3J0cy5jb21wb3NlID0gZXhwb3J0cy5pZGVudGl0eSA9IGV4cG9ydHMuTGVhZk5vZGUgPSBleHBvcnRzLkJyYW5jaE5vZGUgPSBleHBvcnRzLk5vZGUgPSB2b2lkIDA7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuY29uc3QgVFdPX1BPV0VSXzMyID0gMiAqKiAzMjtcbi8qKlxuICogQW4gaW1tdXRhYmxlIGJpbmFyeSBtZXJrbGUgdHJlZSBub2RlXG4gKi9cbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGgwLCBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBoNykge1xuICAgICAgICB0aGlzLmgwID0gaDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMTtcbiAgICAgICAgdGhpcy5oMiA9IGgyO1xuICAgICAgICB0aGlzLmgzID0gaDM7XG4gICAgICAgIHRoaXMuaDQgPSBoNDtcbiAgICAgICAgdGhpcy5oNSA9IGg1O1xuICAgICAgICB0aGlzLmg2ID0gaDY7XG4gICAgICAgIHRoaXMuaDcgPSBoNztcbiAgICB9XG4gICAgYXBwbHlIYXNoKHJvb3QpIHtcbiAgICAgICAgdGhpcy5oMCA9IHJvb3QuaDA7XG4gICAgICAgIHRoaXMuaDEgPSByb290LmgxO1xuICAgICAgICB0aGlzLmgyID0gcm9vdC5oMjtcbiAgICAgICAgdGhpcy5oMyA9IHJvb3QuaDM7XG4gICAgICAgIHRoaXMuaDQgPSByb290Lmg0O1xuICAgICAgICB0aGlzLmg1ID0gcm9vdC5oNTtcbiAgICAgICAgdGhpcy5oNiA9IHJvb3QuaDY7XG4gICAgICAgIHRoaXMuaDcgPSByb290Lmg3O1xuICAgIH1cbn1cbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG4vKipcbiAqIEFuIGltbXV0YWJsZSBiaW5hcnkgbWVya2xlIHRyZWUgbm9kZSB0aGF0IGhhcyBhIGBsZWZ0YCBhbmQgYHJpZ2h0YCBjaGlsZFxuICovXG5jbGFzcyBCcmFuY2hOb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoX2xlZnQsIF9yaWdodCkge1xuICAgICAgICAvLyBGaXJzdCBudWxsIHZhbHVlIGlzIHRvIHNhdmUgYW4gZXh0cmEgdmFyaWFibGUgdG8gY2hlY2sgaWYgYSBub2RlIGhhcyBhIHJvb3Qgb3Igbm90XG4gICAgICAgIHN1cGVyKG51bGwsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gX2xlZnQ7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gX3JpZ2h0O1xuICAgICAgICBpZiAoIV9sZWZ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZWZ0IG5vZGUgaXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3JpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSaWdodCBub2RlIGlzIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcm9vdEhhc2hPYmplY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmgwID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdXBlci5hcHBseUhhc2goaGFzaF8xLmhhc2hUd29PYmplY3RzKHRoaXMubGVmdC5yb290SGFzaE9iamVjdCwgdGhpcy5yaWdodC5yb290SGFzaE9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hfMS5oYXNoT2JqZWN0VG9VaW50OEFycmF5KHRoaXMucm9vdEhhc2hPYmplY3QpO1xuICAgIH1cbiAgICBpc0xlYWYoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xuICAgIH1cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkJyYW5jaE5vZGUgPSBCcmFuY2hOb2RlO1xuLyoqXG4gKiBBbiBpbW11dGFibGUgYmluYXJ5IG1lcmtsZSB0cmVlIG5vZGUgdGhhdCBoYXMgbm8gY2hpbGRyZW5cbiAqL1xuY2xhc3MgTGVhZk5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBzdGF0aWMgZnJvbVJvb3Qocm9vdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSGFzaE9iamVjdChoYXNoXzEudWludDhBcnJheVRvSGFzaE9iamVjdChyb290KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5ldyBMZWFmTm9kZSBmcm9tIGV4aXN0aW5nIEhhc2hPYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IYXNoT2JqZWN0KGhvKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUoaG8uaDAsIGhvLmgxLCBoby5oMiwgaG8uaDMsIGhvLmg0LCBoby5oNSwgaG8uaDYsIGhvLmg3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmV3IExlYWZOb2RlIHdpdGggaXRzIGludGVybmFsIHZhbHVlIHNldCB0byB6ZXJvLiBDb25zaWRlciB1c2luZyBgemVyb05vZGUoMClgIGlmIHlvdSBkb24ndCBuZWVkIHRvIG11dGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYWZOb2RlIHdpdGggSGFzaE9iamVjdCBgKHVpbnQzMiwgMCwgMCwgMCwgMCwgMCwgMCwgMClgLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVWludDMyKHVpbnQzMikge1xuICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlKHVpbnQzMiwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBMZWFmTm9kZSB3aXRoIHRoZSBzYW1lIGludGVybmFsIHZhbHVlcy4gVGhlIHJldHVybmVkIGluc3RhbmNlIGlzIHNhZmUgdG8gbXV0YXRlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBMZWFmTm9kZS5mcm9tSGFzaE9iamVjdCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHJvb3RIYXNoT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIHJldHVybiBoYXNoXzEuaGFzaE9iamVjdFRvVWludDhBcnJheSh0aGlzKTtcbiAgICB9XG4gICAgaXNMZWFmKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiTGVhZk5vZGUgaGFzIG5vIGxlZnQgbm9kZVwiKTtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkxlYWZOb2RlIGhhcyBubyByaWdodCBub2RlXCIpO1xuICAgIH1cbiAgICB3cml0ZVRvQnl0ZXMoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICAgICAgLy8gVE9ETzogT3B0aW1pemVcbiAgICAgICAgZGF0YS5zZXQodGhpcy5yb290LnNsaWNlKDAsIHNpemUpLCBzdGFydCk7XG4gICAgfVxuICAgIGdldFVpbnQodWludEJ5dGVzLCBvZmZzZXRCeXRlcywgY2xpcEluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IGhJbmRleCA9IE1hdGguZmxvb3Iob2Zmc2V0Qnl0ZXMgLyA0KTtcbiAgICAgICAgLy8gbnVtYmVyIGhhcyB0byBiZSBtYXNrZWQgZnJvbSBhbiBoIHZhbHVlXG4gICAgICAgIGlmICh1aW50Qnl0ZXMgPCA0KSB7XG4gICAgICAgICAgICBjb25zdCBiaXRJbmRleCA9IChvZmZzZXRCeXRlcyAlIDQpICogODtcbiAgICAgICAgICAgIGNvbnN0IGggPSBnZXROb2RlSCh0aGlzLCBoSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHVpbnRCeXRlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAweGZmICYgKGggPj4gYml0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDB4ZmZmZiAmIChoID4+IGJpdEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBudW1iZXIgZXF1YWxzIHRoZSBoIHZhbHVlXG4gICAgICAgIGVsc2UgaWYgKHVpbnRCeXRlcyA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5vZGVIKHRoaXMsIGhJbmRleCkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbnVtYmVyIHNwYW5zIDIgaCB2YWx1ZXNcbiAgICAgICAgZWxzZSBpZiAodWludEJ5dGVzID09PSA4KSB7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSBnZXROb2RlSCh0aGlzLCBoSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGdldE5vZGVIKHRoaXMsIGhJbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ID4+PiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGlnaCA9PT0gLTEgJiYgbG93ID09PSAtMSAmJiBjbGlwSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBMaW1pdCB1aW50IHJldHVybnNcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxvdyA+Pj4gMCkgKyAoaGlnaCA+Pj4gMCkgKiBUV09fUE9XRVJfMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmlnZ2VyIHVpbnQgY2FuJ3QgYmUgcmVwcmVzZW50ZWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInVpbnRCeXRlcyA+IDhcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VWludEJpZ2ludCh1aW50Qnl0ZXMsIG9mZnNldEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGhJbmRleCA9IE1hdGguZmxvb3Iob2Zmc2V0Qnl0ZXMgLyA0KTtcbiAgICAgICAgLy8gbnVtYmVyIGhhcyB0byBiZSBtYXNrZWQgZnJvbSBhbiBoIHZhbHVlXG4gICAgICAgIGlmICh1aW50Qnl0ZXMgPCA0KSB7XG4gICAgICAgICAgICBjb25zdCBiaXRJbmRleCA9IChvZmZzZXRCeXRlcyAlIDQpICogODtcbiAgICAgICAgICAgIGNvbnN0IGggPSBnZXROb2RlSCh0aGlzLCBoSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHVpbnRCeXRlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMHhmZiAmIChoID4+IGJpdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KDB4ZmZmZiAmIChoID4+IGJpdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbnVtYmVyIGVxdWFscyB0aGUgaCB2YWx1ZVxuICAgICAgICBlbHNlIGlmICh1aW50Qnl0ZXMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoZ2V0Tm9kZUgodGhpcywgaEluZGV4KSA+Pj4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbnVtYmVyIHNwYW5zIG11bHRpcGxlIGggdmFsdWVzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaFJhbmdlID0gTWF0aC5jZWlsKHVpbnRCeXRlcyAvIDQpO1xuICAgICAgICAgICAgbGV0IHYgPSBCaWdJbnQoMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhSYW5nZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdiArPSBCaWdJbnQoZ2V0Tm9kZUgodGhpcywgaEluZGV4ICsgaSkgPj4+IDApIDw8IEJpZ0ludCgzMiAqIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VWludCh1aW50Qnl0ZXMsIG9mZnNldEJ5dGVzLCB2YWx1ZSwgY2xpcEluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IGhJbmRleCA9IE1hdGguZmxvb3Iob2Zmc2V0Qnl0ZXMgLyA0KTtcbiAgICAgICAgLy8gbnVtYmVyIGhhcyB0byBiZSBtYXNrZWQgZnJvbSBhbiBoIHZhbHVlXG4gICAgICAgIGlmICh1aW50Qnl0ZXMgPCA0KSB7XG4gICAgICAgICAgICBjb25zdCBiaXRJbmRleCA9IChvZmZzZXRCeXRlcyAlIDQpICogODtcbiAgICAgICAgICAgIGxldCBoID0gZ2V0Tm9kZUgodGhpcywgaEluZGV4KTtcbiAgICAgICAgICAgIGlmICh1aW50Qnl0ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBoICY9IH4oMHhmZiA8PCBiaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgaCB8PSAoMHhmZiAmJiB2YWx1ZSkgPDwgYml0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoICY9IH4oMHhmZmZmIDw8IGJpdEluZGV4KTtcbiAgICAgICAgICAgICAgICBoIHw9ICgweGZmZmYgJiYgdmFsdWUpIDw8IGJpdEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Tm9kZUgodGhpcywgaEluZGV4LCBoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBudW1iZXIgZXF1YWxzIHRoZSBoIHZhbHVlXG4gICAgICAgIGVsc2UgaWYgKHVpbnRCeXRlcyA9PT0gNCkge1xuICAgICAgICAgICAgc2V0Tm9kZUgodGhpcywgaEluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbnVtYmVyIHNwYW5zIDIgaCB2YWx1ZXNcbiAgICAgICAgZWxzZSBpZiAodWludEJ5dGVzID09PSA4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5ICYmIGNsaXBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHNldE5vZGVIKHRoaXMsIGhJbmRleCwgLTEpO1xuICAgICAgICAgICAgICAgIHNldE5vZGVIKHRoaXMsIGhJbmRleCArIDEsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldE5vZGVIKHRoaXMsIGhJbmRleCwgdmFsdWUgJiAweGZmZmZmZmZmKTtcbiAgICAgICAgICAgICAgICBzZXROb2RlSCh0aGlzLCBoSW5kZXggKyAxLCAodmFsdWUgLyBUV09fUE9XRVJfMzIpICYgMHhmZmZmZmZmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmlnZ2VyIHVpbnQgY2FuJ3QgYmUgcmVwcmVzZW50ZWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInVpbnRCeXRlcyA+IDhcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VWludEJpZ2ludCh1aW50Qnl0ZXMsIG9mZnNldEJ5dGVzLCB2YWx1ZUJOKSB7XG4gICAgICAgIGNvbnN0IGhJbmRleCA9IE1hdGguZmxvb3Iob2Zmc2V0Qnl0ZXMgLyA0KTtcbiAgICAgICAgLy8gbnVtYmVyIGhhcyB0byBiZSBtYXNrZWQgZnJvbSBhbiBoIHZhbHVlXG4gICAgICAgIGlmICh1aW50Qnl0ZXMgPCA0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IE51bWJlcih2YWx1ZUJOKTtcbiAgICAgICAgICAgIGNvbnN0IGJpdEluZGV4ID0gKG9mZnNldEJ5dGVzICUgNCkgKiA4O1xuICAgICAgICAgICAgbGV0IGggPSBnZXROb2RlSCh0aGlzLCBoSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHVpbnRCeXRlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGggJj0gfigweGZmIDw8IGJpdEluZGV4KTtcbiAgICAgICAgICAgICAgICBoIHw9ICgweGZmICYmIHZhbHVlKSA8PCBiaXRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGggJj0gfigweGZmZmYgPDwgYml0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGggfD0gKDB4ZmZmZiAmJiB2YWx1ZSkgPDwgYml0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXROb2RlSCh0aGlzLCBoSW5kZXgsIGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG51bWJlciBlcXVhbHMgdGhlIGggdmFsdWVcbiAgICAgICAgZWxzZSBpZiAodWludEJ5dGVzID09PSA0KSB7XG4gICAgICAgICAgICBzZXROb2RlSCh0aGlzLCBoSW5kZXgsIE51bWJlcih2YWx1ZUJOKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbnVtYmVyIHNwYW5zIG11bHRpcGxlIGggdmFsdWVzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaEVuZCA9IGhJbmRleCArIE1hdGguY2VpbCh1aW50Qnl0ZXMgLyA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBoSW5kZXg7IGkgPCBoRW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZXROb2RlSCh0aGlzLCBpLCBOdW1iZXIodmFsdWVCTiAmIEJpZ0ludCgweGZmZmZmZmZmKSkpO1xuICAgICAgICAgICAgICAgIHZhbHVlQk4gPSB2YWx1ZUJOID4+IEJpZ0ludCgzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYml0d2lzZU9yVWludCh1aW50Qnl0ZXMsIG9mZnNldEJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBoSW5kZXggPSBNYXRoLmZsb29yKG9mZnNldEJ5dGVzIC8gNCk7XG4gICAgICAgIC8vIG51bWJlciBoYXMgdG8gYmUgbWFza2VkIGZyb20gYW4gaCB2YWx1ZVxuICAgICAgICBpZiAodWludEJ5dGVzIDwgNCkge1xuICAgICAgICAgICAgY29uc3QgYml0SW5kZXggPSAob2Zmc2V0Qnl0ZXMgJSA0KSAqIDg7XG4gICAgICAgICAgICBiaXR3aXNlT3JOb2RlSCh0aGlzLCBoSW5kZXgsIHZhbHVlIDw8IGJpdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBudW1iZXIgZXF1YWxzIHRoZSBoIHZhbHVlXG4gICAgICAgIGVsc2UgaWYgKHVpbnRCeXRlcyA9PT0gNCkge1xuICAgICAgICAgICAgYml0d2lzZU9yTm9kZUgodGhpcywgaEluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbnVtYmVyIHNwYW5zIG11bHRpcGxlIGggdmFsdWVzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaEVuZCA9IGhJbmRleCArIE1hdGguY2VpbCh1aW50Qnl0ZXMgLyA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBoSW5kZXg7IGkgPCBoRW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiaXR3aXNlT3JOb2RlSCh0aGlzLCBpLCB2YWx1ZSAmIDB4ZmZmZmZmZmYpO1xuICAgICAgICAgICAgICAgIHZhbHVlID4+PSAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGVhZk5vZGUgPSBMZWFmTm9kZTtcbmZ1bmN0aW9uIGlkZW50aXR5KG4pIHtcbiAgICByZXR1cm4gbjtcbn1cbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmZ1bmN0aW9uIGNvbXBvc2UoaW5uZXIsIG91dGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBvdXRlcihpbm5lcihuKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcG9zZSA9IGNvbXBvc2U7XG5mdW5jdGlvbiBnZXROb2RlSChub2RlLCBoSW5kZXgpIHtcbiAgICBpZiAoaEluZGV4ID09PSAwKVxuICAgICAgICByZXR1cm4gbm9kZS5oMDtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDEpXG4gICAgICAgIHJldHVybiBub2RlLmgxO1xuICAgIGVsc2UgaWYgKGhJbmRleCA9PT0gMilcbiAgICAgICAgcmV0dXJuIG5vZGUuaDI7XG4gICAgZWxzZSBpZiAoaEluZGV4ID09PSAzKVxuICAgICAgICByZXR1cm4gbm9kZS5oMztcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDQpXG4gICAgICAgIHJldHVybiBub2RlLmg0O1xuICAgIGVsc2UgaWYgKGhJbmRleCA9PT0gNSlcbiAgICAgICAgcmV0dXJuIG5vZGUuaDU7XG4gICAgZWxzZSBpZiAoaEluZGV4ID09PSA2KVxuICAgICAgICByZXR1cm4gbm9kZS5oNjtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDcpXG4gICAgICAgIHJldHVybiBub2RlLmg3O1xuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJoSW5kZXggPiA3XCIpO1xufVxuZXhwb3J0cy5nZXROb2RlSCA9IGdldE5vZGVIO1xuZnVuY3Rpb24gc2V0Tm9kZUgobm9kZSwgaEluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChoSW5kZXggPT09IDApXG4gICAgICAgIG5vZGUuaDAgPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDEpXG4gICAgICAgIG5vZGUuaDEgPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDIpXG4gICAgICAgIG5vZGUuaDIgPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDMpXG4gICAgICAgIG5vZGUuaDMgPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDQpXG4gICAgICAgIG5vZGUuaDQgPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDUpXG4gICAgICAgIG5vZGUuaDUgPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDYpXG4gICAgICAgIG5vZGUuaDYgPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDcpXG4gICAgICAgIG5vZGUuaDcgPSB2YWx1ZTtcbiAgICBlbHNlXG4gICAgICAgIHRocm93IEVycm9yKFwiaEluZGV4ID4gN1wiKTtcbn1cbmV4cG9ydHMuc2V0Tm9kZUggPSBzZXROb2RlSDtcbmZ1bmN0aW9uIGJpdHdpc2VPck5vZGVIKG5vZGUsIGhJbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoaEluZGV4ID09PSAwKVxuICAgICAgICBub2RlLmgwIHw9IHZhbHVlO1xuICAgIGVsc2UgaWYgKGhJbmRleCA9PT0gMSlcbiAgICAgICAgbm9kZS5oMSB8PSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDIpXG4gICAgICAgIG5vZGUuaDIgfD0gdmFsdWU7XG4gICAgZWxzZSBpZiAoaEluZGV4ID09PSAzKVxuICAgICAgICBub2RlLmgzIHw9IHZhbHVlO1xuICAgIGVsc2UgaWYgKGhJbmRleCA9PT0gNClcbiAgICAgICAgbm9kZS5oNCB8PSB2YWx1ZTtcbiAgICBlbHNlIGlmIChoSW5kZXggPT09IDUpXG4gICAgICAgIG5vZGUuaDUgfD0gdmFsdWU7XG4gICAgZWxzZSBpZiAoaEluZGV4ID09PSA2KVxuICAgICAgICBub2RlLmg2IHw9IHZhbHVlO1xuICAgIGVsc2UgaWYgKGhJbmRleCA9PT0gNylcbiAgICAgICAgbm9kZS5oNyB8PSB2YWx1ZTtcbiAgICBlbHNlXG4gICAgICAgIHRocm93IEVycm9yKFwiaEluZGV4ID4gN1wiKTtcbn1cbmV4cG9ydHMuYml0d2lzZU9yTm9kZUggPSBiaXR3aXNlT3JOb2RlSDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYWNrZWROb2RlUm9vdHNUb0J5dGVzID0gZXhwb3J0cy5wYWNrZWRSb290c0J5dGVzVG9MZWFmTm9kZXMgPSBleHBvcnRzLnBhY2tlZFJvb3RzQnl0ZXNUb05vZGUgPSB2b2lkIDA7XG5jb25zdCBzdWJ0cmVlXzEgPSByZXF1aXJlKFwiLi9zdWJ0cmVlXCIpO1xuY29uc3Qgbm9kZV8xID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcbmZ1bmN0aW9uIHBhY2tlZFJvb3RzQnl0ZXNUb05vZGUoZGVwdGgsIGRhdGFWaWV3LCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgbGVhZk5vZGVzID0gcGFja2VkUm9vdHNCeXRlc1RvTGVhZk5vZGVzKGRhdGFWaWV3LCBzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gc3VidHJlZV8xLnN1YnRyZWVGaWxsVG9Db250ZW50cyhsZWFmTm9kZXMsIGRlcHRoKTtcbn1cbmV4cG9ydHMucGFja2VkUm9vdHNCeXRlc1RvTm9kZSA9IHBhY2tlZFJvb3RzQnl0ZXNUb05vZGU7XG4vKipcbiAqIE9wdGltaXplZCBkZXNlcmlhbGl6YXRpb24gb2YgbGluZWFyIGJ5dGVzIHRvIGNvbnNlY3V0aXZlIGxlYWYgbm9kZXNcbiAqL1xuZnVuY3Rpb24gcGFja2VkUm9vdHNCeXRlc1RvTGVhZk5vZGVzKGRhdGFWaWV3LCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgIC8vIElmIHRoZSBvZmZzZXQgaW4gZGF0YSBpcyBub3QgYSBtdWx0aXBsZSBvZiA0LCBVaW50MzJBcnJheSBjYW4ndCBiZSB1c2VkXG4gICAgLy8gPiBzdGFydCBvZmZzZXQgb2YgVWludDMyQXJyYXkgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgNFxuICAgIC8vIE5PVEU6IFBlcmZvcm1hbmNlIHRlc3RzIHNob3cgdGhhdCB1c2luZyBhIERhdGFWaWV3IGlzIGFzIGZhc3QgYXMgVWludDMyQXJyYXlcbiAgICBjb25zdCBmdWxsTm9kZUNvdW50ID0gTWF0aC5mbG9vcihzaXplIC8gMzIpO1xuICAgIGNvbnN0IGxlYWZOb2RlcyA9IG5ldyBBcnJheShNYXRoLmNlaWwoc2l6ZSAvIDMyKSk7XG4gICAgLy8gRWZmaWNpZW50bHkgY29uc3RydWN0IHRoZSB0cmVlIHdyaXRpbmcgdG8gaGFzaE9iamVjdHMgZGlyZWN0bHlcbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSwgd2l0aCB0aGlzIGFwcHJvYWNoIGVhY2ggaCBwcm9wZXJ0eSBpcyB3cml0dGVuIHR3aWNlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsTm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQgKyBpICogMzI7XG4gICAgICAgIGxlYWZOb2Rlc1tpXSA9IG5ldyBub2RlXzEuTGVhZk5vZGUoZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0ICsgMCwgdHJ1ZSksIGRhdGFWaWV3LmdldEludDMyKG9mZnNldCArIDQsIHRydWUpLCBkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQgKyA4LCB0cnVlKSwgZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0ICsgMTIsIHRydWUpLCBkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQgKyAxNiwgdHJ1ZSksIGRhdGFWaWV3LmdldEludDMyKG9mZnNldCArIDIwLCB0cnVlKSwgZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0ICsgMjQsIHRydWUpLCBkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQgKyAyOCwgdHJ1ZSkpO1xuICAgIH1cbiAgICAvLyBDb25zaWRlciB0aGF0IHRoZSBsYXN0IG5vZGUgbWF5IG9ubHkgaW5jbHVkZSBwYXJ0aWFsIGRhdGFcbiAgICBjb25zdCByZW1haW5kZXJCeXRlcyA9IHNpemUgJSAzMjtcbiAgICAvLyBMYXN0IG5vZGVcbiAgICBpZiAocmVtYWluZGVyQnl0ZXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgbm9kZV8xLkxlYWZOb2RlKDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBsZWFmTm9kZXNbZnVsbE5vZGVDb3VudF0gPSBub2RlO1xuICAgICAgICAvLyBMb29wIHRvIGR5bmFtaWNhbGx5IGNvcHkgdGhlIGZ1bGwgaCB2YWx1ZXNcbiAgICAgICAgY29uc3QgZnVsbEhDb3VudCA9IE1hdGguZmxvb3IocmVtYWluZGVyQnl0ZXMgLyA0KTtcbiAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBmdWxsSENvdW50OyBoKyspIHtcbiAgICAgICAgICAgIG5vZGVfMS5zZXROb2RlSChub2RlLCBoLCBkYXRhVmlldy5nZXRJbnQzMihzdGFydCArIGZ1bGxOb2RlQ291bnQgKiAzMiArIGggKiA0LCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtYWluZGVyVWludDMyID0gc2l6ZSAlIDQ7XG4gICAgICAgIGlmIChyZW1haW5kZXJVaW50MzIgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbWFpbmRlclVpbnQzMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaCB8PSBkYXRhVmlldy5nZXRVaW50OChzdGFydCArIHNpemUgLSByZW1haW5kZXJVaW50MzIgKyBpKSA8PCAoaSAqIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZV8xLnNldE5vZGVIKG5vZGUsIGZ1bGxIQ291bnQsIGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWFmTm9kZXM7XG59XG5leHBvcnRzLnBhY2tlZFJvb3RzQnl0ZXNUb0xlYWZOb2RlcyA9IHBhY2tlZFJvb3RzQnl0ZXNUb0xlYWZOb2Rlcztcbi8qKlxuICogT3B0aW1pemVkIHNlcmlhbGl6YXRpb24gb2YgY29uc2VjdXRpdmUgbGVhdmUgbm9kZXMgdG8gbGluZWFyIGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHBhY2tlZE5vZGVSb290c1RvQnl0ZXMoZGF0YVZpZXcsIHN0YXJ0LCBzaXplLCBub2Rlcykge1xuICAgIC8vIElmIHRoZSBvZmZzZXQgaW4gZGF0YSBpcyBub3QgYSBtdWx0aXBsZSBvZiA0LCBVaW50MzJBcnJheSBjYW4ndCBiZSB1c2VkXG4gICAgLy8gPiBzdGFydCBvZmZzZXQgb2YgVWludDMyQXJyYXkgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgNFxuICAgIC8vIE5PVEU6IFBlcmZvcm1hbmNlIHRlc3RzIHNob3cgdGhhdCB1c2luZyBhIERhdGFWaWV3IGlzIGFzIGZhc3QgYXMgVWludDMyQXJyYXlcbiAgICAvLyBDb25zaWRlciB0aGF0IHRoZSBsYXN0IG5vZGUgbWF5IG9ubHkgaW5jbHVkZSBwYXJ0aWFsIGRhdGFcbiAgICBjb25zdCByZW1haW5kZXJCeXRlcyA9IHNpemUgJSAzMjtcbiAgICAvLyBGdWxsIG5vZGVzXG4gICAgLy8gRWZmaWNpZW50bHkgZ2V0IGhhc2hPYmplY3RzIGRhdGEgaW50byBkYXRhXG4gICAgY29uc3QgZnVsbE5vZGVDb3VudCA9IE1hdGguZmxvb3Ioc2l6ZSAvIDMyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxOb2RlQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0ICsgaSAqIDMyO1xuICAgICAgICBkYXRhVmlldy5zZXRJbnQzMihvZmZzZXQgKyAwLCBub2RlLmgwLCB0cnVlKTtcbiAgICAgICAgZGF0YVZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgbm9kZS5oMSwgdHJ1ZSk7XG4gICAgICAgIGRhdGFWaWV3LnNldEludDMyKG9mZnNldCArIDgsIG5vZGUuaDIsIHRydWUpO1xuICAgICAgICBkYXRhVmlldy5zZXRJbnQzMihvZmZzZXQgKyAxMiwgbm9kZS5oMywgdHJ1ZSk7XG4gICAgICAgIGRhdGFWaWV3LnNldEludDMyKG9mZnNldCArIDE2LCBub2RlLmg0LCB0cnVlKTtcbiAgICAgICAgZGF0YVZpZXcuc2V0SW50MzIob2Zmc2V0ICsgMjAsIG5vZGUuaDUsIHRydWUpO1xuICAgICAgICBkYXRhVmlldy5zZXRJbnQzMihvZmZzZXQgKyAyNCwgbm9kZS5oNiwgdHJ1ZSk7XG4gICAgICAgIGRhdGFWaWV3LnNldEludDMyKG9mZnNldCArIDI4LCBub2RlLmg3LCB0cnVlKTtcbiAgICB9XG4gICAgLy8gTGFzdCBub2RlXG4gICAgaWYgKHJlbWFpbmRlckJ5dGVzID4gMCkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbZnVsbE5vZGVDb3VudF07XG4gICAgICAgIC8vIExvb3AgdG8gZHluYW1pY2FsbHkgY29weSB0aGUgZnVsbCBoIHZhbHVlc1xuICAgICAgICBjb25zdCBmdWxsSENvdW50ID0gTWF0aC5mbG9vcihyZW1haW5kZXJCeXRlcyAvIDQpO1xuICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGZ1bGxIQ291bnQ7IGgrKykge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0SW50MzIoc3RhcnQgKyBmdWxsTm9kZUNvdW50ICogMzIgKyBoICogNCwgbm9kZV8xLmdldE5vZGVIKG5vZGUsIGgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1haW5kZXJVaW50MzIgPSBzaXplICUgNDtcbiAgICAgICAgaWYgKHJlbWFpbmRlclVpbnQzMiA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBub2RlXzEuZ2V0Tm9kZUgobm9kZSwgZnVsbEhDb3VudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbWFpbmRlclVpbnQzMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgoc3RhcnQgKyBzaXplIC0gcmVtYWluZGVyVWludDMyICsgaSwgKGggPj4gKGkgKiA4KSkgJiAweGZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMucGFja2VkTm9kZVJvb3RzVG9CeXRlcyA9IHBhY2tlZE5vZGVSb290c1RvQnl0ZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVzZXJpYWxpemVQcm9vZiA9IGV4cG9ydHMuc2VyaWFsaXplUHJvb2YgPSBleHBvcnRzLmNyZWF0ZU5vZGVGcm9tUHJvb2YgPSBleHBvcnRzLmNyZWF0ZVByb29mID0gZXhwb3J0cy5Qcm9vZlR5cGVTZXJpYWxpemVkID0gZXhwb3J0cy5Qcm9vZlR5cGUgPSB2b2lkIDA7XG5jb25zdCBtdWx0aV8xID0gcmVxdWlyZShcIi4vbXVsdGlcIik7XG5jb25zdCBzaW5nbGVfMSA9IHJlcXVpcmUoXCIuL3NpbmdsZVwiKTtcbmNvbnN0IHRyZWVPZmZzZXRfMSA9IHJlcXVpcmUoXCIuL3RyZWVPZmZzZXRcIik7XG52YXIgUHJvb2ZUeXBlO1xuKGZ1bmN0aW9uIChQcm9vZlR5cGUpIHtcbiAgICBQcm9vZlR5cGVbXCJzaW5nbGVcIl0gPSBcInNpbmdsZVwiO1xuICAgIFByb29mVHlwZVtcInRyZWVPZmZzZXRcIl0gPSBcInRyZWVPZmZzZXRcIjtcbiAgICBQcm9vZlR5cGVbXCJtdWx0aVwiXSA9IFwibXVsdGlcIjtcbn0pKFByb29mVHlwZSA9IGV4cG9ydHMuUHJvb2ZUeXBlIHx8IChleHBvcnRzLlByb29mVHlwZSA9IHt9KSk7XG4vKipcbiAqIFNlcmlhbGl6ZWQgcHJvb2ZzIGFyZSBwcmVwZW5kZWQgd2l0aCBhIHNpbmdsZSBieXRlLCBkZW5vdGluZyB0aGVpciB0eXBlXG4gKi9cbmV4cG9ydHMuUHJvb2ZUeXBlU2VyaWFsaXplZCA9IFtcbiAgICBQcm9vZlR5cGUuc2luZ2xlLFxuICAgIFByb29mVHlwZS50cmVlT2Zmc2V0LFxuICAgIFByb29mVHlwZS5tdWx0aSwgLy8gMlxuXTtcbmZ1bmN0aW9uIGNyZWF0ZVByb29mKHJvb3ROb2RlLCBpbnB1dCkge1xuICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICBjYXNlIFByb29mVHlwZS5zaW5nbGU6IHtcbiAgICAgICAgICAgIGNvbnN0IFtsZWFmLCB3aXRuZXNzZXNdID0gc2luZ2xlXzEuY3JlYXRlU2luZ2xlUHJvb2Yocm9vdE5vZGUsIGlucHV0LmdpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFByb29mVHlwZS5zaW5nbGUsXG4gICAgICAgICAgICAgICAgZ2luZGV4OiBpbnB1dC5naW5kZXgsXG4gICAgICAgICAgICAgICAgbGVhZixcbiAgICAgICAgICAgICAgICB3aXRuZXNzZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUHJvb2ZUeXBlLnRyZWVPZmZzZXQ6IHtcbiAgICAgICAgICAgIGNvbnN0IFtvZmZzZXRzLCBsZWF2ZXNdID0gdHJlZU9mZnNldF8xLmNyZWF0ZVRyZWVPZmZzZXRQcm9vZihyb290Tm9kZSwgaW5wdXQuZ2luZGljZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQcm9vZlR5cGUudHJlZU9mZnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIGxlYXZlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBQcm9vZlR5cGUubXVsdGk6IHtcbiAgICAgICAgICAgIGNvbnN0IFtsZWF2ZXMsIHdpdG5lc3NlcywgZ2luZGljZXNdID0gbXVsdGlfMS5jcmVhdGVNdWx0aVByb29mKHJvb3ROb2RlLCBpbnB1dC5naW5kaWNlcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFByb29mVHlwZS5tdWx0aSxcbiAgICAgICAgICAgICAgICBsZWF2ZXMsXG4gICAgICAgICAgICAgICAgd2l0bmVzc2VzLFxuICAgICAgICAgICAgICAgIGdpbmRpY2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9vZiB0eXBlXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlUHJvb2YgPSBjcmVhdGVQcm9vZjtcbmZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tUHJvb2YocHJvb2YpIHtcbiAgICBzd2l0Y2ggKHByb29mLnR5cGUpIHtcbiAgICAgICAgY2FzZSBQcm9vZlR5cGUuc2luZ2xlOlxuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZV8xLmNyZWF0ZU5vZGVGcm9tU2luZ2xlUHJvb2YocHJvb2YuZ2luZGV4LCBwcm9vZi5sZWFmLCBwcm9vZi53aXRuZXNzZXMpO1xuICAgICAgICBjYXNlIFByb29mVHlwZS50cmVlT2Zmc2V0OlxuICAgICAgICAgICAgcmV0dXJuIHRyZWVPZmZzZXRfMS5jcmVhdGVOb2RlRnJvbVRyZWVPZmZzZXRQcm9vZihwcm9vZi5vZmZzZXRzLCBwcm9vZi5sZWF2ZXMpO1xuICAgICAgICBjYXNlIFByb29mVHlwZS5tdWx0aTpcbiAgICAgICAgICAgIHJldHVybiBtdWx0aV8xLmNyZWF0ZU5vZGVGcm9tTXVsdGlQcm9vZihwcm9vZi5sZWF2ZXMsIHByb29mLndpdG5lc3NlcywgcHJvb2YuZ2luZGljZXMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9vZiB0eXBlXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTm9kZUZyb21Qcm9vZiA9IGNyZWF0ZU5vZGVGcm9tUHJvb2Y7XG5mdW5jdGlvbiBzZXJpYWxpemVQcm9vZihwcm9vZikge1xuICAgIHN3aXRjaCAocHJvb2YudHlwZSkge1xuICAgICAgICBjYXNlIFByb29mVHlwZS5zaW5nbGU6XG4gICAgICAgIGNhc2UgUHJvb2ZUeXBlLm11bHRpOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICBjYXNlIFByb29mVHlwZS50cmVlT2Zmc2V0OiB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheSgxICsgdHJlZU9mZnNldF8xLmNvbXB1dGVUcmVlT2Zmc2V0UHJvb2ZTZXJpYWxpemVkTGVuZ3RoKHByb29mLm9mZnNldHMsIHByb29mLmxlYXZlcykpO1xuICAgICAgICAgICAgb3V0cHV0WzBdID0gZXhwb3J0cy5Qcm9vZlR5cGVTZXJpYWxpemVkLmluZGV4T2YoUHJvb2ZUeXBlLnRyZWVPZmZzZXQpO1xuICAgICAgICAgICAgdHJlZU9mZnNldF8xLnNlcmlhbGl6ZVRyZWVPZmZzZXRQcm9vZihvdXRwdXQsIDEsIHByb29mLm9mZnNldHMsIHByb29mLmxlYXZlcyk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb29mIHR5cGVcIik7XG4gICAgfVxufVxuZXhwb3J0cy5zZXJpYWxpemVQcm9vZiA9IHNlcmlhbGl6ZVByb29mO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVQcm9vZihkYXRhKSB7XG4gICAgY29uc3QgcHJvb2ZUeXBlID0gZXhwb3J0cy5Qcm9vZlR5cGVTZXJpYWxpemVkW2RhdGFbMF1dO1xuICAgIGlmICghcHJvb2ZUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvb2YgdHlwZVwiKTtcbiAgICB9XG4gICAgc3dpdGNoIChwcm9vZlR5cGUpIHtcbiAgICAgICAgY2FzZSBQcm9vZlR5cGUuc2luZ2xlOlxuICAgICAgICBjYXNlIFByb29mVHlwZS5tdWx0aTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgY2FzZSBQcm9vZlR5cGUudHJlZU9mZnNldDoge1xuICAgICAgICAgICAgY29uc3QgW29mZnNldHMsIGxlYXZlc10gPSB0cmVlT2Zmc2V0XzEuZGVzZXJpYWxpemVUcmVlT2Zmc2V0UHJvb2YoZGF0YSwgMSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFByb29mVHlwZS50cmVlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldHMsXG4gICAgICAgICAgICAgICAgbGVhdmVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9vZiB0eXBlXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVQcm9vZiA9IGRlc2VyaWFsaXplUHJvb2Y7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTm9kZUZyb21NdWx0aVByb29mID0gZXhwb3J0cy5jcmVhdGVNdWx0aVByb29mID0gdm9pZCAwO1xuY29uc3Qgbm9kZV8xID0gcmVxdWlyZShcIi4uL25vZGVcIik7XG5jb25zdCB0cmVlXzEgPSByZXF1aXJlKFwiLi4vdHJlZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKipcbiAqIENyZWF0ZSBhbiBtdWx0aXByb29mXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9jb25zZW5zdXMtc3BlY3MvYmxvYi9kZXYvc3N6L21lcmtsZS1wcm9vZnMubWQjbWVya2xlLW11bHRpcHJvb2ZzXG4gKlxuICogQHBhcmFtIHJvb3ROb2RlIHRoZSByb290IG5vZGUgb2YgdGhlIHRyZWVcbiAqIEBwYXJhbSBnaW5kaWNlcyBnZW5lcmFsaXplZCBpbmRpY2VzIG9mIGxlYXZlcyB0byBpbmNsdWRlIGluIHRoZSBwcm9vZlxuICovXG5mdW5jdGlvbiBjcmVhdGVNdWx0aVByb29mKHJvb3ROb2RlLCBnaW5kaWNlcykge1xuICAgIGNvbnN0IHRyZWUgPSBuZXcgdHJlZV8xLlRyZWUocm9vdE5vZGUpO1xuICAgIGNvbnN0IHdpdG5lc3NHaW5kaWNlcyA9IHV0aWxfMS5jb21wdXRlTXVsdGlQcm9vZkJpdHN0cmluZ3MoZ2luZGljZXMubWFwKChnaW5kZXgpID0+IGdpbmRleC50b1N0cmluZygyKSksIGZhbHNlLCB1dGlsXzEuU29ydE9yZGVyLkRlY3JlYXNpbmcpO1xuICAgIGNvbnN0IGxlYWZHaW5kaWNlcyA9IGdpbmRpY2VzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gKGEgPCBiID8gMSA6IC0xKSk7XG4gICAgY29uc3QgbGVhdmVzID0gbGVhZkdpbmRpY2VzLm1hcCgoZ2luZGV4KSA9PiB0cmVlLmdldFJvb3QoZ2luZGV4KSk7XG4gICAgY29uc3Qgd2l0bmVzc2VzID0gd2l0bmVzc0dpbmRpY2VzLm1hcCgoZ2luZGV4KSA9PiB0cmVlLmdldFJvb3QoZ2luZGV4KSk7XG4gICAgcmV0dXJuIFtsZWF2ZXMsIHdpdG5lc3NlcywgbGVhZkdpbmRpY2VzXTtcbn1cbmV4cG9ydHMuY3JlYXRlTXVsdGlQcm9vZiA9IGNyZWF0ZU11bHRpUHJvb2Y7XG4vKipcbiAqIFJlY3JlYXRlIGEgYE5vZGVgIGdpdmVuIGEgbXVsdGlwcm9vZlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vY29uc2Vuc3VzLXNwZWNzL2Jsb2IvZGV2L3Nzei9tZXJrbGUtcHJvb2ZzLm1kI21lcmtsZS1tdWx0aXByb29mc1xuICpcbiAqIEBwYXJhbSBsZWF2ZXMgbGVhdmVzIG9mIGEgRUYgbXVsdGlwcm9vZlxuICogQHBhcmFtIHdpdG5lc3NlcyB3aXRuZXNzZXMgb2YgYSBFRiBtdWx0aXByb29mXG4gKiBAcGFyYW0gZ2luZGljZXMgZ2VuZXJhbGl6ZWQgaW5kaWNlcyBvZiB0aGUgbGVhdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tTXVsdGlQcm9vZihsZWF2ZXMsIHdpdG5lc3NlcywgZ2luZGljZXMpIHtcbiAgICBpZiAobGVhdmVzLmxlbmd0aCAhPT0gZ2luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlYXZlcyBsZW5ndGggc2hvdWxkIGVxdWFsIGdpbmRpY2VzIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgY29uc3QgbGVhZkJpdHN0cmluZ3MgPSBnaW5kaWNlcy5tYXAoKGdpbmRleCkgPT4gZ2luZGV4LnRvU3RyaW5nKDIpKTtcbiAgICBjb25zdCB3aXRuZXNzQml0c3RyaW5ncyA9IHV0aWxfMS5jb21wdXRlTXVsdGlQcm9vZkJpdHN0cmluZ3MobGVhZkJpdHN0cmluZ3MsIGZhbHNlLCB1dGlsXzEuU29ydE9yZGVyLkRlY3JlYXNpbmcpO1xuICAgIGlmICh3aXRuZXNzQml0c3RyaW5ncy5sZW5ndGggIT09IHdpdG5lc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2l0bmVzc2VzIGxlbmd0aCBzaG91bGQgZXF1YWwgd2l0bmVzc2VzIGdpbmRpY2VzIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgLy8gQWxnb3JpdGhtOlxuICAgIC8vIGNyZWF0ZSBhbiBvYmplY3Qgd2hpY2ggdHJhY2tzIGtleS12YWx1ZXMgZm9yIGVhY2ggbGV2ZWxcbiAgICAvLyBwcmUtbG9hZCBsZWF2ZXMgYW5kIHdpdG5lc3NlcyBpbnRvIHRoZSBsZXZlbCBvYmplY3RcbiAgICAvLyBsZXZlbCBieSBsZXZlbCwgc3RhcnRpbmcgZnJvbSB0aGUgYm90dG9tLFxuICAgIC8vIGZpbmQgdGhlIHNpYmxpbmcsIGNyZWF0ZSB0aGUgcGFyZW50LCBzdG9yZSBpdCBpbiB0aGUgbmV4dCBsZXZlbCB1cFxuICAgIC8vIHRoZSByb290IGlzIGluIGxldmVsIDFcbiAgICBjb25zdCBtYXhMZXZlbCA9IE1hdGgubWF4KGxlYWZCaXRzdHJpbmdzWzBdPy5sZW5ndGggPz8gMCwgd2l0bmVzc0JpdHN0cmluZ3NbMF0/Lmxlbmd0aCA/PyAwKTtcbiAgICBjb25zdCBsZXZlbHMgPSBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbSh7IGxlbmd0aDogbWF4TGV2ZWwgfSwgKF8sIGkpID0+IFtpICsgMSwge31dKSk7XG4gICAgLy8gcHJlbG9hZCBsZWF2ZXMgYW5kIHdpdG5lc3Nlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVhZkJpdHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGVhZkJpdHN0cmluZyA9IGxlYWZCaXRzdHJpbmdzW2ldO1xuICAgICAgICBjb25zdCBsZWFmID0gbGVhdmVzW2ldO1xuICAgICAgICBsZXZlbHNbbGVhZkJpdHN0cmluZy5sZW5ndGhdW2xlYWZCaXRzdHJpbmddID0gbm9kZV8xLkxlYWZOb2RlLmZyb21Sb290KGxlYWYpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpdG5lc3NCaXRzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHdpdG5lc3NCaXRzdHJpbmcgPSB3aXRuZXNzQml0c3RyaW5nc1tpXTtcbiAgICAgICAgY29uc3Qgd2l0bmVzcyA9IHdpdG5lc3Nlc1tpXTtcbiAgICAgICAgbGV2ZWxzW3dpdG5lc3NCaXRzdHJpbmcubGVuZ3RoXVt3aXRuZXNzQml0c3RyaW5nXSA9IG5vZGVfMS5MZWFmTm9kZS5mcm9tUm9vdCh3aXRuZXNzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG1heExldmVsOyBpID4gMTsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBwYXJlbnRMZXZlbCA9IGxldmVsc1tpIC0gMV07XG4gICAgICAgIGZvciAoY29uc3QgYml0c3RyaW5nIG9mIE9iamVjdC5rZXlzKGxldmVsKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGxldmVsW2JpdHN0cmluZ107XG4gICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0LCB3ZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCBpdHMgc2libGluZ1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0xlZnQgPSBiaXRzdHJpbmdbYml0c3RyaW5nLmxlbmd0aCAtIDFdID09PSBcIjBcIjtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEJpdHN0cmluZyA9IGJpdHN0cmluZy5zdWJzdHJpbmcoMCwgYml0c3RyaW5nLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ0JpdHN0cmluZyA9IHBhcmVudEJpdHN0cmluZyArIChpc0xlZnQgPyBcIjFcIiA6IFwiMFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdOb2RlID0gbGV2ZWxbc2libGluZ0JpdHN0cmluZ107XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmdOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWJsaW5nIG5vdCBmb3VuZDogJHtzaWJsaW5nQml0c3RyaW5nfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gaXNMZWZ0ID8gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKG5vZGUsIHNpYmxpbmdOb2RlKSA6IG5ldyBub2RlXzEuQnJhbmNoTm9kZShzaWJsaW5nTm9kZSwgbm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRMZXZlbFtwYXJlbnRCaXRzdHJpbmddID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgdXNlZCBub2Rlc1xuICAgICAgICAgICAgZGVsZXRlIGxldmVsW2JpdHN0cmluZ107XG4gICAgICAgICAgICBkZWxldGUgbGV2ZWxbc2libGluZ0JpdHN0cmluZ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IGxldmVsc1sxXVtcIjFcIl07XG4gICAgaWYgKCFyb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGNvbnNpc3RlbmN5IGVycm9yOiBubyByb290IGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbn1cbmV4cG9ydHMuY3JlYXRlTm9kZUZyb21NdWx0aVByb29mID0gY3JlYXRlTm9kZUZyb21NdWx0aVByb29mO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU5vZGVGcm9tU2luZ2xlUHJvb2YgPSBleHBvcnRzLmNyZWF0ZVNpbmdsZVByb29mID0gZXhwb3J0cy5FUlJfSU5WQUxJRF9OQVYgPSB2b2lkIDA7XG5jb25zdCBub2RlXzEgPSByZXF1aXJlKFwiLi4vbm9kZVwiKTtcbmNvbnN0IGdpbmRleF8xID0gcmVxdWlyZShcIi4uL2dpbmRleFwiKTtcbmV4cG9ydHMuRVJSX0lOVkFMSURfTkFWID0gXCJJbnZhbGlkIHRyZWUgbmF2aWdhdGlvblwiO1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlUHJvb2Yocm9vdE5vZGUsIGluZGV4KSB7XG4gICAgY29uc3Qgd2l0bmVzc2VzID0gW107XG4gICAgbGV0IG5vZGUgPSByb290Tm9kZTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgZ2luZGV4XzEuZ2luZGV4SXRlcmF0b3IoaW5kZXgpKSB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5FUlJfSU5WQUxJRF9OQVYpO1xuICAgICAgICAgICAgd2l0bmVzc2VzLnB1c2gobm9kZS5sZWZ0LnJvb3QpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5FUlJfSU5WQUxJRF9OQVYpO1xuICAgICAgICAgICAgd2l0bmVzc2VzLnB1c2gobm9kZS5yaWdodC5yb290KTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtub2RlLnJvb3QsIHdpdG5lc3Nlcy5yZXZlcnNlKCldO1xufVxuZXhwb3J0cy5jcmVhdGVTaW5nbGVQcm9vZiA9IGNyZWF0ZVNpbmdsZVByb29mO1xuZnVuY3Rpb24gY3JlYXRlTm9kZUZyb21TaW5nbGVQcm9vZihnaW5kZXgsIGxlYWYsIHdpdG5lc3Nlcykge1xuICAgIGxldCBub2RlID0gbm9kZV8xLkxlYWZOb2RlLmZyb21Sb290KGxlYWYpO1xuICAgIGNvbnN0IHcgPSB3aXRuZXNzZXMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgd2hpbGUgKGdpbmRleCA+IDEpIHtcbiAgICAgICAgY29uc3Qgc2libGluZyA9IG5vZGVfMS5MZWFmTm9kZS5mcm9tUm9vdCh3LnBvcCgpKTtcbiAgICAgICAgaWYgKGdpbmRleCAlIEJpZ0ludCgyKSA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICBub2RlID0gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKG5vZGUsIHNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBub2RlXzEuQnJhbmNoTm9kZShzaWJsaW5nLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBnaW5kZXggPSBnaW5kZXggLyBCaWdJbnQoMik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZXhwb3J0cy5jcmVhdGVOb2RlRnJvbVNpbmdsZVByb29mID0gY3JlYXRlTm9kZUZyb21TaW5nbGVQcm9vZjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZVRyZWVPZmZzZXRQcm9vZiA9IGV4cG9ydHMuc2VyaWFsaXplVHJlZU9mZnNldFByb29mID0gZXhwb3J0cy5jb21wdXRlVHJlZU9mZnNldFByb29mU2VyaWFsaXplZExlbmd0aCA9IGV4cG9ydHMuY3JlYXRlTm9kZUZyb21UcmVlT2Zmc2V0UHJvb2YgPSBleHBvcnRzLmNyZWF0ZVRyZWVPZmZzZXRQcm9vZiA9IGV4cG9ydHMudHJlZU9mZnNldFByb29mVG9Ob2RlID0gZXhwb3J0cy5ub2RlVG9UcmVlT2Zmc2V0UHJvb2YgPSB2b2lkIDA7XG5jb25zdCBub2RlXzEgPSByZXF1aXJlKFwiLi4vbm9kZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKipcbiAqIENvbXB1dGUgb2Zmc2V0cyBhbmQgbGVhdmVzIG9mIGEgdHJlZS1vZmZzZXQgcHJvb2ZcbiAqXG4gKiBSZWN1cnNpdmUgZnVuY3Rpb25cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvbGFtYmRhL2V0aC1tZXJrbGUtdHJlZXMvYmxvYi9tYXN0ZXIvdHJlZV9vZmZzZXRzLm1kXG4gKiBAcGFyYW0gbm9kZSBjdXJyZW50IG5vZGUgaW4gdGhlIHRyZWVcbiAqIEBwYXJhbSBnaW5kZXggY3VycmVudCBnZW5lcmFsaXplZCBpbmRleCBpbiB0aGUgdHJlZVxuICogQHBhcmFtIHByb29mR2luZGljZXMgZ2VuZXJhbGl6ZWQgaW5kaWNlcyB0byBsZWZ0IGluY2x1ZGUgaW4gdGhlIHByb29mIC0gbXVzdCBiZSBzb3J0ZWQgaW4tb3JkZXIgYWNjb3JkaW5nIHRvIHRoZSB0cmVlXG4gKi9cbmZ1bmN0aW9uIG5vZGVUb1RyZWVPZmZzZXRQcm9vZihub2RlLCBnaW5kZXgsIHByb29mR2luZGljZXMpIHtcbiAgICBpZiAoIXByb29mR2luZGljZXMubGVuZ3RoIHx8ICFwcm9vZkdpbmRpY2VzWzBdLnN0YXJ0c1dpdGgoZ2luZGV4KSkge1xuICAgICAgICAvLyB0aGVyZSBhcmUgbm8gcHJvb2YgaW5kaWNlcyBsZWZ0IE9SIHRoZSBjdXJyZW50IHN1YnRyZWUgY29udGFpbnMgbm8gcmVtYWluaW5nIHByb29mIGluZGljZXNcbiAgICAgICAgcmV0dXJuIFtbXSwgW11dO1xuICAgIH1cbiAgICBlbHNlIGlmIChnaW5kZXggPT09IHByb29mR2luZGljZXNbMF0pIHtcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgbm9kZSBpcyBhdCB0aGUgbmV4dCBwcm9vZiBpbmRleFxuICAgICAgICBwcm9vZkdpbmRpY2VzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBbW10sIFtub2RlLnJvb3RdXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXB1dGUgb2Zmc2V0cywgbGVhdmVzIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZVxuICAgICAgICBjb25zdCBbbGVmdE9mZnNldHMsIGxlZnRMZWF2ZXNdID0gbm9kZVRvVHJlZU9mZnNldFByb29mKG5vZGUubGVmdCwgZ2luZGV4ICsgXCIwXCIsIHByb29mR2luZGljZXMpO1xuICAgICAgICBjb25zdCBbcmlnaHRPZmZzZXRzLCByaWdodExlYXZlc10gPSBub2RlVG9UcmVlT2Zmc2V0UHJvb2Yobm9kZS5yaWdodCwgZ2luZGV4ICsgXCIxXCIsIHByb29mR2luZGljZXMpO1xuICAgICAgICAvLyB0aGUgb2Zmc2V0IHByZXBlbmRlZCB0byB0aGUgbGlzdCBpcyAjIG9mIGxlYXZlcyBpbiB0aGUgbGVmdCBzdWJ0cmVlXG4gICAgICAgIGNvbnN0IHBpdm90ID0gbGVmdExlYXZlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBbW3Bpdm90XS5jb25jYXQobGVmdE9mZnNldHMsIHJpZ2h0T2Zmc2V0cyksIGxlZnRMZWF2ZXMuY29uY2F0KHJpZ2h0TGVhdmVzKV07XG4gICAgfVxufVxuZXhwb3J0cy5ub2RlVG9UcmVlT2Zmc2V0UHJvb2YgPSBub2RlVG9UcmVlT2Zmc2V0UHJvb2Y7XG4vKipcbiAqIFJlY3JlYXRlIGEgYE5vZGVgIGdpdmVuIG9mZnNldHMgYW5kIGxlYXZlcyBvZiBhIHRyZWUtb2Zmc2V0IHByb29mXG4gKlxuICogUmVjdXJzaXZlIGRlZmluaXRpb25cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvbGFtYmRhL2V0aC1tZXJrbGUtdHJlZXMvYmxvYi9tYXN0ZXIvdHJlZV9vZmZzZXRzLm1kXG4gKi9cbmZ1bmN0aW9uIHRyZWVPZmZzZXRQcm9vZlRvTm9kZShvZmZzZXRzLCBsZWF2ZXMpIHtcbiAgICBpZiAoIWxlYXZlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvb2YgbXVzdCBjb250YWluIGd0IDAgbGVhdmVzXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBub2RlXzEuTGVhZk5vZGUuZnJvbVJvb3QobGVhdmVzWzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHRoZSBvZmZzZXQgcG9wcGVkIGZyb20gdGhlIGxpc3QgaXMgdGhlICMgb2YgbGVhdmVzIGluIHRoZSBsZWZ0IHN1YnRyZWVcbiAgICAgICAgY29uc3QgcGl2b3QgPSBvZmZzZXRzWzBdO1xuICAgICAgICByZXR1cm4gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKHRyZWVPZmZzZXRQcm9vZlRvTm9kZShvZmZzZXRzLnNsaWNlKDEsIHBpdm90KSwgbGVhdmVzLnNsaWNlKDAsIHBpdm90KSksIHRyZWVPZmZzZXRQcm9vZlRvTm9kZShvZmZzZXRzLnNsaWNlKHBpdm90KSwgbGVhdmVzLnNsaWNlKHBpdm90KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMudHJlZU9mZnNldFByb29mVG9Ob2RlID0gdHJlZU9mZnNldFByb29mVG9Ob2RlO1xuLyoqXG4gKiBDcmVhdGUgYSB0cmVlLW9mZnNldCBwcm9vZlxuICpcbiAqIEBwYXJhbSByb290Tm9kZSB0aGUgcm9vdCBub2RlIG9mIHRoZSB0cmVlXG4gKiBAcGFyYW0gZ2luZGljZXMgZ2VuZXJhbGl6ZWQgaW5kaWNlcyB0byBpbmNsdWRlIGluIHRoZSBwcm9vZlxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmVlT2Zmc2V0UHJvb2Yocm9vdE5vZGUsIGdpbmRpY2VzKSB7XG4gICAgcmV0dXJuIG5vZGVUb1RyZWVPZmZzZXRQcm9vZihyb290Tm9kZSwgXCIxXCIsIHV0aWxfMS5jb21wdXRlTXVsdGlQcm9vZkJpdHN0cmluZ3MoZ2luZGljZXMubWFwKChnKSA9PiBnLnRvU3RyaW5nKDIpKSkpO1xufVxuZXhwb3J0cy5jcmVhdGVUcmVlT2Zmc2V0UHJvb2YgPSBjcmVhdGVUcmVlT2Zmc2V0UHJvb2Y7XG4vKipcbiAqIFJlY3JlYXRlIGEgYE5vZGVgIGdpdmVuIGEgdHJlZS1vZmZzZXQgcHJvb2ZcbiAqXG4gKiBAcGFyYW0gb2Zmc2V0cyBvZmZzZXRzIG9mIGEgdHJlZS1vZmZzZXQgcHJvb2ZcbiAqIEBwYXJhbSBsZWF2ZXMgbGVhdmVzIG9mIGEgdHJlZS1vZmZzZXQgcHJvb2ZcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZUZyb21UcmVlT2Zmc2V0UHJvb2Yob2Zmc2V0cywgbGVhdmVzKSB7XG4gICAgLy8gVE9ETyB2YWxpZGF0aW9uXG4gICAgcmV0dXJuIHRyZWVPZmZzZXRQcm9vZlRvTm9kZShvZmZzZXRzLCBsZWF2ZXMpO1xufVxuZXhwb3J0cy5jcmVhdGVOb2RlRnJvbVRyZWVPZmZzZXRQcm9vZiA9IGNyZWF0ZU5vZGVGcm9tVHJlZU9mZnNldFByb29mO1xuZnVuY3Rpb24gY29tcHV0ZVRyZWVPZmZzZXRQcm9vZlNlcmlhbGl6ZWRMZW5ndGgob2Zmc2V0cywgbGVhdmVzKSB7XG4gICAgLy8gYWRkIDEgZm9yICMgb2YgbGVhdmVzXG4gICAgcmV0dXJuIChvZmZzZXRzLmxlbmd0aCArIDEpICogMiArIGxlYXZlcy5sZW5ndGggKiAzMjtcbn1cbmV4cG9ydHMuY29tcHV0ZVRyZWVPZmZzZXRQcm9vZlNlcmlhbGl6ZWRMZW5ndGggPSBjb21wdXRlVHJlZU9mZnNldFByb29mU2VyaWFsaXplZExlbmd0aDtcbi8vIFNlcmlhbGl6ZWQgdHJlZSBvZmZzZXQgcHJvb2Ygc3RydWN0dXJlOlxuLy8gIyBvZiBsZWF2ZXMgLSAyIGJ5dGVzXG4vLyBvZmZzZXRzIC0gMiBieXRlcyBlYWNoXG4vLyBsZWF2ZXMgLSAzMiBieXRlcyBlYWNoXG5mdW5jdGlvbiBzZXJpYWxpemVUcmVlT2Zmc2V0UHJvb2Yob3V0cHV0LCBieXRlT2Zmc2V0LCBvZmZzZXRzLCBsZWF2ZXMpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgRGF0YVZpZXcob3V0cHV0LmJ1ZmZlciwgb3V0cHV0LmJ5dGVPZmZzZXQsIG91dHB1dC5ieXRlTGVuZ3RoKTtcbiAgICAvLyBzZXQgIyBvZiBsZWF2ZXNcbiAgICB3cml0ZXIuc2V0VWludDE2KGJ5dGVPZmZzZXQsIGxlYXZlcy5sZW5ndGgsIHRydWUpO1xuICAgIC8vIHNldCBvZmZzZXRzXG4gICAgY29uc3Qgb2Zmc2V0c1N0YXJ0SW5kZXggPSBieXRlT2Zmc2V0ICsgMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVyLnNldFVpbnQxNihpICogMiArIG9mZnNldHNTdGFydEluZGV4LCBvZmZzZXRzW2ldLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gc2V0IGxlYXZlc1xuICAgIGNvbnN0IGxlYXZlc1N0YXJ0SW5kZXggPSBvZmZzZXRzU3RhcnRJbmRleCArIG9mZnNldHMubGVuZ3RoICogMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRwdXQuc2V0KGxlYXZlc1tpXSwgaSAqIDMyICsgbGVhdmVzU3RhcnRJbmRleCk7XG4gICAgfVxufVxuZXhwb3J0cy5zZXJpYWxpemVUcmVlT2Zmc2V0UHJvb2YgPSBzZXJpYWxpemVUcmVlT2Zmc2V0UHJvb2Y7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRyZWVPZmZzZXRQcm9vZihkYXRhLCBieXRlT2Zmc2V0KSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgLy8gZ2V0ICMgb2YgbGVhdmVzXG4gICAgY29uc3QgbGVhZkNvdW50ID0gcmVhZGVyLmdldFVpbnQxNihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAobGVhZkNvdW50IC0gMSkgKiAyICsgbGVhZkNvdW50ICogMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlc2VyaWFsaXplIHRyZWUgb2Zmc2V0IHByb29mOiBub3QgZW5vdWdoIGJ5dGVzXCIpO1xuICAgIH1cbiAgICAvLyBnZXQgb2Zmc2V0c1xuICAgIGNvbnN0IG9mZnNldHNTdGFydEluZGV4ID0gYnl0ZU9mZnNldCArIDI7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGxlYWZDb3VudCAtIDEgfSwgKF8sIGkpID0+IHJlYWRlci5nZXRVaW50MTYoaSAqIDIgKyBvZmZzZXRzU3RhcnRJbmRleCwgdHJ1ZSkpO1xuICAgIC8vIGdldCBsZWF2ZXNcbiAgICBjb25zdCBsZWF2ZXNTdGFydEluZGV4ID0gb2Zmc2V0c1N0YXJ0SW5kZXggKyBvZmZzZXRzLmxlbmd0aCAqIDI7XG4gICAgY29uc3QgbGVhdmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbGVhZkNvdW50IH0sIChfLCBpKSA9PiBkYXRhLnN1YmFycmF5KGkgKiAzMiArIGxlYXZlc1N0YXJ0SW5kZXgsIChpICsgMSkgKiAzMiArIGxlYXZlc1N0YXJ0SW5kZXgpKTtcbiAgICByZXR1cm4gW29mZnNldHMsIGxlYXZlc107XG59XG5leHBvcnRzLmRlc2VyaWFsaXplVHJlZU9mZnNldFByb29mID0gZGVzZXJpYWxpemVUcmVlT2Zmc2V0UHJvb2Y7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcHV0ZU11bHRpUHJvb2ZCaXRzdHJpbmdzID0gZXhwb3J0cy5Tb3J0T3JkZXIgPSBleHBvcnRzLmZpbHRlclBhcmVudEJpdHN0cmluZ3MgPSBleHBvcnRzLnNvcnREZWNyZWFzaW5nQml0c3RyaW5ncyA9IGV4cG9ydHMuc29ydEluT3JkZXJCaXRzdHJpbmdzID0gZXhwb3J0cy5jb21wdXRlUHJvb2ZCaXRzdHJpbmdzID0gZXhwb3J0cy5jb21wdXRlUHJvb2ZHaW5kaWNlcyA9IHZvaWQgMDtcbmNvbnN0IGdpbmRleF8xID0gcmVxdWlyZShcIi4uL2dpbmRleFwiKTtcbi8vIE5vdCBjdXJyZW50bHkgaW4gdXNlLCBidXQgc2ltcGxlciBpbXBsZW1lbnRhdGlvbiB1c2VmdWwgZm9yIHRlc3Rpbmdcbi8qKlxuICogQ29tcHV0ZSBib3RoIHRoZSBwYXRoIGFuZCBicmFuY2ggaW5kaWNlc1xuICpcbiAqIFBhdGggaW5kaWNlcyBhcmUgcGFyZW50IGluZGljZXMgdXB3YXJkcyB0b3dhcmQgdGhlIHJvb3RcbiAqIEJyYW5jaCBpbmRpY2VzIGFyZSB3aXRuZXNzZXMgcmVxdWlyZWQgZm9yIGEgbWVya2xlIHByb29mXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVQcm9vZkdpbmRpY2VzKGdpbmRleCkge1xuICAgIGNvbnN0IHBhdGggPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYnJhbmNoID0gbmV3IFNldCgpO1xuICAgIGxldCBnID0gZ2luZGV4O1xuICAgIHdoaWxlIChnID4gMSkge1xuICAgICAgICBwYXRoLmFkZChnKTtcbiAgICAgICAgYnJhbmNoLmFkZChnaW5kZXhfMS5naW5kZXhTaWJsaW5nKGcpKTtcbiAgICAgICAgZyA9IGdpbmRleF8xLmdpbmRleFBhcmVudChnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGF0aCwgYnJhbmNoIH07XG59XG5leHBvcnRzLmNvbXB1dGVQcm9vZkdpbmRpY2VzID0gY29tcHV0ZVByb29mR2luZGljZXM7XG4vKipcbiAqIENvbXB1dGUgYm90aCB0aGUgcGF0aCBhbmQgYnJhbmNoIGluZGljZXNcbiAqXG4gKiBQYXRoIGluZGljZXMgYXJlIHBhcmVudCBpbmRpY2VzIHVwd2FyZHMgdG93YXJkIHRoZSByb290XG4gKiBCcmFuY2ggaW5kaWNlcyBhcmUgd2l0bmVzc2VzIHJlcXVpcmVkIGZvciBhIG1lcmtsZSBwcm9vZlxuICovXG5mdW5jdGlvbiBjb21wdXRlUHJvb2ZCaXRzdHJpbmdzKGdpbmRleCkge1xuICAgIGNvbnN0IHBhdGggPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYnJhbmNoID0gbmV3IFNldCgpO1xuICAgIGxldCBnID0gZ2luZGV4O1xuICAgIHdoaWxlIChnLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGF0aC5hZGQoZyk7XG4gICAgICAgIGNvbnN0IGxhc3RCaXQgPSBnW2cubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGcuc3Vic3RyaW5nKDAsIGcubGVuZ3RoIC0gMSk7XG4gICAgICAgIGJyYW5jaC5hZGQocGFyZW50ICsgKE51bWJlcihsYXN0Qml0KSBeIDEpKTtcbiAgICAgICAgZyA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGF0aCwgYnJhbmNoIH07XG59XG5leHBvcnRzLmNvbXB1dGVQcm9vZkJpdHN0cmluZ3MgPSBjb21wdXRlUHJvb2ZCaXRzdHJpbmdzO1xuLyoqXG4gKiBTb3J0IGdlbmVyYWxpemVkIGluZGljZXMgaW4tb3JkZXJcbiAqIEBwYXJhbSBiaXRMZW5ndGggbWF4aW11bSBiaXQgbGVuZ3RoIG9mIGdlbmVyYWxpemVkIGluZGljZXMgdG8gc29ydFxuICovXG5mdW5jdGlvbiBzb3J0SW5PcmRlckJpdHN0cmluZ3MoZ2luZGljZXMsIGJpdExlbmd0aCkge1xuICAgIGlmICghZ2luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGdpbmRpY2VzXG4gICAgICAgIC5tYXAoKGcpID0+IGcucGFkRW5kKGJpdExlbmd0aCkpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoZykgPT4gZy50cmltKCkpO1xufVxuZXhwb3J0cy5zb3J0SW5PcmRlckJpdHN0cmluZ3MgPSBzb3J0SW5PcmRlckJpdHN0cmluZ3M7XG4vKipcbiAqIFNvcnQgZ2VuZXJhbGl6ZWQgaW5kaWNlcyBpbiBkZWNyZWFzaW5nIG9yZGVyXG4gKi9cbmZ1bmN0aW9uIHNvcnREZWNyZWFzaW5nQml0c3RyaW5ncyhnaW5kaWNlcykge1xuICAgIGlmICghZ2luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGdpbmRpY2VzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIubGVuZ3RoIDwgYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYVBvczAgPSBhLmluZGV4T2YoXCIwXCIpO1xuICAgICAgICBsZXQgYlBvczAgPSBiLmluZGV4T2YoXCIwXCIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoYVBvczAgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYlBvczAgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVBvczAgPCBiUG9zMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYlBvczAgPCBhUG9zMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFQb3MwID0gYS5pbmRleE9mKFwiMFwiLCBhUG9zMCArIDEpO1xuICAgICAgICAgICAgYlBvczAgPSBiLmluZGV4T2YoXCIwXCIsIGJQb3MwICsgMSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc29ydERlY3JlYXNpbmdCaXRzdHJpbmdzID0gc29ydERlY3JlYXNpbmdCaXRzdHJpbmdzO1xuLyoqXG4gKiBGaWx0ZXIgb3V0IHBhcmVudCBnZW5lcmFsaXplZCBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGZpbHRlclBhcmVudEJpdHN0cmluZ3MoZ2luZGljZXMpIHtcbiAgICBjb25zdCBzb3J0ZWRCaXRzdHJpbmdzID0gZ2luZGljZXMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLmxlbmd0aCAtIGIubGVuZ3RoKTtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgIG91dGVyOiBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZEJpdHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnNBID0gc29ydGVkQml0c3RyaW5nc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgc29ydGVkQml0c3RyaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYnNCID0gc29ydGVkQml0c3RyaW5nc1tqXTtcbiAgICAgICAgICAgIGlmIChic0Iuc3RhcnRzV2l0aChic0EpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyZWQucHVzaChic0EpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG59XG5leHBvcnRzLmZpbHRlclBhcmVudEJpdHN0cmluZ3MgPSBmaWx0ZXJQYXJlbnRCaXRzdHJpbmdzO1xudmFyIFNvcnRPcmRlcjtcbihmdW5jdGlvbiAoU29ydE9yZGVyKSB7XG4gICAgU29ydE9yZGVyW1NvcnRPcmRlcltcIkluT3JkZXJcIl0gPSAwXSA9IFwiSW5PcmRlclwiO1xuICAgIFNvcnRPcmRlcltTb3J0T3JkZXJbXCJEZWNyZWFzaW5nXCJdID0gMV0gPSBcIkRlY3JlYXNpbmdcIjtcbiAgICBTb3J0T3JkZXJbU29ydE9yZGVyW1wiVW5zb3J0ZWRcIl0gPSAyXSA9IFwiVW5zb3J0ZWRcIjtcbn0pKFNvcnRPcmRlciA9IGV4cG9ydHMuU29ydE9yZGVyIHx8IChleHBvcnRzLlNvcnRPcmRlciA9IHt9KSk7XG4vKipcbiAqIFJldHVybiB0aGUgc2V0IG9mIGdlbmVyYWxpemVkIGluZGljZXMgcmVxdWlyZWQgZm9yIGEgbXVsdGlwcm9vZlxuICogVGhpcyBtYXkgaW5jbHVkZSBhbGwgbGVhdmVzIGFuZCBhbnkgbmVjZXNzYXJ5IHdpdG5lc3Nlc1xuICogQHBhcmFtIGdpbmRpY2VzIGxlYXZlcyB0byBpbmNsdWRlIGluIHByb29mXG4gKiBAcmV0dXJucyBhbGwgZ2VuZXJhbGl6ZWQgaW5kaWNlcyByZXF1aXJlZCBmb3IgYSBtdWx0aXByb29mIChsZWF2ZXMgYW5kIHdpdG5lc3NlcyksIGRlZHVwbGljYXRlZCBhbmQgc29ydGVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNdWx0aVByb29mQml0c3RyaW5ncyhnaW5kaWNlcywgaW5jbHVkZUxlYXZlcyA9IHRydWUsIHNvcnRPcmRlciA9IFNvcnRPcmRlci5Jbk9yZGVyKSB7XG4gICAgY29uc3QgbGVhdmVzID0gZmlsdGVyUGFyZW50Qml0c3RyaW5ncyhnaW5kaWNlcyk7XG4gICAgLy8gTWF5YmUgaW5pdGlhbGl6ZSB0aGUgcHJvb2YgaW5kaWNlcyB3aXRoIHRoZSBsZWF2ZXNcbiAgICBjb25zdCBwcm9vZiA9IG5ldyBTZXQoaW5jbHVkZUxlYXZlcyA/IGxlYXZlcyA6IFtdKTtcbiAgICBjb25zdCBwYXRocyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBicmFuY2hlcyA9IG5ldyBTZXQoKTtcbiAgICAvLyBDb2xsZWN0IGFsbCBwYXRoIGluZGljZXMgYW5kIGFsbCBicmFuY2ggaW5kaWNlc1xuICAgIGxldCBtYXhCaXRMZW5ndGggPSAxO1xuICAgIGZvciAoY29uc3QgZ2luZGV4IG9mIGxlYXZlcykge1xuICAgICAgICBpZiAoZ2luZGV4Lmxlbmd0aCA+IG1heEJpdExlbmd0aClcbiAgICAgICAgICAgIG1heEJpdExlbmd0aCA9IGdpbmRleC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb21wdXRlUHJvb2ZCaXRzdHJpbmdzKGdpbmRleCk7XG4gICAgICAgIHBhdGguZm9yRWFjaCgoZykgPT4gcGF0aHMuYWRkKGcpKTtcbiAgICAgICAgYnJhbmNoLmZvckVhY2goKGcpID0+IGJyYW5jaGVzLmFkZChnKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbGwgYnJhbmNoZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gdGhlIHBhdGhzXG4gICAgcGF0aHMuZm9yRWFjaCgoZykgPT4gYnJhbmNoZXMuZGVsZXRlKGcpKTtcbiAgICAvLyBBZGQgYWxsIHJlbWFpbmluZyBicmFuY2hlcyB0byB0aGUgbGVhdmVzXG4gICAgYnJhbmNoZXMuZm9yRWFjaCgoZykgPT4gcHJvb2YuYWRkKGcpKTtcbiAgICBzd2l0Y2ggKHNvcnRPcmRlcikge1xuICAgICAgICBjYXNlIFNvcnRPcmRlci5Jbk9yZGVyOlxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbk9yZGVyQml0c3RyaW5ncyhBcnJheS5mcm9tKHByb29mKSwgbWF4Qml0TGVuZ3RoKTtcbiAgICAgICAgY2FzZSBTb3J0T3JkZXIuRGVjcmVhc2luZzpcbiAgICAgICAgICAgIHJldHVybiBzb3J0RGVjcmVhc2luZ0JpdHN0cmluZ3MoQXJyYXkuZnJvbShwcm9vZikpO1xuICAgICAgICBjYXNlIFNvcnRPcmRlci5VbnNvcnRlZDpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHByb29mKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXB1dGVNdWx0aVByb29mQml0c3RyaW5ncyA9IGNvbXB1dGVNdWx0aVByb29mQml0c3RyaW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdWJ0cmVlRmlsbFRvQ29udGVudHMgPSBleHBvcnRzLnN1YnRyZWVGaWxsVG9MZW5ndGggPSBleHBvcnRzLnN1YnRyZWVGaWxsVG9EZXB0aCA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfMSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5jb25zdCB6ZXJvTm9kZV8xID0gcmVxdWlyZShcIi4vemVyb05vZGVcIik7XG5mdW5jdGlvbiBzdWJ0cmVlRmlsbFRvRGVwdGgoYm90dG9tLCBkZXB0aCkge1xuICAgIGxldCBub2RlID0gYm90dG9tO1xuICAgIHdoaWxlIChkZXB0aCA+IDApIHtcbiAgICAgICAgbm9kZSA9IG5ldyBub2RlXzEuQnJhbmNoTm9kZShub2RlLCBub2RlKTtcbiAgICAgICAgZGVwdGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5leHBvcnRzLnN1YnRyZWVGaWxsVG9EZXB0aCA9IHN1YnRyZWVGaWxsVG9EZXB0aDtcbmZ1bmN0aW9uIHN1YnRyZWVGaWxsVG9MZW5ndGgoYm90dG9tLCBkZXB0aCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gMSA8PCBkZXB0aDtcbiAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJfVE9PX01BTllfTk9ERVNcIik7XG4gICAgaWYgKGxlbmd0aCA9PT0gbWF4TGVuZ3RoKVxuICAgICAgICByZXR1cm4gc3VidHJlZUZpbGxUb0RlcHRoKGJvdHRvbSwgZGVwdGgpO1xuICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGJvdHRvbTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJSX05BVklHQVRJT05cIik7XG4gICAgfVxuICAgIGlmIChkZXB0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKGJvdHRvbSwgbGVuZ3RoID4gMSA/IGJvdHRvbSA6IHplcm9Ob2RlXzEuemVyb05vZGUoMCkpO1xuICAgIH1cbiAgICBjb25zdCBwaXZvdCA9IG1heExlbmd0aCA+PiAxO1xuICAgIGlmIChsZW5ndGggPD0gcGl2b3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBub2RlXzEuQnJhbmNoTm9kZShzdWJ0cmVlRmlsbFRvTGVuZ3RoKGJvdHRvbSwgZGVwdGggLSAxLCBsZW5ndGgpLCB6ZXJvTm9kZV8xLnplcm9Ob2RlKGRlcHRoIC0gMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBub2RlXzEuQnJhbmNoTm9kZShzdWJ0cmVlRmlsbFRvRGVwdGgoYm90dG9tLCBkZXB0aCAtIDEpLCBzdWJ0cmVlRmlsbFRvTGVuZ3RoKGJvdHRvbSwgZGVwdGggLSAxLCBsZW5ndGggLSBwaXZvdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuc3VidHJlZUZpbGxUb0xlbmd0aCA9IHN1YnRyZWVGaWxsVG9MZW5ndGg7XG4vKipcbiAqIFdBUk5JTkc6IE11dGF0ZXMgdGhlIHByb3ZpZGVkIG5vZGVzIGFycmF5LlxuICogVE9ETzogRG9uJ3QgbXV0YXRlIHRoZSBub2RlcyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3VidHJlZUZpbGxUb0NvbnRlbnRzKG5vZGVzLCBkZXB0aCkge1xuICAgIGNvbnN0IG1heExlbmd0aCA9IDIgKiogZGVwdGg7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vZGVzLmxlbmd0aCAke25vZGVzLmxlbmd0aH0gb3ZlciBtYXhJbmRleCBhdCBkZXB0aCAke2RlcHRofWApO1xuICAgIH1cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB6ZXJvTm9kZV8xLnplcm9Ob2RlKGRlcHRoKTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAxXG4gICAgICAgICAgICA/IC8vIEFsbCBub2RlcyBhdCBkZXB0aCAxIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIG5ldyBub2RlXzEuQnJhbmNoTm9kZShub2Rlc1swXSwgbm9kZXNbMV0pXG4gICAgICAgICAgICA6IC8vIFBhZCB3aXRoIHplcm8gbm9kZVxuICAgICAgICAgICAgICAgIG5ldyBub2RlXzEuQnJhbmNoTm9kZShub2Rlc1swXSwgemVyb05vZGVfMS56ZXJvTm9kZSgwKSk7XG4gICAgfVxuICAgIGxldCBjb3VudCA9IG5vZGVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGg7IGQgPiAwOyBkLS0pIHtcbiAgICAgICAgY29uc3QgY291bnRSZW1haW5kZXIgPSBjb3VudCAlIDI7XG4gICAgICAgIGNvbnN0IGNvdW50RXZlbiA9IGNvdW50IC0gY291bnRSZW1haW5kZXI7XG4gICAgICAgIC8vIEZvciBlYWNoIGRlcHRoIGxldmVsIGNvbXB1dGUgdGhlIG5ldyBCcmFuY2hOb2RlcyBhbmQgb3ZlcndyaXRlIHRoZSBub2RlcyBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50RXZlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICBub2Rlc1tpIC8gMl0gPSBuZXcgbm9kZV8xLkJyYW5jaE5vZGUobm9kZXNbaV0sIG5vZGVzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50UmVtYWluZGVyID4gMCkge1xuICAgICAgICAgICAgbm9kZXNbY291bnRFdmVuIC8gMl0gPSBuZXcgbm9kZV8xLkJyYW5jaE5vZGUobm9kZXNbY291bnRFdmVuXSwgemVyb05vZGVfMS56ZXJvTm9kZShkZXB0aCAtIGQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgcmVtYWluZXIsIDIgbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBjb3VudFxuICAgICAgICBjb3VudCA9IGNvdW50RXZlbiAvIDIgKyBjb3VudFJlbWFpbmRlcjtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzWzBdO1xufVxuZXhwb3J0cy5zdWJ0cmVlRmlsbFRvQ29udGVudHMgPSBzdWJ0cmVlRmlsbFRvQ29udGVudHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJlZVplcm9BZnRlckluZGV4ID0gZXhwb3J0cy5pdGVyYXRlTm9kZXNBdERlcHRoID0gZXhwb3J0cy5nZXROb2Rlc0F0RGVwdGggPSBleHBvcnRzLnNldE5vZGVzQXREZXB0aCA9IGV4cG9ydHMuc2V0Tm9kZUF0RGVwdGggPSBleHBvcnRzLmdldE5vZGVBdERlcHRoID0gZXhwb3J0cy5zZXROb2RlV2l0aEZuID0gZXhwb3J0cy5zZXROb2RlID0gZXhwb3J0cy5nZXROb2RlID0gZXhwb3J0cy5UcmVlID0gdm9pZCAwO1xuY29uc3QgemVyb05vZGVfMSA9IHJlcXVpcmUoXCIuL3plcm9Ob2RlXCIpO1xuY29uc3QgZ2luZGV4XzEgPSByZXF1aXJlKFwiLi9naW5kZXhcIik7XG5jb25zdCBub2RlXzEgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuY29uc3QgcHJvb2ZfMSA9IHJlcXVpcmUoXCIuL3Byb29mXCIpO1xuY29uc3Qgc2luZ2xlXzEgPSByZXF1aXJlKFwiLi9wcm9vZi9zaW5nbGVcIik7XG4vKipcbiAqIEJpbmFyeSBtZXJrbGUgdHJlZVxuICpcbiAqIFdyYXBwZXIgYXJvdW5kIGltbXV0YWJsZSBgTm9kZWAgdG8gc3VwcG9ydCBtdXRhYmlsaXR5LlxuICpcbiAqIE11dGFiaWxpdHkgYmV0d2VlbiBhIHBhcmVudCB0cmVlIGFuZCBzdWJ0cmVlIGlzIGFjaGlldmVkIGJ5IG1haW50YWluaW5nIGEgYGhvb2tgIGNhbGxiYWNrLCB3aGljaCB1cGRhdGVzIHRoZSBwYXJlbnQgd2hlbiB0aGUgc3VidHJlZSBpcyB1cGRhdGVkLlxuICovXG5jbGFzcyBUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBob29rKSB7XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlID0gbm9kZTtcbiAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgV2Vha1JlZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2sgPSBuZXcgV2Vha1JlZihob29rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgVHJlZWAgZnJvbSBhIGBQcm9vZmAgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21Qcm9vZihwcm9vZikge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUocHJvb2ZfMS5jcmVhdGVOb2RlRnJvbVByb29mKHByb29mKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByb290IG5vZGUgb2YgdGhlIHRyZWVcbiAgICAgKi9cbiAgICBnZXQgcm9vdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290Tm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoZSByb290IG5vZGUgd2lsbCB0cmlnZ2VyIGEgY2FsbCB0byB0aGUgdHJlZSdzIGBob29rYCBpZiBpdCBleGlzdHMuXG4gICAgICovXG4gICAgc2V0IHJvb3ROb2RlKG5ld1Jvb3ROb2RlKSB7XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlID0gbmV3Um9vdE5vZGU7XG4gICAgICAgIGlmICh0aGlzLmhvb2spIHtcbiAgICAgICAgICAgIC8vIFdlYWtSZWYgc2hvdWxkIG5vdCBjaGFuZ2Ugc3RhdHVzIGR1cmluZyBhIHByb2dyYW0ncyBleGVjdXRpb25cbiAgICAgICAgICAgIC8vIFNvLCB1c2UgV2Vha1JlZiBmZWF0dXJlIGRldGVjdGlvbiB0byBhc3N1bWUgdGhlIHR5cGUgb2YgdGhpcy5ob29rXG4gICAgICAgICAgICAvLyB0byBtaW5pbWl6ZSB0aGUgbWVtb3J5IGZvb3RwcmludCBvZiBUcmVlXG4gICAgICAgICAgICBpZiAodHlwZW9mIFdlYWtSZWYgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2sobmV3Um9vdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va1ZhciA9IHRoaXMuaG9vay5kZXJlZigpO1xuICAgICAgICAgICAgICAgIGlmIChob29rVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tWYXIobmV3Um9vdE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSG9vayBoYXMgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZCwgbm8gbmVlZCB0byBrZWVwIHRoZSBob29rUmVmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9vayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgaGFzaCBvZiB0aGUgdHJlZVxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZS5yb290O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSB0cmVlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnJvb3ROb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdWJ0cmVlIGF0IHRoZSBzcGVjaWZpZWQgZ2luZGV4LlxuICAgICAqXG4gICAgICogTm90ZTogVGhlIHJldHVybmVkIHN1YnRyZWUgd2lsbCBoYXZlIGEgYGhvb2tgIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnQgdHJlZS5cbiAgICAgKiBVcGRhdGVzIHRvIHRoZSBzdWJ0cmVlIHdpbGwgcmVzdWx0IGluIHVwZGF0ZXMgdG8gdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICBnZXRTdWJ0cmVlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmdldE5vZGUoaW5kZXgpLCAobm9kZSkgPT4gdGhpcy5zZXROb2RlKGluZGV4LCBub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIGdpbmRleC5cbiAgICAgKi9cbiAgICBnZXROb2RlKGdpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzLnJvb3ROb2RlLCBnaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBkZXB0aCBhbmQgaW5kZXguXG4gICAgICpcbiAgICAgKiBTdXBwb3J0cyBpbmRleCB1cCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqL1xuICAgIGdldE5vZGVBdERlcHRoKGRlcHRoLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0Tm9kZUF0RGVwdGgodGhpcy5yb290Tm9kZSwgZGVwdGgsIGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBoYXNoIGF0IHRoZSBzcGVjaWZpZWQgZ2luZGV4LlxuICAgICAqL1xuICAgIGdldFJvb3QoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZShpbmRleCkucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBub2RlIGF0IGF0IHRoZSBzcGVjaWZpZWQgZ2luZGV4LlxuICAgICAqL1xuICAgIHNldE5vZGUoZ2luZGV4LCBuKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGUgPSBzZXROb2RlKHRoaXMucm9vdE5vZGUsIGdpbmRleCwgbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIHRvIHRoZSBub2RlIGF0IHRoZSBzcGVjaWZpZWQgZ2luZGV4LFxuICAgICAqIHRoZW4gYXBwbHkgdGhlIGZ1bmN0aW9uIHRvIGdldCBhIG5ldyBub2RlIGFuZCBzZXQgdGhlIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBnaW5kZXggd2l0aCB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGNvbnZlbmllbnQgbWV0aG9kIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHRyZWUgMiB0aW1lcyB0b1xuICAgICAqIGdldCBhbmQgc2V0LlxuICAgICAqL1xuICAgIHNldE5vZGVXaXRoRm4oZ2luZGV4LCBnZXROZXdOb2RlKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGUgPSBzZXROb2RlV2l0aEZuKHRoaXMucm9vdE5vZGUsIGdpbmRleCwgZ2V0TmV3Tm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIGRlcHRoIGFuZCBpbmRleC5cbiAgICAgKlxuICAgICAqIFN1cHBvcnRzIGluZGV4IHVwIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICovXG4gICAgc2V0Tm9kZUF0RGVwdGgoZGVwdGgsIGluZGV4LCBub2RlKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGUgPSBzZXROb2RlQXREZXB0aCh0aGlzLnJvb3ROb2RlLCBkZXB0aCwgaW5kZXgsIG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGhhc2ggYXQgdGhlIHNwZWNpZmllZCBnaW5kZXguXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIHdpbGwgc2V0IGEgbmV3IGBMZWFmTm9kZWAgYXQgdGhlIHNwZWNpZmllZCBnaW5kZXguXG4gICAgICovXG4gICAgc2V0Um9vdChpbmRleCwgcm9vdCkge1xuICAgICAgICB0aGlzLnNldE5vZGUoaW5kZXgsIG5vZGVfMS5MZWFmTm9kZS5mcm9tUm9vdChyb290KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhc3QgcmVhZC1vbmx5IGl0ZXJhdGlvblxuICAgICAqIEluLW9yZGVyIHRyYXZlcnNhbCBvZiBub2RlcyBhdCBgZGVwdGhgXG4gICAgICogc3RhcnRpbmcgZnJvbSB0aGUgYHN0YXJ0SW5kZXhgLWluZGV4ZWQgbm9kZVxuICAgICAqIGl0ZXJhdGluZyB0aHJvdWdoIGBjb3VudGAgbm9kZXNcbiAgICAgKlxuICAgICAqIFN1cHBvcnRzIGluZGV4IHVwIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICovXG4gICAgZ2V0Tm9kZXNBdERlcHRoKGRlcHRoLCBzdGFydEluZGV4LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gZ2V0Tm9kZXNBdERlcHRoKHRoaXMucm9vdE5vZGUsIGRlcHRoLCBzdGFydEluZGV4LCBjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhc3QgcmVhZC1vbmx5IGl0ZXJhdGlvblxuICAgICAqIEluLW9yZGVyIHRyYXZlcnNhbCBvZiBub2RlcyBhdCBgZGVwdGhgXG4gICAgICogc3RhcnRpbmcgZnJvbSB0aGUgYHN0YXJ0SW5kZXhgLWluZGV4ZWQgbm9kZVxuICAgICAqIGl0ZXJhdGluZyB0aHJvdWdoIGBjb3VudGAgbm9kZXNcbiAgICAgKlxuICAgICAqIFN1cHBvcnRzIGluZGV4IHVwIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICovXG4gICAgaXRlcmF0ZU5vZGVzQXREZXB0aChkZXB0aCwgc3RhcnRJbmRleCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVOb2Rlc0F0RGVwdGgodGhpcy5yb290Tm9kZSwgZGVwdGgsIHN0YXJ0SW5kZXgsIGNvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbWVya2xlIHByb29mIGZvciB0aGUgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIGdpbmRleC5cbiAgICAgKi9cbiAgICBnZXRTaW5nbGVQcm9vZihpbmRleCkge1xuICAgICAgICByZXR1cm4gc2luZ2xlXzEuY3JlYXRlU2luZ2xlUHJvb2YodGhpcy5yb290Tm9kZSwgaW5kZXgpWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBtZXJrbGUgcHJvb2YgZm9yIHRoZSBwcm9vZiBpbnB1dC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBtdWx0aXByb29mcy5cbiAgICAgKi9cbiAgICBnZXRQcm9vZihpbnB1dCkge1xuICAgICAgICByZXR1cm4gcHJvb2ZfMS5jcmVhdGVQcm9vZih0aGlzLnJvb3ROb2RlLCBpbnB1dCk7XG4gICAgfVxufVxuZXhwb3J0cy5UcmVlID0gVHJlZTtcbi8qKlxuICogUmV0dXJuIHRoZSBub2RlIGF0IHRoZSBzcGVjaWZpZWQgZ2luZGV4LlxuICovXG5mdW5jdGlvbiBnZXROb2RlKHJvb3ROb2RlLCBnaW5kZXgpIHtcbiAgICBjb25zdCBnaW5kZXhCaXRzdHJpbmcgPSBnaW5kZXhfMS5jb252ZXJ0R2luZGV4VG9CaXRzdHJpbmcoZ2luZGV4KTtcbiAgICBsZXQgbm9kZSA9IHJvb3ROb2RlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZ2luZGV4Qml0c3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJlZSAtIGZvdW5kIGxlYWYgYXQgZGVwdGggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGJpdCBpcyBzZXQsIG1lYW5zIG5hdmlnYXRlIHJpZ2h0XG4gICAgICAgIG5vZGUgPSBnaW5kZXhCaXRzdHJpbmdbaV0gPT09IFwiMVwiID8gbm9kZS5yaWdodCA6IG5vZGUubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5leHBvcnRzLmdldE5vZGUgPSBnZXROb2RlO1xuLyoqXG4gKiBTZXQgdGhlIG5vZGUgYXQgYXQgdGhlIHNwZWNpZmllZCBnaW5kZXguXG4gKiBSZXR1cm5zIHRoZSBuZXcgcm9vdCBub2RlLlxuICovXG5mdW5jdGlvbiBzZXROb2RlKHJvb3ROb2RlLCBnaW5kZXgsIG4pIHtcbiAgICAvLyBQcmUtY29tcHV0ZSBlbnRpcmUgYml0c3RyaW5nIGluc3RlYWQgb2YgdXNpbmcgYW4gaXRlcmF0b3IgKDI1JSBmYXN0ZXIpXG4gICAgY29uc3QgZ2luZGV4Qml0c3RyaW5nID0gZ2luZGV4XzEuY29udmVydEdpbmRleFRvQml0c3RyaW5nKGdpbmRleCk7XG4gICAgY29uc3QgcGFyZW50Tm9kZXMgPSBnZXRQYXJlbnROb2Rlcyhyb290Tm9kZSwgZ2luZGV4Qml0c3RyaW5nKTtcbiAgICByZXR1cm4gcmViaW5kTm9kZVRvUm9vdChnaW5kZXhCaXRzdHJpbmcsIHBhcmVudE5vZGVzLCBuKTtcbn1cbmV4cG9ydHMuc2V0Tm9kZSA9IHNldE5vZGU7XG4vKipcbiAqIFRyYXZlcnNlIHRvIHRoZSBub2RlIGF0IHRoZSBzcGVjaWZpZWQgZ2luZGV4LFxuICogdGhlbiBhcHBseSB0aGUgZnVuY3Rpb24gdG8gZ2V0IGEgbmV3IG5vZGUgYW5kIHNldCB0aGUgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIGdpbmRleCB3aXRoIHRoZSByZXN1bHQuXG4gKlxuICogVGhpcyBpcyBhIGNvbnZlbmllbnQgbWV0aG9kIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHRyZWUgMiB0aW1lcyB0b1xuICogZ2V0IGFuZCBzZXQuXG4gKlxuICogUmV0dXJucyB0aGUgbmV3IHJvb3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gc2V0Tm9kZVdpdGhGbihyb290Tm9kZSwgZ2luZGV4LCBnZXROZXdOb2RlKSB7XG4gICAgLy8gUHJlLWNvbXB1dGUgZW50aXJlIGJpdHN0cmluZyBpbnN0ZWFkIG9mIHVzaW5nIGFuIGl0ZXJhdG9yICgyNSUgZmFzdGVyKVxuICAgIGNvbnN0IGdpbmRleEJpdHN0cmluZyA9IGdpbmRleF8xLmNvbnZlcnRHaW5kZXhUb0JpdHN0cmluZyhnaW5kZXgpO1xuICAgIGNvbnN0IHBhcmVudE5vZGVzID0gZ2V0UGFyZW50Tm9kZXMocm9vdE5vZGUsIGdpbmRleEJpdHN0cmluZyk7XG4gICAgY29uc3QgbGFzdFBhcmVudE5vZGUgPSBwYXJlbnROb2Rlc1twYXJlbnROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0Qml0ID0gZ2luZGV4Qml0c3RyaW5nW2dpbmRleEJpdHN0cmluZy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBvbGROb2RlID0gbGFzdEJpdCA9PT0gXCIxXCIgPyBsYXN0UGFyZW50Tm9kZS5yaWdodCA6IGxhc3RQYXJlbnROb2RlLmxlZnQ7XG4gICAgY29uc3QgbmV3Tm9kZSA9IGdldE5ld05vZGUob2xkTm9kZSk7XG4gICAgcmV0dXJuIHJlYmluZE5vZGVUb1Jvb3QoZ2luZGV4Qml0c3RyaW5nLCBwYXJlbnROb2RlcywgbmV3Tm9kZSk7XG59XG5leHBvcnRzLnNldE5vZGVXaXRoRm4gPSBzZXROb2RlV2l0aEZuO1xuLyoqXG4gKiBUcmF2ZXJzZSB0aGUgdHJlZSBmcm9tIHJvb3Qgbm9kZSwgaWdub3JlIHRoZSBsYXN0IGJpdCB0byBnZXQgYWxsIHBhcmVudCBub2Rlc1xuICogb2YgdGhlIHNwZWNpZmllZCBiaXRzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGVzKHJvb3ROb2RlLCBiaXRzdHJpbmcpIHtcbiAgICBsZXQgbm9kZSA9IHJvb3ROb2RlO1xuICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBwYXJlbnQgbm9kZXMgb2Ygbm9kZSBhdCBnaW5kZXggYGluZGV4YC4gVGhlbiB3YWxrIHRoZSBsaXN0XG4gICAgLy8gYmFja3dhcmRzIHRvIHJlYmluZCB0aGVtIFwicmVjdXJzaXZlbHlcIiB3aXRoIHRoZSBuZXcgbm9kZXMgd2l0aG91dCB1c2luZyBmdW5jdGlvbnNcbiAgICBjb25zdCBwYXJlbnROb2RlcyA9IFtyb290Tm9kZV07XG4gICAgLy8gSWdub3JlIHRoZSBmaXJzdCBiaXQsIGxlZnQgcmlnaHQgZGlyZWN0aW9ucyBhcmUgYXQgYml0cyBbMSwuLl1cbiAgICAvLyBJZ25vcmUgdGhlIGxhc3QgYml0LCBubyBuZWVkIHRvIHB1c2ggdGhlIHRhcmdldCBub2RlIHRvIHRoZSBwYXJlbnROb2RlcyBhcnJheVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYml0c3RyaW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAvLyBDb21wYXJlIHRvIHN0cmluZyBkaXJlY3RseSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHR5cGUgY29udmVyc2lvbnNcbiAgICAgICAgaWYgKGJpdHN0cmluZ1tpXSA9PT0gXCIxXCIpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Tm9kZXM7XG59XG4vKipcbiAqIEJ1aWxkIGEgbmV3IHRyZWUgc3RydWN0dXJlIGZyb20gYml0c3RyaW5nLCBwYXJlbnROb2RlcyBhbmQgYSBuZXcgbm9kZS5cbiAqIFJldHVybnMgdGhlIG5ldyByb290IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHJlYmluZE5vZGVUb1Jvb3QoYml0c3RyaW5nLCBwYXJlbnROb2RlcywgbmV3Tm9kZSkge1xuICAgIGxldCBub2RlID0gbmV3Tm9kZTtcbiAgICAvLyBJZ25vcmUgdGhlIGZpcnN0IGJpdCwgbGVmdCByaWdodCBkaXJlY3Rpb25zIGFyZSBhdCBiaXRzIFsxLC4uXVxuICAgIC8vIEl0ZXJhdGUgdGhlIGxpc3QgYmFja3dhcmRzIGluY2x1ZGluZyB0aGUgbGFzdCBiaXQsIGJ1dCBvZmZzZXQgdGhlIHBhcmVudE5vZGVzIGFycmF5XG4gICAgLy8gYnkgb25lIHNpbmNlIHRoZSBmaXJzdCBiaXQgaW4gYml0c3RyaW5nIHdhcyBpZ25vcmVkIGluIHRoZSBwcmV2aW91cyBsb29wXG4gICAgZm9yIChsZXQgaSA9IGJpdHN0cmluZy5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgICAgICBpZiAoYml0c3RyaW5nW2ldID09PSBcIjFcIikge1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBub2RlXzEuQnJhbmNoTm9kZShwYXJlbnROb2Rlc1tpIC0gMV0ubGVmdCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKG5vZGUsIHBhcmVudE5vZGVzW2kgLSAxXS5yaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vKipcbiAqIFN1cHBvcnRzIGluZGV4IHVwIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVBdERlcHRoKHJvb3ROb2RlLCBkZXB0aCwgaW5kZXgpIHtcbiAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gcm9vdE5vZGUubGVmdCA6IHJvb3ROb2RlLnJpZ2h0O1xuICAgIH1cbiAgICAvLyBJZ25vcmUgZmlyc3QgYml0IFwiMVwiLCB0aGVuIHN1YnN0cmFjdCAxIHRvIGdldCB0byB0aGUgcGFyZW50XG4gICAgY29uc3QgZGVwdGhpUm9vdCA9IGRlcHRoIC0gMTtcbiAgICBjb25zdCBkZXB0aGlQYXJlbnQgPSAwO1xuICAgIGxldCBub2RlID0gcm9vdE5vZGU7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoaVJvb3Q7IGQgPj0gZGVwdGhpUGFyZW50OyBkLS0pIHtcbiAgICAgICAgbm9kZSA9IGlzTGVmdE5vZGUoZCwgaW5kZXgpID8gbm9kZS5sZWZ0IDogbm9kZS5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5leHBvcnRzLmdldE5vZGVBdERlcHRoID0gZ2V0Tm9kZUF0RGVwdGg7XG4vKipcbiAqIFN1cHBvcnRzIGluZGV4IHVwIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKi9cbmZ1bmN0aW9uIHNldE5vZGVBdERlcHRoKHJvb3ROb2RlLCBub2Rlc0RlcHRoLCBpbmRleCwgbm9kZUNoYW5nZWQpIHtcbiAgICAvLyBUT0RPOiBPUFRJTUlaRSAoaWYgbmVjZXNzYXJ5KVxuICAgIHJldHVybiBzZXROb2Rlc0F0RGVwdGgocm9vdE5vZGUsIG5vZGVzRGVwdGgsIFtpbmRleF0sIFtub2RlQ2hhbmdlZF0pO1xufVxuZXhwb3J0cy5zZXROb2RlQXREZXB0aCA9IHNldE5vZGVBdERlcHRoO1xuLyoqXG4gKiBTZXQgbXVsdGlwbGUgbm9kZXMgaW4gYmF0Y2gsIGVkaXRpbmcgYW5kIHRyYXZlcnNpbmcgbm9kZXMgc3RyaWN0bHkgb25jZS5cbiAqXG4gKiAtIGdpbmRleGVzIE1VU1QgYmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBiZWZvcmVoYW5kLlxuICogLSBBbGwgZ2luZGV4ZXMgbXVzdCBiZSBhdCB0aGUgZXhhY3Qgc2FtZSBkZXB0aC5cbiAqIC0gRGVwdGggbXVzdCBiZSA+IDAsIGlmIDAganVzdCByZXBsYWNlIHRoZSByb290IG5vZGUuXG4gKlxuICogU3RyYXRlZ3k6IGZvciBlYWNoIGdpbmRleCBpbiBgZ2luZGV4ZXNgIG5hdmlnYXRlIHRvIHRoZSBkZXB0aCBvZiBpdHMgcGFyZW50LFxuICogYW5kIGNyZWF0ZSBhIG5ldyBwYXJlbnQuIFRoZW4gY2FsY3VsYXRlIHRoZSBjbG9zZXN0IGNvbW1vbiBkZXB0aCB3aXRoIHRoZSBuZXh0XG4gKiBnaW5kZXggYW5kIG5hdmlnYXRlIHVwd2FyZHMgY3JlYXRpbmcgb3IgY2FjaGluZyBub2RlcyBhcyBuZWNlc3NhcnkuIExvb3AgYW5kIHJlcGVhdC5cbiAqXG4gKiBTdXBwb3J0cyBpbmRleCB1cCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICovXG5mdW5jdGlvbiBzZXROb2Rlc0F0RGVwdGgocm9vdE5vZGUsIG5vZGVzRGVwdGgsIGluZGV4ZXMsIG5vZGVzKSB7XG4gICAgLy8gZGVwdGggZGVwdGhpICAgZ2luZGV4ZXMgICBpbmRleGVzXG4gICAgLy8gMCAgICAgMSAgICAgICAgICAgMSAgICAgICAgICAwXG4gICAgLy8gMSAgICAgMCAgICAgICAgIDIgICAzICAgICAgMCAgIDFcbiAgICAvLyAyICAgICAtICAgICAgICA0IDUgNiA3ICAgIDAgMSAyIDNcbiAgICAvLyAnMTAnIG1lYW5zLCBhdCBkZXB0aCAxLCBub2RlIGlzIGF0IHRoZSBsZWZ0XG4gICAgLy9cbiAgICAvLyBGb3IgaW5kZXggTiBjaGVjayBpZiB0aGUgYml0IGF0IHBvc2l0aW9uIGRlcHRoaSBpcyBzZXQgdG8gbmF2aWdhdGUgcmlnaHQgYXQgZGVwdGhpXG4gICAgLy8gYGBgXG4gICAgLy8gbWFzayA9IDEgPDwgZGVwdGhpXG4gICAgLy8gZ29SaWdodCA9IChOICYgbWFzaykgPT0gbWFza1xuICAgIC8vIGBgYFxuICAgIC8vIElmIGRlcHRoIGlzIDAgdGhlcmUncyBvbmx5IG9uZSBub2RlIG1heCBhbmQgdGhlIG9wdGltaXphdGlvbiBiZWxvdyB3aWxsIGNhdXNlIGEgbmF2aWdhdGlvbiBlcnJvci5cbiAgICAvLyBGb3IgdGhpcyBjYXNlLCBjaGVjayBpZiB0aGVyZSdzIGEgbmV3IHJvb3Qgbm9kZSBhbmQgcmV0dXJuIGl0LCBvdGhlcndpc2UgdGhlIGN1cnJlbnQgcm9vdE5vZGUuXG4gICAgaWYgKG5vZGVzRGVwdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyBub2Rlc1swXSA6IHJvb3ROb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250aWd1b3VzIGZpbGxlZCBzdGFjayBvZiBwYXJlbnQgbm9kZXMuIEl0IGdldCBmaWxsZWQgaW4gdGhlIGZpcnN0IGRlc2NlbnRcbiAgICAgKiBJbmRleGVkIGJ5IGRlcHRoaVxuICAgICAqL1xuICAgIGNvbnN0IHBhcmVudE5vZGVTdGFjayA9IG5ldyBBcnJheShub2Rlc0RlcHRoKTtcbiAgICAvKipcbiAgICAgKiBUZW1wIHN0YWNrIG9mIGxlZnQgcGFyZW50IG5vZGVzLCBpbmRleCBieSBkZXB0aGkuXG4gICAgICogTm9kZSBsZWZ0UGFyZW50Tm9kZVN0YWNrW2RlcHRoaV0gaXMgYSBub2RlIGF0IGQgPSBkZXB0aGkgLSAxLCBzdWNoIHRoYXQ6XG4gICAgICogYGBgXG4gICAgICogcGFyZW50Tm9kZVN0YWNrW2RlcHRoaV0ubGVmdCA9IGxlZnRQYXJlbnROb2RlU3RhY2tbZGVwdGhpXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0IGxlZnRQYXJlbnROb2RlU3RhY2sgPSBuZXcgQXJyYXkobm9kZXNEZXB0aCk7XG4gICAgLy8gSWdub3JlIGZpcnN0IGJpdCBcIjFcIiwgdGhlbiBzdWJzdHJhY3QgMSB0byBnZXQgdG8gdGhlIHBhcmVudFxuICAgIGNvbnN0IGRlcHRoaVJvb3QgPSBub2Rlc0RlcHRoIC0gMTtcbiAgICBjb25zdCBkZXB0aGlQYXJlbnQgPSAwO1xuICAgIGxldCBkZXB0aGkgPSBkZXB0aGlSb290O1xuICAgIGxldCBub2RlID0gcm9vdE5vZGU7XG4gICAgLy8gSW5zZXJ0IHJvb3Qgbm9kZSB0byBtYWtlIHRoZSBsb29wIGJlbG93IGdlbmVyYWxcbiAgICBwYXJlbnROb2RlU3RhY2tbZGVwdGhpUm9vdF0gPSByb290Tm9kZTtcbiAgICAvLyBUT0RPOiBJdGVyYXRlIHRvIGRlcHRoIDMyIHRvIGFsbG93IHVzaW5nIGJpdCBvcHNcbiAgICAvLyBmb3IgKDsgZGVwdGhpID49IDMyOyBkZXB0aGktLSkge1xuICAgIC8vICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAvLyB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhlc1tpXTtcbiAgICAgICAgLy8gTmF2aWdhdGUgZG93biB1bnRpbCBwYXJlbnQgZGVwdGgsIGFuZCBzdG9yZSB0aGUgY2hhaW4gb2Ygbm9kZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gU3RhcnRzIGZyb20gbGF0ZXN0IGNvbW1vbiBkZXB0aCwgc28gbm9kZSBpcyB0aGUgcGFyZW50IG5vZGUgYXQgYGRlcHRoaWBcbiAgICAgICAgLy8gV2hlbiBwZXJzaXN0aW5nIHRoZSBuZXh0IG5vZGUsIHN0b3JlIGF0IHRoZSBgZCAtIDFgIHNpbmNlIGl0cyB0aGUgY2hpbGQgb2Ygbm9kZSBhdCBgZGVwdGhpYFxuICAgICAgICAvL1xuICAgICAgICAvLyBTdG9wcyBhdCB0aGUgbGV2ZWwgYWJvdmUgZGVwdGhpUGFyZW50LiBGb3IgdGhlIHJlLWJpbmRpbmcgcm91dGluZyBiZWxvdyBub2RlIG11c3QgYmUgYXQgZGVwdGhpUGFyZW50XG4gICAgICAgIGZvciAobGV0IGQgPSBkZXB0aGk7IGQgPiBkZXB0aGlQYXJlbnQ7IGQtLSkge1xuICAgICAgICAgICAgbm9kZSA9IGlzTGVmdE5vZGUoZCwgaW5kZXgpID8gbm9kZS5sZWZ0IDogbm9kZS5yaWdodDtcbiAgICAgICAgICAgIHBhcmVudE5vZGVTdGFja1tkIC0gMV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoaSA9IGRlcHRoaVBhcmVudDtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgbGVmdCBub2RlLCBjaGVjayBmaXJzdCBpdCB0aGUgbmV4dCBub2RlIGlzIG9uIHRoZSByaWdodFxuICAgICAgICAvL1xuICAgICAgICAvLyAgIC0gICAgSWYgYm90aCBub2RlcyBleGlzdCwgY3JlYXRlIG5ld1xuICAgICAgICAvLyAgLyBcXFxuICAgICAgICAvLyB4ICAgeFxuICAgICAgICAvL1xuICAgICAgICAvLyAgIC0gICAgSWYgb25seSB0aGUgbGVmdCBub2RlIGV4aXN0cywgcmViaW5kIGxlZnRcbiAgICAgICAgLy8gIC8gXFxcbiAgICAgICAgLy8geCAgIC1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAtICAgIElmIHRoaXMgaXMgdGhlIHJpZ2h0IG5vZGUsIG9ubHkgdGhlIHJpZ2h0IG5vZGUgZXhpc3RzLCByZWJpbmQgcmlnaHRcbiAgICAgICAgLy8gIC8gXFxcbiAgICAgICAgLy8gLSAgIHhcbiAgICAgICAgLy8gZCA9IDAsIG1hc2sgPSAxIDw8IGQgPSAxXG4gICAgICAgIGNvbnN0IGlzTGVmdExlYWZOb2RlID0gKGluZGV4ICYgMSkgIT09IDE7XG4gICAgICAgIGlmIChpc0xlZnRMZWFmTm9kZSkge1xuICAgICAgICAgICAgLy8gTmV4dCBub2RlIGlzIHRoZSB2ZXJ5IG5leHQgdG8gdGhlIHJpZ2h0IG9mIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gaW5kZXhlc1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKG5vZGVzW2ldLCBub2Rlc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgcG9pbnRlciBvbmUgZXh0cmEgZm9yd2FyZCBzaW5jZSBub2RlIGhhcyBjb25zdW1lZCB0d28gbm9kZXNcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKG5vZGVzW2ldLCBub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgbm9kZV8xLkJyYW5jaE5vZGUobm9kZS5sZWZ0LCBub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGVyZSBgbm9kZWAgaXMgdGhlIG5ldyBCcmFuY2hOb2RlIGF0IGRlcHRoaSBgZGVwdGhpUGFyZW50YFxuICAgICAgICAvLyBOb3cgY2xpbWIgdXB3YXJkcyB1bnRpbCBmaW5kaW5nIHRoZSBjb21tb24gbm9kZSB3aXRoIHRoZSBuZXh0IGluZGV4XG4gICAgICAgIC8vIEZvciB0aGUgbGFzdCBpdGVyYXRpb24sIGNsaW1iIHRvIHRoZSByb290IGF0IGBkZXB0aGlSb290YFxuICAgICAgICBjb25zdCBpc0xhc3RJbmRleCA9IGkgPj0gaW5kZXhlcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBkaWZmRGVwdGhpID0gaXNMYXN0SW5kZXggPyBkZXB0aGlSb290IDogZmluZERpZmZEZXB0aGkoaW5kZXgsIGluZGV4ZXNbaSArIDFdKTtcbiAgICAgICAgLy8gV2hlbiBjbGltYmluZyB1cCBmcm9tIGEgbGVmdCBub2RlIHRoZXJlIGFyZSB0d28gcG9zc2libGUgcGF0aHNcbiAgICAgICAgLy8gMS4gR28gdG8gdGhlIHJpZ2h0IG9mIHRoZSBwYXJlbnQ6IFN0b3JlIGxlZnQgbm9kZSB0byByZWJpbmQgbGF0dGVyXG4gICAgICAgIC8vIDIuIEdvIGFub3RoZXIgbGV2ZWwgdXA6IFdpbGwgbmV2ZXIgdmlzaXQgdGhlIGxlZnQgbm9kZSBhZ2Fpbiwgc28gbXVzdCByZWJpbmQgbm93XG4gICAgICAgIC8vIPCfobwgXFwgICAgIFJlYmluZCBsZWZ0IG9ubHksIHdpbGwgbmV2ZXIgdmlzaXQgdGhpcyBub2RlIGFnYWluXG4gICAgICAgIC8vIPCfob0gL1xcXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIC8g8J+hvSAgUmViaW5kIGxlZnQgb25seSAoc2FtZSBhcyBhYm92ZSlcbiAgICAgICAgLy8g8J+hvSAvXFxcbiAgICAgICAgLy9cbiAgICAgICAgLy8g8J+hvSAvXFwg8J+hviAgU3RvcmUgbGVmdCBub2RlIHRvIHJlYmluZCB0aGUgZW50aXJlIG5vZGUgd2hlbiByZXR1cm5pbmdcbiAgICAgICAgLy9cbiAgICAgICAgLy8g8J+hvCBcXCAgICAgUmViaW5kIHJpZ2h0IHdpdGggbGVmdCBpZiBleGlzdHMsIHdpbGwgbmV2ZXIgdmlzaXQgdGhpcyBub2RlIGFnYWluXG4gICAgICAgIC8vICAgL1xcIPCfobxcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgLyDwn6G9ICBSZWJpbmQgcmlnaHQgd2l0aCBsZWZ0IGlmIGV4aXN0cyAoc2FtZSBhcyBhYm92ZSlcbiAgICAgICAgLy8gICAvXFwg8J+hvFxuICAgICAgICBmb3IgKGxldCBkID0gZGVwdGhpUGFyZW50ICsgMTsgZCA8PSBkaWZmRGVwdGhpOyBkKyspIHtcbiAgICAgICAgICAgIC8vIElmIG5vZGUgaXMgb24gdGhlIGxlZnQsIHN0b3JlIGZvciBsYXR0ZXJcbiAgICAgICAgICAgIC8vIElmIG5vZGUgaXMgb24gdGhlIHJpZ2h0IG1lcmdlIHdpdGggc3RvcmVkIGxlZnQgbm9kZVxuICAgICAgICAgICAgaWYgKGlzTGVmdE5vZGUoZCwgaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdEluZGV4IHx8IGQgIT09IGRpZmZEZXB0aGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBsYXN0IGluZGV4LCBiaW5kIHdpdGggcGFyZW50IHNpbmNlIGl0IHdvbid0IG5hdmlnYXRlIHRvIHRoZSByaWdodCBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28sIGlmIHN0aWxsIGhhcyB0byBtb3ZlIHVwd2FyZHMsIHJlYmluZCBzaW5jZSB0aGUgbm9kZSB3b24ndCBiZSB2aXNpdGVkIGFueW1vcmVcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBub2RlXzEuQnJhbmNoTm9kZShub2RlLCBwYXJlbnROb2RlU3RhY2tbZF0ucmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdG9yZSB0aGUgbGVmdCBub2RlIGlmIGl0J3MgYXQgZCA9IGRpZmZEZXB0aFxuICAgICAgICAgICAgICAgICAgICBsZWZ0UGFyZW50Tm9kZVN0YWNrW2RdID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudE5vZGVTdGFja1tkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Tm9kZSA9IGxlZnRQYXJlbnROb2RlU3RhY2tbZF07XG4gICAgICAgICAgICAgICAgaWYgKGxlZnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBub2RlXzEuQnJhbmNoTm9kZShsZWZ0Tm9kZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRQYXJlbnROb2RlU3RhY2tbZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKHBhcmVudE5vZGVTdGFja1tkXS5sZWZ0LCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBuZXh0IGxvb3BcbiAgICAgICAgLy8gR28gdG8gdGhlIHBhcmVudCBvZiB0aGUgZGVwdGggd2l0aCBkaWZmLCB0byBzd2l0Y2ggYnJhbmNoZXMgdG8gdGhlIHJpZ2h0XG4gICAgICAgIGRlcHRoaSA9IGRpZmZEZXB0aGk7XG4gICAgfVxuICAgIC8vIERvbmUsIHJldHVybiBuZXcgcm9vdCBub2RlXG4gICAgcmV0dXJuIG5vZGU7XG59XG5leHBvcnRzLnNldE5vZGVzQXREZXB0aCA9IHNldE5vZGVzQXREZXB0aDtcbi8qKlxuICogRmFzdCByZWFkLW9ubHkgaXRlcmF0aW9uXG4gKiBJbi1vcmRlciB0cmF2ZXJzYWwgb2Ygbm9kZXMgYXQgYGRlcHRoYFxuICogc3RhcnRpbmcgZnJvbSB0aGUgYHN0YXJ0SW5kZXhgLWluZGV4ZWQgbm9kZVxuICogaXRlcmF0aW5nIHRocm91Z2ggYGNvdW50YCBub2Rlc1xuICpcbiAqICoqU3RyYXRlZ3kqKlxuICogMS4gTmF2aWdhdGUgZG93biB0byBwYXJlbnREZXB0aCBzdG9yaW5nIGEgc3RhY2sgb2YgcGFyZW50c1xuICogMi4gQXQgdGFyZ2V0IGxldmVsIHB1c2ggY3VycmVudCBub2RlXG4gKiAzLiBHbyB1cCB0byB0aGUgZmlyc3QgbGV2ZWwgdGhhdCBuYXZpZ2F0ZWQgbGVmdFxuICogNC4gUmVwZWF0ICgxKSBmb3IgbmV4dCBpbmRleFxuICovXG5mdW5jdGlvbiBnZXROb2Rlc0F0RGVwdGgocm9vdE5vZGUsIGRlcHRoLCBzdGFydEluZGV4LCBjb3VudCkge1xuICAgIC8vIE9wdGltaXplZCBwYXRocyBmb3Igc2hvcnQgdHJlZXMgKHgyMCB0aW1lcyBmYXN0ZXIpXG4gICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFydEluZGV4ID09PSAwICYmIGNvdW50ID4gMCA/IFtyb290Tm9kZV0gOiBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVwdGggPT09IDEpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEluZGV4ID09PSAwID8gW3Jvb3ROb2RlLmxlZnRdIDogW3Jvb3ROb2RlLnJpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcm9vdE5vZGUubGVmdCwgcm9vdE5vZGUucmlnaHRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElnbm9yZSBmaXJzdCBiaXQgXCIxXCIsIHRoZW4gc3Vic3RyYWN0IDEgdG8gZ2V0IHRvIHRoZSBwYXJlbnRcbiAgICBjb25zdCBkZXB0aGlSb290ID0gZGVwdGggLSAxO1xuICAgIGNvbnN0IGRlcHRoaVBhcmVudCA9IDA7XG4gICAgbGV0IGRlcHRoaSA9IGRlcHRoaVJvb3Q7XG4gICAgbGV0IG5vZGUgPSByb290Tm9kZTtcbiAgICAvLyBDb250aWd1b3VzIGZpbGxlZCBzdGFjayBvZiBwYXJlbnQgbm9kZXMuIEl0IGdldCBmaWxsZWQgaW4gdGhlIGZpcnN0IGRlc2NlbnRcbiAgICAvLyBJbmRleGVkIGJ5IGRlcHRoaVxuICAgIGNvbnN0IHBhcmVudE5vZGVTdGFjayA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgY29uc3QgaXNMZWZ0U3RhY2sgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGNvbnN0IG5vZGVzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAvLyBJbnNlcnQgcm9vdCBub2RlIHRvIG1ha2UgdGhlIGxvb3AgYmVsb3cgZ2VuZXJhbFxuICAgIHBhcmVudE5vZGVTdGFja1tkZXB0aGlSb290XSA9IHJvb3ROb2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gZGVwdGhpOyBkID49IGRlcHRoaVBhcmVudDsgZC0tKSB7XG4gICAgICAgICAgICBpZiAoZCAhPT0gZGVwdGhpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZVN0YWNrW2RdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTGVmdCA9IGlzTGVmdE5vZGUoZCwgc3RhcnRJbmRleCArIGkpO1xuICAgICAgICAgICAgaXNMZWZ0U3RhY2tbZF0gPSBpc0xlZnQ7XG4gICAgICAgICAgICBub2RlID0gaXNMZWZ0ID8gbm9kZS5sZWZ0IDogbm9kZS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBub2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGRlcHRoIHdoZXJlIG5hdmlnYXRpb24gd2hlbiBsZWZ0LlxuICAgICAgICAvLyBTdG9yZSB0aGF0IGhlaWdodCBhbmQgZ28gcmlnaHQgZnJvbSB0aGVyZVxuICAgICAgICBmb3IgKGxldCBkID0gZGVwdGhpUGFyZW50OyBkIDw9IGRlcHRoaVJvb3Q7IGQrKykge1xuICAgICAgICAgICAgaWYgKGlzTGVmdFN0YWNrW2RdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZGVwdGhpID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gcGFyZW50Tm9kZVN0YWNrW2RlcHRoaV07XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMuZ2V0Tm9kZXNBdERlcHRoID0gZ2V0Tm9kZXNBdERlcHRoO1xuLyoqXG4gKiBAc2VlIGdldE5vZGVzQXREZXB0aCBidXQgaW5zdGVhZCBvZiBwdXNoaW5nIHRvIGFuIGFycmF5LCBpdCB5aWVsZHNcbiAqL1xuZnVuY3Rpb24qIGl0ZXJhdGVOb2Rlc0F0RGVwdGgocm9vdE5vZGUsIGRlcHRoLCBzdGFydEluZGV4LCBjb3VudCkge1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGNvdW50O1xuICAgIC8vIElnbm9yZSBmaXJzdCBiaXQgXCIxXCIsIHRoZW4gc3Vic3RyYWN0IDEgdG8gZ2V0IHRvIHRoZSBwYXJlbnRcbiAgICBjb25zdCBkZXB0aGlSb290ID0gZGVwdGggLSAxO1xuICAgIGNvbnN0IGRlcHRoaVBhcmVudCA9IDA7XG4gICAgbGV0IGRlcHRoaSA9IGRlcHRoaVJvb3Q7XG4gICAgbGV0IG5vZGUgPSByb290Tm9kZTtcbiAgICAvLyBDb250aWd1b3VzIGZpbGxlZCBzdGFjayBvZiBwYXJlbnQgbm9kZXMuIEl0IGdldCBmaWxsZWQgaW4gdGhlIGZpcnN0IGRlc2NlbnRcbiAgICAvLyBJbmRleGVkIGJ5IGRlcHRoaVxuICAgIGNvbnN0IHBhcmVudE5vZGVTdGFjayA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgY29uc3QgaXNMZWZ0U3RhY2sgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIC8vIEluc2VydCByb290IG5vZGUgdG8gbWFrZSB0aGUgbG9vcCBiZWxvdyBnZW5lcmFsXG4gICAgcGFyZW50Tm9kZVN0YWNrW2RlcHRoaVJvb3RdID0gcm9vdE5vZGU7XG4gICAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IGVuZEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGZvciAobGV0IGQgPSBkZXB0aGk7IGQgPj0gZGVwdGhpUGFyZW50OyBkLS0pIHtcbiAgICAgICAgICAgIGlmIChkICE9PSBkZXB0aGkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlU3RhY2tbZF0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNMZWZ0ID0gaXNMZWZ0Tm9kZShkLCBpbmRleCk7XG4gICAgICAgICAgICBpc0xlZnRTdGFja1tkXSA9IGlzTGVmdDtcbiAgICAgICAgICAgIG5vZGUgPSBpc0xlZnQgPyBub2RlLmxlZnQgOiBub2RlLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGRlcHRoIHdoZXJlIG5hdmlnYXRpb24gd2hlbiBsZWZ0LlxuICAgICAgICAvLyBTdG9yZSB0aGF0IGhlaWdodCBhbmQgZ28gcmlnaHQgZnJvbSB0aGVyZVxuICAgICAgICBmb3IgKGxldCBkID0gZGVwdGhpUGFyZW50OyBkIDw9IGRlcHRoaVJvb3Q7IGQrKykge1xuICAgICAgICAgICAgaWYgKGlzTGVmdFN0YWNrW2RdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZGVwdGhpID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gcGFyZW50Tm9kZVN0YWNrW2RlcHRoaV07XG4gICAgfVxufVxuZXhwb3J0cy5pdGVyYXRlTm9kZXNBdERlcHRoID0gaXRlcmF0ZU5vZGVzQXREZXB0aDtcbi8qKlxuICogWmVybydzIGFsbCBub2RlcyByaWdodCBvZiBpbmRleCB3aXRoIGNvbnN0YW50IGRlcHRoIG9mIGBub2Rlc0RlcHRoYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgemVyby1pbmcgdGhpcyB0cmVlIGF0IGRlcHRoIDIgYWZ0ZXIgaW5kZXggMFxuICogYGBgXG4gKiAgICBYICAgICAgICAgICAgICBYXG4gKiAgWCAgIFggICAgLT4gICAgWCAgIDBcbiAqIFggWCBYIFggICAgICAgIFggMCAwIDBcbiAqIGBgYFxuICpcbiAqIE9yLCB6ZXJvLWluZyB0aGlzIHRyZWUgYXQgZGVwdGggMyBhZnRlciBpbmRleCAyXG4gKiBgYGBcbiAqICAgICAgICBYICAgICAgICAgICAgICAgICAgICAgWFxuICogICAgWCAgICAgICBYICAgICAgICAgICAgIFggICAgICAgMFxuICogIFggICBYICAgWCAgIFggICAgLT4gICBYICAgWCAgIDAgICAwXG4gKiBYIFggWCBYIFggWCBYIFggICAgICAgWCBYIFggMCAwIDAgMCAwXG4gKiBgYGBcbiAqXG4gKiBUaGUgc3RyYXRlZ3kgaXMgdG8gZmlyc3QgbmF2aWdhdGUgZG93biB0byBgbm9kZXNEZXB0aGAgYW5kIGBpbmRleGAgYW5kIGtlZXAgYSBzdGFjayBvZiBwYXJlbnRzLlxuICogVGhlbiBuYXZpZ2F0ZSB1cCByZS1iaW5kaW5nOlxuICogLSBJZiBuYXZpZ2F0ZWQgdG8gdGhlIGxlZnQgcmViaW5kIHdpdGggemVyb05vZGUoKVxuICogLSBJZiBuYXZpZ2F0ZWQgdG8gdGhlIHJpZ2h0IHJlYmluZCB3aXRoIHBhcmVudC5sZWZ0IGZyb20gdGhlIHN0YWNrXG4gKi9cbmZ1bmN0aW9uIHRyZWVaZXJvQWZ0ZXJJbmRleChyb290Tm9kZSwgbm9kZXNEZXB0aCwgaW5kZXgpIHtcbiAgICAvLyBkZXB0aCBkZXB0aGkgICBnaW5kZXhlcyAgIGluZGV4ZXNcbiAgICAvLyAwICAgICAxICAgICAgICAgICAxICAgICAgICAgIDBcbiAgICAvLyAxICAgICAwICAgICAgICAgMiAgIDMgICAgICAwICAgMVxuICAgIC8vIDIgICAgIC0gICAgICAgIDQgNSA2IDcgICAgMCAxIDIgM1xuICAgIC8vICcxMCcgbWVhbnMsIGF0IGRlcHRoIDEsIG5vZGUgaXMgYXQgdGhlIGxlZnRcbiAgICAvL1xuICAgIC8vIEZvciBpbmRleCBOIGNoZWNrIGlmIHRoZSBiaXQgYXQgcG9zaXRpb24gZGVwdGhpIGlzIHNldCB0byBuYXZpZ2F0ZSByaWdodCBhdCBkZXB0aGlcbiAgICAvLyBgYGBcbiAgICAvLyBtYXNrID0gMSA8PCBkZXB0aGlcbiAgICAvLyBnb1JpZ2h0ID0gKE4gJiBtYXNrKSA9PSBtYXNrXG4gICAgLy8gYGBgXG4gICAgLy8gRGVnZW5lcmF0ZSBjYXNlIHdoZXJlIHRyZWUgaXMgemVybyBhZnRlciBhIG5lZ2F0aXZlIGluZGV4ICgtMSkuXG4gICAgLy8gQWxsIHBvc2l0aXZlIGluZGV4ZXMgYXJlIHplcm8sIHNvIHRoZSBlbnRpcmUgdHJlZSBpcyB6ZXJvLiBSZXR1cm4gY2FjaGVkIHplcm8gbm9kZSBhcyByb290LlxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHplcm9Ob2RlXzEuemVyb05vZGUobm9kZXNEZXB0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRpZ3VvdXMgZmlsbGVkIHN0YWNrIG9mIHBhcmVudCBub2Rlcy4gSXQgZ2V0IGZpbGxlZCBpbiB0aGUgZmlyc3QgZGVzY2VudFxuICAgICAqIEluZGV4ZWQgYnkgZGVwdGhpXG4gICAgICovXG4gICAgY29uc3QgcGFyZW50Tm9kZVN0YWNrID0gbmV3IEFycmF5KG5vZGVzRGVwdGgpO1xuICAgIC8vIElnbm9yZSBmaXJzdCBiaXQgXCIxXCIsIHRoZW4gc3Vic3RyYWN0IDEgdG8gZ2V0IHRvIHRoZSBwYXJlbnRcbiAgICBjb25zdCBkZXB0aGlSb290ID0gbm9kZXNEZXB0aCAtIDE7XG4gICAgY29uc3QgZGVwdGhpUGFyZW50ID0gMDtcbiAgICBsZXQgZGVwdGhpID0gZGVwdGhpUm9vdDtcbiAgICBsZXQgbm9kZSA9IHJvb3ROb2RlO1xuICAgIC8vIEluc2VydCByb290IG5vZGUgdG8gbWFrZSB0aGUgbG9vcCBiZWxvdyBnZW5lcmFsXG4gICAgcGFyZW50Tm9kZVN0YWNrW2RlcHRoaVJvb3RdID0gcm9vdE5vZGU7XG4gICAgLy8gTmF2aWdhdGUgZG93biB1bnRpbCBwYXJlbnQgZGVwdGgsIGFuZCBzdG9yZSB0aGUgY2hhaW4gb2Ygbm9kZXNcbiAgICAvL1xuICAgIC8vIFN0b3BzIGF0IHRoZSBkZXB0aGlQYXJlbnQgbGV2ZWwuIFRvIHJlYmluZCBiZWxvdyBkb3duIHRvIGBub2Rlc0RlcHRoYFxuICAgIGZvciAobGV0IGQgPSBkZXB0aGk7IGQgPj0gZGVwdGhpUGFyZW50OyBkLS0pIHtcbiAgICAgICAgbm9kZSA9IGlzTGVmdE5vZGUoZCwgaW5kZXgpID8gbm9kZS5sZWZ0IDogbm9kZS5yaWdodDtcbiAgICAgICAgcGFyZW50Tm9kZVN0YWNrW2QgLSAxXSA9IG5vZGU7XG4gICAgfVxuICAgIGRlcHRoaSA9IGRlcHRoaVBhcmVudDtcbiAgICAvLyBOb3cgY2xpbWIgdXAgcmUtYmluZGluZyB3aXRoIGVpdGhlciB6ZXJvIG9mIGV4aXN0aW5nIHRyZWUuXG4gICAgZm9yIChsZXQgZCA9IGRlcHRoaVBhcmVudDsgZCA8PSBkZXB0aGlSb290OyBkKyspIHtcbiAgICAgICAgaWYgKGlzTGVmdE5vZGUoZCwgaW5kZXgpKSB7XG4gICAgICAgICAgICAvLyBJZiBuYXZpZ2F0ZWQgdG8gdGhlIGxlZnQsIHRoZW4gYWxsIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgcmlnaHQgbm9kZSBhcmUgTk9UIHBhcnQgb2YgdGhlIG5ldyB0cmVlLlxuICAgICAgICAgICAgLy8gU28gcmUtYmluZCBuZXcgYG5vZGVgIHdpdGggYSB6ZXJvTm9kZSBhdCB0aGUgY3VycmVudCBkZXB0aC5cbiAgICAgICAgICAgIG5vZGUgPSBuZXcgbm9kZV8xLkJyYW5jaE5vZGUobm9kZSwgemVyb05vZGVfMS56ZXJvTm9kZShkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBuYXZpZ2F0ZWQgdG8gdGhlIHJpZ2h0LCB0aGVuIGFsbCB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGxlZnQgbm9kZSBhcmUgcGFydCBvZiB0aGUgbmV3IHRyZWUuXG4gICAgICAgICAgICAvLyBTbyByZS1iaW5kIG5ldyBgbm9kZWAgd2l0aCB0aGUgZXhpc3RpbmcgbGVmdCBub2RlIG9mIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICBub2RlID0gbmV3IG5vZGVfMS5CcmFuY2hOb2RlKHBhcmVudE5vZGVTdGFja1tkXS5sZWZ0LCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEb25lLCByZXR1cm4gbmV3IHJvb3Qgbm9kZVxuICAgIHJldHVybiBub2RlO1xufVxuZXhwb3J0cy50cmVlWmVyb0FmdGVySW5kZXggPSB0cmVlWmVyb0FmdGVySW5kZXg7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGluZGV4YCBhdCBgZGVwdGhgIGlzIGEgbGVmdCBub2RlLCBmYWxzZSBpZiBpdCBpcyBhIHJpZ2h0IG5vZGUuXG4gKlxuICogU3VwcG9ydHMgaW5kZXggdXAgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqIEluIEV0aDIgY2FzZSB0aGUgYmlnZ2VzdCB0cmVlJ3MgaW5kZXggaXMgMioqNDAgKFZBTElEQVRPUl9SRUdJU1RSWV9MSU1JVClcbiAqL1xuZnVuY3Rpb24gaXNMZWZ0Tm9kZShkZXB0aGksIGluZGV4KSB7XG4gICAgaWYgKGRlcHRoaSA+IDMxKSB7XG4gICAgICAgIC8vIEphdmFzY3JpcHQgY2FuIG9ubHkgZG8gYml0d2lzZSBvcHMgd2l0aCAzMiBiaXQgbnVtYmVycy5cbiAgICAgICAgLy8gU2hpZnRpbmcgbGVmdCAxIGJ5IDMyIHdyYXBzIGFyb3VuZCBhbmQgYmVjb21lcyAxLlxuICAgICAgICAvLyBHZXQgdGhlIGhpZ2ggcGFydCBvZiBgaW5kZXhgIGFuZCBhZGp1c3QgZGVwdGhpXG4gICAgICAgIGNvbnN0IGluZGV4SGkgPSAoaW5kZXggLyAyICoqIDMyKSA+Pj4gMDtcbiAgICAgICAgY29uc3QgbWFzayA9IDEgPDwgKGRlcHRoaSAtIDMyKTtcbiAgICAgICAgcmV0dXJuIChpbmRleEhpICYgbWFzaykgIT09IG1hc2s7XG4gICAgfVxuICAgIGNvbnN0IG1hc2sgPSAxIDw8IGRlcHRoaTtcbiAgICByZXR1cm4gKGluZGV4ICYgbWFzaykgIT09IG1hc2s7XG59XG4vKipcbiAqIGRlcHRoIGRlcHRoaSAgIGdpbmRleGVzICAgaW5kZXhlc1xuICogMCAgICAgMSAgICAgICAgICAgMSAgICAgICAgICAwXG4gKiAxICAgICAwICAgICAgICAgMiAgIDMgICAgICAwICAgMVxuICogMiAgICAgLSAgICAgICAgNCA1IDYgNyAgICAwIDEgMiAzXG4gKlxuICogKipDb25kaXRpb25zKio6XG4gKiAtIGBmcm9tYCBhbmQgYHRvYCBtdXN0IG5vdCBiZSBlcXVhbFxuICpcbiAqIEBwYXJhbSBmcm9tIEluZGV4XG4gKiBAcGFyYW0gdG8gSW5kZXhcbiAqL1xuZnVuY3Rpb24gZmluZERpZmZEZXB0aGkoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKFxuICAgIC8vICgwLDApIC0+IDAgfCAoMCwxKSAtPiAxIHwgKDAsMikgLT4gMlxuICAgIE1hdGguY2VpbChNYXRoLmxvZzIoLX4oZnJvbSBeIHRvKSkpIC1cbiAgICAgICAgLy8gTXVzdCBvZmZzZXQgYnkgb25lIHRvIG1hdGNoIHRoZSBkZXB0aGkgc2NhbGVcbiAgICAgICAgMSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuemVyb05vZGUgPSB2b2lkIDA7XG5jb25zdCBub2RlXzEgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuY29uc3QgemVyb2VzID0gW25vZGVfMS5MZWFmTm9kZS5mcm9tWmVybygpXTtcbi8qKlxuICogUmV0dXJuIHRoZSBgTm9kZWAgYXQgYSBzcGVjaWZpZWQgaGVpZ2h0IGZyb20gdGhlIG1lcmtsZSB0cmVlIG1hZGUgb2YgXCJ6ZXJvIGRhdGFcIlxuICogYGBgXG4gKiAgICAgICAgICAgLi4uXG4gKiAgICAgICAgICAvXG4gKiAgICAgICAgIHggICAgICAgICAgIDwtIGhlaWdodCAyXG4gKiAgICAgIC8gICAgIFxcXG4gKiAgICAgeCAgICAgICB4ICAgICAgIDwtIGhlaWdodCAxXG4gKiAgIC8gIFxcICAgICAgLyAgXFxcbiAqIDB4MCAgMHgwICAweDAgIDB4MCAgPC0gaGVpZ2h0IDBcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB6ZXJvTm9kZShoZWlnaHQpIHtcbiAgICBpZiAoaGVpZ2h0ID49IHplcm9lcy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHplcm9lcy5sZW5ndGg7IGkgPD0gaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgIHplcm9lc1tpXSA9IG5ldyBub2RlXzEuQnJhbmNoTm9kZSh6ZXJvZXNbaSAtIDFdLCB6ZXJvZXNbaSAtIDFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gemVyb2VzW2hlaWdodF07XG59XG5leHBvcnRzLnplcm9Ob2RlID0gemVyb05vZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJhbmNoTm9kZVN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWVcIik7XG4vKipcbiAqIEJyYW5jaE5vZGUgd2hvc2UgY2hpbGRyZW4ncyBkYXRhIGlzIHJlcHJlc2VudGVkIGFzIGEgc3RydWN0LCBub3QgYSB0cmVlLlxuICpcbiAqIFRoaXMgYXBwcm9hY2ggaXMgdXNlZnVsbCBmb3IgbWVtb3J5IGVmZmljaWVuY3kgb2YgZGF0YSB0aGF0IGlzIG5vdCBtb2RpZmllZCBvZnRlbiwgZm9yIGV4YW1wbGUgdGhlIHZhbGlkYXRvcnNcbiAqIHJlZ2lzdHJ5IGluIEV0aGVyZXVtIGNvbnNlbnN1cyBgc3RhdGUudmFsaWRhdG9yc2AuIFRoZSB0cmFkZW9mZiBpcyB0aGF0IGdldHRpbmcgdGhlIGhhc2gsIGFyZSBwcm9vZnMgaXMgbW9yZVxuICogZXhwZW5zaXZlIGJlY2F1c2UgdGhlIHRyZWUgaGFzIHRvIGJlIHJlY3JlYXRlZCBldmVyeSB0aW1lLlxuICovXG5jbGFzcyBCcmFuY2hOb2RlU3RydWN0IGV4dGVuZHMgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLk5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlVG9Ob2RlLCB2YWx1ZSkge1xuICAgICAgICAvLyBGaXJzdCBudWxsIHZhbHVlIGlzIHRvIHNhdmUgYW4gZXh0cmEgdmFyaWFibGUgdG8gY2hlY2sgaWYgYSBub2RlIGhhcyBhIHJvb3Qgb3Igbm90XG4gICAgICAgIHN1cGVyKG51bGwsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLnZhbHVlVG9Ob2RlID0gdmFsdWVUb05vZGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJvb3RIYXNoT2JqZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5oMCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMudmFsdWVUb05vZGUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBzdXBlci5hcHBseUhhc2gobm9kZS5yb290SGFzaE9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCByb290KCkge1xuICAgICAgICByZXR1cm4gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmhhc2hPYmplY3RUb1VpbnQ4QXJyYXkodGhpcy5yb290SGFzaE9iamVjdCk7XG4gICAgfVxuICAgIGlzTGVhZigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUb05vZGUodGhpcy52YWx1ZSkubGVmdDtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVRvTm9kZSh0aGlzLnZhbHVlKS5yaWdodDtcbiAgICB9XG59XG5leHBvcnRzLkJyYW5jaE5vZGVTdHJ1Y3QgPSBCcmFuY2hOb2RlU3RydWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJhbmNoTm9kZVN0cnVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaDY0ID0gZXhwb3J0cy5ieXRlQXJyYXlFcXVhbHMgPSBleHBvcnRzLnRvSGV4U3RyaW5nID0gZXhwb3J0cy5mcm9tSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRVaW50OEJ5dGVUb0JpdEJvb2xlYW5BcnJheSA9IGV4cG9ydHMuQml0QXJyYXkgPSBleHBvcnRzLlRyZWVWaWV3RFUgPSBleHBvcnRzLlRyZWVWaWV3ID0gZXhwb3J0cy5pc0NvbXBvc2l0ZVR5cGUgPSBleHBvcnRzLkNvbXBvc2l0ZVR5cGUgPSBleHBvcnRzLmlzQmFzaWNUeXBlID0gZXhwb3J0cy5CYXNpY1R5cGUgPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLkJ5dGVBcnJheVR5cGUgPSBleHBvcnRzLkJpdEFycmF5VHlwZSA9IGV4cG9ydHMuQXJyYXlUeXBlID0gZXhwb3J0cy5WZWN0b3JDb21wb3NpdGVUeXBlID0gZXhwb3J0cy5WZWN0b3JCYXNpY1R5cGUgPSBleHBvcnRzLlVuaW9uVHlwZSA9IGV4cG9ydHMuVWludE51bWJlclR5cGUgPSBleHBvcnRzLlVpbnRCaWdpbnRUeXBlID0gZXhwb3J0cy5Ob25lVHlwZSA9IGV4cG9ydHMuTGlzdENvbXBvc2l0ZVR5cGUgPSBleHBvcnRzLkxpc3RCYXNpY1R5cGUgPSBleHBvcnRzLkNvbnRhaW5lck5vZGVTdHJ1Y3RUeXBlID0gZXhwb3J0cy5Db250YWluZXJUeXBlID0gZXhwb3J0cy5CeXRlVmVjdG9yVHlwZSA9IGV4cG9ydHMuQnl0ZUxpc3RUeXBlID0gZXhwb3J0cy5Cb29sZWFuVHlwZSA9IGV4cG9ydHMuQml0VmVjdG9yVHlwZSA9IGV4cG9ydHMuQml0TGlzdFR5cGUgPSB2b2lkIDA7XG4vLyBUeXBlc1xudmFyIGJpdExpc3RfMSA9IHJlcXVpcmUoXCIuL3R5cGUvYml0TGlzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpdExpc3RUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaXRMaXN0XzEuQml0TGlzdFR5cGU7IH0gfSk7XG52YXIgYml0VmVjdG9yXzEgPSByZXF1aXJlKFwiLi90eXBlL2JpdFZlY3RvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpdFZlY3RvclR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpdFZlY3Rvcl8xLkJpdFZlY3RvclR5cGU7IH0gfSk7XG52YXIgYm9vbGVhbl8xID0gcmVxdWlyZShcIi4vdHlwZS9ib29sZWFuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQm9vbGVhblR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvb2xlYW5fMS5Cb29sZWFuVHlwZTsgfSB9KTtcbnZhciBieXRlTGlzdF8xID0gcmVxdWlyZShcIi4vdHlwZS9ieXRlTGlzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ5dGVMaXN0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZUxpc3RfMS5CeXRlTGlzdFR5cGU7IH0gfSk7XG52YXIgYnl0ZVZlY3Rvcl8xID0gcmVxdWlyZShcIi4vdHlwZS9ieXRlVmVjdG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnl0ZVZlY3RvclR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVWZWN0b3JfMS5CeXRlVmVjdG9yVHlwZTsgfSB9KTtcbnZhciBjb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL3R5cGUvY29udGFpbmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udGFpbmVyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGFpbmVyXzEuQ29udGFpbmVyVHlwZTsgfSB9KTtcbnZhciBjb250YWluZXJOb2RlU3RydWN0XzEgPSByZXF1aXJlKFwiLi90eXBlL2NvbnRhaW5lck5vZGVTdHJ1Y3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250YWluZXJOb2RlU3RydWN0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGFpbmVyTm9kZVN0cnVjdF8xLkNvbnRhaW5lck5vZGVTdHJ1Y3RUeXBlOyB9IH0pO1xudmFyIGxpc3RCYXNpY18xID0gcmVxdWlyZShcIi4vdHlwZS9saXN0QmFzaWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0QmFzaWNUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0QmFzaWNfMS5MaXN0QmFzaWNUeXBlOyB9IH0pO1xudmFyIGxpc3RDb21wb3NpdGVfMSA9IHJlcXVpcmUoXCIuL3R5cGUvbGlzdENvbXBvc2l0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpc3RDb21wb3NpdGVUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0Q29tcG9zaXRlXzEuTGlzdENvbXBvc2l0ZVR5cGU7IH0gfSk7XG52YXIgbm9uZV8xID0gcmVxdWlyZShcIi4vdHlwZS9ub25lXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vbmVfMS5Ob25lVHlwZTsgfSB9KTtcbnZhciB1aW50XzEgPSByZXF1aXJlKFwiLi90eXBlL3VpbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50QmlnaW50VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludF8xLlVpbnRCaWdpbnRUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludE51bWJlclR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVpbnRfMS5VaW50TnVtYmVyVHlwZTsgfSB9KTtcbnZhciB1bmlvbl8xID0gcmVxdWlyZShcIi4vdHlwZS91bmlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaW9uVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pb25fMS5VbmlvblR5cGU7IH0gfSk7XG52YXIgdmVjdG9yQmFzaWNfMSA9IHJlcXVpcmUoXCIuL3R5cGUvdmVjdG9yQmFzaWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZWN0b3JCYXNpY1R5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlY3RvckJhc2ljXzEuVmVjdG9yQmFzaWNUeXBlOyB9IH0pO1xudmFyIHZlY3RvckNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4vdHlwZS92ZWN0b3JDb21wb3NpdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZWN0b3JDb21wb3NpdGVUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2ZWN0b3JDb21wb3NpdGVfMS5WZWN0b3JDb21wb3NpdGVUeXBlOyB9IH0pO1xuLy8gQmFzZSB0eXBlc1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi90eXBlL2FycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXJyYXlUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcnJheV8xLkFycmF5VHlwZTsgfSB9KTtcbnZhciBiaXRBcnJheV8xID0gcmVxdWlyZShcIi4vdHlwZS9iaXRBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpdEFycmF5VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYml0QXJyYXlfMS5CaXRBcnJheVR5cGU7IH0gfSk7XG52YXIgYnl0ZUFycmF5XzEgPSByZXF1aXJlKFwiLi90eXBlL2J5dGVBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ5dGVBcnJheVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVBcnJheV8xLkJ5dGVBcnJheVR5cGU7IH0gfSk7XG4vLyBCYXNlIHR5cGUgY2xhc2VzXG52YXIgYWJzdHJhY3RfMSA9IHJlcXVpcmUoXCIuL3R5cGUvYWJzdHJhY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF8xLlR5cGU7IH0gfSk7XG52YXIgYmFzaWNfMSA9IHJlcXVpcmUoXCIuL3R5cGUvYmFzaWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNpY1R5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2ljXzEuQmFzaWNUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCYXNpY1R5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2ljXzEuaXNCYXNpY1R5cGU7IH0gfSk7XG52YXIgY29tcG9zaXRlXzEgPSByZXF1aXJlKFwiLi90eXBlL2NvbXBvc2l0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbXBvc2l0ZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2l0ZV8xLkNvbXBvc2l0ZVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbXBvc2l0ZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2l0ZV8xLmlzQ29tcG9zaXRlVHlwZTsgfSB9KTtcbnZhciBhYnN0cmFjdF8yID0gcmVxdWlyZShcIi4vdmlldy9hYnN0cmFjdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyZWVWaWV3XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF8yLlRyZWVWaWV3OyB9IH0pO1xudmFyIGFic3RyYWN0XzMgPSByZXF1aXJlKFwiLi92aWV3RFUvYWJzdHJhY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmVlVmlld0RVXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF8zLlRyZWVWaWV3RFU7IH0gfSk7XG4vLyBWYWx1ZXNcbnZhciBiaXRBcnJheV8yID0gcmVxdWlyZShcIi4vdmFsdWUvYml0QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaXRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYml0QXJyYXlfMi5CaXRBcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaXRBcnJheV8yLmdldFVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5OyB9IH0pO1xuLy8gVXRpbHNcbnZhciBieXRlQXJyYXlfMiA9IHJlcXVpcmUoXCIuL3V0aWwvYnl0ZUFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbUhleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZUFycmF5XzIuZnJvbUhleFN0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvSGV4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlQXJyYXlfMi50b0hleFN0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVBcnJheUVxdWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZUFycmF5XzIuYnl0ZUFycmF5RXF1YWxzOyB9IH0pO1xudmFyIG1lcmtsZWl6ZV8xID0gcmVxdWlyZShcIi4vdXRpbC9tZXJrbGVpemVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNoNjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lcmtsZWl6ZV8xLmhhc2g2NDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlID0gdm9pZCAwO1xuLyoqXG4gKiBBbiBTU1ogdHlwZSBwcm92aWRlcyB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gKiAtIFNlcmlhbGl6YXRpb24gZnJvbS90byBieXRlcyB0byBlaXRoZXIgYSB2YWx1ZSBvciBhIHRyZWVcbiAqIC0gTWVya2VsaXphdGlvbiB0byBjb21wdXRlIHRoZSBoYXNoVHJlZVJvb3Qgb2YgYm90aCBhIHZhbHVlIGFuZCBhIHRyZWVcbiAqIC0gUHJvb2YgY3JlYXRpb24gZnJvbSB0cmVlc1xuICogLSBDcmVhdGUgYSBWaWV3IGFuZCBhIFZpZXdEVSBpbnN0YW5jZSBmcm9tIGEgdHJlZVxuICogLSBNYW5pcHVsYXRlIHZpZXdzXG4gKi9cbmNsYXNzIFR5cGUge1xuICAgIC8qKiBJTlRFUk5BTCBNRVRIT0Q6IE1lcmtsZWl6ZSB2YWx1ZSB0byB0cmVlICovXG4gICAgdmFsdWVfdG9UcmVlKHZhbHVlKSB7XG4gICAgICAgIC8vIFRPRE86IFVuLXBlcmZvcm1hbnQgcGF0aCBidXQgdXNlZnVsIGZvciBwcm90b3R5cGluZy4gT3ZlcndyaXRlIGluIFR5cGUgaWYgcGVyZm9ybWFuY2UgaXMgaW1wb3J0YW50XG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFsdWVfc2VyaWFsaXplVG9CeXRlcyh7IHVpbnQ4QXJyYXksIGRhdGFWaWV3IH0sIDAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyh7IHVpbnQ4QXJyYXksIGRhdGFWaWV3IH0sIDAsIHVpbnQ4QXJyYXkubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqIElOVEVSTkFMIE1FVEhPRDogVW4tbWVya2xlaXplIHRyZWUgdG8gdmFsdWUgKi9cbiAgICB0cmVlX3RvVmFsdWUobm9kZSkge1xuICAgICAgICAvLyBUT0RPOiBVbi1wZXJmb3JtYW50IHBhdGggYnV0IHVzZWZ1bCBmb3IgcHJvdG90eXBpbmcuIE92ZXJ3cml0ZSBpbiBUeXBlIGlmIHBlcmZvcm1hbmNlIGlzIGltcG9ydGFudFxuICAgICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy50cmVlX3NlcmlhbGl6ZWRTaXplKG5vZGUpKTtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodWludDhBcnJheS5idWZmZXIsIHVpbnQ4QXJyYXkuYnl0ZU9mZnNldCwgdWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy50cmVlX3NlcmlhbGl6ZVRvQnl0ZXMoeyB1aW50OEFycmF5LCBkYXRhVmlldyB9LCAwLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoeyB1aW50OEFycmF5LCBkYXRhVmlldyB9LCAwLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKiBTZXJpYWxpemUgYSB2YWx1ZSB0byBiaW5hcnkgZGF0YSAqL1xuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZV9zZXJpYWxpemVkU2l6ZSh2YWx1ZSkpO1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyh1aW50OEFycmF5LmJ1ZmZlciwgdWludDhBcnJheS5ieXRlT2Zmc2V0LCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXMoeyB1aW50OEFycmF5LCBkYXRhVmlldyB9LCAwLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5O1xuICAgIH1cbiAgICAvKiogRGVzZXJpYWxpemUgYmluYXJ5IGRhdGEgdG8gdmFsdWUgKi9cbiAgICBkZXNlcmlhbGl6ZSh1aW50OEFycmF5KSB7XG4gICAgICAgIC8vIEJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgZG9lcyBub3QgY29weSBtZW1vcnksIGZvcmNlIHVzZSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzI4MDg3XG4gICAgICAgIC8vIC0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2U6IENvcHkgbWVtb3J5LCBzYWZlIHRvIG11dGF0ZVxuICAgICAgICAvLyAtIEJ1ZmZlci5wcm90b3R5cGUuc2xpY2U6IERvZXMgTk9UIGNvcHkgbWVtb3J5LCBtdXRhdGlvbiBhZmZlY3RzIGJvdGggdmlld3NcbiAgICAgICAgLy8gV2UgY291bGQgZW5zdXJlIHRoYXQgYWxsIEJ1ZmZlciBpbnN0YW5jZXMgYXJlIGNvbnZlcnRlZCB0byBVaW50OEFycmF5IGJlZm9yZSBjYWxsaW5nIHZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzXG4gICAgICAgIC8vIEhvd2V2ZXIgZG9pbmcgdGhhdCBpbiBhIGJyb3dzZXIgZnJpZW5kbHkgd2F5IGlzIG5vdCBlYXN5LiBEb3duc3RyZWFtIGNvZGUgdXNlcyBgVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbGBcbiAgICAgICAgLy8gdG8gZW5zdXJlIEJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbmV2ZXIgdXNlZC4gVW5pdCB0ZXN0cyBhbHNvIHRlc3Qgbm9uLW11dGFiaWxpdHkuXG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKHsgdWludDhBcnJheSwgZGF0YVZpZXcgfSwgMCwgdWludDhBcnJheS5sZW5ndGgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXJyYXlUeXBlID0gdm9pZCAwO1xuY29uc3QgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZVwiKTtcbmNvbnN0IGNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4vY29tcG9zaXRlXCIpO1xuY29uc3QgYXJyYXlCYXNpY18xID0gcmVxdWlyZShcIi4vYXJyYXlCYXNpY1wiKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmcgKi9cbi8qKlxuICogQXJyYXk6IG9yZGVyZWQgaG9tb2dlbmVvdXMgY29sbGVjdGlvblxuICovXG5jbGFzcyBBcnJheVR5cGUgZXh0ZW5kcyBjb21wb3NpdGVfMS5Db21wb3NpdGVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50VHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGU7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5QmFzaWNfMS52YWx1ZV9kZWZhdWx0VmFsdWVBcnJheSh0aGlzLmVsZW1lbnRUeXBlLCB0aGlzLmRlZmF1bHRMZW4pO1xuICAgIH1cbiAgICAvLyBQcm9vZnNcbiAgICBnZXRQcm9wZXJ0eVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRUeXBlO1xuICAgIH1cbiAgICBnZXRQcm9wZXJ0eUdpbmRleChwcm9wKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgYXJyYXkgaW5kZXg6ICR7cHJvcH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVua0lkeCA9IE1hdGguZmxvb3IocHJvcCAvIHRoaXMuaXRlbXNQZXJDaHVuayk7XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEudG9HaW5kZXgodGhpcy5kZXB0aCwgQmlnSW50KGNodW5rSWR4KSk7XG4gICAgfVxuICAgIGdldEluZGV4UHJvcGVydHkoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICB0cmVlX2dldExlYWZHaW5kaWNlcyhyb290R2luZGV4LCByb290Tm9kZSkge1xuICAgICAgICBsZXQgbGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5pc0xpc3QpIHtcbiAgICAgICAgICAgIGlmICghcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaXN0IHR5cGUgcmVxdWlyZXMgdHJlZSBhcmd1bWVudCB0byBnZXQgbGVhdmVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy50cmVlX2dldExlbmd0aChyb290Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBWZWN0b3JzIGRvbid0IG5lZWQgYSByb290Tm9kZSB0byByZXR1cm4gbGVuZ3RoXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLnRyZWVfZ2V0TGVuZ3RoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdpbmRpY2VzID0gW107XG4gICAgICAgIGlmIChjb21wb3NpdGVfMS5pc0NvbXBvc2l0ZVR5cGUodGhpcy5lbGVtZW50VHlwZSkpIHtcbiAgICAgICAgICAgIC8vIFVuZGVybHlpbmcgZWxlbWVudHMgZXhpc3Qgb25lIHBlciBjaHVua1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGNodW5rIGdpbmRpY2VzLCByZWN1cnNpdmVseSBmZXRjaGluZyBsZWFmIGdpbmRpY2VzIGZyb20gZWFjaCBjaHVua1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS50b0dpbmRleCh0aGlzLmRlcHRoLCBCaWdJbnQoMCkpO1xuICAgICAgICAgICAgY29uc3QgZW5kR2luZGV4ID0gc3RhcnRJbmRleCArIEJpZ0ludChsZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWRTdGFydEluZGV4ID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmNvbmNhdEdpbmRpY2VzKFtyb290R2luZGV4LCBzdGFydEluZGV4XSk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50VHlwZS5maXhlZFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gdW5yZWFjaGFibGUgY29kZSAqL1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBvZiB2YXJpYWJsZSBzaXplIHJlcXVpcmVzIHRyZWUgYXJndW1lbnQgdG8gZ2V0IGxlYXZlc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdmFyaWFibGUtbGVuZ3RoIGVsZW1lbnRzIG11c3QgcGFzcyB0aGUgdW5kZXJseWluZyBzdWJ0cmVlcyB0byBkZXRlcm1pbmUgdGhlIGxlbmd0aFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGdpbmRleCA9IHN0YXJ0SW5kZXgsIGV4dGVuZGVkR2luZGV4ID0gZXh0ZW5kZWRTdGFydEluZGV4OyBnaW5kZXggPCBlbmRHaW5kZXg7IGdpbmRleCsrLCBleHRlbmRlZEdpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdpbmRpY2VzLnB1c2goLi4udGhpcy5lbGVtZW50VHlwZS50cmVlX2dldExlYWZHaW5kaWNlcyhleHRlbmRlZEdpbmRleCwgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmdldE5vZGUocm9vdE5vZGUsIGdpbmRleCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZXh0ZW5kZWRHaW5kZXggPSBleHRlbmRlZFN0YXJ0SW5kZXg7IGkgPCBsZW5ndGg7IGkrKywgZXh0ZW5kZWRHaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBnaW5kaWNlcy5wdXNoKC4uLnRoaXMuZWxlbWVudFR5cGUudHJlZV9nZXRMZWFmR2luZGljZXMoZXh0ZW5kZWRHaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFzaWNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMuaXRlbXNQZXJDaHVuayk7XG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmNvbmNhdEdpbmRpY2VzKFtyb290R2luZGV4LCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEudG9HaW5kZXgodGhpcy5kZXB0aCwgQmlnSW50KDApKV0pO1xuICAgICAgICAgICAgY29uc3QgZW5kR2luZGV4ID0gc3RhcnRJbmRleCArIEJpZ0ludChjaHVua0NvdW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGdpbmRleCA9IHN0YXJ0SW5kZXg7IGdpbmRleCA8IGVuZEdpbmRleDsgZ2luZGV4KyspIHtcbiAgICAgICAgICAgICAgICBnaW5kaWNlcy5wdXNoKGdpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5jbHVkZSB0aGUgbGVuZ3RoIGNodW5rXG4gICAgICAgIGlmICh0aGlzLmlzTGlzdCkge1xuICAgICAgICAgICAgZ2luZGljZXMucHVzaChwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuY29uY2F0R2luZGljZXMoW3Jvb3RHaW5kZXgsIGNvbXBvc2l0ZV8xLkxFTkdUSF9HSU5ERVhdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdpbmRpY2VzO1xuICAgIH1cbiAgICAvLyBKU09OXG4gICAgZnJvbUpzb24oanNvbikge1xuICAgICAgICAvLyBUT0RPOiBEbyBhIGJldHRlciB0eXBlc2FmZSBhcHByb2FjaCwgYWxsIGZpbmFsIGNsYXNzZXMgb2YgQXJyYXlUeXBlIGltcGxlbWVudCBBcnJheVByb3BzXG4gICAgICAgIC8vIFRoZXJlIGFyZSBtdWx0aXBsZSB0ZXN0cyB0aGF0IGNvdmVyIHRoaXMgcGF0aCBmb3IgYWxsIGNsYXNlc1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnZhbHVlX2Zyb21Kc29uQXJyYXkodGhpcy5lbGVtZW50VHlwZSwganNvbiwgdGhpcyk7XG4gICAgfVxuICAgIHRvSnNvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnZhbHVlX3RvSnNvbkFycmF5KHRoaXMuZWxlbWVudFR5cGUsIHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgY2xvbmUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5QmFzaWNfMS52YWx1ZV9jbG9uZUFycmF5KHRoaXMuZWxlbWVudFR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5QmFzaWNfMS52YWx1ZV9lcXVhbHModGhpcy5lbGVtZW50VHlwZSwgYSwgYik7XG4gICAgfVxufVxuZXhwb3J0cy5BcnJheVR5cGUgPSBBcnJheVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRBcnJheUxlbmd0aCA9IGV4cG9ydHMudmFsdWVfZGVmYXVsdFZhbHVlQXJyYXkgPSBleHBvcnRzLnZhbHVlX2VxdWFscyA9IGV4cG9ydHMudmFsdWVfY2xvbmVBcnJheSA9IGV4cG9ydHMudmFsdWVfdG9Kc29uQXJyYXkgPSBleHBvcnRzLnZhbHVlX2Zyb21Kc29uQXJyYXkgPSBleHBvcnRzLnRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXNBcnJheUJhc2ljID0gZXhwb3J0cy50cmVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUJhc2ljID0gZXhwb3J0cy52YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5QmFzaWMgPSBleHBvcnRzLnZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUJhc2ljID0gZXhwb3J0cy5zZXRDaHVua3NOb2RlID0gZXhwb3J0cy5hZGRMZW5ndGhOb2RlID0gZXhwb3J0cy5nZXRDaHVua3NOb2RlRnJvbVJvb3ROb2RlID0gZXhwb3J0cy5nZXRMZW5ndGhGcm9tUm9vdE5vZGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuLy8gVGhlcmUncyBhIG1hdHJpeCBvZiBBcnJheS1pc2ggdHlwZXMgdGhhdCByZXF1aXJlIGEgY29tYmluYXRpb24gb2YgdGhpcyBmdW5jdGlvbnMuXG4vLyBSZWd1bGFyIGNsYXNzIGV4dGVuZHMgc3ludGF4IGRvZXNuJ3Qgd29yayBiZWNhdXNlIGl0IGNhbiBvbmx5IGV4dGVuZCBhIHNpbmdsZSBjbGFzcy5cbi8vXG4vLyBUeXBlIG9mIGFycmF5OiBMaXN0LCBWZWN0b3IuIENoYW5nZXMgbGVuZ3RoIHByb3BlcnR5XG4vLyBUeXBlIG9mIGVsZW1lbnQ6IEJhc2ljLCBDb21wb3NpdGUuIENoYW5nZXMgbWVya2VsaXphdGlvbiBpZiBwYWNraW5nIG9yIG5vdC5cbi8vIElmIENvbXBvc2l0ZTogRml4ZWQgbGVuLCBWYXJpYWJsZSBsZW4uIENoYW5nZXMgdGhlIHNlcmlhbGl6YXRpb24gcmVxdWlyaW5nIG9mZnNldHMuXG4vKipcbiAqIFNTWiBMaXN0cyAodmFyaWFibGUtbGVuZ3RoIGFycmF5cykgaW5jbHVkZSB0aGUgbGVuZ3RoIG9mIHRoZSBsaXN0IGluIHRoZSB0cmVlXG4gKiBUaGlzIGxlbmd0aCBpcyBhbHdheXMgaW4gdGhlIHNhbWUgaW5kZXggaW4gdGhlIHRyZWVcbiAqIGBgYFxuICogICAxXG4gKiAgLyBcXFxuICogMiAgIDMgLy8gPC1oZXJlXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoRnJvbVJvb3ROb2RlKG5vZGUpIHtcbiAgICAvLyBMZW5ndGggaXMgcmVwcmVzZW50ZWQgYXMgYSBVaW50MzIgYXQgdGhlIHN0YXJ0IG9mIHRoZSBjaHVuazpcbiAgICAvLyA0ID0gNCBieXRlcyBpbiBVaW50MzJcbiAgICAvLyAwID0gMCBvZmZzZXQgYnl0ZXMgaW4gTm9kZSdzIGRhdGFcbiAgICByZXR1cm4gbm9kZS5yaWdodC5nZXRVaW50KDQsIDApO1xufVxuZXhwb3J0cy5nZXRMZW5ndGhGcm9tUm9vdE5vZGUgPSBnZXRMZW5ndGhGcm9tUm9vdE5vZGU7XG5mdW5jdGlvbiBnZXRDaHVua3NOb2RlRnJvbVJvb3ROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5sZWZ0O1xufVxuZXhwb3J0cy5nZXRDaHVua3NOb2RlRnJvbVJvb3ROb2RlID0gZ2V0Q2h1bmtzTm9kZUZyb21Sb290Tm9kZTtcbmZ1bmN0aW9uIGFkZExlbmd0aE5vZGUoY2h1bmtzTm9kZSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuQnJhbmNoTm9kZShjaHVua3NOb2RlLCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuTGVhZk5vZGUuZnJvbVVpbnQzMihsZW5ndGgpKTtcbn1cbmV4cG9ydHMuYWRkTGVuZ3RoTm9kZSA9IGFkZExlbmd0aE5vZGU7XG5mdW5jdGlvbiBzZXRDaHVua3NOb2RlKHJvb3ROb2RlLCBjaHVua3NOb2RlLCBuZXdMZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGhOb2RlID0gbmV3TGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyAvLyBJZiBuZXdMZW5ndGggaXMgc2V0LCBjcmVhdGUgYSBuZXcgbm9kZSBmb3IgbGVuZ3RoXG4gICAgICAgICAgICBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuTGVhZk5vZGUuZnJvbVVpbnQzMihuZXdMZW5ndGgpXG4gICAgICAgIDogLy8gZWxzZSByZS11c2UgZXhpc3Rpbmcgbm9kZVxuICAgICAgICAgICAgcm9vdE5vZGUucmlnaHQ7XG4gICAgcmV0dXJuIG5ldyBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuQnJhbmNoTm9kZShjaHVua3NOb2RlLCBsZW5ndGhOb2RlKTtcbn1cbmV4cG9ydHMuc2V0Q2h1bmtzTm9kZSA9IHNldENodW5rc05vZGU7XG4vKipcbiAqIEBwYXJhbSBsZW5ndGggSW4gTGlzdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIFZlY3RvciBsZW5ndGggPSBmaXhlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlCYXNpYyhlbGVtZW50VHlwZSwgbGVuZ3RoLCBvdXRwdXQsIG9mZnNldCwgdmFsdWUpIHtcbiAgICBjb25zdCBlbFNpemUgPSBlbGVtZW50VHlwZS5ieXRlTGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudFR5cGUudmFsdWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCArIGkgKiBlbFNpemUsIHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIGxlbmd0aCAqIGVsU2l6ZTtcbn1cbmV4cG9ydHMudmFsdWVfc2VyaWFsaXplVG9CeXRlc0FycmF5QmFzaWMgPSB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlCYXNpYztcbmZ1bmN0aW9uIHZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzQXJyYXlCYXNpYyhlbGVtZW50VHlwZSwgZGF0YSwgc3RhcnQsIGVuZCwgYXJyYXlQcm9wcykge1xuICAgIGNvbnN0IGVsU2l6ZSA9IGVsZW1lbnRUeXBlLmJ5dGVMZW5ndGg7XG4gICAgLy8gVmVjdG9yICsgTGlzdCBsZW5ndGggdmFsaWRhdGlvblxuICAgIGNvbnN0IGxlbmd0aCA9IChlbmQgLSBzdGFydCkgLyBlbFNpemU7XG4gICAgYXNzZXJ0VmFsaWRBcnJheUxlbmd0aChsZW5ndGgsIGFycmF5UHJvcHMsIHRydWUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gVE9ETzogSWYgZmFzdGVyLCBjb25zaWRlciBza2lwcGluZyBzaXplIGNoZWNrIGZvciB1aW50IHR5cGVzXG4gICAgICAgIHZhbHVlc1tpXSA9IGVsZW1lbnRUeXBlLnZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0ICsgaSAqIGVsU2l6ZSwgc3RhcnQgKyAoaSArIDEpICogZWxTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydHMudmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXNBcnJheUJhc2ljID0gdmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXNBcnJheUJhc2ljO1xuLyoqXG4gKiBAcGFyYW0gbGVuZ3RoIEluIExpc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCBWZWN0b3IgbGVuZ3RoID0gZml4ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdHJlZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlCYXNpYyhlbGVtZW50VHlwZSwgbGVuZ3RoLCBkZXB0aCwgb3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICBjb25zdCBzaXplID0gZWxlbWVudFR5cGUuYnl0ZUxlbmd0aCAqIGxlbmd0aDtcbiAgICBjb25zdCBjaHVua0NvdW50ID0gTWF0aC5jZWlsKHNpemUgLyAzMik7XG4gICAgY29uc3Qgbm9kZXMgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZXNBdERlcHRoKG5vZGUsIGRlcHRoLCAwLCBjaHVua0NvdW50KTtcbiAgICBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEucGFja2VkTm9kZVJvb3RzVG9CeXRlcyhvdXRwdXQuZGF0YVZpZXcsIG9mZnNldCwgc2l6ZSwgbm9kZXMpO1xuICAgIHJldHVybiBvZmZzZXQgKyBzaXplO1xufVxuZXhwb3J0cy50cmVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUJhc2ljID0gdHJlZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlCYXNpYztcbi8vIExpc3Qgb2YgYmFzaWMgZWxlbWVudHMgd2lsbCBwYWNrIHRoZW0gaW4gbWVya2VsaXplZCBmb3JtXG5mdW5jdGlvbiB0cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzQXJyYXlCYXNpYyhlbGVtZW50VHlwZSwgY2h1bmtEZXB0aCwgZGF0YSwgc3RhcnQsIGVuZCwgYXJyYXlQcm9wcykge1xuICAgIC8vIFZlY3RvciArIExpc3QgbGVuZ3RoIHZhbGlkYXRpb25cbiAgICBjb25zdCBsZW5ndGggPSAoZW5kIC0gc3RhcnQpIC8gZWxlbWVudFR5cGUuYnl0ZUxlbmd0aDtcbiAgICBhc3NlcnRWYWxpZEFycmF5TGVuZ3RoKGxlbmd0aCwgYXJyYXlQcm9wcywgdHJ1ZSk7XG4gICAgLy8gQWJzdHJhY3QgY29udmVydGluZyBkYXRhIHRvIExlYWZOb2RlIHRvIGFsbG93IGZvciBjdXN0b20gZGF0YSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyB0aGUgaGFzaE9iamVjdFxuICAgIGNvbnN0IGNodW5rc05vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEucGFja2VkUm9vdHNCeXRlc1RvTm9kZShjaHVua0RlcHRoLCBkYXRhLmRhdGFWaWV3LCBzdGFydCwgZW5kKTtcbiAgICBpZiAoYXJyYXlQcm9wcy5pc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIGFkZExlbmd0aE5vZGUoY2h1bmtzTm9kZSwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjaHVua3NOb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5QmFzaWMgPSB0cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzQXJyYXlCYXNpYztcbi8qKlxuICogQHBhcmFtIGxlbmd0aCBJbiBMaXN0IGxlbmd0aCA9IHVuZGVmaW5lZCwgVmVjdG9yIGxlbmd0aCA9IGZpeGVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZhbHVlX2Zyb21Kc29uQXJyYXkoZWxlbWVudFR5cGUsIGpzb24sIGFycmF5UHJvcHMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJKU09OIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgICB9XG4gICAgYXNzZXJ0VmFsaWRBcnJheUxlbmd0aChqc29uLmxlbmd0aCwgYXJyYXlQcm9wcyk7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgQXJyYXkoanNvbi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IGVsZW1lbnRUeXBlLmZyb21Kc29uKGpzb25baV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLnZhbHVlX2Zyb21Kc29uQXJyYXkgPSB2YWx1ZV9mcm9tSnNvbkFycmF5O1xuLyoqXG4gKiBAcGFyYW0gbGVuZ3RoIEluIExpc3QgbGVuZ3RoID0gdW5kZWZpbmVkLCBWZWN0b3IgbGVuZ3RoID0gZml4ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmFsdWVfdG9Kc29uQXJyYXkoZWxlbWVudFR5cGUsIHZhbHVlLCBhcnJheVByb3BzKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlQcm9wcy5pc0xpc3QgPyB2YWx1ZS5sZW5ndGggOiBhcnJheVByb3BzLmxlbmd0aDtcbiAgICBjb25zdCBqc29uID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBqc29uW2ldID0gZWxlbWVudFR5cGUudG9Kc29uKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnRzLnZhbHVlX3RvSnNvbkFycmF5ID0gdmFsdWVfdG9Kc29uQXJyYXk7XG4vKipcbiAqIENsb25lIHJlY3Vyc2l2ZWx5IGFuIGFycmF5IG9mIGJhc2ljIG9yIGNvbXBvc2l0ZSB0eXBlc1xuICovXG5mdW5jdGlvbiB2YWx1ZV9jbG9uZUFycmF5KGVsZW1lbnRUeXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3IEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdWYWx1ZVtpXSA9IGVsZW1lbnRUeXBlLmNsb25lKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuZXhwb3J0cy52YWx1ZV9jbG9uZUFycmF5ID0gdmFsdWVfY2xvbmVBcnJheTtcbi8qKlxuICogQ2hlY2sgcmVjdXJzaXZlbHkgaWYgYSB0eXBlIGlzIHN0cnVjdHVyYWx5IGVxdWFsLiBSZXR1cm5zIGVhcmx5XG4gKi9cbmZ1bmN0aW9uIHZhbHVlX2VxdWFscyhlbGVtZW50VHlwZSwgYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlbGVtZW50VHlwZS5lcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMudmFsdWVfZXF1YWxzID0gdmFsdWVfZXF1YWxzO1xuZnVuY3Rpb24gdmFsdWVfZGVmYXVsdFZhbHVlQXJyYXkoZWxlbWVudFR5cGUsIGxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldID0gZWxlbWVudFR5cGUuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnRzLnZhbHVlX2RlZmF1bHRWYWx1ZUFycmF5ID0gdmFsdWVfZGVmYXVsdFZhbHVlQXJyYXk7XG4vKipcbiAqIEBwYXJhbSBjaGVja05vbkRlY2ltYWxMZW5ndGggQ2hlY2sgdGhhdCBsZW5ndGggaXMgYSBtdWx0aXBsZSBvZiBlbGVtZW50IHNpemUuXG4gKiBPcHRpb25hbCBzaW5jZSBpdCdzIG5vdCBuZWNlc3NhcnkgaW4gZ2V0T2Zmc2V0c0FycmF5Q29tcG9zaXRlKCkgZm4uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkQXJyYXlMZW5ndGgobGVuZ3RoLCBhcnJheVByb3BzLCBjaGVja05vbkRlY2ltYWxMZW5ndGgpIHtcbiAgICBpZiAoY2hlY2tOb25EZWNpbWFsTGVuZ3RoICYmIGxlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJzaXplIG5vdCBtdWx0aXBsZSBvZiBlbGVtZW50IGZpeGVkU2l6ZVwiKTtcbiAgICB9XG4gICAgLy8gVmVjdG9yICsgTGlzdCBsZW5ndGggdmFsaWRhdGlvblxuICAgIGlmIChhcnJheVByb3BzLmlzTGlzdCkge1xuICAgICAgICBpZiAobGVuZ3RoID4gYXJyYXlQcm9wcy5saW1pdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxpc3QgbGVuZ3RoICR7bGVuZ3RofSBvdmVyIGxpbWl0ICR7YXJyYXlQcm9wcy5saW1pdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gYXJyYXlQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb3JyZWN0IHZlY3RvciBsZW5ndGggJHtsZW5ndGh9IGV4cGVjdGVkICR7YXJyYXlQcm9wcy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFZhbGlkQXJyYXlMZW5ndGggPSBhc3NlcnRWYWxpZEFycmF5TGVuZ3RoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlCYXNpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsdWVfZ2V0Um9vdHNBcnJheUNvbXBvc2l0ZSA9IGV4cG9ydHMudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5Q29tcG9zaXRlID0gZXhwb3J0cy50cmVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUNvbXBvc2l0ZSA9IGV4cG9ydHMudHJlZV9zZXJpYWxpemVkU2l6ZUFycmF5Q29tcG9zaXRlID0gZXhwb3J0cy52YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5Q29tcG9zaXRlID0gZXhwb3J0cy52YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlDb21wb3NpdGUgPSBleHBvcnRzLnZhbHVlX3NlcmlhbGl6ZWRTaXplQXJyYXlDb21wb3NpdGUgPSBleHBvcnRzLm1heFNpemVBcnJheUNvbXBvc2l0ZSA9IGV4cG9ydHMubWluU2l6ZUFycmF5Q29tcG9zaXRlID0gdm9pZCAwO1xuY29uc3QgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZVwiKTtcbmNvbnN0IGFycmF5QmFzaWNfMSA9IHJlcXVpcmUoXCIuL2FycmF5QmFzaWNcIik7XG5mdW5jdGlvbiBtaW5TaXplQXJyYXlDb21wb3NpdGUoZWxlbWVudFR5cGUsIG1pbkNvdW50KSB7XG4gICAgLy8gVmFyaWFibGUgTGVuZ3RoXG4gICAgaWYgKGVsZW1lbnRUeXBlLmZpeGVkU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWluQ291bnQgKiAoNCArIGVsZW1lbnRUeXBlLm1pblNpemUpO1xuICAgIH1cbiAgICAvLyBGaXhlZCBsZW5ndGhcbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pbkNvdW50ICogZWxlbWVudFR5cGUubWluU2l6ZTtcbiAgICB9XG59XG5leHBvcnRzLm1pblNpemVBcnJheUNvbXBvc2l0ZSA9IG1pblNpemVBcnJheUNvbXBvc2l0ZTtcbmZ1bmN0aW9uIG1heFNpemVBcnJheUNvbXBvc2l0ZShlbGVtZW50VHlwZSwgbWF4Q291bnQpIHtcbiAgICAvLyBWYXJpYWJsZSBMZW5ndGhcbiAgICBpZiAoZWxlbWVudFR5cGUuZml4ZWRTaXplID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXhDb3VudCAqICg0ICsgZWxlbWVudFR5cGUubWF4U2l6ZSk7XG4gICAgfVxuICAgIC8vIEZpeGVkIGxlbmd0aFxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF4Q291bnQgKiBlbGVtZW50VHlwZS5tYXhTaXplO1xuICAgIH1cbn1cbmV4cG9ydHMubWF4U2l6ZUFycmF5Q29tcG9zaXRlID0gbWF4U2l6ZUFycmF5Q29tcG9zaXRlO1xuZnVuY3Rpb24gdmFsdWVfc2VyaWFsaXplZFNpemVBcnJheUNvbXBvc2l0ZShlbGVtZW50VHlwZSwgbGVuZ3RoLCB2YWx1ZSkge1xuICAgIC8vIFZhcmlhYmxlIExlbmd0aFxuICAgIGlmIChlbGVtZW50VHlwZS5maXhlZFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplICs9IDQgKyBlbGVtZW50VHlwZS52YWx1ZV9zZXJpYWxpemVkU2l6ZSh2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZpeGVkIGxlbmd0aFxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGVuZ3RoICogZWxlbWVudFR5cGUuZml4ZWRTaXplO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsdWVfc2VyaWFsaXplZFNpemVBcnJheUNvbXBvc2l0ZSA9IHZhbHVlX3NlcmlhbGl6ZWRTaXplQXJyYXlDb21wb3NpdGU7XG4vKipcbiAqIEBwYXJhbSBsZW5ndGggSW4gTGlzdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIFZlY3RvciBsZW5ndGggPSBmaXhlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlDb21wb3NpdGUoZWxlbWVudFR5cGUsIGxlbmd0aCwgb3V0cHV0LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgLy8gVmFyaWFibGUgbGVuZ3RoXG4gICAgaWYgKGVsZW1lbnRUeXBlLmZpeGVkU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICBsZXQgdmFyaWFibGVJbmRleCA9IG9mZnNldCArIGxlbmd0aCAqIDQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHdyaXRlIG9mZnNldFxuICAgICAgICAgICAgb3V0cHV0LmRhdGFWaWV3LnNldFVpbnQzMihvZmZzZXQgKyBpICogNCwgdmFyaWFibGVJbmRleCAtIG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyB3cml0ZSBzZXJpYWxpemVkIGVsZW1lbnQgdG8gdmFyaWFibGUgc2VjdGlvblxuICAgICAgICAgICAgdmFyaWFibGVJbmRleCA9IGVsZW1lbnRUeXBlLnZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCB2YXJpYWJsZUluZGV4LCB2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlSW5kZXg7XG4gICAgfVxuICAgIC8vIEZpeGVkIGxlbmd0aFxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbGVtZW50VHlwZS52YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0ICsgaSAqIGVsZW1lbnRUeXBlLmZpeGVkU2l6ZSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBsZW5ndGggKiBlbGVtZW50VHlwZS5maXhlZFNpemU7XG4gICAgfVxufVxuZXhwb3J0cy52YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlDb21wb3NpdGUgPSB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlDb21wb3NpdGU7XG5mdW5jdGlvbiB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5Q29tcG9zaXRlKGVsZW1lbnRUeXBlLCBkYXRhLCBzdGFydCwgZW5kLCBhcnJheVByb3BzKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHJlYWRPZmZzZXRzQXJyYXlDb21wb3NpdGUoZWxlbWVudFR5cGUuZml4ZWRTaXplLCBkYXRhLmRhdGFWaWV3LCBzdGFydCwgZW5kLCBhcnJheVByb3BzKTtcbiAgICBjb25zdCBsZW5ndGggPSBvZmZzZXRzLmxlbmd0aDsgLy8gQ2FwdHVyZSBsZW5ndGggYmVmb3JlIHB1c2hpbmcgZW5kIG9mZnNldFxuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIC8vIG9mZmVzdHMgaW5jbHVkZSB0aGUgbGFzdCBlbGVtZW50IGVuZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gVGhlIG9mZnNldHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydFxuICAgICAgICBjb25zdCBzdGFydEVsID0gc3RhcnQgKyBvZmZzZXRzW2ldO1xuICAgICAgICBjb25zdCBlbmRFbCA9IGkgPT09IGxlbmd0aCAtIDEgPyBlbmQgOiBzdGFydCArIG9mZnNldHNbaSArIDFdO1xuICAgICAgICB2YWx1ZXNbaV0gPSBlbGVtZW50VHlwZS52YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydEVsLCBlbmRFbCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnRzLnZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzQXJyYXlDb21wb3NpdGUgPSB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5Q29tcG9zaXRlO1xuLyoqXG4gKiBAcGFyYW0gbGVuZ3RoIEluIExpc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCBWZWN0b3IgbGVuZ3RoID0gZml4ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdHJlZV9zZXJpYWxpemVkU2l6ZUFycmF5Q29tcG9zaXRlKGVsZW1lbnRUeXBlLCBsZW5ndGgsIGRlcHRoLCBub2RlKSB7XG4gICAgLy8gVmFyaWFibGUgTGVuZ3RoXG4gICAgaWYgKGVsZW1lbnRUeXBlLmZpeGVkU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2Rlc0F0RGVwdGgobm9kZSwgZGVwdGgsIDAsIGxlbmd0aCk7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSArPSA0ICsgZWxlbWVudFR5cGUudHJlZV9zZXJpYWxpemVkU2l6ZShub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZpeGVkIGxlbmd0aFxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGVuZ3RoICogZWxlbWVudFR5cGUuZml4ZWRTaXplO1xuICAgIH1cbn1cbmV4cG9ydHMudHJlZV9zZXJpYWxpemVkU2l6ZUFycmF5Q29tcG9zaXRlID0gdHJlZV9zZXJpYWxpemVkU2l6ZUFycmF5Q29tcG9zaXRlO1xuLyoqXG4gKiBAcGFyYW0gbGVuZ3RoIEluIExpc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCBWZWN0b3IgbGVuZ3RoID0gZml4ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdHJlZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlDb21wb3NpdGUoZWxlbWVudFR5cGUsIGxlbmd0aCwgZGVwdGgsIG5vZGUsIG91dHB1dCwgb2Zmc2V0KSB7XG4gICAgY29uc3Qgbm9kZXMgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZXNBdERlcHRoKG5vZGUsIGRlcHRoLCAwLCBsZW5ndGgpO1xuICAgIC8vIFZhcmlhYmxlIExlbmd0aFxuICAgIC8vIEluZGljZXMgY29udGFpbiBvZmZzZXRzLCB3aGljaCBhcmUgaW5kaWNlcyBkZWVwZXIgaW4gdGhlIGJ5dGUgYXJyYXlcbiAgICBpZiAoZWxlbWVudFR5cGUuZml4ZWRTaXplID09PSBudWxsKSB7XG4gICAgICAgIGxldCB2YXJpYWJsZUluZGV4ID0gb2Zmc2V0ICsgbGVuZ3RoICogNDtcbiAgICAgICAgY29uc3QgeyBkYXRhVmlldyB9ID0gb3V0cHV0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB3cml0ZSBvZmZzZXRcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQzMihvZmZzZXQgKyBpICogNCwgdmFyaWFibGVJbmRleCAtIG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyB3cml0ZSBzZXJpYWxpemVkIGVsZW1lbnQgdG8gdmFyaWFibGUgc2VjdGlvblxuICAgICAgICAgICAgdmFyaWFibGVJbmRleCA9IGVsZW1lbnRUeXBlLnRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIHZhcmlhYmxlSW5kZXgsIG5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGVJbmRleDtcbiAgICB9XG4gICAgLy8gRml4ZWQgbGVuZ3RoXG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGVsZW1lbnRUeXBlLnRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgbm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxufVxuZXhwb3J0cy50cmVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUNvbXBvc2l0ZSA9IHRyZWVfc2VyaWFsaXplVG9CeXRlc0FycmF5Q29tcG9zaXRlO1xuZnVuY3Rpb24gdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5Q29tcG9zaXRlKGVsZW1lbnRUeXBlLCBjaHVua0RlcHRoLCBkYXRhLCBzdGFydCwgZW5kLCBhcnJheVByb3BzKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHJlYWRPZmZzZXRzQXJyYXlDb21wb3NpdGUoZWxlbWVudFR5cGUuZml4ZWRTaXplLCBkYXRhLmRhdGFWaWV3LCBzdGFydCwgZW5kLCBhcnJheVByb3BzKTtcbiAgICBjb25zdCBsZW5ndGggPSBvZmZzZXRzLmxlbmd0aDsgLy8gQ2FwdHVyZSBsZW5ndGggYmVmb3JlIHB1c2hpbmcgZW5kIG9mZnNldFxuICAgIGNvbnN0IG5vZGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgLy8gb2ZmZXN0cyBpbmNsdWRlIHRoZSBsYXN0IGVsZW1lbnQgZW5kXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0cyBhcmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0XG4gICAgICAgIGNvbnN0IHN0YXJ0RWwgPSBzdGFydCArIG9mZnNldHNbaV07XG4gICAgICAgIGNvbnN0IGVuZEVsID0gaSA9PT0gbGVuZ3RoIC0gMSA/IGVuZCA6IHN0YXJ0ICsgb2Zmc2V0c1tpICsgMV07XG4gICAgICAgIG5vZGVzW2ldID0gZWxlbWVudFR5cGUudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydEVsLCBlbmRFbCk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IGNvbnZlcnRpbmcgZGF0YSB0byBMZWFmTm9kZSB0byBhbGxvdyBmb3IgY3VzdG9tIGRhdGEgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgdGhlIGhhc2hPYmplY3RcbiAgICBjb25zdCBjaHVua3NOb2RlID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLnN1YnRyZWVGaWxsVG9Db250ZW50cyhub2RlcywgY2h1bmtEZXB0aCk7XG4gICAgLy8gVE9ETzogQWRkIExlYWZOb2RlLmZyb21VaW50KClcbiAgICBpZiAoYXJyYXlQcm9wcy5pc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5QmFzaWNfMS5hZGRMZW5ndGhOb2RlKGNodW5rc05vZGUsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY2h1bmtzTm9kZTtcbiAgICB9XG59XG5leHBvcnRzLnRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXNBcnJheUNvbXBvc2l0ZSA9IHRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXNBcnJheUNvbXBvc2l0ZTtcbi8qKlxuICogQHBhcmFtIGxlbmd0aCBJbiBMaXN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgVmVjdG9yIGxlbmd0aCA9IGZpeGVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZhbHVlX2dldFJvb3RzQXJyYXlDb21wb3NpdGUoZWxlbWVudFR5cGUsIGxlbmd0aCwgdmFsdWUpIHtcbiAgICBjb25zdCByb290cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm9vdHNbaV0gPSBlbGVtZW50VHlwZS5oYXNoVHJlZVJvb3QodmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdHM7XG59XG5leHBvcnRzLnZhbHVlX2dldFJvb3RzQXJyYXlDb21wb3NpdGUgPSB2YWx1ZV9nZXRSb290c0FycmF5Q29tcG9zaXRlO1xuZnVuY3Rpb24gcmVhZE9mZnNldHNBcnJheUNvbXBvc2l0ZShlbGVtZW50Rml4ZWRTaXplLCBkYXRhLCBzdGFydCwgZW5kLCBhcnJheVByb3BzKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgIGxldCBvZmZzZXRzO1xuICAgIC8vIFZhcmlhYmxlIExlbmd0aFxuICAgIC8vIEluZGljZXMgY29udGFpbiBvZmZzZXRzLCB3aGljaCBhcmUgaW5kaWNlcyBkZWVwZXIgaW4gdGhlIGJ5dGUgYXJyYXlcbiAgICBpZiAoZWxlbWVudEZpeGVkU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICBvZmZzZXRzID0gcmVhZFZhcmlhYmxlT2Zmc2V0c0FycmF5Q29tcG9zaXRlKGRhdGEsIHN0YXJ0LCBzaXplKTtcbiAgICB9XG4gICAgLy8gRml4ZWQgbGVuZ3RoXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gdmFsaWQgQ29tcG9zaXRlVHlwZSB3aXRoIGZpeGVkIHNpemUgMCwgaXQncyB1bi1yZWNoYWJsZSBjb2RlLiBCdXQgcHJldmVudHMgZGl2aW5nIGJ5IHplcm9cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlbGVtZW50Rml4ZWRTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImVsZW1lbnQgZml4ZWQgbGVuZ3RoIGlzIDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpemUgJSBlbGVtZW50Rml4ZWRTaXplICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgc2l6ZSAke3NpemV9IGlzIG5vdCBtdWx0aXBsZSBvZiBlbGVtZW50IGZpeGVkU2l6ZSAke2VsZW1lbnRGaXhlZFNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc2l6ZSAvIGVsZW1lbnRGaXhlZFNpemU7XG4gICAgICAgIG9mZnNldHMgPSBuZXcgVWludDMyQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2Zmc2V0c1tpXSA9IGkgKiBlbGVtZW50Rml4ZWRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFZlY3RvciArIExpc3QgbGVuZ3RoIHZhbGlkYXRpb25cbiAgICBhcnJheUJhc2ljXzEuYXNzZXJ0VmFsaWRBcnJheUxlbmd0aChvZmZzZXRzLmxlbmd0aCwgYXJyYXlQcm9wcyk7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59XG4vKipcbiAqIFJlYWRzIHRoZSB2YWx1ZXMgb2YgY29udGlndW91cyB2YXJpYWJsZSBvZmZzZXRzLiBQcm92aWRlZCBidWZmZXIgaW5jbHVkZXMgb2Zmc2V0cyB0aGF0IHBvaW50IHRvIHBvc2l0aW9uXG4gKiB3aXRoaW4gYHNpemVgLiBUaGlzIGZ1bmN0aW9uIGFsc28gdmFsaWRhdGVzIHRoYXQgYWxsIG9mZnNldHMgYXJlIGluIHJhbmdlLlxuICovXG5mdW5jdGlvbiByZWFkVmFyaWFibGVPZmZzZXRzQXJyYXlDb21wb3NpdGUoZGF0YVZpZXcsIHN0YXJ0LCBzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICB9XG4gICAgLy8gYWxsIGVsZW1lbnRzIGFyZSB2YXJpYWJsZS1zaXplZFxuICAgIC8vIGluZGljZXMgY29udGFpbiBvZmZzZXRzLCB3aGljaCBhcmUgaW5kaWNlcyBkZWVwZXIgaW4gdGhlIGJ5dGUgYXJyYXlcbiAgICAvLyBUaGUgc2VyaWFsaXplZCBkYXRhIHdpbGwgc3RhcnQgd2l0aCBvZmZzZXRzIG9mIGFsbCB0aGUgc2VyaWFsaXplZCBvYmplY3RzIChCWVRFU19QRVJfTEVOR1RIX09GRlNFVCBieXRlcyBlYWNoKVxuICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHN0YXJ0LCB0cnVlKTtcbiAgICAvLyBVc2luZyB0aGUgZmlyc3Qgb2Zmc2V0LCB3ZSBjYW4gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsaXN0IChkaXZpZGUgYnkgQllURVNfUEVSX0xFTkdUSF9PRkZTRVQpLCBhcyBpdCBnaXZlc1xuICAgIC8vIHVzIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIG9mZnNldCBkYXRhXG4gICAgY29uc3Qgb2Zmc2V0RGF0YUxlbmd0aCA9IGZpcnN0T2Zmc2V0O1xuICAgIGlmIChmaXJzdE9mZnNldCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkZpcnN0IG9mZnNldCBtdXN0IGJlID4gMFwiKTtcbiAgICB9XG4gICAgaWYgKG9mZnNldERhdGFMZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiT2Zmc2V0IGRhdGEgbGVuZ3RoIG5vdCBtdWx0aXBsZSBvZiA0XCIpO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXRDb3VudCA9IG9mZnNldERhdGFMZW5ndGggLyA0O1xuICAgIGNvbnN0IG9mZnNldHMgPSBuZXcgVWludDMyQXJyYXkob2Zmc2V0Q291bnQpO1xuICAgIG9mZnNldHNbMF0gPSBmaXJzdE9mZnNldDtcbiAgICAvLyBBcnJheUNvbXBvc2l0ZSBoYXMgYSBjb250aWd1b3VzIHNlY3Rpb24gb2Ygb2Zmc2V0cywgdGhlbiB0aGUgZGF0YVxuICAgIC8vXG4gICAgLy8gICAgW29mZnNldCAxXSBbb2Zmc2V0IDJdIFtkYXRhIDEgLi4uLi4uLi4uLl0gW2RhdGEgMiAuLl1cbiAgICAvLyAweCAwODAwMDAwMCAgIDBlMDAwMDAwICAgMDEwMDAyMDAwMzAwICAgICAgICAwMTAwMDIwMFxuICAgIC8vXG4gICAgLy8gRW5zdXJlIHRoYXQ6XG4gICAgLy8gLSBPZmZzZXRzIHBvaW50IHRvIHJlZ2lvbnMgb2YgPiAwIGJ5dGVzLCBpLmUuIGFyZSBpbmNyZWFzaW5nXG4gICAgLy8gLSBPZmZzZXRzIGRvbid0IHBvaW50IHRvIGJ5dGVzIG91dHNpZGUgb2YgdGhlIGFycmF5J3Mgc2l6ZVxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGV4YW1wbGUgYWJvdmUgdGhlIGZpcnN0IG9mZnNldCBpcyA4LCBzbyA4IC8gNCA9IDIgb2Zmc2V0cy5cbiAgICAvLyBUaGVuLCByZWFkIHRoZSByZXN0IG9mIG9mZnNldHMgdG8gZ2V0IG9mZnNldHMgPSBbOCwgMTRdXG4gICAgZm9yIChsZXQgb2Zmc2V0SWR4ID0gMTsgb2Zmc2V0SWR4IDwgb2Zmc2V0Q291bnQ7IG9mZnNldElkeCsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMihzdGFydCArIG9mZnNldElkeCAqIDQsIHRydWUpO1xuICAgICAgICBvZmZzZXRzW29mZnNldElkeF0gPSBvZmZzZXQ7XG4gICAgICAgIC8vIE9mZnNldHMgbXVzdCBwb2ludCB0byBkYXRhIHdpdGhpbiB0aGUgQXJyYXkgYnl0ZXMgc2VjdGlvblxuICAgICAgICBpZiAob2Zmc2V0ID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPZmZzZXQgb3V0IG9mIGJvdW5kcyAke29mZnNldH0gPiAke3NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IG9mZnNldHNbb2Zmc2V0SWR4IC0gMV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2Zmc2V0cyBtdXN0IGJlIGluY3JlYXNpbmcgJHtvZmZzZXR9IDwgJHtvZmZzZXRzW29mZnNldElkeCAtIDFdfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlDb21wb3NpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQmFzaWNUeXBlID0gZXhwb3J0cy5CYXNpY1R5cGUgPSB2b2lkIDA7XG5jb25zdCBhYnN0cmFjdF8xID0gcmVxdWlyZShcIi4vYWJzdHJhY3RcIik7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBiYXNpYyB0eXBlIGFzIGRlZmluZWQgaW4gdGhlIHNwZWM6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vY29uc2Vuc3VzLXNwZWNzL2Jsb2IvZGV2L3Nzei9zaW1wbGUtc2VyaWFsaXplLm1kI2Jhc2ljLXR5cGVzXG4gKi9cbmNsYXNzIEJhc2ljVHlwZSBleHRlbmRzIGFic3RyYWN0XzEuVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaXNCYXNpYyA9IHRydWU7XG4gICAgICAgIC8vIEJhc2ljIHR5cGVzIG1lcmtsZWl6ZSB0byBleGFjdGx5IG9uZSBjaHVuaywgdGh1cyBkZXB0aCBvZiAwXG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICAvLyBCYXNpYyB0eXBlcyBtZXJrbGVpemUgdG8gZXhhY3RseSBvbmUgY2h1bmtcbiAgICAgICAgdGhpcy5tYXhDaHVua0NvdW50ID0gMTtcbiAgICB9XG4gICAgdmFsdWVfc2VyaWFsaXplZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkU2l6ZShzaXplKSB7XG4gICAgICAgIGlmIChzaXplICE9PSB0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBCYXNpY1R5cGUgaW52YWxpZCBzaXplICR7c2l6ZX0gZXhwZWN0ZWQgJHt0aGlzLmJ5dGVMZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzaFRyZWVSb290KHZhbHVlKSB7XG4gICAgICAgIC8vIFRPRE86IE9wdGltaXplXG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFsdWVfc2VyaWFsaXplVG9CeXRlcyh7IHVpbnQ4QXJyYXksIGRhdGFWaWV3IH0sIDAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXk7XG4gICAgfVxuICAgIGNsb25lKHZhbHVlKSB7XG4gICAgICAgIC8vIEFsbCBiYXNpYyB0eXBlcyBhcmUgcmVwcmVzZW50ZWQgYnkgcHJpbWl0aXZlIEphdmFzY3JpcHQgdHlwZXMsIGRvbid0IHJlcXVpcmUgY2xvbmVcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICAvLyBBbGwgYmFzaWMgdHlwZXMgYXJlIHJlcHJlc2VudGVkIGJ5IHByaW1pdGl2ZSBKYXZhc2NyaXB0IHR5cGVzLCB0aGUgb3BlcmF0b3IgPT09IGlzIHN1ZmZpY2llbnRcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY1R5cGUgPSBCYXNpY1R5cGU7XG5mdW5jdGlvbiBpc0Jhc2ljVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUuaXNCYXNpYztcbn1cbmV4cG9ydHMuaXNCYXNpY1R5cGUgPSBpc0Jhc2ljVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2ljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRBcnJheVR5cGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgYnl0ZUFycmF5XzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ieXRlQXJyYXlcIik7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IGNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4vY29tcG9zaXRlXCIpO1xuY29uc3QgYml0QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi92aWV3L2JpdEFycmF5XCIpO1xuY29uc3QgYml0QXJyYXlfMiA9IHJlcXVpcmUoXCIuLi92aWV3RFUvYml0QXJyYXlcIik7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nICovXG4vKipcbiAqIEJpdEFycmF5OiBvcmRlcmVkIGFycmF5IGNvbGxlY3Rpb24gb2YgYm9vbGVhbiB2YWx1ZXNcbiAqIC0gVmFsdWU6IGBCaXRBcnJheWAsIEBzZWUgQml0QXJyYXkgZm9yIGEganVzdGlmaWNhdGlvbiBvZiBpdHMgbWVtb3J5IGVmZmljaWVuY3kgYW5kIHBlcmZvcm1hbmNlXG4gKiAtIFZpZXc6IGBCaXRBcnJheVRyZWVWaWV3YFxuICogLSBWaWV3RFU6IGBCaXRBcnJheVRyZWVWaWV3RFVgXG4gKi9cbmNsYXNzIEJpdEFycmF5VHlwZSBleHRlbmRzIGNvbXBvc2l0ZV8xLkNvbXBvc2l0ZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlzVmlld011dGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXRWaWV3KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBiaXRBcnJheV8xLkJpdEFycmF5VHJlZVZpZXcodGhpcywgdHJlZSk7XG4gICAgfVxuICAgIGdldFZpZXdEVShub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgYml0QXJyYXlfMi5CaXRBcnJheVRyZWVWaWV3RFUodGhpcywgbm9kZSk7XG4gICAgfVxuICAgIGNvbW1pdFZpZXcodmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5ub2RlO1xuICAgIH1cbiAgICBjb21taXRWaWV3RFUodmlldykge1xuICAgICAgICB2aWV3LmNvbW1pdCgpO1xuICAgICAgICByZXR1cm4gdmlldy5ub2RlO1xuICAgIH1cbiAgICBjYWNoZU9mVmlld0RVKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuY2FjaGU7XG4gICAgfVxuICAgIC8vIE1lcmtsZWl6YXRpb25cbiAgICBnZXRSb290cyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbWVya2xlaXplXzEuc3BsaXRJbnRvUm9vdENodW5rcyh2YWx1ZS51aW50OEFycmF5KTtcbiAgICB9XG4gICAgLy8gUHJvb2ZzXG4gICAgZ2V0UHJvcGVydHlHaW5kZXgoKSB7XG4gICAgICAgIC8vIFN0b3AgbmF2aWdhdGluZyBiZWxvdyB0aGlzIHR5cGUuIE11c3Qgb25seSByZXF1ZXN0IGNvbXBsZXRlIGRhdGFcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldFByb3BlcnR5VHlwZSgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSB1bnJlYWNoYWJsZSBjb2RlLCBnZXRQcm9wZXJ0eUdpbmRleCBudWxsIHJldHVybiBwcmV2ZW50cyB0aGlzIGNhbGwgKi9cbiAgICAgICAgdGhyb3cgRXJyb3IoXCJNdXN0IG9ubHkgcmVxdWVzdCBCaXRBcnJheSBjb21wbGV0ZSBkYXRhXCIpO1xuICAgIH1cbiAgICBnZXRJbmRleFByb3BlcnR5KCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHVucmVhY2hhYmxlIGNvZGUsIGdldFByb3BlcnR5R2luZGV4IG51bGwgcmV0dXJuIHByZXZlbnRzIHRoaXMgY2FsbCAqL1xuICAgICAgICB0aHJvdyBFcnJvcihcIk11c3Qgb25seSByZXF1ZXN0IEJpdEFycmF5IGNvbXBsZXRlIGRhdGFcIik7XG4gICAgfVxuICAgIHRyZWVfZnJvbVByb29mTm9kZShub2RlKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGRvbmU6IHRydWUgfTtcbiAgICB9XG4gICAgdHJlZV9nZXRMZWFmR2luZGljZXMocm9vdEdpbmRleCwgcm9vdE5vZGUpIHtcbiAgICAgICAgY29uc3QgYnl0ZUxlbiA9IHRoaXMudHJlZV9nZXRCeXRlTGVuKHJvb3ROb2RlKTtcbiAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IE1hdGguY2VpbChieXRlTGVuIC8gMzIpO1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmNvbmNhdEdpbmRpY2VzKFtyb290R2luZGV4LCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEudG9HaW5kZXgodGhpcy5kZXB0aCwgQmlnSW50KDApKV0pO1xuICAgICAgICBjb25zdCBnaW5kaWNlcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGdpbmRleCA9IHN0YXJ0SW5kZXg7IGkgPCBjaHVua0NvdW50OyBpKyssIGdpbmRleCsrKSB7XG4gICAgICAgICAgICBnaW5kaWNlc1tpXSA9IGdpbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNsdWRlIHRoZSBsZW5ndGggY2h1bmtcbiAgICAgICAgaWYgKHRoaXMuaXNMaXN0KSB7XG4gICAgICAgICAgICBnaW5kaWNlcy5wdXNoKHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5jb25jYXRHaW5kaWNlcyhbcm9vdEdpbmRleCwgY29tcG9zaXRlXzEuTEVOR1RIX0dJTkRFWF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2luZGljZXM7XG4gICAgfVxuICAgIC8vIEpTT05cbiAgICBmcm9tSnNvbihqc29uKSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBieXRlQXJyYXlfMS5mcm9tSGV4U3RyaW5nKGpzb24pO1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyh1aW50OEFycmF5LmJ1ZmZlciwgdWludDhBcnJheS5ieXRlT2Zmc2V0LCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICAvLyB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyBNVVNUIHZhbGlkYXRlIGxlbmd0aCAobGltaXQsIG9yIGxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoeyB1aW50OEFycmF5LCBkYXRhVmlldyB9LCAwLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuICAgIHRvSnNvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYnl0ZUFycmF5XzEudG9IZXhTdHJpbmcodGhpcy5zZXJpYWxpemUodmFsdWUpKTtcbiAgICB9XG4gICAgY2xvbmUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNsb25lKCk7XG4gICAgfVxuICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmJpdExlbiA9PT0gYi5iaXRMZW4gJiYgYnl0ZUFycmF5XzEuYnl0ZUFycmF5RXF1YWxzKGEudWludDhBcnJheSwgYi51aW50OEFycmF5KTtcbiAgICB9XG59XG5leHBvcnRzLkJpdEFycmF5VHlwZSA9IEJpdEFycmF5VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdEFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRMaXN0VHlwZSA9IHZvaWQgMDtcbmNvbnN0IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWVcIik7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IG5hbWVkXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9uYW1lZFwiKTtcbmNvbnN0IGFycmF5QmFzaWNfMSA9IHJlcXVpcmUoXCIuL2FycmF5QmFzaWNcIik7XG5jb25zdCBiaXRBcnJheV8xID0gcmVxdWlyZShcIi4uL3ZhbHVlL2JpdEFycmF5XCIpO1xuY29uc3QgYml0QXJyYXlfMiA9IHJlcXVpcmUoXCIuL2JpdEFycmF5XCIpO1xuLyoqXG4gKiBCaXRMaXN0OiBvcmRlcmVkIHZhcmlhYmxlLWxlbmd0aCBjb2xsZWN0aW9uIG9mIGJvb2xlYW4gdmFsdWVzLCBsaW1pdGVkIHRvIE4gYml0c1xuICogLSBOb3RhdGlvbiBgQml0bGlzdFtOXWBcbiAqIC0gVmFsdWU6IGBCaXRBcnJheWAsIEBzZWUgQml0QXJyYXkgZm9yIGEganVzdGlmaWNhdGlvbiBvZiBpdHMgbWVtb3J5IGVmZmljaWVuY3kgYW5kIHBlcmZvcm1hbmNlXG4gKiAtIFZpZXc6IGBCaXRBcnJheVRyZWVWaWV3YFxuICogLSBWaWV3RFU6IGBCaXRBcnJheVRyZWVWaWV3RFVgXG4gKi9cbmNsYXNzIEJpdExpc3RUeXBlIGV4dGVuZHMgYml0QXJyYXlfMi5CaXRBcnJheVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbWl0Qml0cywgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxpbWl0Qml0cyA9IGxpbWl0Qml0cztcbiAgICAgICAgdGhpcy5maXhlZFNpemUgPSBudWxsO1xuICAgICAgICB0aGlzLm1pblNpemUgPSAxOyAvLyArMSBmb3IgdGhlIGV4dHJhIHBhZGRpbmcgYml0XG4gICAgICAgIHRoaXMuaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxpbWl0Qml0cyA9PT0gMClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTGlzdCBsaW1pdCBtdXN0IGJlID4gMFwiKTtcbiAgICAgICAgdGhpcy50eXBlTmFtZSA9IG9wdHM/LnR5cGVOYW1lID8/IGBCaXRMaXN0WyR7bGltaXRCaXRzfV1gO1xuICAgICAgICAvLyBUT0RPIENoZWNrIHRoYXQgaXRlbXNQZXJDaHVuayBpcyBhbiBpbnRlZ2VyXG4gICAgICAgIHRoaXMubWF4Q2h1bmtDb3VudCA9IE1hdGguY2VpbCh0aGlzLmxpbWl0Qml0cyAvIDggLyAzMik7XG4gICAgICAgIHRoaXMuY2h1bmtEZXB0aCA9IG1lcmtsZWl6ZV8xLm1heENodW5rc1RvRGVwdGgodGhpcy5tYXhDaHVua0NvdW50KTtcbiAgICAgICAgLy8gRGVwdGggaW5jbHVkZXMgdGhlIGV4dHJhIGxldmVsIGZvciB0aGUgbGVuZ3RoIG5vZGVcbiAgICAgICAgdGhpcy5kZXB0aCA9IDEgKyB0aGlzLmNodW5rRGVwdGg7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IE1hdGguY2VpbChsaW1pdEJpdHMgLyA4KSArIDE7IC8vICsxIGZvciB0aGUgZXh0cmEgcGFkZGluZyBiaXRcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGxpbWl0Qml0cywgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lZF8xLm5hbWVkQ2xhc3MoQml0TGlzdFR5cGUsIG9wdHMudHlwZU5hbWUpKShsaW1pdEJpdHMsIG9wdHMpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBiaXRBcnJheV8xLkJpdEFycmF5LmZyb21CaXRMZW4oMCk7XG4gICAgfVxuICAgIC8vIFZpZXdzOiBpbmhlcml0ZWQgZnJvbSBCaXRBcnJheVR5cGVcbiAgICAvLyBTZXJpYWxpemF0aW9uICsgZGVzZXJpYWxpemF0aW9uXG4gICAgdmFsdWVfc2VyaWFsaXplZFNpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJpdExlblRvU2VyaWFsaXplZExlbmd0aCh2YWx1ZS5iaXRMZW4pO1xuICAgIH1cbiAgICB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBvdXRwdXQudWludDhBcnJheS5zZXQodmFsdWUudWludDhBcnJheSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5UGFkZGluZ0JpdChvdXRwdXQudWludDhBcnJheSwgb2Zmc2V0LCB2YWx1ZS5iaXRMZW4pO1xuICAgIH1cbiAgICB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHsgdWludDhBcnJheSwgYml0TGVuIH0gPSB0aGlzLmRlc2VyaWFsaXplVWludDhBcnJheUJpdExpc3RGcm9tQnl0ZXMoZGF0YS51aW50OEFycmF5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBiaXRBcnJheV8xLkJpdEFycmF5KHVpbnQ4QXJyYXksIGJpdExlbik7XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplZFNpemUobm9kZSkge1xuICAgICAgICByZXR1cm4gYml0TGVuVG9TZXJpYWxpemVkTGVuZ3RoKGFycmF5QmFzaWNfMS5nZXRMZW5ndGhGcm9tUm9vdE5vZGUobm9kZSkpO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzTm9kZSA9IGFycmF5QmFzaWNfMS5nZXRDaHVua3NOb2RlRnJvbVJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBjb25zdCBiaXRMZW4gPSBhcnJheUJhc2ljXzEuZ2V0TGVuZ3RoRnJvbVJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBjb25zdCBieXRlTGVuID0gTWF0aC5jZWlsKGJpdExlbiAvIDgpO1xuICAgICAgICBjb25zdCBjaHVua0xlbiA9IE1hdGguY2VpbChieXRlTGVuIC8gMzIpO1xuICAgICAgICBjb25zdCBub2RlcyA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2Rlc0F0RGVwdGgoY2h1bmtzTm9kZSwgdGhpcy5jaHVua0RlcHRoLCAwLCBjaHVua0xlbik7XG4gICAgICAgIHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5wYWNrZWROb2RlUm9vdHNUb0J5dGVzKG91dHB1dC5kYXRhVmlldywgb2Zmc2V0LCBieXRlTGVuLCBub2Rlcyk7XG4gICAgICAgIHJldHVybiBhcHBseVBhZGRpbmdCaXQob3V0cHV0LnVpbnQ4QXJyYXksIG9mZnNldCwgYml0TGVuKTtcbiAgICB9XG4gICAgdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHsgdWludDhBcnJheSwgYml0TGVuIH0gPSB0aGlzLmRlc2VyaWFsaXplVWludDhBcnJheUJpdExpc3RGcm9tQnl0ZXMoZGF0YS51aW50OEFycmF5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodWludDhBcnJheS5idWZmZXIsIHVpbnQ4QXJyYXkuYnl0ZU9mZnNldCwgdWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2h1bmtzTm9kZSA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5wYWNrZWRSb290c0J5dGVzVG9Ob2RlKHRoaXMuY2h1bmtEZXB0aCwgZGF0YVZpZXcsIDAsIHVpbnQ4QXJyYXkubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGFycmF5QmFzaWNfMS5hZGRMZW5ndGhOb2RlKGNodW5rc05vZGUsIGJpdExlbik7XG4gICAgfVxuICAgIHRyZWVfZ2V0Qnl0ZUxlbihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpdExpc3RUeXBlIHJlcXVpcmVzIGEgbm9kZSB0byBnZXQgbGVhdmVzXCIpO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGFycmF5QmFzaWNfMS5nZXRMZW5ndGhGcm9tUm9vdE5vZGUobm9kZSkgLyA4KTtcbiAgICB9XG4gICAgLy8gTWVya2xlaXphdGlvbjogaW5oZXJpdGVkIGZyb20gQml0QXJyYXlUeXBlXG4gICAgaGFzaFRyZWVSb290KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtZXJrbGVpemVfMS5taXhJbkxlbmd0aChzdXBlci5oYXNoVHJlZVJvb3QodmFsdWUpLCB2YWx1ZS5iaXRMZW4pO1xuICAgIH1cbiAgICAvLyBQcm9vZnM6IGluaGVyaXRlZCBmcm9tIEJpdEFycmF5VHlwZVxuICAgIC8vIEpTT046IGluaGVyaXRlZCBmcm9tIEJpdEFycmF5VHlwZVxuICAgIC8vIERlc2VyaWFsaXplciBoZWxwZXJzXG4gICAgZGVzZXJpYWxpemVVaW50OEFycmF5Qml0TGlzdEZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHsgdWludDhBcnJheSwgYml0TGVuIH0gPSBkZXNlcmlhbGl6ZVVpbnQ4QXJyYXlCaXRMaXN0RnJvbUJ5dGVzKGRhdGEsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAoYml0TGVuID4gdGhpcy5saW1pdEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBiaXRMZW4gb3ZlciBsaW1pdCAke2JpdExlbn0gPiAke3RoaXMubGltaXRCaXRzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVpbnQ4QXJyYXksIGJpdExlbiB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQml0TGlzdFR5cGUgPSBCaXRMaXN0VHlwZTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplVWludDhBcnJheUJpdExpc3RGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgQml0TGlzdCBhdHRlbXB0aW5nIHRvIHJlYWQgYnl0ZSAke2VuZH0gb2YgZGF0YSBsZW5ndGggJHtkYXRhLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdEJ5dGUgPSBkYXRhW2VuZCAtIDFdO1xuICAgIGNvbnN0IHNpemUgPSBlbmQgLSBzdGFydDtcbiAgICBpZiAobGFzdEJ5dGUgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkZXNlcmlhbGl6ZWQgYml0bGlzdCwgcGFkZGluZyBiaXQgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmIChsYXN0Qnl0ZSA9PT0gMSkge1xuICAgICAgICAvLyBCdWZmZXIucHJvdG90eXBlLnNsaWNlIGRvZXMgbm90IGNvcHkgbWVtb3J5LCBFbmZvcmNlIFVpbnQ4QXJyYXkgdXNhZ2UgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yODA4N1xuICAgICAgICBjb25zdCB1aW50OEFycmF5ID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhLCBzdGFydCwgZW5kIC0gMSk7XG4gICAgICAgIGNvbnN0IGJpdExlbiA9IChzaXplIC0gMSkgKiA4O1xuICAgICAgICByZXR1cm4geyB1aW50OEFycmF5LCBiaXRMZW4gfTtcbiAgICB9XG4gICAgLy8gdGhlIGxhc3QgYnl0ZSBpcyA+IDEsIHNvIGEgcGFkZGluZyBiaXQgd2lsbCBleGlzdCBpbiB0aGUgbGFzdCBieXRlIGFuZCBuZWVkIHRvIGJlIHJlbW92ZWRcbiAgICAvLyBCdWZmZXIucHJvdG90eXBlLnNsaWNlIGRvZXMgbm90IGNvcHkgbWVtb3J5LCBFbmZvcmNlIFVpbnQ4QXJyYXkgdXNhZ2UgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yODA4N1xuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEsIHN0YXJ0LCBlbmQpO1xuICAgIC8vIG1hc2sgbGFzdENodW5rQnl0ZVxuICAgIGNvbnN0IGxhc3RCeXRlQml0TGVuZ3RoID0gbGFzdEJ5dGUudG9TdHJpbmcoMikubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBiaXRMZW4gPSAoc2l6ZSAtIDEpICogOCArIGxhc3RCeXRlQml0TGVuZ3RoO1xuICAgIGNvbnN0IG1hc2sgPSAweGZmID4+ICg4IC0gbGFzdEJ5dGVCaXRMZW5ndGgpO1xuICAgIHVpbnQ4QXJyYXlbc2l6ZSAtIDFdICY9IG1hc2s7XG4gICAgcmV0dXJuIHsgdWludDhBcnJheSwgYml0TGVuIH07XG59XG5mdW5jdGlvbiBiaXRMZW5Ub1NlcmlhbGl6ZWRMZW5ndGgoYml0TGVuKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBNYXRoLmNlaWwoYml0TGVuIC8gOCk7XG4gICAgLy8gKzEgZm9yIHRoZSBleHRyYSBwYWRkaW5nIGJpdFxuICAgIHJldHVybiBiaXRMZW4gJSA4ID09PSAwID8gYnl0ZXMgKyAxIDogYnl0ZXM7XG59XG4vKipcbiAqIEFwcGx5IHBhZGRpbmcgYml0IHRvIGEgc2VyaWFsaXplZCBCaXRMaXN0IGFscmVhZHkgd3JpdHRlbiB0byBgb3V0cHV0YCBhdCBgb2Zmc2V0YFxuICogQHJldHVybnMgTmV3IG9mZnNldCBhZnRlciAobWF5YmUpIHdyaXR0aW5nIGEgcGFkZGluZyBiaXQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UGFkZGluZ0JpdChvdXRwdXQsIG9mZnNldCwgYml0TGVuKSB7XG4gICAgY29uc3QgYnl0ZUxlbiA9IE1hdGguY2VpbChiaXRMZW4gLyA4KTtcbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBieXRlTGVuO1xuICAgIGlmIChiaXRMZW4gJSA4ID09PSAwKSB7XG4gICAgICAgIG91dHB1dFtuZXdPZmZzZXRdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld09mZnNldCArIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXRbbmV3T2Zmc2V0IC0gMV0gfD0gMSA8PCBiaXRMZW4gJSA4O1xuICAgICAgICByZXR1cm4gbmV3T2Zmc2V0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdExpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpdFZlY3RvclR5cGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgbWVya2xlaXplXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJrbGVpemVcIik7XG5jb25zdCBuYW1lZF8xID0gcmVxdWlyZShcIi4uL3V0aWwvbmFtZWRcIik7XG5jb25zdCBiaXRBcnJheV8xID0gcmVxdWlyZShcIi4uL3ZhbHVlL2JpdEFycmF5XCIpO1xuY29uc3QgYml0QXJyYXlfMiA9IHJlcXVpcmUoXCIuL2JpdEFycmF5XCIpO1xuLyoqXG4gKiBCaXRWZWN0b3I6IG9yZGVyZWQgZml4ZWQtbGVuZ3RoIGNvbGxlY3Rpb24gb2YgYm9vbGVhbiB2YWx1ZXMsIHdpdGggTiBiaXRzXG4gKiAtIE5vdGF0aW9uOiBgQml0dmVjdG9yW05dYFxuICogLSBWYWx1ZTogYEJpdEFycmF5YCwgQHNlZSBCaXRBcnJheSBmb3IgYSBqdXN0aWZpY2F0aW9uIG9mIGl0cyBtZW1vcnkgZWZmaWNpZW5jeSBhbmQgcGVyZm9ybWFuY2VcbiAqIC0gVmlldzogYEJpdEFycmF5VHJlZVZpZXdgXG4gKiAtIFZpZXdEVTogYEJpdEFycmF5VHJlZVZpZXdEVWBcbiAqL1xuY2xhc3MgQml0VmVjdG9yVHlwZSBleHRlbmRzIGJpdEFycmF5XzIuQml0QXJyYXlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGhCaXRzLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGVuZ3RoQml0cyA9IGxlbmd0aEJpdHM7XG4gICAgICAgIHRoaXMuaXNMaXN0ID0gZmFsc2U7XG4gICAgICAgIGlmIChsZW5ndGhCaXRzID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJWZWN0b3IgbGVuZ3RoIG11c3QgYmUgPiAwXCIpO1xuICAgICAgICB0aGlzLnR5cGVOYW1lID0gb3B0cz8udHlwZU5hbWUgPz8gYEJpdFZlY3Rvclske2xlbmd0aEJpdHN9XWA7XG4gICAgICAgIHRoaXMuY2h1bmtDb3VudCA9IE1hdGguY2VpbCh0aGlzLmxlbmd0aEJpdHMgLyA4IC8gMzIpO1xuICAgICAgICB0aGlzLm1heENodW5rQ291bnQgPSB0aGlzLmNodW5rQ291bnQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBtZXJrbGVpemVfMS5tYXhDaHVua3NUb0RlcHRoKHRoaXMuY2h1bmtDb3VudCk7XG4gICAgICAgIHRoaXMuZml4ZWRTaXplID0gTWF0aC5jZWlsKHRoaXMubGVuZ3RoQml0cyAvIDgpO1xuICAgICAgICB0aGlzLm1pblNpemUgPSB0aGlzLmZpeGVkU2l6ZTtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gdGhpcy5maXhlZFNpemU7XG4gICAgICAgIC8vIFRvIGNhY2hlIG1hc2sgZm9yIHRyYWlsaW5nIHplcm8gYml0cyB2YWxpZGF0aW9uXG4gICAgICAgIHRoaXMuemVyb0JpdHNNYXNrID0gbGVuZ3RoQml0cyAlIDggPT09IDAgPyAwIDogMHhmZiAmICgweGZmIDw8IGxlbmd0aEJpdHMgJSA4KTtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGxpbWl0Qml0cywgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lZF8xLm5hbWVkQ2xhc3MoQml0VmVjdG9yVHlwZSwgb3B0cy50eXBlTmFtZSkpKGxpbWl0Qml0cywgb3B0cyk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGJpdEFycmF5XzEuQml0QXJyYXkuZnJvbUJpdExlbih0aGlzLmxlbmd0aEJpdHMpO1xuICAgIH1cbiAgICAvLyBWaWV3czogaW5oZXJpdGVkIGZyb20gQml0QXJyYXlUeXBlXG4gICAgLy8gU2VyaWFsaXphdGlvbiArIGRlc2VyaWFsaXphdGlvblxuICAgIHZhbHVlX3NlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXhlZFNpemU7XG4gICAgfVxuICAgIHZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIG91dHB1dC51aW50OEFycmF5LnNldCh2YWx1ZS51aW50OEFycmF5LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5maXhlZFNpemU7XG4gICAgfVxuICAgIHZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZExlbmd0aChkYXRhLnVpbnQ4QXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgICAgICAvLyBCdWZmZXIucHJvdG90eXBlLnNsaWNlIGRvZXMgbm90IGNvcHkgbWVtb3J5LCBFbmZvcmNlIFVpbnQ4QXJyYXkgdXNhZ2UgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yODA4N1xuICAgICAgICByZXR1cm4gbmV3IGJpdEFycmF5XzEuQml0QXJyYXkoVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhLnVpbnQ4QXJyYXksIHN0YXJ0LCBlbmQpLCB0aGlzLmxlbmd0aEJpdHMpO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXhlZFNpemU7XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgbm9kZSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2Rlc0F0RGVwdGgobm9kZSwgdGhpcy5kZXB0aCwgMCwgdGhpcy5jaHVua0NvdW50KTtcbiAgICAgICAgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLnBhY2tlZE5vZGVSb290c1RvQnl0ZXMob3V0cHV0LmRhdGFWaWV3LCBvZmZzZXQsIHRoaXMuZml4ZWRTaXplLCBub2Rlcyk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLmZpeGVkU2l6ZTtcbiAgICB9XG4gICAgdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRMZW5ndGgoZGF0YS51aW50OEFycmF5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5wYWNrZWRSb290c0J5dGVzVG9Ob2RlKHRoaXMuZGVwdGgsIGRhdGEuZGF0YVZpZXcsIHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICB0cmVlX2dldEJ5dGVMZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpeGVkU2l6ZTtcbiAgICB9XG4gICAgLy8gTWVya2xlaXphdGlvbjogaW5oZXJpdGVkIGZyb20gQml0QXJyYXlUeXBlXG4gICAgLy8gUHJvb2ZzOiBpbmhlcml0ZWQgZnJvbSBCaXRBcnJheVR5cGVcbiAgICAvLyBKU09OOiBpbmhlcml0ZWQgZnJvbSBCaXRBcnJheVR5cGVcbiAgICAvLyBEZXNlcmlhbGl6ZXIgaGVscGVyc1xuICAgIGFzc2VydFZhbGlkTGVuZ3RoKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgIT09IHRoaXMuZml4ZWRTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBCaXRWZWN0b3Igc2l6ZSAke3NpemV9ICE9ICR7dGhpcy5maXhlZFNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbGVuZ3RoQml0cyBpcyBub3QgYWxpZ25lZCB0byBieXRlcywgZW5zdXJlIHRyYWlsaW5nIGJpdHMgYXJlIHplcm9lZFxuICAgICAgICBpZiAoXG4gICAgICAgIC8vIElmIHplcm9CaXRzTWFzayA9PSAwLCB0aGVuIHRoZSBCaXRWZWN0b3IgdXNlcyBmdWxsIGJ5dGVzIG9ubHlcbiAgICAgICAgdGhpcy56ZXJvQml0c01hc2sgPiAwICYmXG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFzdCBieXRlIGlzIHBhcnRpYWwsIHJldHJpZXZlIGl0IGFuZCB1c2UgdGhlIGNhY2hlZCBtYXNrIHRvIGNoZWNrIGlmIHRyYWlsaW5nIGJpdHMgYXJlIHplcm9lZFxuICAgICAgICAgICAgKGRhdGFbZW5kIC0gMV0gJiB0aGlzLnplcm9CaXRzTWFzaykgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpdFZlY3Rvcjogbm9uemVybyBiaXRzIHBhc3QgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CaXRWZWN0b3JUeXBlID0gQml0VmVjdG9yVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdFZlY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQm9vbGVhblR5cGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgbmFtZWRfMSA9IHJlcXVpcmUoXCIuLi91dGlsL25hbWVkXCIpO1xuY29uc3QgYmFzaWNfMSA9IHJlcXVpcmUoXCIuL2Jhc2ljXCIpO1xuLyoqXG4gKiBCb29sZWFuOiBUcnVlIG9yIEZhbHNlXG4gKiAtIE5vdGF0aW9uOiBgYm9vbGVhbmBcbiAqL1xuY2xhc3MgQm9vbGVhblR5cGUgZXh0ZW5kcyBiYXNpY18xLkJhc2ljVHlwZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAxO1xuICAgICAgICB0aGlzLml0ZW1zUGVyQ2h1bmsgPSAzMjtcbiAgICAgICAgdGhpcy5maXhlZFNpemUgPSAxO1xuICAgICAgICB0aGlzLm1pblNpemUgPSAxO1xuICAgICAgICB0aGlzLm1heFNpemUgPSAxO1xuICAgICAgICB0aGlzLnR5cGVOYW1lID0gb3B0cz8udHlwZU5hbWUgPz8gXCJib29sZWFuXCI7XG4gICAgfVxuICAgIHN0YXRpYyBuYW1lZChvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgKG5hbWVkXzEubmFtZWRDbGFzcyhCb29sZWFuVHlwZSwgb3B0cy50eXBlTmFtZSkpKG9wdHMpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gU2VyaWFsaXphdGlvbiArIGRlc2VyaWFsaXphdGlvblxuICAgIHZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIG91dHB1dC51aW50OEFycmF5W29mZnNldF0gPSB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbiAgICB9XG4gICAgdmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkU2l6ZShlbmQgLSBzdGFydCk7XG4gICAgICAgIHN3aXRjaCAoZGF0YS51aW50OEFycmF5W3N0YXJ0XSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCb29sZWFuOiBpbnZhbGlkIHZhbHVlOiAke2RhdGEudWludDhBcnJheVtzdGFydF19YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJlZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCBub2RlKSB7XG4gICAgICAgIC8vIFRPRE86IEFzc3VtZXMgTGVhZk5vZGUgaGFzIDQgYnl0ZSB1aW50cyBhcmUgcHJpbWFyeSB1bml0XG4gICAgICAgIG91dHB1dC51aW50OEFycmF5W29mZnNldF0gPSBub2RlLmdldFVpbnQoNCwgMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICAgIH1cbiAgICB0cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZFNpemUoZW5kIC0gc3RhcnQpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEudWludDhBcnJheVtzdGFydF07XG4gICAgICAgIGlmICh2YWx1ZSA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBCb29sZWFuOiBpbnZhbGlkIHZhbHVlICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5MZWFmTm9kZS5mcm9tVWludDMyKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gRmFzdCB0cmVlIG9wdHNcbiAgICB0cmVlX2dldEZyb21Ob2RlKGxlYWZOb2RlKSB7XG4gICAgICAgIHJldHVybiBsZWFmTm9kZS5nZXRVaW50KDQsIDApID09PSAxO1xuICAgIH1cbiAgICB0cmVlX3NldFRvTm9kZShsZWFmTm9kZSwgdmFsdWUpIHtcbiAgICAgICAgbGVhZk5vZGUuc2V0VWludCg0LCAwLCB2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgdHJlZV9nZXRGcm9tUGFja2VkTm9kZShsZWFmTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0Qnl0ZXMgPSBpbmRleCAlIHRoaXMuaXRlbXNQZXJDaHVuaztcbiAgICAgICAgcmV0dXJuIGxlYWZOb2RlLmdldFVpbnQoMSwgb2Zmc2V0Qnl0ZXMpICE9PSAwO1xuICAgIH1cbiAgICB0cmVlX3NldFRvUGFja2VkTm9kZShsZWFmTm9kZSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEJ5dGVzID0gaW5kZXggJSB0aGlzLml0ZW1zUGVyQ2h1bms7XG4gICAgICAgIGxlYWZOb2RlLnNldFVpbnQoMSwgb2Zmc2V0Qnl0ZXMsIHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICAvLyBKU09OXG4gICAgZnJvbUpzb24oanNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgSlNPTiBpbnZhbGlkIHR5cGUgJHt0eXBlb2YganNvbn0gZXhwZWN0ZWQgYm9vbGVhbmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICB0b0pzb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQm9vbGVhblR5cGUgPSBCb29sZWFuVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xlYW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ5dGVBcnJheVR5cGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgYnl0ZUFycmF5XzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ieXRlQXJyYXlcIik7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IGNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4vY29tcG9zaXRlXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZyAqL1xuLyoqXG4gKiBCeXRlQXJyYXk6IG9yZGVyZWQgYXJyYXkgY29sbGVjdGlvbiBvZiBieXRlIHZhbHVlc1xuICogLSBWYWx1ZTogYFVpbnQ4QXJyYXlgXG4gKiAtIFZpZXc6IGBVaW50OEFycmF5YFxuICogLSBWaWV3RFU6IGBVaW50OEFycmF5YFxuICpcbiAqIEJ5dGVBcnJheSBpcyBhbiBpbW11dGFibGUgdmFsdWUgd2hpY2ggaXMgcmVwcmVzZW50ZWQgYnkgYSBVaW50OEFycmF5IGZvciBtZW1vcnkgZWZmaWNpZW5jeSBhbmQgcGVyZm9ybWFuY2UuXG4gKiBOb3RlOiBDb25zdW1lcnMgb2YgdGhpcyB0eXBlIE1VU1QgbmV2ZXIgbXV0YXRlIHRoZSBgVWludDhBcnJheWAgcmVwcmVzZW50YXRpb24gb2YgYSBCeXRlQXJyYXkuXG4gKi9cbmNsYXNzIEJ5dGVBcnJheVR5cGUgZXh0ZW5kcyBjb21wb3NpdGVfMS5Db21wb3NpdGVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pc1ZpZXdNdXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gU2luY2UgaXQncyBhIGJ5dGUgYXJyYXkgdGhlIG1pblNpemUgaXMgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5taW5TaXplKTtcbiAgICB9XG4gICAgZ2V0Vmlldyh0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZpZXdEVSh0cmVlLnJvb3ROb2RlKTtcbiAgICB9XG4gICAgZ2V0Vmlld0RVKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZV90b1ZhbHVlKG5vZGUpO1xuICAgIH1cbiAgICBjb21taXRWaWV3KHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWl0Vmlld0RVKHZpZXcpO1xuICAgIH1cbiAgICBjb21taXRWaWV3RFUodmlldykge1xuICAgICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZV9zZXJpYWxpemVkU2l6ZSh2aWV3KSk7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFsdWVfc2VyaWFsaXplVG9CeXRlcyh7IHVpbnQ4QXJyYXksIGRhdGFWaWV3IH0sIDAsIHZpZXcpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKHsgdWludDhBcnJheSwgZGF0YVZpZXcgfSwgMCwgdWludDhBcnJheS5sZW5ndGgpO1xuICAgIH1cbiAgICBjYWNoZU9mVmlld0RVKCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE92ZXItd3JpdGUgdG8gcHJldmVudCBzZXJpYWxpemUgKyBkZXNlcmlhbGl6ZVxuICAgIHRvVmlldyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRvVmlld0RVKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VyaWFsaXphdGlvbiArIGRlc2VyaWFsaXphdGlvbiAob25seSB2YWx1ZSBpcyBnZW5lcmljKVxuICAgIHZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIG91dHB1dC51aW50OEFycmF5LnNldCh2YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgdmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkU2l6ZShlbmQgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEudWludDhBcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8vIE1lcmtsZWl6YXRpb25cbiAgICBnZXRSb290cyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbWVya2xlaXplXzEuc3BsaXRJbnRvUm9vdENodW5rcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFByb29mc1xuICAgIGdldFByb3BlcnR5R2luZGV4KCkge1xuICAgICAgICAvLyBTdG9wIG5hdmlnYXRpbmcgYmVsb3cgdGhpcyB0eXBlLiBNdXN0IG9ubHkgcmVxdWVzdCBjb21wbGV0ZSBkYXRhXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRQcm9wZXJ0eVR5cGUoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiTXVzdCBvbmx5IHJlcXVlc3QgQnl0ZUFycmF5IGNvbXBsZXRlIGRhdGFcIik7XG4gICAgfVxuICAgIGdldEluZGV4UHJvcGVydHkoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiTXVzdCBvbmx5IHJlcXVlc3QgQnl0ZUFycmF5IGNvbXBsZXRlIGRhdGFcIik7XG4gICAgfVxuICAgIHRyZWVfZnJvbVByb29mTm9kZShub2RlKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGRvbmU6IHRydWUgfTtcbiAgICB9XG4gICAgdHJlZV9nZXRMZWFmR2luZGljZXMocm9vdEdpbmRleCwgcm9vdE5vZGUpIHtcbiAgICAgICAgY29uc3QgYnl0ZUxlbiA9IHRoaXMudHJlZV9nZXRCeXRlTGVuKHJvb3ROb2RlKTtcbiAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IE1hdGguY2VpbChieXRlTGVuIC8gMzIpO1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmNvbmNhdEdpbmRpY2VzKFtyb290R2luZGV4LCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEudG9HaW5kZXgodGhpcy5kZXB0aCwgQmlnSW50KDApKV0pO1xuICAgICAgICBjb25zdCBnaW5kaWNlcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGdpbmRleCA9IHN0YXJ0SW5kZXg7IGkgPCBjaHVua0NvdW50OyBpKyssIGdpbmRleCsrKSB7XG4gICAgICAgICAgICBnaW5kaWNlc1tpXSA9IGdpbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNsdWRlIHRoZSBsZW5ndGggY2h1bmtcbiAgICAgICAgaWYgKHRoaXMuaXNMaXN0KSB7XG4gICAgICAgICAgICBnaW5kaWNlcy5wdXNoKHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5jb25jYXRHaW5kaWNlcyhbcm9vdEdpbmRleCwgY29tcG9zaXRlXzEuTEVOR1RIX0dJTkRFWF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2luZGljZXM7XG4gICAgfVxuICAgIC8vIEpTT05cbiAgICBmcm9tSnNvbihqc29uKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZUFycmF5XzEuZnJvbUhleFN0cmluZyhqc29uKTtcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZFNpemUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0b0pzb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheV8xLnRvSGV4U3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gQnl0ZUFycmF5IGlzIGltbXV0YWJsZVxuICAgIGNsb25lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheV8xLmJ5dGVBcnJheUVxdWFscyhhLCBiKTtcbiAgICB9XG59XG5leHBvcnRzLkJ5dGVBcnJheVR5cGUgPSBCeXRlQXJyYXlUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZUFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CeXRlTGlzdFR5cGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgbWVya2xlaXplXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJrbGVpemVcIik7XG5jb25zdCBuYW1lZF8xID0gcmVxdWlyZShcIi4uL3V0aWwvbmFtZWRcIik7XG5jb25zdCBhcnJheUJhc2ljXzEgPSByZXF1aXJlKFwiLi9hcnJheUJhc2ljXCIpO1xuY29uc3QgYnl0ZUFycmF5XzEgPSByZXF1aXJlKFwiLi9ieXRlQXJyYXlcIik7XG4vKipcbiAqIEJ5dGVMaXN0OiBJbW11dGFibGUgYWxpYXMgb2YgTGlzdFtieXRlLCBOXVxuICogLSBOb3RhdGlvbjogYEJ5dGVMaXN0W05dYFxuICogLSBWYWx1ZTogYFVpbnQ4QXJyYXlgXG4gKiAtIFZpZXc6IGBVaW50OEFycmF5YFxuICogLSBWaWV3RFU6IGBVaW50OEFycmF5YFxuICpcbiAqIEJ5dGVMaXN0IGlzIGFuIGltbXV0YWJsZSB2YWx1ZSB3aGljaCBpcyByZXByZXNlbnRlZCBieSBhIFVpbnQ4QXJyYXkgZm9yIG1lbW9yeSBlZmZpY2llbmN5IGFuZCBwZXJmb3JtYW5jZS5cbiAqIE5vdGU6IENvbnN1bWVycyBvZiB0aGlzIHR5cGUgTVVTVCBuZXZlciBtdXRhdGUgdGhlIGBVaW50OEFycmF5YCByZXByZXNlbnRhdGlvbiBvZiBhIEJ5dGVMaXN0LlxuICpcbiAqIEZvciBhIGBCeXRlTGlzdFR5cGVgIHdpdGggbXV0YWJpbGl0eSwgdXNlIGBMaXN0QmFzaWNUeXBlKGJ5dGVUeXBlKWBcbiAqL1xuY2xhc3MgQnl0ZUxpc3RUeXBlIGV4dGVuZHMgYnl0ZUFycmF5XzEuQnl0ZUFycmF5VHlwZSB7XG4gICAgY29uc3RydWN0b3IobGltaXRCeXRlcywgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxpbWl0Qnl0ZXMgPSBsaW1pdEJ5dGVzO1xuICAgICAgICB0aGlzLmZpeGVkU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxpbWl0Qnl0ZXMgPT09IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkxpc3QgbGltaXQgbXVzdCBiZSA+IDBcIik7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBvcHRzPy50eXBlTmFtZSA/PyBgQnl0ZUxpc3RbJHtsaW1pdEJ5dGVzfV1gO1xuICAgICAgICB0aGlzLm1heENodW5rQ291bnQgPSBNYXRoLmNlaWwodGhpcy5saW1pdEJ5dGVzIC8gMzIpO1xuICAgICAgICB0aGlzLmNodW5rRGVwdGggPSBtZXJrbGVpemVfMS5tYXhDaHVua3NUb0RlcHRoKHRoaXMubWF4Q2h1bmtDb3VudCk7XG4gICAgICAgIHRoaXMuZGVwdGggPSAxICsgdGhpcy5jaHVua0RlcHRoO1xuICAgICAgICB0aGlzLm1pblNpemUgPSAwO1xuICAgICAgICB0aGlzLm1heFNpemUgPSB0aGlzLmxpbWl0Qnl0ZXM7XG4gICAgfVxuICAgIHN0YXRpYyBuYW1lZChsaW1pdEJpdHMsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAobmFtZWRfMS5uYW1lZENsYXNzKEJ5dGVMaXN0VHlwZSwgb3B0cy50eXBlTmFtZSkpKGxpbWl0Qml0cywgb3B0cyk7XG4gICAgfVxuICAgIC8vIFZpZXdzOiBpbmhlcml0ZWQgZnJvbSBCeXRlQXJyYXlUeXBlXG4gICAgLy8gU2VyaWFsaXphdGlvbiArIGRlc2VyaWFsaXphdGlvblxuICAgIHZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIC8vIHZhbHVlXyogaW5oZXJpdGVkIGZyb20gQnl0ZUFycmF5VHlwZVxuICAgIHRyZWVfc2VyaWFsaXplZFNpemUobm9kZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLmdldExlbmd0aEZyb21Sb290Tm9kZShub2RlKTtcbiAgICB9XG4gICAgdHJlZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IGNodW5rc05vZGUgPSBhcnJheUJhc2ljXzEuZ2V0Q2h1bmtzTm9kZUZyb21Sb290Tm9kZShub2RlKTtcbiAgICAgICAgY29uc3QgYnl0ZUxlbiA9IGFycmF5QmFzaWNfMS5nZXRMZW5ndGhGcm9tUm9vdE5vZGUobm9kZSk7XG4gICAgICAgIGNvbnN0IGNodW5rTGVuID0gTWF0aC5jZWlsKGJ5dGVMZW4gLyAzMik7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmdldE5vZGVzQXREZXB0aChjaHVua3NOb2RlLCB0aGlzLmNodW5rRGVwdGgsIDAsIGNodW5rTGVuKTtcbiAgICAgICAgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLnBhY2tlZE5vZGVSb290c1RvQnl0ZXMob3V0cHV0LmRhdGFWaWV3LCBvZmZzZXQsIGJ5dGVMZW4sIG5vZGVzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW47XG4gICAgfVxuICAgIHRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkU2l6ZShlbmQgLSBzdGFydCk7XG4gICAgICAgIGNvbnN0IGNodW5rc05vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEucGFja2VkUm9vdHNCeXRlc1RvTm9kZSh0aGlzLmNodW5rRGVwdGgsIGRhdGEuZGF0YVZpZXcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLmFkZExlbmd0aE5vZGUoY2h1bmtzTm9kZSwgZW5kIC0gc3RhcnQpO1xuICAgIH1cbiAgICB0cmVlX2dldEJ5dGVMZW4obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCeXRlTGlzdFR5cGUgcmVxdWlyZXMgYSBub2RlIHRvIGdldCBsZWF2ZXNcIik7XG4gICAgICAgIHJldHVybiBhcnJheUJhc2ljXzEuZ2V0TGVuZ3RoRnJvbVJvb3ROb2RlKG5vZGUpO1xuICAgIH1cbiAgICAvLyBNZXJrbGVpemF0aW9uOiBpbmhlcml0ZWQgZnJvbSBCeXRlQXJyYXlUeXBlXG4gICAgaGFzaFRyZWVSb290KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtZXJrbGVpemVfMS5taXhJbkxlbmd0aChzdXBlci5oYXNoVHJlZVJvb3QodmFsdWUpLCB2YWx1ZS5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBQcm9vZnM6IGluaGVyaXRlZCBmcm9tIEJpdEFycmF5VHlwZVxuICAgIC8vIEpTT046IGluaGVyaXRlZCBmcm9tIEJ5dGVBcnJheVR5cGVcbiAgICBhc3NlcnRWYWxpZFNpemUoc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA+IHRoaXMubGltaXRCeXRlcykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEJ5dGVMaXN0IGludmFsaWQgc2l6ZSAke3NpemV9IGxpbWl0ICR7dGhpcy5saW1pdEJ5dGVzfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CeXRlTGlzdFR5cGUgPSBCeXRlTGlzdFR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnl0ZVZlY3RvclR5cGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgbWVya2xlaXplXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJrbGVpemVcIik7XG5jb25zdCBuYW1lZF8xID0gcmVxdWlyZShcIi4uL3V0aWwvbmFtZWRcIik7XG5jb25zdCBieXRlQXJyYXlfMSA9IHJlcXVpcmUoXCIuL2J5dGVBcnJheVwiKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmcgKi9cbi8qKlxuICogQnl0ZVZlY3RvcjogSW1tdXRhYmxlIGFsaWFzIG9mIFZlY3RvcltieXRlLCBOXVxuICogLSBOb3RhdGlvbjogYEJ5dGVWZWN0b3JbTl1gXG4gKiAtIFZhbHVlOiBgVWludDhBcnJheWBcbiAqIC0gVmlldzogYFVpbnQ4QXJyYXlgXG4gKiAtIFZpZXdEVTogYFVpbnQ4QXJyYXlgXG4gKlxuICogQnl0ZVZlY3RvciBpcyBhbiBpbW11dGFibGUgdmFsdWUgd2hpY2ggaXMgcmVwcmVzZW50ZWQgYnkgYSBVaW50OEFycmF5IGZvciBtZW1vcnkgZWZmaWNpZW5jeSBhbmQgcGVyZm9ybWFuY2UuXG4gKiBOb3RlOiBDb25zdW1lcnMgb2YgdGhpcyB0eXBlIE1VU1QgbmV2ZXIgbXV0YXRlIHRoZSBgVWludDhBcnJheWAgcmVwcmVzZW50YXRpb24gb2YgYSBCeXRlVmVjdG9yLlxuICpcbiAqIEZvciBhIGBCeXRlVmVjdG9yVHlwZWAgd2l0aCBtdXRhYmlsaXR5LCB1c2UgYFZlY3RvckJhc2ljVHlwZShieXRlVHlwZSlgXG4gKi9cbmNsYXNzIEJ5dGVWZWN0b3JUeXBlIGV4dGVuZHMgYnl0ZUFycmF5XzEuQnl0ZUFycmF5VHlwZSB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoQnl0ZXMsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sZW5ndGhCeXRlcyA9IGxlbmd0aEJ5dGVzO1xuICAgICAgICB0aGlzLmlzTGlzdCA9IGZhbHNlO1xuICAgICAgICBpZiAobGVuZ3RoQnl0ZXMgPT09IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlZlY3RvciBsZW5ndGggbXVzdCBiZSA+IDBcIik7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBvcHRzPy50eXBlTmFtZSA/PyBgQnl0ZVZlY3Rvclske2xlbmd0aEJ5dGVzfV1gO1xuICAgICAgICB0aGlzLm1heENodW5rQ291bnQgPSBNYXRoLmNlaWwodGhpcy5sZW5ndGhCeXRlcyAvIDMyKTtcbiAgICAgICAgdGhpcy5jaHVua0RlcHRoID0gbWVya2xlaXplXzEubWF4Q2h1bmtzVG9EZXB0aCh0aGlzLm1heENodW5rQ291bnQpO1xuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5jaHVua0RlcHRoO1xuICAgICAgICB0aGlzLmZpeGVkU2l6ZSA9IHRoaXMubGVuZ3RoQnl0ZXM7XG4gICAgICAgIHRoaXMubWluU2l6ZSA9IHRoaXMuZml4ZWRTaXplO1xuICAgICAgICB0aGlzLm1heFNpemUgPSB0aGlzLmZpeGVkU2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGxpbWl0Qml0cywgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lZF8xLm5hbWVkQ2xhc3MoQnl0ZVZlY3RvclR5cGUsIG9wdHMudHlwZU5hbWUpKShsaW1pdEJpdHMsIG9wdHMpO1xuICAgIH1cbiAgICAvLyBWaWV3czogaW5oZXJpdGVkIGZyb20gQnl0ZUFycmF5VHlwZVxuICAgIC8vIFNlcmlhbGl6YXRpb24gKyBkZXNlcmlhbGl6YXRpb25cbiAgICB2YWx1ZV9zZXJpYWxpemVkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4ZWRTaXplO1xuICAgIH1cbiAgICAvLyB2YWx1ZV8qIGluaGVyaXRlZCBmcm9tIEJ5dGVBcnJheVR5cGVcbiAgICB0cmVlX3NlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXhlZFNpemU7XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgbm9kZSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2Rlc0F0RGVwdGgobm9kZSwgdGhpcy5jaHVua0RlcHRoLCAwLCB0aGlzLm1heENodW5rQ291bnQpO1xuICAgICAgICBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEucGFja2VkTm9kZVJvb3RzVG9CeXRlcyhvdXRwdXQuZGF0YVZpZXcsIG9mZnNldCwgdGhpcy5maXhlZFNpemUsIG5vZGVzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMuZml4ZWRTaXplO1xuICAgIH1cbiAgICB0cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZFNpemUoZW5kIC0gc3RhcnQpO1xuICAgICAgICByZXR1cm4gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLnBhY2tlZFJvb3RzQnl0ZXNUb05vZGUodGhpcy5jaHVua0RlcHRoLCBkYXRhLmRhdGFWaWV3LCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgdHJlZV9nZXRCeXRlTGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGhCeXRlcztcbiAgICB9XG4gICAgLy8gTWVya2xlaXphdGlvbjogaW5oZXJpdGVkIGZyb20gQnl0ZUFycmF5VHlwZVxuICAgIC8vIFByb29mczogaW5oZXJpdGVkIGZyb20gQml0QXJyYXlUeXBlXG4gICAgLy8gSlNPTjogaW5oZXJpdGVkIGZyb20gQnl0ZUFycmF5VHlwZVxuICAgIGFzc2VydFZhbGlkU2l6ZShzaXplKSB7XG4gICAgICAgIGlmIChzaXplICE9PSB0aGlzLmxlbmd0aEJ5dGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQnl0ZVZlY3RvciBpbnZhbGlkIHNpemUgJHtzaXplfSBleHBlY3RlZCAke3RoaXMubGVuZ3RoQnl0ZXN9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJ5dGVWZWN0b3JUeXBlID0gQnl0ZVZlY3RvclR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlVmVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0NvbXBvc2l0ZVR5cGUgPSBleHBvcnRzLkNvbXBvc2l0ZVR5cGUgPSBleHBvcnRzLkxFTkdUSF9HSU5ERVggPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgYnl0ZUFycmF5XzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ieXRlQXJyYXlcIik7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IHRyZWVQb3N0UHJvY2Vzc0Zyb21Qcm9vZk5vZGVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL3Byb29mL3RyZWVQb3N0UHJvY2Vzc0Zyb21Qcm9vZk5vZGVcIik7XG5jb25zdCBhYnN0cmFjdF8xID0gcmVxdWlyZShcIi4vYWJzdHJhY3RcIik7XG5leHBvcnRzLkxFTkdUSF9HSU5ERVggPSBCaWdJbnQoMyk7XG4vKiogRGVkaWNhdGVkIHByb3BlcnR5IHRvIGNhY2hlIGhhc2hUcmVlUm9vdCBvZiBpbW11dGFibGUgQ29tcG9zaXRlVHlwZSB2YWx1ZXMgKi9cbmNvbnN0IHN5bWJvbENhY2hlZFBlcm1hbmVudFJvb3QgPSBTeW1ib2woXCJzc3pfY2FjaGVkX3Blcm1hbmVudF9yb290XCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZyAgKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbXBvc2l0ZSB0eXBlIGFzIGRlZmluZWQgaW4gdGhlIHNwZWM6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vY29uc2Vuc3VzLXNwZWNzL2Jsb2IvZGV2L3Nzei9zaW1wbGUtc2VyaWFsaXplLm1kI2NvbXBvc2l0ZS10eXBlc1xuICovXG5jbGFzcyBDb21wb3NpdGVUeXBlIGV4dGVuZHMgYWJzdHJhY3RfMS5UeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBDYWNoZXMgYGhhc2hUcmVlUm9vdCgpYCByZXN1bHQgZm9yIHN0cnVjdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBNdXN0IG9ubHkgYmUgdXNlZCBmb3IgaW1tdXRhYmxlIHZhbHVlcy4gVGhlIGNhY2hlZCByb290IGlzIG5ldmVyIGRpc2NhcmRlZFxuICAgICAqL1xuICAgIGNhY2hlUGVybWFuZW50Um9vdFN0cnVjdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhY2hlUGVybWFuZW50Um9vdFN0cnVjdCA9IGNhY2hlUGVybWFuZW50Um9vdFN0cnVjdDtcbiAgICAgICAgdGhpcy5pc0Jhc2ljID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBOZXcgaW5zdGFuY2Ugb2YgYSByZWN1cnNpdmUgemVybydlZCB2YWx1ZSBjb252ZXJ0ZWQgdG8gVHJlZSBWaWV3ICovXG4gICAgZGVmYXVsdFZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVmlldyh0aGlzLmRlZmF1bHRWYWx1ZSgpKTtcbiAgICB9XG4gICAgLyoqIE5ldyBpbnN0YW5jZSBvZiBhIHJlY3Vyc2l2ZSB6ZXJvJ2VkIHZhbHVlIGNvbnZlcnRlZCB0byBEZWZlcnJlZCBVcGRhdGUgVHJlZSBWaWV3ICovXG4gICAgZGVmYXVsdFZpZXdEVSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9WaWV3RFUodGhpcy5kZWZhdWx0VmFsdWUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIGJpbmFyeSBkYXRhIHRvIGEgVHJlZSBWaWV3LlxuICAgICAqIEBzZWUge0BsaW5rIENvbXBvc2l0ZVR5cGUuZ2V0Vmlld31cbiAgICAgKi9cbiAgICBkZXNlcmlhbGl6ZVRvVmlldyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoeyB1aW50OEFycmF5OiBkYXRhLCBkYXRhVmlldyB9LCAwLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZpZXcobmV3IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5UcmVlKG5vZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgYmluYXJ5IGRhdGEgdG8gYSBEZWZlcnJlZCBVcGRhdGUgVHJlZSBWaWV3LlxuICAgICAqIEBzZWUge0BsaW5rIENvbXBvc2l0ZVR5cGUuZ2V0Vmlld0RVfVxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplVG9WaWV3RFUoZGF0YSkge1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy50cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKHsgdWludDhBcnJheTogZGF0YSwgZGF0YVZpZXcgfSwgMCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWaWV3RFUobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB2YWx1ZSB0byBhIFZpZXcuXG4gICAgICogQHNlZSB7QGxpbmsgQ29tcG9zaXRlVHlwZS5nZXRWaWV3fVxuICAgICAqL1xuICAgIHRvVmlldyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy52YWx1ZV90b1RyZWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWaWV3KG5ldyBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuVHJlZShub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB2YWx1ZSB0byBhIFZpZXdEVS5cbiAgICAgKiBAc2VlIHtAbGluayBDb21wb3NpdGVUeXBlLmdldFZpZXdEVX1cbiAgICAgKi9cbiAgICB0b1ZpZXdEVSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy52YWx1ZV90b1RyZWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWaWV3RFUobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB2YWx1ZSB0byBhIFZpZXcuXG4gICAgICogQHNlZSB7QGxpbmsgQ29tcG9zaXRlVHlwZS5nZXRWaWV3fVxuICAgICAqL1xuICAgIHRvVmFsdWVGcm9tVmlldyh2aWV3KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNvbW1pdFZpZXcodmlldyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVfdG9WYWx1ZShub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHZhbHVlIHRvIGEgVmlld0RVLlxuICAgICAqIEBzZWUge0BsaW5rIENvbXBvc2l0ZVR5cGUuZ2V0Vmlld0RVfVxuICAgICAqL1xuICAgIHRvVmFsdWVGcm9tVmlld0RVKHZpZXcpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY29tbWl0Vmlld0RVKHZpZXcpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlX3RvVmFsdWUobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIFZpZXdEVSB0byBhIFZpZXcuXG4gICAgICogQHNlZSB7QGxpbmsgQ29tcG9zaXRlVHlwZS5nZXRWaWV3fSBhbmQge0BsaW5rIENvbXBvc2l0ZVR5cGUuZ2V0Vmlld0RVfVxuICAgICAqL1xuICAgIHRvVmlld0Zyb21WaWV3RFUodmlldykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jb21taXRWaWV3RFUodmlldyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZpZXcobmV3IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5UcmVlKG5vZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgVmlldyB0byBhIFZpZXdEVS5cbiAgICAgKiBAc2VlIHtAbGluayBDb21wb3NpdGVUeXBlLmdldFZpZXd9IGFuZCB7QGxpbmsgQ29tcG9zaXRlVHlwZS5nZXRWaWV3RFV9XG4gICAgICovXG4gICAgdG9WaWV3RFVGcm9tVmlldyh2aWV3KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNvbW1pdFZpZXcodmlldyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZpZXdEVShub2RlKTtcbiAgICB9XG4gICAgLy8gTWVya2xlaXplIEFQSVxuICAgIGhhc2hUcmVlUm9vdCh2YWx1ZSkge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIG11dGFibGUgcm9vdCBpZiBhbnlcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVQZXJtYW5lbnRSb290U3RydWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRSb290ID0gdmFsdWVbc3ltYm9sQ2FjaGVkUGVybWFuZW50Um9vdF07XG4gICAgICAgICAgICBpZiAoY2FjaGVkUm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRSb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3QgPSBtZXJrbGVpemVfMS5tZXJrbGVpemUodGhpcy5nZXRSb290cyh2YWx1ZSksIHRoaXMubWF4Q2h1bmtDb3VudCk7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlUGVybWFuZW50Um9vdFN0cnVjdCkge1xuICAgICAgICAgICAgdmFsdWVbc3ltYm9sQ2FjaGVkUGVybWFuZW50Um9vdF0gPSByb290O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICAvLyBGb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nIHRoaXMgZmVhdHVyZVxuICAgIGdldENhY2hlZFBlcm1hbmVudFJvb3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW3N5bWJvbENhY2hlZFBlcm1hbmVudFJvb3RdO1xuICAgIH1cbiAgICAvLyBQcm9vZnMgQVBJXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgVHJlZSBWaWV3IGZyb20gYSBQcm9vZi4gVmVyaWZpZXMgdGhhdCB0aGUgUHJvb2YgaXMgY29ycmVjdCBhZ2FpbnN0IGByb290YC5cbiAgICAgKiBAc2VlIHtAbGluayBDb21wb3NpdGVUeXBlLmdldFZpZXd9XG4gICAgICovXG4gICAgY3JlYXRlRnJvbVByb29mKHByb29mLCByb290KSB7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlRnJvbVByb29mID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLlRyZWUuY3JlYXRlRnJvbVByb29mKHByb29mKS5yb290Tm9kZTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0cmVlUG9zdFByb2Nlc3NGcm9tUHJvb2ZOb2RlXzEudHJlZVBvc3RQcm9jZXNzRnJvbVByb29mTm9kZShyb290Tm9kZUZyb21Qcm9vZiwgdGhpcyk7XG4gICAgICAgIGlmIChyb290ICE9PSB1bmRlZmluZWQgJiYgIWJ5dGVBcnJheV8xLmJ5dGVBcnJheUVxdWFscyhyb290Tm9kZS5yb290LCByb290KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvb2YgZG9lcyBub3QgbWF0Y2ggdHJ1c3RlZCByb290XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZpZXcobmV3IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5UcmVlKHJvb3ROb2RlKSk7XG4gICAgfVxuICAgIC8qKiBJTlRFUk5BTCBNRVRIT0Q6IEZvciB2aWV3J3MgQVBJLCBjcmVhdGUgcHJvb2YgZnJvbSBhIHRyZWUgKi9cbiAgICB0cmVlX2NyZWF0ZVByb29mKG5vZGUsIGpzb25QYXRocykge1xuICAgICAgICBjb25zdCBnaW5kZXhlcyA9IHRoaXMudHJlZV9jcmVhdGVQcm9vZkdpbmRleGVzKG5vZGUsIGpzb25QYXRocyk7XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuY3JlYXRlUHJvb2Yobm9kZSwge1xuICAgICAgICAgICAgdHlwZTogcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLlByb29mVHlwZS50cmVlT2Zmc2V0LFxuICAgICAgICAgICAgZ2luZGljZXM6IGdpbmRleGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIElOVEVSTkFMIE1FVEhPRDogRm9yIHZpZXcncyBBUEksIGNyZWF0ZSBwcm9vZiBmcm9tIGEgdHJlZSAqL1xuICAgIHRyZWVfY3JlYXRlUHJvb2ZHaW5kZXhlcyhub2RlLCBqc29uUGF0aHMpIHtcbiAgICAgICAgY29uc3QgZ2luZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUGF0aCBvZiBqc29uUGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgZ2luZGV4IH0gPSB0aGlzLmdldFBhdGhJbmZvKGpzb25QYXRoKTtcbiAgICAgICAgICAgIGlmICghaXNDb21wb3NpdGVUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZ2luZGV4ZXMucHVzaChnaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhdGggc3VidHlwZSBpcyBjb21wb3NpdGUsIGluY2x1ZGUgdGhlIGdpbmRpY2VzIG9mIGFsbCB0aGUgbGVhdmVzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVhZkdpbmRleGVzID0gdHlwZS50cmVlX2dldExlYWZHaW5kaWNlcyhnaW5kZXgsIHR5cGUuZml4ZWRTaXplID09PSBudWxsID8gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmdldE5vZGUobm9kZSwgZ2luZGV4KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBnaW5kZXggb2YgbGVhZkdpbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdpbmRleGVzLnB1c2goZ2luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdpbmRleGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byBhIHN1YnR5cGUgJiBnaW5kZXggdXNpbmcgYSBwYXRoXG4gICAgICovXG4gICAgZ2V0UGF0aEluZm8ocGF0aCkge1xuICAgICAgICBjb25zdCBnaW5kaWNlcyA9IFtdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwYXRoKSB7XG4gICAgICAgICAgICBpZiAodHlwZS5pc0Jhc2ljKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRoOiBjYW5ub3QgbmF2aWdhdGUgYmV5b25kIGEgYmFzaWMgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdpbmRleCA9IHR5cGUuZ2V0UHJvcGVydHlHaW5kZXgocHJvcCk7XG4gICAgICAgICAgICAvLyBlbHNlIHN0b3AgbmF2aWdhdGluZ1xuICAgICAgICAgICAgaWYgKGdpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdpbmRpY2VzLnB1c2goZ2luZGV4KTtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZS5nZXRQcm9wZXJ0eVR5cGUocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBnaW5kZXg6IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5jb25jYXRHaW5kaWNlcyhnaW5kaWNlcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElOVEVSTkFMIE1FVEhPRDogcG9zdCBwcm9jZXNzIGDHuG9kZWAgaW5zdGFuY2UgY3JlYXRlZCBmcm9tIGEgcHJvb2YgYW5kIHJldHVybiBlaXRoZXIgdGhlIHNhbWUgbm9kZSxcbiAgICAgKiBhbmQgYSBuZXcgbm9kZSByZXByZXNlbnRpbmcgdGhlIHNhbWUgZGF0YSBpcyBhIGRpZmZlcmVudCBgTm9kZWAgaW5zdGFuY2UuIEN1cnJlbnRseSB1c2VkIGV4Y2x1c2l2ZWx5XG4gICAgICogYnkgQ29udGFpbmVyTm9kZVN0cnVjdCB0byBjb252ZXJ0IGBCcmFuY2hOb2RlYCBpbnRvIGBCcmFuY2hOb2RlU3RydWN0YC5cbiAgICAgKi9cbiAgICB0cmVlX2Zyb21Qcm9vZk5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4geyBub2RlLCBkb25lOiBmYWxzZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGU7XG5mdW5jdGlvbiBpc0NvbXBvc2l0ZVR5cGUodHlwZSkge1xuICAgIHJldHVybiAhdHlwZS5pc0Jhc2ljO1xufVxuZXhwb3J0cy5pc0NvbXBvc2l0ZVR5cGUgPSBpc0NvbXBvc2l0ZVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb3NpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbmRlckNvbnRhaW5lclR5cGVOYW1lID0gZXhwb3J0cy5wcmVjb21wdXRlSnNvbktleSA9IGV4cG9ydHMuQ29udGFpbmVyVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWVcIik7XG5jb25zdCBjYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNhc2VcIikpO1xuY29uc3QgbWVya2xlaXplXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJrbGVpemVcIik7XG5jb25zdCBuYW1lZF8xID0gcmVxdWlyZShcIi4uL3V0aWwvbmFtZWRcIik7XG5jb25zdCBjb21wb3NpdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBvc2l0ZVwiKTtcbmNvbnN0IGNvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3ZpZXcvY29udGFpbmVyXCIpO1xuY29uc3QgY29udGFpbmVyXzIgPSByZXF1aXJlKFwiLi4vdmlld0RVL2NvbnRhaW5lclwiKTtcbi8qKlxuICogQ29udGFpbmVyOiBvcmRlcmVkIGhldGVyb2dlbmVvdXMgY29sbGVjdGlvbiBvZiB2YWx1ZXNcbiAqIC0gTm90YXRpb246IEN1c3RvbSBuYW1lIHBlciBpbnN0YW5jZVxuICovXG5jbGFzcyBDb250YWluZXJUeXBlIGV4dGVuZHMgY29tcG9zaXRlXzEuQ29tcG9zaXRlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHM/LmNhY2hlUGVybWFuZW50Um9vdFN0cnVjdCk7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmlzTGlzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVmlld011dGFibGUgPSB0cnVlO1xuICAgICAgICAvLyBSZW5kZXIgZGV0YWlsZWQgdHlwZU5hbWUuIENvbnN1bWVycyBzaG91bGQgb3ZlcndyaXRlIHNpbmNlIGl0IGNhbiBnZXQgbG9uZ1xuICAgICAgICB0aGlzLnR5cGVOYW1lID0gb3B0cz8udHlwZU5hbWUgPz8gcmVuZGVyQ29udGFpbmVyVHlwZU5hbWUoZmllbGRzKTtcbiAgICAgICAgdGhpcy5tYXhDaHVua0NvdW50ID0gT2JqZWN0LmtleXMoZmllbGRzKS5sZW5ndGg7XG4gICAgICAgIHRoaXMuZGVwdGggPSBtZXJrbGVpemVfMS5tYXhDaHVua3NUb0RlcHRoKHRoaXMubWF4Q2h1bmtDb3VudCk7XG4gICAgICAgIC8vIFByZWNhbGN1bGF0ZWQgZGF0YSBmb3IgZmFzdGVyIHNlcmRlc1xuICAgICAgICB0aGlzLmZpZWxkc0VudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgICAgICAgICAgdGhpcy5maWVsZHNFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGU6IHRoaXMuZmllbGRzW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgICAgICAganNvbktleTogcHJlY29tcHV0ZUpzb25LZXkoZmllbGROYW1lLCBvcHRzPy5jYXNpbmdNYXAsIG9wdHM/Lmpzb25DYXNlKSxcbiAgICAgICAgICAgICAgICBnaW5kZXg6IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS50b0dpbmRleCh0aGlzLmRlcHRoLCBCaWdJbnQodGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aCkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ29udGFpbmVyIG11c3QgaGF2ZSA+IDAgZmllbGRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZWNhbGN1bGF0ZSBmb3IgUHJvb2ZzIEFQSVxuICAgICAgICB0aGlzLmZpZWxkc0dpbmRleCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5maWVsZHNHaW5kZXhbdGhpcy5maWVsZHNFbnRyaWVzW2ldLmZpZWxkTmFtZV0gPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEudG9HaW5kZXgodGhpcy5kZXB0aCwgQmlnSW50KGkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUbyByZXNvbHZlIEpTT04gcGF0aHMgaW4gZmllbGROYW1lIG5vdGF0aW9uIGFuZCBqc29uS2V5IG5vdGF0aW9uXG4gICAgICAgIHRoaXMuanNvbktleVRvRmllbGROYW1lID0ge307XG4gICAgICAgIGZvciAoY29uc3QgeyBmaWVsZE5hbWUsIGpzb25LZXkgfSBvZiB0aGlzLmZpZWxkc0VudHJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuanNvbktleVRvRmllbGROYW1lW2pzb25LZXldID0gZmllbGROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWluTGVuLCBtYXhMZW4sIGZpeGVkU2l6ZSB9ID0gcHJlY29tcHV0ZVNpemVzKGZpZWxkcyk7XG4gICAgICAgIHRoaXMubWluU2l6ZSA9IG1pbkxlbjtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4TGVuO1xuICAgICAgICB0aGlzLmZpeGVkU2l6ZSA9IGZpeGVkU2l6ZTtcbiAgICAgICAgY29uc3QgeyBpc0ZpeGVkTGVuLCBmaWVsZFJhbmdlc0ZpeGVkTGVuLCB2YXJpYWJsZU9mZnNldHNQb3NpdGlvbiwgZml4ZWRFbmQgfSA9IHByZWNvbXB1dGVTZXJkZXNEYXRhKGZpZWxkcyk7XG4gICAgICAgIHRoaXMuaXNGaXhlZExlbiA9IGlzRml4ZWRMZW47XG4gICAgICAgIHRoaXMuZmllbGRSYW5nZXNGaXhlZExlbiA9IGZpZWxkUmFuZ2VzRml4ZWRMZW47XG4gICAgICAgIHRoaXMudmFyaWFibGVPZmZzZXRzUG9zaXRpb24gPSB2YXJpYWJsZU9mZnNldHNQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5maXhlZEVuZCA9IGZpeGVkRW5kO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIG9wdGlvbnMgYXJlIG5lY2Vzc2FyeSBmb3IgQ29udGFpbmVyTm9kZVN0cnVjdCB0byBvdmVycmlkZSB0aGlzLlxuICAgICAgICAvLyBSZWZhY3RvciB0aGlzIGNvbnN0cnVjdG9yIHRvIGFsbG93IGN1c3RvbWl6YXRpb24gd2l0aG91dCBwb2xsdXRpbiB0aGUgb3B0aW9uc1xuICAgICAgICB0aGlzLlRyZWVWaWV3ID0gb3B0cz8uZ2V0Q29udGFpbmVyVHJlZVZpZXdDbGFzcz8uKHRoaXMpID8/IGNvbnRhaW5lcl8xLmdldENvbnRhaW5lclRyZWVWaWV3Q2xhc3ModGhpcyk7XG4gICAgICAgIHRoaXMuVHJlZVZpZXdEVSA9IG9wdHM/LmdldENvbnRhaW5lclRyZWVWaWV3RFVDbGFzcz8uKHRoaXMpID8/IGNvbnRhaW5lcl8yLmdldENvbnRhaW5lclRyZWVWaWV3RFVDbGFzcyh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGZpZWxkcywgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lZF8xLm5hbWVkQ2xhc3MoQ29udGFpbmVyVHlwZSwgb3B0cy50eXBlTmFtZSkpKGZpZWxkcywgb3B0cyk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB7IGZpZWxkTmFtZSwgZmllbGRUeXBlIH0gb2YgdGhpcy5maWVsZHNFbnRyaWVzKSB7XG4gICAgICAgICAgICB2YWx1ZVtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0Vmlldyh0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5UcmVlVmlldyh0aGlzLCB0cmVlKTtcbiAgICB9XG4gICAgZ2V0Vmlld0RVKG5vZGUsIGNhY2hlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5UcmVlVmlld0RVKHRoaXMsIG5vZGUsIGNhY2hlKTtcbiAgICB9XG4gICAgY2FjaGVPZlZpZXdEVSh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3LmNhY2hlO1xuICAgIH1cbiAgICBjb21taXRWaWV3KHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcubm9kZTtcbiAgICB9XG4gICAgY29tbWl0Vmlld0RVKHZpZXcpIHtcbiAgICAgICAgdmlldy5jb21taXQoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcubm9kZTtcbiAgICB9XG4gICAgLy8gU2VyaWFsaXphdGlvbiArIGRlc2VyaWFsaXphdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb250YWluZXJzIGNhbiBtaXggZml4ZWQgbGVuZ3RoIGFuZCB2YXJpYWJsZSBsZW5ndGggZGF0YS5cbiAgICAvL1xuICAgIC8vIEZpeGVkIHBhcnQgICAgICAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUgcGFydFxuICAgIC8vIFtmaWVsZDEgb2Zmc2V0XVtmaWVsZDIgZGF0YSAgICAgICBdW2ZpZWxkMSBkYXRhICAgICAgICAgICAgICAgXVxuICAgIC8vIFsweDAwMDAwMGNdICAgIFsweGFhYmJhYWJiYWFiYmFhYmJdWzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXVxuICAgIHZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlKSB7XG4gICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSB9ID0gdGhpcy5maWVsZHNFbnRyaWVzW2ldO1xuICAgICAgICAgICAgLy8gT2Zmc2V0ICg0IGJ5dGVzKSArIHNpemVcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPVxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZS5maXhlZFNpemUgPT09IG51bGwgPyA0ICsgZmllbGRUeXBlLnZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlW2ZpZWxkTmFtZV0pIDogZmllbGRUeXBlLmZpeGVkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxTaXplO1xuICAgIH1cbiAgICB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBsZXQgZml4ZWRJbmRleCA9IG9mZnNldDtcbiAgICAgICAgbGV0IHZhcmlhYmxlSW5kZXggPSBvZmZzZXQgKyB0aGlzLmZpeGVkRW5kO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSB9ID0gdGhpcy5maWVsZHNFbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGZpZWxkVHlwZS5maXhlZFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBvdXRwdXQuZGF0YVZpZXcuc2V0VWludDMyKGZpeGVkSW5kZXgsIHZhcmlhYmxlSW5kZXggLSBvZmZzZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGZpeGVkSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBzZXJpYWxpemVkIGVsZW1lbnQgdG8gdmFyaWFibGUgc2VjdGlvblxuICAgICAgICAgICAgICAgIHZhcmlhYmxlSW5kZXggPSBmaWVsZFR5cGUudmFsdWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIHZhcmlhYmxlSW5kZXgsIHZhbHVlW2ZpZWxkTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZWRJbmRleCA9IGZpZWxkVHlwZS52YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgZml4ZWRJbmRleCwgdmFsdWVbZmllbGROYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlSW5kZXg7XG4gICAgfVxuICAgIHZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3QgZmllbGRSYW5nZXMgPSB0aGlzLmdldEZpZWxkUmFuZ2VzKGRhdGEuZGF0YVZpZXcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSB9ID0gdGhpcy5maWVsZHNFbnRyaWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZmllbGRSYW5nZSA9IGZpZWxkUmFuZ2VzW2ldO1xuICAgICAgICAgICAgdmFsdWVbZmllbGROYW1lXSA9IGZpZWxkVHlwZS52YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCArIGZpZWxkUmFuZ2Uuc3RhcnQsIHN0YXJ0ICsgZmllbGRSYW5nZS5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdHJlZV9zZXJpYWxpemVkU2l6ZShub2RlKSB7XG4gICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICBjb25zdCBub2RlcyA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2Rlc0F0RGVwdGgobm9kZSwgdGhpcy5kZXB0aCwgMCwgdGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZpZWxkVHlwZSB9ID0gdGhpcy5maWVsZHNFbnRyaWVzW2ldO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgLy8gT2Zmc2V0ICg0IGJ5dGVzKSArIHNpemVcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBmaWVsZFR5cGUuZml4ZWRTaXplID09PSBudWxsID8gNCArIGZpZWxkVHlwZS50cmVlX3NlcmlhbGl6ZWRTaXplKG5vZGUpIDogZmllbGRUeXBlLmZpeGVkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxTaXplO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgbGV0IGZpeGVkSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIGxldCB2YXJpYWJsZUluZGV4ID0gb2Zmc2V0ICsgdGhpcy5maXhlZEVuZDtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZXNBdERlcHRoKG5vZGUsIHRoaXMuZGVwdGgsIDAsIHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZFR5cGUgfSA9IHRoaXMuZmllbGRzRW50cmllc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChmaWVsZFR5cGUuZml4ZWRTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb3V0cHV0LmRhdGFWaWV3LnNldFVpbnQzMihmaXhlZEluZGV4LCB2YXJpYWJsZUluZGV4IC0gb2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmaXhlZEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgc2VyaWFsaXplZCBlbGVtZW50IHRvIHZhcmlhYmxlIHNlY3Rpb25cbiAgICAgICAgICAgICAgICB2YXJpYWJsZUluZGV4ID0gZmllbGRUeXBlLnRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIHZhcmlhYmxlSW5kZXgsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZWRJbmRleCA9IGZpZWxkVHlwZS50cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBmaXhlZEluZGV4LCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGVJbmRleDtcbiAgICB9XG4gICAgdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkUmFuZ2VzID0gdGhpcy5nZXRGaWVsZFJhbmdlcyhkYXRhLmRhdGFWaWV3LCBzdGFydCwgZW5kKTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZpZWxkVHlwZSB9ID0gdGhpcy5maWVsZHNFbnRyaWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZmllbGRSYW5nZSA9IGZpZWxkUmFuZ2VzW2ldO1xuICAgICAgICAgICAgbm9kZXNbaV0gPSBmaWVsZFR5cGUudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCArIGZpZWxkUmFuZ2Uuc3RhcnQsIHN0YXJ0ICsgZmllbGRSYW5nZS5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuc3VidHJlZUZpbGxUb0NvbnRlbnRzKG5vZGVzLCB0aGlzLmRlcHRoKTtcbiAgICB9XG4gICAgLy8gTWVya2xlaXphdGlvblxuICAgIGdldFJvb3RzKHN0cnVjdCkge1xuICAgICAgICBjb25zdCByb290cyA9IG5ldyBBcnJheSh0aGlzLmZpZWxkc0VudHJpZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkc0VudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmllbGROYW1lLCBmaWVsZFR5cGUgfSA9IHRoaXMuZmllbGRzRW50cmllc1tpXTtcbiAgICAgICAgICAgIHJvb3RzW2ldID0gZmllbGRUeXBlLmhhc2hUcmVlUm9vdChzdHJ1Y3RbZmllbGROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RzO1xuICAgIH1cbiAgICAvLyBQcm9vZnNcbiAgICAvLyBnZXRQcm9wZXJ0eUdpbmRleFxuICAgIC8vIGdldFByb3BlcnR5VHlwZVxuICAgIC8vIHRyZWVfZ2V0TGVhZkdpbmRpY2VzXG4gICAgZ2V0UHJvcGVydHlHaW5kZXgocHJvcCkge1xuICAgICAgICBjb25zdCBnaW5kZXggPSB0aGlzLmZpZWxkc0dpbmRleFtwcm9wXSA/PyB0aGlzLmZpZWxkc0dpbmRleFt0aGlzLmpzb25LZXlUb0ZpZWxkTmFtZVtwcm9wXV07XG4gICAgICAgIGlmIChnaW5kZXggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIGNvbnRhaW5lciBwcm9wZXJ0eSAke3Byb3B9YCk7XG4gICAgICAgIHJldHVybiBnaW5kZXg7XG4gICAgfVxuICAgIGdldFByb3BlcnR5VHlwZShwcm9wKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZpZWxkc1twcm9wXSA/PyB0aGlzLmZpZWxkc1t0aGlzLmpzb25LZXlUb0ZpZWxkTmFtZVtwcm9wXV07XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5rbm93biBjb250YWluZXIgcHJvcGVydHkgJHtwcm9wfWApO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZ2V0SW5kZXhQcm9wZXJ0eShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzRW50cmllc1tpbmRleF0uZmllbGROYW1lO1xuICAgIH1cbiAgICB0cmVlX2dldExlYWZHaW5kaWNlcyhyb290R2luZGV4LCByb290Tm9kZSkge1xuICAgICAgICBjb25zdCBnaW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSB9ID0gdGhpcy5maWVsZHNFbnRyaWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZmllbGRHaW5kZXggPSB0aGlzLmZpZWxkc0dpbmRleFtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgZmllbGRHaW5kZXhGcm9tUm9vdCA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5jb25jYXRHaW5kaWNlcyhbcm9vdEdpbmRleCwgZmllbGRHaW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChmaWVsZFR5cGUuaXNCYXNpYykge1xuICAgICAgICAgICAgICAgIGdpbmRpY2VzLnB1c2goZmllbGRHaW5kZXhGcm9tUm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVUeXBlID0gZmllbGRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZFR5cGUuZml4ZWRTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhcmlhYmxlIHR5cGUgcmVxdWlyZXMgdHJlZSBhcmd1bWVudCB0byBnZXQgbGVhdmVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdpbmRpY2VzLnB1c2goLi4uY29tcG9zaXRlVHlwZS50cmVlX2dldExlYWZHaW5kaWNlcyhmaWVsZEdpbmRleEZyb21Sb290LCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZShyb290Tm9kZSwgZmllbGRHaW5kZXgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnaW5kaWNlcy5wdXNoKC4uLmNvbXBvc2l0ZVR5cGUudHJlZV9nZXRMZWFmR2luZGljZXMoZmllbGRHaW5kZXhGcm9tUm9vdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2luZGljZXM7XG4gICAgfVxuICAgIC8vIEpTT05cbiAgICBmcm9tSnNvbihqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJKU09OIG11c3QgYmUgb2YgdHlwZSBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSlNPTiBtdXN0IG5vdCBiZSBudWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZpZWxkTmFtZSwgZmllbGRUeXBlLCBqc29uS2V5IH0gPSB0aGlzLmZpZWxkc0VudHJpZXNbaV07XG4gICAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSBqc29uW2pzb25LZXldO1xuICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEpTT04gZXhwZWN0ZWQga2V5ICR7anNvbktleX0gaXMgdW5kZWZpbmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZVtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmZyb21Kc29uKGpzb25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0b0pzb24odmFsdWUpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSwganNvbktleSB9ID0gdGhpcy5maWVsZHNFbnRyaWVzW2ldO1xuICAgICAgICAgICAganNvbltqc29uS2V5XSA9IGZpZWxkVHlwZS50b0pzb24odmFsdWVbZmllbGROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGNsb25lKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHNFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZpZWxkTmFtZSwgZmllbGRUeXBlIH0gPSB0aGlzLmZpZWxkc0VudHJpZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZVtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNsb25lKHZhbHVlW2ZpZWxkTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkc0VudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmllbGROYW1lLCBmaWVsZFR5cGUgfSA9IHRoaXMuZmllbGRzRW50cmllc1tpXTtcbiAgICAgICAgICAgIGlmICghZmllbGRUeXBlLmVxdWFscyhhW2ZpZWxkTmFtZV0sIGJbZmllbGROYW1lXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplciBoZWxwZXI6IFJldHVybnMgdGhlIGJ5dGVzIHJhbmdlcyBvZiBhbGwgZmllbGRzLCBib3RoIHZhcmlhYmxlIGFuZCBmaXhlZCBzaXplLlxuICAgICAqIEZpZWxkcyBtYXkgbm90IGJlIGNvbnRpZ3VvdXMgaW4gdGhlIHNlcmlhbGl6ZWQgYnl0ZXMsIHNvIHRoZSByZXR1cm5lZCByYW5nZXMgYXJlIFtzdGFydCwgZW5kXS5cbiAgICAgKiAtIEZvciBmaXhlZCBzaXplIGZpZWxkcyByZS11c2VzIHRoZSBwcmUtY29tcHV0ZWQgdmFsdWVzIHRoaXMuZmllbGRSYW5nZXNGaXhlZExlblxuICAgICAqIC0gRm9yIHZhcmlhYmxlIHNpemUgZmllbGRzIGRvZXMgYSBmaXJzdCBwYXNzIG92ZXIgdGhlIGZpeGVkIHNlY3Rpb24gdG8gcmVhZCBvZmZzZXRzXG4gICAgICovXG4gICAgZ2V0RmllbGRSYW5nZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZU9mZnNldHNQb3NpdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGZpeGVkIGxlbmd0aCBjb250YWluZXJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgIGlmIChzaXplICE9PSB0aGlzLmZpeGVkRW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYCR7dGhpcy50eXBlTmFtZX0gc2l6ZSAke3NpemV9IG5vdCBlcXVhbCBmaXhlZCBzaXplICR7dGhpcy5maXhlZEVuZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkUmFuZ2VzRml4ZWRMZW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhZCBvZmZzZXRzIGluIG9uZSBwYXNzXG4gICAgICAgIGNvbnN0IG9mZnNldHMgPSByZWFkVmFyaWFibGVPZmZzZXRzKGRhdGEsIHN0YXJ0LCBlbmQsIHRoaXMuZml4ZWRFbmQsIHRoaXMudmFyaWFibGVPZmZzZXRzUG9zaXRpb24pO1xuICAgICAgICBvZmZzZXRzLnB1c2goZW5kIC0gc3RhcnQpOyAvLyBUaGUgb2Zmc2V0cyBhcmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0XG4gICAgICAgIC8vIE1lcmdlIGZpZWxkUmFuZ2VzRml4ZWRMZW4gKyBvZmZzZXRzIGluIG9uZSBhcnJheVxuICAgICAgICBsZXQgdmFyaWFibGVJZHggPSAwO1xuICAgICAgICBsZXQgZml4ZWRJZHggPSAwO1xuICAgICAgICBjb25zdCBmaWVsZFJhbmdlcyA9IG5ldyBBcnJheSh0aGlzLmlzRml4ZWRMZW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlzRml4ZWRMZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRml4ZWRMZW5baV0pIHtcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGZyb20gZml4TGVuIHJhbmdlcyArK1xuICAgICAgICAgICAgICAgIGZpZWxkUmFuZ2VzW2ldID0gdGhpcy5maWVsZFJhbmdlc0ZpeGVkTGVuW2ZpeGVkSWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHVzaCBmcm9tIHZhckxlbiByYW5nZXMgKytcbiAgICAgICAgICAgICAgICBmaWVsZFJhbmdlc1tpXSA9IHsgc3RhcnQ6IG9mZnNldHNbdmFyaWFibGVJZHhdLCBlbmQ6IG9mZnNldHNbdmFyaWFibGVJZHggKyAxXSB9O1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkUmFuZ2VzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udGFpbmVyVHlwZSA9IENvbnRhaW5lclR5cGU7XG4vKipcbiAqIFJldHVybnMgdGhlIGJ5dGUgcmFuZ2VzIG9mIGFsbCB2YXJpYWJsZSBzaXplIGZpZWxkcy5cbiAqL1xuZnVuY3Rpb24gcmVhZFZhcmlhYmxlT2Zmc2V0cyhkYXRhLCBzdGFydCwgZW5kLCBmaXhlZEVuZCwgdmFyaWFibGVPZmZzZXRzUG9zaXRpb24pIHtcbiAgICAvLyBTaW5jZSB2YXJpYWJsZS1zaXplZCB2YWx1ZXMgY2FuIGJlIGludGVyc3BlcnNlZCB3aXRoIGZpeGVkLXNpemVkIHZhbHVlcywgd2UgcHJlY2FsY3VsYXRlXG4gICAgLy8gdGhlIG9mZnNldCBpbmRpY2VzIHNvIHdlIGNhbiBtb3JlIGVhc2lseSBkZXNlcmlhbGl6ZSB0aGUgZmllbGRzIGluIG9uY2UgcGFzcyBmaXJzdCB3ZSBnZXQgdGhlIGZpeGVkIHNpemVzXG4gICAgLy8gTm90ZTogYGZpeGVkU2l6ZXNbaV0gPSBudWxsYCBpZiB0aGF0IGZpZWxkIGhhcyB2YXJpYWJsZSBsZW5ndGhcbiAgICBjb25zdCBzaXplID0gZW5kIC0gc3RhcnQ7XG4gICAgLy8gd2l0aCB0aGUgZml4ZWQgc2l6ZXMsIHdlIGNhbiByZWFkIHRoZSBvZmZzZXRzLCBhbmQgc3RvcmUgZm9yIG91ciBzaW5nbGUgcGFzc1xuICAgIGNvbnN0IG9mZnNldHMgPSBuZXcgQXJyYXkodmFyaWFibGVPZmZzZXRzUG9zaXRpb24ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhcmlhYmxlT2Zmc2V0c1Bvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRhdGEuZ2V0VWludDMyKHN0YXJ0ICsgdmFyaWFibGVPZmZzZXRzUG9zaXRpb25baV0sIHRydWUpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBvZmZzZXRzLiBJZiB0aGUgbGlzdCBpcyBlbXB0eSB0aGUgb2Zmc2V0IHBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIsIG9mZnNldCA9PSBzaXplXG4gICAgICAgIGlmIChvZmZzZXQgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9mZnNldCBvdXQgb2YgYm91bmRzICR7b2Zmc2V0fSA+ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gZml4ZWRFbmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpcnN0IG9mZnNldCBtdXN0IGVxdWFsIHRvIGZpeGVkRW5kICR7b2Zmc2V0fSAhPSAke2ZpeGVkRW5kfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG9mZnNldHNbaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPZmZzZXRzIG11c3QgYmUgaW5jcmVhc2luZyAke29mZnNldH0gPCAke29mZnNldHNbaSAtIDFdfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldHNbaV0gPSBvZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXRzO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlIGZpeGVkIGFuZCB2YXJpYWJsZSBvZmZzZXRzIHBvc2l0aW9uIGZvciBmYXN0ZXIgZGVzZXJpYWxpemF0aW9uLlxuICogQHJldHVybnMgRG9lcyBhIHNpbmdsZSBwYXNzIG92ZXIgYWxsIGZpZWxkcyBhbmQgcmV0dXJuczpcbiAqIC0gaXNGaXhlZExlbjogSWYgZmllbGQgaW5kZXggW2ldIGlzIGZpeGVkIGxlbmd0aFxuICogLSBmaWVsZFJhbmdlc0ZpeGVkTGVuOiBGb3IgZmllbGRzIHdpdGggZml4ZWQgbGVuZ3RoLCB0aGVpciByYW5nZSBvZiBieXRlc1xuICogLSB2YXJpYWJsZU9mZnNldHNQb3NpdGlvbjogUG9zaXRpb24gb2YgdGhlIDQgYnl0ZXMgb2Zmc2V0IGZvciB2YXJpYWJsZSBzaXplIGZpZWxkc1xuICogLSBmaXhlZEVuZDogRW5kIG9mIHRoZSBmaXhlZCBzaXplIHJhbmdlXG4gKiAtXG4gKi9cbmZ1bmN0aW9uIHByZWNvbXB1dGVTZXJkZXNEYXRhKGZpZWxkcykge1xuICAgIGNvbnN0IGlzRml4ZWRMZW4gPSBbXTtcbiAgICBjb25zdCBmaWVsZFJhbmdlc0ZpeGVkTGVuID0gW107XG4gICAgY29uc3QgdmFyaWFibGVPZmZzZXRzUG9zaXRpb24gPSBbXTtcbiAgICBsZXQgcG9pbnRlckZpeGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGZpZWxkVHlwZSBvZiBPYmplY3QudmFsdWVzKGZpZWxkcykpIHtcbiAgICAgICAgaXNGaXhlZExlbi5wdXNoKGZpZWxkVHlwZS5maXhlZFNpemUgIT09IG51bGwpO1xuICAgICAgICBpZiAoZmllbGRUeXBlLmZpeGVkU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVmFyaWFibGUgbGVuZ3RoXG4gICAgICAgICAgICB2YXJpYWJsZU9mZnNldHNQb3NpdGlvbi5wdXNoKHBvaW50ZXJGaXhlZCk7XG4gICAgICAgICAgICBwb2ludGVyRml4ZWQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkUmFuZ2VzRml4ZWRMZW4ucHVzaCh7IHN0YXJ0OiBwb2ludGVyRml4ZWQsIGVuZDogcG9pbnRlckZpeGVkICsgZmllbGRUeXBlLmZpeGVkU2l6ZSB9KTtcbiAgICAgICAgICAgIHBvaW50ZXJGaXhlZCArPSBmaWVsZFR5cGUuZml4ZWRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzRml4ZWRMZW4sXG4gICAgICAgIGZpZWxkUmFuZ2VzRml4ZWRMZW4sXG4gICAgICAgIHZhcmlhYmxlT2Zmc2V0c1Bvc2l0aW9uLFxuICAgICAgICBmaXhlZEVuZDogcG9pbnRlckZpeGVkLFxuICAgIH07XG59XG4vKipcbiAqIFByZWNvbXB1dGUgc2l6ZXMgb2YgdGhlIENvbnRhaW5lciBkb2luZyBvbmUgcGFzcyBvdmVyIGZpZWxkc1xuICovXG5mdW5jdGlvbiBwcmVjb21wdXRlU2l6ZXMoZmllbGRzKSB7XG4gICAgbGV0IG1pbkxlbiA9IDA7XG4gICAgbGV0IG1heExlbiA9IDA7XG4gICAgbGV0IGZpeGVkU2l6ZSA9IDA7XG4gICAgZm9yIChjb25zdCBmaWVsZFR5cGUgb2YgT2JqZWN0LnZhbHVlcyhmaWVsZHMpKSB7XG4gICAgICAgIG1pbkxlbiArPSBmaWVsZFR5cGUubWluU2l6ZTtcbiAgICAgICAgbWF4TGVuICs9IGZpZWxkVHlwZS5tYXhTaXplO1xuICAgICAgICBpZiAoZmllbGRUeXBlLmZpeGVkU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gKzQgZm9yIHRoZSBvZmZzZXRcbiAgICAgICAgICAgIG1pbkxlbiArPSA0O1xuICAgICAgICAgICAgbWF4TGVuICs9IDQ7XG4gICAgICAgICAgICBmaXhlZFNpemUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpeGVkU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZml4ZWRTaXplICs9IGZpZWxkVHlwZS5maXhlZFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWluTGVuLCBtYXhMZW4sIGZpeGVkU2l6ZSB9O1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBKU09OIGtleSBmb3IgZWFjaCBmaWVsZE5hbWUuIFRoZXJlIHdpbGwgZXhpc3QgYSBzaW5nbGUgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgZWFjaCB0eXBlLlxuICogVG8gdHJhbnNmb3JtIEpTT04gcGF5bG9hZHMgdG8gYSBjYXNpbmcgdGhhdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgdHlwZSdzIGRlZmluZWQgdXNlIGV4dGVybmFsIHRvb2xpbmcuXG4gKi9cbmZ1bmN0aW9uIHByZWNvbXB1dGVKc29uS2V5KGZpZWxkTmFtZSwgY2FzaW5nTWFwLCBqc29uQ2FzZSkge1xuICAgIGlmIChjYXNpbmdNYXApIHtcbiAgICAgICAgY29uc3Qga2V5RnJvbUNhc2VNYXAgPSBjYXNpbmdNYXBbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGtleUZyb21DYXNlTWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBjYXNpbmdNYXBbJHtmaWVsZE5hbWV9XSBub3QgZGVmaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlGcm9tQ2FzZU1hcDtcbiAgICB9XG4gICAgZWxzZSBpZiAoanNvbkNhc2UpIHtcbiAgICAgICAgaWYgKGpzb25DYXNlID09PSBcImV0aDJcIikge1xuICAgICAgICAgICAgY29uc3Qgc25ha2UgPSBjYXNlXzEuZGVmYXVsdC5zbmFrZShmaWVsZE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNuYWtlLnJlcGxhY2UoLyhcXGQpJC8sIFwiXyQxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhc2VfMS5kZWZhdWx0W2pzb25DYXNlXShmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgIH1cbn1cbmV4cG9ydHMucHJlY29tcHV0ZUpzb25LZXkgPSBwcmVjb21wdXRlSnNvbktleTtcbi8qKlxuICogUmVuZGVyIGZpZWxkIHR5cGVOYW1lcyBmb3IgYSBkZXRhaWxlZCB0eXBlTmFtZSBvZiB0aGlzIENvbnRhaW5lclxuICovXG5mdW5jdGlvbiByZW5kZXJDb250YWluZXJUeXBlTmFtZShmaWVsZHMsIHByZWZpeCA9IFwiQ29udGFpbmVyXCIpIHtcbiAgICBjb25zdCBmaWVsZE5hbWVzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgICBjb25zdCBmaWVsZFR5cGVOYW1lcyA9IGZpZWxkTmFtZXMubWFwKChmaWVsZE5hbWUpID0+IGAke2ZpZWxkTmFtZX06ICR7ZmllbGRzW2ZpZWxkTmFtZV0udHlwZU5hbWV9YCkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiBgJHtwcmVmaXh9KHske2ZpZWxkVHlwZU5hbWVzfX0pYDtcbn1cbmV4cG9ydHMucmVuZGVyQ29udGFpbmVyVHlwZU5hbWUgPSByZW5kZXJDb250YWluZXJUeXBlTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5lci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udGFpbmVyTm9kZVN0cnVjdFR5cGUgPSB2b2lkIDA7XG5jb25zdCBjb21wb3NpdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBvc2l0ZVwiKTtcbmNvbnN0IGNvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vY29udGFpbmVyXCIpO1xuY29uc3QgbmFtZWRfMSA9IHJlcXVpcmUoXCIuLi91dGlsL25hbWVkXCIpO1xuY29uc3QgY29udGFpbmVyTm9kZVN0cnVjdF8xID0gcmVxdWlyZShcIi4uL3ZpZXcvY29udGFpbmVyTm9kZVN0cnVjdFwiKTtcbmNvbnN0IGNvbnRhaW5lck5vZGVTdHJ1Y3RfMiA9IHJlcXVpcmUoXCIuLi92aWV3RFUvY29udGFpbmVyTm9kZVN0cnVjdFwiKTtcbmNvbnN0IGJyYW5jaE5vZGVTdHJ1Y3RfMSA9IHJlcXVpcmUoXCIuLi9icmFuY2hOb2RlU3RydWN0XCIpO1xuLyoqXG4gKiBDb250YWluZXJOb2RlU3RydWN0OiBvcmRlcmVkIGhldGVyb2dlbmVvdXMgY29sbGVjdGlvbiBvZiB2YWx1ZXMuXG4gKiAtIE5vdGF0aW9uOiBDdXN0b20gbmFtZSBwZXIgaW5zdGFuY2VcbiAqXG4gKiBBIENvbnRhaW5lck5vZGVTdHJ1Y3QgaXMgaWRlbnRpY2FsIHRvIGEgQ29udGFpbmVyIHR5cGUgZXhjZXB0IHRoYXQgaXQgcmVwcmVzZW50cyB0cmVlIGRhdGEgd2l0aCBhIGN1c3RvbVxuICogQnJhbmNoTm9kZVN0cnVjdCBub2RlLiBUaGlzIHNwZWNpYWwgYnJhbmNoIG5vZGUgcmVwcmVzZW50cyB0aGUgZGF0YSBvZiBpdHMgZW50aXJlIHN1YiB0cmVlIGFzIGEgdmFsdWUsIGluc3RlYWRcbiAqIG9mIGEgdHJlZSBvZiBub2Rlcy4gVGhpcyBhcHByb2FjaCBpcyBhIHRyYWRlb2ZmOlxuICpcbiAqIC0gTW9yZSBtZW1vcnkgZWZmaWNpZW50XG4gKiAtIEZhc3RlciByZWFkcywgc2luY2UgaXQgZG9lc24ndCByZXF1aXJlIHBhcnNpbmcgbWVya2xlaXplZCBkYXRhXG4gKiAtIFNsb3dlciBoYXNoaW5nLCBzaW5jZSBpdCBoYXMgdG8gbWVya2xlaXplIHRoZSBlbnRpcmUgdmFsdWUgZXZlcnl0aW1lIGFuZCBoYXMgbm90IGludGVybWVkaWFyeSBoYXNoaW5nIGNhY2hlXG4gKlxuICogVGhpcyB0cmFkZW9mZiBpcyBnb29kIGZvciBkYXRhIHRoYXQgaXMgcmVhZCBvZnRlbiwgd3JpdHRlbiByYXJlbHksIGFuZCBjb25zdW1lcyBhIGxvdCBvZiBtZW1vcnkgKGkuZS4gVmFsaWRhdG9yKVxuICovXG5jbGFzcyBDb250YWluZXJOb2RlU3RydWN0VHlwZSBleHRlbmRzIGNvbnRhaW5lcl8xLkNvbnRhaW5lclR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgb3B0cykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIHtcbiAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSBkZWZhdWx0IFwiQ29udGFpbmVyXCIgdHlwZU5hbWVcbiAgICAgICAgICAgIC8vIFJlbmRlciBkZXRhaWxlZCB0eXBlTmFtZS4gQ29uc3VtZXJzIHNob3VsZCBvdmVyd3JpdGUgc2luY2UgaXQgY2FuIGdldCBsb25nXG4gICAgICAgICAgICB0eXBlTmFtZTogb3B0cz8udHlwZU5hbWUgPz8gY29udGFpbmVyXzEucmVuZGVyQ29udGFpbmVyVHlwZU5hbWUoZmllbGRzLCBcIkNvbnRhaW5lck5vZGVTdHJ1Y3RcIiksXG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHJlZVZpZXdDbGFzczogY29udGFpbmVyTm9kZVN0cnVjdF8xLmdldENvbnRhaW5lclRyZWVWaWV3Q2xhc3MsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUcmVlVmlld0RVQ2xhc3M6IGNvbnRhaW5lck5vZGVTdHJ1Y3RfMi5nZXRDb250YWluZXJUcmVlVmlld0RVQ2xhc3MsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgLy8gQ29udGFpbmVyTm9kZVN0cnVjdFR5cGUgVHJlZVZpZXdzIGRvbid0IGhhbmRsZSByZWN1cnNpdmUgbXV0YWJsZSBUcmVlVmlld3MgbGlrZSBDb250YWluZXJUeXBlIGRvZXMuXG4gICAgICAgIC8vIFVzaW5nIENvbnRhaW5lck5vZGVTdHJ1Y3RUeXBlIGZvciBmaWVsZHMgdGhhdCBoYXZlIG11dGFibGUgdmlld3MgKGxpa2UgYSBMaXN0QmFzaWMpLCB3aWxsIHJlc3VsdCBpblxuICAgICAgICAvLyB1bm5leHBlY3RlZCBiZWhhdmlvdXIgaWYgdGhvc2UgY2hpbGQgdmlld3MgYXJlIG11dGF0ZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCB0aGlzIGV4YW1wbGUgYmVsb3cgd29uJ3QgcGVyc2lzdCB0aGUgcHVzaGVkIHZhbHVlcyB0byB0aGUgbGlzdDpcbiAgICAgICAgLy8gYGBgdHNcbiAgICAgICAgLy8gY29uc3QgdHlwZSA9IENvbnRhaW5lck5vZGVTdHJ1Y3RUeXBlKHthOiBuZXcgTGlzdEJhc2ljVHlwZShieXRlVHlwZSwgMSl9KTtcbiAgICAgICAgLy8gY29uc3QgdmlldyA9IHR5cGUuZGVmYXVsdFZpZXdEVSgpO1xuICAgICAgICAvLyB2aWV3LmEucHVzaCgwKVxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgTGlzdEJhc2ljVmlld0RVIGluIHZpZXcuYSB3aWxsIG5ldmVyIHByb3BhZ2F0ZSB0aGUgY2hhbmdlcyB1cHdhcmRzIHRvIGl0cyBDb250YWluZXJOb2RlU3RydWN0VHlwZS5cbiAgICAgICAgZm9yIChjb25zdCB7IGZpZWxkTmFtZSwgZmllbGRUeXBlIH0gb2YgdGhpcy5maWVsZHNFbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRlXzEuaXNDb21wb3NpdGVUeXBlKGZpZWxkVHlwZSkgJiYgZmllbGRUeXBlLmlzVmlld011dGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29udGFpbmVyTm9kZVN0cnVjdFR5cGUgZmllbGQgJyR7ZmllbGROYW1lfScgJHtmaWVsZFR5cGUudHlwZU5hbWV9IHZpZXcgaXMgbXV0YWJsZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBuYW1lZChmaWVsZHMsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAobmFtZWRfMS5uYW1lZENsYXNzKGNvbnRhaW5lcl8xLkNvbnRhaW5lclR5cGUsIG9wdHMudHlwZU5hbWUpKShmaWVsZHMsIG9wdHMpO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZWRTaXplKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfc2VyaWFsaXplZFNpemUobm9kZS52YWx1ZSk7XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgbm9kZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgYnJhbmNoTm9kZVN0cnVjdF8xLkJyYW5jaE5vZGVTdHJ1Y3QodGhpcy52YWx1ZVRvVHJlZS5iaW5kKHRoaXMpLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFByb29mc1xuICAgIC8vIENvbnRhaW5lck5vZGVTdHJ1Y3RUeXBlIGNhbiBvbmx5IHBhcnNlIHByb29mcyB0aGF0IGNvbnRhaW4gYWxsIHRoZSBkYXRhLlxuICAgIC8vIFRPRE86IFN1cHBvcnQgY29udmVydGluZyBhIHBhcnRpYWwgdHJlZSB0byBhIHBhcnRpYWwgdmFsdWVcbiAgICBnZXRQcm9wZXJ0eUdpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFBvc3QgcHJvY2VzcyB0cmVlIHRvIGNvbnZlcnQgcmVndWxhciBCcmFuY2hOb2RlIHRvIEJyYW5jaE5vZGVTdHJ1Y3RcbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSBjb252ZXJzaW9uc1xuICAgIHRyZWVfZnJvbVByb29mTm9kZShub2RlKSB7XG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgZnJvbSBgbm9kZWAgYWxvbmUgaWYgaXQgY29udGFpbnMgY29tcGxldGUgZGF0YS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRocm93IGEgbmljZSBlcnJvciBcIkNvbnRhaW5lck5vZGVTdHJ1Y3QgdHlwZSByZXF1aXJlcyBwcm9vZnMgZm9yIGFsbCBpdHMgZGF0YVwiXG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShzdXBlci50cmVlX3NlcmlhbGl6ZWRTaXplKG5vZGUpKTtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodWludDhBcnJheS5idWZmZXIsIHVpbnQ4QXJyYXkuYnl0ZU9mZnNldCwgdWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgc3VwZXIudHJlZV9zZXJpYWxpemVUb0J5dGVzKHsgdWludDhBcnJheSwgZGF0YVZpZXcgfSwgMCwgbm9kZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyh7IHVpbnQ4QXJyYXksIGRhdGFWaWV3IH0sIDAsIHVpbnQ4QXJyYXkubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGU6IG5ldyBicmFuY2hOb2RlU3RydWN0XzEuQnJhbmNoTm9kZVN0cnVjdCh0aGlzLnZhbHVlVG9UcmVlLmJpbmQodGhpcyksIHZhbHVlKSxcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE92ZXJ3cml0ZXMgZm9yIGZhc3QgY29udmVyc2lvbiBub2RlIDwtPiB2YWx1ZVxuICAgIHRyZWVfdG9WYWx1ZShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZV90b1RyZWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicmFuY2hOb2RlU3RydWN0XzEuQnJhbmNoTm9kZVN0cnVjdCh0aGlzLnZhbHVlVG9UcmVlLmJpbmQodGhpcyksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gVE9ETzogT3B0aW1pemUgY29udmVyc2lvblxuICAgIHZhbHVlVG9UcmVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFsdWVfc2VyaWFsaXplVG9CeXRlcyh7IHVpbnQ4QXJyYXksIGRhdGFWaWV3IH0sIDAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoeyB1aW50OEFycmF5LCBkYXRhVmlldyB9LCAwLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250YWluZXJOb2RlU3RydWN0VHlwZSA9IENvbnRhaW5lck5vZGVTdHJ1Y3RUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbmVyTm9kZVN0cnVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdEJhc2ljVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGFycmF5QmFzaWNfMSA9IHJlcXVpcmUoXCIuL2FycmF5QmFzaWNcIik7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IG5hbWVkXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9uYW1lZFwiKTtcbmNvbnN0IGxpc3RCYXNpY18xID0gcmVxdWlyZShcIi4uL3ZpZXcvbGlzdEJhc2ljXCIpO1xuY29uc3QgbGlzdEJhc2ljXzIgPSByZXF1aXJlKFwiLi4vdmlld0RVL2xpc3RCYXNpY1wiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbi8qKlxuICogTGlzdDogb3JkZXJlZCB2YXJpYWJsZS1sZW5ndGggaG9tb2dlbmVvdXMgY29sbGVjdGlvbiwgbGltaXRlZCB0byBOIHZhbHVlc1xuICpcbiAqIEFycmF5IG9mIEJhc2ljIHR5cGU6XG4gKiAtIEJhc2ljIHR5cGVzIGFyZSBtYXggMzIgYnl0ZXMgbG9uZyBzbyBtdWx0aXBsZSB2YWx1ZXMgbWF5IGJlIHBhY2tlZCBpbiB0aGUgc2FtZSBub2RlLlxuICogLSBCYXNpYyB0eXBlcyBhcmUgbmV2ZXIgcmV0dXJuZWQgaW4gYSB2aWV3IHdyYXBwZXIsIGJ1dCB0aGVpciB2YWx1ZSByZXByZXNlbnRhdGlvblxuICovXG5jbGFzcyBMaXN0QmFzaWNUeXBlIGV4dGVuZHMgYXJyYXlfMS5BcnJheVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRUeXBlLCBsaW1pdCwgb3B0cykge1xuICAgICAgICBzdXBlcihlbGVtZW50VHlwZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFR5cGUgPSBlbGVtZW50VHlwZTtcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLmZpeGVkU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1ZpZXdNdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGVuID0gMDtcbiAgICAgICAgaWYgKCFlbGVtZW50VHlwZS5pc0Jhc2ljKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJlbGVtZW50VHlwZSBtdXN0IGJlIGJhc2ljXCIpO1xuICAgICAgICBpZiAobGltaXQgPT09IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkxpc3QgbGltaXQgbXVzdCBiZSA+IDBcIik7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBvcHRzPy50eXBlTmFtZSA/PyBgTGlzdFske2VsZW1lbnRUeXBlLnR5cGVOYW1lfSwgJHtsaW1pdH1dYDtcbiAgICAgICAgLy8gVE9ETyBDaGVjayB0aGF0IGl0ZW1zUGVyQ2h1bmsgaXMgYW4gaW50ZWdlclxuICAgICAgICB0aGlzLml0ZW1zUGVyQ2h1bmsgPSAzMiAvIGVsZW1lbnRUeXBlLmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMubWF4Q2h1bmtDb3VudCA9IE1hdGguY2VpbCgodGhpcy5saW1pdCAqIGVsZW1lbnRUeXBlLmJ5dGVMZW5ndGgpIC8gMzIpO1xuICAgICAgICB0aGlzLmNodW5rRGVwdGggPSBtZXJrbGVpemVfMS5tYXhDaHVua3NUb0RlcHRoKHRoaXMubWF4Q2h1bmtDb3VudCk7XG4gICAgICAgIC8vIERlcHRoIGluY2x1ZGVzIHRoZSBleHRyYSBsZXZlbCBmb3IgdGhlIGxlbmd0aCBub2RlXG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLmNodW5rRGVwdGggKyAxO1xuICAgICAgICB0aGlzLm1pblNpemUgPSAwO1xuICAgICAgICB0aGlzLm1heFNpemUgPSB0aGlzLmxpbWl0ICogZWxlbWVudFR5cGUubWF4U2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGVsZW1lbnRUeXBlLCBsaW1pdCwgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lZF8xLm5hbWVkQ2xhc3MoTGlzdEJhc2ljVHlwZSwgb3B0cy50eXBlTmFtZSkpKGVsZW1lbnRUeXBlLCBsaW1pdCwgb3B0cyk7XG4gICAgfVxuICAgIGdldFZpZXcodHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IGxpc3RCYXNpY18xLkxpc3RCYXNpY1RyZWVWaWV3KHRoaXMsIHRyZWUpO1xuICAgIH1cbiAgICBnZXRWaWV3RFUobm9kZSwgY2FjaGUpIHtcbiAgICAgICAgLy8gY2FjaGUgdHlwZSBzaG91bGQgYmUgdmFsaWRhdGVkIChpZiBhcHBsaWNhdGUpIGluIHRoZSB2aWV3XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgbGlzdEJhc2ljXzIuTGlzdEJhc2ljVHJlZVZpZXdEVSh0aGlzLCBub2RlLCBjYWNoZSk7XG4gICAgfVxuICAgIGNvbW1pdFZpZXcodmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5ub2RlO1xuICAgIH1cbiAgICBjb21taXRWaWV3RFUodmlldykge1xuICAgICAgICB2aWV3LmNvbW1pdCgpO1xuICAgICAgICByZXR1cm4gdmlldy5ub2RlO1xuICAgIH1cbiAgICBjYWNoZU9mVmlld0RVKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuY2FjaGU7XG4gICAgfVxuICAgIC8vIFNlcmlhbGl6YXRpb24gKyBkZXNlcmlhbGl6YXRpb25cbiAgICB2YWx1ZV9zZXJpYWxpemVkU2l6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoICogdGhpcy5lbGVtZW50VHlwZS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUJhc2ljKHRoaXMuZWxlbWVudFR5cGUsIHZhbHVlLmxlbmd0aCwgb3V0cHV0LCBvZmZzZXQsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzQXJyYXlCYXNpYyh0aGlzLmVsZW1lbnRUeXBlLCBkYXRhLCBzdGFydCwgZW5kLCB0aGlzKTtcbiAgICB9XG4gICAgdHJlZV9zZXJpYWxpemVkU2l6ZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVfZ2V0TGVuZ3RoKG5vZGUpICogdGhpcy5lbGVtZW50VHlwZS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzTm9kZSA9IHRoaXMudHJlZV9nZXRDaHVua3NOb2RlKG5vZGUpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnRyZWVfZ2V0TGVuZ3RoKG5vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnRyZWVfc2VyaWFsaXplVG9CeXRlc0FycmF5QmFzaWModGhpcy5lbGVtZW50VHlwZSwgbGVuZ3RoLCB0aGlzLmNodW5rRGVwdGgsIG91dHB1dCwgb2Zmc2V0LCBjaHVua3NOb2RlKTtcbiAgICB9XG4gICAgdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBhcnJheUJhc2ljXzEudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5QmFzaWModGhpcy5lbGVtZW50VHlwZSwgdGhpcy5jaHVua0RlcHRoLCBkYXRhLCBzdGFydCwgZW5kLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gSGVscGVycyBmb3IgVHJlZVZpZXdcbiAgICB0cmVlX2dldExlbmd0aChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnJpZ2h0LmdldFVpbnQoNCwgMCk7XG4gICAgfVxuICAgIHRyZWVfc2V0TGVuZ3RoKHRyZWUsIGxlbmd0aCkge1xuICAgICAgICB0cmVlLnJvb3ROb2RlID0gYXJyYXlCYXNpY18xLmFkZExlbmd0aE5vZGUodHJlZS5yb290Tm9kZS5sZWZ0LCBsZW5ndGgpO1xuICAgIH1cbiAgICB0cmVlX2dldENodW5rc05vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5sZWZ0O1xuICAgIH1cbiAgICB0cmVlX3NldENodW5rc05vZGUocm9vdE5vZGUsIGNodW5rc05vZGUsIG5ld0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnNldENodW5rc05vZGUocm9vdE5vZGUsIGNodW5rc05vZGUsIG5ld0xlbmd0aCk7XG4gICAgfVxuICAgIC8vIE1lcmtsZWl6YXRpb25cbiAgICBoYXNoVHJlZVJvb3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1lcmtsZWl6ZV8xLm1peEluTGVuZ3RoKHN1cGVyLmhhc2hUcmVlUm9vdCh2YWx1ZSksIHZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJvb3RzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGFycmF5QmFzaWNfMS52YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlCYXNpYyh0aGlzLmVsZW1lbnRUeXBlLCB2YWx1ZS5sZW5ndGgsIHsgdWludDhBcnJheSwgZGF0YVZpZXcgfSwgMCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVya2xlaXplXzEuc3BsaXRJbnRvUm9vdENodW5rcyh1aW50OEFycmF5KTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RCYXNpY1R5cGUgPSBMaXN0QmFzaWNUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlzdEJhc2ljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0Q29tcG9zaXRlVHlwZSA9IHZvaWQgMDtcbmNvbnN0IG1lcmtsZWl6ZV8xID0gcmVxdWlyZShcIi4uL3V0aWwvbWVya2xlaXplXCIpO1xuY29uc3QgbmFtZWRfMSA9IHJlcXVpcmUoXCIuLi91dGlsL25hbWVkXCIpO1xuY29uc3QgYXJyYXlCYXNpY18xID0gcmVxdWlyZShcIi4vYXJyYXlCYXNpY1wiKTtcbmNvbnN0IGFycmF5Q29tcG9zaXRlXzEgPSByZXF1aXJlKFwiLi9hcnJheUNvbXBvc2l0ZVwiKTtcbmNvbnN0IGxpc3RDb21wb3NpdGVfMSA9IHJlcXVpcmUoXCIuLi92aWV3L2xpc3RDb21wb3NpdGVcIik7XG5jb25zdCBsaXN0Q29tcG9zaXRlXzIgPSByZXF1aXJlKFwiLi4vdmlld0RVL2xpc3RDb21wb3NpdGVcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG4vKipcbiAqIExpc3Q6IG9yZGVyZWQgdmFyaWFibGUtbGVuZ3RoIGhvbW9nZW5lb3VzIGNvbGxlY3Rpb24sIGxpbWl0ZWQgdG8gTiB2YWx1ZXNcbiAqXG4gKiBBcnJheSBvZiBDb21wb3NpdGUgdHlwZTpcbiAqIC0gQ29tcG9zaXRlIHR5cGVzIGFsd2F5cyB0YWtlIGF0IGxlYXN0IG9uZSBjaHVua1xuICogLSBDb21wb3NpdGUgdHlwZXMgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyB2aWV3c1xuICovXG5jbGFzcyBMaXN0Q29tcG9zaXRlVHlwZSBleHRlbmRzIGFycmF5XzEuQXJyYXlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50VHlwZSwgbGltaXQsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudFR5cGUpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGU7XG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5pdGVtc1BlckNodW5rID0gMTtcbiAgICAgICAgdGhpcy5maXhlZFNpemUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTGlzdCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNWaWV3TXV0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbiA9IDA7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZS5pc0Jhc2ljKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJlbGVtZW50VHlwZSBtdXN0IG5vdCBiZSBiYXNpY1wiKTtcbiAgICAgICAgaWYgKGxpbWl0ID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJMaXN0IGxpbWl0IG11c3QgYmUgPiAwXCIpO1xuICAgICAgICB0aGlzLnR5cGVOYW1lID0gb3B0cz8udHlwZU5hbWUgPz8gYExpc3RbJHtlbGVtZW50VHlwZS50eXBlTmFtZX0sICR7bGltaXR9XWA7XG4gICAgICAgIHRoaXMubWF4Q2h1bmtDb3VudCA9IHRoaXMubGltaXQ7XG4gICAgICAgIHRoaXMuY2h1bmtEZXB0aCA9IG1lcmtsZWl6ZV8xLm1heENodW5rc1RvRGVwdGgodGhpcy5tYXhDaHVua0NvdW50KTtcbiAgICAgICAgLy8gRGVwdGggaW5jbHVkZXMgdGhlIGV4dHJhIGxldmVsIGZvciB0aGUgbGVuZ3RoIG5vZGVcbiAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuY2h1bmtEZXB0aCArIDE7XG4gICAgICAgIHRoaXMubWluU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IGFycmF5Q29tcG9zaXRlXzEubWF4U2l6ZUFycmF5Q29tcG9zaXRlKGVsZW1lbnRUeXBlLCB0aGlzLmxpbWl0KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgbmFtZWQoZWxlbWVudFR5cGUsIGxpbWl0LCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgKG5hbWVkXzEubmFtZWRDbGFzcyhMaXN0Q29tcG9zaXRlVHlwZSwgb3B0cy50eXBlTmFtZSkpKGVsZW1lbnRUeXBlLCBsaW1pdCwgb3B0cyk7XG4gICAgfVxuICAgIGdldFZpZXcodHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IGxpc3RDb21wb3NpdGVfMS5MaXN0Q29tcG9zaXRlVHJlZVZpZXcodGhpcywgdHJlZSk7XG4gICAgfVxuICAgIGdldFZpZXdEVShub2RlLCBjYWNoZSkge1xuICAgICAgICAvLyBjYWNoZSB0eXBlIHNob3VsZCBiZSB2YWxpZGF0ZWQgKGlmIGFwcGxpY2F0ZSkgaW4gdGhlIHZpZXdcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyBsaXN0Q29tcG9zaXRlXzIuTGlzdENvbXBvc2l0ZVRyZWVWaWV3RFUodGhpcywgbm9kZSwgY2FjaGUpO1xuICAgIH1cbiAgICBjb21taXRWaWV3KHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcubm9kZTtcbiAgICB9XG4gICAgY29tbWl0Vmlld0RVKHZpZXcpIHtcbiAgICAgICAgdmlldy5jb21taXQoKTtcbiAgICAgICAgcmV0dXJuIHZpZXcubm9kZTtcbiAgICB9XG4gICAgY2FjaGVPZlZpZXdEVSh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3LmNhY2hlO1xuICAgIH1cbiAgICAvLyBTZXJpYWxpemF0aW9uICsgZGVzZXJpYWxpemF0aW9uXG4gICAgdmFsdWVfc2VyaWFsaXplZFNpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29tcG9zaXRlXzEudmFsdWVfc2VyaWFsaXplZFNpemVBcnJheUNvbXBvc2l0ZSh0aGlzLmVsZW1lbnRUeXBlLCB2YWx1ZS5sZW5ndGgsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29tcG9zaXRlXzEudmFsdWVfc2VyaWFsaXplVG9CeXRlc0FycmF5Q29tcG9zaXRlKHRoaXMuZWxlbWVudFR5cGUsIHZhbHVlLmxlbmd0aCwgb3V0cHV0LCBvZmZzZXQsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gYXJyYXlDb21wb3NpdGVfMS52YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5Q29tcG9zaXRlKHRoaXMuZWxlbWVudFR5cGUsIGRhdGEsIHN0YXJ0LCBlbmQsIHRoaXMpO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZWRTaXplKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzTm9kZSA9IHRoaXMudHJlZV9nZXRDaHVua3NOb2RlKG5vZGUpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnRyZWVfZ2V0TGVuZ3RoKG5vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXlDb21wb3NpdGVfMS50cmVlX3NlcmlhbGl6ZWRTaXplQXJyYXlDb21wb3NpdGUodGhpcy5lbGVtZW50VHlwZSwgbGVuZ3RoLCB0aGlzLmNodW5rRGVwdGgsIGNodW5rc05vZGUpO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzTm9kZSA9IHRoaXMudHJlZV9nZXRDaHVua3NOb2RlKG5vZGUpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnRyZWVfZ2V0TGVuZ3RoKG5vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXlDb21wb3NpdGVfMS50cmVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUNvbXBvc2l0ZSh0aGlzLmVsZW1lbnRUeXBlLCBsZW5ndGgsIHRoaXMuY2h1bmtEZXB0aCwgY2h1bmtzTm9kZSwgb3V0cHV0LCBvZmZzZXQpO1xuICAgIH1cbiAgICB0cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29tcG9zaXRlXzEudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5Q29tcG9zaXRlKHRoaXMuZWxlbWVudFR5cGUsIHRoaXMuY2h1bmtEZXB0aCwgZGF0YSwgc3RhcnQsIGVuZCwgdGhpcyk7XG4gICAgfVxuICAgIC8vIEhlbHBlcnMgZm9yIFRyZWVWaWV3XG4gICAgdHJlZV9nZXRMZW5ndGgobm9kZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLmdldExlbmd0aEZyb21Sb290Tm9kZShub2RlKTtcbiAgICB9XG4gICAgdHJlZV9zZXRMZW5ndGgodHJlZSwgbGVuZ3RoKSB7XG4gICAgICAgIHRyZWUucm9vdE5vZGUgPSBhcnJheUJhc2ljXzEuYWRkTGVuZ3RoTm9kZSh0cmVlLnJvb3ROb2RlLmxlZnQsIGxlbmd0aCk7XG4gICAgfVxuICAgIHRyZWVfZ2V0Q2h1bmtzTm9kZShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmxlZnQ7XG4gICAgfVxuICAgIHRyZWVfc2V0Q2h1bmtzTm9kZShyb290Tm9kZSwgY2h1bmtzTm9kZSwgbmV3TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBhcnJheUJhc2ljXzEuc2V0Q2h1bmtzTm9kZShyb290Tm9kZSwgY2h1bmtzTm9kZSwgbmV3TGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gTWVya2xlaXphdGlvblxuICAgIGhhc2hUcmVlUm9vdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbWVya2xlaXplXzEubWl4SW5MZW5ndGgoc3VwZXIuaGFzaFRyZWVSb290KHZhbHVlKSwgdmFsdWUubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0Um9vdHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29tcG9zaXRlXzEudmFsdWVfZ2V0Um9vdHNBcnJheUNvbXBvc2l0ZSh0aGlzLmVsZW1lbnRUeXBlLCB2YWx1ZS5sZW5ndGgsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RDb21wb3NpdGVUeXBlID0gTGlzdENvbXBvc2l0ZVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0Q29tcG9zaXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob25lVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWVcIik7XG5jb25zdCBiYXNpY18xID0gcmVxdWlyZShcIi4vYmFzaWNcIik7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbmNsYXNzIE5vbmVUeXBlIGV4dGVuZHMgYmFzaWNfMS5CYXNpY1R5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGVOYW1lID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXNQZXJDaHVuayA9IDMyO1xuICAgICAgICB0aGlzLmZpeGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubWluU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IDA7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGJ5dGVzIHNlcmRlc1xuICAgIHZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuemVyb05vZGUoMCk7XG4gICAgfVxuICAgIC8vIEZhc3QgdHJlZSBvcHRzXG4gICAgdHJlZV9nZXRGcm9tTm9kZShsZWFmTm9kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJlZV9zZXRUb05vZGUobGVhZk5vZGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJlZV9nZXRGcm9tUGFja2VkTm9kZShsZWFmTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyZWVfc2V0VG9QYWNrZWROb2RlKGxlYWZOb2RlLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBKU09OXG4gICAgZnJvbUpzb24oanNvbikge1xuICAgICAgICBpZiAoanNvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJKU09OIGludmFsaWQgdHlwZSBub25lIG11c3QgYmUgbnVsbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9Kc29uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9uZVR5cGUgPSBOb25lVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVpbnRCaWdpbnRUeXBlID0gZXhwb3J0cy5VaW50TnVtYmVyVHlwZSA9IGV4cG9ydHMudWludEJpZ2ludEJ5dGVMZW5zID0gZXhwb3J0cy51aW50TnVtYmVyQnl0ZUxlbnMgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgbmFtZWRfMSA9IHJlcXVpcmUoXCIuLi91dGlsL25hbWVkXCIpO1xuY29uc3QgYmFzaWNfMSA9IHJlcXVpcmUoXCIuL2Jhc2ljXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZyAqL1xuY29uc3QgTUFYX1NBRkVfSU5URUdFUl9CTiA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG5jb25zdCBCSUdJTlRfMl9QT1dfNjQgPSBCaWdJbnQoMikgKiogQmlnSW50KDY0KTtcbmNvbnN0IEJJR0lOVF8yX1BPV18xMjggPSBCaWdJbnQoMikgKiogQmlnSW50KDEyOCk7XG5jb25zdCBCSUdJTlRfMl9QT1dfMTkyID0gQmlnSW50KDIpICoqIEJpZ0ludCgxOTIpO1xuLy8gY29uc3QgQklHSU5UXzY0X01BWCA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmNvbnN0IE5VTUJFUl8yX1BPV18zMiA9IDIgKiogMzI7XG5jb25zdCBOVU1CRVJfMzJfTUFYID0gMHhmZmZmZmZmZjtcbmV4cG9ydHMudWludE51bWJlckJ5dGVMZW5zID0gWzEsIDIsIDQsIDhdO1xuZXhwb3J0cy51aW50QmlnaW50Qnl0ZUxlbnMgPSBbMSwgMiwgNCwgOCwgMTYsIDMyXTtcbi8qKlxuICogVWludDogTi1iaXQgdW5zaWduZWQgaW50ZWdlciAod2hlcmUgTiBpbiBbOCwgMTYsIDMyLCA2NCwgMTI4LCAyNTZdKVxuICogLSBOb3RhdGlvbjogdWludE5cbiAqXG4gKiBVaW50TnVtYmVyIGlzIHJlcHJlc2VudGVkIGFzIHRoZSBKYXZhc2NyaXB0IHByaW1pdGl2ZSB2YWx1ZSAnTnVtYmVyJy5cbiAqXG4gKiBUaGUgTnVtYmVyIHR5cGUgaXMgYSBkb3VibGUtcHJlY2lzaW9uIDY0LWJpdCBiaW5hcnkgZm9ybWF0IElFRUUgNzU0IHZhbHVlIChudW1iZXJzIGJldHdlZW4gLSgyXjUzIOKIkiAxKSBhbmRcbiAqIDJeNTMg4oiSIDEpLiBJdCBhbHNvIGhhcyB0aGUgc3ltYm9saWMgdmFsdWU6ICtJbmZpbml0eS5cbiAqXG4gKiBBcyBvZiAyMDIxIHBlcmZvcm1hbmNlIG9mICdOdW1iZXInIGlzIGV4dHJlbWVseSBmYXN0ZXIgdGhhbiAnQmlnSW50Jy4gU29tZSB2YWx1ZXMgYXJlIHNwZWMnZWQgYXMgVWludDY0IGJ1dFxuICogcHJhY3RpY2FsbHkgdGhleSB3aWxsIG5ldmVyIGV4Y2VlZCA1MyBiaXRzLCBzdWNoIGFzIGFueSB1bml0IHRpbWUgb3Igc2ltcGxlIGNvdW50ZXJzLiBUaGlzIHR5cGUgaXMgYW4gb3B0aW1pemF0aW9uXG4gKiBmb3IgdGhlc2UgY2FzZXMsIGFzIFVpbnROdW1iZXI2NCBjYW4gcmVwcmVzZW50IGFueSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDJeNTPiiJIxIGFzIHdlbGwgYXMgdGhlIG1heCB2YWx1ZSAyXjY0LTEuXG4gKi9cbmNsYXNzIFVpbnROdW1iZXJUeXBlIGV4dGVuZHMgYmFzaWNfMS5CYXNpY1R5cGUge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVMZW5ndGgsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggPiA4KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVpbnROdW1iZXIgYnl0ZUxlbmd0aCBsaW1pdCBpcyA4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmxvZzIoYnl0ZUxlbmd0aCkgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImJ5dGVMZW5ndGggbXVzdCBiZSBhIHBvd2VyIG9mIDJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlTmFtZSA9IG9wdHM/LnR5cGVOYW1lID8/IGB1aW50JHtieXRlTGVuZ3RoICogOH1gO1xuICAgICAgICBpZiAob3B0cz8uY2xpcEluZmluaXR5KVxuICAgICAgICAgICAgdGhpcy50eXBlTmFtZSArPSBcIkluZlwiO1xuICAgICAgICBpZiAob3B0cz8uc2V0Qml0d2lzZU9SKVxuICAgICAgICAgICAgdGhpcy50eXBlTmFtZSArPSBcIk9SXCI7XG4gICAgICAgIHRoaXMuaXRlbXNQZXJDaHVuayA9IDMyIC8gdGhpcy5ieXRlTGVuZ3RoO1xuICAgICAgICB0aGlzLmZpeGVkU2l6ZSA9IGJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMubWluU2l6ZSA9IGJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IGJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMubWF4RGVjaW1hbFN0ciA9IChCaWdJbnQoMikgKiogQmlnSW50KHRoaXMuYnl0ZUxlbmd0aCAqIDgpIC0gQmlnSW50KDEpKS50b1N0cmluZygxMCk7XG4gICAgICAgIHRoaXMuY2xpcEluZmluaXR5ID0gb3B0cz8uY2xpcEluZmluaXR5ID09PSB0cnVlO1xuICAgICAgICB0aGlzLnNldEJpdHdpc2VPUiA9IG9wdHM/LnNldEJpdHdpc2VPUiA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGJ5dGVMZW5ndGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAobmFtZWRfMS5uYW1lZENsYXNzKFVpbnROdW1iZXJUeXBlLCBvcHRzLnR5cGVOYW1lKSkoYnl0ZUxlbmd0aCwgb3B0cyk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFNlcmlhbGl6YXRpb24gKyBkZXNlcmlhbGl6YXRpb25cbiAgICB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzKHsgZGF0YVZpZXcgfSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldEludDgob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQzMihvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEJlbmNobWFyayBpZiBpdCdzIGZhc3RlciB0byBzZXQgQklHSU5UXzY0X01BWCBvbmNlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQzMihvZmZzZXQsIDB4ZmZmZmZmZmYpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgMHhmZmZmZmZmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MzIob2Zmc2V0LCB2YWx1ZSAmIDB4ZmZmZmZmZmYsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgKHZhbHVlIC8gTlVNQkVSXzJfUE9XXzMyKSAmIDB4ZmZmZmZmZmYsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyh7IGRhdGFWaWV3IH0sIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZFNpemUoZW5kIC0gc3RhcnQpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChzdGFydCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gZGF0YVZpZXcuZ2V0VWludDMyKHN0YXJ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gZGF0YVZpZXcuZ2V0VWludDMyKHN0YXJ0ICsgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGIgPT09IE5VTUJFUl8zMl9NQVggJiYgYSA9PT0gTlVNQkVSXzMyX01BWCAmJiB0aGlzLmNsaXBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiAqIE5VTUJFUl8yX1BPV18zMiArIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgbm9kZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUuZ2V0VWludCh0aGlzLmJ5dGVMZW5ndGgsIDAsIHRoaXMuY2xpcEluZmluaXR5KTtcbiAgICAgICAgdGhpcy52YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkU2l6ZShlbmQgLSBzdGFydCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5MZWFmTm9kZS5mcm9tWmVybygpO1xuICAgICAgICBub2RlLnNldFVpbnQodGhpcy5ieXRlTGVuZ3RoLCAwLCB2YWx1ZSwgdGhpcy5jbGlwSW5maW5pdHkpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8gRmFzdCBUcmVlIGFjY2Vzc1xuICAgIHRyZWVfZ2V0RnJvbU5vZGUobGVhZk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGxlYWZOb2RlLmdldFVpbnQodGhpcy5ieXRlTGVuZ3RoLCAwLCB0aGlzLmNsaXBJbmZpbml0eSk7XG4gICAgfVxuICAgIHRyZWVfc2V0VG9Ob2RlKGxlYWZOb2RlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyZWVfc2V0VG9QYWNrZWROb2RlKGxlYWZOb2RlLCAwLCB2YWx1ZSk7XG4gICAgfVxuICAgIHRyZWVfZ2V0RnJvbVBhY2tlZE5vZGUobGVhZk5vZGUsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEJ5dGVzID0gdGhpcy5ieXRlTGVuZ3RoICogKGluZGV4ICUgdGhpcy5pdGVtc1BlckNodW5rKTtcbiAgICAgICAgcmV0dXJuIGxlYWZOb2RlLmdldFVpbnQodGhpcy5ieXRlTGVuZ3RoLCBvZmZzZXRCeXRlcywgdGhpcy5jbGlwSW5maW5pdHkpO1xuICAgIH1cbiAgICB0cmVlX3NldFRvUGFja2VkTm9kZShsZWFmTm9kZSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEJ5dGVzID0gdGhpcy5ieXRlTGVuZ3RoICogKGluZGV4ICUgdGhpcy5pdGVtc1BlckNodW5rKTtcbiAgICAgICAgLy8gVE9ETzogQmVuY2htYXJrIHRoZSBjb3N0IG9mIHRoaXMgaWYsIGFuZCBjb25zaWRlciB1c2luZyBhIGRpZmZlcmVudCBjbGFzc1xuICAgICAgICBpZiAodGhpcy5zZXRCaXR3aXNlT1IpIHtcbiAgICAgICAgICAgIGxlYWZOb2RlLmJpdHdpc2VPclVpbnQodGhpcy5ieXRlTGVuZ3RoLCBvZmZzZXRCeXRlcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVhZk5vZGUuc2V0VWludCh0aGlzLmJ5dGVMZW5ndGgsIG9mZnNldEJ5dGVzLCB2YWx1ZSwgdGhpcy5jbGlwSW5maW5pdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEpTT05cbiAgICBmcm9tSnNvbihqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGpzb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBJbmZpbml0eSAmJiBqc29uID09PSB0aGlzLm1heERlY2ltYWxTdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyB0byBoYW5kbGUgbWF4IHBvc3NpYmxlIG51bWJlclxuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KGpzb24sIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkpTT04gaW52YWxpZCBudW1iZXIgaXNOYU5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG51bSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IHRvIHByZXZlbnQgZGVjaW1hbCBwcmVjaXNpb24gZXJyb3JzIGRvd25zdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJKU09OIGludmFsaWQgbnVtYmVyID4gTUFYX1NBRkVfSU5URUdFUlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBqc29uID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBpZiAoanNvbiA+IE1BWF9TQUZFX0lOVEVHRVJfQk4pIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyB0byBwcmV2ZW50IGRlY2ltYWwgcHJlY2lzaW9uIGVycm9ycyBkb3duc3RyZWFtXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJKU09OIGludmFsaWQgbnVtYmVyID4gTUFYX1NBRkVfSU5URUdFUl9CTlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgSlNPTiBpbnZhbGlkIHR5cGUgJHt0eXBlb2YganNvbn0gZXhwZWN0ZWQgbnVtYmVyYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9Kc29uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heERlY2ltYWxTdHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoMTApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VaW50TnVtYmVyVHlwZSA9IFVpbnROdW1iZXJUeXBlO1xuLyoqXG4gKiBVaW50OiBOLWJpdCB1bnNpZ25lZCBpbnRlZ2VyICh3aGVyZSBOIGluIFs4LCAxNiwgMzIsIDY0LCAxMjgsIDI1Nl0pXG4gKiAtIE5vdGF0aW9uOiB1aW50TlxuICpcbiAqIFVpbnRCaWdpbnQgaXMgcmVwcmVzZW50ZWQgYXMgdGhlIEphdmFzY3JpcHQgcHJpbWl0aXZlIHZhbHVlICdCaWdJbnQnLlxuICpcbiAqIFRoZSBCaWdJbnQgdHlwZSBpcyBhIG51bWVyaWMgcHJpbWl0aXZlIGluIEphdmFTY3JpcHQgdGhhdCBjYW4gcmVwcmVzZW50IGludGVnZXJzIHdpdGggYXJiaXRyYXJ5IHByZWNpc2lvbi5cbiAqIFdpdGggQmlnSW50cywgeW91IGNhbiBzYWZlbHkgc3RvcmUgYW5kIG9wZXJhdGUgb24gbGFyZ2UgaW50ZWdlcnMgZXZlbiBiZXlvbmQgdGhlIHNhZmUgaW50ZWdlciBsaW1pdCBmb3IgTnVtYmVycy5cbiAqXG4gKiBBcyBvZiAyMDIxIHBlcmZvcm1hbmNlIG9mICdOdW1iZXInIGlzIGV4dHJlbWVseSBmYXN0ZXIgdGhhbiAnQmlnSW50Jy4gRm9yIFVpbnQgdmFsdWVzIHVuZGVyIDUzIGJpdHMgdXNlIFVpbnROdW1iZXIuXG4gKiBGb3Igb3RoZXIgdmFsdWVzIHRoYXQgbWF5IGV4Y2VlZCA1MyBiaXRzLCB1c2UgVWludEJpZ2ludC5cbiAqL1xuY2xhc3MgVWludEJpZ2ludFR5cGUgZXh0ZW5kcyBiYXNpY18xLkJhc2ljVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYnl0ZUxlbmd0aCwgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgICAgICBpZiAoYnl0ZUxlbmd0aCA+IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVpbnRCaWdpbnQgYnl0ZUxlbmd0aCBsaW1pdCBpcyAzMlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5sb2cyKGJ5dGVMZW5ndGgpICUgMSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJieXRlTGVuZ3RoIG11c3QgYmUgYSBwb3dlciBvZiAyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBvcHRzPy50eXBlTmFtZSA/PyBgdWludEJpZ2ludCR7Ynl0ZUxlbmd0aCAqIDh9YDtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5pdGVtc1BlckNodW5rID0gMzIgLyB0aGlzLmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMuZml4ZWRTaXplID0gYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5taW5TaXplID0gYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGJ5dGVMZW5ndGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAobmFtZWRfMS5uYW1lZENsYXNzKFVpbnRCaWdpbnRUeXBlLCBvcHRzLnR5cGVOYW1lKSkoYnl0ZUxlbmd0aCwgb3B0cyk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICB9XG4gICAgLy8gU2VyaWFsaXphdGlvbiArIGRlc2VyaWFsaXphdGlvblxuICAgIHZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXMoeyBkYXRhVmlldyB9LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0SW50OChvZmZzZXQsIE51bWJlcih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQsIE51bWJlcih2YWx1ZSksIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQzMihvZmZzZXQsIE51bWJlcih2YWx1ZSksIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldEJpZ1VpbnQ2NChvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnl0ZUxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBCSUdJTlRfMl9QT1dfNjQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvID0gQmlnSW50LmFzVWludE4oNjQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0QmlnVWludDY0KG9mZnNldCArIGksIGxvLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoeyBkYXRhVmlldyB9LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgaWYgKHNpemUgIT09IHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgc2l6ZSAke3NpemV9IGV4cGVjdGVkICR7dGhpcy5ieXRlTGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IHByZS1hc3NpZ25pbmcgdGhlIHJpZ2h0IGZ1bmN0aW9uIGF0IHRoZSBjb25zdHJ1Y3RvciB0byBhdm9pZCB0aGlzIHN3aXRjaCBpcyBub3QgZmFzdGVyXG4gICAgICAgIHN3aXRjaCAodGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChkYXRhVmlldy5nZXRVaW50OChzdGFydCkpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQoZGF0YVZpZXcuZ2V0VWludDE2KHN0YXJ0LCB0cnVlKSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChkYXRhVmlldy5nZXRVaW50MzIoc3RhcnQsIHRydWUpKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0LCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgMTY6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0ICsgOCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKiBCSUdJTlRfMl9QT1dfNjQgKyBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzMjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBkYXRhVmlldy5nZXRCaWdVaW50NjQoc3RhcnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBkYXRhVmlldy5nZXRCaWdVaW50NjQoc3RhcnQgKyA4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0ICsgMTYsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBkYXRhVmlldy5nZXRCaWdVaW50NjQoc3RhcnQgKyAyNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQgKiBCSUdJTlRfMl9QT1dfMTkyICsgYyAqIEJJR0lOVF8yX1BPV18xMjggKyBiICogQklHSU5UXzJfUE9XXzY0ICsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLmdldFVpbnRCaWdpbnQodGhpcy5ieXRlTGVuZ3RoLCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBzaXplID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIGlmIChzaXplICE9PSB0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIHNpemUgJHtzaXplfSBleHBlY3RlZCAke3RoaXMuYnl0ZUxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuTGVhZk5vZGUuZnJvbVplcm8oKTtcbiAgICAgICAgbm9kZS5zZXRVaW50QmlnaW50KHRoaXMuYnl0ZUxlbmd0aCwgMCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8gRmFzdCBUcmVlIGFjY2Vzc1xuICAgIHRyZWVfZ2V0RnJvbU5vZGUobGVhZk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGxlYWZOb2RlLmdldFVpbnRCaWdpbnQodGhpcy5ieXRlTGVuZ3RoLCAwKTtcbiAgICB9XG4gICAgLyoqIE11dGF0ZXMgbm9kZSB0byBzZXQgdmFsdWUgKi9cbiAgICB0cmVlX3NldFRvTm9kZShsZWFmTm9kZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlX3NldFRvUGFja2VkTm9kZShsZWFmTm9kZSwgMCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKiogRVhBTVBMRSBvZiBgdHJlZV9nZXRGcm9tTm9kZWAgKi9cbiAgICB0cmVlX2dldEZyb21QYWNrZWROb2RlKGxlYWZOb2RlLCBpbmRleCkge1xuICAgICAgICBjb25zdCBvZmZzZXRCeXRlcyA9IHRoaXMuYnl0ZUxlbmd0aCAqIChpbmRleCAlIHRoaXMuaXRlbXNQZXJDaHVuayk7XG4gICAgICAgIHJldHVybiBsZWFmTm9kZS5nZXRVaW50QmlnaW50KHRoaXMuYnl0ZUxlbmd0aCwgb2Zmc2V0Qnl0ZXMpO1xuICAgIH1cbiAgICAvKiogTXV0YXRlcyBub2RlIHRvIHNldCB2YWx1ZSAqL1xuICAgIHRyZWVfc2V0VG9QYWNrZWROb2RlKGxlYWZOb2RlLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0Qnl0ZXMgPSB0aGlzLmJ5dGVMZW5ndGggKiAoaW5kZXggJSB0aGlzLml0ZW1zUGVyQ2h1bmspO1xuICAgICAgICAvLyBUT0RPOiBOb3Qtb3B0aW1pemVkLCBjb3B5IHBhc3RlZCBmcm9tIFVpbnROdW1iZXJUeXBlXG4gICAgICAgIGxlYWZOb2RlLnNldFVpbnRCaWdpbnQodGhpcy5ieXRlTGVuZ3RoLCBvZmZzZXRCeXRlcywgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBKU09OXG4gICAgZnJvbUpzb24oanNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBqc29uID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBqc29uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEpTT04gaW52YWxpZCB0eXBlICR7dHlwZW9mIGpzb259IGV4cGVjdGVkIGJpZ2ludGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSnNvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoMTApO1xuICAgIH1cbn1cbmV4cG9ydHMuVWludEJpZ2ludFR5cGUgPSBVaW50QmlnaW50VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuaW9uVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWVcIik7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IG5hbWVkXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9uYW1lZFwiKTtcbmNvbnN0IGNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4vY29tcG9zaXRlXCIpO1xuY29uc3QgYXJyYXlCYXNpY18xID0gcmVxdWlyZShcIi4vYXJyYXlCYXNpY1wiKTtcbmNvbnN0IG5vbmVfMSA9IHJlcXVpcmUoXCIuL25vbmVcIik7XG5jb25zdCBWQUxVRV9HSU5ERVggPSBCaWdJbnQoMik7XG5jb25zdCBTRUxFQ1RPUl9HSU5ERVggPSBCaWdJbnQoMyk7XG4vKipcbiAqIFVuaW9uOiB1bmlvbiB0eXBlIGNvbnRhaW5pbmcgb25lIG9mIHRoZSBnaXZlbiBzdWJ0eXBlc1xuICogLSBOb3RhdGlvbjogVW5pb25bdHlwZV8wLCB0eXBlXzEsIC4uLl0sIGUuZy4gdW5pb25bTm9uZSwgdWludDY0LCB1aW50MzJdXG4gKi9cbmNsYXNzIFVuaW9uVHlwZSBleHRlbmRzIGNvbXBvc2l0ZV8xLkNvbXBvc2l0ZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHR5cGVzLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgdGhpcy5kZXB0aCA9IDE7XG4gICAgICAgIHRoaXMubWF4Q2h1bmtDb3VudCA9IDE7XG4gICAgICAgIHRoaXMuZml4ZWRTaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0xpc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzVmlld011dGFibGUgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZXMubGVuZ3RoID49IDEyOCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNdXN0IGhhdmUgbGVzcyB0aGFuIDEyOCB0eXBlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11c3QgaGF2ZSBhdCBsZWFzdCAxIHR5cGUgb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc1swXSBpbnN0YW5jZW9mIG5vbmVfMS5Ob25lVHlwZSAmJiB0eXBlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11c3QgaGF2ZSBhdCBsZWFzdCAyIHR5cGUgb3B0aW9ucyBpZiB0aGUgZmlyc3QgaXMgTm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNbaV0gaW5zdGFuY2VvZiBub25lXzEuTm9uZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vbmUgbWF5IG9ubHkgYmUgdGhlIGZpcnN0IG9wdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGVOYW1lID0gb3B0cz8udHlwZU5hbWUgPz8gYFVuaW9uWyR7dHlwZXMubWFwKCh0KSA9PiB0LnR5cGVOYW1lKS5qb2luKFwiLFwiKX1dYDtcbiAgICAgICAgY29uc3QgbWluTGVucyA9IFtdO1xuICAgICAgICBjb25zdCBtYXhMZW5zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgX3R5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgICAgIG1pbkxlbnMucHVzaChfdHlwZS5taW5TaXplKTtcbiAgICAgICAgICAgIG1heExlbnMucHVzaChfdHlwZS5tYXhTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblNpemUgPSAxICsgTWF0aC5taW4oLi4ubWluTGVucyk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IDEgKyBNYXRoLm1heCguLi5tYXhMZW5zKTtcbiAgICAgICAgdGhpcy5tYXhTZWxlY3RvciA9IHRoaXMudHlwZXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKHR5cGVzLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgKG5hbWVkXzEubmFtZWRDbGFzcyhVbmlvblR5cGUsIG9wdHMudHlwZU5hbWUpKSh0eXBlcywgb3B0cyk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAwLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudHlwZXNbMF0uZGVmYXVsdFZhbHVlKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFZpZXcodHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlX3RvVmFsdWUodHJlZS5yb290Tm9kZSk7XG4gICAgfVxuICAgIGdldFZpZXdEVShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVfdG9WYWx1ZShub2RlKTtcbiAgICB9XG4gICAgY2FjaGVPZlZpZXdEVSgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXRWaWV3KHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfdG9UcmVlKHZpZXcpO1xuICAgIH1cbiAgICBjb21taXRWaWV3RFUodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV90b1RyZWUodmlldyk7XG4gICAgfVxuICAgIHZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAxICsgdGhpcy50eXBlc1t2YWx1ZS5zZWxlY3Rvcl0udmFsdWVfc2VyaWFsaXplZFNpemUodmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBvdXRwdXQudWludDhBcnJheVtvZmZzZXRdID0gdmFsdWUuc2VsZWN0b3I7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVzW3ZhbHVlLnNlbGVjdG9yXS52YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0ICsgMSwgdmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZGF0YS51aW50OEFycmF5W3N0YXJ0XTtcbiAgICAgICAgaWYgKHNlbGVjdG9yID4gdGhpcy5tYXhTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgc2VsZWN0b3IgJHtzZWxlY3Rvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50eXBlc1tzZWxlY3Rvcl0udmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQgKyAxLCBlbmQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZWRTaXplKG5vZGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBhcnJheUJhc2ljXzEuZ2V0TGVuZ3RoRnJvbVJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgIHJldHVybiAxICsgdGhpcy50eXBlc1tzZWxlY3Rvcl0udmFsdWVfc2VyaWFsaXplZFNpemUodmFsdWVOb2RlKTtcbiAgICB9XG4gICAgdHJlZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYXJyYXlCYXNpY18xLmdldExlbmd0aEZyb21Sb290Tm9kZShub2RlKTtcbiAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICBvdXRwdXQudWludDhBcnJheVtvZmZzZXRdID0gc2VsZWN0b3I7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVzW3NlbGVjdG9yXS50cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQgKyAxLCB2YWx1ZU5vZGUpO1xuICAgIH1cbiAgICB0cmVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBkYXRhLnVpbnQ4QXJyYXlbc3RhcnRdO1xuICAgICAgICBpZiAoc2VsZWN0b3IgPiB0aGlzLm1heFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBzZWxlY3RvciAke3NlbGVjdG9yfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHRoaXMudHlwZXNbc2VsZWN0b3JdLnRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXMoZGF0YSwgc3RhcnQgKyAxLCBlbmQpO1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLmFkZExlbmd0aE5vZGUodmFsdWVOb2RlLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8vIE1lcmtsZWl6YXRpb25cbiAgICBoYXNoVHJlZVJvb3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1lcmtsZWl6ZV8xLm1peEluTGVuZ3RoKHN1cGVyLmhhc2hUcmVlUm9vdCh2YWx1ZSksIHZhbHVlLnNlbGVjdG9yKTtcbiAgICB9XG4gICAgZ2V0Um9vdHModmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWVSb290ID0gdGhpcy50eXBlc1t2YWx1ZS5zZWxlY3Rvcl0uaGFzaFRyZWVSb290KHZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZVJvb3RdO1xuICAgIH1cbiAgICAvLyBQcm9vZnNcbiAgICBnZXRQcm9wZXJ0eUdpbmRleChwcm9wKSB7XG4gICAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZBTFVFX0dJTkRFWDtcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBTRUxFQ1RPUl9HSU5ERVg7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVbmlvbiB0eXBlIHByb3BlcnR5ICR7cHJvcH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRQcm9wZXJ0eVR5cGUoKSB7XG4gICAgICAgIC8vIGEgVW5pb24gaGFzIG11bHRpcGxlIHR5cGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhcHBsaWNhYmxlIGZvciBVbmlvbiB0eXBlXCIpO1xuICAgIH1cbiAgICBnZXRJbmRleFByb3BlcnR5KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBcInZhbHVlXCI7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBcInNlbGVjdG9yXCI7XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5pb24gaW5kZXggb2Ygb3V0IGJvdW5kc1wiKTtcbiAgICB9XG4gICAgdHJlZV9nZXRMZWFmR2luZGljZXMocm9vdEdpbmRleCwgcm9vdE5vZGUpIHtcbiAgICAgICAgaWYgKCFyb290Tm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJyb290Tm9kZSByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnaW5kaWNlcyA9IFtwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuY29uY2F0R2luZGljZXMoW3Jvb3RHaW5kZXgsIFNFTEVDVE9SX0dJTkRFWF0pXTtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBhcnJheUJhc2ljXzEuZ2V0TGVuZ3RoRnJvbVJvb3ROb2RlKHJvb3ROb2RlKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZXNbc2VsZWN0b3JdO1xuICAgICAgICBjb25zdCBleHRlbmRlZEZpZWxkR2luZGV4ID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmNvbmNhdEdpbmRpY2VzKFtyb290R2luZGV4LCBWQUxVRV9HSU5ERVhdKTtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZV8xLmlzQ29tcG9zaXRlVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgZ2luZGljZXMucHVzaCguLi50eXBlLnRyZWVfZ2V0TGVhZkdpbmRpY2VzKGV4dGVuZGVkRmllbGRHaW5kZXgsIHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2RlKHJvb3ROb2RlLCBWQUxVRV9HSU5ERVgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnaW5kaWNlcy5wdXNoKGV4dGVuZGVkRmllbGRHaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnaW5kaWNlcztcbiAgICB9XG4gICAgLy8gSlNPTlxuICAgIGZyb21Kc29uKGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OIG11c3QgYmUgb2YgdHlwZSBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5pb24gPSBqc29uO1xuICAgICAgICBpZiAodHlwZW9mIHVuaW9uLnNlbGVjdG9yICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEpTT04gVW5pb24gc2VsZWN0b3IgbXVzdCBiZSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZXNbdW5pb24uc2VsZWN0b3JdO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSlNPTiBVbmlvbiBzZWxlY3RvciBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB1bmlvbi5zZWxlY3RvcixcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlLnRvSnNvbih1bmlvbi52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvSnNvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0b3I6IHZhbHVlLnNlbGVjdG9yLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudHlwZXNbdmFsdWUuc2VsZWN0b3JdLnRvSnNvbih2YWx1ZS52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNsb25lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3RvcjogdmFsdWUuc2VsZWN0b3IsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50eXBlc1t2YWx1ZS5zZWxlY3Rvcl0uY2xvbmUodmFsdWUudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICBpZiAoYS5zZWxlY3RvciAhPT0gYi5zZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVzW2Euc2VsZWN0b3JdLmVxdWFscyhhLnZhbHVlLCBiLnZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uVHlwZSA9IFVuaW9uVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WZWN0b3JCYXNpY1R5cGUgPSB2b2lkIDA7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IG5hbWVkXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9uYW1lZFwiKTtcbmNvbnN0IGFycmF5QmFzaWNfMSA9IHJlcXVpcmUoXCIuL2FycmF5QmFzaWNcIik7XG5jb25zdCBhcnJheUJhc2ljXzIgPSByZXF1aXJlKFwiLi4vdmlldy9hcnJheUJhc2ljXCIpO1xuY29uc3QgYXJyYXlCYXNpY18zID0gcmVxdWlyZShcIi4uL3ZpZXdEVS9hcnJheUJhc2ljXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuLyoqXG4gKiBWZWN0b3I6IE9yZGVyZWQgZml4ZWQtbGVuZ3RoIGhvbW9nZW5lb3VzIGNvbGxlY3Rpb24sIHdpdGggTiB2YWx1ZXNcbiAqXG4gKiBBcnJheSBvZiBCYXNpYyB0eXBlOlxuICogLSBCYXNpYyB0eXBlcyBhcmUgbWF4IDMyIGJ5dGVzIGxvbmcgc28gbXVsdGlwbGUgdmFsdWVzIG1heSBiZSBwYWNrZWQgaW4gdGhlIHNhbWUgbm9kZS5cbiAqIC0gQmFzaWMgdHlwZXMgYXJlIG5ldmVyIHJldHVybmVkIGluIGEgdmlldyB3cmFwcGVyLCBidXQgdGhlaXIgdmFsdWUgcmVwcmVzZW50YXRpb25cbiAqL1xuY2xhc3MgVmVjdG9yQmFzaWNUeXBlIGV4dGVuZHMgYXJyYXlfMS5BcnJheVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRUeXBlLCBsZW5ndGgsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudFR5cGUpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmlzTGlzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVmlld011dGFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoIWVsZW1lbnRUeXBlLmlzQmFzaWMpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImVsZW1lbnRUeXBlIG11c3QgYmUgYmFzaWNcIik7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlZlY3RvciBsZW5ndGggbXVzdCBiZSA+IDBcIik7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBvcHRzPy50eXBlTmFtZSA/PyBgVmVjdG9yWyR7ZWxlbWVudFR5cGUudHlwZU5hbWV9LCAke2xlbmd0aH1dYDtcbiAgICAgICAgLy8gVE9ETyBDaGVjayB0aGF0IGl0ZW1zUGVyQ2h1bmsgaXMgYW4gaW50ZWdlclxuICAgICAgICB0aGlzLml0ZW1zUGVyQ2h1bmsgPSAzMiAvIGVsZW1lbnRUeXBlLmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMubWF4Q2h1bmtDb3VudCA9IE1hdGguY2VpbCgobGVuZ3RoICogZWxlbWVudFR5cGUuYnl0ZUxlbmd0aCkgLyAzMik7XG4gICAgICAgIHRoaXMuY2h1bmtEZXB0aCA9IG1lcmtsZWl6ZV8xLm1heENodW5rc1RvRGVwdGgodGhpcy5tYXhDaHVua0NvdW50KTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuY2h1bmtEZXB0aDtcbiAgICAgICAgdGhpcy5maXhlZFNpemUgPSBsZW5ndGggKiBlbGVtZW50VHlwZS5ieXRlTGVuZ3RoO1xuICAgICAgICB0aGlzLm1pblNpemUgPSB0aGlzLmZpeGVkU2l6ZTtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gdGhpcy5maXhlZFNpemU7XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbiA9IGxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIG5hbWVkKGVsZW1lbnRUeXBlLCBsaW1pdCwgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lZF8xLm5hbWVkQ2xhc3MoVmVjdG9yQmFzaWNUeXBlLCBvcHRzLnR5cGVOYW1lKSkoZWxlbWVudFR5cGUsIGxpbWl0LCBvcHRzKTtcbiAgICB9XG4gICAgZ2V0Vmlldyh0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXJyYXlCYXNpY18yLkFycmF5QmFzaWNUcmVlVmlldyh0aGlzLCB0cmVlKTtcbiAgICB9XG4gICAgZ2V0Vmlld0RVKG5vZGUsIGNhY2hlKSB7XG4gICAgICAgIC8vIGNhY2hlIHR5cGUgc2hvdWxkIGJlIHZhbGlkYXRlZCAoaWYgYXBwbGljYXRlKSBpbiB0aGUgdmlld1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gbmV3IGFycmF5QmFzaWNfMy5BcnJheUJhc2ljVHJlZVZpZXdEVSh0aGlzLCBub2RlLCBjYWNoZSk7XG4gICAgfVxuICAgIGNvbW1pdFZpZXcodmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5ub2RlO1xuICAgIH1cbiAgICBjb21taXRWaWV3RFUodmlldykge1xuICAgICAgICB2aWV3LmNvbW1pdCgpO1xuICAgICAgICByZXR1cm4gdmlldy5ub2RlO1xuICAgIH1cbiAgICBjYWNoZU9mVmlld0RVKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuY2FjaGU7XG4gICAgfVxuICAgIC8vIFNlcmlhbGl6YXRpb24gKyBkZXNlcmlhbGl6YXRpb25cbiAgICB2YWx1ZV9zZXJpYWxpemVkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4ZWRTaXplO1xuICAgIH1cbiAgICB2YWx1ZV9zZXJpYWxpemVUb0J5dGVzKG91dHB1dCwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnZhbHVlX3NlcmlhbGl6ZVRvQnl0ZXNBcnJheUJhc2ljKHRoaXMuZWxlbWVudFR5cGUsIHRoaXMubGVuZ3RoLCBvdXRwdXQsIG9mZnNldCwgdmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBhcnJheUJhc2ljXzEudmFsdWVfZGVzZXJpYWxpemVGcm9tQnl0ZXNBcnJheUJhc2ljKHRoaXMuZWxlbWVudFR5cGUsIGRhdGEsIHN0YXJ0LCBlbmQsIHRoaXMpO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXhlZFNpemU7XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgbm9kZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNpY18xLnRyZWVfc2VyaWFsaXplVG9CeXRlc0FycmF5QmFzaWModGhpcy5lbGVtZW50VHlwZSwgdGhpcy5sZW5ndGgsIHRoaXMuZGVwdGgsIG91dHB1dCwgb2Zmc2V0LCBub2RlKTtcbiAgICB9XG4gICAgdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBhcnJheUJhc2ljXzEudHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlc0FycmF5QmFzaWModGhpcy5lbGVtZW50VHlwZSwgdGhpcy5kZXB0aCwgZGF0YSwgc3RhcnQsIGVuZCwgdGhpcyk7XG4gICAgfVxuICAgIC8vIEhlbHBlcnMgZm9yIFRyZWVWaWV3XG4gICAgdHJlZV9nZXRMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgdHJlZV9zZXRMZW5ndGgoKSB7XG4gICAgICAgIC8vIFZlY3RvcidzIGxlbmd0aCBpcyBpbW11dGFibGUsIGlnbm9yZSB0aGlzIGNhbGxcbiAgICB9XG4gICAgdHJlZV9nZXRDaHVua3NOb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHRyZWVfc2V0Q2h1bmtzTm9kZShyb290Tm9kZSwgY2h1bmtzTm9kZSkge1xuICAgICAgICByZXR1cm4gY2h1bmtzTm9kZTtcbiAgICB9XG4gICAgLy8gTWVya2xlaXphdGlvblxuICAgIGdldFJvb3RzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLmZpeGVkU2l6ZSk7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGFycmF5QmFzaWNfMS52YWx1ZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlCYXNpYyh0aGlzLmVsZW1lbnRUeXBlLCB0aGlzLmxlbmd0aCwgeyB1aW50OEFycmF5LCBkYXRhVmlldyB9LCAwLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXJrbGVpemVfMS5zcGxpdEludG9Sb290Q2h1bmtzKHVpbnQ4QXJyYXkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmVjdG9yQmFzaWNUeXBlID0gVmVjdG9yQmFzaWNUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yQmFzaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZlY3RvckNvbXBvc2l0ZVR5cGUgPSB2b2lkIDA7XG5jb25zdCBtZXJrbGVpemVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmtsZWl6ZVwiKTtcbmNvbnN0IG5hbWVkXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9uYW1lZFwiKTtcbmNvbnN0IGFycmF5Q29tcG9zaXRlXzEgPSByZXF1aXJlKFwiLi9hcnJheUNvbXBvc2l0ZVwiKTtcbmNvbnN0IGFycmF5Q29tcG9zaXRlXzIgPSByZXF1aXJlKFwiLi4vdmlldy9hcnJheUNvbXBvc2l0ZVwiKTtcbmNvbnN0IGFycmF5Q29tcG9zaXRlXzMgPSByZXF1aXJlKFwiLi4vdmlld0RVL2FycmF5Q29tcG9zaXRlXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuLyoqXG4gKiBWZWN0b3I6IE9yZGVyZWQgZml4ZWQtbGVuZ3RoIGhvbW9nZW5lb3VzIGNvbGxlY3Rpb24sIHdpdGggTiB2YWx1ZXNcbiAqXG4gKiBBcnJheSBvZiBDb21wb3NpdGUgdHlwZTpcbiAqIC0gQ29tcG9zaXRlIHR5cGVzIGFsd2F5cyB0YWtlIGF0IGxlYXN0IG9uZSBjaHVua1xuICogLSBDb21wb3NpdGUgdHlwZXMgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyB2aWV3c1xuICovXG5jbGFzcyBWZWN0b3JDb21wb3NpdGVUeXBlIGV4dGVuZHMgYXJyYXlfMS5BcnJheVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRUeXBlLCBsZW5ndGgsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudFR5cGUpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLml0ZW1zUGVyQ2h1bmsgPSAxO1xuICAgICAgICB0aGlzLmlzTGlzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVmlld011dGFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUuaXNCYXNpYylcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZWxlbWVudFR5cGUgbXVzdCBub3QgYmUgYmFzaWNcIik7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlZlY3RvciBsZW5ndGggbXVzdCBiZSA+IDBcIik7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBvcHRzPy50eXBlTmFtZSA/PyBgVmVjdG9yWyR7ZWxlbWVudFR5cGUudHlwZU5hbWV9LCAke2xlbmd0aH1dYDtcbiAgICAgICAgdGhpcy5tYXhDaHVua0NvdW50ID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmNodW5rRGVwdGggPSBtZXJrbGVpemVfMS5tYXhDaHVua3NUb0RlcHRoKHRoaXMubWF4Q2h1bmtDb3VudCk7XG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLmNodW5rRGVwdGg7XG4gICAgICAgIHRoaXMuZml4ZWRTaXplID0gZWxlbWVudFR5cGUuZml4ZWRTaXplID09PSBudWxsID8gbnVsbCA6IGxlbmd0aCAqIGVsZW1lbnRUeXBlLmZpeGVkU2l6ZTtcbiAgICAgICAgdGhpcy5taW5TaXplID0gYXJyYXlDb21wb3NpdGVfMS5taW5TaXplQXJyYXlDb21wb3NpdGUoZWxlbWVudFR5cGUsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IGFycmF5Q29tcG9zaXRlXzEubWF4U2l6ZUFycmF5Q29tcG9zaXRlKGVsZW1lbnRUeXBlLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLmRlZmF1bHRMZW4gPSBsZW5ndGg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIG5hbWVkKGVsZW1lbnRUeXBlLCBsaW1pdCwgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IChuYW1lZF8xLm5hbWVkQ2xhc3MoVmVjdG9yQ29tcG9zaXRlVHlwZSwgb3B0cy50eXBlTmFtZSkpKGVsZW1lbnRUeXBlLCBsaW1pdCwgb3B0cyk7XG4gICAgfVxuICAgIGdldFZpZXcodHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IGFycmF5Q29tcG9zaXRlXzIuQXJyYXlDb21wb3NpdGVUcmVlVmlldyh0aGlzLCB0cmVlKTtcbiAgICB9XG4gICAgZ2V0Vmlld0RVKG5vZGUsIGNhY2hlKSB7XG4gICAgICAgIC8vIGNhY2hlIHR5cGUgc2hvdWxkIGJlIHZhbGlkYXRlZCAoaWYgYXBwbGljYXRlKSBpbiB0aGUgdmlld1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gbmV3IGFycmF5Q29tcG9zaXRlXzMuQXJyYXlDb21wb3NpdGVUcmVlVmlld0RVKHRoaXMsIG5vZGUsIGNhY2hlKTtcbiAgICB9XG4gICAgY29tbWl0Vmlldyh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3Lm5vZGU7XG4gICAgfVxuICAgIGNvbW1pdFZpZXdEVSh2aWV3KSB7XG4gICAgICAgIHZpZXcuY29tbWl0KCk7XG4gICAgICAgIHJldHVybiB2aWV3Lm5vZGU7XG4gICAgfVxuICAgIGNhY2hlT2ZWaWV3RFUodmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5jYWNoZTtcbiAgICB9XG4gICAgLy8gU2VyaWFsaXphdGlvbiArIGRlc2VyaWFsaXphdGlvblxuICAgIHZhbHVlX3NlcmlhbGl6ZWRTaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhcnJheUNvbXBvc2l0ZV8xLnZhbHVlX3NlcmlhbGl6ZWRTaXplQXJyYXlDb21wb3NpdGUodGhpcy5lbGVtZW50VHlwZSwgdGhpcy5sZW5ndGgsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWVfc2VyaWFsaXplVG9CeXRlcyhvdXRwdXQsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29tcG9zaXRlXzEudmFsdWVfc2VyaWFsaXplVG9CeXRlc0FycmF5Q29tcG9zaXRlKHRoaXMuZWxlbWVudFR5cGUsIHRoaXMubGVuZ3RoLCBvdXRwdXQsIG9mZnNldCwgdmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBhcnJheUNvbXBvc2l0ZV8xLnZhbHVlX2Rlc2VyaWFsaXplRnJvbUJ5dGVzQXJyYXlDb21wb3NpdGUodGhpcy5lbGVtZW50VHlwZSwgZGF0YSwgc3RhcnQsIGVuZCwgdGhpcyk7XG4gICAgfVxuICAgIHRyZWVfc2VyaWFsaXplZFNpemUobm9kZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlDb21wb3NpdGVfMS50cmVlX3NlcmlhbGl6ZWRTaXplQXJyYXlDb21wb3NpdGUodGhpcy5lbGVtZW50VHlwZSwgdGhpcy5sZW5ndGgsIHRoaXMuZGVwdGgsIG5vZGUpO1xuICAgIH1cbiAgICB0cmVlX3NlcmlhbGl6ZVRvQnl0ZXMob3V0cHV0LCBvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29tcG9zaXRlXzEudHJlZV9zZXJpYWxpemVUb0J5dGVzQXJyYXlDb21wb3NpdGUodGhpcy5lbGVtZW50VHlwZSwgdGhpcy5sZW5ndGgsIHRoaXMuZGVwdGgsIG5vZGUsIG91dHB1dCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdHJlZV9kZXNlcmlhbGl6ZUZyb21CeXRlcyhkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBhcnJheUNvbXBvc2l0ZV8xLnRyZWVfZGVzZXJpYWxpemVGcm9tQnl0ZXNBcnJheUNvbXBvc2l0ZSh0aGlzLmVsZW1lbnRUeXBlLCB0aGlzLmRlcHRoLCBkYXRhLCBzdGFydCwgZW5kLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gSGVscGVycyBmb3IgVHJlZVZpZXdcbiAgICB0cmVlX2dldExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICB0cmVlX3NldExlbmd0aCgpIHtcbiAgICAgICAgLy8gVmVjdG9yJ3MgbGVuZ3RoIGlzIGltbXV0YWJsZSwgaWdub3JlIHRoaXMgY2FsbFxuICAgIH1cbiAgICB0cmVlX2dldENodW5rc05vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdHJlZV9zZXRDaHVua3NOb2RlKHJvb3ROb2RlLCBjaHVua3NOb2RlKSB7XG4gICAgICAgIHJldHVybiBjaHVua3NOb2RlO1xuICAgIH1cbiAgICAvLyBNZXJrbGVpemF0aW9uXG4gICAgZ2V0Um9vdHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Q29tcG9zaXRlXzEudmFsdWVfZ2V0Um9vdHNBcnJheUNvbXBvc2l0ZSh0aGlzLmVsZW1lbnRUeXBlLCB0aGlzLmxlbmd0aCwgdmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmVjdG9yQ29tcG9zaXRlVHlwZSA9IFZlY3RvckNvbXBvc2l0ZVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWN0b3JDb21wb3NpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ5dGVBcnJheUVxdWFscyA9IGV4cG9ydHMuZnJvbUhleFN0cmluZyA9IGV4cG9ydHMudG9IZXhTdHJpbmcgPSB2b2lkIDA7XG4vLyBDYWNoaW5nIHRoaXMgaW5mbyBjb3N0cyBhYm91dCB+MTAwMCBieXRlcyBhbmQgc3BlZWRzIHVwIHRvSGV4U3RyaW5nKCkgYnkgeDZcbmNvbnN0IGhleEJ5Qnl0ZSA9IG5ldyBBcnJheSgyNTYpO1xuZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZXMpIHtcbiAgICBsZXQgaGV4ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICBpZiAoIWhleEJ5Qnl0ZVtieXRlXSkge1xuICAgICAgICAgICAgaGV4QnlCeXRlW2J5dGVdID0gYnl0ZSA8IDE2ID8gXCIwXCIgKyBieXRlLnRvU3RyaW5nKDE2KSA6IGJ5dGUudG9TdHJpbmcoMTYpO1xuICAgICAgICB9XG4gICAgICAgIGhleCArPSBoZXhCeUJ5dGVbYnl0ZV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLnRvSGV4U3RyaW5nID0gdG9IZXhTdHJpbmc7XG5mdW5jdGlvbiBmcm9tSGV4U3RyaW5nKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGV4IGFyZ3VtZW50IHR5cGUgJHt0eXBlb2YgaGV4fSBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nYCk7XG4gICAgfVxuICAgIGlmIChoZXguc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgIGhleCA9IGhleC5zbGljZSgyKTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGV4IHN0cmluZyBsZW5ndGggJHtoZXgubGVuZ3RofSBtdXN0IGJlIG11bHRpcGxlIG9mIDJgKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZUxlbiA9IGhleC5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IHBhcnNlSW50KGhleC5zbGljZShpICogMiwgKGkgKyAxKSAqIDIpLCAxNik7XG4gICAgICAgIGJ5dGVzW2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5mcm9tSGV4U3RyaW5nID0gZnJvbUhleFN0cmluZztcbmZ1bmN0aW9uIGJ5dGVBcnJheUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmJ5dGVBcnJheUVxdWFscyA9IGJ5dGVBcnJheUVxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVBcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV4dFBvd2VyT2YyID0gZXhwb3J0cy5tYXhDaHVua3NUb0RlcHRoID0gZXhwb3J0cy5iaXRMZW5ndGggPSBleHBvcnRzLm1peEluTGVuZ3RoID0gZXhwb3J0cy5zcGxpdEludG9Sb290Q2h1bmtzID0gZXhwb3J0cy5tZXJrbGVpemUgPSBleHBvcnRzLmhhc2g2NCA9IHZvaWQgMDtcbmNvbnN0IGFzX3NoYTI1Nl8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvYXMtc2hhMjU2XCIpO1xuY29uc3QgemVyb3NfMSA9IHJlcXVpcmUoXCIuL3plcm9zXCIpO1xuZnVuY3Rpb24gaGFzaDY0KGJ5dGVzMzJBLCBieXRlczMyQikge1xuICAgIHJldHVybiBhc19zaGEyNTZfMS5kaWdlc3QyQnl0ZXMzMihieXRlczMyQSwgYnl0ZXMzMkIpO1xufVxuZXhwb3J0cy5oYXNoNjQgPSBoYXNoNjQ7XG5mdW5jdGlvbiBtZXJrbGVpemUoY2h1bmtzLCBwYWRGb3IpIHtcbiAgICBjb25zdCBsYXllckNvdW50ID0gYml0TGVuZ3RoKG5leHRQb3dlck9mMihwYWRGb3IpIC0gMSk7XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gemVyb3NfMS56ZXJvSGFzaChsYXllckNvdW50KTtcbiAgICB9XG4gICAgbGV0IGNodW5rQ291bnQgPSBjaHVua3MubGVuZ3RoO1xuICAgIC8vIEluc3RlYWQgb2YgcHVzaGluZyBvbiBhbGwgcGFkZGluZyB6ZXJvIGNodW5rcyBhdCB0aGUgbGVhZiBsZXZlbFxuICAgIC8vIHdlIHB1c2ggb24gemVybyBoYXNoIGNodW5rcyBhdCB0aGUgaGlnaGVzdCBwb3NzaWJsZSBsZXZlbCB0byBhdm9pZCBvdmVyLWhhc2hpbmdcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGxheWVyQ291bnQ7IGwrKykge1xuICAgICAgICBjb25zdCBwYWRDb3VudCA9IGNodW5rQ291bnQgJSAyO1xuICAgICAgICBjb25zdCBwYWRkZWRDaHVua0NvdW50ID0gY2h1bmtDb3VudCArIHBhZENvdW50O1xuICAgICAgICAvLyBpZiB0aGUgY2h1bmtzLmxlbmd0aCBpcyBvZGRcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwdXNoIG9uIHRoZSB6ZXJvLWhhc2ggb2YgdGhhdCBsZXZlbCB0byBtZXJrbGVpemUgdGhhdCBsZXZlbFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNodW5rc1tjaHVua0NvdW50ICsgaV0gPSB6ZXJvc18xLnplcm9IYXNoKGwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQ2h1bmtDb3VudDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjaHVua3NbaSAvIDJdID0gaGFzaDY0KGNodW5rc1tpXSwgY2h1bmtzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtDb3VudCA9IHBhZGRlZENodW5rQ291bnQgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzWzBdO1xufVxuZXhwb3J0cy5tZXJrbGVpemUgPSBtZXJrbGVpemU7XG4vKipcbiAqIFNwbGl0IGEgbG9uZyBVaW50OEFycmF5IGludG8gVWludDhBcnJheSBvZiBleGFjdGx5IDMyIGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0SW50b1Jvb3RDaHVua3MobG9uZ0NodW5rKSB7XG4gICAgY29uc3QgY2h1bmtDb3VudCA9IE1hdGguY2VpbChsb25nQ2h1bmsubGVuZ3RoIC8gMzIpO1xuICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgY2h1bmsuc2V0KGxvbmdDaHVuay5zbGljZShpICogMzIsIChpICsgMSkgKiAzMikpO1xuICAgICAgICBjaHVua3NbaV0gPSBjaHVuaztcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcztcbn1cbmV4cG9ydHMuc3BsaXRJbnRvUm9vdENodW5rcyA9IHNwbGl0SW50b1Jvb3RDaHVua3M7XG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gbWl4SW5MZW5ndGgocm9vdCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgbGVuZ3RoQnVmID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICBsZW5ndGhCdWYud3JpdGVVSW50TEUobGVuZ3RoLCAwLCA2KTtcbiAgICByZXR1cm4gaGFzaDY0KHJvb3QsIGxlbmd0aEJ1Zik7XG59XG5leHBvcnRzLm1peEluTGVuZ3RoID0gbWl4SW5MZW5ndGg7XG4vLyB4MiBmYXN0ZXIgdGhhbiBiaXRMZW5ndGhTdHIoKSB3aGljaCB1c2VzIE51bWJlci50b1N0cmluZygyKVxuZnVuY3Rpb24gYml0TGVuZ3RoKGkpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKGkpKSArIDE7XG59XG5leHBvcnRzLmJpdExlbmd0aCA9IGJpdExlbmd0aDtcbi8qKlxuICogR2l2ZW4gbWF4Q2h1bmtDb3VudCByZXR1cm4gdGhlIGNodW5rRGVwdGhcbiAqIGBgYFxuICogbjogWzAsMSwyLDMsNCw1LDYsNyw4LDldXG4gKiBkOiBbMCwwLDEsMiwyLDMsMywzLDMsNF1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBtYXhDaHVua3NUb0RlcHRoKG4pIHtcbiAgICBpZiAobiA9PT0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZzIobikpO1xufVxuZXhwb3J0cy5tYXhDaHVua3NUb0RlcHRoID0gbWF4Q2h1bmtzVG9EZXB0aDtcbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBuZXh0UG93ZXJPZjIobikge1xuICAgIHJldHVybiBuIDw9IDAgPyAxIDogTWF0aC5wb3coMiwgYml0TGVuZ3RoKG4gLSAxKSk7XG59XG5leHBvcnRzLm5leHRQb3dlck9mMiA9IG5leHRQb3dlck9mMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmtsZWl6ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmFtZWRDbGFzcyA9IHZvaWQgMDtcbmZ1bmN0aW9uIG5hbWVkQ2xhc3Moc3VwZXJDbGFzcywgY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInN1cGVyQ2xhc3NcIiwgYHJldHVybiBjbGFzcyAke2NsYXNzTmFtZX0gZXh0ZW5kcyBzdXBlckNsYXNzIHt9YCkoc3VwZXJDbGFzcyk7XG59XG5leHBvcnRzLm5hbWVkQ2xhc3MgPSBuYW1lZENsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyZWVQb3N0UHJvY2Vzc0Zyb21Qcm9vZk5vZGUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuLyoqIER1cGxpY2F0ZWQgcGFydGlhbCBkZWNsYXJhdGlvbiB0byBicmVhayBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggQ29tcG9zaXRlVHlwZSAqL1xuZnVuY3Rpb24gaXNDb21wb3NpdGVUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gIXR5cGUuaXNCYXNpYztcbn1cbi8qKlxuICogTmF2aWdhdGVzIGFuZCBtdXRhdGVzIG5vZGVzIHRvIHBvc3QgcHJvY2VzcyBhIHRyZWUgY3JlYXRlZCB3aXRoIGBUcmVlLmNyZWF0ZUZyb21Qcm9vZmAuXG4gKiBUcmVlIHJldHVybnMgcmVndWxhciBhIHRyZWUgd2l0aCBvbmx5IEJyYW5jaE5vZGUgYW5kIExlYWZOb2RlIGluc3RhbmNlcy4gSG93ZXZlciwgU1NaIGZlYXR1cmVzXG4gKiBub24tc3RhbmRhcmQgbm9kZXMgdGhhdCBtYWtlIHByb29mcyBmb3IgdGhvc2UgdHlwZXMgdG8gYmUgdW4tdXNhYmxlLiBUaGlzIGluY2x1ZGU6XG4gKiAtIEJyYW5jaE5vZGVTdHJ1Y3Q6IE11c3QgY29udGFpbiBjb21wbGV0ZSBkYXRhIGB0cmVlX2Zyb21Qcm9vZk5vZGVgIHRyYW5zZm9ybXMgYSBCcmFuY2hOb2RlIGFuZFxuICogICBhbGwgb2YgaXRzIGRhdGEgaW50byBhIHNpbmdsZSBCcmFuY2hOb2RlU3RydWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBiaXRzdHJpbmcgQml0c3RyaW5nIHdpdGhvdXQgdGhlIGxlYWRpbmcgXCIxXCIsIHNpbmNlIGl0J3Mgb25seSB1c2VkIHRvIGNvbXB1dGUgaG9yaXpvbnRhbCBpbmRleGVzLlxuICovXG5mdW5jdGlvbiB0cmVlUG9zdFByb2Nlc3NGcm9tUHJvb2ZOb2RlKG5vZGUsIHR5cGUsIGJpdHN0cmluZyA9IFwiXCIsIGN1cnJlbnREZXB0aCA9IDApIHtcbiAgICAvLyBNdXN0IHJ1biB0cmVlX2Zyb21Qcm9vZk5vZGUgb24gdGhlIGZpcnN0IHJlY2VpdmVkIG5vZGUgKGkuZS4gVmFsaWRhdG9yIG9iamVjdClcbiAgICBpZiAoY3VycmVudERlcHRoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5vZGVQb3N0ID0gdHlwZS50cmVlX2Zyb21Qcm9vZk5vZGUobm9kZSk7XG4gICAgICAgIGlmIChub2RlUG9zdC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVBvc3Qubm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlUG9zdC5ub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGF0VHlwZURlcHRoID0gdHlwZS5kZXB0aCA9PT0gY3VycmVudERlcHRoO1xuICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgIGlmIChhdFR5cGVEZXB0aCkge1xuICAgICAgICAgICAgY29uc3QganNvblBhdGhQcm9wID0gdHlwZS5nZXRJbmRleFByb3BlcnR5KGJpdHN0cmluZ1RvSW5kZXgoYml0c3RyaW5nKSk7XG4gICAgICAgICAgICBpZiAoanNvblBhdGhQcm9wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gYml0c3RyaW5nIGlzIG91dCBvZiBib3VuZHMsIHdpdG5lc3Mgbm9kZVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdHlwZS5nZXRQcm9wZXJ0eVR5cGUoanNvblBhdGhQcm9wKTtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgdHlwZSBtZXJrbGVpemVkIGZpdHMgaW4gYSBzaW5nbGUgY2h1bmsgdGhlbiB0aGlzIExlYWZOb2RlIGluY2x1ZGVzIGFsbCBkYXRhXG4gICAgICAgICAgICBpZiAoY2hpbGRUeXBlLm1heENodW5rQ291bnQgPT09IDEgJiYgaXNDb21wb3NpdGVUeXBlKGNoaWxkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRUeXBlLnRyZWVfZnJvbVByb29mTm9kZShub2RlKS5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2l0bmVzcyBub2RlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMZWFmTm9kZSBub3QgYXQgdHlwZSBkZXB0aCBpcyBhIHdpdG5lc3Mgb3IgYSBsZW5ndGggLyBzZWxlY3RvciBub2Rlc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoYXRUeXBlRGVwdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25QYXRoUHJvcCA9IHR5cGUuZ2V0SW5kZXhQcm9wZXJ0eShiaXRzdHJpbmdUb0luZGV4KGJpdHN0cmluZykpO1xuICAgICAgICAgICAgaWYgKGpzb25QYXRoUHJvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGJpdHN0cmluZyBpcyBvdXQgb2YgYm91bmRzLCB3aXRuZXNzIG5vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IHR5cGUuZ2V0UHJvcGVydHlUeXBlKGpzb25QYXRoUHJvcCk7XG4gICAgICAgICAgICBpZiAoIWlzQ29tcG9zaXRlVHlwZShjaGlsZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCcmFuY2hOb2RlIGRvZXMgbm90IG1hcCB0byBDb21wb3NpdGVUeXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZVBvc3QgPSBjaGlsZFR5cGUudHJlZV9mcm9tUHJvb2ZOb2RlKG5vZGUpO1xuICAgICAgICAgICAgLy8gSWYgdHJlZV9mcm9tUHJvb2ZOb2RlIGlzIHRoZSBpZGVudGl0eSBmdW5jdGlvbiwga2VlcCBnb2luZywgb3RoZXJ3aXNlIHN0b3AgbmF2aWdhdGluZ1xuICAgICAgICAgICAgaWYgKG5vZGVQb3N0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVBvc3Qubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmVlUG9zdFByb2Nlc3NGcm9tUHJvb2ZOb2RlKG5vZGVQb3N0Lm5vZGUsIGNoaWxkVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnJhbmNoTm9kZSBhdCBub3QgdHlwZSBkZXB0aCwga2VlcCBuYXZpZ2F0aW5nXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVmdE5vZGUgPSB0cmVlUG9zdFByb2Nlc3NGcm9tUHJvb2ZOb2RlKG5vZGUubGVmdCwgdHlwZSwgYml0c3RyaW5nICsgXCIwXCIsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHROb2RlID0gdHJlZVBvc3RQcm9jZXNzRnJvbVByb29mTm9kZShub2RlLnJpZ2h0LCB0eXBlLCBiaXRzdHJpbmcgKyBcIjFcIiwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgICAgICBpZiAobGVmdE5vZGUgPT09IG5vZGUubGVmdCAmJiByaWdodE5vZGUgPT09IG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLkJyYW5jaE5vZGUobGVmdE5vZGUsIHJpZ2h0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnRyZWVQb3N0UHJvY2Vzc0Zyb21Qcm9vZk5vZGUgPSB0cmVlUG9zdFByb2Nlc3NGcm9tUHJvb2ZOb2RlO1xuLyoqIFJldHVybiB0aGUgbm9kZSBob3Jpem9udGFsIGluZGV4IGdpdmVuIGEgYml0c3RyaW5nIHdpdGhvdXQgdGhlIGxlYWRpbmcgXCIxXCIgKi9cbmZ1bmN0aW9uIGJpdHN0cmluZ1RvSW5kZXgoYml0c3RyaW5nKSB7XG4gICAgaWYgKGJpdHN0cmluZyA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHBhcnNlSW50KGJpdHN0cmluZywgMik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlUG9zdFByb2Nlc3NGcm9tUHJvb2ZOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy56ZXJvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGFzX3NoYTI1Nl8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvYXMtc2hhMjU2XCIpO1xuLy8gY3JlYXRlIGFycmF5IG9mIFwiemVybyBoYXNoZXNcIiwgc3VjY2Vzc2l2ZWx5IGhhc2hlZCB6ZXJvIGNodW5rc1xuY29uc3QgemVyb0hhc2hlcyA9IFtuZXcgVWludDhBcnJheSgzMildO1xuZnVuY3Rpb24gemVyb0hhc2goZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPj0gemVyb0hhc2hlcy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHplcm9IYXNoZXMubGVuZ3RoOyBpIDw9IGRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIHplcm9IYXNoZXNbaV0gPSBhc19zaGEyNTZfMS5kaWdlc3QyQnl0ZXMzMih6ZXJvSGFzaGVzW2kgLSAxXSwgemVyb0hhc2hlc1tpIC0gMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB6ZXJvSGFzaGVzW2RlcHRoXTtcbn1cbmV4cG9ydHMuemVyb0hhc2ggPSB6ZXJvSGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXplcm9zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVaW50OEJ5dGVUb0JpdEJvb2xlYW5BcnJheSA9IGV4cG9ydHMuQml0QXJyYXkgPSB2b2lkIDA7XG4vKiogR2xvYmFsbHkgY2FjaGUgdGhpcyBpbmZvcm1hdGlvbi4gQHNlZSBnZXRVaW50OEJ5dGVUb0JpdEJvb2xlYW5BcnJheSAqL1xuY29uc3QgdWludDhCeXRlVG9CaXRCb29sZWFuQXJyYXlzID0gbmV3IEFycmF5KDI1Nik7XG4vKipcbiAqIEJpdEFycmF5IG1heSBiZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBiaXRzIG9yIGNvbXByZXNzZWQgaW50byBhbiBhcnJheSBvZiBieXRlcy5cbiAqXG4gKiAqKkFycmF5IG9mIGJpdHMqKjpcbiAqIFJlcXVpcmUgOC44NyBieXRlcyBwZXIgYml0LCBzbyBmb3IgNTEyIGJpdHMgPSA0NTAwIGJ5dGVzLlxuICogQXJlICdmYXN0ZXInIHRvIGl0ZXJhdGUgd2l0aCBuYXRpdmUgdG9vbGluZyBidXQgYXJlIGFzIGZhc3QgYXMgYXJyYXkgb2YgYnl0ZXMgd2l0aCBwcmVjb21wdXRlZCBjYWNoZXMuXG4gKlxuICogKipBcnJheSBvZiBieXRlcyoqOlxuICogUmVxdWlyZSBhbiBhdmVyYWdlIGNvc3Qgb2YgVWludDhBcnJheSBpbiBKUyA9IDIyMCBieXRlcyBmb3IgMzIgYnl0ZXMsIHNvIGZvciA1MTIgYml0cyA9IDIyMCBieXRlcy5cbiAqIFdpdGggcHJlY29tcHV0ZWQgYm9vbGVhbiBhcnJheXMgcGVyIGJ5dGVzIHZhbHVlIGFyZSBhcyBmYXN0IHRvIGl0ZXJhdGUgYXMgYW4gYXJyYXkgb2YgYml0cyBhYm92ZS5cbiAqXG4gKiBUaGlzIEJpdEFycmF5IGltcGxlbWVudGF0aW9uIHdpbGwgcmVwcmVzZW50IGRhdGEgYXMgYSBVaW50OEFycmF5IHNpbmNlIGl0J3MgdmVyeSBjaGVhcCB0byBkZXNlcmlhbGl6ZSBhbmQgY2FuIGJlIGFzXG4gKiBmYXN0IHRvIGl0ZXJhdGUgYXMgYSBuYXRpdmUgYXJyYXkgb2YgYm9vbGVhbnMsIHByZWNvbXB1dGluZyBib29sZWFuIGFycmF5cyAodG90YWwgbWVtb3J5IGNvc3Qgb2YgMTYwMDAgYnl0ZXMpLlxuICovXG5jbGFzcyBCaXRBcnJheSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFVuZGVybHlpbmcgQml0QXJyYXkgVWludDhBcnJheSBkYXRhICovXG4gICAgdWludDhBcnJheSwgXG4gICAgLyoqIEltbXV0YWJsZSBiaXRMZW4gb2YgdGhpcyBCaXRBcnJheSAqL1xuICAgIGJpdExlbikge1xuICAgICAgICB0aGlzLnVpbnQ4QXJyYXkgPSB1aW50OEFycmF5O1xuICAgICAgICB0aGlzLmJpdExlbiA9IGJpdExlbjtcbiAgICAgICAgaWYgKHVpbnQ4QXJyYXkubGVuZ3RoICE9PSBNYXRoLmNlaWwoYml0TGVuIC8gOCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQml0QXJyYXkgdWludDhBcnJheSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYml0TGVuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgemVybydlZCBCaXRBcnJheSBvZiBgYml0TGVuYCAqL1xuICAgIHN0YXRpYyBmcm9tQml0TGVuKGJpdExlbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpdEFycmF5KG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChiaXRMZW4gLyA4KSksIGJpdExlbik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgQml0QXJyYXkgb2YgYGJpdExlbmAgd2l0aCBhIHNpbmdsZSBiaXQgc2V0IHRvIHRydWUgYXQgcG9zaXRpb24gYGJpdEluZGV4YCAqL1xuICAgIHN0YXRpYyBmcm9tU2luZ2xlQml0KGJpdExlbiwgYml0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgYml0QXJyYXkgPSBCaXRBcnJheS5mcm9tQml0TGVuKGJpdExlbik7XG4gICAgICAgIGJpdEFycmF5LnNldChiaXRJbmRleCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBiaXRBcnJheTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBCaXRBcnJheSBmcm9tIGFuIGFycmF5IG9mIGJvb2xlYW5zIHJlcHJlc2VudGF0aW9uICovXG4gICAgc3RhdGljIGZyb21Cb29sQXJyYXkoYml0Qm9vbEFycikge1xuICAgICAgICBjb25zdCBiaXRBcnJheSA9IEJpdEFycmF5LmZyb21CaXRMZW4oYml0Qm9vbEFyci5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdEJvb2xBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChiaXRCb29sQXJyW2ldID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYml0QXJyYXkuc2V0KGksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaXRBcnJheTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIC8vIFRPRE86IEJlbmNobWFyayBpZiBVaW50OEFycmF5LnNsaWNlKDApIGlzIHRoZSBmYXN0ZXN0IHdheSB0byBjb3B5IGRhdGEgaGVyZVxuICAgICAgICAvLyBCdWZmZXIucHJvdG90eXBlLnNsaWNlIGRvZXMgbm90IGNvcHkgbWVtb3J5LCBFbmZvcmNlIFVpbnQ4QXJyYXkgdXNhZ2UgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yODA4N1xuICAgICAgICByZXR1cm4gbmV3IEJpdEFycmF5KFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy51aW50OEFycmF5LCAwKSwgdGhpcy5iaXRMZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYml0IHZhbHVlIGF0IGluZGV4IGBiaXRJbmRleGBcbiAgICAgKi9cbiAgICBnZXQoYml0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZUlkeCA9IE1hdGguZmxvb3IoYml0SW5kZXggLyA4KTtcbiAgICAgICAgY29uc3QgYml0SW5CaXQgPSBiaXRJbmRleCAlIDg7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAxIDw8IGJpdEluQml0O1xuICAgICAgICByZXR1cm4gKHRoaXMudWludDhBcnJheVtieXRlSWR4XSAmIG1hc2spID09PSBtYXNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYml0IHZhbHVlIGF0IGluZGV4IGBiaXRJbmRleGBcbiAgICAgKi9cbiAgICBzZXQoYml0SW5kZXgsIGJpdCkge1xuICAgICAgICBpZiAoYml0SW5kZXggPj0gdGhpcy5iaXRMZW4pIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBCaXRBcnJheSBzZXQgYml0SW5kZXggJHtiaXRJbmRleH0gYmV5b25kIGJpdExlbiAke3RoaXMuYml0TGVufWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVJZHggPSBNYXRoLmZsb29yKGJpdEluZGV4IC8gOCk7XG4gICAgICAgIGNvbnN0IGJpdEluQml0ID0gYml0SW5kZXggJSA4O1xuICAgICAgICBjb25zdCBtYXNrID0gMSA8PCBiaXRJbkJpdDtcbiAgICAgICAgbGV0IGJ5dGUgPSB0aGlzLnVpbnQ4QXJyYXlbYnl0ZUlkeF07XG4gICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgIC8vIEZvciBiaXQgaW4gYnl0ZSwgMSwwIE9SIDEgPSAxXG4gICAgICAgICAgICAvLyBieXRlIDEwMDExMFxuICAgICAgICAgICAgLy8gbWFzayAwMTAwMDBcbiAgICAgICAgICAgIC8vIHJlcyAgMTEwMTEwXG4gICAgICAgICAgICBieXRlIHw9IG1hc2s7XG4gICAgICAgICAgICB0aGlzLnVpbnQ4QXJyYXlbYnl0ZUlkeF0gPSBieXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIGJpdCBpbiBieXRlLCAxLDAgT1IgMSA9IDBcbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIG1hc2spID09PSBtYXNrKSB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZSAxMTAxMTBcbiAgICAgICAgICAgICAgICAvLyBtYXNrIDAxMDAwMFxuICAgICAgICAgICAgICAgIC8vIHJlcyAgMTAwMTEwXG4gICAgICAgICAgICAgICAgYnl0ZSBePSBtYXNrO1xuICAgICAgICAgICAgICAgIHRoaXMudWludDhBcnJheVtieXRlSWR4XSA9IGJ5dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPaywgYml0IGlzIGFscmVhZHkgMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBNZXJnZSB0d28gQml0QXJyYXkgYml0ZmllbGRzIHdpdGggT1IuIE11c3QgaGF2ZSB0aGUgc2FtZSBiaXRMZW4gKi9cbiAgICBtZXJnZU9yV2l0aChiaXRBcnJheTIpIHtcbiAgICAgICAgaWYgKGJpdEFycmF5Mi5iaXRMZW4gIT09IHRoaXMuYml0TGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11c3QgbWVyZ2UgQml0QXJyYXlzIG9mIHNhbWUgYml0TGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIGJpdEZpZWxkc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudWludDhBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy51aW50OEFycmF5W2ldID0gdGhpcy51aW50OEFycmF5W2ldIHwgYml0QXJyYXkyLnVpbnQ4QXJyYXlbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBpbmRleGVzIHdoaWNoIGhhdmUgYSBiaXQgc2V0IHRvIHRydWVcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RWYWx1ZXModmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHllcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gdGhpcy5iaXRMZW4pIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNdXN0IG5vdCBpbnRlcnNlY3QgdmFsdWVzIG9mIGxlbmd0aCAke3ZhbHVlcy5sZW5ndGh9ICE9IGJpdExlbiAke3RoaXMuYml0TGVufWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxCeXRlTGVuID0gTWF0aC5mbG9vcih0aGlzLmJpdExlbiAvIDgpO1xuICAgICAgICBjb25zdCByZW1haW5kZXJCaXRzID0gdGhpcy5iaXRMZW4gJSA4O1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBieXRlIG9mIGJpdHNcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnVpbnQ4QXJyYXk7XG4gICAgICAgIGZvciAobGV0IGlCeXRlID0gMDsgaUJ5dGUgPCBmdWxsQnl0ZUxlbjsgaUJ5dGUrKykge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBwcmVjb21wdXRlZCBib29sZWFuIGFycmF5IGZvciB0aGlzIGJ5dGVcbiAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5zSW5CeXRlID0gZ2V0VWludDhCeXRlVG9CaXRCb29sZWFuQXJyYXkoYnl0ZXNbaUJ5dGVdKTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGJpdCBpbiB0aGUgYnl0ZSBjaGVjayBwYXJ0aWNpcGF0aW9uIGFuZCBhZGQgdG8gaW5kZXhlc1NlbGVjdGVkIGFycmF5XG4gICAgICAgICAgICBmb3IgKGxldCBpQml0ID0gMDsgaUJpdCA8IDg7IGlCaXQrKykge1xuICAgICAgICAgICAgICAgIGlmIChib29sZWFuc0luQnl0ZVtpQml0XSkge1xuICAgICAgICAgICAgICAgICAgICB5ZXMucHVzaCh2YWx1ZXNbaUJ5dGUgKiA4ICsgaUJpdF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtYWluZGVyQml0cyA+IDApIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcHJlY29tcHV0ZWQgYm9vbGVhbiBhcnJheSBmb3IgdGhpcyBieXRlXG4gICAgICAgICAgICBjb25zdCBib29sZWFuc0luQnl0ZSA9IGdldFVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5KGJ5dGVzW2Z1bGxCeXRlTGVuXSk7XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBiaXQgaW4gdGhlIGJ5dGUgY2hlY2sgcGFydGljaXBhdGlvbiBhbmQgYWRkIHRvIGluZGV4ZXNTZWxlY3RlZCBhcnJheVxuICAgICAgICAgICAgZm9yIChsZXQgaUJpdCA9IDA7IGlCaXQgPCByZW1haW5kZXJCaXRzOyBpQml0KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYm9vbGVhbnNJbkJ5dGVbaUJpdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgeWVzLnB1c2godmFsdWVzW2Z1bGxCeXRlTGVuICogOCArIGlCaXRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb25zIG9mIGFsbCBiaXRzIHRoYXQgYXJlIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgZ2V0VHJ1ZUJpdEluZGV4ZXMoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBbXTtcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYnl0ZSBvZiBiaXRzXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy51aW50OEFycmF5O1xuICAgICAgICBmb3IgKGxldCBpQnl0ZSA9IDAsIGJ5dGVMZW4gPSBieXRlcy5sZW5ndGg7IGlCeXRlIDwgYnl0ZUxlbjsgaUJ5dGUrKykge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBwcmVjb21wdXRlZCBib29sZWFuIGFycmF5IGZvciB0aGlzIGJ5dGVcbiAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5zSW5CeXRlID0gZ2V0VWludDhCeXRlVG9CaXRCb29sZWFuQXJyYXkoYnl0ZXNbaUJ5dGVdKTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGJpdCBpbiB0aGUgYnl0ZSBjaGVjayBwYXJ0aWNpcGF0aW9uIGFuZCBhZGQgdG8gaW5kZXhlc1NlbGVjdGVkIGFycmF5XG4gICAgICAgICAgICBmb3IgKGxldCBpQml0ID0gMDsgaUJpdCA8IDg7IGlCaXQrKykge1xuICAgICAgICAgICAgICAgIGlmIChib29sZWFuc0luQnl0ZVtpQml0XSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaUJ5dGUgKiA4ICsgaUJpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIGEgc2luZ2xlIGJpdCBzZXQuIElmIG5vIGJpdCBzZXQgb3IgbW9yZSB0aGFuIDEgYml0IHNldCwgdGhyb3dzLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogIC0gbnVtYmVyOiBpZiB0aGVyZSdzIGEgc2luZ2xlIGJpdCBzZXQsIHRoZSBudW1iZXIgaXQgdGhlIHNpbmdsZSBiaXQgc2V0IHBvc2l0aW9uXG4gICAgICogIC0gbnVsbDogaWYgRVJST1JfTU9SRV9USEFOX09ORV9CSVRfU0VUIG9yIEVSUk9SX05PX0JJVF9TRVRcbiAgICAgKiBAdGhyb3dzXG4gICAgICogIC0gRVJST1JfTU9SRV9USEFOX09ORV9CSVRfU0VUXG4gICAgICogIC0gRVJST1JfTk9fQklUX1NFVFxuICAgICAqL1xuICAgIGdldFNpbmdsZVRydWVCaXQoKSB7XG4gICAgICAgIGxldCBpbmRleCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy51aW50OEFycmF5O1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBieXRlIG9mIGJpdHNcbiAgICAgICAgZm9yIChsZXQgaUJ5dGUgPSAwLCBieXRlTGVuID0gYnl0ZXMubGVuZ3RoOyBpQnl0ZSA8IGJ5dGVMZW47IGlCeXRlKyspIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgZXhhY3RseSB6ZXJvLCB0aGVyZSB3b24ndCBiZSBhbnkgaW5kZXhlcywgY29udGludWUgZWFybHlcbiAgICAgICAgICAgIGlmIChieXRlc1tpQnl0ZV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcHJlY29tcHV0ZWQgYm9vbGVhbiBhcnJheSBmb3IgdGhpcyBieXRlXG4gICAgICAgICAgICBjb25zdCBib29sZWFuc0luQnl0ZSA9IGdldFVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5KGJ5dGVzW2lCeXRlXSk7XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBiaXQgaW4gdGhlIGJ5dGUgY2hlY2sgcGFydGljaXBhdGlvbiBhbmQgYWRkIHRvIGluZGV4ZXNTZWxlY3RlZCBhcnJheVxuICAgICAgICAgICAgZm9yIChsZXQgaUJpdCA9IDA7IGlCaXQgPCA4OyBpQml0KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYm9vbGVhbnNJbkJ5dGVbaUJpdF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFUlJPUl9NT1JFX1RIQU5fT05FX0JJVF9TRVRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaUJ5dGUgKiA4ICsgaUJpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFUlJPUl9OT19CSVRfU0VUXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0Jvb2xBcnJheSgpIHtcbiAgICAgICAgY29uc3QgYml0Qm9vbEFyciA9IG5ldyBBcnJheSh0aGlzLmJpdExlbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iaXRMZW47IGkrKykge1xuICAgICAgICAgICAgYml0Qm9vbEFycltpXSA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaXRCb29sQXJyO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0QXJyYXkgPSBCaXRBcnJheTtcbi8qKlxuICogR2l2ZW4gYSBieXRlICgwIC0+IDI1NSksIHJldHVybiBhIEFycmF5IG9mIGJvb2xlYW4gd2l0aCBsZW5ndGggPSA4LCBiaWcgZW5kaWFuLlxuICogRXg6IDEgPT4gW3RydWUgZmFsc2UgZmFsc2UgZmFsc2UgZmFsc2UgZmFsc2UgZmFsc2UgZmFsc2VdXG4gKiAgICAgNSA9PiBbdHJ1ZSBmYWxzZSB0cnVlIGZhbHNlIGZhbHNlIGZhc2UgZmFsc2UgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIGdldFVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5KGJ5dGUpIHtcbiAgICBpZiAoIXVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5c1tieXRlXSkge1xuICAgICAgICB1aW50OEJ5dGVUb0JpdEJvb2xlYW5BcnJheXNbYnl0ZV0gPSBjb21wdXRlVWludDhCeXRlVG9CaXRCb29sZWFuQXJyYXkoYnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiB1aW50OEJ5dGVUb0JpdEJvb2xlYW5BcnJheXNbYnl0ZV07XG59XG5leHBvcnRzLmdldFVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5ID0gZ2V0VWludDhCeXRlVG9CaXRCb29sZWFuQXJyYXk7XG4vKiogQHNlZSBnZXRVaW50OEJ5dGVUb0JpdEJvb2xlYW5BcnJheSAqL1xuZnVuY3Rpb24gY29tcHV0ZVVpbnQ4Qnl0ZVRvQml0Qm9vbGVhbkFycmF5KGJ5dGUpIHtcbiAgICAvLyB0aGlzIHJldHVybnMgbGl0dGxlIGVuZGlhblxuICAgIGNvbnN0IGJpbmFyeVN0ciA9IGJ5dGUudG9TdHJpbmcoMik7XG4gICAgY29uc3QgYmluYXJ5TGVuZ3RoID0gYmluYXJ5U3RyLmxlbmd0aDtcbiAgICBjb25zdCBiaXRzID0gbmV3IEFycmF5KDgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGJpdHNbaV0gPVxuICAgICAgICAgICAgaSA8IGJpbmFyeUxlbmd0aFxuICAgICAgICAgICAgICAgID8gLy9cbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5U3RyW2JpbmFyeUxlbmd0aCAtIGkgLSAxXSA9PT0gXCIxXCJcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYml0cztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdEFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmVlVmlld0RVID0gdm9pZCAwO1xuY29uc3QgYWJzdHJhY3RfMSA9IHJlcXVpcmUoXCIuLi92aWV3L2Fic3RyYWN0XCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZyAgKi9cbi8qKlxuICogQSBEZWZlcnJlZCBVcGRhdGUgVHJlZSBWaWV3IChgVmlld0RVYCkgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIHR5cGUgYW5kXG4gKiBhIFNTWiBOb2RlIHRoYXQgY29udGFpbnM6XG4gKiAtIGRhdGEgbWVya2xlaXplZFxuICogLSBzb21lIGFyYml0cmFyeSBjYWNoZXMgdG8gc3BlZWQgdXAgZGF0YSBtYW5pcHVsYXRpb24gcmVxdWlyZWQgYnkgdGhlIHR5cGVcbiAqXG4gKiAqKlZpZXdEVSoqXG4gKiAtIEJlc3QgZm9yIGNvbXBsZXggdXNhZ2Ugd2hlcmUgcGVyZm9ybWFuY2UgaXMgaW1wb3J0YW50XG4gKiAtIERlZmVycyBjaGFuZ2VzIHRvIHdoZW4gY29tbWl0IGlzIGNhbGxlZFxuICogLSBEb2VzIE5PVCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgVmlld0RVXG4gKiAtIEhhcyBjYWNoZXMgZm9yIGZhc3QgZ2V0IC8gc2V0IG9wc1xuICovXG5jbGFzcyBUcmVlVmlld0RVIGV4dGVuZHMgYWJzdHJhY3RfMS5UcmVlVmlldyB7XG4gICAgLyoqXG4gICAgICogTWVya2xlaXplIHZpZXcgYW5kIGNvbXB1dGUgaXRzIGhhc2hUcmVlUm9vdC5cbiAgICAgKiBDb21taXRzIGFueSBwZW5kaW5nIGNoYW5nZXMgYmVmb3JlIGNvbXB1dGluZyB0aGUgcm9vdC5cbiAgICAgKlxuICAgICAqIFNlZSBzcGVjIGZvciBkZWZpbml0aW9uIG9mIGhhc2hUcmVlUm9vdDpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vY29uc2Vuc3VzLXNwZWNzL2Jsb2IvZGV2L3Nzei9zaW1wbGUtc2VyaWFsaXplLm1kI21lcmtsZWl6YXRpb25cbiAgICAgKi9cbiAgICBoYXNoVHJlZVJvb3QoKSB7XG4gICAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgICAgIHJldHVybiBzdXBlci5oYXNoVHJlZVJvb3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHZpZXcgdG8gYmluYXJ5IGRhdGEuXG4gICAgICogQ29tbWl0cyBhbnkgcGVuZGluZyBjaGFuZ2VzIGJlZm9yZSBjb21wdXRpbmcgdGhlIHJvb3QuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICB0aGlzLmNvbW1pdCgpO1xuICAgICAgICByZXR1cm4gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBWaWV3RFUgaW5zdGFuY2UgcmVmZXJlbmNpbmcgdGhlIHNhbWUgaW50ZXJuYWwgYE5vZGVgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBpdCB3aWxsIHRyYW5zZmVyIHRoZSBjYWNoZSBvZiB0aGlzIFZpZXdEVSB0byB0aGUgbmV3IGNsb25lZCBpbnN0YW5jZS4gU2V0IGBkb250VHJhbnNmZXJDYWNoZWAgdG8gdHJ1ZVxuICAgICAqIHRvIE5PVCB0cmFuc2ZlciB0aGUgY2FjaGUgdG8gdGhlIGNsb25lZCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjbG9uZShkb250VHJhbnNmZXJDYWNoZSkge1xuICAgICAgICBpZiAoZG9udFRyYW5zZmVyQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuZ2V0Vmlld0RVKHRoaXMubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuZ2V0Vmlld0RVKHRoaXMubm9kZSwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UcmVlVmlld0RVID0gVHJlZVZpZXdEVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcnJheUJhc2ljVHJlZVZpZXdEVSA9IHZvaWQgMDtcbmNvbnN0IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWVcIik7XG5jb25zdCBhYnN0cmFjdF8xID0gcmVxdWlyZShcIi4vYWJzdHJhY3RcIik7XG5jbGFzcyBBcnJheUJhc2ljVHJlZVZpZXdEVSBleHRlbmRzIGFic3RyYWN0XzEuVHJlZVZpZXdEVSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgX3Jvb3ROb2RlLCBjYWNoZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IF9yb290Tm9kZTtcbiAgICAgICAgdGhpcy5ub2Rlc0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlydHlMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gY2FjaGUubm9kZXM7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBjYWNoZS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gY2FjaGUubm9kZXNQb3B1bGF0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSB0aGlzLnR5cGUudHJlZV9nZXRMZW5ndGgoX3Jvb3ROb2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNQb3B1bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LiBFcXVhbCB0byB1bi1jb21taXRlZCBsZW5ndGggb2YgdGhlIGFycmF5XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290Tm9kZTtcbiAgICB9XG4gICAgZ2V0IGNhY2hlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZXM6IHRoaXMubm9kZXMsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMuX2xlbmd0aCxcbiAgICAgICAgICAgIG5vZGVzUG9wdWxhdGVkOiB0aGlzLm5vZGVzUG9wdWxhdGVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBgaW5kZXhgLiBSZXR1cm5zIHRoZSBCYXNpYyBlbGVtZW50IHR5cGUgdmFsdWUgZGlyZWN0bHlcbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgLy8gRmlyc3Qgd2FsayB0aHJvdWdoIHRoZSB0cmVlIHRvIGdldCB0aGUgcm9vdCBub2RlIGZvciB0aGF0IGluZGV4XG4gICAgICAgIGNvbnN0IGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy50eXBlLml0ZW1zUGVyQ2h1bmspO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZXNbY2h1bmtJbmRleF07XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZUF0RGVwdGgodGhpcy5fcm9vdE5vZGUsIHRoaXMudHlwZS5kZXB0aCwgY2h1bmtJbmRleCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2NodW5rSW5kZXhdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmVsZW1lbnRUeXBlLnRyZWVfZ2V0RnJvbVBhY2tlZE5vZGUobm9kZSwgaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgQmFzaWMgZWxlbWVudCB0eXBlIGB2YWx1ZWAgYXQgYGluZGV4YFxuICAgICAqL1xuICAgIHNldChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIHNldHRpbmcgaW5kZXggb3ZlciBsZW5ndGggJHtpbmRleH0gPiAke3RoaXMuX2xlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVua0luZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMudHlwZS5pdGVtc1BlckNodW5rKTtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBub2RlIGlmIGN1cnJlbnQgbGVhZk5vZGUgaXMgbm90IGRpcnR5XG4gICAgICAgIGxldCBub2RlQ2hhbmdlZDtcbiAgICAgICAgaWYgKHRoaXMubm9kZXNDaGFuZ2VkLmhhcyhjaHVua0luZGV4KSkge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIHBvcHVsYXRlZFxuICAgICAgICAgICAgbm9kZUNoYW5nZWQgPSB0aGlzLm5vZGVzW2NodW5rSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVByZXYgPSAodGhpcy5ub2Rlc1tjaHVua0luZGV4XSA/P1xuICAgICAgICAgICAgICAgIHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2RlQXREZXB0aCh0aGlzLl9yb290Tm9kZSwgdGhpcy50eXBlLmRlcHRoLCBjaHVua0luZGV4KSk7XG4gICAgICAgICAgICBub2RlQ2hhbmdlZCA9IG5vZGVQcmV2LmNsb25lKCk7XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2hhbmdlZCBub2RlIGluIHRoZSBub2RlcyBjYWNoZVxuICAgICAgICAgICAgdGhpcy5ub2Rlc1tjaHVua0luZGV4XSA9IG5vZGVDaGFuZ2VkO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc0NoYW5nZWQuYWRkKGNodW5rSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZS5lbGVtZW50VHlwZS50cmVlX3NldFRvUGFja2VkTm9kZShub2RlQ2hhbmdlZCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB2YWx1ZXMgb2YgdGhpcyBhcnJheSBhcyBCYXNpYyBlbGVtZW50IHR5cGUgdmFsdWVzLCBmcm9tIGluZGV4IHplcm8gdG8gYHRoaXMubGVuZ3RoIC0gMWBcbiAgICAgKi9cbiAgICBnZXRBbGwoKSB7XG4gICAgICAgIGlmICghdGhpcy5ub2Rlc1BvcHVsYXRlZCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNQcmV2ID0gdGhpcy5ub2RlcztcbiAgICAgICAgICAgIGNvbnN0IGNodW5rc05vZGUgPSB0aGlzLnR5cGUudHJlZV9nZXRDaHVua3NOb2RlKHRoaXMubm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gTWF0aC5jZWlsKHRoaXMuX2xlbmd0aCAvIHRoaXMudHlwZS5pdGVtc1BlckNodW5rKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZXNBdERlcHRoKGNodW5rc05vZGUsIHRoaXMudHlwZS5jaHVua0RlcHRoLCAwLCBjaHVua0NvdW50KTtcbiAgICAgICAgICAgIC8vIFJlLWFwcGx5IGNoYW5nZWQgbm9kZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy5ub2Rlc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2luZGV4XSA9IG5vZGVzUHJldltpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5fbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaXRlbXNQZXJDaHVuayA9IHRoaXMudHlwZS5pdGVtc1BlckNodW5rOyAvLyBQcmV2ZW50IG1hbnkgYWNjZXNzIGluIGZvciBsb29wIGJlbG93XG4gICAgICAgIGNvbnN0IGxlbkZ1bGxOb2RlcyA9IE1hdGguZmxvb3IodGhpcy5fbGVuZ3RoIC8gaXRlbXNQZXJDaHVuayk7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IHRoaXMuX2xlbmd0aCAlIGl0ZW1zUGVyQ2h1bms7XG4gICAgICAgIC8vIFRPRE8gT3B0aW1pemU6IGNhY2hpbmcgdGhlIHZhcmlhYmxlcyB1c2VkIGluIHRoZSBsb29wIGFib3ZlIGl0XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbGVuRnVsbE5vZGVzOyBuKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZOb2RlID0gdGhpcy5ub2Rlc1tuXTtcbiAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBhZGQgYSBmYXN0IGJ1bGsgcGFja2VkIGVsZW1lbnQgcmVhZGVyIGluIHRoZSBlbGVtZW50VHlwZVxuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAvLyBhYnN0cmFjdCBnZXRWYWx1ZXNGcm9tUGFja2VkTm9kZShsZWFmTm9kZTogTGVhZk5vZGUsIG91dHB1dDogVltdLCBpbmRleE9mZnNldDogbnVtYmVyKTogdm9pZDtcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgLy8gaWYgcGVyZm9ybWFuY2UgaGVyZSBpcyBhIHByb2JsZW1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXNQZXJDaHVuazsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW24gKiBpdGVtc1BlckNodW5rICsgaV0gPSB0aGlzLnR5cGUuZWxlbWVudFR5cGUudHJlZV9nZXRGcm9tUGFja2VkTm9kZShsZWFmTm9kZSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbWFpbmRlciA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZOb2RlID0gdGhpcy5ub2Rlc1tsZW5GdWxsTm9kZXNdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1haW5kZXI7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tsZW5GdWxsTm9kZXMgKiBpdGVtc1BlckNodW5rICsgaV0gPSB0aGlzLnR5cGUuZWxlbWVudFR5cGUudHJlZV9nZXRGcm9tUGFja2VkTm9kZShsZWFmTm9kZSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc0NoYW5nZWQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE51bWVyaWNhbCBzb3J0IGFzY2VuZGluZ1xuICAgICAgICBjb25zdCBpbmRleGVzID0gQXJyYXkuZnJvbSh0aGlzLm5vZGVzQ2hhbmdlZC5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBuZXcgQXJyYXkoaW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGVzW2ldID0gdGhpcy5ub2Rlc1tpbmRleGVzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVua3NOb2RlID0gdGhpcy50eXBlLnRyZWVfZ2V0Q2h1bmtzTm9kZSh0aGlzLl9yb290Tm9kZSk7XG4gICAgICAgIC8vIFRPRE86IEVuc3VyZSBmYXN0IHNldE5vZGVzQXREZXB0aCgpIG1ldGhvZCBpcyBjb3JyZWN0XG4gICAgICAgIGNvbnN0IG5ld0NodW5rc05vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuc2V0Tm9kZXNBdERlcHRoKGNodW5rc05vZGUsIHRoaXMudHlwZS5jaHVua0RlcHRoLCBpbmRleGVzLCBub2Rlcyk7XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlID0gdGhpcy50eXBlLnRyZWVfc2V0Q2h1bmtzTm9kZSh0aGlzLl9yb290Tm9kZSwgbmV3Q2h1bmtzTm9kZSwgdGhpcy5kaXJ0eUxlbmd0aCA/IHRoaXMuX2xlbmd0aCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMubm9kZXNDaGFuZ2VkLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGlydHlMZW5ndGggPSBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIE11c3QgY2xlYXIgbm9kZXNDaGFuZ2VkLCBvdGhlcndpc2UgYSBzdWJzZXF1ZW50IGNvbW1pdCBjYWxsIHdpbGwgYnJlYWssIGJlY2F1c2UgaXQgYXNzdW1lcyBhIG5vZGUgaXMgdGhlcmVcbiAgICAgICAgdGhpcy5ub2Rlc0NoYW5nZWQuY2xlYXIoKTtcbiAgICAgICAgLy8gUmVzZXQgY2FjaGVkIGxlbmd0aCBvbmx5IGlmIGl0IGhhcyBiZWVuIG11dGF0ZWRcbiAgICAgICAgaWYgKHRoaXMuZGlydHlMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMudHlwZS50cmVlX2dldExlbmd0aCh0aGlzLl9yb290Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFycmF5QmFzaWNUcmVlVmlld0RVID0gQXJyYXlCYXNpY1RyZWVWaWV3RFU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheUJhc2ljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcnJheUNvbXBvc2l0ZVRyZWVWaWV3RFUgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgYWJzdHJhY3RfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0XCIpO1xuY2xhc3MgQXJyYXlDb21wb3NpdGVUcmVlVmlld0RVIGV4dGVuZHMgYWJzdHJhY3RfMS5UcmVlVmlld0RVIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBfcm9vdE5vZGUsIGNhY2hlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlID0gX3Jvb3ROb2RlO1xuICAgICAgICB0aGlzLnZpZXdzQ2hhbmdlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGFjY2Vzc2libGUgaW4gdGhlIGNhY2hlIG9iamVjdCBwZXJzaXN0ZWQgaW4gdGhlIHBhcmVudCdzIGNhY2hlLlxuICAgICAgICAvLyBub2RlcywgY2FjaGVzLCBfbGVuZ3RoLCBhbmQgbm9kZXNQb3B1bGF0ZWQgYXJlIG11dGF0ZWQuIENvbnNpZGVyIGhhdmluZyB0aGVtIGluIGEgX2NhY2hlIG9iamVjdCBzdWNoIHRoYXRcbiAgICAgICAgLy8gbXV0YXRpb25zIGFmZmVjdCB0aGUgY2FjaGUgYWxyZWFkeSBmb3VuZCBpbiB0aGUgcGFyZW50IG9iamVjdFxuICAgICAgICB0aGlzLmRpcnR5TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IGNhY2hlLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5jYWNoZXMgPSBjYWNoZS5jYWNoZXM7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBjYWNoZS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gY2FjaGUubm9kZXNQb3B1bGF0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmNhY2hlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy50eXBlLnRyZWVfZ2V0TGVuZ3RoKF9yb290Tm9kZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZXhhY3RseSAwIG5vZGVzLCBub2Rlc1BvcHVsYXRlZCA9IHRydWUgYmVjYXVzZSAwIC8gMCBhcmUgaW4gdGhlIG5vZGVzIGFycmF5XG4gICAgICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gdGhpcy5fbGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuIEVxdWFsIHRvIHVuLWNvbW1pdGVkIGxlbmd0aCBvZiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3ROb2RlO1xuICAgIH1cbiAgICBnZXQgY2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogdGhpcy5ub2RlcyxcbiAgICAgICAgICAgIGNhY2hlczogdGhpcy5jYWNoZXMsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMuX2xlbmd0aCxcbiAgICAgICAgICAgIG5vZGVzUG9wdWxhdGVkOiB0aGlzLm5vZGVzUG9wdWxhdGVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBgaW5kZXhgLiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgQ29tcG9zaXRlIGVsZW1lbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IEFzc3VtZXMgdGhhdCBhbnkgdmlldyBjcmVhdGVkIGhlcmUgd2lsbCBjaGFuZ2UgYW5kIHdpbGwgY2FsbCAuY29tbWl0KCkgb24gaXQuXG4gICAgICogLmdldCgpIHNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIGNhc2VzIHdoZW4gc29tZXRoaW5nIG1heSBtdXRhdGUuIFRvIGdldCBhbGwgaXRlbXMgd2l0aG91dFxuICAgICAqIHRyaWdnZXJpbmcgYSAuY29tbWl0KCkgaW4gYWxsIHRoZW0gdXNlIC5nZXRBbGxSZWFkT25seSgpLlxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICBjb25zdCB2aWV3Q2hhbmdlZCA9IHRoaXMudmlld3NDaGFuZ2VkLmdldChpbmRleCk7XG4gICAgICAgIGlmICh2aWV3Q2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdDaGFuZ2VkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2Rlc1tpbmRleF07XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZUF0RGVwdGgodGhpcy5fcm9vdE5vZGUsIHRoaXMudHlwZS5kZXB0aCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1tpbmRleF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG5ldyB2aWV3IHRvIGNhbGwgLmNvbW1pdCBvbiBpdCBsYXR0ZXIsIG9ubHkgaWYgbXV0YWJsZVxuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy50eXBlLmVsZW1lbnRUeXBlLmdldFZpZXdEVShub2RlLCB0aGlzLmNhY2hlc1tpbmRleF0pO1xuICAgICAgICBpZiAodGhpcy50eXBlLmVsZW1lbnRUeXBlLmlzVmlld011dGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld3NDaGFuZ2VkLnNldChpbmRleCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBwZXJzaXN0IHRoZSBjaGlsZCdzIHZpZXcgY2FjaGUgc2luY2UgYSBzZWNvbmQgZ2V0IHJldHVybnMgdGhpcyB2aWV3IGluc3RhbmNlLlxuICAgICAgICAvLyBUaGUgY2FjaGUgaXMgb25seSBwZXJzaXN0ZWQgb24gY29tbWl0IHdoZXJlIHRoZSB2aWV3c0NoYW5nZWQgbWFwIGlzIGRyb3BwZWQuXG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBgaW5kZXhgLiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgQ29tcG9zaXRlIGVsZW1lbnQgdHlwZS5cbiAgICAgKiBET0VTIE5PVCBQUk9QQUdBVEUgQ0hBTkdFUzogdXNlIG9ubHkgZm9yIHJlYWRzIGFuZCB0byBza2lwIHBhcmVudCByZWZlcmVuY2VzLlxuICAgICAqL1xuICAgIGdldFJlYWRvbmx5KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHZpZXdDaGFuZ2VkID0gdGhpcy52aWV3c0NoYW5nZWQuZ2V0KGluZGV4KTtcbiAgICAgICAgaWYgKHZpZXdDaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NoYW5nZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVzW2luZGV4XTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZSA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2RlQXREZXB0aCh0aGlzLl9yb290Tm9kZSwgdGhpcy50eXBlLmRlcHRoLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2luZGV4XSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5lbGVtZW50VHlwZS5nZXRWaWV3RFUobm9kZSwgdGhpcy5jYWNoZXNbaW5kZXhdKTtcbiAgICB9XG4gICAgLy8gRGlkIG5vdCBpbXBsZW1lbnRlZFxuICAgIC8vIGBnZXRSZWFkb25seVZhbHVlKGluZGV4OiBudW1iZXIpOiBWYWx1ZU9mPEVsZW1lbnRUeXBlPmBcbiAgICAvLyBiZWNhdXNlIGl0IGNhbiBicmVhayBpbiB1bmV4cGVjdGVkIHdheXMgaWYgdGhlcmUgYXJlIHBlbmRpbmcgY2hhbmdlcyBpbiB0aGlzLnZpZXdzQ2hhbmdlZC5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGNvdWxkIGZpcnN0IGNoZWNrIGlmIGB0aGlzLnZpZXdzQ2hhbmdlZGAgaGFzIGEgdmlldyBmb3IgYGluZGV4YCBhbmQgY29tbWl0IGl0LFxuICAgIC8vIGJ1dCB0aGF0IHdvdWxkIGJlIHByZXR0eSBzbG93LCBhbmQgdGhlIHNhbWUgcmVzdWx0IGNhbiBiZSBhY2hpZXZlZCB3aXRoXG4gICAgLy8gYHRoaXMuZ2V0UmVhZG9ubHkoaW5kZXgpLnRvVmFsdWUoKWBcbiAgICAvKipcbiAgICAgKiBTZXQgQ29tcG9zaXRlIGVsZW1lbnQgdHlwZSBgdmlld2AgYXQgYGluZGV4YFxuICAgICAqL1xuICAgIHNldChpbmRleCwgdmlldykge1xuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3Igc2V0dGluZyBpbmRleCBvdmVyIGxlbmd0aCAke2luZGV4fSA+ICR7dGhpcy5fbGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gc2V0dGluZyBhIHZpZXc6XG4gICAgICAgIC8vIC0gTm90IG5lY2Vzc2FyeSB0byBjb21taXQgbm9kZVxuICAgICAgICAvLyAtIE5vdCBuZWNlc3NhcnkgdG8gcGVyc2lzdCBjYWNoZVxuICAgICAgICAvLyBKdXN0IGtlZXBpbmcgYSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgaW4gdGhpcy52aWV3c0NoYW5nZWQgZW5zdXJlcyBjb25zaXN0ZW5jeVxuICAgICAgICB0aGlzLnZpZXdzQ2hhbmdlZC5zZXQoaW5kZXgsIHZpZXcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXQVJOSU5HOiBSZXR1cm5zIGFsbCBjb21taXRlZCBjaGFuZ2VzLCBpZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgY2hhbmdlcyBjb21taXQgdGhlbSBiZWZvcmVoYW5kXG4gICAgICovXG4gICAgZ2V0QWxsUmVhZG9ubHkoKSB7XG4gICAgICAgIHRoaXMucG9wdWxhdGVBbGxOb2RlcygpO1xuICAgICAgICBjb25zdCB2aWV3cyA9IG5ldyBBcnJheSh0aGlzLl9sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3c1tpXSA9IHRoaXMudHlwZS5lbGVtZW50VHlwZS5nZXRWaWV3RFUodGhpcy5ub2Rlc1tpXSwgdGhpcy5jYWNoZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV0FSTklORzogUmV0dXJucyBhbGwgY29tbWl0ZWQgY2hhbmdlcywgaWYgdGhlcmUgYXJlIGFueSBwZW5kaW5nIGNoYW5nZXMgY29tbWl0IHRoZW0gYmVmb3JlaGFuZFxuICAgICAqL1xuICAgIGdldEFsbFJlYWRvbmx5VmFsdWVzKCkge1xuICAgICAgICB0aGlzLnBvcHVsYXRlQWxsTm9kZXMoKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuX2xlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHRoaXMudHlwZS5lbGVtZW50VHlwZS50cmVlX3RvVmFsdWUodGhpcy5ub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy52aWV3c0NoYW5nZWQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVzQ2hhbmdlZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgdmlld10gb2YgdGhpcy52aWV3c0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnR5cGUuZWxlbWVudFR5cGUuY29tbWl0Vmlld0RVKHZpZXcpO1xuICAgICAgICAgICAgLy8gU2V0IG5ldyBub2RlIGluIG5vZGVzIGFycmF5IHRvIGVuc3VyZSBkYXRhIHJlcHJlc2VudGVkIGluIHRoZSB0cmVlIGFuZCBmYXN0IG5vZGVzIGFjY2VzcyBpcyBlcXVhbFxuICAgICAgICAgICAgdGhpcy5ub2Rlc1tpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgbm9kZXNDaGFuZ2VkLnB1c2goeyBpbmRleCwgbm9kZSB9KTtcbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSB2aWV3J3MgY2FjaGVzIHRvIHByZXNlcnZlIGl0J3MgZGF0YSBhZnRlciAndGhpcy52aWV3c0NoYW5nZWQuY2xlYXIoKSdcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy50eXBlLmVsZW1lbnRUeXBlLmNhY2hlT2ZWaWV3RFUodmlldyk7XG4gICAgICAgICAgICBpZiAoY2FjaGUpXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZXNbaW5kZXhdID0gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogT3B0aW1pemUgdG8gbG9vcCBvbmx5IG9uY2UsIE51bWVyaWNhbCBzb3J0IGFzY2VuZGluZ1xuICAgICAgICBjb25zdCBub2Rlc0NoYW5nZWRTb3J0ZWQgPSBub2Rlc0NoYW5nZWQuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gbm9kZXNDaGFuZ2VkU29ydGVkLm1hcCgoZW50cnkpID0+IGVudHJ5LmluZGV4KTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBub2Rlc0NoYW5nZWRTb3J0ZWQubWFwKChlbnRyeSkgPT4gZW50cnkubm9kZSk7XG4gICAgICAgIGNvbnN0IGNodW5rc05vZGUgPSB0aGlzLnR5cGUudHJlZV9nZXRDaHVua3NOb2RlKHRoaXMuX3Jvb3ROb2RlKTtcbiAgICAgICAgLy8gVE9ETzogRW5zdXJlIGZhc3Qgc2V0Tm9kZXNBdERlcHRoKCkgbWV0aG9kIGlzIGNvcnJlY3RcbiAgICAgICAgY29uc3QgbmV3Q2h1bmtzTm9kZSA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5zZXROb2Rlc0F0RGVwdGgoY2h1bmtzTm9kZSwgdGhpcy50eXBlLmNodW5rRGVwdGgsIGluZGV4ZXMsIG5vZGVzKTtcbiAgICAgICAgdGhpcy5fcm9vdE5vZGUgPSB0aGlzLnR5cGUudHJlZV9zZXRDaHVua3NOb2RlKHRoaXMuX3Jvb3ROb2RlLCBuZXdDaHVua3NOb2RlLCB0aGlzLmRpcnR5TGVuZ3RoID8gdGhpcy5fbGVuZ3RoIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy52aWV3c0NoYW5nZWQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5kaXJ0eUxlbmd0aCA9IGZhbHNlO1xuICAgIH1cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY2FjaGVzID0gW107XG4gICAgICAgIHRoaXMubm9kZXNQb3B1bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSXQncyBub3QgbmVjZXNzYXJ5IHRvIGNsZWFyIHRoaXMudmlld3NDaGFuZ2VkIHNpbmNlIHRoZXkgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIGNhY2hlLlxuICAgICAgICAvLyBIb3dldmVyIHByZXNlcnZpbmcgX1NPTUVfIGNhY2hlcyByZXN1bHRzIGluIGEgdmVyeSB1bnByZWRpY3RhYmxlIGV4cGVyaWVuY2UuXG4gICAgICAgIHRoaXMudmlld3NDaGFuZ2VkLmNsZWFyKCk7XG4gICAgICAgIC8vIFJlc2V0IGNhY2hlZCBsZW5ndGggb25seSBpZiBpdCBoYXMgYmVlbiBtdXRhdGVkXG4gICAgICAgIGlmICh0aGlzLmRpcnR5TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSB0aGlzLnR5cGUudHJlZV9nZXRMZW5ndGgodGhpcy5fcm9vdE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUxlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvcHVsYXRlQWxsTm9kZXMoKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgdW5jb21taXRlZCBjaGFuZ2VzIGl0IG1heSBicmVhay5cbiAgICAgICAgLy8gdGhpcy5sZW5ndGggY2FuIGJlIGluY3JlYXNlZCBidXQgdGhpcy5fcm9vdE5vZGUgZG9lc24ndCBoYXZlIHRoYXQgaXRlbVxuICAgICAgICBpZiAodGhpcy52aWV3c0NoYW5nZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTXVzdCBjb21taXQgY2hhbmdlcyBiZWZvcmUgcmVhZGluZyBhbGwgbm9kZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5vZGVzUG9wdWxhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmdldE5vZGVzQXREZXB0aCh0aGlzLl9yb290Tm9kZSwgdGhpcy50eXBlLmRlcHRoLCAwLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXJyYXlDb21wb3NpdGVUcmVlVmlld0RVID0gQXJyYXlDb21wb3NpdGVUcmVlVmlld0RVO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlDb21wb3NpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpdEFycmF5VHJlZVZpZXdEVSA9IHZvaWQgMDtcbmNvbnN0IGFic3RyYWN0XzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdFwiKTtcbi8qKlxuICogVGhpbiB3cmFwcGVyIGFyb3VuZCBCaXRBcnJheSB0byB1cHN0cmVhbSBjaGFuZ2VzIGFmdGVyIGB0aGlzLmNvbW1pdCgpYFxuICovXG5jbGFzcyBCaXRBcnJheVRyZWVWaWV3RFUgZXh0ZW5kcyBhYnN0cmFjdF8xLlRyZWVWaWV3RFUge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIF9yb290Tm9kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IF9yb290Tm9kZTtcbiAgICAgICAgLyoqIENhY2hlZCBCaXRBcnJheSBpbnN0YW5jZSBjb21wdXRlZCBvbmx5IG9uIGRlbWFuZCAqL1xuICAgICAgICB0aGlzLl9iaXRBcnJheSA9IG51bGw7XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdE5vZGU7XG4gICAgfVxuICAgIGdldCBjYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9iaXRBcnJheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGUgPSB0aGlzLnR5cGUudmFsdWVfdG9UcmVlKHRoaXMuX2JpdEFycmF5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXcmFwcGVkIEFQSSBmcm9tIEJpdEFycmF5XG4gICAgLyoqIEBzZWUgQml0QXJyYXkudWludDhBcnJheSAqL1xuICAgIGdldCB1aW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS51aW50OEFycmF5O1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5iaXRMZW4gKi9cbiAgICBnZXQgYml0TGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS5iaXRMZW47XG4gICAgfVxuICAgIC8qKiBAc2VlIEJpdEFycmF5LmdldCAqL1xuICAgIGdldChiaXRJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS5nZXQoYml0SW5kZXgpO1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5zZXQgKi9cbiAgICBzZXQoYml0SW5kZXgsIGJpdCkge1xuICAgICAgICB0aGlzLmJpdEFycmF5LnNldChiaXRJbmRleCwgYml0KTtcbiAgICB9XG4gICAgLyoqIEBzZWUgQml0QXJyYXkubWVyZ2VPcldpdGggKi9cbiAgICBtZXJnZU9yV2l0aChiaXRBcnJheTIpIHtcbiAgICAgICAgdGhpcy5iaXRBcnJheS5tZXJnZU9yV2l0aChiaXRBcnJheTIpO1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5pbnRlcnNlY3RWYWx1ZXMgKi9cbiAgICBpbnRlcnNlY3RWYWx1ZXModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdEFycmF5LmludGVyc2VjdFZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5nZXRUcnVlQml0SW5kZXhlcyAqL1xuICAgIGdldFRydWVCaXRJbmRleGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS5nZXRUcnVlQml0SW5kZXhlcygpO1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5nZXRTaW5nbGVUcnVlQml0ICovXG4gICAgZ2V0U2luZ2xlVHJ1ZUJpdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYml0QXJyYXkuZ2V0U2luZ2xlVHJ1ZUJpdCgpO1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS50b0Jvb2xBcnJheSAqL1xuICAgIHRvQm9vbEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS50b0Jvb2xBcnJheSgpO1xuICAgIH1cbiAgICAvKiogTGF6aWx5IGNvbXB1dGVkIGJpdEFycmF5IGluc3RhbmNlICovXG4gICAgZ2V0IGJpdEFycmF5KCkge1xuICAgICAgICBpZiAodGhpcy5fYml0QXJyYXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpdEFycmF5ID0gdGhpcy50eXBlLnRyZWVfdG9WYWx1ZSh0aGlzLl9yb290Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpdEFycmF5O1xuICAgIH1cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLl9iaXRBcnJheSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRBcnJheVRyZWVWaWV3RFUgPSBCaXRBcnJheVRyZWVWaWV3RFU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXRBcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q29udGFpbmVyVHJlZVZpZXdEVUNsYXNzID0gdm9pZCAwO1xuY29uc3QgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZVwiKTtcbmNvbnN0IGJhc2ljXzEgPSByZXF1aXJlKFwiLi4vdHlwZS9iYXNpY1wiKTtcbmNvbnN0IGNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4uL3R5cGUvY29tcG9zaXRlXCIpO1xuY29uc3QgYWJzdHJhY3RfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0XCIpO1xuY2xhc3MgQ29udGFpbmVyVHJlZVZpZXdEVSBleHRlbmRzIGFic3RyYWN0XzEuVHJlZVZpZXdEVSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgX3Jvb3ROb2RlLCBjYWNoZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IF9yb290Tm9kZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzQ2hhbmdlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy52aWV3c0NoYW5nZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IGNhY2hlLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5jYWNoZXMgPSBjYWNoZS5jYWNoZXM7XG4gICAgICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gY2FjaGUubm9kZXNQb3B1bGF0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmNhY2hlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1BvcHVsYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdE5vZGU7XG4gICAgfVxuICAgIGdldCBjYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiB0aGlzLm5vZGVzLFxuICAgICAgICAgICAgY2FjaGVzOiB0aGlzLmNhY2hlcyxcbiAgICAgICAgICAgIG5vZGVzUG9wdWxhdGVkOiB0aGlzLm5vZGVzUG9wdWxhdGVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzQ2hhbmdlZC5zaXplID09PSAwICYmIHRoaXMudmlld3NDaGFuZ2VkLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2Rlc0NoYW5nZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHZpZXddIG9mIHRoaXMudmlld3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSB0aGlzLnR5cGUuZmllbGRzRW50cmllc1tpbmRleF0uZmllbGRUeXBlO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGZpZWxkVHlwZS5jb21taXRWaWV3RFUodmlldyk7XG4gICAgICAgICAgICAvLyBTZXQgbmV3IG5vZGUgaW4gbm9kZXMgYXJyYXkgdG8gZW5zdXJlIGRhdGEgcmVwcmVzZW50ZWQgaW4gdGhlIHRyZWUgYW5kIGZhc3Qgbm9kZXMgYWNjZXNzIGlzIGVxdWFsXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2luZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBub2Rlc0NoYW5nZWQucHVzaCh7IGluZGV4LCBub2RlIH0pO1xuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHZpZXcncyBjYWNoZXMgdG8gcHJlc2VydmUgaXQncyBkYXRhIGFmdGVyICd0aGlzLnZpZXdzQ2hhbmdlZC5jbGVhcigpJ1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBmaWVsZFR5cGUuY2FjaGVPZlZpZXdEVSh2aWV3KTtcbiAgICAgICAgICAgIGlmIChjYWNoZSlcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlc1tpbmRleF0gPSBjYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRoaXMubm9kZXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBub2Rlc0NoYW5nZWQucHVzaCh7IGluZGV4LCBub2RlOiB0aGlzLm5vZGVzW2luZGV4XSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0byBsb29wIG9ubHkgb25jZSwgTnVtZXJpY2FsIHNvcnQgYXNjZW5kaW5nXG4gICAgICAgIGNvbnN0IG5vZGVzQ2hhbmdlZFNvcnRlZCA9IG5vZGVzQ2hhbmdlZC5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBub2Rlc0NoYW5nZWRTb3J0ZWQubWFwKChlbnRyeSkgPT4gZW50cnkuaW5kZXgpO1xuICAgICAgICBjb25zdCBub2RlcyA9IG5vZGVzQ2hhbmdlZFNvcnRlZC5tYXAoKGVudHJ5KSA9PiBlbnRyeS5ub2RlKTtcbiAgICAgICAgdGhpcy5fcm9vdE5vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuc2V0Tm9kZXNBdERlcHRoKHRoaXMuX3Jvb3ROb2RlLCB0aGlzLnR5cGUuZGVwdGgsIGluZGV4ZXMsIG5vZGVzKTtcbiAgICAgICAgdGhpcy5ub2Rlc0NoYW5nZWQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy52aWV3c0NoYW5nZWQuY2xlYXIoKTtcbiAgICB9XG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzUG9wdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIE11c3QgY2xlYXIgbm9kZXNDaGFuZ2VkLCBvdGhlcndpc2UgYSBzdWJzZXF1ZW50IGNvbW1pdCBjYWxsIHdpbGwgYnJlYWssIGJlY2F1c2UgaXQgYXNzdW1lcyBhIG5vZGUgaXMgdGhlcmVcbiAgICAgICAgdGhpcy5ub2Rlc0NoYW5nZWQuY2xlYXIoKTtcbiAgICAgICAgLy8gSXQncyBub3QgbmVjZXNzYXJ5IHRvIGNsZWFyIHRoaXMudmlld3NDaGFuZ2VkIHNpbmNlIHRoZXkgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIGNhY2hlLlxuICAgICAgICAvLyBIb3dldmVyIHByZXNlcnZpbmcgX1NPTUVfIGNhY2hlcyByZXN1bHRzIGluIGEgdmVyeSB1bnByZWRpY3RhYmxlIGV4cGVyaWVuY2UuXG4gICAgICAgIHRoaXMudmlld3NDaGFuZ2VkLmNsZWFyKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyVHJlZVZpZXdEVUNsYXNzKHR5cGUpIHtcbiAgICBjbGFzcyBDdXN0b21Db250YWluZXJUcmVlVmlld0RVIGV4dGVuZHMgQ29udGFpbmVyVHJlZVZpZXdEVSB7XG4gICAgfVxuICAgIC8vIER5bmFtaWNhbGx5IGRlZmluZSBwcm90b3R5cGUgbWV0aG9kc1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0eXBlLmZpZWxkc0VudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGROYW1lLCBmaWVsZFR5cGUgfSA9IHR5cGUuZmllbGRzRW50cmllc1tpbmRleF07XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCB0eXBlIGlzIGJhc2ljLCB0aGUgdmFsdWUgdG8gZ2V0IGFuZCBzZXQgd2lsbCBiZSB0aGUgYWN0dWFsICdzdHJ1Y3QnIHZhbHVlIChpLmUuIGEgSlMgbnVtYmVyKS5cbiAgICAgICAgLy8gVGhlIHZpZXcgbXVzdCB1c2UgdGhlIHRyZWVfZ2V0RnJvbU5vZGUoKSBhbmQgdHJlZV9zZXRUb05vZGUoKSBtZXRob2RzIHRvIHBlcnNpc3QgdGhlIHN0cnVjdCBkYXRhIHRvIHRoZSBub2RlLFxuICAgICAgICAvLyBhbmQgdXNlIHRoZSBjYWNoZWQgdmlld3MgYXJyYXkgdG8gc3RvcmUgdGhlIG5ldyBub2RlLlxuICAgICAgICBpZiAoYmFzaWNfMS5pc0Jhc2ljVHlwZShmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXdEVS5wcm90b3R5cGUsIGZpZWxkTmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZpZXcgdGhlIG1lbW9yeSBjb3N0IG9mIHRoaXMgY2xvc3VyZXNcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3Qgd2FsayB0aHJvdWdoIHRoZSB0cmVlIHRvIGdldCB0aGUgcm9vdCBub2RlIGZvciB0aGF0IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5ub2Rlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZUF0RGVwdGgodGhpcy5fcm9vdE5vZGUsIHRoaXMudHlwZS5kZXB0aCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFR5cGUudHJlZV9nZXRGcm9tTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgbm9kZSBpZiBjdXJyZW50IGxlYWZOb2RlIGlzIG5vdCBkaXJ0eVxuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzQ2hhbmdlZC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGFzc3VtZXMgdGhhdCBub2RlIGhhcyBhbHJlYWR5IGJlZW4gcG9wdWxhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQ2hhbmdlZCA9IHRoaXMubm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVByZXYgPSAodGhpcy5ub2Rlc1tpbmRleF0gPz8gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmdldE5vZGVBdERlcHRoKHRoaXMuX3Jvb3ROb2RlLCB0aGlzLnR5cGUuZGVwdGgsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQ2hhbmdlZCA9IG5vZGVQcmV2LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2hhbmdlZCBub2RlIGluIHRoZSBub2RlcyBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpbmRleF0gPSBub2RlQ2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXNDaGFuZ2VkLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlLnRyZWVfc2V0VG9Ob2RlKG5vZGVDaGFuZ2VkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCB0eXBlIGlzIGNvbXBvc2l0ZSwgdGhlIHZhbHVlIHRvIGdldCBhbmQgc2V0IHdpbGwgYmUgYW5vdGhlciBUcmVlVmlldy4gVGhlIHBhcmVudCBUcmVlVmlldyBtdXN0XG4gICAgICAgIC8vIGNhY2hlIHRoZSB2aWV3IGl0c2VsZiB0byByZXRhaW4gdGhlIGNhY2hlcyBvZiB0aGUgY2hpbGQgdmlldy4gVG8gc2V0IGEgdmFsdWUgdGhlIHZpZXcgbXVzdCByZXR1cm4gYSBub2RlIHRvXG4gICAgICAgIC8vIHNldCBpdCB0byB0aGUgcGFyZW50IHRyZWUgaW4gdGhlIGZpZWxkIGdpbmRleC5cbiAgICAgICAgZWxzZSBpZiAoY29tcG9zaXRlXzEuaXNDb21wb3NpdGVUeXBlKGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlld0RVLnByb3RvdHlwZSwgZmllbGROYW1lLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgVHJlZVZpZXdEVSBvZiBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld0NoYW5nZWQgPSB0aGlzLnZpZXdzQ2hhbmdlZC5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlld0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdDaGFuZ2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5ub2Rlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZUF0RGVwdGgodGhpcy5fcm9vdE5vZGUsIHRoaXMudHlwZS5kZXB0aCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG5ldyB2aWV3IHRvIGNhbGwgLmNvbW1pdCBvbiBpdCBsYXR0ZXIsIG9ubHkgaWYgbXV0YWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZmllbGRUeXBlLmdldFZpZXdEVShub2RlLCB0aGlzLmNhY2hlc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRUeXBlLmlzVmlld011dGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3NDaGFuZ2VkLnNldChpbmRleCwgdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBwZXJzaXN0IHRoZSBjaGlsZCdzIHZpZXcgY2FjaGUgc2luY2UgYSBzZWNvbmQgZ2V0IHJldHVybnMgdGhpcyB2aWV3IGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FjaGUgaXMgb25seSBwZXJzaXN0ZWQgb24gY29tbWl0IHdoZXJlIHRoZSB2aWV3c0NoYW5nZWQgbWFwIGlzIGRyb3BwZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEV4cGVjdHMgVHJlZVZpZXdEVSBvZiBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gc2V0dGluZyBhIHZpZXc6XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gTm90IG5lY2Vzc2FyeSB0byBjb21taXQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyAtIE5vdCBuZWNlc3NhcnkgdG8gcGVyc2lzdCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGtlZXBpbmcgYSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgaW4gdGhpcy52aWV3c0NoYW5nZWQgZW5zdXJlcyBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdzQ2hhbmdlZC5zZXQoaW5kZXgsIHZpZXcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSB1bnJlYWNoYWJsZSBjb2RlICovXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5rbm93biBmaWVsZFR5cGUgJHtmaWVsZFR5cGUudHlwZU5hbWV9IGZvciBmaWVsZE5hbWUgJHtmaWVsZE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hhbmdlIGNsYXNzIG5hbWVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXdEVSwgXCJuYW1lXCIsIHsgdmFsdWU6IHR5cGUudHlwZU5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXdEVTtcbn1cbmV4cG9ydHMuZ2V0Q29udGFpbmVyVHJlZVZpZXdEVUNsYXNzID0gZ2V0Q29udGFpbmVyVHJlZVZpZXdEVUNsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDb250YWluZXJUcmVlVmlld0RVQ2xhc3MgPSB2b2lkIDA7XG5jb25zdCBjb21wb3NpdGVfMSA9IHJlcXVpcmUoXCIuLi90eXBlL2NvbXBvc2l0ZVwiKTtcbmNvbnN0IGFic3RyYWN0XzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdFwiKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmcgKi9cbmNsYXNzIENvbnRhaW5lclRyZWVWaWV3RFUgZXh0ZW5kcyBhYnN0cmFjdF8xLlRyZWVWaWV3RFUge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5vZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdE5vZGU7XG4gICAgfVxuICAgIGdldCBjYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlQ2hhbmdlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZUNoYW5nZWQ7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcm9vdE5vZGUgPSB0aGlzLnR5cGUudmFsdWVfdG9UcmVlKHZhbHVlKTtcbiAgICB9XG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5lclRyZWVWaWV3RFVDbGFzcyh0eXBlKSB7XG4gICAgY2xhc3MgQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXdEVSBleHRlbmRzIENvbnRhaW5lclRyZWVWaWV3RFUge1xuICAgIH1cbiAgICAvLyBEeW5hbWljYWxseSBkZWZpbmUgcHJvdG90eXBlIG1ldGhvZHNcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdHlwZS5maWVsZHNFbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCB7IGZpZWxkTmFtZSwgZmllbGRUeXBlIH0gPSB0eXBlLmZpZWxkc0VudHJpZXNbaW5kZXhdO1xuICAgICAgICAvLyBJZiB0aGUgZmllbGQgdHlwZSBpcyBiYXNpYywgdGhlIHZhbHVlIHRvIGdldCBhbmQgc2V0IHdpbGwgYmUgdGhlIGFjdHVhbCAnc3RydWN0JyB2YWx1ZSAoaS5lLiBhIEpTIG51bWJlcikuXG4gICAgICAgIC8vIFRoZSB2aWV3IG11c3QgdXNlIHRoZSB0cmVlX2dldEZyb21Ob2RlKCkgYW5kIHRyZWVfc2V0VG9Ob2RlKCkgbWV0aG9kcyB0byBwZXJzaXN0IHRoZSBzdHJ1Y3QgZGF0YSB0byB0aGUgbm9kZSxcbiAgICAgICAgLy8gYW5kIHVzZSB0aGUgY2FjaGVkIHZpZXdzIGFycmF5IHRvIHN0b3JlIHRoZSBuZXcgbm9kZS5cbiAgICAgICAgaWYgKGZpZWxkVHlwZS5pc0Jhc2ljKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXdEVS5wcm90b3R5cGUsIGZpZWxkTmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZpZXcgdGhlIG1lbW9yeSBjb3N0IG9mIHRoaXMgY2xvc3VyZXNcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZUNoYW5nZWQgfHwgdGhpcy5fcm9vdE5vZGUudmFsdWUpW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZUNoYW5nZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VkID0gdGhpcy50eXBlLmNsb25lKHRoaXMuX3Jvb3ROb2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZFtmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCB0eXBlIGlzIGNvbXBvc2l0ZSwgdGhlIHZhbHVlIHRvIGdldCBhbmQgc2V0IHdpbGwgYmUgYW5vdGhlciBUcmVlVmlldy4gVGhlIHBhcmVudCBUcmVlVmlldyBtdXN0XG4gICAgICAgIC8vIGNhY2hlIHRoZSB2aWV3IGl0c2VsZiB0byByZXRhaW4gdGhlIGNhY2hlcyBvZiB0aGUgY2hpbGQgdmlldy4gVG8gc2V0IGEgdmFsdWUgdGhlIHZpZXcgbXVzdCByZXR1cm4gYSBub2RlIHRvXG4gICAgICAgIC8vIHNldCBpdCB0byB0aGUgcGFyZW50IHRyZWUgaW4gdGhlIGZpZWxkIGdpbmRleC5cbiAgICAgICAgZWxzZSBpZiAoY29tcG9zaXRlXzEuaXNDb21wb3NpdGVUeXBlKGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlld0RVLnByb3RvdHlwZSwgZmllbGROYW1lLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgVHJlZVZpZXdEVSBvZiBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlQ2hhbmdlZCB8fCB0aGlzLl9yb290Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVHlwZS50b1ZpZXdEVSh2YWx1ZVtmaWVsZE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEV4cGVjdHMgVHJlZVZpZXdEVSBvZiBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlQ2hhbmdlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQgPSB0aGlzLnR5cGUuY2xvbmUodGhpcy5fcm9vdE5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGRUeXBlLnRvVmFsdWVGcm9tVmlld0RVKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZFtmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHVucmVhY2hhYmxlIGNvZGUgKi9cbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIGZpZWxkVHlwZSAke2ZpZWxkVHlwZS50eXBlTmFtZX0gZm9yIGZpZWxkTmFtZSAke2ZpZWxkTmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGFuZ2UgY2xhc3MgbmFtZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlld0RVLCBcIm5hbWVcIiwgeyB2YWx1ZTogdHlwZS50eXBlTmFtZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiBDdXN0b21Db250YWluZXJUcmVlVmlld0RVO1xufVxuZXhwb3J0cy5nZXRDb250YWluZXJUcmVlVmlld0RVQ2xhc3MgPSBnZXRDb250YWluZXJUcmVlVmlld0RVQ2xhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWluZXJOb2RlU3RydWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0QmFzaWNUcmVlVmlld0RVID0gdm9pZCAwO1xuY29uc3QgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZVwiKTtcbmNvbnN0IGFycmF5QmFzaWNfMSA9IHJlcXVpcmUoXCIuL2FycmF5QmFzaWNcIik7XG5jbGFzcyBMaXN0QmFzaWNUcmVlVmlld0RVIGV4dGVuZHMgYXJyYXlCYXNpY18xLkFycmF5QmFzaWNUcmVlVmlld0RVIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBfcm9vdE5vZGUsIGNhY2hlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIF9yb290Tm9kZSwgY2FjaGUpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IF9yb290Tm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgdmFsdWUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhbmQgYWRkcyAxIHRvIHRoZSB1bi1jb21taXRlZCBWaWV3RFUgbGVuZ3RoXG4gICAgICovXG4gICAgcHVzaCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID49IHRoaXMudHlwZS5saW1pdCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvciBwdXNoaW5nIG92ZXIgbGltaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXV0YXRlIGxlbmd0aCBiZWZvcmUgLnNldCgpXG4gICAgICAgIHRoaXMuZGlydHlMZW5ndGggPSB0cnVlO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xlbmd0aCsrO1xuICAgICAgICAvLyBJZiBpbiBuZXcgbm9kZS4uXG4gICAgICAgIGlmIChpbmRleCAlIHRoaXMudHlwZS5pdGVtc1BlckNodW5rID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTZXQgYSB6ZXJvIG5vZGUgdG8gdGhlIG5vZGVzIGFycmF5IHRvIGF2b2lkIGEgbmF2aWdhdGlvbiBkb3dud2FyZHMgaW4gLnNldCgpXG4gICAgICAgICAgICBjb25zdCBjaHVua0luZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMudHlwZS5pdGVtc1BlckNodW5rKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbY2h1bmtJbmRleF0gPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuemVyb05vZGUoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RCYXNpY1RyZWVWaWV3RFUgPSBMaXN0QmFzaWNUcmVlVmlld0RVO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlzdEJhc2ljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0Q29tcG9zaXRlVHJlZVZpZXdEVSA9IHZvaWQgMDtcbmNvbnN0IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3BlcnNpc3RlbnQtbWVya2xlLXRyZWVcIik7XG5jb25zdCBhcnJheUNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4vYXJyYXlDb21wb3NpdGVcIik7XG5jbGFzcyBMaXN0Q29tcG9zaXRlVHJlZVZpZXdEVSBleHRlbmRzIGFycmF5Q29tcG9zaXRlXzEuQXJyYXlDb21wb3NpdGVUcmVlVmlld0RVIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBfcm9vdE5vZGUsIGNhY2hlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIF9yb290Tm9kZSwgY2FjaGUpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9yb290Tm9kZSA9IF9yb290Tm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgdmFsdWUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhbmQgYWRkcyAxIHRvIHRoZSB1bi1jb21taXRlZCBWaWV3RFUgbGVuZ3RoXG4gICAgICovXG4gICAgcHVzaCh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPj0gdGhpcy50eXBlLmxpbWl0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkVycm9yIHB1c2hpbmcgb3ZlciBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9sZW5ndGgrKztcbiAgICAgICAgLy8gTm8gbmVlZCBmb3IgcHJlLWluaXRpYWxpemF0aW9uIGxpa2UgaW4gTGlzdEJhc2ljLnB1c2ggc2luY2UgQXJyYXlDb21wb3NpdGVUcmVlVmlld0RVLnNldCgpIGRvZXNuJ3QgZG8gYSBnZXQgbm9kZVxuICAgICAgICB0aGlzLnNldChpbmRleCwgdmlldyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgTGlzdENvbXBvc2l0ZVRyZWVWaWV3RFUgaW5zdGFuY2Ugd2l0aCB0aGUgdmFsdWVzIGZyb20gMCB0byBgaW5kZXhgLlxuICAgICAqIFRoZSBuZXcgbGlzdCBpcyBlcXVpdmFsZW50IHRvIChwc2V1ZG8tY29kZSk6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG5vZGVzID0gZ2V0Q2h1bmtOb2RlcygpXG4gICAgICogcmV0dXJuIGxpc3RGcm9tQ2h1bmtOb2Rlcyhub2Rlcy5zbGljZSgwLCBpbmRleCArIDEpKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVG8gYWNoaWV2ZSBpdCwgcmViaW5kcyB0aGUgdW5kZXJseWluZyB0cmVlIHplcm8taW5nIGFsbCBub2RlcyByaWdodCBvZiBgaW5kZXhgLlxuICAgICAqXG4gICAgICogTm90ZTogVXNpbmcgaW5kZXggPSAtMSwgcmV0dXJucyBhbiBlbXB0eSBsaXN0IG9mIGxlbmd0aCAwLlxuICAgICAqL1xuICAgIHNsaWNlVG8oaW5kZXgpIHtcbiAgICAgICAgLy8gQ29tbWl0IGJlZm9yZSBnZXR0aW5nIHJvb3ROb2RlIHRvIGVuc3VyZSBhbGwgcGVuZGluZyBkYXRhIGlzIGluIHRoZSByb290Tm9kZVxuICAgICAgICB0aGlzLmNvbW1pdCgpO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IHRoaXMuX3Jvb3ROb2RlO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnR5cGUudHJlZV9nZXRMZW5ndGgocm9vdE5vZGUpO1xuICAgICAgICAvLyBBbGwgbm9kZXMgYmV5b25kIGxlbmd0aCBhcmUgYWxyZWFkeSB6ZXJvXG4gICAgICAgIC8vIEFycmF5IG9mIGxlbmd0aCAyOiBbWCxYLDAsMF0sIGZvciBpbmRleCA+PSAxIG5vIGFjdGlvbiBuZWVkZWRcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBMaXN0LCBkbyB0aGUgdHJlZVplcm9BZnRlckluZGV4IG9wZXJhdGlvbiBvbiB0aGUgY2h1bmtzIHRyZWVcbiAgICAgICAgY29uc3QgY2h1bmtzTm9kZSA9IHRoaXMudHlwZS50cmVlX2dldENodW5rc05vZGUocm9vdE5vZGUpO1xuICAgICAgICBjb25zdCBuZXdDaHVua3NOb2RlID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLnRyZWVaZXJvQWZ0ZXJJbmRleChjaHVua3NOb2RlLCB0aGlzLnR5cGUuY2h1bmtEZXB0aCwgaW5kZXgpO1xuICAgICAgICAvLyBNdXN0IHNldCBuZXcgbGVuZ3RoIGFuZCBjb21taXQgdG8gdHJlZSB0byByZXN0b3JlIHRoZSBzYW1lIHRyZWUgYXQgdGhhdCBpbmRleFxuICAgICAgICBjb25zdCBuZXdMZW5ndGggPSBpbmRleCArIDE7XG4gICAgICAgIGNvbnN0IG5ld1Jvb3ROb2RlID0gdGhpcy50eXBlLnRyZWVfc2V0Q2h1bmtzTm9kZShyb290Tm9kZSwgbmV3Q2h1bmtzTm9kZSwgbmV3TGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5nZXRWaWV3RFUobmV3Um9vdE5vZGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdENvbXBvc2l0ZVRyZWVWaWV3RFUgPSBMaXN0Q29tcG9zaXRlVHJlZVZpZXdEVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3RDb21wb3NpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyZWVWaWV3ID0gdm9pZCAwO1xuY29uc3QgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZVwiKTtcbi8qKlxuICogQSBUcmVlIFZpZXcgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIHR5cGUgYW5kIGFuIFNTWiBUcmVlIHRoYXQgY29udGFpbnM6XG4gKiAtIGRhdGEgbWVya2xlaXplZFxuICogLSBhIGhvb2sgdG8gaXRzIHBhcmVudCBUcmVlIHRvIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZHNcbiAqXG4gKiAqKlZpZXcqKlxuICogLSBCZXN0IGZvciBzaW1wbGUgdXNhZ2Ugd2hlcmUgcGVyZm9ybWFuY2UgaXMgTk9UIGltcG9ydGFudFxuICogLSBBcHBsaWVzIGNoYW5nZXMgaW1tZWRpYXRlbHlcbiAqIC0gSGFzIHJlZmVyZW5jZSB0byBwYXJlbnQgdHJlZVxuICogLSBEb2VzIE5PVCBoYXZlIGNhY2hlcyBmb3IgZmFzdCBnZXQgLyBzZXQgb3BzXG4gKi9cbmNsYXNzIFRyZWVWaWV3IHtcbiAgICAvKiogU2VyaWFsaXplIHZpZXcgdG8gYmluYXJ5IGRhdGEgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHRoaXMudHlwZS50cmVlX3NlcmlhbGl6ZWRTaXplKHRoaXMubm9kZSkpO1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRwdXQuYnVmZmVyLCBvdXRwdXQuYnl0ZU9mZnNldCwgb3V0cHV0LmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnR5cGUudHJlZV9zZXJpYWxpemVUb0J5dGVzKHsgdWludDhBcnJheTogb3V0cHV0LCBkYXRhVmlldyB9LCAwLCB0aGlzLm5vZGUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJrbGVpemUgdmlldyBhbmQgY29tcHV0ZSBpdHMgaGFzaFRyZWVSb290LlxuICAgICAqXG4gICAgICogU2VlIHNwZWMgZm9yIGRlZmluaXRpb24gb2YgaGFzaFRyZWVSb290OlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9jb25zZW5zdXMtc3BlY3MvYmxvYi9kZXYvc3N6L3NpbXBsZS1zZXJpYWxpemUubWQjbWVya2xlaXphdGlvblxuICAgICAqL1xuICAgIGhhc2hUcmVlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5yb290O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBNZXJrbGUgbXVsdGlwcm9vZiBvbiB0aGlzIHZpZXcncyBkYXRhLlxuICAgICAqIEEgYHBhdGhgIGlzIGFuIGFycmF5IG9mICdKU09OJyBwYXRocyBpbnRvIHRoZSBkYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIHN0YXRlLmNyZWF0ZVByb29mKFtcbiAgICAgKiAgIFtcInZhbGlkYXRvcnNcIiwgMTIzNCwgXCJzbGFzaGVkXCJdLFxuICAgICAqICAgW1wiZ2VuZXNpc1RpbWVcIl1cbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIHNwZWMgZm9yIGRlZmluaXRpb24gb2YgbWVya2xlIG11bHRpcHJvb2ZzOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9jb25zZW5zdXMtc3BlY3MvYmxvYi9kZXYvc3N6L21lcmtsZS1wcm9vZnMubWQjbWVya2xlLW11bHRpcHJvb2ZzXG4gICAgICovXG4gICAgY3JlYXRlUHJvb2YocGF0aHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS50cmVlX2NyZWF0ZVByb29mKHRoaXMubm9kZSwgcGF0aHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIHZpZXcgaW50byBhIHZhbHVlLCBmcm9tIHRoZSBjdXJyZW50IG5vZGUgaW5zdGFuY2UuXG4gICAgICogRm9yIFZpZXdEVSByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgY29tbWl0dGVkIGRhdGEsIHNvIGNhbGwgLmNvbW1pdCgpIGJlZm9yZSBpZiB0aGVyZSBhcmUgcGVuZGluZyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHRvVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUudHJlZV90b1ZhbHVlKHRoaXMubm9kZSk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm4gYSBuZXcgVHJlZSBWaWV3IGluc3RhbmNlIHJlZmVyZW5jaW5nIHRoZSBzYW1lIGludGVybmFsIGBOb2RlYC4gRHJvcHMgaXRzIGV4aXN0aW5nIGBUcmVlYCBob29rIGlmIGFueSAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmdldFZpZXcobmV3IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5UcmVlKHRoaXMubm9kZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJlZVZpZXcgPSBUcmVlVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcnJheUJhc2ljVHJlZVZpZXcgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgYWJzdHJhY3RfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0XCIpO1xuY2xhc3MgQXJyYXlCYXNpY1RyZWVWaWV3IGV4dGVuZHMgYWJzdHJhY3RfMS5UcmVlVmlldyB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdHJlZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LiBFcXVhbCB0byB0aGUgVWludDMyIHZhbHVlIG9mIHRoZSBUcmVlJ3MgbGVuZ3RoIG5vZGVcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLnRyZWVfZ2V0TGVuZ3RoKHRoaXMudHJlZS5yb290Tm9kZSk7XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnJvb3ROb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBgaW5kZXhgLiBSZXR1cm5zIHRoZSBCYXNpYyBlbGVtZW50IHR5cGUgdmFsdWUgZGlyZWN0bHlcbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgLy8gRmlyc3Qgd2FsayB0aHJvdWdoIHRoZSB0cmVlIHRvIGdldCB0aGUgcm9vdCBub2RlIGZvciB0aGF0IGluZGV4XG4gICAgICAgIGNvbnN0IGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy50eXBlLml0ZW1zUGVyQ2h1bmspO1xuICAgICAgICBjb25zdCBsZWFmTm9kZSA9IHRoaXMudHJlZS5nZXROb2RlQXREZXB0aCh0aGlzLnR5cGUuZGVwdGgsIGNodW5rSW5kZXgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5lbGVtZW50VHlwZS50cmVlX2dldEZyb21QYWNrZWROb2RlKGxlYWZOb2RlLCBpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBCYXNpYyBlbGVtZW50IHR5cGUgYHZhbHVlYCBhdCBgaW5kZXhgXG4gICAgICovXG4gICAgc2V0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIHNldHRpbmcgaW5kZXggb3ZlciBsZW5ndGggJHtpbmRleH0gPiAke2xlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVua0luZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMudHlwZS5pdGVtc1BlckNodW5rKTtcbiAgICAgICAgY29uc3QgbGVhZk5vZGVQcmV2ID0gdGhpcy50cmVlLmdldE5vZGVBdERlcHRoKHRoaXMudHlwZS5kZXB0aCwgY2h1bmtJbmRleCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBub2RlIHRvIHByZXNlcnZlIGltbXV0YWJpbGl0eVxuICAgICAgICBjb25zdCBsZWFmTm9kZSA9IGxlYWZOb2RlUHJldi5jbG9uZSgpO1xuICAgICAgICB0aGlzLnR5cGUuZWxlbWVudFR5cGUudHJlZV9zZXRUb1BhY2tlZE5vZGUobGVhZk5vZGUsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIC8vIENvbW1pdCBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLnRyZWUuc2V0Tm9kZUF0RGVwdGgodGhpcy50eXBlLmRlcHRoLCBjaHVua0luZGV4LCBsZWFmTm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdmFsdWVzIG9mIHRoaXMgYXJyYXkgYXMgQmFzaWMgZWxlbWVudCB0eXBlIHZhbHVlcywgZnJvbSBpbmRleCB6ZXJvIHRvIGB0aGlzLmxlbmd0aCAtIDFgXG4gICAgICovXG4gICAgZ2V0QWxsKCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY2h1bmtzTm9kZSA9IHRoaXMudHlwZS50cmVlX2dldENodW5rc05vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IE1hdGguY2VpbChsZW5ndGggLyB0aGlzLnR5cGUuaXRlbXNQZXJDaHVuayk7XG4gICAgICAgIGNvbnN0IGxlYWZOb2RlcyA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2Rlc0F0RGVwdGgoY2h1bmtzTm9kZSwgdGhpcy50eXBlLmNodW5rRGVwdGgsIDAsIGNodW5rQ291bnQpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaXRlbXNQZXJDaHVuayA9IHRoaXMudHlwZS5pdGVtc1BlckNodW5rOyAvLyBQcmV2ZW50IG1hbnkgYWNjZXNzIGluIGZvciBsb29wIGJlbG93XG4gICAgICAgIGNvbnN0IGxlbkZ1bGxOb2RlcyA9IE1hdGguZmxvb3IobGVuZ3RoIC8gaXRlbXNQZXJDaHVuayk7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IGxlbmd0aCAlIGl0ZW1zUGVyQ2h1bms7XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbGVuRnVsbE5vZGVzOyBuKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZOb2RlID0gbGVhZk5vZGVzW25dO1xuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGFkZCBhIGZhc3QgYnVsayBwYWNrZWQgZWxlbWVudCByZWFkZXIgaW4gdGhlIGVsZW1lbnRUeXBlXG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIC8vIGFic3RyYWN0IGdldFZhbHVlc0Zyb21QYWNrZWROb2RlKGxlYWZOb2RlOiBMZWFmTm9kZSwgb3V0cHV0OiBWW10sIGluZGV4T2Zmc2V0OiBudW1iZXIpOiB2b2lkO1xuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAvLyBpZiBwZXJmb3JtYW5jZSBoZXJlIGlzIGEgcHJvYmxlbVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtc1BlckNodW5rOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbbiAqIGl0ZW1zUGVyQ2h1bmsgKyBpXSA9IHRoaXMudHlwZS5lbGVtZW50VHlwZS50cmVlX2dldEZyb21QYWNrZWROb2RlKGxlYWZOb2RlLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtYWluZGVyID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGVhZk5vZGUgPSBsZWFmTm9kZXNbbGVuRnVsbE5vZGVzXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtYWluZGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbbGVuRnVsbE5vZGVzICogaXRlbXNQZXJDaHVuayArIGldID0gdGhpcy50eXBlLmVsZW1lbnRUeXBlLnRyZWVfZ2V0RnJvbVBhY2tlZE5vZGUobGVhZk5vZGUsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5BcnJheUJhc2ljVHJlZVZpZXcgPSBBcnJheUJhc2ljVHJlZVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheUJhc2ljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcnJheUNvbXBvc2l0ZVRyZWVWaWV3ID0gdm9pZCAwO1xuY29uc3QgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZVwiKTtcbmNvbnN0IGFic3RyYWN0XzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdFwiKTtcbmNsYXNzIEFycmF5Q29tcG9zaXRlVHJlZVZpZXcgZXh0ZW5kcyBhYnN0cmFjdF8xLlRyZWVWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB0cmVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuIEVxdWFsIHRvIHRoZSBVaW50MzIgdmFsdWUgb2YgdGhlIFRyZWUncyBsZW5ndGggbm9kZVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUudHJlZV9nZXRMZW5ndGgodGhpcy50cmVlLnJvb3ROb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVmlldydzIFRyZWUgcm9vdE5vZGVcbiAgICAgKi9cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5yb290Tm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgYGluZGV4YC4gUmV0dXJucyBhIHZpZXcgb2YgdGhlIENvbXBvc2l0ZSBlbGVtZW50IHR5cGVcbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgLy8gVE9ETzogT3B0aW1pemUgd2l0aG91dCBiaXRzdHJpbmdcbiAgICAgICAgY29uc3QgZ2luZGV4ID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLnRvR2luZGV4Qml0c3RyaW5nKHRoaXMudHlwZS5kZXB0aCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBzdWJ0cmVlID0gdGhpcy50cmVlLmdldFN1YnRyZWUoZ2luZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5lbGVtZW50VHlwZS5nZXRWaWV3KHN1YnRyZWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBgaW5kZXhgLiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgQ29tcG9zaXRlIGVsZW1lbnQgdHlwZS5cbiAgICAgKiBET0VTIE5PVCBQUk9QQUdBVEUgQ0hBTkdFUzogdXNlIG9ubHkgZm9yIHJlYWRzIGFuZCB0byBza2lwIHBhcmVudCByZWZlcmVuY2VzLlxuICAgICAqL1xuICAgIGdldFJlYWRvbmx5KGluZGV4KSB7XG4gICAgICAgIC8vIFRPRE86IE9wdGltaXplIHdpdGhvdXQgYml0c3RyaW5nXG4gICAgICAgIGNvbnN0IGdpbmRleCA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS50b0dpbmRleEJpdHN0cmluZyh0aGlzLnR5cGUuZGVwdGgsIGluZGV4KTtcbiAgICAgICAgLy8gdHJlZS5nZXRTdWJ0cmVlIGJ1dCB3aXRob3V0IHRoZSBob29rXG4gICAgICAgIGNvbnN0IHN1YnRyZWUgPSBuZXcgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLlRyZWUodGhpcy50cmVlLmdldE5vZGUoZ2luZGV4KSk7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZWxlbWVudFR5cGUuZ2V0VmlldyhzdWJ0cmVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IENvbXBvc2l0ZSBlbGVtZW50IHR5cGUgYHZpZXdgIGF0IGBpbmRleGBcbiAgICAgKi9cbiAgICBzZXQoaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBzZXR0aW5nIGluZGV4IG92ZXIgbGVuZ3RoICR7aW5kZXh9ID4gJHtsZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMudHlwZS5lbGVtZW50VHlwZS5jb21taXRWaWV3KHZpZXcpO1xuICAgICAgICB0aGlzLnRyZWUuc2V0Tm9kZUF0RGVwdGgodGhpcy50eXBlLmRlcHRoLCBpbmRleCwgbm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygdmlld3Mgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBhcnJheSwgZnJvbSBpbmRleCB6ZXJvIHRvIGB0aGlzLmxlbmd0aCAtIDFgLlxuICAgICAqIFRoZSByZXR1cm5lZCB2aWV3cyBkb24ndCBoYXZlIGEgcGFyZW50IGhvb2sgdG8gdGhpcyBWaWV3J3MgVHJlZSwgc28gY2hhbmdlcyBpbiB0aGUgcmV0dXJuZWQgdmlld3Mgd29uJ3QgYmVcbiAgICAgKiBwcm9wYWdhdGVkIHVwd2FyZHMuIFRvIGdldCBsaW5rZWQgZWxlbWVudCBWaWV3cyB1c2UgYHRoaXMuZ2V0KClgXG4gICAgICovXG4gICAgZ2V0QWxsUmVhZG9ubHkoKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjaHVua3NOb2RlID0gdGhpcy50eXBlLnRyZWVfZ2V0Q2h1bmtzTm9kZSh0aGlzLm5vZGUpO1xuICAgICAgICBjb25zdCBub2RlcyA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2Rlc0F0RGVwdGgoY2h1bmtzTm9kZSwgdGhpcy50eXBlLmNodW5rRGVwdGgsIDAsIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE9wdGltaXplXG4gICAgICAgICAgICB2aWV3c1tpXSA9IHRoaXMudHlwZS5lbGVtZW50VHlwZS5nZXRWaWV3KG5ldyBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuVHJlZShub2Rlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBhcnJheSwgZnJvbSBpbmRleCB6ZXJvIHRvIGB0aGlzLmxlbmd0aCAtIDFgLlxuICAgICAqIFRoZSByZXR1cm5lZCB2YWx1ZXMgYXJlIG5vdCBWaWV3cyBzbyBhbnkgY2hhbmdlcyB3b24ndCBiZSBwcm9wYWdhdGVkIHVwd2FyZHMuXG4gICAgICogVG8gZ2V0IGxpbmtlZCBlbGVtZW50IFZpZXdzIHVzZSBgdGhpcy5nZXQoKWBcbiAgICAgKi9cbiAgICBnZXRBbGxSZWFkb25seVZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNodW5rc05vZGUgPSB0aGlzLnR5cGUudHJlZV9nZXRDaHVua3NOb2RlKHRoaXMubm9kZSk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xLmdldE5vZGVzQXREZXB0aChjaHVua3NOb2RlLCB0aGlzLnR5cGUuY2h1bmtEZXB0aCwgMCwgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHRoaXMudHlwZS5lbGVtZW50VHlwZS50cmVlX3RvVmFsdWUobm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5BcnJheUNvbXBvc2l0ZVRyZWVWaWV3ID0gQXJyYXlDb21wb3NpdGVUcmVlVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5Q29tcG9zaXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRBcnJheVRyZWVWaWV3ID0gdm9pZCAwO1xuY29uc3QgYWJzdHJhY3RfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0XCIpO1xuLyoqXG4gKiBUaGluIHdyYXBwZXIgYXJvdW5kIEJpdEFycmF5IHRvIHVwc3RyZWFtIGNoYW5nZXMgdG8gYHRyZWVgIG9uIGV2ZXJ5IGB0aGlzLnNldCgpYFxuICovXG5jbGFzcyBCaXRBcnJheVRyZWVWaWV3IGV4dGVuZHMgYWJzdHJhY3RfMS5UcmVlVmlldyB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdHJlZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLmJpdEFycmF5ID0gdHlwZS50cmVlX3RvVmFsdWUodHJlZS5yb290Tm9kZSk7XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnJvb3ROb2RlO1xuICAgIH1cbiAgICAvLyBXcmFwcGVkIEFQSSBmcm9tIEJpdEFycmF5XG4gICAgLyoqIEBzZWUgQml0QXJyYXkudWludDhBcnJheSAqL1xuICAgIGdldCB1aW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS51aW50OEFycmF5O1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5iaXRMZW4gKi9cbiAgICBnZXQgYml0TGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS5iaXRMZW47XG4gICAgfVxuICAgIC8qKiBAc2VlIEJpdEFycmF5LmdldCAqL1xuICAgIGdldChiaXRJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS5nZXQoYml0SW5kZXgpO1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5zZXQgKi9cbiAgICBzZXQoYml0SW5kZXgsIGJpdCkge1xuICAgICAgICB0aGlzLmJpdEFycmF5LnNldChiaXRJbmRleCwgYml0KTtcbiAgICAgICAgLy8gVXBzdHJlYW0gY2hhbmdlc1xuICAgICAgICB0aGlzLnRyZWUucm9vdE5vZGUgPSB0aGlzLnR5cGUudmFsdWVfdG9UcmVlKHRoaXMuYml0QXJyYXkpO1xuICAgIH1cbiAgICAvKiogQHNlZSBCaXRBcnJheS5tZXJnZU9yV2l0aCAqL1xuICAgIG1lcmdlT3JXaXRoKGJpdEFycmF5Mikge1xuICAgICAgICB0aGlzLmJpdEFycmF5Lm1lcmdlT3JXaXRoKGJpdEFycmF5Mik7XG4gICAgfVxuICAgIC8qKiBAc2VlIEJpdEFycmF5LmludGVyc2VjdFZhbHVlcyAqL1xuICAgIGludGVyc2VjdFZhbHVlcyh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYml0QXJyYXkuaW50ZXJzZWN0VmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKiBAc2VlIEJpdEFycmF5LmdldFRydWVCaXRJbmRleGVzICovXG4gICAgZ2V0VHJ1ZUJpdEluZGV4ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdEFycmF5LmdldFRydWVCaXRJbmRleGVzKCk7XG4gICAgfVxuICAgIC8qKiBAc2VlIEJpdEFycmF5LmdldFNpbmdsZVRydWVCaXQgKi9cbiAgICBnZXRTaW5nbGVUcnVlQml0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRBcnJheS5nZXRTaW5nbGVUcnVlQml0KCk7XG4gICAgfVxuICAgIC8qKiBAc2VlIEJpdEFycmF5LnRvQm9vbEFycmF5ICovXG4gICAgdG9Cb29sQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpdEFycmF5LnRvQm9vbEFycmF5KCk7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRBcnJheVRyZWVWaWV3ID0gQml0QXJyYXlUcmVlVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdEFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDb250YWluZXJUcmVlVmlld0NsYXNzID0gdm9pZCAwO1xuY29uc3QgcGVyc2lzdGVudF9tZXJrbGVfdHJlZV8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvcGVyc2lzdGVudC1tZXJrbGUtdHJlZVwiKTtcbmNvbnN0IGJhc2ljXzEgPSByZXF1aXJlKFwiLi4vdHlwZS9iYXNpY1wiKTtcbmNvbnN0IGNvbXBvc2l0ZV8xID0gcmVxdWlyZShcIi4uL3R5cGUvY29tcG9zaXRlXCIpO1xuY29uc3QgYWJzdHJhY3RfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0XCIpO1xuLyoqXG4gKiBJbnRlbnRlZCB1c2FnZTpcbiAqXG4gKiAtIEdldCBpbml0aWFsIEJlYWNvblN0YXRlIGZyb20gZGlzay5cbiAqIC0gQmVmb3JlIGFwcGx5aW5nIG5leHQgYmxvY2ssIHN3aXRjaCB0byBtdXRhYmxlXG4gKiAtIEdldCBzb21lIGZpZWxkLCBjcmVhdGUgYSB2aWV3IGluIG11dGFibGUgbW9kZVxuICogLSBEbyBtb2RpZmljYXRpb25zIG9mIHRoZSBzdGF0ZSBpbiB0aGUgc3RhdGUgdHJhbnNpdGlvbiBmdW5jdGlvblxuICogLSBXaGVuIGRvbmUsIGNvbW1pdCBhbmQgYXBwbHkgbmV3IHJvb3Qgbm9kZSBvbmNlIHRvIG9nIEJlYWNvblN0YXRlXG4gKiAtIEhvd2V2ZXIsIGtlZXAgYWxsIHRoZSBjYWNoZXMgYW5kIHRyYW5zZmVyIHRoZW0gdG8gdGhlIG5ldyBCZWFjb25TdGF0ZVxuICpcbiAqIFF1ZXN0aW9uczpcbiAqIC0gQ2FuIHRoZSBjaGlsZCB2aWV3cyBjcmVhdGVkIGluIG11dGFibGUgbW9kZSBzd2l0Y2ggdG8gbm90IG11dGFibGU/IElmIHNvLCBpdCBzZWVtcyB0aGF0IGl0IG5lZWRzIHRvIHJlY3Vyc2l2ZWx5XG4gKiAgIGl0ZXJhdGUgdGhlIGVudGlyZSBkYXRhIHN0cnVjdHVyZSBhbmQgdmlld3NcbiAqXG4gKi9cbmNsYXNzIENvbnRhaW5lclRyZWVWaWV3IGV4dGVuZHMgYWJzdHJhY3RfMS5UcmVlVmlldyB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdHJlZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5yb290Tm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJUcmVlVmlld0NsYXNzKHR5cGUpIHtcbiAgICBjbGFzcyBDdXN0b21Db250YWluZXJUcmVlVmlldyBleHRlbmRzIENvbnRhaW5lclRyZWVWaWV3IHtcbiAgICB9XG4gICAgLy8gRHluYW1pY2FsbHkgZGVmaW5lIHByb3RvdHlwZSBtZXRob2RzXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHR5cGUuZmllbGRzRW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSB9ID0gdHlwZS5maWVsZHNFbnRyaWVzW2luZGV4XTtcbiAgICAgICAgLy8gSWYgdGhlIGZpZWxkIHR5cGUgaXMgYmFzaWMsIHRoZSB2YWx1ZSB0byBnZXQgYW5kIHNldCB3aWxsIGJlIHRoZSBhY3R1YWwgJ3N0cnVjdCcgdmFsdWUgKGkuZS4gYSBKUyBudW1iZXIpLlxuICAgICAgICAvLyBUaGUgdmlldyBtdXN0IHVzZSB0aGUgdHJlZV9nZXRGcm9tTm9kZSgpIGFuZCB0cmVlX3NldFRvTm9kZSgpIG1ldGhvZHMgdG8gcGVyc2lzdCB0aGUgc3RydWN0IGRhdGEgdG8gdGhlIG5vZGUsXG4gICAgICAgIC8vIGFuZCB1c2UgdGhlIGNhY2hlZCB2aWV3cyBhcnJheSB0byBzdG9yZSB0aGUgbmV3IG5vZGUuXG4gICAgICAgIGlmIChiYXNpY18xLmlzQmFzaWNUeXBlKGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlldy5wcm90b3R5cGUsIGZpZWxkTmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZpZXcgdGhlIG1lbW9yeSBjb3N0IG9mIHRoaXMgY2xvc3VyZXNcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhZk5vZGUgPSBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEuZ2V0Tm9kZUF0RGVwdGgodGhpcy5ub2RlLCB0aGlzLnR5cGUuZGVwdGgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVHlwZS50cmVlX2dldEZyb21Ob2RlKGxlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYWZOb2RlUHJldiA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5nZXROb2RlQXREZXB0aCh0aGlzLm5vZGUsIHRoaXMudHlwZS5kZXB0aCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmTm9kZSA9IGxlYWZOb2RlUHJldi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUudHJlZV9zZXRUb05vZGUobGVhZk5vZGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlLnNldE5vZGVBdERlcHRoKHRoaXMudHlwZS5kZXB0aCwgaW5kZXgsIGxlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGZpZWxkIHR5cGUgaXMgY29tcG9zaXRlLCB0aGUgdmFsdWUgdG8gZ2V0IGFuZCBzZXQgd2lsbCBiZSBhbm90aGVyIFRyZWVWaWV3LiBUaGUgcGFyZW50IFRyZWVWaWV3IG11c3RcbiAgICAgICAgLy8gY2FjaGUgdGhlIHZpZXcgaXRzZWxmIHRvIHJldGFpbiB0aGUgY2FjaGVzIG9mIHRoZSBjaGlsZCB2aWV3LiBUbyBzZXQgYSB2YWx1ZSB0aGUgdmlldyBtdXN0IHJldHVybiBhIG5vZGUgdG9cbiAgICAgICAgLy8gc2V0IGl0IHRvIHRoZSBwYXJlbnQgdHJlZSBpbiB0aGUgZmllbGQgZ2luZGV4LlxuICAgICAgICBlbHNlIGlmIChjb21wb3NpdGVfMS5pc0NvbXBvc2l0ZVR5cGUoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUNvbnRhaW5lclRyZWVWaWV3LnByb3RvdHlwZSwgZmllbGROYW1lLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgVHJlZVZpZXcgb2YgZmllbGROYW1lXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdpbmRleCA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS50b0dpbmRleEJpdHN0cmluZyh0aGlzLnR5cGUuZGVwdGgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVHlwZS5nZXRWaWV3KHRoaXMudHJlZS5nZXRTdWJ0cmVlKGdpbmRleCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0cyBUcmVlVmlldyBvZiBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gZmllbGRUeXBlLmNvbW1pdFZpZXcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUuc2V0Tm9kZUF0RGVwdGgodGhpcy50eXBlLmRlcHRoLCBpbmRleCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHVucmVhY2hhYmxlIGNvZGUgKi9cbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIGZpZWxkVHlwZSAke2ZpZWxkVHlwZS50eXBlTmFtZX0gZm9yIGZpZWxkTmFtZSAke2ZpZWxkTmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGFuZ2UgY2xhc3MgbmFtZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlldywgXCJuYW1lXCIsIHsgdmFsdWU6IHR5cGUudHlwZU5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXc7XG59XG5leHBvcnRzLmdldENvbnRhaW5lclRyZWVWaWV3Q2xhc3MgPSBnZXRDb250YWluZXJUcmVlVmlld0NsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDb250YWluZXJUcmVlVmlld0NsYXNzID0gdm9pZCAwO1xuY29uc3QgY29tcG9zaXRlXzEgPSByZXF1aXJlKFwiLi4vdHlwZS9jb21wb3NpdGVcIik7XG5jb25zdCBicmFuY2hOb2RlU3RydWN0XzEgPSByZXF1aXJlKFwiLi4vYnJhbmNoTm9kZVN0cnVjdFwiKTtcbmNvbnN0IGFic3RyYWN0XzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdFwiKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmcgKi9cbi8qKlxuICogSW50ZW50ZWQgdXNhZ2U6XG4gKlxuICogLSBHZXQgaW5pdGlhbCBCZWFjb25TdGF0ZSBmcm9tIGRpc2suXG4gKiAtIEJlZm9yZSBhcHBseWluZyBuZXh0IGJsb2NrLCBzd2l0Y2ggdG8gbXV0YWJsZVxuICogLSBHZXQgc29tZSBmaWVsZCwgY3JlYXRlIGEgdmlldyBpbiBtdXRhYmxlIG1vZGVcbiAqIC0gRG8gbW9kaWZpY2F0aW9ucyBvZiB0aGUgc3RhdGUgaW4gdGhlIHN0YXRlIHRyYW5zaXRpb24gZnVuY3Rpb25cbiAqIC0gV2hlbiBkb25lLCBjb21taXQgYW5kIGFwcGx5IG5ldyByb290IG5vZGUgb25jZSB0byBvZyBCZWFjb25TdGF0ZVxuICogLSBIb3dldmVyLCBrZWVwIGFsbCB0aGUgY2FjaGVzIGFuZCB0cmFuc2ZlciB0aGVtIHRvIHRoZSBuZXcgQmVhY29uU3RhdGVcbiAqXG4gKiBRdWVzdGlvbnM6XG4gKiAtIENhbiB0aGUgY2hpbGQgdmlld3MgY3JlYXRlZCBpbiBtdXRhYmxlIG1vZGUgc3dpdGNoIHRvIG5vdCBtdXRhYmxlPyBJZiBzbywgaXQgc2VlbXMgdGhhdCBpdCBuZWVkcyB0byByZWN1cnNpdmVseVxuICogICBpdGVyYXRlIHRoZSBlbnRpcmUgZGF0YSBzdHJ1Y3R1cmUgYW5kIHZpZXdzXG4gKlxuICovXG5jbGFzcyBDb250YWluZXJUcmVlVmlldyBleHRlbmRzIGFic3RyYWN0XzEuVHJlZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHRyZWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucm9vdE5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyVHJlZVZpZXdDbGFzcyh0eXBlKSB7XG4gICAgY2xhc3MgQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXcgZXh0ZW5kcyBDb250YWluZXJUcmVlVmlldyB7XG4gICAgfVxuICAgIC8vIER5bmFtaWNhbGx5IGRlZmluZSBwcm90b3R5cGUgbWV0aG9kc1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0eXBlLmZpZWxkc0VudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGROYW1lLCBmaWVsZFR5cGUgfSA9IHR5cGUuZmllbGRzRW50cmllc1tpbmRleF07XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCB0eXBlIGlzIGJhc2ljLCB0aGUgdmFsdWUgdG8gZ2V0IGFuZCBzZXQgd2lsbCBiZSB0aGUgYWN0dWFsICdzdHJ1Y3QnIHZhbHVlIChpLmUuIGEgSlMgbnVtYmVyKS5cbiAgICAgICAgLy8gVGhlIHZpZXcgbXVzdCB1c2UgdGhlIHRyZWVfZ2V0RnJvbU5vZGUoKSBhbmQgdHJlZV9zZXRUb05vZGUoKSBtZXRob2RzIHRvIHBlcnNpc3QgdGhlIHN0cnVjdCBkYXRhIHRvIHRoZSBub2RlLFxuICAgICAgICAvLyBhbmQgdXNlIHRoZSBjYWNoZWQgdmlld3MgYXJyYXkgdG8gc3RvcmUgdGhlIG5ldyBub2RlLlxuICAgICAgICBpZiAoZmllbGRUeXBlLmlzQmFzaWMpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlldy5wcm90b3R5cGUsIGZpZWxkTmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZpZXcgdGhlIG1lbW9yeSBjb3N0IG9mIHRoaXMgY2xvc3VyZXNcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5yb290Tm9kZS52YWx1ZVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMudHJlZS5yb290Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZVZhbHVlID0gdGhpcy50eXBlLmNsb25lKG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBjaGVjayBmb3IgdmFsaWQgZmllbGQgbmFtZT8gQmVuY2htYXJrIHRoZSBjb3N0XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVWYWx1ZVtmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZS5yb290Tm9kZSA9IG5ldyBicmFuY2hOb2RlU3RydWN0XzEuQnJhbmNoTm9kZVN0cnVjdChub2RlW1widmFsdWVUb05vZGVcIl0sIG5ld05vZGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCB0eXBlIGlzIGNvbXBvc2l0ZSwgdGhlIHZhbHVlIHRvIGdldCBhbmQgc2V0IHdpbGwgYmUgYW5vdGhlciBUcmVlVmlldy4gVGhlIHBhcmVudCBUcmVlVmlldyBtdXN0XG4gICAgICAgIC8vIGNhY2hlIHRoZSB2aWV3IGl0c2VsZiB0byByZXRhaW4gdGhlIGNhY2hlcyBvZiB0aGUgY2hpbGQgdmlldy4gVG8gc2V0IGEgdmFsdWUgdGhlIHZpZXcgbXVzdCByZXR1cm4gYSBub2RlIHRvXG4gICAgICAgIC8vIHNldCBpdCB0byB0aGUgcGFyZW50IHRyZWUgaW4gdGhlIGZpZWxkIGdpbmRleC5cbiAgICAgICAgZWxzZSBpZiAoY29tcG9zaXRlXzEuaXNDb21wb3NpdGVUeXBlKGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlldy5wcm90b3R5cGUsIGZpZWxkTmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIFRyZWVWaWV3IG9mIGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLnRyZWUucm9vdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFR5cGUudG9WaWV3KHZhbHVlW2ZpZWxkTmFtZV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0cyBUcmVlVmlldyBvZiBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnRyZWUucm9vdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGVWYWx1ZSA9IHRoaXMudHlwZS5jbG9uZShub2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgY2hlY2sgZm9yIHZhbGlkIGZpZWxkIG5hbWU/IEJlbmNobWFyayB0aGUgY29zdFxuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlVmFsdWVbZmllbGROYW1lXSA9IGZpZWxkVHlwZS50b1ZhbHVlRnJvbVZpZXcodmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZS5yb290Tm9kZSA9IG5ldyBicmFuY2hOb2RlU3RydWN0XzEuQnJhbmNoTm9kZVN0cnVjdChub2RlW1widmFsdWVUb05vZGVcIl0sIG5ld05vZGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHVucmVhY2hhYmxlIGNvZGUgKi9cbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIGZpZWxkVHlwZSAke2ZpZWxkVHlwZS50eXBlTmFtZX0gZm9yIGZpZWxkTmFtZSAke2ZpZWxkTmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGFuZ2UgY2xhc3MgbmFtZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21Db250YWluZXJUcmVlVmlldywgXCJuYW1lXCIsIHsgdmFsdWU6IHR5cGUudHlwZU5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gQ3VzdG9tQ29udGFpbmVyVHJlZVZpZXc7XG59XG5leHBvcnRzLmdldENvbnRhaW5lclRyZWVWaWV3Q2xhc3MgPSBnZXRDb250YWluZXJUcmVlVmlld0NsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbmVyTm9kZVN0cnVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdEJhc2ljVHJlZVZpZXcgPSB2b2lkIDA7XG5jb25zdCBwZXJzaXN0ZW50X21lcmtsZV90cmVlXzEgPSByZXF1aXJlKFwiQGNoYWluc2FmZS9wZXJzaXN0ZW50LW1lcmtsZS10cmVlXCIpO1xuY29uc3QgYXJyYXlCYXNpY18xID0gcmVxdWlyZShcIi4vYXJyYXlCYXNpY1wiKTtcbmNsYXNzIExpc3RCYXNpY1RyZWVWaWV3IGV4dGVuZHMgYXJyYXlCYXNpY18xLkFycmF5QmFzaWNUcmVlVmlldyB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdHJlZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0cmVlKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgdmFsdWUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhbmQgYWRkcyAxIHRvIHRoZSBjdXJyZW50IFRyZWUgbGVuZ3RoLlxuICAgICAqL1xuICAgIHB1c2godmFsdWUpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPj0gdGhpcy50eXBlLmxpbWl0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkVycm9yIHB1c2hpbmcgb3ZlciBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUudHJlZV9zZXRMZW5ndGgodGhpcy50cmVlLCBsZW5ndGggKyAxKTtcbiAgICAgICAgLy8gSWYgaW4gbmV3IG5vZGUuLlxuICAgICAgICBpZiAobGVuZ3RoICUgdGhpcy50eXBlLml0ZW1zUGVyQ2h1bmsgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE9wdGltaXplOiBUaGlzIGBpbk5ld05vZGVgIGNvdWxkIGJlIG9tbWl0dGVkIGJ1dCBpdCB3b3VsZCBjYXVzZSBhIGZ1bGwgbmF2aWdhdGlvbiBpbiAuc2V0KClcbiAgICAgICAgICAgIC8vIEJlbmNobWFyayB0aGUgY29zdCBvZiB0aGF0IG5hdmlnYXRpb24gdnMgdGhlIGV4dHJhIG1hdGggaGVyZVxuICAgICAgICAgICAgLy8gVE9ETzogT3B0aW1pemU6IHByZXZlbnQgZG91YmxlIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICBjb25zdCBsZWFmTm9kZSA9IHBlcnNpc3RlbnRfbWVya2xlX3RyZWVfMS5MZWFmTm9kZS5mcm9tWmVybygpO1xuICAgICAgICAgICAgdGhpcy50eXBlLmVsZW1lbnRUeXBlLnRyZWVfc2V0VG9QYWNrZWROb2RlKGxlYWZOb2RlLCBsZW5ndGgsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIENvbW1pdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgY29uc3QgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gdGhpcy50eXBlLml0ZW1zUGVyQ2h1bmspO1xuICAgICAgICAgICAgdGhpcy50cmVlLnNldE5vZGVBdERlcHRoKHRoaXMudHlwZS5kZXB0aCwgY2h1bmtJbmRleCwgbGVhZk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmUtdXNlIC5zZXQoKSBzaW5jZSBubyBuZXcgbm9kZSBpcyBhZGRlZFxuICAgICAgICAgICAgdGhpcy5zZXQobGVuZ3RoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpc3RCYXNpY1RyZWVWaWV3ID0gTGlzdEJhc2ljVHJlZVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0QmFzaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpc3RDb21wb3NpdGVUcmVlVmlldyA9IHZvaWQgMDtcbmNvbnN0IGFycmF5Q29tcG9zaXRlXzEgPSByZXF1aXJlKFwiLi9hcnJheUNvbXBvc2l0ZVwiKTtcbmNsYXNzIExpc3RDb21wb3NpdGVUcmVlVmlldyBleHRlbmRzIGFycmF5Q29tcG9zaXRlXzEuQXJyYXlDb21wb3NpdGVUcmVlVmlldyB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdHJlZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0cmVlKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgdmlldyBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFuZCBhZGRzIDEgdG8gdGhlIGN1cnJlbnQgVHJlZSBsZW5ndGguXG4gICAgICovXG4gICAgcHVzaCh2aWV3KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID49IHRoaXMudHlwZS5saW1pdCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvciBwdXNoaW5nIG92ZXIgbGltaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlLnRyZWVfc2V0TGVuZ3RoKHRoaXMudHJlZSwgbGVuZ3RoICsgMSk7XG4gICAgICAgIC8vIE5vIG5lZWQgZm9yIHByZS1pbml0aWFsaXphdGlvbiBsaWtlIGluIExpc3RCYXNpYy5wdXNoIHNpbmNlIEFycmF5Q29tcG9zaXRlVHJlZVZpZXcuc2V0KCkgZG9lc24ndCBkbyBhIGdldCBub2RlXG4gICAgICAgIHRoaXMuc2V0KGxlbmd0aCwgdmlldyk7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0Q29tcG9zaXRlVHJlZVZpZXcgPSBMaXN0Q29tcG9zaXRlVHJlZVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0Q29tcG9zaXRlLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJnb2VybGlcIixcbiAgICBcImNoYWluSWRcIjogNSxcbiAgICBcIm5ldHdvcmtJZFwiOiA1LFxuICAgIFwiZGVmYXVsdEhhcmRmb3JrXCI6IFwibWVyZ2VcIixcbiAgICBcImNvbnNlbnN1c1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInBvYVwiLFxuICAgICAgICBcImFsZ29yaXRobVwiOiBcImNsaXF1ZVwiLFxuICAgICAgICBcImNsaXF1ZVwiOiB7XG4gICAgICAgICAgICBcInBlcmlvZFwiOiAxNSxcbiAgICAgICAgICAgIFwiZXBvY2hcIjogMzAwMDBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJjb21tZW50XCI6IFwiQ3Jvc3MtY2xpZW50IFBvQSB0ZXN0IG5ldHdvcmtcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9nb2VybGkvdGVzdG5ldFwiLFxuICAgIFwiZ2VuZXNpc1wiOiB7XG4gICAgICAgIFwidGltZXN0YW1wXCI6IFwiMHg1YzUxYTYwN1wiLFxuICAgICAgICBcImdhc0xpbWl0XCI6IDEwNDg1NzYwLFxuICAgICAgICBcImRpZmZpY3VsdHlcIjogMSxcbiAgICAgICAgXCJub25jZVwiOiBcIjB4MDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcImV4dHJhRGF0YVwiOiBcIjB4MjI0NjZjNjU3ODY5MjA2OTczMjA2MTIwNzQ2ODY5NmU2NzIyMjAyZDIwNDE2NjcyNjkwMDAwMDAwMDAwMDAwMGUwYTJiZDQyNThkMjc2ODgzN2JhYTI2YTI4ZmU3MWRjMDc5Zjg0YzcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICB9LFxuICAgIFwiaGFyZGZvcmtzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTNmNWFiMDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJob21lc3RlYWRcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGEzZjVhYjA4XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidGFuZ2VyaW5lV2hpc3RsZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTNmNWFiMDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzcHVyaW91c0RyYWdvblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTNmNWFiMDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJieXphbnRpdW1cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGEzZjVhYjA4XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uc3RhbnRpbm9wbGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGEzZjVhYjA4XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGV0ZXJzYnVyZ1wiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTNmNWFiMDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpc3RhbmJ1bFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAxNTYxNjUxLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YzI1ZWZhNWNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiZXJsaW5cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogNDQ2MDY0NCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDc1N2ExYzQ3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9uZG9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDUwNjI2MDUsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhiOGM2Mjk5ZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiLy9fY29tbWVudFwiOiBcIlRoZSBmb3JrSGFzaCB3aWxsIHJlbWFpbiBzYW1lIGFzIG1lcmdlRm9ya0lkVHJhbnNpdGlvbiBpcyBwb3N0IG1lcmdlLCB0ZXJtaW5hbCBibG9jazogaHR0cHM6Ly9nb2VybGkuZXRoZXJzY2FuLmlvL2Jsb2NrLzczODI4MThcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lcmdlXCIsXG4gICAgICAgICAgICBcInR0ZFwiOiBcIjEwNzkwMDAwXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDczODI4MTksXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhiOGM2Mjk5ZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lcmdlRm9ya0lkVHJhbnNpdGlvblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiBudWxsLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNoYW5naGFpXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IG51bGxcbiAgICAgICAgfVxuICAgIF0sXG4gICAgXCJib290c3RyYXBOb2Rlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCI1MS4xNDEuNzguNTNcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCIwMTFmNzU4ZTY1NTJkMTA1MTgzYjE3NjFjNWUyZGVhMDExMWJjMjBmZDVmNjQyMmJjN2Y5MWUwZmFiYmVjOWE2NTk1Y2FmNjIzOWIzN2ZlYjc3M2RkZGQzZjg3MjQwZDk5ZDg1OTQzMTg5MWU0YTY0MmNmMmEwYTllNmNiYjk4YVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiVXBzdHJlYW0gYm9vdG5vZGUgMVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxMy45My41NC4xMzdcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCIxNzZiOTQxN2Y1MTFkMDViNmIyY2YzZTM0Yjc1NmNmMGE3MDk2YjMwOTQ1NzJhOGY2ZWY0Y2RjYjlkMWY5ZDAwNjgzYmYwZjgzMzQ3ZWViZGYzYjgxYzM1MjFjMjMzMjA4NmQ5NTkyODAyMjMwYmY1MjhlYWY2MDZhMWQ5Njc3YlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiVXBzdHJlYW0gYm9vdG5vZGUgMlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCI5NC4yMzcuNTQuMTE0XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMTMsXG4gICAgICAgICAgICBcImlkXCI6IFwiNDZhZGQ0NGI5ZjEzOTY1ZjdiOTg3NWFjNmI4NWYwMTZmMzQxMDEyZDg0Zjk3NTM3NzU3MzgwMGE4NjM1MjZmNGRhMTlhZTJjNjIwZWM3M2QxMTU5MWZhOTUxMGU5OTJlY2MwM2FkMDc1MWY1M2NjMDJmN2M3ZWQ2ZDU1YzcyOTFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIlVwc3RyZWFtIGJvb3Rub2RlIDNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiMTguMjE4LjI1MC42NlwiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzEzLFxuICAgICAgICAgICAgXCJpZFwiOiBcImI1OTQ4YTJkM2U5ZDQ4NmM0ZDc1YmYzMjcxMzIyMWMyYmQ2Y2Y4NjQ2MzMwMjMzOTI5OWJkMjI3ZGMyZTI3NmNkNWExYzdjYTRmNDNhMGU5MTIyZmU5YWY4ODRlZmVkNTYzYmQyYTFmZDI4NjYxZjNiNWY1YWQ3YmYxZGU1OTQ5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJVcHN0cmVhbSBib290bm9kZSA0XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjMuMTEuMTQ3LjY3XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiYTYxMjE1NjQxZmI4NzE0YTM3M2M4MGVkYmZhMGVhODg3ODI0MzE5M2Y1N2M5NmVlYjQ0ZDBiYzAxOWVmMjk1YWJkNGUwNDRmZDYxOWJmYzRjNTk3MzFhNzNmYjc5YWZlODRlOWFiNmRhMGM3NDNjZWI0NzljYmI2ZDI2M2ZhOTFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkV0aGVyZXVtIEZvdW5kYXRpb24gYm9vdG5vZGVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTEuMTUuMTE2LjIyNlwiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcImE4NjliMDJjZWMxNjcyMTFmYjQ4MTVhODI5NDFkYjJlN2VkMjkzNmZkOTBlNzg2MTljNTNlYjE3NzUzZmNmMDIwNzQ2M2UzNDE5YzI2NGUyYTFkZDg3ODZkZTBkZjdlNjhjZjk5NTcxYWI4YWViN2M0ZTUxMzY3ZWYxODZiMWRkXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJHb2VybGkgSW5pdGlhdGl2ZSBib290bm9kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCI1MS4xNS4xMTkuMTU3XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiODA3YjM3ZWU0ODE2ZWNmNDA3ZTkxMTIyMjQ0OTRiNzRkZDU5MzM2MjVmNjU1OTYyZDg5MmYyZjBmMDJkN2ZiYmIzZTJhOTRjZjg3YTk2NjA5NTI2ZjMwYzk5OGZkNzFlOTNlMmY1MzAxNWM1NThmZmM4YjAzZWNlYWYzMGVlMzNcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkdvZXJsaSBJbml0aWF0aXZlIGJvb3Rub2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUxLjE1LjExOS4xNTdcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiA0MDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCJhNTllMzNjY2QyYjNlNTJkNTc4ZjFmYmQ3MGM2ZjliYWJkYTI2NTBmMDc2MGQ2ZmYzYjM3NzQyZmRjZGZkYjNkZWZiYTVkNTZkMzE1YjQwYzQ2YjcwMTk4Yzc2MjFlNjNmZmEzZjk4NzM4OWM3MTE4NjM0YjBmZWZiYmRmYTdmZFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiR29lcmxpIEluaXRpYXRpdmUgYm9vdG5vZGVcIlxuICAgICAgICB9XG4gICAgXSxcbiAgICBcImRuc05ldHdvcmtzXCI6IFtcbiAgICAgICAgXCJlbnJ0cmVlOi8vQUtBM0FNNkxQQllFVURNVk5VM0JTVlFKNUFENDVZN1lQT0hKTEVGNlcyNlFPRTRWVFVEUEVAYWxsLmdvZXJsaS5ldGhkaXNjby5uZXRcIlxuICAgIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJtYWlubmV0XCIsXG4gICAgXCJjaGFpbklkXCI6IDEsXG4gICAgXCJuZXR3b3JrSWRcIjogMSxcbiAgICBcImRlZmF1bHRIYXJkZm9ya1wiOiBcIm1lcmdlXCIsXG4gICAgXCJjb25zZW5zdXNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJwb3dcIixcbiAgICAgICAgXCJhbGdvcml0aG1cIjogXCJldGhhc2hcIixcbiAgICAgICAgXCJldGhhc2hcIjoge31cbiAgICB9LFxuICAgIFwiY29tbWVudFwiOiBcIlRoZSBFdGhlcmV1bSBtYWluIGNoYWluXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2V0aHN0YXRzLm5ldC9cIixcbiAgICBcImdlbmVzaXNcIjoge1xuICAgICAgICBcImdhc0xpbWl0XCI6IDUwMDAsXG4gICAgICAgIFwiZGlmZmljdWx0eVwiOiAxNzE3OTg2OTE4NCxcbiAgICAgICAgXCJub25jZVwiOiBcIjB4MDAwMDAwMDAwMDAwMDA0MlwiLFxuICAgICAgICBcImV4dHJhRGF0YVwiOiBcIjB4MTFiYmU4ZGI0ZTM0N2I0ZThjOTM3YzFjODM3MGU0YjVlZDMzYWRiM2RiNjljYmRiN2EzOGUxZTUwYjFiODJmYVwiXG4gICAgfSxcbiAgICBcImhhcmRmb3Jrc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNoYWluc3RhcnRcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZjNjRlYzA0XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaG9tZXN0ZWFkXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDExNTAwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg5N2MyYzM0Y1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImRhb1wiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAxOTIwMDAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4OTFkMWY5NDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0YW5nZXJpbmVXaGlzdGxlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDI0NjMwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg3YTY0ZGExM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNwdXJpb3VzRHJhZ29uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDI2NzUwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHgzZWRkNWIxMFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImJ5emFudGl1bVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA0MzcwMDAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTAwYmMzMjRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb25zdGFudGlub3BsZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA3MjgwMDAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NjY4ZGIwYWZcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwZXRlcnNidXJnXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDcyODAwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg2NjhkYjBhZlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImlzdGFuYnVsXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDkwNjkwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg4NzlkNmUzMFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm11aXJHbGFjaWVyXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDkyMDAwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhlMDI5ZTk5MVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImJlcmxpblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAxMjI0NDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDBlYjQ0MGY2XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9uZG9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDEyOTY1MDAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YjcxNTA3N2RcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJhcnJvd0dsYWNpZXJcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTM3NzMwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHgyMGMzMjdmY1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImdyYXlHbGFjaWVyXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDE1MDUwMDAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4ZjBhZmQwZTNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIi8vX2NvbW1lbnRcIjogXCJUaGUgZm9ya0hhc2ggd2lsbCByZW1haW4gc2FtZSBhcyBtZXJnZUZvcmtJZFRyYW5zaXRpb24gaXMgcG9zdCBtZXJnZSwgdGVybWluYWwgYmxvY2s6IGh0dHBzOi8vZXRoZXJzY2FuLmlvL2Jsb2NrLzE1NTM3MzkzXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZXJnZVwiLFxuICAgICAgICAgICAgXCJ0dGRcIjogXCI1ODc1MDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAxNTUzNzM5NCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGYwYWZkMGUzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2hhbmdoYWlcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogbnVsbFxuICAgICAgICB9XG4gICAgXSxcbiAgICBcImJvb3RzdHJhcE5vZGVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjE4LjEzOC4xMDguNjdcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCJkODYwYTAxZjk3MjJkNzgwNTE2MTlkMWUyMzUxYWJhM2Y0M2Y5NDNmNmYwMDcxOGQxYjliYWE0MTAxOTMyYTFmNTAxMWYxNmJiMmIxYmIzNWRiMjBkNmZlMjhmYTBiZjA5NjM2ZDI2YTg3ZDMxZGU5ZWM2MjAzZWVlZGIxZjY2NlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImFwLXNvdXRoZWFzdC0xLTAwMVwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiYm9vdG5vZGUtYXdzLWFwLXNvdXRoZWFzdC0xLTAwMVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIzLjIwOS40NS43OVwiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjIyYTgyMzJjM2FiYzc2YTE2YWU5ZDZjM2IxNjRmOTg3NzVmZTIyNmYwOTE3YjBjYTg3MTEyOGE3NGE4ZTk2MzBiNDU4NDYwODY1YmFiNDU3MjIxZjFkNDQ4ZGQ5NzkxZDI0YzRlNWQ4ODc4NjE4MGFjMTg1ZGY4MTNhNjhkNGRlXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXMtZWFzdC0xLTAwMVwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiYm9vdG5vZGUtYXdzLXVzLWVhc3QtMS0wMDFcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiMzQuMjU1LjIzLjExM1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcImNhNmRlNjJmY2UyNzhmOTZhZWE2ZWM1YTJkYWFkYjg3N2U1MTY1MTI0N2NiOTZlZTMxMGEzMThkZWY0NjI5MTNiNjUzOTYzYzE1NWEwZWY2YzdkNTAwNDhiYmE2ZTZjZWE4ODExMzA4NTc0MTNkOWY1MGE2MjE1NDZiNTkwNzU4XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiZXUtd2VzdC0xLTAwMVwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiYm9vdG5vZGUtYXdzLWV1LXdlc3QtMS0wMDFcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiMzUuMTU4LjI0NC4xNTFcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCIyNzk5NDRkOGRjZDQyOGRmZmFhNzQzNmYyNWNhMGNhNDNhZTE5ZTdiY2Y5NGE4ZmI3ZDE2NDE2NTFmOTJkMTIxZTk3MmFjMmU4ZjM4MTQxNGI4MGNjOGU1NTU1ODExYzJlYzZlMWE5OWJiMDA5YjNmNTNjNGM2OTkyM2UxMWJkOFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImV1LWNlbnRyYWwtMS0wMDFcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcImJvb3Rub2RlLWF3cy1ldS1jZW50cmFsLTEtMDAxXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUyLjE4Ny4yMDcuMjdcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCI4NDk5ZGEwM2M0N2Q2MzdiMjBlZWUyNGVlYzNjMzU2YzlhMmU2MTQ4ZDZmZTI1Y2ExOTVjNzk0OWFiOGVjMmMwM2UzNTU2MTI2YjBkN2VkNjQ0Njc1ZTc4YzQzMThiMDg2OTFiN2I1N2RlMTBlNWYwZDQwZDA1YjA5MjM4ZmEwYVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImF1c3RyYWxpYWVhc3QtMDAxXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJib290bm9kZS1henVyZS1hdXN0cmFsaWFlYXN0LTAwMVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxOTEuMjM0LjE2Mi4xOThcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCIxMDM4NThiZGI4ODc1NmM3MWYxNWU5YjVlMDliNTZkYzFiZTUyZjBhNTAyMWQ0NjMwMWRiYmZiN2UxMzAwMjljYzlkMGQ2ZjczZjY5M2JjMjliNjY1NzcwZmZmN2RhNGQzNGYzYzYzNzlmZTEyNzIxYjVkN2EwYmNiNWNhMWZjMVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImJyYXppbHNvdXRoLTAwMVwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiYm9vdG5vZGUtYXp1cmUtYnJhemlsc291dGgtMDAxXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUyLjIzMS4xNjUuMTA4XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiNzE1MTcxZjUwNTA4YWJhODhhZWNkMTI1MGFmMzkyYTQ1YTMzMGFmOTFkN2I5MDcwMWM0MzZiNjE4Yzg2YWFhMTU4OWM5MTg0NTYxOTA3YmViYmI1NjQzOWI4Zjg3ODdiYzAxZjQ5YTdjNzcyNzZjNThjMWIwOTgyMmQ3NWU4ZThcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJrb3JlYXNvdXRoLTAwMVwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiYm9vdG5vZGUtYXp1cmUta29yZWFzb3V0aC0wMDFcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiMTA0LjQyLjIxNy4yNVwiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjVkNmQ3Y2QyMGQ2ZGE0YmI4M2ExZDI4Y2FkYjVkNDA5YjY0ZWRmMzE0YzAzMzVkZjY1OGMxYTU0ZTMyYzdjNGE3YWI3ODIzZDU3YzM5YjZhNzU3NTU2ZTY4ZmYxZGYxN2M3NDhiNjk4NTQ0YTU1Y2I0ODhiNTI0NzlhOTJiNjBmXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwid2VzdHVzLTAwMVwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiYm9vdG5vZGUtYXp1cmUtd2VzdHVzLTAwMVwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZG5zTmV0d29ya3NcIjogW1xuICAgICAgICBcImVucnRyZWU6Ly9BS0EzQU02TFBCWUVVRE1WTlUzQlNWUUo1QUQ0NVk3WVBPSEpMRUY2VzI2UU9FNFZUVURQRUBhbGwubWFpbm5ldC5ldGhkaXNjby5uZXRcIlxuICAgIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJyaW5rZWJ5XCIsXG4gICAgXCJjaGFpbklkXCI6IDQsXG4gICAgXCJuZXR3b3JrSWRcIjogNCxcbiAgICBcImRlZmF1bHRIYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwiY29uc2Vuc3VzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwicG9hXCIsXG4gICAgICAgIFwiYWxnb3JpdGhtXCI6IFwiY2xpcXVlXCIsXG4gICAgICAgIFwiY2xpcXVlXCI6IHtcbiAgICAgICAgICAgIFwicGVyaW9kXCI6IDE1LFxuICAgICAgICAgICAgXCJlcG9jaFwiOiAzMDAwMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImNvbW1lbnRcIjogXCJQb0EgdGVzdCBuZXR3b3JrXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL3d3dy5yaW5rZWJ5LmlvXCIsXG4gICAgXCJnZW5lc2lzXCI6IHtcbiAgICAgICAgXCJ0aW1lc3RhbXBcIjogXCIweDU4ZWU0MGJhXCIsXG4gICAgICAgIFwiZ2FzTGltaXRcIjogNDcwMDAwMCxcbiAgICAgICAgXCJkaWZmaWN1bHR5XCI6IDEsXG4gICAgICAgIFwibm9uY2VcIjogXCIweDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCJleHRyYURhdGFcIjogXCIweDUyNjU3MzcwNjU2Mzc0MjA2ZDc5MjA2MTc1NzQ2ODZmNzI2OTc0NjE2ODIwN2U0NTJlNDM2MTcyNzQ2ZDYxNmU0MmViNzY4ZjIyNDRjODgxMWM2MzcyOWEyMWEzNTY5NzMxNTM1ZjA2N2ZmYzU3ODM5YjAwMjA2ZDFhZDIwYzY5YTE5ODFiNDg5Zjc3MjAzMWIyNzkxODJkOTllNjU3MDNmMDA3NmU0ODEyNjUzYWFiODVmY2EwZjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICB9LFxuICAgIFwiaGFyZGZvcmtzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4M2I4ZTA2OTFcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJob21lc3RlYWRcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDYwOTQ5Mjk1XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidGFuZ2VyaW5lV2hpc3RsZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAyLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4OGJkZTQwZGRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzcHVyaW91c0RyYWdvblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAzLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4Y2IzYTY0YmJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJieXphbnRpdW1cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTAzNTMwMSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDhkNzQ4YjU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uc3RhbnRpbm9wbGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMzY2MDY2MyxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGU0OWNhYjE0XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGV0ZXJzYnVyZ1wiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA0MzIxMjM0LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YWZlYzZiMjdcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpc3RhbmJ1bFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA1NDM1MzQ1LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4Y2JkYjg4MzhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiZXJsaW5cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogODI5MDkyOCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDY5MTBjOGJkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9uZG9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDg4OTc5ODgsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg4ZTI5ZjJmM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lcmdlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2hhbmdoYWlcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogbnVsbFxuICAgICAgICB9XG4gICAgXSxcbiAgICBcImJvb3RzdHJhcE5vZGVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUyLjE2OS40Mi4xMDFcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCJhMjRhYzdjNTQ4NGVmNGVkMGM1ZWIyZDM2NjIwYmE0ZTRhYTEzYjhjODQ2ODRlMWI0YWFiMGNlYmVhMmFlNDVjYjRkMzc1Yjc3ZWFiNTY1MTZkMzRiZmJkM2MxYTgzM2ZjNTEyOTZmZjA4NGI3NzBiOTRmYjkwMjhjNGQyNWNjZlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiSUVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMy4xNTguMTg0XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiMzQzMTQ5ZTRmZWVmYTE1ZDg4MmQ5ZmU0YWM3ZDg4Zjg4NWJkMDVlYmI3MzVlNTQ3ZjEyZTEyMDgwYTlmYTA3YzgwMTRjYTZmZDdmMzczMTIzNDg4MTAyZmU1ZTM0MTExZjg1MDljZjBiN2RlM2Y1YjQ0MzM5YzlmMjVlODdjYjhcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIklORlVSQVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxNTkuODkuMjguMjExXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiYjZiMjg4OTBiMDA2NzQzNjgwYzUyZTY0ZTBkMTZkYjU3ZjI4MTI0ODg1NTk1ZmEwM2E1NjJiZTFkMmJmMGYzYTFkYTI5N2Q1NmIxM2RhMjVmYjk5Mjg4OGZkNTU2ZDRjMWEyN2IxZjM5ZDUzMWJkZTdkZTE5MjFjOTAwNjFjYzZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkFLQVNIQVwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZG5zTmV0d29ya3NcIjogW1xuICAgICAgICBcImVucnRyZWU6Ly9BS0EzQU02TFBCWUVVRE1WTlUzQlNWUUo1QUQ0NVk3WVBPSEpMRUY2VzI2UU9FNFZUVURQRUBhbGwucmlua2VieS5ldGhkaXNjby5uZXRcIlxuICAgIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJyb3BzdGVuXCIsXG4gICAgXCJjaGFpbklkXCI6IDMsXG4gICAgXCJuZXR3b3JrSWRcIjogMyxcbiAgICBcImRlZmF1bHRIYXJkZm9ya1wiOiBcIm1lcmdlXCIsXG4gICAgXCJjb25zZW5zdXNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJwb3dcIixcbiAgICAgICAgXCJhbGdvcml0aG1cIjogXCJldGhhc2hcIixcbiAgICAgICAgXCJldGhhc2hcIjoge31cbiAgICB9LFxuICAgIFwiY29tbWVudFwiOiBcIlBvVyB0ZXN0IG5ldHdvcmtcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9yb3BzdGVuXCIsXG4gICAgXCJnZW5lc2lzXCI6IHtcbiAgICAgICAgXCJnYXNMaW1pdFwiOiAxNjc3NzIxNixcbiAgICAgICAgXCJkaWZmaWN1bHR5XCI6IDEwNDg1NzYsXG4gICAgICAgIFwibm9uY2VcIjogXCIweDAwMDAwMDAwMDAwMDAwNDJcIixcbiAgICAgICAgXCJleHRyYURhdGFcIjogXCIweDM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzVcIlxuICAgIH0sXG4gICAgXCJoYXJkZm9ya3NcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHgzMGM3ZGRiY1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImhvbWVzdGVhZFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4MzBjN2RkYmNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0YW5nZXJpbmVXaGlzdGxlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHgzMGM3ZGRiY1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNwdXJpb3VzRHJhZ29uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDEwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NjM3NjAxOTBcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJieXphbnRpdW1cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTcwMDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDNlYTE1OWM3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uc3RhbnRpbm9wbGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogNDIzMDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDk3YjU0NGYzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGV0ZXJzYnVyZ1wiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA0OTM5Mzk0LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4ZDZlMjE0OWJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpc3RhbmJ1bFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA2NDg1ODQ2LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NGJjNjYzOTZcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtdWlyR2xhY2llclwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA3MTE3MTE3LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NjcyN2VmOTBcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiZXJsaW5cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogOTgxMjE4OSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGExNTdkMzc3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9uZG9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDEwNDk5NDAxLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NzExOWI2YjNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIi8vX2NvbW1lbnRcIjogXCJUaGUgZm9ya0hhc2ggd2lsbCByZW1haW4gc2FtZSBhcyBtZXJnZUZvcmtJZFRyYW5zaXRpb24gaXMgcG9zdCBtZXJnZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VcIixcbiAgICAgICAgICAgIFwidHRkXCI6IFwiNTAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDcxMTliNmIzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2hhbmdoYWlcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogbnVsbFxuICAgICAgICB9XG4gICAgXSxcbiAgICBcImJvb3RzdHJhcE5vZGVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUyLjE3Ni43LjEwXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiMzBiN2FiMzBhMDFjMTI0YTZjY2VjYTM2ODYzZWNlMTJjNGY1ZmE2OGUzYmE5YjBiNTE0MDdjY2MwMDJlZWVkM2IzMTAyZDIwYTg4ZjFjMWQzYzMxNTRlMjQ0OTMxN2I4ZWY5NTA5MGU3N2IzMTJkNWNjMzkzNTRmODZkNWQ2MDZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIlVTLUF6dXJlIGdldGhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMTc2LjEwMC43N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjg2NWE2MzI1NWIzYmI2ODAyM2I2YmZmZDUwOTUxMThmY2MxM2U3OWRjZjAxNGZlNGU0N2UwNjVjMzUwYzdjYzcyYWYyZTUzZWZmODk1ZjExYmExYmJiNmEyYjMzMjcxYzExMTZlZTg3MGYyNjY2MThlYWRmYzJlNzhhYTczNDljXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJVUy1BenVyZSBwYXJpdHlcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMjMyLjI0My4xNTJcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCI2MzMyNzkyYzRhMDBlM2U0ZWUwOTI2ZWQ4OWUwZDI3ZWY5ODU0MjRkOTdiNmE0NWJmMGYyM2U1MWYwZGNiNWU2NmI4NzU3Nzc1MDY0NThhZWE3YWY2ZjllNGZmYjY5ZjQzZjM3NzhlZTczYzgxZWQ5ZDM0YzUxYzRiMTZiMGIwZlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiUGFyaXR5XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjE5Mi44MS4yMDguMjIzXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiOTRjMTVkMWI5ZTJmZTdjZTU2ZTQ1OGI5YTNiNjcyZWYxMTg5NGRkZWRkMGM2ZjI0N2UwZjFkMzQ4N2Y1MmI2NjIwOGZiNGFlYjgxNzlmY2U2ZTNhNzQ5ZWE5M2VkMTQ3YzM3OTc2ZDY3YWY1NTc1MDhkMTk5ZDk1OTRjMzVmMDlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkBncGlwXCJcbiAgICAgICAgfVxuICAgIF0sXG4gICAgXCJkbnNOZXR3b3Jrc1wiOiBbXG4gICAgICAgIFwiZW5ydHJlZTovL0FLQTNBTTZMUEJZRVVETVZOVTNCU1ZRSjVBRDQ1WTdZUE9ISkxFRjZXMjZRT0U0VlRVRFBFQGFsbC5yb3BzdGVuLmV0aGRpc2NvLm5ldFwiXG4gICAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInNlcG9saWFcIixcbiAgICBcImNoYWluSWRcIjogMTExNTUxMTEsXG4gICAgXCJuZXR3b3JrSWRcIjogMTExNTUxMTEsXG4gICAgXCJkZWZhdWx0SGFyZGZvcmtcIjogXCJtZXJnZVwiLFxuICAgIFwiY29uc2Vuc3VzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwicG93XCIsXG4gICAgICAgIFwiYWxnb3JpdGhtXCI6IFwiZXRoYXNoXCIsXG4gICAgICAgIFwiZXRoYXNoXCI6IHt9XG4gICAgfSxcbiAgICBcImNvbW1lbnRcIjogXCJQb1cgdGVzdCBuZXR3b3JrIHRvIHJlcGxhY2UgUm9wc3RlblwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL3B1bGwvMjM3MzBcIixcbiAgICBcImdlbmVzaXNcIjoge1xuICAgICAgICBcInRpbWVzdGFtcFwiOiBcIjB4NjE1OWFmMTlcIixcbiAgICAgICAgXCJnYXNMaW1pdFwiOiAzMDAwMDAwMCxcbiAgICAgICAgXCJkaWZmaWN1bHR5XCI6IDEzMTA3MixcbiAgICAgICAgXCJub25jZVwiOiBcIjB4MDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcImV4dHJhRGF0YVwiOiBcIjB4NTM2NTcwNmY2YzY5NjEyYzIwNDE3NDY4NjU2ZTczMmMyMDQxNzQ3NDY5NjM2MTJjMjA0NzcyNjU2NTYzNjUyMVwiXG4gICAgfSxcbiAgICBcImhhcmRmb3Jrc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNoYWluc3RhcnRcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaG9tZXN0ZWFkXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRhbmdlcmluZVdoaXN0bGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3B1cmlvdXNEcmFnb25cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYnl6YW50aXVtXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnN0YW50aW5vcGxlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBldGVyc2J1cmdcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaXN0YW5idWxcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibXVpckdsYWNpZXJcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYmVybGluXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxvbmRvblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4ZmUzMzY2ZTdcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIi8vX2NvbW1lbnRcIjogXCJUaGUgZm9ya0hhc2ggd2lsbCByZW1haW4gc2FtZSBhcyBtZXJnZUZvcmtJZFRyYW5zaXRpb24gaXMgcG9zdCBtZXJnZSwgdGVybWluYWwgYmxvY2s6IGh0dHBzOi8vc2Vwb2xpYS5ldGhlcnNjYW4uaW8vYmxvY2svMTQ1MDQwOFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VcIixcbiAgICAgICAgICAgIFwidHRkXCI6IFwiMTcwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTQ1MDQwOSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDE3MzUzNzEsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhiOTZjYmQxM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNoYW5naGFpXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcInRpbWVzdGFtcFwiOiBcIjE2Nzc1NTcwODhcIixcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGY3ZjliYzA4XCJcbiAgICAgICAgfVxuICAgIF0sXG4gICAgXCJib290c3RyYXBOb2Rlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxOC4xNjguMTgyLjg2XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiOTI0NmQwMGJjOGZkMTc0MmU1YWQyNDI4YjgwZmM0ZGM0NWQ3ODYyODNlMDVlZjZlZGJkOTAwMmNiYzMzNWQ0MDk5ODQ0NDczMmZiZTkyMWNiODhlMWQyYzczZDFiMWRlNTNiYWU2YTIyMzc5OTZlOWJmZTE0Zjg3MWJhZjcwNjZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcImdldGhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMTQuMTUxLjE3N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcImVjNjZkZGNmMWE5NzQ5NTBiZDRjNzgyNzg5YTdlMDRmOGFhNzExMGE3MjU2OWI2ZTY1ZmNkNTFlOTM3ZTc0ZWVkMzAzYjFlYTczNGU0ZDE5Y2ZhZWM5ZmJmZjliNmVlNjViZjMxZGNiNTBiYTc5YWNjZTlkZDYzYTZhY2E2MWM3XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJiZXN1XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjE2NS4yMi4xOTYuMTczXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiY2U5NzBhZDJlOWRhYTllMTQ1OTNkZTg0YThiNDlkYTNkNTRjY2ZkZjgzY2JjNGZlNTE5Y2I4YjM2YjU5MThlZDRlYWIwODdkZWRkNGE2MjQ3OWI4ZDUwNzU2YjQ5MmQ1Zjc2MjM2N2M4ZDIwMzI5YTc4NTRlYzAxNTQ3NTY4YTZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkVGXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjY1LjEwOC45NS42N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjA3NTUwM2IxM2VkNzM2MjQ0ODk2ZWZjZGUyYTk5MmVjMGI0NTEzNTdkNDZjYjdhODEzMmMwMzg0NzIxNzQyNTk3ZmM4ZjBkOTFiYmI0MGJiNTJlN2Q2ZTY2NzI4ZDM2YTFmZGEwOTE3NjI5NGU0YTMwY2ZhYzU1ZGNjZTI2YmM2XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJsb2Rlc3RhclwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZG5zTmV0d29ya3NcIjogW1xuICAgICAgICBcImVucnRyZWU6Ly9BS0EzQU02TFBCWUVVRE1WTlUzQlNWUUo1QUQ0NVk3WVBPSEpMRUY2VzI2UU9FNFZUVURQRUBhbGwuc2Vwb2xpYS5ldGhkaXNjby5uZXRcIlxuICAgIF1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb24gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IGNyY18zMl8xID0gcmVxdWlyZShcImNyYy0zMlwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGdvZXJsaSA9IHJlcXVpcmUoXCIuL2NoYWlucy9nb2VybGkuanNvblwiKTtcbmNvbnN0IG1haW5uZXQgPSByZXF1aXJlKFwiLi9jaGFpbnMvbWFpbm5ldC5qc29uXCIpO1xuY29uc3Qgcmlua2VieSA9IHJlcXVpcmUoXCIuL2NoYWlucy9yaW5rZWJ5Lmpzb25cIik7XG5jb25zdCByb3BzdGVuID0gcmVxdWlyZShcIi4vY2hhaW5zL3JvcHN0ZW4uanNvblwiKTtcbmNvbnN0IHNlcG9saWEgPSByZXF1aXJlKFwiLi9jaGFpbnMvc2Vwb2xpYS5qc29uXCIpO1xuY29uc3QgZWlwc18xID0gcmVxdWlyZShcIi4vZWlwc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhhcmRmb3Jrc18xID0gcmVxdWlyZShcIi4vaGFyZGZvcmtzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBDb21tb24gY2xhc3MgdG8gYWNjZXNzIGNoYWluIGFuZCBoYXJkZm9yayBwYXJhbWV0ZXJzIGFuZCB0byBwcm92aWRlXG4gKiBhIHVuaWZpZWQgYW5kIHNoYXJlZCB2aWV3IG9uIHRoZSBuZXR3b3JrIGFuZCBoYXJkZm9yayBzdGF0ZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayBDb21tb24uY3VzdG9tfSBzdGF0aWMgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIHNpbXBsZVxuICogY3VzdG9tIGNoYWluIHtAbGluayBDb21tb259IG9iamVjdHMgKG1vcmUgY29tcGxldGUgY3VzdG9tIGNoYWluIHNldHVwc1xuICogY2FuIGJlIGNyZWF0ZWQgdmlhIHRoZSBtYWluIGNvbnN0cnVjdG9yIGFuZCB0aGUge0BsaW5rIENvbW1vbk9wdHMuY3VzdG9tQ2hhaW5zfSBwYXJhbWV0ZXIpLlxuICovXG5jbGFzcyBDb21tb24gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZWlwcyA9IFtdO1xuICAgICAgICB0aGlzLl9jdXN0b21DaGFpbnMgPSBvcHRzLmN1c3RvbUNoYWlucyA/PyBbXTtcbiAgICAgICAgdGhpcy5fY2hhaW5QYXJhbXMgPSB0aGlzLnNldENoYWluKG9wdHMuY2hhaW4pO1xuICAgICAgICB0aGlzLkRFRkFVTFRfSEFSREZPUksgPSB0aGlzLl9jaGFpblBhcmFtcy5kZWZhdWx0SGFyZGZvcmsgPz8gZW51bXNfMS5IYXJkZm9yay5NZXJnZTtcbiAgICAgICAgLy8gQXNzaWduIGhhcmRmb3JrIGNoYW5nZXMgaW4gdGhlIHNlcXVlbmNlIG9mIHRoZSBhcHBsaWVkIGhhcmRmb3Jrc1xuICAgICAgICB0aGlzLkhBUkRGT1JLX0NIQU5HRVMgPSB0aGlzLmhhcmRmb3JrcygpLm1hcCgoaGYpID0+IFtcbiAgICAgICAgICAgIGhmLm5hbWUsXG4gICAgICAgICAgICBoYXJkZm9ya3NfMS5oYXJkZm9ya3NbaGYubmFtZV0sXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLl9oYXJkZm9yayA9IHRoaXMuREVGQVVMVF9IQVJERk9SSztcbiAgICAgICAgaWYgKG9wdHMuaGFyZGZvcmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIYXJkZm9yayhvcHRzLmhhcmRmb3JrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5laXBzKSB7XG4gICAgICAgICAgICB0aGlzLnNldEVJUHMob3B0cy5laXBzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEge0BsaW5rIENvbW1vbn0gb2JqZWN0IGZvciBhIGN1c3RvbSBjaGFpbiwgYmFzZWQgb24gYSBzdGFuZGFyZCBvbmUuXG4gICAgICpcbiAgICAgKiBJdCB1c2VzIGFsbCB0aGUge0BsaW5rIENoYWlufSBwYXJhbWV0ZXJzIGZyb20gdGhlIHtAbGluayBiYXNlQ2hhaW59IG9wdGlvbiBleGNlcHQgdGhlIG9uZXMgb3ZlcnJpZGRlblxuICAgICAqIGluIGEgcHJvdmlkZWQge0BsaW5rIGNoYWluUGFyYW1zT3JOYW1lfSBkaWN0aW9uYXJ5LiBTb21lIHVzYWdlIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogQ29tbW9uLmN1c3RvbSh7Y2hhaW5JZDogMTIzfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSBhbHNvIHNlbGVjdGVkIHN1cHBvcnRlZCBjdXN0b20gY2hhaW5zIHdoaWNoIGNhbiBiZSBpbml0aWFsaXplZCBieSB1c2luZyBvbmUgb2YgdGhlXG4gICAgICoge0BsaW5rIEN1c3RvbUNoYWluc30gZm9yIHtAbGluayBjaGFpblBhcmFtc09yTmFtZX0sIGUuZy46XG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogQ29tbW9uLmN1c3RvbShDdXN0b21DaGFpbnMuTWF0aWNNdW1iYWkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlc2Ugc3VwcG9ydGVkIGN1c3RvbSBjaGFpbnMgb25seSBwcm92aWRlIHNvbWUgYmFzZSBwYXJhbWV0ZXJzICh1c3VhbGx5IHRoZSBjaGFpbiBhbmRcbiAgICAgKiBuZXR3b3JrIElEIGFuZCBhIG5hbWUpIGFuZCBjYW4gb25seSBiZSB1c2VkIGZvciBzZWxlY3RlZCB1c2UgY2FzZXMgKGUuZy4gc2VuZGluZyBhIHR4IHdpdGhcbiAgICAgKiB0aGUgYEBldGhlcmV1bWpzL3R4YCBsaWJyYXJ5IHRvIGEgTGF5ZXItMiBjaGFpbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5QYXJhbXNPck5hbWUgQ3VzdG9tIHBhcmFtZXRlciBkaWN0IChgbmFtZWAgd2lsbCBkZWZhdWx0IHRvIGBjdXN0b20tY2hhaW5gKSBvciBzdHJpbmcgd2l0aCBuYW1lIG9mIGEgc3VwcG9ydGVkIGN1c3RvbSBjaGFpblxuICAgICAqIEBwYXJhbSBvcHRzIEN1c3RvbSBjaGFpbiBvcHRpb25zIHRvIHNldCB0aGUge0BsaW5rIEN1c3RvbUNvbW1vbk9wdHMuYmFzZUNoYWlufSwgc2VsZWN0ZWQge0BsaW5rIEN1c3RvbUNvbW1vbk9wdHMuaGFyZGZvcmt9IGFuZCBvdGhlcnNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3VzdG9tKGNoYWluUGFyYW1zT3JOYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYmFzZUNoYWluID0gb3B0cy5iYXNlQ2hhaW4gPz8gJ21haW5uZXQnO1xuICAgICAgICBjb25zdCBzdGFuZGFyZENoYWluUGFyYW1zID0geyAuLi5Db21tb24uX2dldENoYWluUGFyYW1zKGJhc2VDaGFpbikgfTtcbiAgICAgICAgc3RhbmRhcmRDaGFpblBhcmFtc1snbmFtZSddID0gJ2N1c3RvbS1jaGFpbic7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhaW5QYXJhbXNPck5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbW1vbih7XG4gICAgICAgICAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhbmRhcmRDaGFpblBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hhaW5QYXJhbXNPck5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uUG9seWdvbk1haW5uZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGVudW1zXzEuQ3VzdG9tQ2hhaW4uUG9seWdvbk1haW5uZXQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEzNyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiAxMzcsXG4gICAgICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uUG9seWdvbk11bWJhaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZW51bXNfMS5DdXN0b21DaGFpbi5Qb2x5Z29uTXVtYmFpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiA4MDAwMSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiA4MDAwMSxcbiAgICAgICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpblBhcmFtc09yTmFtZSA9PT0gZW51bXNfMS5DdXN0b21DaGFpbi5BcmJpdHJ1bVJpbmtlYnlUZXN0bmV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbnVtc18xLkN1c3RvbUNoYWluLkFyYml0cnVtUmlua2VieVRlc3RuZXQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDQyMTYxMSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiA0MjE2MTEsXG4gICAgICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uQXJiaXRydW1PbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGVudW1zXzEuQ3VzdG9tQ2hhaW4uQXJiaXRydW1PbmUsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDQyMTYxLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IDQyMTYxLFxuICAgICAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluUGFyYW1zT3JOYW1lID09PSBlbnVtc18xLkN1c3RvbUNoYWluLnhEYWlDaGFpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZW51bXNfMS5DdXN0b21DaGFpbi54RGFpQ2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiAxMDAsXG4gICAgICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uT3B0aW1pc3RpY0tvdmFuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbnVtc18xLkN1c3RvbUNoYWluLk9wdGltaXN0aWNLb3ZhbixcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogNjksXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtJZDogNjksXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pc20gaGFzIG5vdCBpbXBsZW1lbnRlZCB0aGUgTG9uZG9uIGhhcmRmb3JrIHlldCAodGFyZ2V0aW5nIFExLjIyKVxuICAgICAgICAgICAgICAgIHsgaGFyZGZvcms6IGVudW1zXzEuSGFyZGZvcmsuQmVybGluLCAuLi5vcHRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluUGFyYW1zT3JOYW1lID09PSBlbnVtc18xLkN1c3RvbUNoYWluLk9wdGltaXN0aWNFdGhlcmV1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZW51bXNfMS5DdXN0b21DaGFpbi5PcHRpbWlzdGljRXRoZXJldW0sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEwLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IDEwLFxuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXNtIGhhcyBub3QgaW1wbGVtZW50ZWQgdGhlIExvbmRvbiBoYXJkZm9yayB5ZXQgKHRhcmdldGluZyBRMS4yMilcbiAgICAgICAgICAgICAgICB7IGhhcmRmb3JrOiBlbnVtc18xLkhhcmRmb3JrLkJlcmxpbiwgLi4ub3B0cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VzdG9tIGNoYWluICR7Y2hhaW5QYXJhbXNPck5hbWV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGxvYWQgYW5kIHNldCBjb21tb24gZnJvbSBhIGdldGggZ2VuZXNpcyBqc29uXG4gICAgICogQHBhcmFtIGdlbmVzaXNKc29uIGpzb24gb2YgZ2V0aCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHsgY2hhaW4sIGVpcHMsIGdlbmVzaXNIYXNoLCBoYXJkZm9yaywgbWVyZ2VGb3JrSWRQb3N0TWVyZ2UgfSB0byBmdXJ0aGVyIGNvbmZpZ3VyZSB0aGUgY29tbW9uIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgQ29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIGZyb21HZXRoR2VuZXNpcyhnZW5lc2lzSnNvbiwgeyBjaGFpbiwgZWlwcywgZ2VuZXNpc0hhc2gsIGhhcmRmb3JrLCBtZXJnZUZvcmtJZFBvc3RNZXJnZSB9KSB7XG4gICAgICAgIGNvbnN0IGdlbmVzaXNQYXJhbXMgPSAoMCwgdXRpbHNfMS5wYXJzZUdldGhHZW5lc2lzKShnZW5lc2lzSnNvbiwgY2hhaW4sIG1lcmdlRm9ya0lkUG9zdE1lcmdlKTtcbiAgICAgICAgY29uc3QgY29tbW9uID0gbmV3IENvbW1vbih7XG4gICAgICAgICAgICBjaGFpbjogZ2VuZXNpc1BhcmFtcy5uYW1lID8/ICdjdXN0b20nLFxuICAgICAgICAgICAgY3VzdG9tQ2hhaW5zOiBbZ2VuZXNpc1BhcmFtc10sXG4gICAgICAgICAgICBlaXBzLFxuICAgICAgICAgICAgaGFyZGZvcms6IGhhcmRmb3JrID8/IGdlbmVzaXNQYXJhbXMuaGFyZGZvcmssXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZ2VuZXNpc0hhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tbW9uLnNldEZvcmtIYXNoZXMoZ2VuZXNpc0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGEge0BsaW5rIGNoYWluSWR9IGlzIHN1cHBvcnRlZCBhcyBhIHN0YW5kYXJkIGNoYWluXG4gICAgICogQHBhcmFtIGNoYWluSWQgYmlnaW50IGlkIChgMWApIG9mIGEgc3RhbmRhcmQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemVkQ2hhaW5zID0gdGhpcy5fZ2V0SW5pdGlhbGl6ZWRDaGFpbnMoKTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oaW5pdGlhbGl6ZWRDaGFpbnNbJ25hbWVzJ11bY2hhaW5JZC50b1N0cmluZygpXSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZ2V0Q2hhaW5QYXJhbXMoY2hhaW4sIGN1c3RvbUNoYWlucykge1xuICAgICAgICBjb25zdCBpbml0aWFsaXplZENoYWlucyA9IHRoaXMuX2dldEluaXRpYWxpemVkQ2hhaW5zKGN1c3RvbUNoYWlucyk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhaW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjaGFpbiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGNoYWluID0gY2hhaW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplZENoYWluc1snbmFtZXMnXVtjaGFpbl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gaW5pdGlhbGl6ZWRDaGFpbnNbJ25hbWVzJ11bY2hhaW5dO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsaXplZENoYWluc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhaW4gd2l0aCBJRCAke2NoYWlufSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxpemVkQ2hhaW5zW2NoYWluXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZWRDaGFpbnNbY2hhaW5dO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhaW4gd2l0aCBuYW1lICR7Y2hhaW59IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2hhaW5cbiAgICAgKiBAcGFyYW0gY2hhaW4gU3RyaW5nICgnbWFpbm5ldCcpIG9yIE51bWJlciAoMSkgY2hhaW4gcmVwcmVzZW50YXRpb24uXG4gICAgICogICAgICAgICAgICAgIE9yLCBhIERpY3Rpb25hcnkgb2YgY2hhaW4gcGFyYW1ldGVycyBmb3IgYSBwcml2YXRlIG5ldHdvcmsuXG4gICAgICogQHJldHVybnMgVGhlIGRpY3Rpb25hcnkgd2l0aCBwYXJhbWV0ZXJzIHNldCBhcyBjaGFpblxuICAgICAqL1xuICAgIHNldENoYWluKGNoYWluKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhaW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjaGFpbiA9PT0gJ2JpZ2ludCcgfHwgdHlwZW9mIGNoYWluID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5QYXJhbXMgPSBDb21tb24uX2dldENoYWluUGFyYW1zKGNoYWluLCB0aGlzLl9jdXN0b21DaGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGFpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXN0b21DaGFpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhaW4gbXVzdCBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBiaWdpbnQgd2hlbiBpbml0aWFsaXplZCB3aXRoIGN1c3RvbUNoYWlucyBwYXNzZWQgaW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkID0gWyduZXR3b3JrSWQnLCAnZ2VuZXNpcycsICdoYXJkZm9ya3MnLCAnYm9vdHN0cmFwTm9kZXMnXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgcmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwYXJhbSBpbiBjaGFpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGNoYWluIHBhcmFtZXRlcjogJHtwYXJhbX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGFpblBhcmFtcyA9IGNoYWluO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBpbnB1dCBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhmIG9mIHRoaXMuaGFyZGZvcmtzKCkpIHtcbiAgICAgICAgICAgIGlmIChoZi5ibG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYXJkZm9yayBjYW5ub3QgaGF2ZSB1bmRlZmluZWQgYmxvY2sgbnVtYmVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXJkZm9yayB0byBnZXQgcGFyYW1zIGZvclxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBTdHJpbmcgaWRlbnRpZmllciAoZS5nLiAnYnl6YW50aXVtJykgb3Ige0BsaW5rIEhhcmRmb3JrfSBlbnVtXG4gICAgICovXG4gICAgc2V0SGFyZGZvcmsoaGFyZGZvcmspIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgaGZDaGFuZ2VzIG9mIHRoaXMuSEFSREZPUktfQ0hBTkdFUykge1xuICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1swXSA9PT0gaGFyZGZvcmspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFyZGZvcmsgIT09IGhhcmRmb3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhcmRmb3JrID0gaGFyZGZvcms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGFyZGZvcmtDaGFuZ2VkJywgaGFyZGZvcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGlzdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYXJkZm9yayB3aXRoIG5hbWUgJHtoYXJkZm9ya30gbm90IHN1cHBvcnRlZGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhhcmRmb3JrIGJhc2VkIG9uIHRoZSBibG9jayBudW1iZXIgb3IgYW4gb3B0aW9uYWxcbiAgICAgKiB0b3RhbCBkaWZmaWN1bHR5IChNZXJnZSBIRikgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBBbiBvcHRpb25hbCBURCB0YWtlcyBwcmVjZWRlbmNlIGluIGNhc2UgdGhlIGNvcnJlc3BvbmRpbmcgSEYgYmxvY2tcbiAgICAgKiBpcyBzZXQgdG8gYG51bGxgIG9yIG90aGVyd2lzZSBuZWVkcyB0byBtYXRjaCAoaWYgbm90IGFuIGVycm9yXG4gICAgICogd2lsbCBiZSB0aHJvd24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyXG4gICAgICogQHBhcmFtIHRkIDogdG90YWwgZGlmZmljdWx0eSBvZiB0aGUgcGFyZW50IGJsb2NrIChmb3IgYmxvY2sgaGYpIE9SIG9mIHRoZSBjaGFpbiBsYXRlc3QgKGZvciBjaGFpbiBoZilcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wOiB0aW1lc3RhbXAgaW4gc2Vjb25kcyBhdCB3aGljaCBibG9jayB3YXMvaXMgdG8gYmUgbWludGVkXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIEhGXG4gICAgICovXG4gICAgZ2V0SGFyZGZvcmtCeUJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyLCB0ZCwgdGltZXN0YW1wKSB7XG4gICAgICAgIGJsb2NrTnVtYmVyID0gKDAsIHV0aWxfMS50b1R5cGUpKGJsb2NrTnVtYmVyLCB1dGlsXzEuVHlwZU91dHB1dC5CaWdJbnQpO1xuICAgICAgICB0ZCA9ICgwLCB1dGlsXzEudG9UeXBlKSh0ZCwgdXRpbF8xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICAgICAgdGltZXN0YW1wID0gKDAsIHV0aWxfMS50b1R5cGUpKHRpbWVzdGFtcCwgdXRpbF8xLlR5cGVPdXRwdXQuTnVtYmVyKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBoYXJkZm9ya3Mgd2l0aCBubyBibG9jayBudW1iZXIsIG5vIHR0ZCBvciBubyB0aW1lc3RhbXAgKGkuZS4gdW5hcHBsaWVkIGhhcmRmb3JrcylcbiAgICAgICAgY29uc3QgaGZzID0gdGhpcy5oYXJkZm9ya3MoKS5maWx0ZXIoKGhmKSA9PiBoZi5ibG9jayAhPT0gbnVsbCB8fCAoaGYudHRkICE9PSBudWxsICYmIGhmLnR0ZCAhPT0gdW5kZWZpbmVkKSB8fCBoZi50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG1lcmdlSW5kZXggPSBoZnMuZmluZEluZGV4KChoZikgPT4gaGYudHRkICE9PSBudWxsICYmIGhmLnR0ZCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgZG91YmxlVFRESEYgPSBoZnNcbiAgICAgICAgICAgIC5zbGljZShtZXJnZUluZGV4ICsgMSlcbiAgICAgICAgICAgIC5maW5kSW5kZXgoKGhmKSA9PiBoZi50dGQgIT09IG51bGwgJiYgaGYudHRkICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoZG91YmxlVFRESEYgPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1vcmUgdGhhbiBvbmUgbWVyZ2UgaGFyZGZvcmtzIGZvdW5kIHdpdGggdHRkIHNwZWNpZmllZGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGhhcmRmb3JrIHRoYXQgaGFzIGEgYmxvY2sgbnVtYmVyIGdyZWF0ZXIgdGhhbiBgYmxvY2tOdW1iZXJgXG4gICAgICAgIC8vIChza2lwcyB0aGUgbWVyZ2UgaGFyZGZvcmsgc2luY2UgaXQgY2Fubm90IGhhdmUgYSBibG9jayBudW1iZXIgc3BlY2lmaWVkKS5cbiAgICAgICAgLy8gSWYgdGltZXN0YW1wIGlzIG5vdCBwcm92aWRlZCwgaXQgYWxzbyBza2lwcyB0aW1lc3RhbXBzIGhhcmRmb3JrcyB0byBjb250aW51ZVxuICAgICAgICAvLyBkaXNjb3ZlcmluZy9jaGVja2luZyBudW1iZXIgaGFyZGZvcmtzLlxuICAgICAgICBsZXQgaGZJbmRleCA9IGhmcy5maW5kSW5kZXgoKGhmKSA9PiAoaGYuYmxvY2sgIT09IG51bGwgJiYgaGYuYmxvY2sgPiBibG9ja051bWJlcikgfHxcbiAgICAgICAgICAgICh0aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiBOdW1iZXIoaGYudGltZXN0YW1wKSA+IHRpbWVzdGFtcCkpO1xuICAgICAgICBpZiAoaGZJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGFsbCBoYXJkZm9ya3MgYXBwbHksIHNldCBoZkluZGV4IHRvIHRoZSBsYXN0IG9uZSBhcyB0aGF0J3MgdGhlIGNhbmRpZGF0ZVxuICAgICAgICAgICAgaGZJbmRleCA9IGhmcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGZJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gY2Fubm90IGhhdmUgYSBjYXNlIHdoZXJlIGEgYmxvY2sgbnVtYmVyIGlzIGJlZm9yZSBhbGwgYXBwbGllZCBoYXJkZm9ya3NcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjaGFpbiBoYXMgdG8gc3RhcnQgd2l0aCBhIGhhcmRmb3JrXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBoYXJkZm9yayBhdCBibG9jayAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGltZXN0YW1wIGlzIG5vdCBwcm92aWRlZCwgd2UgbmVlZCB0byByb2xsYmFjayB0byB0aGUgbGFzdCBoZiB3aXRoIGJsb2NrIG9yIHR0ZFxuICAgICAgICBpZiAodGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBCYWNrID0gaGZzXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGhmSW5kZXgpXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5maW5kSW5kZXgoKGhmKSA9PiBoZi5ibG9jayAhPT0gbnVsbCB8fCBoZi50dGQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBoZkluZGV4ID0gaGZJbmRleCAtIHN0ZXBCYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vdmUgaGZJbmRleCBvbmUgYmFjayB0byBhcnJpdmUgYXQgY2FuZGlkYXRlIGhhcmRmb3JrXG4gICAgICAgIGhmSW5kZXggPSBoZkluZGV4IC0gMTtcbiAgICAgICAgLy8gSWYgdGhlIHRpbWVzdGFtcCB3YXMgbm90IHByb3ZpZGVkLCB3ZSBjb3VsZCBoYXZlIHNraXBwZWQgdGltZXN0YW1wIGhhcmRmb3JrcyB0byBsb29rIGZvciBudW1iZXJcbiAgICAgICAgLy8gaGFyZGZvcmtzLiBzbyBpdCB3aWxsIG5vdyBiZSBuZWVkZWQgdG8gcm9sbGJhY2tcbiAgICAgICAgaWYgKGhmc1toZkluZGV4XS5ibG9jayA9PT0gbnVsbCAmJiBoZnNbaGZJbmRleF0udGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIG9uIHRoZSBtZXJnZSBoYXJkZm9yay4gIExldCdzIGNoZWNrIHRoZSBUVERcbiAgICAgICAgICAgIGlmICh0ZCA9PT0gdW5kZWZpbmVkIHx8IHRkID09PSBudWxsIHx8IEJpZ0ludChoZnNbaGZJbmRleF0udHRkKSA+IHRkKSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgdHRkIGdyZWF0ZXIgdGhhbiBjdXJyZW50IHRkIHNvIHdlJ3JlIG9uIGhhcmRmb3JrIGJlZm9yZSBtZXJnZVxuICAgICAgICAgICAgICAgIGhmSW5kZXggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZXJnZUluZGV4ID49IDAgJiYgdGQgIT09IHVuZGVmaW5lZCAmJiB0ZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChoZkluZGV4ID49IG1lcmdlSW5kZXggJiYgQmlnSW50KGhmc1ttZXJnZUluZGV4XS50dGQpID4gdGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01heGltdW0gSEYgZGV0ZXJtaW5lZCBieSB0b3RhbCBkaWZmaWN1bHR5IGlzIGxvd2VyIHRoYW4gdGhlIGJsb2NrIG51bWJlciBIRicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoZkluZGV4IDwgbWVyZ2VJbmRleCAmJiBCaWdJbnQoaGZzW21lcmdlSW5kZXhdLnR0ZCkgPD0gdGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0hGIGRldGVybWluZWQgYnkgYmxvY2sgbnVtYmVyIGlzIGxvd2VyIHRoYW4gdGhlIG1pbmltdW0gdG90YWwgZGlmZmljdWx0eSBIRicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZlN0YXJ0SW5kZXggPSBoZkluZGV4O1xuICAgICAgICAvLyBNb3ZlIHRoZSBoZkluZGV4IHRvIHRoZSBlbmQgb2YgdGhlIGhhcmRmb3JrcyB0aGF0IG1pZ2h0IGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSBibG9jay90aW1lc3RhbXBcbiAgICAgICAgLy8gVGhpcyB3b24ndCBhbnl3YXkgYmUgdGhlIGNhc2Ugd2l0aCBNZXJnZSBoZnNcbiAgICAgICAgZm9yICg7IGhmSW5kZXggPCBoZnMubGVuZ3RoIC0gMTsgaGZJbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBicmVhayBvdXQgaWYgaGZJbmRleCArIDEgaXMgbm90IHNjaGVkdWxlZCBhdCBoZkluZGV4XG4gICAgICAgICAgICBpZiAoaGZzW2hmSW5kZXhdLmJsb2NrICE9PSBoZnNbaGZJbmRleCArIDFdLmJsb2NrIHx8XG4gICAgICAgICAgICAgICAgaGZzW2hmSW5kZXhdLnRpbWVzdGFtcCAhPT0gaGZzW2hmSW5kZXggKyAxXS50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5UaW1lU3RhbXAgPSBoZnNcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaGZTdGFydEluZGV4KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgaGYpID0+IE1hdGgubWF4KE51bWJlcihoZi50aW1lc3RhbXAgPz8gJzAnKSwgYWNjKSwgMCk7XG4gICAgICAgICAgICBpZiAobWluVGltZVN0YW1wID4gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1heGltdW0gSEYgZGV0ZXJtaW5lZCBieSB0aW1lc3RhbXAgaXMgbG93ZXIgdGhhbiB0aGUgYmxvY2sgbnVtYmVyL3R0ZCBIRmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF4VGltZVN0YW1wID0gaGZzXG4gICAgICAgICAgICAgICAgLnNsaWNlKGhmSW5kZXggKyAxKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgaGYpID0+IE1hdGgubWluKE51bWJlcihoZi50aW1lc3RhbXAgPz8gdGltZXN0YW1wKSwgYWNjKSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lU3RhbXAgPCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgTWF4aW11bSBIRiBkZXRlcm1pbmVkIGJ5IGJsb2NrIG51bWJlci90dGQgaXMgbG93ZXIgdGhhbiB0aW1lc3RhbXAgSEZgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXJkZm9yayA9IGhmc1toZkluZGV4XTtcbiAgICAgICAgcmV0dXJuIGhhcmRmb3JrLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgaGFyZGZvcmsgYmFzZWQgb24gdGhlIGJsb2NrIG51bWJlciBvciBhbiBvcHRpb25hbFxuICAgICAqIHRvdGFsIGRpZmZpY3VsdHkgKE1lcmdlIEhGKSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEFuIG9wdGlvbmFsIFREIHRha2VzIHByZWNlZGVuY2UgaW4gY2FzZSB0aGUgY29ycmVzcG9uZGluZyBIRiBibG9ja1xuICAgICAqIGlzIHNldCB0byBgbnVsbGAgb3Igb3RoZXJ3aXNlIG5lZWRzIHRvIG1hdGNoIChpZiBub3QgYW4gZXJyb3JcbiAgICAgKiB3aWxsIGJlIHRocm93bikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXJcbiAgICAgKiBAcGFyYW0gdGRcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIEhGIHNldFxuICAgICAqL1xuICAgIHNldEhhcmRmb3JrQnlCbG9ja051bWJlcihibG9ja051bWJlciwgdGQsIHRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuZ2V0SGFyZGZvcmtCeUJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyLCB0ZCwgdGltZXN0YW1wKTtcbiAgICAgICAgdGhpcy5zZXRIYXJkZm9yayhoYXJkZm9yayk7XG4gICAgICAgIHJldHVybiBoYXJkZm9yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uLCByZXR1cm5zIHRoZSBwYXJhbXMgZm9yIHRoZSBnaXZlbiBoYXJkZm9yayBmb3IgdGhlIGNoYWluIHNldFxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lXG4gICAgICogQHJldHVybnMgRGljdGlvbmFyeSB3aXRoIGhhcmRmb3JrIHBhcmFtcyBvciBudWxsIGlmIGhhcmRmb3JrIG5vdCBvbiBjaGFpblxuICAgICAqL1xuICAgIF9nZXRIYXJkZm9yayhoYXJkZm9yaykge1xuICAgICAgICBjb25zdCBoZnMgPSB0aGlzLmhhcmRmb3JrcygpO1xuICAgICAgICBmb3IgKGNvbnN0IGhmIG9mIGhmcykge1xuICAgICAgICAgICAgaWYgKGhmWyduYW1lJ10gPT09IGhhcmRmb3JrKVxuICAgICAgICAgICAgICAgIHJldHVybiBoZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIEVJUHNcbiAgICAgKiBAcGFyYW0gZWlwc1xuICAgICAqL1xuICAgIHNldEVJUHMoZWlwcyA9IFtdKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWlwIG9mIGVpcHMpIHtcbiAgICAgICAgICAgIGlmICghKGVpcCBpbiBlaXBzXzEuRUlQcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZWlwfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5IRiA9IHRoaXMuZ3RlSGFyZGZvcmsoZWlwc18xLkVJUHNbZWlwXVsnbWluaW11bUhhcmRmb3JrJ10pO1xuICAgICAgICAgICAgaWYgKCFtaW5IRikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlaXB9IGNhbm5vdCBiZSBhY3RpdmF0ZWQgb24gaGFyZGZvcmsgJHt0aGlzLmhhcmRmb3JrKCl9LCBtaW5pbXVtSGFyZGZvcms6ICR7bWluSEZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWlwc18xLkVJUHNbZWlwXS5yZXF1aXJlZEVJUHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBlaXBzXzEuRUlQc1tlaXBdLnJlcXVpcmVkRUlQcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShlaXBzLmluY2x1ZGVzKGVsZW0pIHx8IHRoaXMuaXNBY3RpdmF0ZWRFSVAoZWxlbSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZWlwfSByZXF1aXJlcyBFSVAgJHtlbGVtfSwgYnV0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgRUlQIGxpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9laXBzID0gZWlwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcmFtZXRlciBmb3IgdGhlIGN1cnJlbnQgY2hhaW4gc2V0dXBcbiAgICAgKlxuICAgICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgcHJlc2VudCBpbiBhbiBFSVAsIHRoZSBFSVAgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICogT3RoZXJ3aXNlIHRoZSBwYXJhbWV0ZXIgaWYgdGFrZW4gZnJvbSB0aGUgbGF0ZXN0IGFwcGxpZWQgSEYgd2l0aFxuICAgICAqIGEgY2hhbmdlIG9uIHRoZSByZXNwZWN0aXZlIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b3BpYyBQYXJhbWV0ZXIgdG9waWMgKCdnYXNDb25maWcnLCAnZ2FzUHJpY2VzJywgJ3ZtJywgJ3BvdycpXG4gICAgICogQHBhcmFtIG5hbWUgUGFyYW1ldGVyIG5hbWUgKGUuZy4gJ21pbkdhc0xpbWl0JyBmb3IgJ2dhc0NvbmZpZycgdG9waWMpXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHJlcXVlc3RlZCBvciBgQmlnSW50KDApYCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBwYXJhbSh0b3BpYywgbmFtZSkge1xuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciB0aGUgY2FzZSB0aGF0IGRpZmZlcmVudCBhY3RpdmUgRUlQc1xuICAgICAgICAvLyBjYW4gY2hhbmdlIHRoZSBzYW1lIHBhcmFtZXRlclxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgZWlwIG9mIHRoaXMuX2VpcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJhbUJ5RUlQKHRvcGljLCBuYW1lLCBlaXApO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtQnlIYXJkZm9yayh0b3BpYywgbmFtZSwgdGhpcy5faGFyZGZvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXIgY29ycmVzcG9uZGluZyB0byBhIGhhcmRmb3JrXG4gICAgICogQHBhcmFtIHRvcGljIFBhcmFtZXRlciB0b3BpYyAoJ2dhc0NvbmZpZycsICdnYXNQcmljZXMnLCAndm0nLCAncG93JylcbiAgICAgKiBAcGFyYW0gbmFtZSBQYXJhbWV0ZXIgbmFtZSAoZS5nLiAnbWluR2FzTGltaXQnIGZvciAnZ2FzQ29uZmlnJyB0b3BpYylcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZVxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSByZXF1ZXN0ZWQgb3IgYEJpZ0ludCgwKWAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgcGFyYW1CeUhhcmRmb3JrKHRvcGljLCBuYW1lLCBoYXJkZm9yaykge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGhmQ2hhbmdlcyBvZiB0aGlzLkhBUkRGT1JLX0NIQU5HRVMpIHtcbiAgICAgICAgICAgIC8vIEVJUC1yZWZlcmVuY2luZyBIRiBmaWxlIChlLmcuIGJlcmxpbi5qc29uKVxuICAgICAgICAgICAgaWYgKCdlaXBzJyBpbiBoZkNoYW5nZXNbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZkVJUHMgPSBoZkNoYW5nZXNbMV1bJ2VpcHMnXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVpcCBvZiBoZkVJUHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVFSVAgPSB0aGlzLnBhcmFtQnlFSVAodG9waWMsIG5hbWUsIGVpcCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlRUlQID09PSAnYmlnaW50JyA/IHZhbHVlRUlQIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcmFtZXRlci1pbmxpbmluZyBIRiBmaWxlIChlLmcuIGlzdGFuYnVsLmpzb24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGZDaGFuZ2VzWzFdW3RvcGljXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9waWMgJHt0b3BpY30gbm90IGRlZmluZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1sxXVt0b3BpY11bbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhmQ2hhbmdlc1sxXVt0b3BpY11bbmFtZV0udjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGZDaGFuZ2VzWzBdID09PSBoYXJkZm9yaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlID8/IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFyYW1ldGVyIGNvcnJlc3BvbmRpbmcgdG8gYW4gRUlQXG4gICAgICogQHBhcmFtIHRvcGljIFBhcmFtZXRlciB0b3BpYyAoJ2dhc0NvbmZpZycsICdnYXNQcmljZXMnLCAndm0nLCAncG93JylcbiAgICAgKiBAcGFyYW0gbmFtZSBQYXJhbWV0ZXIgbmFtZSAoZS5nLiAnbWluR2FzTGltaXQnIGZvciAnZ2FzQ29uZmlnJyB0b3BpYylcbiAgICAgKiBAcGFyYW0gZWlwIE51bWJlciBvZiB0aGUgRUlQXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHJlcXVlc3RlZCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBwYXJhbUJ5RUlQKHRvcGljLCBuYW1lLCBlaXApIHtcbiAgICAgICAgaWYgKCEoZWlwIGluIGVpcHNfMS5FSVBzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2VpcH0gbm90IHN1cHBvcnRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVpcFBhcmFtcyA9IGVpcHNfMS5FSVBzW2VpcF07XG4gICAgICAgIGlmICghKHRvcGljIGluIGVpcFBhcmFtcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9waWMgJHt0b3BpY30gbm90IGRlZmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWlwUGFyYW1zW3RvcGljXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWlwUGFyYW1zW3RvcGljXVtuYW1lXS52O1xuICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcmFtZXRlciBmb3IgdGhlIGhhcmRmb3JrIGFjdGl2ZSBvbiBibG9jayBudW1iZXIgb3JcbiAgICAgKiBvcHRpb25hbCBwcm92aWRlZCB0b3RhbCBkaWZmaWN1bHR5IChNZXJnZSBIRilcbiAgICAgKiBAcGFyYW0gdG9waWMgUGFyYW1ldGVyIHRvcGljXG4gICAgICogQHBhcmFtIG5hbWUgUGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXIgQmxvY2sgbnVtYmVyXG4gICAgICogQHBhcmFtIHRkIFRvdGFsIGRpZmZpY3VsdHlcbiAgICAgKiAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSByZXF1ZXN0ZWQgb3IgYEJpZ0ludCgwKWAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgcGFyYW1CeUJsb2NrKHRvcGljLCBuYW1lLCBibG9ja051bWJlciwgdGQsIHRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuZ2V0SGFyZGZvcmtCeUJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyLCB0ZCwgdGltZXN0YW1wKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1CeUhhcmRmb3JrKHRvcGljLCBuYW1lLCBoYXJkZm9yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbiBFSVAgaXMgYWN0aXZhdGVkIGJ5IGVpdGhlciBiZWluZyBpbmNsdWRlZCBpbiB0aGUgRUlQc1xuICAgICAqIG1hbnVhbGx5IHBhc3NlZCBpbiB3aXRoIHRoZSB7QGxpbmsgQ29tbW9uT3B0cy5laXBzfSBvciBpbiBhXG4gICAgICogaGFyZGZvcmsgY3VycmVudGx5IGJlaW5nIGFjdGl2ZVxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2Qgb25seSB3b3JrcyBmb3IgRUlQcyBiZWluZyBzdXBwb3J0ZWRcbiAgICAgKiBieSB0aGUge0BsaW5rIENvbW1vbk9wdHMuZWlwc30gY29uc3RydWN0b3Igb3B0aW9uXG4gICAgICogQHBhcmFtIGVpcFxuICAgICAqL1xuICAgIGlzQWN0aXZhdGVkRUlQKGVpcCkge1xuICAgICAgICBpZiAodGhpcy5laXBzKCkuaW5jbHVkZXMoZWlwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBoZkNoYW5nZXMgb2YgdGhpcy5IQVJERk9SS19DSEFOR0VTKSB7XG4gICAgICAgICAgICBjb25zdCBoZiA9IGhmQ2hhbmdlc1sxXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmd0ZUhhcmRmb3JrKGhmWyduYW1lJ10pICYmICdlaXBzJyBpbiBoZikge1xuICAgICAgICAgICAgICAgIGlmIChoZlsnZWlwcyddLmluY2x1ZGVzKGVpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHNldCBvciBwcm92aWRlZCBoYXJkZm9yayBpcyBhY3RpdmUgb24gYmxvY2sgbnVtYmVyXG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWUgb3IgbnVsbCAoZm9yIEhGIHNldClcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIEhGIGlzIGFjdGl2ZSBvbiBibG9jayBudW1iZXJcbiAgICAgKi9cbiAgICBoYXJkZm9ya0lzQWN0aXZlT25CbG9jayhoYXJkZm9yaywgYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgYmxvY2tOdW1iZXIgPSAoMCwgdXRpbF8xLnRvVHlwZSkoYmxvY2tOdW1iZXIsIHV0aWxfMS5UeXBlT3V0cHV0LkJpZ0ludCk7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGFyZGZvcmspO1xuICAgICAgICBpZiAodHlwZW9mIGhmQmxvY2sgPT09ICdiaWdpbnQnICYmIGhmQmxvY2sgIT09IEJpZ0ludCgwKSAmJiBibG9ja051bWJlciA+PSBoZkJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIHRvIGhhcmRmb3JrSXNBY3RpdmVPbkJsb2NrIHdoZW4gaGFyZGZvcmsgaXMgc2V0XG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBIRiBpcyBhY3RpdmUgb24gYmxvY2sgbnVtYmVyXG4gICAgICovXG4gICAgYWN0aXZlT25CbG9jayhibG9ja051bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0lzQWN0aXZlT25CbG9jayhudWxsLCBibG9ja051bWJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcXVlbmNlIGJhc2VkIGNoZWNrIGlmIGdpdmVuIG9yIHNldCBIRjEgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIEhGMlxuICAgICAqIEBwYXJhbSBoYXJkZm9yazEgSGFyZGZvcmsgbmFtZSBvciBudWxsIChpZiBzZXQpXG4gICAgICogQHBhcmFtIGhhcmRmb3JrMiBIYXJkZm9yayBuYW1lXG4gICAgICogQHBhcmFtIG9wdHMgSGFyZGZvcmsgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgSEYxIGd0ZSBIRjJcbiAgICAgKi9cbiAgICBoYXJkZm9ya0d0ZUhhcmRmb3JrKGhhcmRmb3JrMSwgaGFyZGZvcmsyKSB7XG4gICAgICAgIGhhcmRmb3JrMSA9IGhhcmRmb3JrMSA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgY29uc3QgaGFyZGZvcmtzID0gdGhpcy5oYXJkZm9ya3MoKTtcbiAgICAgICAgbGV0IHBvc0hmMSA9IC0xLCBwb3NIZjIgPSAtMTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBoZiBvZiBoYXJkZm9ya3MpIHtcbiAgICAgICAgICAgIGlmIChoZlsnbmFtZSddID09PSBoYXJkZm9yazEpXG4gICAgICAgICAgICAgICAgcG9zSGYxID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoaGZbJ25hbWUnXSA9PT0gaGFyZGZvcmsyKVxuICAgICAgICAgICAgICAgIHBvc0hmMiA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zSGYxID49IHBvc0hmMiAmJiBwb3NIZjIgIT09IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyB0byBoYXJkZm9ya0d0ZUhhcmRmb3JrIHdoZW4gaGFyZGZvcmsgaXMgc2V0XG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGhhcmRmb3JrIHNldCBpcyBncmVhdGVyIHRoYW4gaGFyZGZvcmsgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBndGVIYXJkZm9yayhoYXJkZm9yaykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0d0ZUhhcmRmb3JrKG51bGwsIGhhcmRmb3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGFyZGZvcmsgY2hhbmdlIGJsb2NrIGZvciBoYXJkZm9yayBwcm92aWRlZCBvciBzZXRcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgQmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgdW5zY2hlZHVsZWRcbiAgICAgKi9cbiAgICBoYXJkZm9ya0Jsb2NrKGhhcmRmb3JrKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5fZ2V0SGFyZGZvcmsoaGFyZGZvcmspPy5bJ2Jsb2NrJ107XG4gICAgICAgIGlmIChibG9jayA9PT0gdW5kZWZpbmVkIHx8IGJsb2NrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KGJsb2NrKTtcbiAgICB9XG4gICAgaGFyZGZvcmtUaW1lc3RhbXAoaGFyZGZvcmspIHtcbiAgICAgICAgaGFyZGZvcmsgPSBoYXJkZm9yayA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gdGhpcy5fZ2V0SGFyZGZvcmsoaGFyZGZvcmspPy5bJ3RpbWVzdGFtcCddO1xuICAgICAgICBpZiAodGltZXN0YW1wID09PSB1bmRlZmluZWQgfHwgdGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhhcmRmb3JrIGNoYW5nZSBibG9jayBmb3IgZWlwXG4gICAgICogQHBhcmFtIGVpcCBFSVAgbnVtYmVyXG4gICAgICogQHJldHVybnMgQmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgdW5zY2hlZHVsZWRcbiAgICAgKi9cbiAgICBlaXBCbG9jayhlaXApIHtcbiAgICAgICAgZm9yIChjb25zdCBoZkNoYW5nZXMgb2YgdGhpcy5IQVJERk9SS19DSEFOR0VTKSB7XG4gICAgICAgICAgICBjb25zdCBoZiA9IGhmQ2hhbmdlc1sxXTtcbiAgICAgICAgICAgIGlmICgnZWlwcycgaW4gaGYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgaWYgKGhmWydlaXBzJ10uaW5jbHVkZXMoZWlwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0Jsb2NrKGhmQ2hhbmdlc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoYXJkZm9yayBjaGFuZ2UgdG90YWwgZGlmZmljdWx0eSAoTWVyZ2UgSEYpIGZvciBoYXJkZm9yayBwcm92aWRlZCBvciBzZXRcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgVG90YWwgZGlmZmljdWx0eSBvciBudWxsIGlmIG5vIHNldFxuICAgICAqL1xuICAgIGhhcmRmb3JrVFREKGhhcmRmb3JrKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IHR0ZCA9IHRoaXMuX2dldEhhcmRmb3JrKGhhcmRmb3JrKT8uWyd0dGQnXTtcbiAgICAgICAgaWYgKHR0ZCA9PT0gdW5kZWZpbmVkIHx8IHR0ZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0dGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGJsb2NrIG51bWJlciBwcm92aWRlZCBpcyB0aGUgaGFyZGZvcmsgKGdpdmVuIG9yIHNldCkgY2hhbmdlIGJsb2NrXG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyIE51bWJlciBvZiB0aGUgYmxvY2sgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBibG9ja051bWJlciBpcyBIRiBibG9ja1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgaXNIYXJkZm9ya0Jsb2NrKGJsb2NrTnVtYmVyLCBoYXJkZm9yaykge1xuICAgICAgICBibG9ja051bWJlciA9ICgwLCB1dGlsXzEudG9UeXBlKShibG9ja051bWJlciwgdXRpbF8xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICAgICAgaGFyZGZvcmsgPSBoYXJkZm9yayA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGFyZGZvcmspO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGJsb2NrID09PSAnYmlnaW50JyAmJiBibG9jayAhPT0gQmlnSW50KDApID8gYmxvY2sgPT09IGJsb2NrTnVtYmVyIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYW5nZSBibG9jayBmb3IgdGhlIG5leHQgaGFyZGZvcmsgYWZ0ZXIgdGhlIGhhcmRmb3JrIHByb3ZpZGVkIG9yIHNldFxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lLCBvcHRpb25hbCBpZiBIRiBzZXRcbiAgICAgKiBAcmV0dXJucyBCbG9jayB0aW1lc3RhbXAsIG51bWJlciBvciBudWxsIGlmIG5vdCBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBuZXh0SGFyZGZvcmtCbG9ja09yVGltZXN0YW1wKGhhcmRmb3JrKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGhmcyA9IHRoaXMuaGFyZGZvcmtzKCk7XG4gICAgICAgIGxldCBoZkluZGV4ID0gaGZzLmZpbmRJbmRleCgoaGYpID0+IGhmLm5hbWUgPT09IGhhcmRmb3JrKTtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaGFyZGZvcmsgaXMgbWVyZ2UsIGdvIG9uZSBiZWhpbmQgYXMgbWVyZ2UgaGYgaXMgbm90IHBhcnQgb2YgdGhlc2VcbiAgICAgICAgLy8gY2FsY3MgZXZlbiBpZiB0aGUgbWVyZ2UgaGYgYmxvY2sgaXMgc2V0XG4gICAgICAgIGlmIChoYXJkZm9yayA9PT0gZW51bXNfMS5IYXJkZm9yay5NZXJnZSkge1xuICAgICAgICAgICAgaGZJbmRleCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhcmRmb3JrIG5vdCBmb3VuZFxuICAgICAgICBpZiAoaGZJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJySGZUaW1lT3JCbG9jayA9IGhmc1toZkluZGV4XS50aW1lc3RhbXAgPz8gaGZzW2hmSW5kZXhdLmJsb2NrO1xuICAgICAgICBjdXJySGZUaW1lT3JCbG9jayA9XG4gICAgICAgICAgICBjdXJySGZUaW1lT3JCbG9jayAhPT0gbnVsbCAmJiBjdXJySGZUaW1lT3JCbG9jayAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIoY3VyckhmVGltZU9yQmxvY2spXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBuZXh0SGYgPSBoZnMuc2xpY2UoaGZJbmRleCArIDEpLmZpbmQoKGhmKSA9PiB7XG4gICAgICAgICAgICBsZXQgaGZUaW1lT3JCbG9jayA9IGhmLnRpbWVzdGFtcCA/PyBoZi5ibG9jaztcbiAgICAgICAgICAgIGhmVGltZU9yQmxvY2sgPVxuICAgICAgICAgICAgICAgIGhmVGltZU9yQmxvY2sgIT09IG51bGwgJiYgaGZUaW1lT3JCbG9jayAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKGhmVGltZU9yQmxvY2spIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiAoaGYubmFtZSAhPT0gZW51bXNfMS5IYXJkZm9yay5NZXJnZSAmJlxuICAgICAgICAgICAgICAgIGhmVGltZU9yQmxvY2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBoZlRpbWVPckJsb2NrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBoZlRpbWVPckJsb2NrICE9PSBjdXJySGZUaW1lT3JCbG9jayk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiBubyBuZXh0IGhmIGZvdW5kIHdpdGggdmFsaWQgYmxvY2sgb3IgdGltZXN0YW1wIHJldHVybiBudWxsXG4gICAgICAgIGlmIChuZXh0SGYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEhmQmxvY2sgPSBuZXh0SGYudGltZXN0YW1wID8/IG5leHRIZi5ibG9jaztcbiAgICAgICAgaWYgKG5leHRIZkJsb2NrID09PSBudWxsIHx8IG5leHRIZkJsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQobmV4dEhmQmxvY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGFuZ2UgYmxvY2sgZm9yIHRoZSBuZXh0IGhhcmRmb3JrIGFmdGVyIHRoZSBoYXJkZm9yayBwcm92aWRlZCBvciBzZXRcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgQmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgbmV4dEhhcmRmb3JrQmxvY2soaGFyZGZvcmspIHtcbiAgICAgICAgaGFyZGZvcmsgPSBoYXJkZm9yayA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgbGV0IGhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGFyZGZvcmspO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbWVyZ2UgaGFyZGZvcmsgd2l0aCBibG9jayBub3Qgc2V0LCB0aGVuIHdlIGZhbGxiYWNrIHRvIHByZXZpb3VzIGhhcmRmb3JrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIG5leHRIYXJkZm9ya0Jsb2NrXG4gICAgICAgIGlmIChoZkJsb2NrID09PSBudWxsICYmIGhhcmRmb3JrID09PSBlbnVtc18xLkhhcmRmb3JrLk1lcmdlKSB7XG4gICAgICAgICAgICBjb25zdCBoZnMgPSB0aGlzLmhhcmRmb3JrcygpO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VJbmRleCA9IGhmcy5maW5kSW5kZXgoKGhmKSA9PiBoZi50dGQgIT09IG51bGwgJiYgaGYudHRkICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1lcmdlIGhhcmRmb3JrIHNob3VsZCBoYXZlIGJlZW4gZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGZzW21lcmdlSW5kZXggLSAxXS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGZCbG9jayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV4dCBmb3JrIGJsb2NrIG51bWJlciBvciBudWxsIGlmIG5vbmUgYXZhaWxhYmxlXG4gICAgICAgIC8vIExvZ2ljOiBpZiBhY2N1bXVsYXRvciBpcyBzdGlsbCBudWxsIGFuZCBvbiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZlxuICAgICAgICAvLyBhIGJsb2NrIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBoZkJsb2NrIHNldCB0aGUgYWNjdW11bGF0b3IsXG4gICAgICAgIC8vIHBhc3Mgb24gdGhlIGFjY3VtdWxhdG9yIGFzIHRoZSBmaW5hbCByZXN1bHQgZnJvbSB0aGlzIHRpbWUgb25cbiAgICAgICAgY29uc3QgbmV4dEhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrcygpLnJlZHVjZSgoYWNjLCBoZikgPT4ge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBpZ25vcmUgdGhlIG1lcmdlIGJsb2NrIGluIG91ciBuZXh0IGhhcmRmb3JrIGNhbGNcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gQmlnSW50KGhmLmJsb2NrID09PSBudWxsIHx8IChoZi50dGQgIT09IHVuZGVmaW5lZCAmJiBoZi50dGQgIT09IG51bGwpID8gMCA6IGhmLmJsb2NrKTtcbiAgICAgICAgICAgIC8vIFR5cGVzY3JpcHQgY2FuJ3Qgc2VlbSB0byBmb2xsb3cgdGhhdCB0aGUgaGZCbG9jayBpcyBub3QgbnVsbCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICByZXR1cm4gYmxvY2sgPiBoZkJsb2NrICYmIGFjYyA9PT0gbnVsbCA/IGJsb2NrIDogYWNjO1xuICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5leHRIZkJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGJsb2NrIG51bWJlciBwcm92aWRlZCBpcyB0aGUgaGFyZGZvcmsgY2hhbmdlIGJsb2NrIGZvbGxvd2luZyB0aGUgaGFyZGZvcmsgZ2l2ZW4gb3Igc2V0XG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyIE51bWJlciBvZiB0aGUgYmxvY2sgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBibG9ja051bWJlciBpcyBIRiBibG9ja1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgaXNOZXh0SGFyZGZvcmtCbG9jayhibG9ja051bWJlciwgaGFyZGZvcmspIHtcbiAgICAgICAgYmxvY2tOdW1iZXIgPSAoMCwgdXRpbF8xLnRvVHlwZSkoYmxvY2tOdW1iZXIsIHV0aWxfMS5UeXBlT3V0cHV0LkJpZ0ludCk7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IG5leHRIYXJkZm9ya0Jsb2NrID0gdGhpcy5uZXh0SGFyZGZvcmtCbG9jayhoYXJkZm9yayk7XG4gICAgICAgIHJldHVybiBuZXh0SGFyZGZvcmtCbG9jayA9PT0gbnVsbCA/IGZhbHNlIDogbmV4dEhhcmRmb3JrQmxvY2sgPT09IGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGEgZm9yayBoYXNoXG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcGFyYW0gZ2VuZXNpc0hhc2ggR2VuZXNpcyBibG9jayBoYXNoIG9mIHRoZSBjaGFpblxuICAgICAqIEByZXR1cm5zIEZvcmsgaGFzaCBhcyBoZXggc3RyaW5nXG4gICAgICovXG4gICAgX2NhbGNGb3JrSGFzaChoYXJkZm9yaywgZ2VuZXNpc0hhc2gpIHtcbiAgICAgICAgbGV0IGhmQnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICBsZXQgcHJldkJsb2NrT3JUaW1lID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBoZiBvZiB0aGlzLmhhcmRmb3JrcygpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrLCB0aW1lc3RhbXAsIG5hbWUgfSA9IGhmO1xuICAgICAgICAgICAgLy8gVGltZXN0YW1wIHRvIGJlIHVzZWQgZm9yIHRpbWVzdGFtcCBiYXNlZCBoZnMgZXZlbiBpZiB3ZSBtYXkgYnVuZGxlXG4gICAgICAgICAgICAvLyBibG9jayBudW1iZXIgd2l0aCB0aGVtIHJldHJvc3BlY3RpdmVseVxuICAgICAgICAgICAgbGV0IGJsb2NrT3JUaW1lID0gdGltZXN0YW1wID8/IGJsb2NrO1xuICAgICAgICAgICAgYmxvY2tPclRpbWUgPSBibG9ja09yVGltZSAhPT0gbnVsbCA/IE51bWJlcihibG9ja09yVGltZSkgOiBudWxsO1xuICAgICAgICAgICAgLy8gU2tpcCBmb3IgY2hhaW5zdGFydCAoMCksIG5vdCBhcHBsaWVkIEhGcyAobnVsbCkgYW5kXG4gICAgICAgICAgICAvLyB3aGVuIGFscmVhZHkgYXBwbGllZCBvbiBzYW1lIGJsb2NrT3JUaW1lIEhGc1xuICAgICAgICAgICAgLy8gYW5kIG9uIHRoZSBtZXJnZSBzaW5jZSBmb3JraGFzaCBkb2Vzbid0IGNoYW5nZSBvbiBtZXJnZSBoZlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBibG9ja09yVGltZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBibG9ja09yVGltZSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgIGJsb2NrT3JUaW1lICE9PSBwcmV2QmxvY2tPclRpbWUgJiZcbiAgICAgICAgICAgICAgICBuYW1lICE9PSBlbnVtc18xLkhhcmRmb3JrLk1lcmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGZCbG9ja0J1ZmZlciA9IEJ1ZmZlci5mcm9tKGJsb2NrT3JUaW1lLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgxNiwgJzAnKSwgJ2hleCcpO1xuICAgICAgICAgICAgICAgIGhmQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbaGZCdWZmZXIsIGhmQmxvY2tCdWZmZXJdKTtcbiAgICAgICAgICAgICAgICBwcmV2QmxvY2tPclRpbWUgPSBibG9ja09yVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZi5uYW1lID09PSBoYXJkZm9yaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2dlbmVzaXNIYXNoLCBoZkJ1ZmZlcl0pO1xuICAgICAgICAvLyBDUkMzMiBkZWxpdmVycyByZXN1bHQgYXMgc2lnbmVkIChuZWdhdGl2ZSkgMzItYml0IGludGVnZXIsXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gaGV4IHN0cmluZ1xuICAgICAgICBjb25zdCBmb3JraGFzaCA9ICgwLCB1dGlsXzEuaW50VG9CdWZmZXIpKCgwLCBjcmNfMzJfMS5idWYpKGlucHV0QnVmZmVyKSA+Pj4gMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICByZXR1cm4gYDB4JHtmb3JraGFzaH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV0aC82NCBjb21wbGlhbnQgZm9yayBoYXNoIChFSVAtMjEyNClcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHBhcmFtIGdlbmVzaXNIYXNoIEdlbmVzaXMgYmxvY2sgaGFzaCBvZiB0aGUgY2hhaW4sIG9wdGlvbmFsIGlmIGFscmVhZHkgZGVmaW5lZCBhbmQgbm90IG5lZWRlZCB0byBiZSBjYWxjdWxhdGVkXG4gICAgICovXG4gICAgZm9ya0hhc2goaGFyZGZvcmssIGdlbmVzaXNIYXNoKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9nZXRIYXJkZm9yayhoYXJkZm9yayk7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8XG4gICAgICAgICAgICAoZGF0YT8uYmxvY2sgPT09IG51bGwgJiYgZGF0YT8udGltZXN0YW1wID09PSB1bmRlZmluZWQgJiYgZGF0YT8udHRkID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnTm8gZm9yayBoYXNoIGNhbGN1bGF0aW9uIHBvc3NpYmxlIGZvciBmdXR1cmUgaGFyZGZvcmsnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGE/LmZvcmtIYXNoICE9PSBudWxsICYmIGRhdGE/LmZvcmtIYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmZvcmtIYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2VuZXNpc0hhc2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVzaXNIYXNoIHJlcXVpcmVkIGZvciBmb3JrSGFzaCBjYWxjdWxhdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0ZvcmtIYXNoKGhhcmRmb3JrLCBnZW5lc2lzSGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmtIYXNoIEZvcmsgaGFzaCBhcyBhIGhleCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBBcnJheSB3aXRoIGhhcmRmb3JrIGRhdGEgKG5hbWUsIGJsb2NrLCBmb3JrSGFzaClcbiAgICAgKi9cbiAgICBoYXJkZm9ya0ZvckZvcmtIYXNoKGZvcmtIYXNoKSB7XG4gICAgICAgIGNvbnN0IHJlc0FycmF5ID0gdGhpcy5oYXJkZm9ya3MoKS5maWx0ZXIoKGhmKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaGYuZm9ya0hhc2ggPT09IGZvcmtIYXNoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc0FycmF5Lmxlbmd0aCA+PSAxID8gcmVzQXJyYXlbcmVzQXJyYXkubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFueSBtaXNzaW5nIGZvcmtIYXNoZXMgb24gdGhlIHBhc3NlZC1pbiB7QGxpbmsgQ29tbW9ufSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjb21tb24gVGhlIHtAbGluayBDb21tb259IHRvIHNldCB0aGUgZm9ya0hhc2hlcyBmb3JcbiAgICAgKiBAcGFyYW0gZ2VuZXNpc0hhc2ggVGhlIGdlbmVzaXMgYmxvY2sgaGFzaFxuICAgICAqL1xuICAgIHNldEZvcmtIYXNoZXMoZ2VuZXNpc0hhc2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBoZiBvZiB0aGlzLmhhcmRmb3JrcygpKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja09yVGltZSA9IGhmLnRpbWVzdGFtcCA/PyBoZi5ibG9jaztcbiAgICAgICAgICAgIGlmICgoaGYuZm9ya0hhc2ggPT09IG51bGwgfHwgaGYuZm9ya0hhc2ggPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICAgICAoKGJsb2NrT3JUaW1lICE9PSBudWxsICYmIGJsb2NrT3JUaW1lICE9PSB1bmRlZmluZWQpIHx8IHR5cGVvZiBoZi50dGQgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIGhmLmZvcmtIYXNoID0gdGhpcy5mb3JrSGFzaChoZi5uYW1lLCBnZW5lc2lzSGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgR2VuZXNpcyBwYXJhbWV0ZXJzIG9mIHRoZSBjdXJyZW50IGNoYWluXG4gICAgICogQHJldHVybnMgR2VuZXNpcyBkaWN0aW9uYXJ5XG4gICAgICovXG4gICAgZ2VuZXNpcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zLmdlbmVzaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhhcmRmb3JrcyBmb3IgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgd2l0aCBhcnJheXMgb2YgaGFyZGZvcmtzXG4gICAgICovXG4gICAgaGFyZGZvcmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXMuaGFyZGZvcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJvb3RzdHJhcCBub2RlcyBmb3IgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyB7RGljdGlvbmFyeX0gRGljdCB3aXRoIGJvb3RzdHJhcCBub2Rlc1xuICAgICAqL1xuICAgIGJvb3RzdHJhcE5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXMuYm9vdHN0cmFwTm9kZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgRE5TIG5ldHdvcmtzIGZvciB0aGUgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gQXJyYXkgb2YgRE5TIEVOUiB1cmxzXG4gICAgICovXG4gICAgZG5zTmV0d29ya3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpblBhcmFtcy5kbnNOZXR3b3JrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGFyZGZvcmsgc2V0XG4gICAgICogQHJldHVybnMgSGFyZGZvcmsgbmFtZVxuICAgICAqL1xuICAgIGhhcmRmb3JrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFyZGZvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElkIG9mIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyBjaGFpbiBJZFxuICAgICAqL1xuICAgIGNoYWluSWQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5fY2hhaW5QYXJhbXMuY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIGNoYWluIG5hbWUgKGxvd2VyIGNhc2UpXG4gICAgICovXG4gICAgY2hhaW5OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSWQgb2YgY3VycmVudCBuZXR3b3JrXG4gICAgICogQHJldHVybnMgbmV0d29yayBJZFxuICAgICAqL1xuICAgIG5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLl9jaGFpblBhcmFtcy5uZXR3b3JrSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgRUlQc1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgRUlQc1xuICAgICAqL1xuICAgIGVpcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9laXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25zZW5zdXMgdHlwZSBvZiB0aGUgbmV0d29ya1xuICAgICAqIFBvc3NpYmxlIHZhbHVlczogXCJwb3dcInxcInBvYVwifFwicG9zXCJcbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgdmFsdWUgY2FuIHVwZGF0ZSBhbG9uZyBhIEhhcmRmb3JrLlxuICAgICAqL1xuICAgIGNvbnNlbnN1c1R5cGUoKSB7XG4gICAgICAgIGNvbnN0IGhhcmRmb3JrID0gdGhpcy5oYXJkZm9yaygpO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgaGZDaGFuZ2VzIG9mIHRoaXMuSEFSREZPUktfQ0hBTkdFUykge1xuICAgICAgICAgICAgaWYgKCdjb25zZW5zdXMnIGluIGhmQ2hhbmdlc1sxXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaGZDaGFuZ2VzWzFdWydjb25zZW5zdXMnXVsndHlwZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1swXSA9PT0gaGFyZGZvcmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8/IHRoaXMuX2NoYWluUGFyYW1zWydjb25zZW5zdXMnXVsndHlwZSddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jcmV0ZSBjb25zZW5zdXMgaW1wbGVtZW50YXRpb25cbiAgICAgKiBhbGdvcml0aG0gb3IgcHJvdG9jb2wgZm9yIHRoZSBuZXR3b3JrXG4gICAgICogZS5nLiBcImV0aGFzaFwiIGZvciBcInBvd1wiIGNvbnNlbnN1cyB0eXBlLFxuICAgICAqIFwiY2xpcXVlXCIgZm9yIFwicG9hXCIgY29uc2Vuc3VzIHR5cGUgb3JcbiAgICAgKiBcImNhc3BlclwiIGZvciBcInBvc1wiIGNvbnNlbnN1cyB0eXBlLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyB2YWx1ZSBjYW4gdXBkYXRlIGFsb25nIGEgSGFyZGZvcmsuXG4gICAgICovXG4gICAgY29uc2Vuc3VzQWxnb3JpdGhtKCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuaGFyZGZvcmsoKTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGhmQ2hhbmdlcyBvZiB0aGlzLkhBUkRGT1JLX0NIQU5HRVMpIHtcbiAgICAgICAgICAgIGlmICgnY29uc2Vuc3VzJyBpbiBoZkNoYW5nZXNbMV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhmQ2hhbmdlc1sxXVsnY29uc2Vuc3VzJ11bJ2FsZ29yaXRobSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1swXSA9PT0gaGFyZGZvcmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8/IHRoaXMuX2NoYWluUGFyYW1zWydjb25zZW5zdXMnXVsnYWxnb3JpdGhtJ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IHdpdGggY29uc2Vuc3VzIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBwYXJhbWV0ZXJzIGJhc2VkIG9uIHRoZSBjb25zZW5zdXMgYWxnb3JpdGhtXG4gICAgICpcbiAgICAgKiBFeHBlY3RlZCByZXR1cm5zIChwYXJhbWV0ZXJzIG11c3QgYmUgcHJlc2VudCBpblxuICAgICAqIHRoZSByZXNwZWN0aXZlIGNoYWluIGpzb24gZmlsZXMpOlxuICAgICAqXG4gICAgICogZXRoYXNoOiBlbXB0eSBvYmplY3RcbiAgICAgKiBjbGlxdWU6IHBlcmlvZCwgZXBvY2hcbiAgICAgKiBjYXNwZXI6IGVtcHR5IG9iamVjdFxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyB2YWx1ZSBjYW4gdXBkYXRlIGFsb25nIGEgSGFyZGZvcmsuXG4gICAgICovXG4gICAgY29uc2Vuc3VzQ29uZmlnKCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuaGFyZGZvcmsoKTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGhmQ2hhbmdlcyBvZiB0aGlzLkhBUkRGT1JLX0NIQU5HRVMpIHtcbiAgICAgICAgICAgIGlmICgnY29uc2Vuc3VzJyBpbiBoZkNoYW5nZXNbMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIHBhcmFtZXRlciBpcyBuYW1lZCBhZnRlciB0aGUgcmVzcGVjdGl2ZSBjb25zZW5zdXMgYWxnb3JpdGhtXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoZkNoYW5nZXNbMV1bJ2NvbnNlbnN1cyddW2hmQ2hhbmdlc1sxXVsnY29uc2Vuc3VzJ11bJ2FsZ29yaXRobSddXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZkNoYW5nZXNbMF0gPT09IGhhcmRmb3JrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmFsdWUgPz8gdGhpcy5fY2hhaW5QYXJhbXNbJ2NvbnNlbnN1cyddW3RoaXMuY29uc2Vuc3VzQWxnb3JpdGhtKCldID8/IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGlzIHtAbGluayBDb21tb259IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKSwgdGhpcyk7XG4gICAgICAgIGNvcHkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBzdGF0aWMgX2dldEluaXRpYWxpemVkQ2hhaW5zKGN1c3RvbUNoYWlucykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBpZF0gb2YgT2JqZWN0LmVudHJpZXMoZW51bXNfMS5DaGFpbikpIHtcbiAgICAgICAgICAgIG5hbWVzW2lkXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFpbnMgPSB7IG1haW5uZXQsIHJvcHN0ZW4sIHJpbmtlYnksIGdvZXJsaSwgc2Vwb2xpYSB9O1xuICAgICAgICBpZiAoY3VzdG9tQ2hhaW5zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIGN1c3RvbUNoYWlucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gY2hhaW47XG4gICAgICAgICAgICAgICAgbmFtZXNbY2hhaW4uY2hhaW5JZC50b1N0cmluZygpXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgY2hhaW5zW25hbWVdID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhaW5zLm5hbWVzID0gbmFtZXM7XG4gICAgICAgIHJldHVybiBjaGFpbnM7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tb24gPSBDb21tb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0xMTUzXCIsXG4gICAgXCJudW1iZXJcIjogMTE1MyxcbiAgICBcImNvbW1lbnRcIjogXCJUcmFuc2llbnQgU3RvcmFnZVwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTUzXCIsXG4gICAgXCJzdGF0dXNcIjogXCJSZXZpZXdcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImNoYWluc3RhcnRcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwidHN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgVFNUT1JFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGxvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBUTE9BRCBvcGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTE1NTlcIixcbiAgICBcIm51bWJlclwiOiAxNTU5LFxuICAgIFwiY29tbWVudFwiOiBcIkZlZSBtYXJrZXQgY2hhbmdlIGZvciBFVEggMS4wIGNoYWluXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NTlcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJiZXJsaW5cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMjkzMF0sXG4gICAgXCJnYXNDb25maWdcIjoge1xuICAgICAgICBcImJhc2VGZWVNYXhDaGFuZ2VEZW5vbWluYXRvclwiOiB7XG4gICAgICAgICAgICBcInZcIjogOCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk1heGltdW0gYmFzZSBmZWUgY2hhbmdlIGRlbm9taW5hdG9yXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlbGFzdGljaXR5TXVsdGlwbGllclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIk1heGltdW0gYmxvY2sgZ2FzIHRhcmdldCBlbGFzdGljaXR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbml0aWFsQmFzZUZlZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwMDAwMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkluaXRpYWwgYmFzZSBmZWUgb24gZmlyc3QgRUlQMTU1OSBibG9ja1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjMxNVwiLFxuICAgIFwibnVtYmVyXCI6IDIzMTUsXG4gICAgXCJjb21tZW50XCI6IFwiU2ltcGxlIHN1YnJvdXRpbmVzIGZvciB0aGUgRVZNXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTIzMTVcIixcbiAgICBcInN0YXR1c1wiOiBcIkRyYWZ0XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJpc3RhbmJ1bFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJiZWdpbnN1YlwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCRUdJTlNVQiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInJldHVybnN1YlwiOiB7XG4gICAgICAgICAgICBcInZcIjogNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBSRVRVUk5TVUIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJqdW1wc3ViXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBKVU1QU1VCIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjUzN1wiLFxuICAgIFwibnVtYmVyXCI6IDI1MzcsXG4gICAgXCJjb21tZW50XCI6IFwiQkxTMTItMzgxIHByZWNvbXBpbGVzXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI1MzdcIixcbiAgICBcInN0YXR1c1wiOiBcIkRyYWZ0XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcIkJsczEyMzgxRzFBZGRHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDYwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IG9mIGEgc2luZ2xlIEJMUzEyLTM4MSBHMSBhZGRpdGlvbiBwcmVjb21waWxlLWNhbGxcIlxuICAgICAgICB9LFxuICAgICAgICBcIkJsczEyMzgxRzFNdWxHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEyMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgYSBzaW5nbGUgQkxTMTItMzgxIEcxIG11bHRpcGxpY2F0aW9uIHByZWNvbXBpbGUtY2FsbFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFHMkFkZEdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogNDUwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IG9mIGEgc2luZ2xlIEJMUzEyLTM4MSBHMiBhZGRpdGlvbiBwcmVjb21waWxlLWNhbGxcIlxuICAgICAgICB9LFxuICAgICAgICBcIkJsczEyMzgxRzJNdWxHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDU1MDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgYSBzaW5nbGUgQkxTMTItMzgxIEcyIG11bHRpcGxpY2F0aW9uIHByZWNvbXBpbGUtY2FsbFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFQYWlyaW5nQmFzZUdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMTE1MDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBnYXMgY29zdCBvZiBCTFMxMi0zODEgcGFpcmluZyBjaGVja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFQYWlyaW5nUGVyUGFpckdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMjMwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJQZXItcGFpciBnYXMgY29zdCBvZiBCTFMxMi0zODEgcGFpcmluZyBjaGVja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFNYXBHMUdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogNTUwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IG9mIEJMUzEyLTM4MSBtYXAgZmllbGQgZWxlbWVudCB0byBHMVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFNYXBHMkdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMTEwMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgQkxTMTItMzgxIG1hcCBmaWVsZCBlbGVtZW50IHRvIEcyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJCbHMxMjM4MU11bHRpRXhwR2FzRGlzY291bnRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IFtcbiAgICAgICAgICAgICAgICBbMSwgMTIwMF0sXG4gICAgICAgICAgICAgICAgWzIsIDg4OF0sXG4gICAgICAgICAgICAgICAgWzMsIDc2NF0sXG4gICAgICAgICAgICAgICAgWzQsIDY0MV0sXG4gICAgICAgICAgICAgICAgWzUsIDU5NF0sXG4gICAgICAgICAgICAgICAgWzYsIDU0N10sXG4gICAgICAgICAgICAgICAgWzcsIDUwMF0sXG4gICAgICAgICAgICAgICAgWzgsIDQ1M10sXG4gICAgICAgICAgICAgICAgWzksIDQzOF0sXG4gICAgICAgICAgICAgICAgWzEwLCA0MjNdLFxuICAgICAgICAgICAgICAgIFsxMSwgNDA4XSxcbiAgICAgICAgICAgICAgICBbMTIsIDM5NF0sXG4gICAgICAgICAgICAgICAgWzEzLCAzNzldLFxuICAgICAgICAgICAgICAgIFsxNCwgMzY0XSxcbiAgICAgICAgICAgICAgICBbMTUsIDM0OV0sXG4gICAgICAgICAgICAgICAgWzE2LCAzMzRdLFxuICAgICAgICAgICAgICAgIFsxNywgMzMwXSxcbiAgICAgICAgICAgICAgICBbMTgsIDMyNl0sXG4gICAgICAgICAgICAgICAgWzE5LCAzMjJdLFxuICAgICAgICAgICAgICAgIFsyMCwgMzE4XSxcbiAgICAgICAgICAgICAgICBbMjEsIDMxNF0sXG4gICAgICAgICAgICAgICAgWzIyLCAzMTBdLFxuICAgICAgICAgICAgICAgIFsyMywgMzA2XSxcbiAgICAgICAgICAgICAgICBbMjQsIDMwMl0sXG4gICAgICAgICAgICAgICAgWzI1LCAyOThdLFxuICAgICAgICAgICAgICAgIFsyNiwgMjk0XSxcbiAgICAgICAgICAgICAgICBbMjcsIDI4OV0sXG4gICAgICAgICAgICAgICAgWzI4LCAyODVdLFxuICAgICAgICAgICAgICAgIFsyOSwgMjgxXSxcbiAgICAgICAgICAgICAgICBbMzAsIDI3N10sXG4gICAgICAgICAgICAgICAgWzMxLCAyNzNdLFxuICAgICAgICAgICAgICAgIFszMiwgMjY5XSxcbiAgICAgICAgICAgICAgICBbMzMsIDI2OF0sXG4gICAgICAgICAgICAgICAgWzM0LCAyNjZdLFxuICAgICAgICAgICAgICAgIFszNSwgMjY1XSxcbiAgICAgICAgICAgICAgICBbMzYsIDI2M10sXG4gICAgICAgICAgICAgICAgWzM3LCAyNjJdLFxuICAgICAgICAgICAgICAgIFszOCwgMjYwXSxcbiAgICAgICAgICAgICAgICBbMzksIDI1OV0sXG4gICAgICAgICAgICAgICAgWzQwLCAyNTddLFxuICAgICAgICAgICAgICAgIFs0MSwgMjU2XSxcbiAgICAgICAgICAgICAgICBbNDIsIDI1NF0sXG4gICAgICAgICAgICAgICAgWzQzLCAyNTNdLFxuICAgICAgICAgICAgICAgIFs0NCwgMjUxXSxcbiAgICAgICAgICAgICAgICBbNDUsIDI1MF0sXG4gICAgICAgICAgICAgICAgWzQ2LCAyNDhdLFxuICAgICAgICAgICAgICAgIFs0NywgMjQ3XSxcbiAgICAgICAgICAgICAgICBbNDgsIDI0NV0sXG4gICAgICAgICAgICAgICAgWzQ5LCAyNDRdLFxuICAgICAgICAgICAgICAgIFs1MCwgMjQyXSxcbiAgICAgICAgICAgICAgICBbNTEsIDI0MV0sXG4gICAgICAgICAgICAgICAgWzUyLCAyMzldLFxuICAgICAgICAgICAgICAgIFs1MywgMjM4XSxcbiAgICAgICAgICAgICAgICBbNTQsIDIzNl0sXG4gICAgICAgICAgICAgICAgWzU1LCAyMzVdLFxuICAgICAgICAgICAgICAgIFs1NiwgMjMzXSxcbiAgICAgICAgICAgICAgICBbNTcsIDIzMl0sXG4gICAgICAgICAgICAgICAgWzU4LCAyMzFdLFxuICAgICAgICAgICAgICAgIFs1OSwgMjI5XSxcbiAgICAgICAgICAgICAgICBbNjAsIDIyOF0sXG4gICAgICAgICAgICAgICAgWzYxLCAyMjZdLFxuICAgICAgICAgICAgICAgIFs2MiwgMjI1XSxcbiAgICAgICAgICAgICAgICBbNjMsIDIyM10sXG4gICAgICAgICAgICAgICAgWzY0LCAyMjJdLFxuICAgICAgICAgICAgICAgIFs2NSwgMjIxXSxcbiAgICAgICAgICAgICAgICBbNjYsIDIyMF0sXG4gICAgICAgICAgICAgICAgWzY3LCAyMTldLFxuICAgICAgICAgICAgICAgIFs2OCwgMjE5XSxcbiAgICAgICAgICAgICAgICBbNjksIDIxOF0sXG4gICAgICAgICAgICAgICAgWzcwLCAyMTddLFxuICAgICAgICAgICAgICAgIFs3MSwgMjE2XSxcbiAgICAgICAgICAgICAgICBbNzIsIDIxNl0sXG4gICAgICAgICAgICAgICAgWzczLCAyMTVdLFxuICAgICAgICAgICAgICAgIFs3NCwgMjE0XSxcbiAgICAgICAgICAgICAgICBbNzUsIDIxM10sXG4gICAgICAgICAgICAgICAgWzc2LCAyMTNdLFxuICAgICAgICAgICAgICAgIFs3NywgMjEyXSxcbiAgICAgICAgICAgICAgICBbNzgsIDIxMV0sXG4gICAgICAgICAgICAgICAgWzc5LCAyMTFdLFxuICAgICAgICAgICAgICAgIFs4MCwgMjEwXSxcbiAgICAgICAgICAgICAgICBbODEsIDIwOV0sXG4gICAgICAgICAgICAgICAgWzgyLCAyMDhdLFxuICAgICAgICAgICAgICAgIFs4MywgMjA4XSxcbiAgICAgICAgICAgICAgICBbODQsIDIwN10sXG4gICAgICAgICAgICAgICAgWzg1LCAyMDZdLFxuICAgICAgICAgICAgICAgIFs4NiwgMjA1XSxcbiAgICAgICAgICAgICAgICBbODcsIDIwNV0sXG4gICAgICAgICAgICAgICAgWzg4LCAyMDRdLFxuICAgICAgICAgICAgICAgIFs4OSwgMjAzXSxcbiAgICAgICAgICAgICAgICBbOTAsIDIwMl0sXG4gICAgICAgICAgICAgICAgWzkxLCAyMDJdLFxuICAgICAgICAgICAgICAgIFs5MiwgMjAxXSxcbiAgICAgICAgICAgICAgICBbOTMsIDIwMF0sXG4gICAgICAgICAgICAgICAgWzk0LCAxOTldLFxuICAgICAgICAgICAgICAgIFs5NSwgMTk5XSxcbiAgICAgICAgICAgICAgICBbOTYsIDE5OF0sXG4gICAgICAgICAgICAgICAgWzk3LCAxOTddLFxuICAgICAgICAgICAgICAgIFs5OCwgMTk2XSxcbiAgICAgICAgICAgICAgICBbOTksIDE5Nl0sXG4gICAgICAgICAgICAgICAgWzEwMCwgMTk1XSxcbiAgICAgICAgICAgICAgICBbMTAxLCAxOTRdLFxuICAgICAgICAgICAgICAgIFsxMDIsIDE5M10sXG4gICAgICAgICAgICAgICAgWzEwMywgMTkzXSxcbiAgICAgICAgICAgICAgICBbMTA0LCAxOTJdLFxuICAgICAgICAgICAgICAgIFsxMDUsIDE5MV0sXG4gICAgICAgICAgICAgICAgWzEwNiwgMTkxXSxcbiAgICAgICAgICAgICAgICBbMTA3LCAxOTBdLFxuICAgICAgICAgICAgICAgIFsxMDgsIDE4OV0sXG4gICAgICAgICAgICAgICAgWzEwOSwgMTg4XSxcbiAgICAgICAgICAgICAgICBbMTEwLCAxODhdLFxuICAgICAgICAgICAgICAgIFsxMTEsIDE4N10sXG4gICAgICAgICAgICAgICAgWzExMiwgMTg2XSxcbiAgICAgICAgICAgICAgICBbMTEzLCAxODVdLFxuICAgICAgICAgICAgICAgIFsxMTQsIDE4NV0sXG4gICAgICAgICAgICAgICAgWzExNSwgMTg0XSxcbiAgICAgICAgICAgICAgICBbMTE2LCAxODNdLFxuICAgICAgICAgICAgICAgIFsxMTcsIDE4Ml0sXG4gICAgICAgICAgICAgICAgWzExOCwgMTgyXSxcbiAgICAgICAgICAgICAgICBbMTE5LCAxODFdLFxuICAgICAgICAgICAgICAgIFsxMjAsIDE4MF0sXG4gICAgICAgICAgICAgICAgWzEyMSwgMTc5XSxcbiAgICAgICAgICAgICAgICBbMTIyLCAxNzldLFxuICAgICAgICAgICAgICAgIFsxMjMsIDE3OF0sXG4gICAgICAgICAgICAgICAgWzEyNCwgMTc3XSxcbiAgICAgICAgICAgICAgICBbMTI1LCAxNzZdLFxuICAgICAgICAgICAgICAgIFsxMjYsIDE3Nl0sXG4gICAgICAgICAgICAgICAgWzEyNywgMTc1XSxcbiAgICAgICAgICAgICAgICBbMTI4LCAxNzRdXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkXCI6IFwiRGlzY291bnQgZ2FzIGNvc3RzIG9mIGNhbGxzIHRvIHRoZSBNdWx0aUV4cCBwcmVjb21waWxlcyB3aXRoIGBrYCAocG9pbnQsIHNjYWxhcikgcGFpclwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjU2NVwiLFxuICAgIFwibnVtYmVyXCI6IDI1NjUsXG4gICAgXCJjb21tZW50XCI6IFwiTW9kRXhwIGdhcyBjb3N0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI1NjVcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJieXphbnRpdW1cIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwibW9kZXhwR3F1YWRkaXZpc29yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiR3F1YWRkaXZpc29yIGZyb20gbW9kZXhwIHByZWNvbXBpbGUgZm9yIGdhcyBjYWxjdWxhdGlvblwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjcxOFwiLFxuICAgIFwiY29tbWVudFwiOiBcIlR5cGVkIFRyYW5zYWN0aW9uIEVudmVsb3BlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI3MThcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0yOTI5XCIsXG4gICAgXCJjb21tZW50XCI6IFwiR2FzIGNvc3QgaW5jcmVhc2VzIGZvciBzdGF0ZSBhY2Nlc3Mgb3Bjb2Rlc1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yOTI5XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJjb2xkc2xvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIxMDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBvZiB0aGUgZmlyc3QgcmVhZCBvZiBzdG9yYWdlIGZyb20gYSBnaXZlbiBsb2NhdGlvbiAocGVyIHRyYW5zYWN0aW9uKVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sZGFjY291bnRhY2Nlc3NcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDI2MDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBvZiB0aGUgZmlyc3QgcmVhZCBvZiBhIGdpdmVuIGFkZHJlc3MgKHBlciB0cmFuc2FjdGlvbilcIlxuICAgICAgICB9LFxuICAgICAgICBcIndhcm1zdG9yYWdlcmVhZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgcmVhZGluZyBzdG9yYWdlIGxvY2F0aW9ucyB3aGljaCBoYXZlIGFscmVhZHkgbG9hZGVkICdjb2xkJ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlQ2xlYW5HYXNFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyOTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmcm9tIGNsZWFuIG5vbi16ZXJvIHRvIHNvbWV0aGluZyBlbHNlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVOb29wR2FzRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBpZiB0aGUgdmFsdWUgZG9lc24ndCBjaGFuZ2VcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZURpcnR5R2FzRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBpZiBhIGRpcnR5IHZhbHVlIGlzIGNoYW5nZWRcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZUluaXRSZWZ1bmRFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxOTkwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIHJlc2V0dGluZyB0byB0aGUgb3JpZ2luYWwgemVybyB2YWx1ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlQ2xlYW5SZWZ1bmRFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0OTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmb3IgcmVzZXR0aW5nIHRvIHRoZSBvcmlnaW5hbCBub24temVybyB2YWx1ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbGNvZGVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTENPREUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWxlZ2F0ZWNhbGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgREVMRUdBVEVDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3RhdGljY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTVEFUSUNDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmFsYW5jZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCQUxBTkNFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRVhUQ09ERVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRjb2RlY29weVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBFWFRDT0RFQ09QWSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImV4dGNvZGVoYXNoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVIQVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2xvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0xPQUQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU1NUT1JFIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjkzMFwiLFxuICAgIFwiY29tbWVudFwiOiBcIk9wdGlvbmFsIGFjY2VzcyBsaXN0c1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yOTMwXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwiaXN0YW5idWxcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMjcxOCwgMjkyOV0sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImFjY2Vzc0xpc3RTdG9yYWdlS2V5Q29zdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTkwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IHBlciBzdG9yYWdlIGtleSBpbiBhbiBBY2Nlc3MgTGlzdCB0cmFuc2FjdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWNjZXNzTGlzdEFkZHJlc3NDb3N0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyNDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3QgcGVyIHN0b3JhZ2Uga2V5IGluIGFuIEFjY2VzcyBMaXN0IHRyYW5zYWN0aW9uXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zMDc0XCIsXG4gICAgXCJudW1iZXJcIjogMzA3NCxcbiAgICBcImNvbW1lbnRcIjogXCJBVVRIIGFuZCBBVVRIQ0FMTCBvcGNvZGVzXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTMwNzRcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImF1dGhcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMxMDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBvZiB0aGUgQVVUSCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImF1dGhjYWxsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgdGhlIEFVVEhDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYXV0aGNhbGxWYWx1ZVRyYW5zZmVyXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA2NzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiUGFpZCBmb3IgQ0FMTCB3aGVuIHRoZSB2YWx1ZSB0cmFuc2ZlciBpcyBub24temVyb1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzE5OFwiLFxuICAgIFwibnVtYmVyXCI6IDMxOTgsXG4gICAgXCJjb21tZW50XCI6IFwiQkFTRUZFRSBvcGNvZGVcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzE5OFwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJiYXNlZmVlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgdGhlIEJBU0VGRUUgb3Bjb2RlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zNTI5XCIsXG4gICAgXCJjb21tZW50XCI6IFwiUmVkdWN0aW9uIGluIHJlZnVuZHNcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzUyOVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImJlcmxpblwiLFxuICAgIFwicmVxdWlyZWRFSVBzXCI6IFsyOTI5XSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7XG4gICAgICAgIFwibWF4UmVmdW5kUXVvdGllbnRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIHJlZnVuZCBxdW90aWVudDsgbWF4IHR4IHJlZnVuZCBpcyBtaW4odHguZ2FzVXNlZC9tYXhSZWZ1bmRRdW90aWVudCwgdHguZ2FzUmVmdW5kKVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJzZWxmZGVzdHJ1Y3RSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJSZWZ1bmRlZCBmb2xsb3dpbmcgYSBzZWxmZGVzdHJ1Y3Qgb3BlcmF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVDbGVhclJlZnVuZEVJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDQ4MDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZvciBjbGVhcmluZyBhbiBvcmlnaW5hbGx5IGV4aXN0aW5nIHN0b3JhZ2Ugc2xvdFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzU0MFwiLFxuICAgIFwibnVtYmVyXCI6IDM1NDAsXG4gICAgXCJjb21tZW50XCI6IFwiRVZNIE9iamVjdCBGb3JtYXQgKEVPRikgdjFcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzU0MFwiLFxuICAgIFwic3RhdHVzXCI6IFwiUmV2aWV3XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJsb25kb25cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMzU0MV0sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zNTQxXCIsXG4gICAgXCJjb21tZW50XCI6IFwiUmVqZWN0IG5ldyBjb250cmFjdHMgc3RhcnRpbmcgd2l0aCB0aGUgMHhFRiBieXRlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM1NDFcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJiZXJsaW5cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTM1NTRcIixcbiAgICBcImNvbW1lbnRcIjogXCJSZWR1Y3Rpb24gaW4gcmVmdW5kc1wiLFxuICAgIFwidXJsXCI6IFwiRGlmZmljdWx0eSBCb21iIERlbGF5IHRvIERlY2VtYmVyIDFzdCAyMDIxXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibXVpckdsYWNpZXJcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJkaWZmaWN1bHR5Qm9tYkRlbGF5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA5NTAwMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwidGhlIGFtb3VudCBvZiBibG9ja3MgdG8gZGVsYXkgdGhlIGRpZmZpY3VsdHkgYm9tYiB3aXRoXCJcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzYwN1wiLFxuICAgIFwibnVtYmVyXCI6IDM2MDcsXG4gICAgXCJjb21tZW50XCI6IFwiUmVqZWN0IHRyYW5zYWN0aW9ucyBmcm9tIHNlbmRlcnMgd2l0aCBkZXBsb3llZCBjb2RlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM2MDdcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogW10sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zNjUxXCIsXG4gICAgXCJudW1iZXJcIjogMzE5OCxcbiAgICBcImNvbW1lbnRcIjogXCJXYXJtIENPSU5CQVNFXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM2NTFcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogWzI5MjldLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzY3MFwiLFxuICAgIFwibnVtYmVyXCI6IDM2NzAsXG4gICAgXCJjb21tZW50XCI6IFwiRU9GIC0gQ29kZSBWYWxpZGF0aW9uXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM2NzBcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogWzM1NDBdLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzY3NVwiLFxuICAgIFwibnVtYmVyXCI6IDM2NzUsXG4gICAgXCJjb21tZW50XCI6IFwiVXBncmFkZSBjb25zZW5zdXMgdG8gUHJvb2Ytb2YtU3Rha2VcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzY3NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwicmVxdWlyZWRFSVBzXCI6IFtdLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzg1NVwiLFxuICAgIFwibnVtYmVyXCI6IDM4NTUsXG4gICAgXCJjb21tZW50XCI6IFwiUFVTSDAgaW5zdHJ1Y3Rpb25cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzg1NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiUmV2aWV3XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogW10sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcInB1c2gwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFBVU0gwIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzg2MFwiLFxuICAgIFwibnVtYmVyXCI6IDM4NjAsXG4gICAgXCJjb21tZW50XCI6IFwiTGltaXQgYW5kIG1ldGVyIGluaXRjb2RlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM4NjBcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwic3B1cmlvdXNEcmFnb25cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwiaW5pdENvZGVXb3JkQ29zdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyB0byBwYXkgZm9yIGVhY2ggd29yZCAoMzIgYnl0ZXMpIG9mIGluaXRjb2RlIHdoZW4gY3JlYXRpbmcgYSBjb250cmFjdFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge1xuICAgICAgICBcIm1heEluaXRDb2RlU2l6ZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDkxNTIsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIGxlbmd0aCBvZiBpbml0aWFsaXphdGlvbiBjb2RlIHdoZW4gY3JlYXRpbmcgYSBjb250cmFjdFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTQzNDVcIixcbiAgICBcIm51bWJlclwiOiA0MzQ1LFxuICAgIFwiY29tbWVudFwiOiBcIkRpZmZpY3VsdHkgQm9tYiBEZWxheSB0byBKdW5lIDIwMjJcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM0NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge1xuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwNzAwMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwidGhlIGFtb3VudCBvZiBibG9ja3MgdG8gZGVsYXkgdGhlIGRpZmZpY3VsdHkgYm9tYiB3aXRoXCJcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtNDM5OVwiLFxuICAgIFwibnVtYmVyXCI6IDQzOTksXG4gICAgXCJjb21tZW50XCI6IFwiU3VwcGxhbnQgRElGRklDVUxUWSBvcGNvZGUgd2l0aCBQUkVWUkFOREFPXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQzOTlcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogW10sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC00ODQ0XCIsXG4gICAgXCJudW1iZXJcIjogNDg0NCxcbiAgICBcImNvbW1lbnRcIjogXCJTaGFyZCBCbG9iIFRyYW5zYWN0aW9uc1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC00ODQ0XCIsXG4gICAgXCJzdGF0dXNcIjogXCJEcmFmdFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibWVyZ2VcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMTU1OSwgMjcxOCwgMjkzMCwgNDg5NV0sXG4gICAgXCJnYXNDb25maWdcIjoge1xuICAgICAgICBcImRhdGFHYXNQZXJCbG9iXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMzEwNzIsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgYmFzZSBmZWUgZm9yIGRhdGEgZ2FzIHBlciBibG9iXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0YXJnZXREYXRhR2FzUGVyQmxvY2tcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDI2MjE0NCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSB0YXJnZXQgZGF0YSBnYXMgY29uc3VtZWQgcGVyIGJsb2NrXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhEYXRhR2FzUGVyQmxvY2tcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUyNDI4OCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBtYXggZGF0YSBnYXMgYWxsb3dhYmxlIHBlciBibG9ja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YUdhc1ByaWNlVXBkYXRlRnJhY3Rpb25cIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIyMjU2NTIsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgZGVub21pbmF0b3IgdXNlZCBpbiB0aGUgZXhwb25lbnRpYWwgd2hlbiBjYWxjdWxhdGluZyBhIGRhdGEgZ2FzIHByaWNlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcInNpbXBsZUdhc1BlckJsb2JcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEyMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGhlIGJhc2ljIGdhcyBmZWUgZm9yIGVhY2ggYmxvYlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWluRGF0YUdhc1ByaWNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGhlIG1pbmltdW0gZmVlIHBlciBkYXRhIGdhc1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwia3pnUG9pbnRFdmFsdWF0aW9uR2FzUHJlY29tcGlsZVByaWNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1MDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBmZWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb2ludCBldmFsdWF0aW9uIHByZWNvbXBpbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGFoYXNoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIERBVEFIQVNIIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwic2hhcmRpbmdcIjoge1xuICAgICAgICBcImJsb2JDb21taXRtZW50VmVyc2lvbkt6Z1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMSxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBudW1iZXIgaW5kaWNhdGVkIGEgdmVyc2lvbmVkIGhhc2ggaXMgYSBLWkcgY29tbWl0bWVudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmllbGRFbGVtZW50c1BlckJsb2JcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDQwOTYsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzIGFsbG93ZWQgcGVyIGJsb2JcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTQ4OTVcIixcbiAgICBcIm51bWJlclwiOiA0ODk1LFxuICAgIFwiY29tbWVudFwiOiBcIkJlYWNvbiBjaGFpbiBwdXNoIHdpdGhkcmF3YWxzIGFzIG9wZXJhdGlvbnNcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDg5NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiUmV2aWV3XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJtZXJnZVwiLFxuICAgIFwicmVxdWlyZWRFSVBzXCI6IFtdLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtNTEzM1wiLFxuICAgIFwibnVtYmVyXCI6IDUxMzMsXG4gICAgXCJjb21tZW50XCI6IFwiRGVsYXlpbmcgRGlmZmljdWx0eSBCb21iIHRvIG1pZC1TZXB0ZW1iZXIgMjAyMlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC01MTMzXCIsXG4gICAgXCJzdGF0dXNcIjogXCJEcmFmdFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwiZ3JheUdsYWNpZXJcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJkaWZmaWN1bHR5Qm9tYkRlbGF5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMTQwMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcInRoZSBhbW91bnQgb2YgYmxvY2tzIHRvIGRlbGF5IHRoZSBkaWZmaWN1bHR5IGJvbWIgd2l0aFwiXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRUlQcyA9IHZvaWQgMDtcbmV4cG9ydHMuRUlQcyA9IHtcbiAgICAxMTUzOiByZXF1aXJlKCcuLzExNTMuanNvbicpLFxuICAgIDE1NTk6IHJlcXVpcmUoJy4vMTU1OS5qc29uJyksXG4gICAgMjMxNTogcmVxdWlyZSgnLi8yMzE1Lmpzb24nKSxcbiAgICAyNTM3OiByZXF1aXJlKCcuLzI1MzcuanNvbicpLFxuICAgIDI1NjU6IHJlcXVpcmUoJy4vMjU2NS5qc29uJyksXG4gICAgMjcxODogcmVxdWlyZSgnLi8yNzE4Lmpzb24nKSxcbiAgICAyOTI5OiByZXF1aXJlKCcuLzI5MjkuanNvbicpLFxuICAgIDI5MzA6IHJlcXVpcmUoJy4vMjkzMC5qc29uJyksXG4gICAgMzA3NDogcmVxdWlyZSgnLi8zMDc0Lmpzb24nKSxcbiAgICAzMTk4OiByZXF1aXJlKCcuLzMxOTguanNvbicpLFxuICAgIDM1Mjk6IHJlcXVpcmUoJy4vMzUyOS5qc29uJyksXG4gICAgMzU0MDogcmVxdWlyZSgnLi8zNTQwLmpzb24nKSxcbiAgICAzNTQxOiByZXF1aXJlKCcuLzM1NDEuanNvbicpLFxuICAgIDM1NTQ6IHJlcXVpcmUoJy4vMzU1NC5qc29uJyksXG4gICAgMzYwNzogcmVxdWlyZSgnLi8zNjA3Lmpzb24nKSxcbiAgICAzNjUxOiByZXF1aXJlKCcuLzM2NTEuanNvbicpLFxuICAgIDM2NzA6IHJlcXVpcmUoJy4vMzY3MC5qc29uJyksXG4gICAgMzY3NTogcmVxdWlyZSgnLi8zNjc1Lmpzb24nKSxcbiAgICAzODU1OiByZXF1aXJlKCcuLzM4NTUuanNvbicpLFxuICAgIDM4NjA6IHJlcXVpcmUoJy4vMzg2MC5qc29uJyksXG4gICAgNDM0NTogcmVxdWlyZSgnLi80MzQ1Lmpzb24nKSxcbiAgICA0Mzk5OiByZXF1aXJlKCcuLzQzOTkuanNvbicpLFxuICAgIDQ4NDQ6IHJlcXVpcmUoJy4vNDg0NC5qc29uJyksXG4gICAgNDg5NTogcmVxdWlyZSgnLi80ODk1Lmpzb24nKSxcbiAgICA1MTMzOiByZXF1aXJlKCcuLzUxMzMuanNvbicpLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DdXN0b21DaGFpbiA9IGV4cG9ydHMuQ29uc2Vuc3VzQWxnb3JpdGhtID0gZXhwb3J0cy5Db25zZW5zdXNUeXBlID0gZXhwb3J0cy5IYXJkZm9yayA9IGV4cG9ydHMuQ2hhaW4gPSB2b2lkIDA7XG52YXIgQ2hhaW47XG4oZnVuY3Rpb24gKENoYWluKSB7XG4gICAgQ2hhaW5bQ2hhaW5bXCJNYWlubmV0XCJdID0gMV0gPSBcIk1haW5uZXRcIjtcbiAgICBDaGFpbltDaGFpbltcIlJvcHN0ZW5cIl0gPSAzXSA9IFwiUm9wc3RlblwiO1xuICAgIENoYWluW0NoYWluW1wiUmlua2VieVwiXSA9IDRdID0gXCJSaW5rZWJ5XCI7XG4gICAgQ2hhaW5bQ2hhaW5bXCJHb2VybGlcIl0gPSA1XSA9IFwiR29lcmxpXCI7XG4gICAgQ2hhaW5bQ2hhaW5bXCJTZXBvbGlhXCJdID0gMTExNTUxMTFdID0gXCJTZXBvbGlhXCI7XG59KShDaGFpbiA9IGV4cG9ydHMuQ2hhaW4gfHwgKGV4cG9ydHMuQ2hhaW4gPSB7fSkpO1xudmFyIEhhcmRmb3JrO1xuKGZ1bmN0aW9uIChIYXJkZm9yaykge1xuICAgIEhhcmRmb3JrW1wiQ2hhaW5zdGFydFwiXSA9IFwiY2hhaW5zdGFydFwiO1xuICAgIEhhcmRmb3JrW1wiSG9tZXN0ZWFkXCJdID0gXCJob21lc3RlYWRcIjtcbiAgICBIYXJkZm9ya1tcIkRhb1wiXSA9IFwiZGFvXCI7XG4gICAgSGFyZGZvcmtbXCJUYW5nZXJpbmVXaGlzdGxlXCJdID0gXCJ0YW5nZXJpbmVXaGlzdGxlXCI7XG4gICAgSGFyZGZvcmtbXCJTcHVyaW91c0RyYWdvblwiXSA9IFwic3B1cmlvdXNEcmFnb25cIjtcbiAgICBIYXJkZm9ya1tcIkJ5emFudGl1bVwiXSA9IFwiYnl6YW50aXVtXCI7XG4gICAgSGFyZGZvcmtbXCJDb25zdGFudGlub3BsZVwiXSA9IFwiY29uc3RhbnRpbm9wbGVcIjtcbiAgICBIYXJkZm9ya1tcIlBldGVyc2J1cmdcIl0gPSBcInBldGVyc2J1cmdcIjtcbiAgICBIYXJkZm9ya1tcIklzdGFuYnVsXCJdID0gXCJpc3RhbmJ1bFwiO1xuICAgIEhhcmRmb3JrW1wiTXVpckdsYWNpZXJcIl0gPSBcIm11aXJHbGFjaWVyXCI7XG4gICAgSGFyZGZvcmtbXCJCZXJsaW5cIl0gPSBcImJlcmxpblwiO1xuICAgIEhhcmRmb3JrW1wiTG9uZG9uXCJdID0gXCJsb25kb25cIjtcbiAgICBIYXJkZm9ya1tcIkFycm93R2xhY2llclwiXSA9IFwiYXJyb3dHbGFjaWVyXCI7XG4gICAgSGFyZGZvcmtbXCJHcmF5R2xhY2llclwiXSA9IFwiZ3JheUdsYWNpZXJcIjtcbiAgICBIYXJkZm9ya1tcIk1lcmdlRm9ya0lkVHJhbnNpdGlvblwiXSA9IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCI7XG4gICAgSGFyZGZvcmtbXCJNZXJnZVwiXSA9IFwibWVyZ2VcIjtcbiAgICBIYXJkZm9ya1tcIlNoYW5naGFpXCJdID0gXCJzaGFuZ2hhaVwiO1xuICAgIEhhcmRmb3JrW1wiU2hhcmRpbmdGb3JrRGV2XCJdID0gXCJzaGFyZGluZ0ZvcmtcIjtcbn0pKEhhcmRmb3JrID0gZXhwb3J0cy5IYXJkZm9yayB8fCAoZXhwb3J0cy5IYXJkZm9yayA9IHt9KSk7XG52YXIgQ29uc2Vuc3VzVHlwZTtcbihmdW5jdGlvbiAoQ29uc2Vuc3VzVHlwZSkge1xuICAgIENvbnNlbnN1c1R5cGVbXCJQcm9vZk9mU3Rha2VcIl0gPSBcInBvc1wiO1xuICAgIENvbnNlbnN1c1R5cGVbXCJQcm9vZk9mV29ya1wiXSA9IFwicG93XCI7XG4gICAgQ29uc2Vuc3VzVHlwZVtcIlByb29mT2ZBdXRob3JpdHlcIl0gPSBcInBvYVwiO1xufSkoQ29uc2Vuc3VzVHlwZSA9IGV4cG9ydHMuQ29uc2Vuc3VzVHlwZSB8fCAoZXhwb3J0cy5Db25zZW5zdXNUeXBlID0ge30pKTtcbnZhciBDb25zZW5zdXNBbGdvcml0aG07XG4oZnVuY3Rpb24gKENvbnNlbnN1c0FsZ29yaXRobSkge1xuICAgIENvbnNlbnN1c0FsZ29yaXRobVtcIkV0aGFzaFwiXSA9IFwiZXRoYXNoXCI7XG4gICAgQ29uc2Vuc3VzQWxnb3JpdGhtW1wiQ2xpcXVlXCJdID0gXCJjbGlxdWVcIjtcbiAgICBDb25zZW5zdXNBbGdvcml0aG1bXCJDYXNwZXJcIl0gPSBcImNhc3BlclwiO1xufSkoQ29uc2Vuc3VzQWxnb3JpdGhtID0gZXhwb3J0cy5Db25zZW5zdXNBbGdvcml0aG0gfHwgKGV4cG9ydHMuQ29uc2Vuc3VzQWxnb3JpdGhtID0ge30pKTtcbnZhciBDdXN0b21DaGFpbjtcbihmdW5jdGlvbiAoQ3VzdG9tQ2hhaW4pIHtcbiAgICAvKipcbiAgICAgKiBQb2x5Z29uIChNYXRpYykgTWFpbm5ldFxuICAgICAqXG4gICAgICogLSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm1hdGljLm5ldHdvcmsvZG9jcy9kZXZlbG9wL25ldHdvcmstZGV0YWlscy9uZXR3b3JrKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wiUG9seWdvbk1haW5uZXRcIl0gPSBcInBvbHlnb24tbWFpbm5ldFwiO1xuICAgIC8qKlxuICAgICAqIFBvbHlnb24gKE1hdGljKSBNdW1iYWkgVGVzdG5ldFxuICAgICAqXG4gICAgICogLSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm1hdGljLm5ldHdvcmsvZG9jcy9kZXZlbG9wL25ldHdvcmstZGV0YWlscy9uZXR3b3JrKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wiUG9seWdvbk11bWJhaVwiXSA9IFwicG9seWdvbi1tdW1iYWlcIjtcbiAgICAvKipcbiAgICAgKiBBcmJpdHJ1bSBSaW5rZWJ5IFRlc3RuZXRcbiAgICAgKlxuICAgICAqIC0gW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm9mZmNoYWlubGFicy5jb20vZG9jcy9wdWJsaWNfdGVzdG5ldClcbiAgICAgKi9cbiAgICBDdXN0b21DaGFpbltcIkFyYml0cnVtUmlua2VieVRlc3RuZXRcIl0gPSBcImFyYml0cnVtLXJpbmtlYnktdGVzdG5ldFwiO1xuICAgIC8qKlxuICAgICAqIEFyYml0cnVtIE9uZSAtIG1haW5uZXQgZm9yIEFyYml0cnVtIHJvbGwtdXBcbiAgICAgKlxuICAgICAqIC0gW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm9mZmNoYWlubGFicy5jb20vcHVibGljLWNoYWlucylcbiAgICAgKi9cbiAgICBDdXN0b21DaGFpbltcIkFyYml0cnVtT25lXCJdID0gXCJhcmJpdHJ1bS1vbmVcIjtcbiAgICAvKipcbiAgICAgKiB4RGFpIEVWTSBzaWRlY2hhaW4gd2l0aCBhIG5hdGl2ZSBzdGFibGUgdG9rZW5cbiAgICAgKlxuICAgICAqIC0gW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnhkYWljaGFpbi5jb20vKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wieERhaUNoYWluXCJdID0gXCJ4LWRhaS1jaGFpblwiO1xuICAgIC8qKlxuICAgICAqIE9wdGltaXN0aWMgS292YW4gLSB0ZXN0bmV0IGZvciBPcHRpbWlzbSByb2xsLXVwXG4gICAgICpcbiAgICAgKiAtIFtEb2N1bWVudGF0aW9uXShodHRwczovL2NvbW11bml0eS5vcHRpbWlzbS5pby9kb2NzL2RldmVsb3BlcnMvdHV0b3JpYWxzLmh0bWwpXG4gICAgICovXG4gICAgQ3VzdG9tQ2hhaW5bXCJPcHRpbWlzdGljS292YW5cIl0gPSBcIm9wdGltaXN0aWMta292YW5cIjtcbiAgICAvKipcbiAgICAgKiBPcHRpbWlzdGljIEV0aGVyZXVtIC0gbWFpbm5ldCBmb3IgT3B0aW1pc20gcm9sbC11cFxuICAgICAqXG4gICAgICogLSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9jb21tdW5pdHkub3B0aW1pc20uaW8vZG9jcy9kZXZlbG9wZXJzL3R1dG9yaWFscy5odG1sKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wiT3B0aW1pc3RpY0V0aGVyZXVtXCJdID0gXCJvcHRpbWlzdGljLWV0aGVyZXVtXCI7XG59KShDdXN0b21DaGFpbiA9IGV4cG9ydHMuQ3VzdG9tQ2hhaW4gfHwgKGV4cG9ydHMuQ3VzdG9tQ2hhaW4gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bXMuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcImFycm93R2xhY2llclwiLFxuICAgIFwiY29tbWVudFwiOiBcIkhGIHRvIGRlbGF5IHRoZSBkaWZmaWN1bHR5IGJvbWJcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9leGVjdXRpb24tc3BlY3MvYmxvYi9tYXN0ZXIvbmV0d29yay11cGdyYWRlcy9tYWlubmV0LXVwZ3JhZGVzL2Fycm93LWdsYWNpZXIubWRcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJlaXBzXCI6IFs0MzQ1XSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiYmVybGluXCIsXG4gICAgXCJjb21tZW50XCI6IFwiSEYgdGFyZ2V0ZWQgZm9yIEp1bHkgMjAyMCBmb2xsb3dpbmcgdGhlIE11aXIgR2xhY2llciBIRlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yMDcwXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZWlwc1wiOiBbMjU2NSwgMjkyOSwgMjcxOCwgMjkzMF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJieXphbnRpdW1cIixcbiAgICBcImNvbW1lbnRcIjogXCJIYXJkZm9yayB3aXRoIG5ldyBwcmVjb21waWxlcywgaW5zdHJ1Y3Rpb25zIGFuZCBvdGhlciBwcm90b2NvbCBjaGFuZ2VzXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTYwOVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwibW9kZXhwR3F1YWRkaXZpc29yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdxdWFkZGl2aXNvciBmcm9tIG1vZGV4cCBwcmVjb21waWxlIGZvciBnYXMgY2FsY3VsYXRpb25cIlxuICAgICAgICB9LFxuICAgICAgICBcImVjQWRkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1MDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdHMgZm9yIGN1cnZlIGFkZGl0aW9uIHByZWNvbXBpbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImVjTXVsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0MDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0cyBmb3IgY3VydmUgbXVsdGlwbGljYXRpb24gcHJlY29tcGlsZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZWNQYWlyaW5nXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGdhcyBjb3N0cyBmb3IgY3VydmUgcGFpcmluZyBwcmVjb21waWxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlY1BhaXJpbmdXb3JkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA4MDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0cyByZWdhcmRpbmcgY3VydmUgcGFpcmluZyBwcmVjb21waWxlIGlucHV0IGxlbmd0aFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmV2ZXJ0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFJFVkVSVCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInN0YXRpY2NhbGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDcwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTVEFUSUNDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmV0dXJuZGF0YXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgUkVUVVJOREFUQVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXR1cm5kYXRhY29weVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBSRVRVUk5EQVRBQ09QWSBvcGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJtaW5lclJld2FyZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogXCIzMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IGEgbWluZXIgZ2V0IHJld2FyZGVkIGZvciBtaW5pbmcgYSBibG9ja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlmZmljdWx0eUJvbWJEZWxheVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzAwMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcInRoZSBhbW91bnQgb2YgYmxvY2tzIHRvIGRlbGF5IHRoZSBkaWZmaWN1bHR5IGJvbWIgd2l0aFwiXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgIFwiY29tbWVudFwiOiBcIlN0YXJ0IG9mIHRoZSBFdGhlcmV1bSBtYWluIGNoYWluXCIsXG4gICAgXCJ1cmxcIjogXCJcIixcbiAgICBcInN0YXR1c1wiOiBcIlwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHtcbiAgICAgICAgXCJtaW5HYXNMaW1pdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk1pbmltdW0gdGhlIGdhcyBsaW1pdCBtYXkgZXZlciBiZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2FzTGltaXRCb3VuZERpdmlzb3JcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwMjQsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgYm91bmQgZGl2aXNvciBvZiB0aGUgZ2FzIGxpbWl0LCB1c2VkIGluIHVwZGF0ZSBjYWxjdWxhdGlvbnNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1heFJlZnVuZFF1b3RpZW50XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiTWF4aW11bSByZWZ1bmQgcXVvdGllbnQ7IG1heCB0eCByZWZ1bmQgaXMgbWluKHR4Lmdhc1VzZWQvbWF4UmVmdW5kUXVvdGllbnQsIHR4Lmdhc1JlZnVuZClcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwiYmFzZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBiYXNlIGNvc3QsIHVzZWQgZS5nLiBmb3IgQ2hhaW5JRCBvcGNvZGUgKElzdGFuYnVsKVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGllclN0ZXBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IFswLCAyLCAzLCA1LCA4LCAxMCwgMjBdLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgb3BlcmF0aW9uLCBmb3IgYSBzZWxlY3Rpb24gb2YgdGhlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBFWFAgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHBCeXRlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRpbWVzIGNlaWwobG9nMjU2KGV4cG9uZW50KSkgZm9yIHRoZSBFWFAgaW5zdHJ1Y3Rpb25cIlxuICAgICAgICB9LFxuICAgICAgICBcInNoYTNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNIQTMgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGEzV29yZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNixcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIHdvcmQgb2YgdGhlIFNIQTMgb3BlcmF0aW9uJ3MgZGF0YVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2xvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNMT0FEIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlU2V0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgdGhlIHplcm9uZXNzIGNoYW5nZXMgZnJvbSB6ZXJvXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVSZXNldFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgdGhlIHplcm9uZXNzIGRvZXMgbm90IGNoYW5nZSBmcm9tIHplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZVJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGlmIHRoZSB6ZXJvbmVzcyBjaGFuZ2VzIHRvIHplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcImp1bXBkZXN0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEpVTVBERVNUIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibG9nXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzNzUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTE9HIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibG9nRGF0YVwiOiB7XG4gICAgICAgICAgICBcInZcIjogOCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlBlciBieXRlIGluIGEgTE9HKiBvcGVyYXRpb24ncyBkYXRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsb2dUb3BpY1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMzc1LFxuICAgICAgICAgICAgXCJkXCI6IFwiTXVsdGlwbGllZCBieSB0aGUgKiBvZiB0aGUgTE9HKiwgcGVyIExPRyB0cmFuc2FjdGlvbi4gZS5nLiBMT0cwIGluY3VycyAwICogY190eExvZ1RvcGljR2FzLCBMT0c0IGluY3VycyA0ICogY190eExvZ1RvcGljR2FzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMyMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIENSRUFURSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDQwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIENBTEwgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsU3RpcGVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjMwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkZyZWUgZ2FzIGdpdmVuIGF0IGJlZ2lubmluZyBvZiBjYWxsXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsVmFsdWVUcmFuc2ZlclwiOiB7XG4gICAgICAgICAgICBcInZcIjogOTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlBhaWQgZm9yIENBTEwgd2hlbiB0aGUgdmFsdWUgdHJhbnNmb3IgaXMgbm9uLXplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxOZXdBY2NvdW50XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlBhaWQgZm9yIENBTEwgd2hlbiB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyBkaWRuJ3QgZXhpc3QgcHJpb3JcIlxuICAgICAgICB9LFxuICAgICAgICBcInNlbGZkZXN0cnVjdFJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjQwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJSZWZ1bmRlZCBmb2xsb3dpbmcgYSBzZWxmZGVzdHJ1Y3Qgb3BlcmF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZW1vcnlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJUaW1lcyB0aGUgYWRkcmVzcyBvZiB0aGUgKGhpZ2hlc3QgcmVmZXJlbmNlZCBieXRlIGluIG1lbW9yeSArIDEpLiBOT1RFOiByZWZlcmVuY2luZyBoYXBwZW5zIG9uIHJlYWQsIHdyaXRlIGFuZCBpbiBpbnN0cnVjdGlvbnMgc3VjaCBhcyBSRVRVUk4gYW5kIENBTExcIlxuICAgICAgICB9LFxuICAgICAgICBcInF1YWRDb2VmZkRpdlwiOiB7XG4gICAgICAgICAgICBcInZcIjogNTEyLFxuICAgICAgICAgICAgXCJkXCI6IFwiRGl2aXNvciBmb3IgdGhlIHF1YWRyYXRpYyBwYXJ0aWNsZSBvZiB0aGUgbWVtb3J5IGNvc3QgZXF1YXRpb25cIlxuICAgICAgICB9LFxuICAgICAgICBcImNyZWF0ZURhdGFcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidHhcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIxMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiUGVyIHRyYW5zYWN0aW9uLiBOT1RFOiBOb3QgcGF5YWJsZSBvbiBkYXRhIG9mIGNhbGxzIGJldHdlZW4gdHJhbnNhY3Rpb25zXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eENyZWF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzMjAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBjb3N0IG9mIGNyZWF0aW5nIGEgY29udHJhY3QgdmlhIHR4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eERhdGFaZXJvXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0LFxuICAgICAgICAgICAgXCJkXCI6IFwiUGVyIGJ5dGUgb2YgZGF0YSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRoYXQgZXF1YWxzIHplcm8uIE5PVEU6IE5vdCBwYXlhYmxlIG9uIGRhdGEgb2YgY2FsbHMgYmV0d2VlbiB0cmFuc2FjdGlvbnNcIlxuICAgICAgICB9LFxuICAgICAgICBcInR4RGF0YU5vblplcm9cIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDY4LFxuICAgICAgICAgICAgXCJkXCI6IFwiUGVyIGJ5dGUgb2YgZGF0YSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRoYXQgaXMgbm90IGVxdWFsIHRvIHplcm8uIE5PVEU6IE5vdCBwYXlhYmxlIG9uIGRhdGEgb2YgY2FsbHMgYmV0d2VlbiB0cmFuc2FjdGlvbnNcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvcHlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJNdWx0aXBsaWVkIGJ5IHRoZSBudW1iZXIgb2YgMzItYnl0ZSB3b3JkcyB0aGF0IGFyZSBjb3BpZWQgKHJvdW5kIHVwKSBmb3IgYW55ICpDT1BZIG9wZXJhdGlvbiBhbmQgYWRkZWRcIlxuICAgICAgICB9LFxuICAgICAgICBcImVjUmVjb3ZlclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhMjU2XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA2MCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhMjU2V29yZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTIsXG4gICAgICAgICAgICBcImRcIjogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBcInJpcGVtZDE2MFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNjAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyaXBlbWQxNjBXb3JkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMjAsXG4gICAgICAgICAgICBcImRcIjogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBcImlkZW50aXR5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRlbnRpdHlXb3JkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzdG9wXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNUT1Agb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhZGRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQUREIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibXVsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1LFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE1VTCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInN1YlwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTVUIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkaXZcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRElWIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2RpdlwiOiB7XG4gICAgICAgICAgICBcInZcIjogNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTRElWIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibW9kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1LFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE1PRCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNtb2RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU01PRCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImFkZG1vZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogOCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBBRERNT0Qgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtdWxtb2RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTVVMTU9EIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2lnbmV4dGVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTSUdORVhURU5EIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibHRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTFQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJndFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBHVCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNsdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTTFQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZ3RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0dUIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXFcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRVEgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpc3plcm9cIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgSVNaRVJPIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYW5kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEFORCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm9yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE9SIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwieG9yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFhPUiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5vdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBOT1Qgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJieXRlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEJZVEUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEFERFJFU1Mgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCQUxBTkNFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwib3JpZ2luXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE9SSUdJTiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxlclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMRVIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsdmFsdWVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTFZBTFVFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbGRhdGFsb2FkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIENBTExEQVRBTE9BRCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxkYXRhc2l6ZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMREFUQVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsZGF0YWNvcHlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTERBVEFDT1BZIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ09ERVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2RlY29weVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDT0RFQ09QWSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImdhc3ByaWNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEdBU1BSSUNFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVTSVpFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZWNvcHlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVDT1BZIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmxvY2toYXNoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCTE9DS0hBU0ggb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2luYmFzZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDT0lOQkFTRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInRpbWVzdGFtcFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBUSU1FU1RBTVAgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJudW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTlVNQkVSIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlmZmljdWx0eVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBESUZGSUNVTFRZIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2FzbGltaXRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgR0FTTElNSVQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3BcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgUE9QIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWxvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTUxPQUQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTVNUT1JFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibXN0b3JlOFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBNU1RPUkU4IG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNTVE9SRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImp1bXBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgSlVNUCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImp1bXBpXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBKVU1QSSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInBjXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFBDIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJnYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgR0FTIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicHVzaFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBQVVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZHVwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIERVUCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInN3YXBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU1dBUCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxjb2RlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0MCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMQ09ERSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInJldHVyblwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBSRVRVUk4gb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbnZhbGlkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIElOVkFMSUQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZWxmZGVzdHJ1Y3RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0VMRkRFU1RSVUNUIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge1xuICAgICAgICBcInN0YWNrTGltaXRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwMjQsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIHNpemUgb2YgVk0gc3RhY2sgYWxsb3dlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbENyZWF0ZURlcHRoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDI0LFxuICAgICAgICAgICAgXCJkXCI6IFwiTWF4aW11bSBkZXB0aCBvZiBjYWxsL2NyZWF0ZSBzdGFja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4RXh0cmFEYXRhU2l6ZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzIsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIHNpemUgZXh0cmEgZGF0YSBtYXkgYmUgYWZ0ZXIgR2VuZXNpc1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJtaW5pbXVtRGlmZmljdWx0eVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTMxMDcyLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGhlIG1pbmltdW0gdGhhdCB0aGUgZGlmZmljdWx0eSBtYXkgZXZlciBiZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlmZmljdWx0eUJvdW5kRGl2aXNvclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjA0OCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBib3VuZCBkaXZpc29yIG9mIHRoZSBkaWZmaWN1bHR5LCB1c2VkIGluIHRoZSB1cGRhdGUgY2FsY3VsYXRpb25zXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkdXJhdGlvbkxpbWl0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBkZWNpc2lvbiBib3VuZGFyeSBvbiB0aGUgYmxvY2t0aW1lIGR1cmF0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgZGlmZmljdWx0eSBzaG91bGQgZ28gdXAgb3Igbm90XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlcG9jaER1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkR1cmF0aW9uIGJldHdlZW4gcHJvb2Ytb2Ytd29yayBlcG9jaHNcIlxuICAgICAgICB9LFxuICAgICAgICBcInRpbWVib21iUGVyaW9kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJFeHBvbmVudGlhbCBkaWZmaWN1bHR5IHRpbWVib21iIHBlcmlvZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWluZXJSZXdhcmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IFwiNTAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgICAgXCJkXCI6IFwidGhlIGFtb3VudCBhIG1pbmVyIGdldCByZXdhcmRlZCBmb3IgbWluaW5nIGEgYmxvY2tcIlxuICAgICAgICB9LFxuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IG9mIGJsb2NrcyB0byBkZWxheSB0aGUgZGlmZmljdWx0eSBib21iIHdpdGhcIlxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcImNvbnN0YW50aW5vcGxlXCIsXG4gICAgXCJjb21tZW50XCI6IFwiUG9zdHBvbmVkIGhhcmRmb3JrIGluY2x1ZGluZyBFSVAtMTI4MyAoU1NUT1JFIGdhcyBtZXRlcmluZyBjaGFuZ2VzKVwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMDEzXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJuZXRTc3RvcmVOb29wR2FzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGlmIHRoZSB2YWx1ZSBkb2Vzbid0IGNoYW5nZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibmV0U3N0b3JlSW5pdEdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMjAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gemVyb1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibmV0U3N0b3JlQ2xlYW5HYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gbm9uLXplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZURpcnR5R2FzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gZGlydHlcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZUNsZWFyUmVmdW5kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIGNsZWFyaW5nIGFuIG9yaWdpbmFsbHkgZXhpc3Rpbmcgc3RvcmFnZSBzbG90XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZXRTc3RvcmVSZXNldFJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDgwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIHJlc2V0dGluZyB0byB0aGUgb3JpZ2luYWwgbm9uLXplcm8gdmFsdWVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZVJlc2V0Q2xlYXJSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDE5ODAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmb3IgcmVzZXR0aW5nIHRvIHRoZSBvcmlnaW5hbCB6ZXJvIHZhbHVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0hMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hyXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNIUiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNhclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTQVIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRjb2RlaGFzaFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVIQVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY3JlYXRlMlwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzIwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ1JFQVRFMiBvcGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJtaW5lclJld2FyZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogXCIyMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgYW1vdW50IGEgbWluZXIgZ2V0cyByZXdhcmRlZCBmb3IgbWluaW5nIGEgYmxvY2tcIlxuICAgICAgICB9LFxuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IG9mIGJsb2NrcyB0byBkZWxheSB0aGUgZGlmZmljdWx0eSBib21iIHdpdGhcIlxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcImRhb1wiLFxuICAgIFwiY29tbWVudFwiOiBcIkRBTyByZXNjdWUgaGFyZGZvcmtcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzc5XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJncmF5R2xhY2llclwiLFxuICAgIFwiY29tbWVudFwiOiBcIkRlbGF5aW5nIHRoZSBkaWZmaWN1bHR5IGJvbWIgdG8gTWlkIFNlcHRlbWJlciAyMDIyXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZXhlY3V0aW9uLXNwZWNzL2Jsb2IvbWFzdGVyL25ldHdvcmstdXBncmFkZXMvbWFpbm5ldC11cGdyYWRlcy9ncmF5LWdsYWNpZXIubWRcIixcbiAgICBcInN0YXR1c1wiOiBcIkRyYWZ0XCIsXG4gICAgXCJlaXBzXCI6IFs1MTMzXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiaG9tZXN0ZWFkXCIsXG4gICAgXCJjb21tZW50XCI6IFwiSG9tZXN0ZWFkIGhhcmRmb3JrIHdpdGggcHJvdG9jb2wgYW5kIG5ldHdvcmsgY2hhbmdlc1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02MDZcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImRlbGVnYXRlY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgREVMRUdBVEVDQUxMIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXJkZm9ya3MgPSB2b2lkIDA7XG5leHBvcnRzLmhhcmRmb3JrcyA9IHtcbiAgICBjaGFpbnN0YXJ0OiByZXF1aXJlKCcuL2NoYWluc3RhcnQuanNvbicpLFxuICAgIGhvbWVzdGVhZDogcmVxdWlyZSgnLi9ob21lc3RlYWQuanNvbicpLFxuICAgIGRhbzogcmVxdWlyZSgnLi9kYW8uanNvbicpLFxuICAgIHRhbmdlcmluZVdoaXN0bGU6IHJlcXVpcmUoJy4vdGFuZ2VyaW5lV2hpc3RsZS5qc29uJyksXG4gICAgc3B1cmlvdXNEcmFnb246IHJlcXVpcmUoJy4vc3B1cmlvdXNEcmFnb24uanNvbicpLFxuICAgIGJ5emFudGl1bTogcmVxdWlyZSgnLi9ieXphbnRpdW0uanNvbicpLFxuICAgIGNvbnN0YW50aW5vcGxlOiByZXF1aXJlKCcuL2NvbnN0YW50aW5vcGxlLmpzb24nKSxcbiAgICBwZXRlcnNidXJnOiByZXF1aXJlKCcuL3BldGVyc2J1cmcuanNvbicpLFxuICAgIGlzdGFuYnVsOiByZXF1aXJlKCcuL2lzdGFuYnVsLmpzb24nKSxcbiAgICBtdWlyR2xhY2llcjogcmVxdWlyZSgnLi9tdWlyR2xhY2llci5qc29uJyksXG4gICAgYmVybGluOiByZXF1aXJlKCcuL2Jlcmxpbi5qc29uJyksXG4gICAgbG9uZG9uOiByZXF1aXJlKCcuL2xvbmRvbi5qc29uJyksXG4gICAgc2hhbmdoYWk6IHJlcXVpcmUoJy4vc2hhbmdoYWkuanNvbicpLFxuICAgIGFycm93R2xhY2llcjogcmVxdWlyZSgnLi9hcnJvd0dsYWNpZXIuanNvbicpLFxuICAgIGdyYXlHbGFjaWVyOiByZXF1aXJlKCcuL2dyYXlHbGFjaWVyLmpzb24nKSxcbiAgICBtZXJnZUZvcmtJZFRyYW5zaXRpb246IHJlcXVpcmUoJy4vbWVyZ2VGb3JrSWRUcmFuc2l0aW9uLmpzb24nKSxcbiAgICBtZXJnZTogcmVxdWlyZSgnLi9tZXJnZS5qc29uJyksXG4gICAgc2hhcmRpbmdGb3JrOiByZXF1aXJlKCcuL3NoYXJkaW5nLmpzb24nKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiaXN0YW5idWxcIixcbiAgICBcImNvbW1lbnRcIjogXCJIRiB0YXJnZXRlZCBmb3IgRGVjZW1iZXIgMjAxOSBmb2xsb3dpbmcgdGhlIENvbnN0YW50aW5vcGxlL1BldGVyc2J1cmcgSEZcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTY3OVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwiYmxha2UyUm91bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBwZXIgcm91bmQgZm9yIHRoZSBCbGFrZTIgRiBwcmVjb21waWxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlY0FkZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTUwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3RzIGZvciBjdXJ2ZSBhZGRpdGlvbiBwcmVjb21waWxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlY011bFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNjAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0cyBmb3IgY3VydmUgbXVsdGlwbGljYXRpb24gcHJlY29tcGlsZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZWNQYWlyaW5nXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0NTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZ2FzIGNvc3RzIGZvciBjdXJ2ZSBwYWlyaW5nIHByZWNvbXBpbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImVjUGFpcmluZ1dvcmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDM0MDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3RzIHJlZ2FyZGluZyBjdXJ2ZSBwYWlyaW5nIHByZWNvbXBpbGUgaW5wdXQgbGVuZ3RoXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eERhdGFOb25aZXJvXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxNixcbiAgICAgICAgICAgIFwiZFwiOiBcIlBlciBieXRlIG9mIGRhdGEgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0aGF0IGlzIG5vdCBlcXVhbCB0byB6ZXJvLiBOT1RFOiBOb3QgcGF5YWJsZSBvbiBkYXRhIG9mIGNhbGxzIGJldHdlZW4gdHJhbnNhY3Rpb25zXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVTZW50cnlHYXNFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiTWluaW11bSBnYXMgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgYW4gU1NUT1JFIGNhbGwsIG5vdCBjb25zdW1lZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlTm9vcEdhc0VJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgdGhlIHZhbHVlIGRvZXNuJ3QgY2hhbmdlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVEaXJ0eUdhc0VJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgYSBkaXJ0eSB2YWx1ZSBpcyBjaGFuZ2VkXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVJbml0R2FzRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gemVybyB0byBub24temVyb1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlSW5pdFJlZnVuZEVJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDE5MjAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmb3IgcmVzZXR0aW5nIHRvIHRoZSBvcmlnaW5hbCB6ZXJvIHZhbHVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVDbGVhbkdhc0VJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gbm9uLXplcm8gdG8gc29tZXRoaW5nIGVsc2VcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZUNsZWFuUmVmdW5kRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDIwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIHJlc2V0dGluZyB0byB0aGUgb3JpZ2luYWwgbm9uLXplcm8gdmFsdWVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZUNsZWFyUmVmdW5kRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZvciBjbGVhcmluZyBhbiBvcmlnaW5hbGx5IGV4aXN0aW5nIHN0b3JhZ2Ugc2xvdFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmFsYW5jZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogNzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEJBTEFOQ0Ugb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRjb2RlaGFzaFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVIQVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2hhaW5pZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDSEFJTklEIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2VsZmJhbGFuY2VcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0VMRkJBTEFOQ0Ugb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzbG9hZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogODAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNMT0FEIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJsb25kb25cIixcbiAgICBcImNvbW1lbnRcIjogXCJIRiB0YXJnZXRlZCBmb3IgSnVseSAyMDIxIGZvbGxvd2luZyB0aGUgQmVybGluIGZvcmtcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9ldGgxLjAtc3BlY3MvYmxvYi9tYXN0ZXIvbmV0d29yay11cGdyYWRlcy9tYWlubmV0LXVwZ3JhZGVzL2xvbmRvbi5tZFwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImVpcHNcIjogWzE1NTksIDMxOTgsIDM1MjksIDM1NDFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwibWVyZ2VcIixcbiAgICBcImNvbW1lbnRcIjogXCJIYXJkZm9yayB0byB1cGdyYWRlIHRoZSBjb25zZW5zdXMgbWVjaGFuaXNtIHRvIFByb29mLW9mLVN0YWtlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZXhlY3V0aW9uLXNwZWNzL2Jsb2IvbWFzdGVyL25ldHdvcmstdXBncmFkZXMvbWFpbm5ldC11cGdyYWRlcy9tZXJnZS5tZFwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImNvbnNlbnN1c1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInBvc1wiLFxuICAgICAgICBcImFsZ29yaXRobVwiOiBcImNhc3BlclwiLFxuICAgICAgICBcImNhc3BlclwiOiB7fVxuICAgIH0sXG4gICAgXCJlaXBzXCI6IFszNjc1LCA0Mzk5XVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIm1lcmdlRm9ya0lkVHJhbnNpdGlvblwiLFxuICAgIFwiY29tbWVudFwiOiBcIlByZS1tZXJnZSBoYXJkZm9yayB0byBmb3JrIG9mZiBub24tdXBncmFkZWQgY2xpZW50c1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0zNjc1XCIsXG4gICAgXCJzdGF0dXNcIjogXCJEcmFmdFwiLFxuICAgIFwiZWlwc1wiOiBbXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIm11aXJHbGFjaWVyXCIsXG4gICAgXCJjb21tZW50XCI6IFwiSEYgdG8gZGVsYXkgdGhlIGRpZmZpY3VsdHkgYm9tYlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yMzg0XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge1xuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDkwMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IG9mIGJsb2NrcyB0byBkZWxheSB0aGUgZGlmZmljdWx0eSBib21iIHdpdGhcIlxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInBldGVyc2J1cmdcIixcbiAgICBcImNvbW1lbnRcIjogXCJBa2EgY29uc3RhbnRpbm9wbGVGaXgsIHJlbW92ZXMgRUlQLTEyODMsIGFjdGl2YXRlIHRvZ2V0aGVyIHdpdGggb3IgYWZ0ZXIgY29uc3RhbnRpbm9wbGVcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTcxNlwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwibmV0U3N0b3JlTm9vcEdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlJlbW92ZWQgYWxvbmcgRUlQLTEyODNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZUluaXRHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IG51bGwsXG4gICAgICAgICAgICBcImRcIjogXCJSZW1vdmVkIGFsb25nIEVJUC0xMjgzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZXRTc3RvcmVDbGVhbkdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlJlbW92ZWQgYWxvbmcgRUlQLTEyODNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZURpcnR5R2FzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiBudWxsLFxuICAgICAgICAgICAgXCJkXCI6IFwiUmVtb3ZlZCBhbG9uZyBFSVAtMTI4M1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibmV0U3N0b3JlQ2xlYXJSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IG51bGwsXG4gICAgICAgICAgICBcImRcIjogXCJSZW1vdmVkIGFsb25nIEVJUC0xMjgzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZXRTc3RvcmVSZXNldFJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlJlbW92ZWQgYWxvbmcgRUlQLTEyODNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZVJlc2V0Q2xlYXJSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IG51bGwsXG4gICAgICAgICAgICBcImRcIjogXCJSZW1vdmVkIGFsb25nIEVJUC0xMjgzXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInNoYW5naGFpXCIsXG4gICAgXCJjb21tZW50XCI6IFwiTmV4dCBmZWF0dXJlIGhhcmRmb3JrIGFmdGVyIHRoZSBtZXJnZSBoYXJkZm9yayBoYXZpbmcgd2l0aGRyYXdhbHMsIHdhcm0gY29pbmJhc2UsIHB1c2gwLCBsaW1pdC9tZXRlciBpbml0Y29kZVwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1zcGVjcy9ibG9iL21hc3Rlci9uZXR3b3JrLXVwZ3JhZGVzL21haW5uZXQtdXBncmFkZXMvc2hhbmdoYWkubWRcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJlaXBzXCI6IFszNjUxLCAzODU1LCAzODYwLCA0ODk1XVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInNoYXJkaW5nRm9ya1wiLFxuICAgIFwiY29tbWVudFwiOiBcIkludGVybmFsIGhhcmRmb3JrIHRvIHRlc3QgcHJvdG8tZGFua3NoYXJkaW5nIChkbyBub3QgdXNlIGluIHByb2R1Y3Rpb24pXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQ4NDRcIixcbiAgICBcInN0YXR1c1wiOiBcIkV4cGVyaW1lbnRhbFwiLFxuICAgIFwiZWlwc1wiOiBbNDg0NF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJzcHVyaW91c0RyYWdvblwiLFxuICAgIFwiY29tbWVudFwiOiBcIkhGIHdpdGggRUlQcyBmb3Igc2ltcGxlIHJlcGxheSBhdHRhY2sgcHJvdGVjdGlvbiwgRVhQIGNvc3QgaW5jcmVhc2UsIHN0YXRlIHRyaWUgY2xlYXJpbmcsIGNvbnRyYWN0IGNvZGUgc2l6ZSBsaW1pdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02MDdcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImV4cEJ5dGVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGltZXMgY2VpbChsb2cyNTYoZXhwb25lbnQpKSBmb3IgdGhlIEVYUCBpbnN0cnVjdGlvblwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge1xuICAgICAgICBcIm1heENvZGVTaXplXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyNDU3NixcbiAgICAgICAgICAgIFwiZFwiOiBcIk1heGltdW0gbGVuZ3RoIG9mIGNvbnRyYWN0IGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInRhbmdlcmluZVdoaXN0bGVcIixcbiAgICBcImNvbW1lbnRcIjogXCJIYXJkZm9yayB3aXRoIGdhcyBjb3N0IGNoYW5nZXMgZm9yIElPLWhlYXZ5IG9wZXJhdGlvbnNcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjA4XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJzbG9hZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU0xPQUQgb3BlcmF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA3MDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBDQUxMIG9wZXJhdGlvbiAmIG1lc3NhZ2UgY2FsbCB0cmFuc2FjdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDcwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBFWFRDT0RFU0laRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImV4dGNvZGVjb3B5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA3MDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRVhUQ09ERUNPUFkgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0MDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQkFMQU5DRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImRlbGVnYXRlY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIERFTEVHQVRFQ0FMTCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxjb2RlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA3MDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTENPREUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZWxmZGVzdHJ1Y3RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0VMRkRFU1RSVUNUIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlR2V0aEdlbmVzaXMgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbi8qKlxuICogVHJhbnNmb3JtcyBHZXRoIGZvcm1hdHRlZCBub25jZSAoaS5lLiBoZXggc3RyaW5nKSB0byA4IGJ5dGUgMHgtcHJlZml4ZWQgc3RyaW5nIHVzZWQgaW50ZXJuYWxseVxuICogQHBhcmFtIG5vbmNlIHN0cmluZyBwYXJzZWQgZnJvbSB0aGUgR2V0aCBnZW5lc2lzIGZpbGVcbiAqIEByZXR1cm5zIG5vbmNlIGFzIGEgMHgtcHJlZml4ZWQgOCBieXRlIHN0cmluZ1xuICovXG5mdW5jdGlvbiBmb3JtYXROb25jZShub25jZSkge1xuICAgIGlmICghbm9uY2UgfHwgbm9uY2UgPT09ICcweDAnKSB7XG4gICAgICAgIHJldHVybiAnMHgwMDAwMDAwMDAwMDAwMDAwJztcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsXzEuaXNIZXhQcmVmaXhlZCkobm9uY2UpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgKDAsIHV0aWxfMS5zdHJpcEhleFByZWZpeCkobm9uY2UpLnBhZFN0YXJ0KDE2LCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gJzB4JyArIG5vbmNlLnBhZFN0YXJ0KDE2LCAnMCcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBHZXRoIGdlbmVzaXMgcGFyYW1ldGVycyB0byBhbiBFdGhlcmV1bUpTIGNvbXBhdGlibGUgYENvbW1vbk9wdHNgIG9iamVjdFxuICogQHBhcmFtIGpzb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgR2V0aCBnZW5lc2lzIGZpbGVcbiAqIEBwYXJhbSBvcHRpb25hbCBtZXJnZUZvcmtJZFBvc3RNZXJnZSB3aGljaCBjbGFyaWZpZXMgdGhlIHBsYWNlbWVudCBvZiBNZXJnZUZvcmtJZFRyYW5zaXRpb25cbiAqIGhhcmRmb3JrLCB3aGljaCBieSBkZWZhdWx0IGlzIHBvc3QgbWVyZ2UgYXMgd2l0aCB0aGUgbWVyZ2VkIGV0aCBuZXR3b3JrcyBidXQgY291bGQgYWxzbyBjb21lXG4gKiBiZWZvcmUgbWVyZ2UgbGlrZSBpbiBraWxuIGdlbmVzaXNcbiAqIEByZXR1cm5zIGdlbmVzaXMgcGFyYW1ldGVycyBpbiBhIGBDb21tb25PcHRzYCBjb21wbGlhbnQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlR2V0aFBhcmFtcyhqc29uLCBtZXJnZUZvcmtJZFBvc3RNZXJnZSA9IHRydWUpIHtcbiAgICBjb25zdCB7IG5hbWUsIGNvbmZpZywgZGlmZmljdWx0eSwgbWl4SGFzaCwgZ2FzTGltaXQsIGNvaW5iYXNlLCBiYXNlRmVlUGVyR2FzLCB9ID0ganNvbjtcbiAgICBsZXQgeyBleHRyYURhdGEsIHRpbWVzdGFtcCwgbm9uY2UgfSA9IGpzb247XG4gICAgY29uc3QgZ2VuZXNpc1RpbWVzdGFtcCA9IE51bWJlcih0aW1lc3RhbXApO1xuICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gY29uZmlnO1xuICAgIC8vIGdldGggaXMgbm90IHN0cmljdGx5IHB1dHRpbmcgZW1wdHkgZmllbGRzIHdpdGggYSAweCBwcmVmaXhcbiAgICBpZiAoZXh0cmFEYXRhID09PSAnJykge1xuICAgICAgICBleHRyYURhdGEgPSAnMHgnO1xuICAgIH1cbiAgICAvLyBnZXRoIG1heSB1c2UgbnVtYmVyIGZvciB0aW1lc3RhbXBcbiAgICBpZiAoISgwLCB1dGlsXzEuaXNIZXhQcmVmaXhlZCkodGltZXN0YW1wKSkge1xuICAgICAgICB0aW1lc3RhbXAgPSAoMCwgdXRpbF8xLmludFRvSGV4KShwYXJzZUludCh0aW1lc3RhbXApKTtcbiAgICB9XG4gICAgLy8gZ2V0aCBtYXkgbm90IGdpdmUgdXMgYSBub25jZSBzdHJpY3RseSBmb3JtYXR0ZWQgdG8gYW4gOCBieXRlIGhleCBzdHJpbmdcbiAgICBpZiAobm9uY2UubGVuZ3RoICE9PSAxOCkge1xuICAgICAgICBub25jZSA9IGZvcm1hdE5vbmNlKG5vbmNlKTtcbiAgICB9XG4gICAgLy8gRUlQMTU1IGFuZCBFSVAxNTggYXJlIGJvdGggcGFydCBvZiBTcHVyaW91cyBEcmFnb24gaGFyZGZvcmsgYW5kIG11c3Qgb2NjdXIgYXQgdGhlIHNhbWUgdGltZVxuICAgIC8vIGJ1dCBoYXZlIGRpZmZlcmVudCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgaW4gZ2V0aCBnZW5lc2lzIHBhcmFtZXRlcnNcbiAgICBpZiAoY29uZmlnLmVpcDE1NUJsb2NrICE9PSBjb25maWcuZWlwMTU4QmxvY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFSVAxNTUgYmxvY2sgbnVtYmVyIG11c3QgZXF1YWwgRUlQIDE1OCBibG9jayBudW1iZXIgc2luY2UgYm90aCBhcmUgcGFydCBvZiBTcHVyaW91c0RyYWdvbiBoYXJkZm9yayBhbmQgdGhlIGNsaWVudCBvbmx5IHN1cHBvcnRzIGFjdGl2YXRpbmcgdGhlIGZ1bGwgaGFyZGZvcmsnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICBuZXR3b3JrSWQ6IGNoYWluSWQsXG4gICAgICAgIGdlbmVzaXM6IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBwYXJzZUludChnYXNMaW1pdCksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBwYXJzZUludChkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgbWl4SGFzaCxcbiAgICAgICAgICAgIGNvaW5iYXNlLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhcyxcbiAgICAgICAgfSxcbiAgICAgICAgaGFyZGZvcms6IHVuZGVmaW5lZCxcbiAgICAgICAgaGFyZGZvcmtzOiBbXSxcbiAgICAgICAgYm9vdHN0cmFwTm9kZXM6IFtdLFxuICAgICAgICBjb25zZW5zdXM6IGNvbmZpZy5jbGlxdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BvYScsXG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiAnY2xpcXVlJyxcbiAgICAgICAgICAgICAgICBjbGlxdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlY2VudCBnZXRoIGdlbmVzaXMgc2VlbXMgdG8gYmUgdXNpbmcgYmxvY2twZXJpb2RzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBlcG9jaGxlbmd0aCBmb3IgY2xpcXVlIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2hhY2ttZC5pby9QcVpnTXBua1NXQ1d2NWpvSm9GeW1RXG4gICAgICAgICAgICAgICAgICAgIHBlcmlvZDogY29uZmlnLmNsaXF1ZS5wZXJpb2QgPz8gY29uZmlnLmNsaXF1ZS5ibG9ja3BlcmlvZHNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIGVwb2NoOiBjb25maWcuY2xpcXVlLmVwb2NoID8/IGNvbmZpZy5jbGlxdWUuZXBvY2hsZW5ndGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb3cnLFxuICAgICAgICAgICAgICAgIGFsZ29yaXRobTogJ2V0aGFzaCcsXG4gICAgICAgICAgICAgICAgZXRoYXNoOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBmb3JrTWFwID0ge1xuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5Ib21lc3RlYWRdOiB7IG5hbWU6ICdob21lc3RlYWRCbG9jaycgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuRGFvXTogeyBuYW1lOiAnZGFvRm9ya0Jsb2NrJyB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5UYW5nZXJpbmVXaGlzdGxlXTogeyBuYW1lOiAnZWlwMTUwQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLlNwdXJpb3VzRHJhZ29uXTogeyBuYW1lOiAnZWlwMTU1QmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLkJ5emFudGl1bV06IHsgbmFtZTogJ2J5emFudGl1bUJsb2NrJyB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5Db25zdGFudGlub3BsZV06IHsgbmFtZTogJ2NvbnN0YW50aW5vcGxlQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLlBldGVyc2J1cmddOiB7IG5hbWU6ICdwZXRlcnNidXJnQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLklzdGFuYnVsXTogeyBuYW1lOiAnaXN0YW5idWxCbG9jaycgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuTXVpckdsYWNpZXJdOiB7IG5hbWU6ICdtdWlyR2xhY2llckJsb2NrJyB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5CZXJsaW5dOiB7IG5hbWU6ICdiZXJsaW5CbG9jaycgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuTG9uZG9uXTogeyBuYW1lOiAnbG9uZG9uQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLk1lcmdlRm9ya0lkVHJhbnNpdGlvbl06IHsgbmFtZTogJ21lcmdlRm9ya0Jsb2NrJywgcG9zdE1lcmdlOiBtZXJnZUZvcmtJZFBvc3RNZXJnZSB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5TaGFuZ2hhaV06IHsgbmFtZTogJ3NoYW5naGFpVGltZScsIHBvc3RNZXJnZTogdHJ1ZSwgaXNUaW1lc3RhbXA6IHRydWUgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuU2hhcmRpbmdGb3JrRGV2XTogeyBuYW1lOiAnc2hhcmRpbmdGb3JrVGltZScsIHBvc3RNZXJnZTogdHJ1ZSwgaXNUaW1lc3RhbXA6IHRydWUgfSxcbiAgICB9O1xuICAgIC8vIGZvcmtNYXBSZXYgaXMgdGhlIG1hcCBmcm9tIGNvbmZpZyBmaWVsZCBuYW1lIHRvIEhhcmRmb3JrXG4gICAgY29uc3QgZm9ya01hcFJldiA9IE9iamVjdC5rZXlzKGZvcmtNYXApLnJlZHVjZSgoYWNjLCBlbGVtKSA9PiB7XG4gICAgICAgIGFjY1tmb3JrTWFwW2VsZW1dLm5hbWVdID0gZWxlbTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgY29uZmlnSGFyZGZvcmtOYW1lcyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKChrZXkpID0+IGZvcmtNYXBSZXZba2V5XSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ1trZXldICE9PSB1bmRlZmluZWQgJiYgY29uZmlnW2tleV0gIT09IG51bGwpO1xuICAgIHBhcmFtcy5oYXJkZm9ya3MgPSBjb25maWdIYXJkZm9ya05hbWVzXG4gICAgICAgIC5tYXAoKG5hbWVCbG9jaykgPT4gKHtcbiAgICAgICAgbmFtZTogZm9ya01hcFJldltuYW1lQmxvY2tdLFxuICAgICAgICBibG9jazogZm9ya01hcFtmb3JrTWFwUmV2W25hbWVCbG9ja11dLmlzVGltZXN0YW1wID09PSB0cnVlIHx8IHR5cGVvZiBjb25maWdbbmFtZUJsb2NrXSAhPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBjb25maWdbbmFtZUJsb2NrXSxcbiAgICAgICAgdGltZXN0YW1wOiBmb3JrTWFwW2ZvcmtNYXBSZXZbbmFtZUJsb2NrXV0uaXNUaW1lc3RhbXAgPT09IHRydWUgJiYgdHlwZW9mIGNvbmZpZ1tuYW1lQmxvY2tdID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBjb25maWdbbmFtZUJsb2NrXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfSkpXG4gICAgICAgIC5maWx0ZXIoKGZvcmspID0+IGZvcmsuYmxvY2sgIT09IG51bGwgfHwgZm9yay50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCk7XG4gICAgcGFyYW1zLmhhcmRmb3Jrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS5ibG9jayA/PyBJbmZpbml0eSkgLSAoYi5ibG9jayA/PyBJbmZpbml0eSk7XG4gICAgfSk7XG4gICAgcGFyYW1zLmhhcmRmb3Jrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS50aW1lc3RhbXAgPz8gZ2VuZXNpc1RpbWVzdGFtcCkgLSAoYi50aW1lc3RhbXAgPz8gZ2VuZXNpc1RpbWVzdGFtcCk7XG4gICAgfSk7XG4gICAgaWYgKGNvbmZpZy50ZXJtaW5hbFRvdGFsRGlmZmljdWx0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEZvbGxvd2luZyBwb2ludHMgbmVlZCB0byBiZSBjb25zaWRlcmVkIGZvciBwbGFjZW1lbnQgb2YgbWVyZ2UgaGZcbiAgICAgICAgLy8gLSBNZXJnZSBoYXJkZm9yayBjYW4ndCBiZSBwbGFjZWQgYXQgZ2VuZXNpc1xuICAgICAgICAvLyAtIFBsYWNlIG1lcmdlIGhmIGJlZm9yZSBhbnkgaGFyZGZvcmtzIHRoYXQgcmVxdWlyZSBDTCBwYXJ0aWNpcGF0aW9uIGZvciBlLmcuIHdpdGhkcmF3YWxzXG4gICAgICAgIC8vIC0gTWVyZ2UgaGFyZGZvcmsgaGFzIHRvIGJlIHBsYWNlZCBqdXN0IGFmdGVyIGdlbmVzaXMgaWYgYW55IG9mIHRoZSBnZW5lc2lzIGhhcmRmb3JrcyBtYWtlIENMXG4gICAgICAgIC8vICAgbmVjZXNzYXJ5IGZvciBlLmcuIHdpdGhkcmF3YWxzXG4gICAgICAgIGNvbnN0IG1lcmdlQ29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogZW51bXNfMS5IYXJkZm9yay5NZXJnZSxcbiAgICAgICAgICAgIHR0ZDogY29uZmlnLnRlcm1pbmFsVG90YWxEaWZmaWN1bHR5LFxuICAgICAgICAgICAgYmxvY2s6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE1lcmdlIGhhcmRmb3JrIGhhcyB0byBiZSBwbGFjZWQgYmVmb3JlIGZpcnN0IGhhcmRmb3JrIHRoYXQgaXMgZGVwZW5kZW50IG9uIG1lcmdlXG4gICAgICAgIGNvbnN0IHBvc3RNZXJnZUluZGV4ID0gcGFyYW1zLmhhcmRmb3Jrcy5maW5kSW5kZXgoKGhmKSA9PiBmb3JrTWFwW2hmLm5hbWVdPy5wb3N0TWVyZ2UgPT09IHRydWUpO1xuICAgICAgICBpZiAocG9zdE1lcmdlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBwYXJhbXMuaGFyZGZvcmtzLnNwbGljZShwb3N0TWVyZ2VJbmRleCwgMCwgbWVyZ2VDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLmhhcmRmb3Jrcy5wdXNoKG1lcmdlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXRlc3RIYXJkZm9yayA9IHBhcmFtcy5oYXJkZm9ya3MubGVuZ3RoID4gMCA/IHBhcmFtcy5oYXJkZm9ya3Muc2xpY2UoLTEpWzBdIDogdW5kZWZpbmVkO1xuICAgIHBhcmFtcy5oYXJkZm9yayA9IGxhdGVzdEhhcmRmb3JrPy5uYW1lO1xuICAgIHBhcmFtcy5oYXJkZm9ya3MudW5zaGlmdCh7IG5hbWU6IGVudW1zXzEuSGFyZGZvcmsuQ2hhaW5zdGFydCwgYmxvY2s6IDAgfSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbi8qKlxuICogUGFyc2VzIGEgZ2VuZXNpcy5qc29uIGV4cG9ydGVkIGZyb20gR2V0aCBpbnRvIHBhcmFtZXRlcnMgZm9yIENvbW1vbiBpbnN0YW5jZVxuICogQHBhcmFtIGpzb24gcmVwcmVzZW50aW5nIHRoZSBHZXRoIGdlbmVzaXMgZmlsZVxuICogQHBhcmFtIG5hbWUgb3B0aW9uYWwgY2hhaW4gbmFtZVxuICogQHJldHVybnMgcGFyc2VkIHBhcmFtc1xuICovXG5mdW5jdGlvbiBwYXJzZUdldGhHZW5lc2lzKGpzb24sIG5hbWUsIG1lcmdlRm9ya0lkUG9zdE1lcmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKFsnY29uZmlnJywgJ2RpZmZpY3VsdHknLCAnZ2FzTGltaXQnLCAnYWxsb2MnXS5zb21lKChmaWVsZCkgPT4gIShmaWVsZCBpbiBqc29uKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQsIGV4cGVjdGVkIGdldGggZ2VuZXNpcyBmaWVsZHMgbWlzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzb24ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlR2V0aFBhcmFtcyhqc29uLCBtZXJnZUZvcmtJZFBvc3RNZXJnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcGFyc2luZyBwYXJhbWV0ZXJzIGZpbGU6ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbn1cbmV4cG9ydHMucGFyc2VHZXRoR2VuZXNpcyA9IHBhcnNlR2V0aEdlbmVzaXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVRyYW5zYWN0aW9uID0gdm9pZCAwO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvY29tbW9uXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG4vKipcbiAqIFRoaXMgYmFzZSBjbGFzcyB3aWxsIGxpa2VseSBiZSBzdWJqZWN0IHRvIGZ1cnRoZXJcbiAqIHJlZmFjdG9yaW5nIGFsb25nIHRoZSBpbnRyb2R1Y3Rpb24gb2YgYWRkaXRpb25hbCB0eCB0eXBlc1xuICogb24gdGhlIEV0aGVyZXVtIG5ldHdvcmsuXG4gKlxuICogSXQgaXMgdGhlcmVmb3JlIG5vdCByZWNvbW1lbmRlZCB0byB1c2UgZGlyZWN0bHkuXG4gKi9cbmNsYXNzIEJhc2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IodHhEYXRhLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7XG4gICAgICAgICAgICBoYXNoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhRmVlOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIHR4IHR5cGUgZGVmaW5pbmcgRUlQcyxcbiAgICAgICAgICogZS5nLiAxNTU5IChmZWUgbWFya2V0KSBhbmQgMjkzMCAoYWNjZXNzIGxpc3RzKVxuICAgICAgICAgKiBmb3IgRmVlTWFya2V0RUlQMTU1OVRyYW5zYWN0aW9uIG9iamVjdHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlQ2FwYWJpbGl0aWVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBjaGFpbiB0aGUgdHggZmFsbHMgYmFjayB0byBpZiBubyBDb21tb25cbiAgICAgICAgICogaXMgcHJvdmlkZWQgYW5kIGlmIHRoZSBjaGFpbiBjYW4ndCBiZSBkZXJpdmVkIGZyb21cbiAgICAgICAgICogYSBwYXNzZWQgaW4gY2hhaW5JZCAob25seSBFSVAtMjcxOCB0eXBlZCB0eHMpIG9yXG4gICAgICAgICAqIEVJUC0xNTUgc2lnbmF0dXJlIChsZWdhY3kgdHhzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ERUZBVUxUX0NIQUlOID0gY29tbW9uXzEuQ2hhaW4uTWFpbm5ldDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IEhGIGlmIHRoZSB0eCB0eXBlIGlzIGFjdGl2ZSBvbiB0aGF0IEhGXG4gICAgICAgICAqIG9yIHRoZSBmaXJzdCBncmVhdGVyIEhGIHdoZXJlIHRoZSB0eCBpcyBhY3RpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuREVGQVVMVF9IQVJERk9SSyA9IGNvbW1vbl8xLkhhcmRmb3JrLk1lcmdlO1xuICAgICAgICBjb25zdCB7IG5vbmNlLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLCB2LCByLCBzLCB0eXBlIH0gPSB0eERhdGE7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBOdW1iZXIoKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkoKDAsIHV0aWxfMS50b0J1ZmZlcikodHlwZSkpKTtcbiAgICAgICAgdGhpcy50eE9wdGlvbnMgPSBvcHRzO1xuICAgICAgICBjb25zdCB0b0IgPSAoMCwgdXRpbF8xLnRvQnVmZmVyKSh0byA9PT0gJycgPyAnMHgnIDogdG8pO1xuICAgICAgICBjb25zdCB2QiA9ICgwLCB1dGlsXzEudG9CdWZmZXIpKHYgPT09ICcnID8gJzB4JyA6IHYpO1xuICAgICAgICBjb25zdCByQiA9ICgwLCB1dGlsXzEudG9CdWZmZXIpKHIgPT09ICcnID8gJzB4JyA6IHIpO1xuICAgICAgICBjb25zdCBzQiA9ICgwLCB1dGlsXzEudG9CdWZmZXIpKHMgPT09ICcnID8gJzB4JyA6IHMpO1xuICAgICAgICB0aGlzLm5vbmNlID0gKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkoKDAsIHV0aWxfMS50b0J1ZmZlcikobm9uY2UgPT09ICcnID8gJzB4JyA6IG5vbmNlKSk7XG4gICAgICAgIHRoaXMuZ2FzTGltaXQgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KSgoMCwgdXRpbF8xLnRvQnVmZmVyKShnYXNMaW1pdCA9PT0gJycgPyAnMHgnIDogZ2FzTGltaXQpKTtcbiAgICAgICAgdGhpcy50byA9IHRvQi5sZW5ndGggPiAwID8gbmV3IHV0aWxfMS5BZGRyZXNzKHRvQikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KSgoMCwgdXRpbF8xLnRvQnVmZmVyKSh2YWx1ZSA9PT0gJycgPyAnMHgnIDogdmFsdWUpKTtcbiAgICAgICAgdGhpcy5kYXRhID0gKDAsIHV0aWxfMS50b0J1ZmZlcikoZGF0YSA9PT0gJycgPyAnMHgnIDogZGF0YSk7XG4gICAgICAgIHRoaXMudiA9IHZCLmxlbmd0aCA+IDAgPyAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KSh2QikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuciA9IHJCLmxlbmd0aCA+IDAgPyAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KShyQikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucyA9IHNCLmxlbmd0aCA+IDAgPyAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KShzQikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQ2Fubm90RXhjZWVkTWF4SW50ZWdlcih7IHZhbHVlOiB0aGlzLnZhbHVlLCByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgLy8gZ2V0aCBsaW1pdHMgZ2FzTGltaXQgdG8gMl42NC0xXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQ2Fubm90RXhjZWVkTWF4SW50ZWdlcih7IGdhc0xpbWl0OiB0aGlzLmdhc0xpbWl0IH0sIDY0KTtcbiAgICAgICAgLy8gRUlQLTI2ODEgbGltaXRzIG5vbmNlIHRvIDJeNjQtMSAoY2Fubm90IGVxdWFsIDJeNjQtMSlcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVDYW5ub3RFeGNlZWRNYXhJbnRlZ2VyKHsgbm9uY2U6IHRoaXMubm9uY2UgfSwgNjQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqXG4gICAgICogTm90ZTogbGVnYWN5IHR4cyB3aWxsIHJldHVybiB0eCB0eXBlIGAwYC5cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHR4IHR5cGUgZGVmaW5pbmcgY2FwYWJpbGl0eSBpcyBhY3RpdmVcbiAgICAgKiBvbiBhIHR4LCBmb3IgZXhhbXBsZSB0aGUgRUlQLTE1NTkgZmVlIG1hcmtldCBtZWNoYW5pc21cbiAgICAgKiBvciB0aGUgRUlQLTI5MzAgYWNjZXNzIGxpc3QgZmVhdHVyZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSB0eCB0eXBlIGl0c2VsZixcbiAgICAgKiBzbyBFSVAtMjkzMCBhY2Nlc3MgbGlzdHMgY2FuIHZlcnkgd2VsbCBiZSBhY3RpdmVcbiAgICAgKiBvbiBhbiBFSVAtMTU1OSB0eCBmb3IgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VmdWwgZm9yIGZlYXR1cmUgY2hlY2tzIGlmIHRoZVxuICAgICAqIHR4IHR5cGUgaXMgdW5rbm93biAoZS5nLiB3aGVuIGluc3RhbnRpYXRlZCB3aXRoXG4gICAgICogdGhlIHR4IGZhY3RvcnkpLlxuICAgICAqXG4gICAgICogU2VlIGBDYXBhYmlsaXRlc2AgaW4gdGhlIGB0eXBlc2AgbW9kdWxlIGZvciBhIHJlZmVyZW5jZVxuICAgICAqIG9uIGFsbCBzdXBwb3J0ZWQgY2FwYWJpbGl0aWVzLlxuICAgICAqL1xuICAgIHN1cHBvcnRzKGNhcGFiaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlQ2FwYWJpbGl0aWVzLmluY2x1ZGVzKGNhcGFiaWxpdHkpO1xuICAgIH1cbiAgICB2YWxpZGF0ZShzdHJpbmdFcnJvciA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5nZXRCYXNlRmVlKCkgPiB0aGlzLmdhc0xpbWl0KSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChgZ2FzTGltaXQgaXMgdG9vIGxvdy4gZ2l2ZW4gJHt0aGlzLmdhc0xpbWl0fSwgbmVlZCBhdCBsZWFzdCAke3RoaXMuZ2V0QmFzZUZlZSgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU2lnbmVkKCkgJiYgIXRoaXMudmVyaWZ5U2lnbmF0dXJlKCkpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKCdJbnZhbGlkIFNpZ25hdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdFcnJvciA/IGVycm9ycyA6IGVycm9ycy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIF92YWxpZGF0ZVlQYXJpdHkoKSB7XG4gICAgICAgIGNvbnN0IHsgdiB9ID0gdGhpcztcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBCaWdJbnQoMCkgJiYgdiAhPT0gQmlnSW50KDEpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygnVGhlIHktcGFyaXR5IG9mIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgZWl0aGVyIGJlIDAgb3IgMScpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRUlQLTI6IEFsbCB0cmFuc2FjdGlvbiBzaWduYXR1cmVzIHdob3NlIHMtdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHNlY3AyNTZrMW4vMmFyZSBjb25zaWRlcmVkIGludmFsaWQuXG4gICAgICogUmVhc29uaW5nOiBodHRwczovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTU3MjhcbiAgICAgKi9cbiAgICBfdmFsaWRhdGVIaWdoUygpIHtcbiAgICAgICAgY29uc3QgeyBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jb21tb24uZ3RlSGFyZGZvcmsoJ2hvbWVzdGVhZCcpICYmIHMgIT09IHVuZGVmaW5lZCAmJiBzID4gdXRpbF8xLlNFQ1AyNTZLMV9PUkRFUl9ESVZfMikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ0ludmFsaWQgU2lnbmF0dXJlOiBzLXZhbHVlcyBncmVhdGVyIHRoYW4gc2VjcDI1Nmsxbi8yIGFyZSBjb25zaWRlcmVkIGludmFsaWQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGFtb3VudCBvZiBnYXMgdGhlIHR4IG11c3QgaGF2ZSAoRGF0YUZlZSArIFR4RmVlICsgQ3JlYXRpb24gRmVlKVxuICAgICAqL1xuICAgIGdldEJhc2VGZWUoKSB7XG4gICAgICAgIGNvbnN0IHR4RmVlID0gdGhpcy5jb21tb24ucGFyYW0oJ2dhc1ByaWNlcycsICd0eCcpO1xuICAgICAgICBsZXQgZmVlID0gdGhpcy5nZXREYXRhRmVlKCk7XG4gICAgICAgIGlmICh0eEZlZSlcbiAgICAgICAgICAgIGZlZSArPSB0eEZlZTtcbiAgICAgICAgaWYgKHRoaXMuY29tbW9uLmd0ZUhhcmRmb3JrKCdob21lc3RlYWQnKSAmJiB0aGlzLnRvQ3JlYXRpb25BZGRyZXNzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4Q3JlYXRpb25GZWUgPSB0aGlzLmNvbW1vbi5wYXJhbSgnZ2FzUHJpY2VzJywgJ3R4Q3JlYXRpb24nKTtcbiAgICAgICAgICAgIGlmICh0eENyZWF0aW9uRmVlKVxuICAgICAgICAgICAgICAgIGZlZSArPSB0eENyZWF0aW9uRmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgZ2FzIHBhaWQgZm9yIHRoZSBkYXRhIGluIHRoaXMgdHhcbiAgICAgKi9cbiAgICBnZXREYXRhRmVlKCkge1xuICAgICAgICBjb25zdCB0eERhdGFaZXJvID0gdGhpcy5jb21tb24ucGFyYW0oJ2dhc1ByaWNlcycsICd0eERhdGFaZXJvJyk7XG4gICAgICAgIGNvbnN0IHR4RGF0YU5vblplcm8gPSB0aGlzLmNvbW1vbi5wYXJhbSgnZ2FzUHJpY2VzJywgJ3R4RGF0YU5vblplcm8nKTtcbiAgICAgICAgbGV0IGNvc3QgPSBCaWdJbnQoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPT09IDAgPyAoY29zdCArPSB0eERhdGFaZXJvKSA6IChjb3N0ICs9IHR4RGF0YU5vblplcm8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy50byA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudG8gPT09IG51bGwpICYmIHRoaXMuY29tbW9uLmlzQWN0aXZhdGVkRUlQKDM4NjApKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gQmlnSW50KE1hdGguY2VpbCh0aGlzLmRhdGEubGVuZ3RoIC8gMzIpKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRDb2RlQ29zdCA9IHRoaXMuY29tbW9uLnBhcmFtKCdnYXNQcmljZXMnLCAnaW5pdENvZGVXb3JkQ29zdCcpICogZGF0YUxlbmd0aDtcbiAgICAgICAgICAgIGNvc3QgKz0gaW5pdENvZGVDb3N0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3N0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdHgncyBgdG9gIGlzIHRvIHRoZSBjcmVhdGlvbiBhZGRyZXNzXG4gICAgICovXG4gICAgdG9DcmVhdGlvbkFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvID09PSB1bmRlZmluZWQgfHwgdGhpcy50by5idWYubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1NpZ25lZCgpIHtcbiAgICAgICAgY29uc3QgeyB2LCByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHIgPT09IHVuZGVmaW5lZCB8fCBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZFxuICAgICAqL1xuICAgIHZlcmlmeVNpZ25hdHVyZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE1haW4gc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBpcyBkb25lIGluIGBnZXRTZW5kZXJQdWJsaWNLZXkoKWBcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHRoaXMuZ2V0U2VuZGVyUHVibGljS2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS51bnBhZEJ1ZmZlcikocHVibGljS2V5KS5sZW5ndGggIT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZW5kZXIncyBhZGRyZXNzXG4gICAgICovXG4gICAgZ2V0U2VuZGVyQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1dGlsXzEuQWRkcmVzcygoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykodGhpcy5nZXRTZW5kZXJQdWJsaWNLZXkoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBzaWduZWQgdHggaXMgcmV0dXJuZWQgYXMgYSBuZXcgb2JqZWN0LFxuICAgICAqIHVzZSBhcyBmb2xsb3dzOlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCBzaWduZWRUeCA9IHR4LnNpZ24ocHJpdmF0ZUtleSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzaWduKHByaXZhdGVLZXkpIHtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ1ByaXZhdGUga2V5IG11c3QgYmUgMzIgYnl0ZXMgaW4gbGVuZ3RoLicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFjayBmb3IgdGhlIGNvbnN0ZWxsYXRpb24gdGhhdCB3ZSBoYXZlIGdvdCBhIGxlZ2FjeSB0eCBhZnRlciBzcHVyaW91c0RyYWdvbiB3aXRoIGEgbm9uLUVJUDE1NSBjb25mb3JtaW5nIHNpZ25hdHVyZVxuICAgICAgICAvLyBhbmQgd2FudCB0byByZWNyZWF0ZSBhIHNpZ25hdHVyZSAod2hlcmUgRUlQMTU1IHNob3VsZCBiZSBhcHBsaWVkKVxuICAgICAgICAvLyBMZWF2aW5nIHRoaXMgaGFjayBsZXRzIHRoZSBsZWdhY3kuc3BlYy50cyAtPiBzaWduKCksIHZlcmlmeVNpZ25hdHVyZSgpIHRlc3QgZmFpbFxuICAgICAgICAvLyAyMDIxLTA2LTIzXG4gICAgICAgIGxldCBoYWNrQXBwbGllZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLmNvbW1vbi5ndGVIYXJkZm9yaygnc3B1cmlvdXNEcmFnb24nKSAmJlxuICAgICAgICAgICAgIXRoaXMuc3VwcG9ydHModHlwZXNfMS5DYXBhYmlsaXR5LkVJUDE1NVJlcGxheVByb3RlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNhcGFiaWxpdGllcy5wdXNoKHR5cGVzXzEuQ2FwYWJpbGl0eS5FSVAxNTVSZXBsYXlQcm90ZWN0aW9uKTtcbiAgICAgICAgICAgIGhhY2tBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtc2dIYXNoID0gdGhpcy5nZXRNZXNzYWdlVG9TaWduKHRydWUpO1xuICAgICAgICBjb25zdCB7IHYsIHIsIHMgfSA9ICgwLCB1dGlsXzEuZWNzaWduKShtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLl9wcm9jZXNzU2lnbmF0dXJlKHYsIHIsIHMpO1xuICAgICAgICAvLyBIYWNrIHBhcnQgMlxuICAgICAgICBpZiAoaGFja0FwcGxpZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5hY3RpdmVDYXBhYmlsaXRpZXMuaW5kZXhPZih0eXBlc18xLkNhcGFiaWxpdHkuRUlQMTU1UmVwbGF5UHJvdGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FwYWJpbGl0aWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIGNoYWluIElEIGNoZWNrcyBvbiBjb21tb24gYW5kIHJldHVybnMgYSBjb21tb25cbiAgICAgKiB0byBiZSB1c2VkIG9uIGluc3RhbnRpYXRpb25cbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tbW9uIC0ge0BsaW5rIENvbW1vbn0gaW5zdGFuY2UgZnJvbSB0eCBvcHRpb25zXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBJRCBmcm9tIHR4IG9wdGlvbnMgKHR5cGVkIHR4cykgb3Igc2lnbmF0dXJlIChsZWdhY3kgdHgpXG4gICAgICovXG4gICAgX2dldENvbW1vbihjb21tb24sIGNoYWluSWQpIHtcbiAgICAgICAgLy8gQ2hhaW4gSUQgcHJvdmlkZWRcbiAgICAgICAgaWYgKGNoYWluSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZEJpZ0ludCA9ICgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKGNoYWluSWQpKTtcbiAgICAgICAgICAgIGlmIChjb21tb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbW9uLmNoYWluSWQoKSAhPT0gY2hhaW5JZEJpZ0ludCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygnVGhlIGNoYWluIElEIGRvZXMgbm90IG1hdGNoIHRoZSBjaGFpbiBJRCBvZiBDb21tb24nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvbW1vbiBwcm92aWRlZCwgY2hhaW4gSUQgZG9lcyBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIC0+IFJldHVybiBwcm92aWRlZCBDb21tb25cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uLmNvcHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb21tb25fMS5Db21tb24uaXNTdXBwb3J0ZWRDaGFpbklkKGNoYWluSWRCaWdJbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIENvbW1vbiwgY2hhaW4gSUQgc3VwcG9ydGVkIGJ5IENvbW1vblxuICAgICAgICAgICAgICAgICAgICAvLyAtPiBJbnN0YW50aWF0ZSBDb21tb24gd2l0aCBjaGFpbiBJRFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvbW1vbl8xLkNvbW1vbih7IGNoYWluOiBjaGFpbklkQmlnSW50LCBoYXJkZm9yazogdGhpcy5ERUZBVUxUX0hBUkRGT1JLIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gQ29tbW9uLCBjaGFpbiBJRCBub3Qgc3VwcG9ydGVkIGJ5IENvbW1vblxuICAgICAgICAgICAgICAgICAgICAvLyAtPiBJbnN0YW50aWF0ZSBjdXN0b20gQ29tbW9uIGRlcml2ZWQgZnJvbSBERUZBVUxUX0NIQUlOXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5Db21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b20tY2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiBjaGFpbklkQmlnSW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZEJpZ0ludCxcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBiYXNlQ2hhaW46IHRoaXMuREVGQVVMVF9DSEFJTiwgaGFyZGZvcms6IHRoaXMuREVGQVVMVF9IQVJERk9SSyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBjaGFpbiBJRCBwcm92aWRlZFxuICAgICAgICAgICAgLy8gLT4gcmV0dXJuIENvbW1vbiBwcm92aWRlZCBvciBjcmVhdGUgbmV3IGRlZmF1bHQgQ29tbW9uXG4gICAgICAgICAgICByZXR1cm4gKGNvbW1vbj8uY29weSgpID8/IG5ldyBjb21tb25fMS5Db21tb24oeyBjaGFpbjogdGhpcy5ERUZBVUxUX0NIQUlOLCBoYXJkZm9yazogdGhpcy5ERUZBVUxUX0hBUkRGT1JLIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCBhbiBvYmplY3Qgd2l0aCBCaWdJbnQgdmFsdWVzIGNhbm5vdCBleGNlZWQgdGhlIHNwZWNpZmllZCBiaXQgbGltaXQuXG4gICAgICogQHBhcmFtIHZhbHVlcyBPYmplY3QgY29udGFpbmluZyBzdHJpbmcga2V5cyBhbmQgQmlnSW50IHZhbHVlc1xuICAgICAqIEBwYXJhbSBiaXRzIE51bWJlciBvZiBiaXRzIHRvIGNoZWNrICg2NCBvciAyNTYpXG4gICAgICogQHBhcmFtIGNhbm5vdEVxdWFsIFBhc3MgdHJ1ZSBpZiB0aGUgbnVtYmVyIGFsc28gY2Fubm90IGVxdWFsIG9uZSBsZXNzIHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlQ2Fubm90RXhjZWVkTWF4SW50ZWdlcih2YWx1ZXMsIGJpdHMgPSAyNTYsIGNhbm5vdEVxdWFsID0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWVzKSkge1xuICAgICAgICAgICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbm5vdEVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB1dGlsXzEuTUFYX1VJTlQ2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKGAke2tleX0gY2Fubm90IGVxdWFsIG9yIGV4Y2VlZCBNQVhfVUlOVDY0ICgyXjY0LTEpLCBnaXZlbiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPiB1dGlsXzEuTUFYX1VJTlQ2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKGAke2tleX0gY2Fubm90IGV4Y2VlZCBNQVhfVUlOVDY0ICgyXjY0LTEpLCBnaXZlbiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2Fubm90RXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHV0aWxfMS5NQVhfSU5URUdFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKGAke2tleX0gY2Fubm90IGVxdWFsIG9yIGV4Y2VlZCBNQVhfSU5URUdFUiAoMl4yNTYtMSksIGdpdmVuICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IHV0aWxfMS5NQVhfSU5URUdFUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKGAke2tleX0gY2Fubm90IGV4Y2VlZCBNQVhfSU5URUdFUiAoMl4yNTYtMSksIGdpdmVuICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygndW5pbXBsZW1lbnRlZCBiaXRzIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgX3ZhbGlkYXRlTm90QXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHR4RGF0YUtleXMgPSBbXG4gICAgICAgICAgICAnbm9uY2UnLFxuICAgICAgICAgICAgJ2dhc1ByaWNlJyxcbiAgICAgICAgICAgICdnYXNMaW1pdCcsXG4gICAgICAgICAgICAndG8nLFxuICAgICAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgICAgICdkYXRhJyxcbiAgICAgICAgICAgICd2JyxcbiAgICAgICAgICAgICdyJyxcbiAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICd0eXBlJyxcbiAgICAgICAgICAgICdiYXNlRmVlJyxcbiAgICAgICAgICAgICdtYXhGZWVQZXJHYXMnLFxuICAgICAgICAgICAgJ2NoYWluSWQnLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBpZiAodHhEYXRhS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9IGNhbm5vdCBiZSBhbiBhcnJheWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaGFyZWQgZXJyb3IgcG9zdGZpeCBwYXJ0IGZvciBfZXJyb3IoKSBtZXRob2RcbiAgICAgKiB0eCB0eXBlIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0U2hhcmVkRXJyb3JQb3N0Zml4KCkge1xuICAgICAgICBsZXQgaGFzaCA9ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGFzaCA9IHRoaXMuaXNTaWduZWQoKSA/ICgwLCB1dGlsXzEuYnVmZmVyVG9IZXgpKHRoaXMuaGFzaCgpKSA6ICdub3QgYXZhaWxhYmxlICh1bnNpZ25lZCknO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYXNoID0gJ2Vycm9yJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNTaWduZWQgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzU2lnbmVkID0gdGhpcy5pc1NpZ25lZCgpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhc2ggPSAnZXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZiA9ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGYgPSB0aGlzLmNvbW1vbi5oYXJkZm9yaygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoZiA9ICdlcnJvcic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvc3RmaXggPSBgdHggdHlwZT0ke3RoaXMudHlwZX0gaGFzaD0ke2hhc2h9IG5vbmNlPSR7dGhpcy5ub25jZX0gdmFsdWU9JHt0aGlzLnZhbHVlfSBgO1xuICAgICAgICBwb3N0Zml4ICs9IGBzaWduZWQ9JHtpc1NpZ25lZH0gaGY9JHtoZn1gO1xuICAgICAgICByZXR1cm4gcG9zdGZpeDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VUcmFuc2FjdGlvbiA9IEJhc2VUcmFuc2FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VUcmFuc2FjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKiBFSVA0ODQ0IGNvbnN0YW50cyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CWVRFU19QRVJfRklFTERfRUxFTUVOVCA9IGV4cG9ydHMuRklFTERfRUxFTUVOVFNfUEVSX0JMT0IgPSBleHBvcnRzLk1BWF9UWF9XUkFQX0taR19DT01NSVRNRU5UUyA9IGV4cG9ydHMuTElNSVRfQkxPQlNfUEVSX1RYID0gZXhwb3J0cy5NQVhfVkVSU0lPTkVEX0hBU0hFU19MSVNUX1NJWkUgPSBleHBvcnRzLk1BWF9BQ0NFU1NfTElTVF9TSVpFID0gZXhwb3J0cy5NQVhfQ0FMTERBVEFfU0laRSA9IHZvaWQgMDtcbmV4cG9ydHMuTUFYX0NBTExEQVRBX1NJWkUgPSAxNjc3NzIxNjsgLy8gMiAqKiAyNFxuZXhwb3J0cy5NQVhfQUNDRVNTX0xJU1RfU0laRSA9IDE2Nzc3MjE2OyAvLyAyICoqIDI0XG5leHBvcnRzLk1BWF9WRVJTSU9ORURfSEFTSEVTX0xJU1RfU0laRSA9IDE2Nzc3MjE2OyAvLyAyICoqIDI0XG5leHBvcnRzLkxJTUlUX0JMT0JTX1BFUl9UWCA9IDE2Nzc3MjE2OyAvLyAyICoqIDI0XG5leHBvcnRzLk1BWF9UWF9XUkFQX0taR19DT01NSVRNRU5UUyA9IDE2Nzc3MjE2OyAvLyAyICoqIDI0XG5leHBvcnRzLkZJRUxEX0VMRU1FTlRTX1BFUl9CTE9CID0gNDA5NjsgLy8gVGhpcyBpcyBhbHNvIGluIHRoZSBDb21tb24gNDg0NCBwYXJhbWV0ZXJzIGJ1dCBuZWVkZWQgaGVyZSBzaW5jZSB0eXBlcyBjYW4ndCBhY2Nlc3MgQ29tbW9uIHBhcmFtc1xuZXhwb3J0cy5CWVRFU19QRVJfRklFTERfRUxFTUVOVCA9IDMyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBybHBfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy9ybHBcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IGtlY2Nha18xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWtcIik7XG5jb25zdCBiYXNlVHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Jhc2VUcmFuc2FjdGlvblwiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBUUkFOU0FDVElPTl9UWVBFID0gMjtcbmNvbnN0IFRSQU5TQUNUSU9OX1RZUEVfQlVGRkVSID0gQnVmZmVyLmZyb20oVFJBTlNBQ1RJT05fVFlQRS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJ2hleCcpO1xuLyoqXG4gKiBUeXBlZCB0cmFuc2FjdGlvbiB3aXRoIGEgbmV3IGdhcyBmZWUgbWFya2V0IG1lY2hhbmlzbVxuICpcbiAqIC0gVHJhbnNhY3Rpb25UeXBlOiAyXG4gKiAtIEVJUDogW0VJUC0xNTU5XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NTkpXG4gKi9cbmNsYXNzIEZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbiBleHRlbmRzIGJhc2VUcmFuc2FjdGlvbl8xLkJhc2VUcmFuc2FjdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciB0YWtlcyB0aGUgdmFsdWVzLCB2YWxpZGF0ZXMgdGhlbSwgYXNzaWducyB0aGVtIGFuZCBmcmVlemVzIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQgdXNlXG4gICAgICogdGhlIHN0YXRpYyBmYWN0b3J5IG1ldGhvZHMgdG8gYXNzaXN0IGluIGNyZWF0aW5nIGEgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb21cbiAgICAgKiB2YXJ5aW5nIGRhdGEgdHlwZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHhEYXRhLCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoeyAuLi50eERhdGEsIHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUgfSwgb3B0cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBIRiBpZiB0aGUgdHggdHlwZSBpcyBhY3RpdmUgb24gdGhhdCBIRlxuICAgICAgICAgKiBvciB0aGUgZmlyc3QgZ3JlYXRlciBIRiB3aGVyZSB0aGUgdHggaXMgYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLkRFRkFVTFRfSEFSREZPUksgPSAnbG9uZG9uJztcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBhY2Nlc3NMaXN0LCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0gPSB0eERhdGE7XG4gICAgICAgIHRoaXMuY29tbW9uID0gdGhpcy5fZ2V0Q29tbW9uKG9wdHMuY29tbW9uLCBjaGFpbklkKTtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gdGhpcy5jb21tb24uY2hhaW5JZCgpO1xuICAgICAgICBpZiAodGhpcy5jb21tb24uaXNBY3RpdmF0ZWRFSVAoMTU1OSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VJUC0xNTU5IG5vdCBlbmFibGVkIG9uIENvbW1vbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FwYWJpbGl0aWVzID0gdGhpcy5hY3RpdmVDYXBhYmlsaXRpZXMuY29uY2F0KFsxNTU5LCAyNzE4LCAyOTMwXSk7XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBhY2Nlc3MgbGlzdCBmaWVsZHNcbiAgICAgICAgY29uc3QgYWNjZXNzTGlzdERhdGEgPSB1dGlsXzIuQWNjZXNzTGlzdHMuZ2V0QWNjZXNzTGlzdERhdGEoYWNjZXNzTGlzdCA/PyBbXSk7XG4gICAgICAgIHRoaXMuYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3REYXRhLmFjY2Vzc0xpc3Q7XG4gICAgICAgIHRoaXMuQWNjZXNzTGlzdEpTT04gPSBhY2Nlc3NMaXN0RGF0YS5BY2Nlc3NMaXN0SlNPTjtcbiAgICAgICAgLy8gVmVyaWZ5IHRoZSBhY2Nlc3MgbGlzdCBmb3JtYXQuXG4gICAgICAgIHV0aWxfMi5BY2Nlc3NMaXN0cy52ZXJpZnlBY2Nlc3NMaXN0KHRoaXMuYWNjZXNzTGlzdCk7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyR2FzID0gKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkoKDAsIHV0aWxfMS50b0J1ZmZlcikobWF4RmVlUGVyR2FzID09PSAnJyA/ICcweCcgOiBtYXhGZWVQZXJHYXMpKTtcbiAgICAgICAgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9ICgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKG1heFByaW9yaXR5RmVlUGVyR2FzID09PSAnJyA/ICcweCcgOiBtYXhQcmlvcml0eUZlZVBlckdhcykpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUNhbm5vdEV4Y2VlZE1heEludGVnZXIoe1xuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0aGlzLm1heEZlZVBlckdhcyxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICB9KTtcbiAgICAgICAgYmFzZVRyYW5zYWN0aW9uXzEuQmFzZVRyYW5zYWN0aW9uLl92YWxpZGF0ZU5vdEFycmF5KHR4RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmdhc0xpbWl0ICogdGhpcy5tYXhGZWVQZXJHYXMgPiB1dGlsXzEuTUFYX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKCdnYXNMaW1pdCAqIG1heEZlZVBlckdhcyBjYW5ub3QgZXhjZWVkIE1BWF9JTlRFR0VSICgyXjI1Ni0xKScpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzIDwgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ21heEZlZVBlckdhcyBjYW5ub3QgYmUgbGVzcyB0aGFuIG1heFByaW9yaXR5RmVlUGVyR2FzIChUaGUgdG90YWwgbXVzdCBiZSB0aGUgbGFyZ2VyIG9mIHRoZSB0d28pJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWxpZGF0ZVlQYXJpdHkoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVIaWdoUygpO1xuICAgICAgICBpZiAodGhpcy5jb21tb24uaXNBY3RpdmF0ZWRFSVAoMzg2MCkpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzIuY2hlY2tNYXhJbml0Q29kZVNpemUpKHRoaXMuY29tbW9uLCB0aGlzLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmVlemUgPSBvcHRzPy5mcmVlemUgPz8gdHJ1ZTtcbiAgICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIHRyYW5zYWN0aW9uIGZyb20gYSBkYXRhIGRpY3Rpb25hcnkuXG4gICAgICpcbiAgICAgKiBGb3JtYXQ6IHsgY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhc0xpbWl0LCB0bywgdmFsdWUsIGRhdGEsXG4gICAgICogYWNjZXNzTGlzdCwgdiwgciwgcyB9XG4gICAgICpcbiAgICAgKiBOb3RlczpcbiAgICAgKiAtIGBjaGFpbklkYCB3aWxsIGJlIHNldCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBwcm92aWRlZFxuICAgICAqIC0gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsIGFuZCBoYXZlIHNvbWUgYmFzaWMgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVR4RGF0YSh0eERhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbih0eERhdGEsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIHRyYW5zYWN0aW9uIGZyb20gdGhlIHNlcmlhbGl6ZWQgdHguXG4gICAgICpcbiAgICAgKiBGb3JtYXQ6IGAweDAyIHx8IHJscChbY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhc0xpbWl0LCB0bywgdmFsdWUsIGRhdGEsXG4gICAgICogYWNjZXNzTGlzdCwgc2lnbmF0dXJlWVBhcml0eSwgc2lnbmF0dXJlUiwgc2lnbmF0dXJlU10pYFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VyaWFsaXplZFR4KHNlcmlhbGl6ZWQsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAoIXNlcmlhbGl6ZWQuc2xpY2UoMCwgMSkuZXF1YWxzKFRSQU5TQUNUSU9OX1RZUEVfQlVGRkVSKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcmlhbGl6ZWQgdHggaW5wdXQ6IG5vdCBhbiBFSVAtMTU1OSB0cmFuc2FjdGlvbiAod3JvbmcgdHggdHlwZSwgZXhwZWN0ZWQ6ICR7VFJBTlNBQ1RJT05fVFlQRX0sIHJlY2VpdmVkOiAke3NlcmlhbGl6ZWRcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgMSlcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2hleCcpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9ICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKHJscF8xLlJMUC5kZWNvZGUoc2VyaWFsaXplZC5zbGljZSgxKSkpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcmlhbGl6ZWQgdHggaW5wdXQ6IG11c3QgYmUgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRmVlTWFya2V0RUlQMTU1OVRyYW5zYWN0aW9uLmZyb21WYWx1ZXNBcnJheSh2YWx1ZXMsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBmcm9tIGEgdmFsdWVzIGFycmF5LlxuICAgICAqXG4gICAgICogRm9ybWF0OiBgW2NoYWluSWQsIG5vbmNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLFxuICAgICAqIGFjY2Vzc0xpc3QsIHNpZ25hdHVyZVlQYXJpdHksIHNpZ25hdHVyZVIsIHNpZ25hdHVyZVNdYFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IDkgJiYgdmFsdWVzLmxlbmd0aCAhPT0gMTIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFSVAtMTU1OSB0cmFuc2FjdGlvbi4gT25seSBleHBlY3RpbmcgOSB2YWx1ZXMgKGZvciB1bnNpZ25lZCB0eCkgb3IgMTIgdmFsdWVzIChmb3Igc2lnbmVkIHR4KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhc0xpbWl0LCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3QsIHYsIHIsIHMsXSA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVOb3RBcnJheSh7IGNoYWluSWQsIHYgfSk7XG4gICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMpKHsgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhc0xpbWl0LCB2YWx1ZSwgdiwgciwgcyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgY2hhaW5JZDogKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkoY2hhaW5JZCksXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3QgPz8gW10sXG4gICAgICAgICAgICB2OiB2ICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KSh2KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBnYXMgcGFpZCBmb3IgdGhlIGRhdGEgaW4gdGhpcyB0eFxuICAgICAqL1xuICAgIGdldERhdGFGZWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmRhdGFGZWUgJiYgdGhpcy5jYWNoZS5kYXRhRmVlLmhhcmRmb3JrID09PSB0aGlzLmNvbW1vbi5oYXJkZm9yaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5kYXRhRmVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3N0ID0gc3VwZXIuZ2V0RGF0YUZlZSgpO1xuICAgICAgICBjb3N0ICs9IEJpZ0ludCh1dGlsXzIuQWNjZXNzTGlzdHMuZ2V0RGF0YUZlZUVJUDI5MzAodGhpcy5hY2Nlc3NMaXN0LCB0aGlzLmNvbW1vbikpO1xuICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmRhdGFGZWUgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGNvc3QsXG4gICAgICAgICAgICAgICAgaGFyZGZvcms6IHRoaXMuY29tbW9uLmhhcmRmb3JrKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3N0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdXAgZnJvbnQgYW1vdW50IHRoYXQgYW4gYWNjb3VudCBtdXN0IGhhdmUgZm9yIHRoaXMgdHJhbnNhY3Rpb24gdG8gYmUgdmFsaWRcbiAgICAgKiBAcGFyYW0gYmFzZUZlZSBUaGUgYmFzZSBmZWUgb2YgdGhlIGJsb2NrICh3aWxsIGJlIHNldCB0byAwIGlmIG5vdCBwcm92aWRlZClcbiAgICAgKi9cbiAgICBnZXRVcGZyb250Q29zdChiYXNlRmVlID0gQmlnSW50KDApKSB7XG4gICAgICAgIGNvbnN0IHByaW8gPSB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBjb25zdCBtYXhCYXNlID0gdGhpcy5tYXhGZWVQZXJHYXMgLSBiYXNlRmVlO1xuICAgICAgICBjb25zdCBpbmNsdXNpb25GZWVQZXJHYXMgPSBwcmlvIDwgbWF4QmFzZSA/IHByaW8gOiBtYXhCYXNlO1xuICAgICAgICBjb25zdCBnYXNQcmljZSA9IGluY2x1c2lvbkZlZVBlckdhcyArIGJhc2VGZWU7XG4gICAgICAgIHJldHVybiB0aGlzLmdhc0xpbWl0ICogZ2FzUHJpY2UgKyB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQnVmZmVyIEFycmF5IG9mIHRoZSByYXcgQnVmZmVycyBvZiB0aGUgRUlQLTE1NTkgdHJhbnNhY3Rpb24sIGluIG9yZGVyLlxuICAgICAqXG4gICAgICogRm9ybWF0OiBgW2NoYWluSWQsIG5vbmNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLFxuICAgICAqIGFjY2Vzc0xpc3QsIHNpZ25hdHVyZVlQYXJpdHksIHNpZ25hdHVyZVIsIHNpZ25hdHVyZVNdYFxuICAgICAqXG4gICAgICogVXNlIHtAbGluayBGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24uc2VyaWFsaXplfSB0byBhZGQgYSB0cmFuc2FjdGlvbiB0byBhIGJsb2NrXG4gICAgICogd2l0aCB7QGxpbmsgQmxvY2suZnJvbVZhbHVlc0FycmF5fS5cbiAgICAgKlxuICAgICAqIEZvciBhbiB1bnNpZ25lZCB0eCB0aGlzIG1ldGhvZCB1c2VzIHRoZSBlbXB0eSBCdWZmZXIgdmFsdWVzIGZvciB0aGVcbiAgICAgKiBzaWduYXR1cmUgcGFyYW1ldGVycyBgdmAsIGByYCBhbmQgYHNgIGZvciBlbmNvZGluZy4gRm9yIGFuIEVJUC0xNTUgY29tcGxpYW50XG4gICAgICogcmVwcmVzZW50YXRpb24gZm9yIGV4dGVybmFsIHNpZ25pbmcgdXNlIHtAbGluayBGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24uZ2V0TWVzc2FnZVRvU2lnbn0uXG4gICAgICovXG4gICAgcmF3KCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICB0aGlzLnRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvLmJ1ZiA6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy52YWx1ZSksXG4gICAgICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0aGlzLmFjY2Vzc0xpc3QsXG4gICAgICAgICAgICB0aGlzLnYgIT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy52KSA6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgIHRoaXMuciAhPT0gdW5kZWZpbmVkID8gKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLnIpIDogQnVmZmVyLmZyb20oW10pLFxuICAgICAgICAgICAgdGhpcy5zICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMucykgOiBCdWZmZXIuZnJvbShbXSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlcmlhbGl6ZWQgZW5jb2Rpbmcgb2YgdGhlIEVJUC0xNTU5IHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogRm9ybWF0OiBgMHgwMiB8fCBybHAoW2NoYWluSWQsIG5vbmNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLFxuICAgICAqIGFjY2Vzc0xpc3QsIHNpZ25hdHVyZVlQYXJpdHksIHNpZ25hdHVyZVIsIHNpZ25hdHVyZVNdKWBcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpbiBjb250cmFzdCB0byB0aGUgbGVnYWN5IHR4IHNlcmlhbGl6YXRpb24gZm9ybWF0IHRoaXMgaXMgbm90XG4gICAgICogdmFsaWQgUkxQIGFueSBtb3JlIGR1ZSB0byB0aGUgcmF3IHR4IHR5cGUgcHJlY2VkaW5nIGFuZCBjb25jYXRlbmF0ZWQgdG9cbiAgICAgKiB0aGUgUkxQIGVuY29kaW5nIG9mIHRoZSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5yYXcoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgVFJBTlNBQ1RJT05fVFlQRV9CVUZGRVIsXG4gICAgICAgICAgICBCdWZmZXIuZnJvbShybHBfMS5STFAuZW5jb2RlKCgwLCB1dGlsXzEuYnVmQXJyVG9BcnIpKGJhc2UpKSksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXJpYWxpemVkIHVuc2lnbmVkIHR4IChoYXNoZWQgb3IgcmF3KSwgd2hpY2ggY2FuIGJlIHVzZWRcbiAgICAgKiB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiAoZS5nLiBmb3Igc2VuZGluZyB0byBhIGhhcmR3YXJlIHdhbGxldCkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpbiBjb250cmFzdCB0byB0aGUgbGVnYWN5IHR4IHRoZSByYXcgbWVzc2FnZSBmb3JtYXQgaXMgYWxyZWFkeVxuICAgICAqIHNlcmlhbGl6ZWQgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBSTFAgZW5jb2RlZCBhbnkgbW9yZS5cbiAgICAgKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCBzZXJpYWxpemVkTWVzc2FnZSA9IHR4LmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpIC8vIHVzZSB0aGlzIGZvciB0aGUgSFcgd2FsbGV0IGlucHV0XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFzaE1lc3NhZ2UgLSBSZXR1cm4gaGFzaGVkIG1lc3NhZ2UgaWYgc2V0IHRvIHRydWUgKGRlZmF1bHQ6IHRydWUpXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZVRvU2lnbihoYXNoTWVzc2FnZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMucmF3KCkuc2xpY2UoMCwgOSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgIFRSQU5TQUNUSU9OX1RZUEVfQlVGRkVSLFxuICAgICAgICAgICAgQnVmZmVyLmZyb20ocmxwXzEuUkxQLmVuY29kZSgoMCwgdXRpbF8xLmJ1ZkFyclRvQXJyKShiYXNlKSkpLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGhhc2hNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikobWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSBzaGEzLTI1NiBoYXNoIG9mIHRoZSBzZXJpYWxpemVkIHR4LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBmb3Igc2lnbmVkIHR4cyAoaXQgdGhyb3dzIG90aGVyd2lzZSkuXG4gICAgICogVXNlIHtAbGluayBGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24uZ2V0TWVzc2FnZVRvU2lnbn0gdG8gZ2V0IGEgdHggaGFzaCBmb3IgdGhlIHB1cnBvc2Ugb2Ygc2lnbmluZy5cbiAgICAgKi9cbiAgICBoYXNoKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ0Nhbm5vdCBjYWxsIGhhc2ggbWV0aG9kIGlmIHRyYW5zYWN0aW9uIGlzIG5vdCBzaWduZWQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4odGhpcykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5oYXNoID0gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikodGhpcy5zZXJpYWxpemUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikodGhpcy5zZXJpYWxpemUoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIHNoYTMtMjU2IGhhc2ggd2hpY2ggY2FuIGJlIHVzZWQgdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgICAgKi9cbiAgICBnZXRNZXNzYWdlVG9WZXJpZnlTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1lc3NhZ2VUb1NpZ24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyXG4gICAgICovXG4gICAgZ2V0U2VuZGVyUHVibGljS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ0Nhbm5vdCBjYWxsIHRoaXMgbWV0aG9kIGlmIHRyYW5zYWN0aW9uIGlzIG5vdCBzaWduZWQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZ0hhc2ggPSB0aGlzLmdldE1lc3NhZ2VUb1ZlcmlmeVNpZ25hdHVyZSgpO1xuICAgICAgICBjb25zdCB7IHYsIHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSGlnaFMoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmVjcmVjb3ZlcikobXNnSGFzaCwgdiArIEJpZ0ludCgyNyksIC8vIFJlY292ZXIgdGhlIDI3IHdoaWNoIHdhcyBzdHJpcHBlZCBmcm9tIGVjc2lnblxuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKShyKSwgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKShzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKCdJbnZhbGlkIFNpZ25hdHVyZScpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Byb2Nlc3NTaWduYXR1cmUodiwgciwgcykge1xuICAgICAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLnR4T3B0aW9ucywgY29tbW9uOiB0aGlzLmNvbW1vbiB9O1xuICAgICAgICByZXR1cm4gRmVlTWFya2V0RUlQMTU1OVRyYW5zYWN0aW9uLmZyb21UeERhdGEoe1xuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbklkLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdGhpcy5tYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICBnYXNMaW1pdDogdGhpcy5nYXNMaW1pdCxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiB0aGlzLmFjY2Vzc0xpc3QsXG4gICAgICAgICAgICB2OiB2IC0gQmlnSW50KDI3KSxcbiAgICAgICAgICAgIHI6ICgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKHIpLFxuICAgICAgICAgICAgczogKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkocyksXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzTGlzdEpTT04gPSB1dGlsXzIuQWNjZXNzTGlzdHMuZ2V0QWNjZXNzTGlzdEpTT04odGhpcy5hY2Nlc3NMaXN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYWluSWQ6ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBub25jZTogKDAsIHV0aWxfMS5iaWdJbnRUb0hleCkodGhpcy5ub25jZSksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogKDAsIHV0aWxfMS5iaWdJbnRUb0hleCkodGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWx1ZTogKDAsIHV0aWxfMS5iaWdJbnRUb0hleCkodGhpcy52YWx1ZSksXG4gICAgICAgICAgICBkYXRhOiAnMHgnICsgdGhpcy5kYXRhLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3RKU09OLFxuICAgICAgICAgICAgdjogdGhpcy52ICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnYpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcjogdGhpcy5yICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgczogdGhpcy5zICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnMpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb21wYWN0IGVycm9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZXJyb3JTdHIoKSB7XG4gICAgICAgIGxldCBlcnJvclN0ciA9IHRoaXMuX2dldFNoYXJlZEVycm9yUG9zdGZpeCgpO1xuICAgICAgICBlcnJvclN0ciArPSBgIG1heEZlZVBlckdhcz0ke3RoaXMubWF4RmVlUGVyR2FzfSBtYXhQcmlvcml0eUZlZVBlckdhcz0ke3RoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXN9YDtcbiAgICAgICAgcmV0dXJuIGVycm9yU3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGFubm90YXRlZCBlcnJvciBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXNnIEJhc2UgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfZXJyb3JNc2cobXNnKSB7XG4gICAgICAgIHJldHVybiBgJHttc2d9ICgke3RoaXMuZXJyb3JTdHIoKX0pYDtcbiAgICB9XG59XG5leHBvcnRzLkZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbiA9IEZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVpcDE1NTlUcmFuc2FjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWNjZXNzTGlzdEVJUDI5MzBUcmFuc2FjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHJscF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3JscFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IGJhc2VUcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vYmFzZVRyYW5zYWN0aW9uXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IFRSQU5TQUNUSU9OX1RZUEUgPSAxO1xuY29uc3QgVFJBTlNBQ1RJT05fVFlQRV9CVUZGRVIgPSBCdWZmZXIuZnJvbShUUkFOU0FDVElPTl9UWVBFLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnaGV4Jyk7XG4vKipcbiAqIFR5cGVkIHRyYW5zYWN0aW9uIHdpdGggb3B0aW9uYWwgYWNjZXNzIGxpc3RzXG4gKlxuICogLSBUcmFuc2FjdGlvblR5cGU6IDFcbiAqIC0gRUlQOiBbRUlQLTI5MzBdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjkzMClcbiAqL1xuY2xhc3MgQWNjZXNzTGlzdEVJUDI5MzBUcmFuc2FjdGlvbiBleHRlbmRzIGJhc2VUcmFuc2FjdGlvbl8xLkJhc2VUcmFuc2FjdGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciB0YWtlcyB0aGUgdmFsdWVzLCB2YWxpZGF0ZXMgdGhlbSwgYXNzaWducyB0aGVtIGFuZCBmcmVlemVzIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQgdXNlXG4gICAgICogdGhlIHN0YXRpYyBmYWN0b3J5IG1ldGhvZHMgdG8gYXNzaXN0IGluIGNyZWF0aW5nIGEgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb21cbiAgICAgKiB2YXJ5aW5nIGRhdGEgdHlwZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHhEYXRhLCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoeyAuLi50eERhdGEsIHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUgfSwgb3B0cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBIRiBpZiB0aGUgdHggdHlwZSBpcyBhY3RpdmUgb24gdGhhdCBIRlxuICAgICAgICAgKiBvciB0aGUgZmlyc3QgZ3JlYXRlciBIRiB3aGVyZSB0aGUgdHggaXMgYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLkRFRkFVTFRfSEFSREZPUksgPSAnYmVybGluJztcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBhY2Nlc3NMaXN0LCBnYXNQcmljZSB9ID0gdHhEYXRhO1xuICAgICAgICB0aGlzLmNvbW1vbiA9IHRoaXMuX2dldENvbW1vbihvcHRzLmNvbW1vbiwgY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IHRoaXMuY29tbW9uLmNoYWluSWQoKTtcbiAgICAgICAgLy8gRUlQLTI3MTggY2hlY2sgaXMgZG9uZSBpbiBDb21tb25cbiAgICAgICAgaWYgKCF0aGlzLmNvbW1vbi5pc0FjdGl2YXRlZEVJUCgyOTMwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFSVAtMjkzMCBub3QgZW5hYmxlZCBvbiBDb21tb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUNhcGFiaWxpdGllcyA9IHRoaXMuYWN0aXZlQ2FwYWJpbGl0aWVzLmNvbmNhdChbMjcxOCwgMjkzMF0pO1xuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgYWNjZXNzIGxpc3QgZmllbGRzXG4gICAgICAgIGNvbnN0IGFjY2Vzc0xpc3REYXRhID0gdXRpbF8yLkFjY2Vzc0xpc3RzLmdldEFjY2Vzc0xpc3REYXRhKGFjY2Vzc0xpc3QgPz8gW10pO1xuICAgICAgICB0aGlzLmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0RGF0YS5hY2Nlc3NMaXN0O1xuICAgICAgICB0aGlzLkFjY2Vzc0xpc3RKU09OID0gYWNjZXNzTGlzdERhdGEuQWNjZXNzTGlzdEpTT047XG4gICAgICAgIC8vIFZlcmlmeSB0aGUgYWNjZXNzIGxpc3QgZm9ybWF0LlxuICAgICAgICB1dGlsXzIuQWNjZXNzTGlzdHMudmVyaWZ5QWNjZXNzTGlzdCh0aGlzLmFjY2Vzc0xpc3QpO1xuICAgICAgICB0aGlzLmdhc1ByaWNlID0gKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkoKDAsIHV0aWxfMS50b0J1ZmZlcikoZ2FzUHJpY2UgPT09ICcnID8gJzB4JyA6IGdhc1ByaWNlKSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQ2Fubm90RXhjZWVkTWF4SW50ZWdlcih7XG4gICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nYXNQcmljZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2VUcmFuc2FjdGlvbl8xLkJhc2VUcmFuc2FjdGlvbi5fdmFsaWRhdGVOb3RBcnJheSh0eERhdGEpO1xuICAgICAgICBpZiAodGhpcy5nYXNQcmljZSAqIHRoaXMuZ2FzTGltaXQgPiB1dGlsXzEuTUFYX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKCdnYXNMaW1pdCAqIGdhc1ByaWNlIGNhbm5vdCBleGNlZWQgTUFYX0lOVEVHRVInKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlWVBhcml0eSgpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUhpZ2hTKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbW1vbi5pc0FjdGl2YXRlZEVJUCgzODYwKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMi5jaGVja01heEluaXRDb2RlU2l6ZSkodGhpcy5jb21tb24sIHRoaXMuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyZWV6ZSA9IG9wdHM/LmZyZWV6ZSA/PyB0cnVlO1xuICAgICAgICBpZiAoZnJlZXplKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgdHJhbnNhY3Rpb24gZnJvbSBhIGRhdGEgZGljdGlvbmFyeS5cbiAgICAgKlxuICAgICAqIEZvcm1hdDogeyBjaGFpbklkLCBub25jZSwgZ2FzUHJpY2UsIGdhc0xpbWl0LCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3QsXG4gICAgICogdiwgciwgcyB9XG4gICAgICpcbiAgICAgKiBOb3RlczpcbiAgICAgKiAtIGBjaGFpbklkYCB3aWxsIGJlIHNldCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBwcm92aWRlZFxuICAgICAqIC0gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsIGFuZCBoYXZlIHNvbWUgYmFzaWMgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVR4RGF0YSh0eERhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEFjY2Vzc0xpc3RFSVAyOTMwVHJhbnNhY3Rpb24odHhEYXRhLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSB0cmFuc2FjdGlvbiBmcm9tIHRoZSBzZXJpYWxpemVkIHR4LlxuICAgICAqXG4gICAgICogRm9ybWF0OiBgMHgwMSB8fCBybHAoW2NoYWluSWQsIG5vbmNlLCBnYXNQcmljZSwgZ2FzTGltaXQsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdCxcbiAgICAgKiBzaWduYXR1cmVZUGFyaXR5ICh2KSwgc2lnbmF0dXJlUiAociksIHNpZ25hdHVyZVMgKHMpXSlgXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZXJpYWxpemVkVHgoc2VyaWFsaXplZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICghc2VyaWFsaXplZC5zbGljZSgwLCAxKS5lcXVhbHMoVFJBTlNBQ1RJT05fVFlQRV9CVUZGRVIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VyaWFsaXplZCB0eCBpbnB1dDogbm90IGFuIEVJUC0yOTMwIHRyYW5zYWN0aW9uICh3cm9uZyB0eCB0eXBlLCBleHBlY3RlZDogJHtUUkFOU0FDVElPTl9UWVBFfSwgcmVjZWl2ZWQ6ICR7c2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIC5zbGljZSgwLCAxKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygnaGV4Jyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVzID0gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikocmxwXzEuUkxQLmRlY29kZShVaW50OEFycmF5LmZyb20oc2VyaWFsaXplZC5zbGljZSgxKSkpKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJpYWxpemVkIHR4IGlucHV0OiBtdXN0IGJlIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFjY2Vzc0xpc3RFSVAyOTMwVHJhbnNhY3Rpb24uZnJvbVZhbHVlc0FycmF5KHZhbHVlcywgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGZyb20gYSB2YWx1ZXMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBGb3JtYXQ6IGBbY2hhaW5JZCwgbm9uY2UsIGdhc1ByaWNlLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0LFxuICAgICAqIHNpZ25hdHVyZVlQYXJpdHkgKHYpLCBzaWduYXR1cmVSIChyKSwgc2lnbmF0dXJlUyAocyldYFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IDggJiYgdmFsdWVzLmxlbmd0aCAhPT0gMTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFSVAtMjkzMCB0cmFuc2FjdGlvbi4gT25seSBleHBlY3RpbmcgOCB2YWx1ZXMgKGZvciB1bnNpZ25lZCB0eCkgb3IgMTEgdmFsdWVzIChmb3Igc2lnbmVkIHR4KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY2hhaW5JZCwgbm9uY2UsIGdhc1ByaWNlLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0LCB2LCByLCBzXSA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVOb3RBcnJheSh7IGNoYWluSWQsIHYgfSk7XG4gICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMpKHsgbm9uY2UsIGdhc1ByaWNlLCBnYXNMaW1pdCwgdmFsdWUsIHYsIHIsIHMgfSk7XG4gICAgICAgIGNvbnN0IGVtcHR5QWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICByZXR1cm4gbmV3IEFjY2Vzc0xpc3RFSVAyOTMwVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgY2hhaW5JZDogKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkoY2hhaW5JZCksXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3QgPz8gZW1wdHlBY2Nlc3NMaXN0LFxuICAgICAgICAgICAgdjogdiAhPT0gdW5kZWZpbmVkID8gKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkodikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgZ2FzIHBhaWQgZm9yIHRoZSBkYXRhIGluIHRoaXMgdHhcbiAgICAgKi9cbiAgICBnZXREYXRhRmVlKCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5kYXRhRmVlICYmIHRoaXMuY2FjaGUuZGF0YUZlZS5oYXJkZm9yayA9PT0gdGhpcy5jb21tb24uaGFyZGZvcmsoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGF0YUZlZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29zdCA9IHN1cGVyLmdldERhdGFGZWUoKTtcbiAgICAgICAgY29zdCArPSBCaWdJbnQodXRpbF8yLkFjY2Vzc0xpc3RzLmdldERhdGFGZWVFSVAyOTMwKHRoaXMuYWNjZXNzTGlzdCwgdGhpcy5jb21tb24pKTtcbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbih0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5kYXRhRmVlID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb3N0LFxuICAgICAgICAgICAgICAgIGhhcmRmb3JrOiB0aGlzLmNvbW1vbi5oYXJkZm9yaygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29zdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHVwIGZyb250IGFtb3VudCB0aGF0IGFuIGFjY291bnQgbXVzdCBoYXZlIGZvciB0aGlzIHRyYW5zYWN0aW9uIHRvIGJlIHZhbGlkXG4gICAgICovXG4gICAgZ2V0VXBmcm9udENvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhc0xpbWl0ICogdGhpcy5nYXNQcmljZSArIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCdWZmZXIgQXJyYXkgb2YgdGhlIHJhdyBCdWZmZXJzIG9mIHRoZSBFSVAtMjkzMCB0cmFuc2FjdGlvbiwgaW4gb3JkZXIuXG4gICAgICpcbiAgICAgKiBGb3JtYXQ6IGBbY2hhaW5JZCwgbm9uY2UsIGdhc1ByaWNlLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0LFxuICAgICAqIHNpZ25hdHVyZVlQYXJpdHkgKHYpLCBzaWduYXR1cmVSIChyKSwgc2lnbmF0dXJlUyAocyldYFxuICAgICAqXG4gICAgICogVXNlIHtAbGluayBBY2Nlc3NMaXN0RUlQMjkzMFRyYW5zYWN0aW9uLnNlcmlhbGl6ZX0gdG8gYWRkIGEgdHJhbnNhY3Rpb24gdG8gYSBibG9ja1xuICAgICAqIHdpdGgge0BsaW5rIEJsb2NrLmZyb21WYWx1ZXNBcnJheX0uXG4gICAgICpcbiAgICAgKiBGb3IgYW4gdW5zaWduZWQgdHggdGhpcyBtZXRob2QgdXNlcyB0aGUgZW1wdHkgQnVmZmVyIHZhbHVlcyBmb3IgdGhlXG4gICAgICogc2lnbmF0dXJlIHBhcmFtZXRlcnMgYHZgLCBgcmAgYW5kIGBzYCBmb3IgZW5jb2RpbmcuIEZvciBhbiBFSVAtMTU1IGNvbXBsaWFudFxuICAgICAqIHJlcHJlc2VudGF0aW9uIGZvciBleHRlcm5hbCBzaWduaW5nIHVzZSB7QGxpbmsgQWNjZXNzTGlzdEVJUDI5MzBUcmFuc2FjdGlvbi5nZXRNZXNzYWdlVG9TaWdufS5cbiAgICAgKi9cbiAgICByYXcoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMubm9uY2UpLFxuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICB0aGlzLnRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvLmJ1ZiA6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy52YWx1ZSksXG4gICAgICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0aGlzLmFjY2Vzc0xpc3QsXG4gICAgICAgICAgICB0aGlzLnYgIT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy52KSA6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgIHRoaXMuciAhPT0gdW5kZWZpbmVkID8gKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLnIpIDogQnVmZmVyLmZyb20oW10pLFxuICAgICAgICAgICAgdGhpcy5zICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMucykgOiBCdWZmZXIuZnJvbShbXSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlcmlhbGl6ZWQgZW5jb2Rpbmcgb2YgdGhlIEVJUC0yOTMwIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogRm9ybWF0OiBgMHgwMSB8fCBybHAoW2NoYWluSWQsIG5vbmNlLCBnYXNQcmljZSwgZ2FzTGltaXQsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdCxcbiAgICAgKiBzaWduYXR1cmVZUGFyaXR5ICh2KSwgc2lnbmF0dXJlUiAociksIHNpZ25hdHVyZVMgKHMpXSlgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaW4gY29udHJhc3QgdG8gdGhlIGxlZ2FjeSB0eCBzZXJpYWxpemF0aW9uIGZvcm1hdCB0aGlzIGlzIG5vdFxuICAgICAqIHZhbGlkIFJMUCBhbnkgbW9yZSBkdWUgdG8gdGhlIHJhdyB0eCB0eXBlIHByZWNlZGluZyBhbmQgY29uY2F0ZW5hdGVkIHRvXG4gICAgICogdGhlIFJMUCBlbmNvZGluZyBvZiB0aGUgdmFsdWVzLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMucmF3KCk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgIFRSQU5TQUNUSU9OX1RZUEVfQlVGRkVSLFxuICAgICAgICAgICAgQnVmZmVyLmZyb20ocmxwXzEuUkxQLmVuY29kZSgoMCwgdXRpbF8xLmJ1ZkFyclRvQXJyKShiYXNlKSkpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2VyaWFsaXplZCB1bnNpZ25lZCB0eCAoaGFzaGVkIG9yIHJhdyksIHdoaWNoIGNhbiBiZSB1c2VkXG4gICAgICogdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gKGUuZy4gZm9yIHNlbmRpbmcgdG8gYSBoYXJkd2FyZSB3YWxsZXQpLlxuICAgICAqXG4gICAgICogTm90ZTogaW4gY29udHJhc3QgdG8gdGhlIGxlZ2FjeSB0eCB0aGUgcmF3IG1lc3NhZ2UgZm9ybWF0IGlzIGFscmVhZHlcbiAgICAgKiBzZXJpYWxpemVkIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgUkxQIGVuY29kZWQgYW55IG1vcmUuXG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSB0eC5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKSAvLyB1c2UgdGhpcyBmb3IgdGhlIEhXIHdhbGxldCBpbnB1dFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGhhc2hNZXNzYWdlIC0gUmV0dXJuIGhhc2hlZCBtZXNzYWdlIGlmIHNldCB0byB0cnVlIChkZWZhdWx0OiB0cnVlKVxuICAgICAqL1xuICAgIGdldE1lc3NhZ2VUb1NpZ24oaGFzaE1lc3NhZ2UgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLnJhdygpLnNsaWNlKDAsIDgpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBUUkFOU0FDVElPTl9UWVBFX0JVRkZFUixcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHJscF8xLlJMUC5lbmNvZGUoKDAsIHV0aWxfMS5idWZBcnJUb0FycikoYmFzZSkpKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChoYXNoTWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKG1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgc2hhMy0yNTYgaGFzaCBvZiB0aGUgc2VyaWFsaXplZCB0eC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgZm9yIHNpZ25lZCB0eHMgKGl0IHRocm93cyBvdGhlcndpc2UpLlxuICAgICAqIFVzZSB7QGxpbmsgQWNjZXNzTGlzdEVJUDI5MzBUcmFuc2FjdGlvbi5nZXRNZXNzYWdlVG9TaWdufSB0byBnZXQgYSB0eCBoYXNoIGZvciB0aGUgcHVycG9zZSBvZiBzaWduaW5nLlxuICAgICAqL1xuICAgIGhhc2goKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NpZ25lZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygnQ2Fubm90IGNhbGwgaGFzaCBtZXRob2QgaWYgdHJhbnNhY3Rpb24gaXMgbm90IHNpZ25lZCcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbih0aGlzKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmhhc2ggPSBCdWZmZXIuZnJvbSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSh0aGlzLnNlcmlhbGl6ZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSh0aGlzLnNlcmlhbGl6ZSgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgc2hhMy0yNTYgaGFzaCB3aGljaCBjYW4gYmUgdXNlZCB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGdldE1lc3NhZ2VUb1ZlcmlmeVNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWVzc2FnZVRvU2lnbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXJcbiAgICAgKi9cbiAgICBnZXRTZW5kZXJQdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NpZ25lZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygnQ2Fubm90IGNhbGwgdGhpcyBtZXRob2QgaWYgdHJhbnNhY3Rpb24gaXMgbm90IHNpZ25lZCcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnSGFzaCA9IHRoaXMuZ2V0TWVzc2FnZVRvVmVyaWZ5U2lnbmF0dXJlKCk7XG4gICAgICAgIGNvbnN0IHsgdiwgciwgcyB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVIaWdoUygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuZWNyZWNvdmVyKShtc2dIYXNoLCB2ICsgQmlnSW50KDI3KSwgLy8gUmVjb3ZlciB0aGUgMjcgd2hpY2ggd2FzIHN0cmlwcGVkIGZyb20gZWNzaWduXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHIpLCAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ0ludmFsaWQgU2lnbmF0dXJlJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJvY2Vzc1NpZ25hdHVyZSh2LCByLCBzKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMudHhPcHRpb25zLCBjb21tb246IHRoaXMuY29tbW9uIH07XG4gICAgICAgIHJldHVybiBBY2Nlc3NMaXN0RUlQMjkzMFRyYW5zYWN0aW9uLmZyb21UeERhdGEoe1xuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbklkLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nYXNQcmljZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0aGlzLmdhc0xpbWl0LFxuICAgICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IHRoaXMuYWNjZXNzTGlzdCxcbiAgICAgICAgICAgIHY6IHYgLSBCaWdJbnQoMjcpLFxuICAgICAgICAgICAgcjogKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkociksXG4gICAgICAgICAgICBzOiAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KShzKSxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NMaXN0SlNPTiA9IHV0aWxfMi5BY2Nlc3NMaXN0cy5nZXRBY2Nlc3NMaXN0SlNPTih0aGlzLmFjY2Vzc0xpc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhaW5JZDogKDAsIHV0aWxfMS5iaWdJbnRUb0hleCkodGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIG5vbmNlOiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWx1ZTogKDAsIHV0aWxfMS5iaWdJbnRUb0hleCkodGhpcy52YWx1ZSksXG4gICAgICAgICAgICBkYXRhOiAnMHgnICsgdGhpcy5kYXRhLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3RKU09OLFxuICAgICAgICAgICAgdjogdGhpcy52ICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnYpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcjogdGhpcy5yICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgczogdGhpcy5zICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnMpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb21wYWN0IGVycm9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgZXJyb3JTdHIoKSB7XG4gICAgICAgIGxldCBlcnJvclN0ciA9IHRoaXMuX2dldFNoYXJlZEVycm9yUG9zdGZpeCgpO1xuICAgICAgICAvLyBLZWVwID8gZm9yIHRoaXMuYWNjZXNzTGlzdCBzaW5jZSB0aGlzIG90aGVyd2lzZSBjYXVzZXMgSGFyZGhhdCBFMkUgdGVzdHMgdG8gZmFpbFxuICAgICAgICBlcnJvclN0ciArPSBgIGdhc1ByaWNlPSR7dGhpcy5nYXNQcmljZX0gYWNjZXNzTGlzdENvdW50PSR7dGhpcy5hY2Nlc3NMaXN0Py5sZW5ndGggPz8gMH1gO1xuICAgICAgICByZXR1cm4gZXJyb3JTdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYW4gYW5ub3RhdGVkIGVycm9yIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgQmFzZSBlcnJvciBtZXNzYWdlXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIF9lcnJvck1zZyhtc2cpIHtcbiAgICAgICAgcmV0dXJuIGAke21zZ30gKCR7dGhpcy5lcnJvclN0cigpfSlgO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjZXNzTGlzdEVJUDI5MzBUcmFuc2FjdGlvbiA9IEFjY2Vzc0xpc3RFSVAyOTMwVHJhbnNhY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1laXAyOTMwVHJhbnNhY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsb2JFSVA0ODQ0VHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBzc3pfMSA9IHJlcXVpcmUoXCJAY2hhaW5zYWZlL3NzelwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IGJhc2VUcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vYmFzZVRyYW5zYWN0aW9uXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBremdfMSA9IHJlcXVpcmUoXCIuL2t6Zy9remdcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgYmxvYkhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2Jsb2JIZWxwZXJzXCIpO1xuY29uc3QgVFJBTlNBQ1RJT05fVFlQRSA9IDB4MDU7XG5jb25zdCBUUkFOU0FDVElPTl9UWVBFX0JVRkZFUiA9IEJ1ZmZlci5mcm9tKFRSQU5TQUNUSU9OX1RZUEUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICdoZXgnKTtcbmNvbnN0IHZhbGlkYXRlQmxvYlRyYW5zYWN0aW9uTmV0d29ya1dyYXBwZXIgPSAodmVyc2lvbmVkSGFzaGVzLCBibG9icywgY29tbWl0bWVudHMsIGt6Z1Byb29mLCB2ZXJzaW9uKSA9PiB7XG4gICAgaWYgKCEodmVyc2lvbmVkSGFzaGVzLmxlbmd0aCA9PT0gYmxvYnMubGVuZ3RoICYmIGJsb2JzLmxlbmd0aCA9PT0gY29tbWl0bWVudHMubGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiB2ZXJzaW9uZWRIYXNoZXMsIGJsb2JzLCBhbmQgY29tbWl0bWVudHMgbm90IGFsbCBlcXVhbCcpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBremdfMS5remcudmVyaWZ5QWdncmVnYXRlS3pnUHJvb2YoYmxvYnMsIGNvbW1pdG1lbnRzLCBremdQcm9vZik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS1pHIHByb29mIGNhbm5vdCBiZSB2ZXJpZmllZCBmcm9tIGJsb2JzL2NvbW1pdG1lbnRzJyk7XG4gICAgfVxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdmVyc2lvbmVkSGFzaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkVmVyc2lvbmVkSGFzaCA9ICgwLCBibG9iSGVscGVyc18xLmNvbXB1dGVWZXJzaW9uZWRIYXNoKShjb21taXRtZW50c1t4XSwgdmVyc2lvbik7XG4gICAgICAgIGlmICghKDAsIHNzel8xLmJ5dGVBcnJheUVxdWFscykoY29tcHV0ZWRWZXJzaW9uZWRIYXNoLCB2ZXJzaW9uZWRIYXNoZXNbeF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbW1pdG1lbnQgZm9yIGJsb2IgYXQgaW5kZXggJHt4fSBkb2VzIG5vdCBtYXRjaCB2ZXJzaW9uZWRIYXNoYCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBUeXBlZCB0cmFuc2FjdGlvbiB3aXRoIGEgbmV3IGdhcyBmZWUgbWFya2V0IG1lY2hhbmlzbSBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgaW5jbHVkZSBcImJsb2JzXCIgb2YgZGF0YVxuICpcbiAqIC0gVHJhbnNhY3Rpb25UeXBlOiA1XG4gKiAtIEVJUDogW0VJUC00ODQ0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQ4NDQpXG4gKi9cbmNsYXNzIEJsb2JFSVA0ODQ0VHJhbnNhY3Rpb24gZXh0ZW5kcyBiYXNlVHJhbnNhY3Rpb25fMS5CYXNlVHJhbnNhY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29uc3RydWN0b3IgdGFrZXMgdGhlIHZhbHVlcywgdmFsaWRhdGVzIHRoZW0sIGFzc2lnbnMgdGhlbSBhbmQgZnJlZXplcyB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZVxuICAgICAqIHRoZSBzdGF0aWMgY29uc3RydWN0b3JzIG9yIGZhY3RvcnkgbWV0aG9kcyB0byBhc3Npc3QgaW4gY3JlYXRpbmcgYSBUcmFuc2FjdGlvbiBvYmplY3QgZnJvbVxuICAgICAqIHZhcnlpbmcgZGF0YSB0eXBlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eERhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcih7IC4uLnR4RGF0YSwgdHlwZTogVFJBTlNBQ1RJT05fVFlQRSB9LCBvcHRzKTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBhY2Nlc3NMaXN0LCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJEYXRhR2FzIH0gPSB0eERhdGE7XG4gICAgICAgIHRoaXMuY29tbW9uID0gdGhpcy5fZ2V0Q29tbW9uKG9wdHMuY29tbW9uLCBjaGFpbklkKTtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gdGhpcy5jb21tb24uY2hhaW5JZCgpO1xuICAgICAgICBpZiAodGhpcy5jb21tb24uaXNBY3RpdmF0ZWRFSVAoMTU1OSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VJUC0xNTU5IG5vdCBlbmFibGVkIG9uIENvbW1vbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbW1vbi5pc0FjdGl2YXRlZEVJUCg0ODQ0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQLTQ4NDQgbm90IGVuYWJsZWQgb24gQ29tbW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVDYXBhYmlsaXRpZXMgPSB0aGlzLmFjdGl2ZUNhcGFiaWxpdGllcy5jb25jYXQoWzE1NTksIDI3MTgsIDI5MzBdKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGFjY2VzcyBsaXN0IGZpZWxkc1xuICAgICAgICBjb25zdCBhY2Nlc3NMaXN0RGF0YSA9IHV0aWxfMi5BY2Nlc3NMaXN0cy5nZXRBY2Nlc3NMaXN0RGF0YShhY2Nlc3NMaXN0ID8/IFtdKTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdERhdGEuYWNjZXNzTGlzdDtcbiAgICAgICAgdGhpcy5BY2Nlc3NMaXN0SlNPTiA9IGFjY2Vzc0xpc3REYXRhLkFjY2Vzc0xpc3RKU09OO1xuICAgICAgICAvLyBWZXJpZnkgdGhlIGFjY2VzcyBsaXN0IGZvcm1hdC5cbiAgICAgICAgdXRpbF8yLkFjY2Vzc0xpc3RzLnZlcmlmeUFjY2Vzc0xpc3QodGhpcy5hY2Nlc3NMaXN0KTtcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJHYXMgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KSgoMCwgdXRpbF8xLnRvQnVmZmVyKShtYXhGZWVQZXJHYXMgPT09ICcnID8gJzB4JyA6IG1heEZlZVBlckdhcykpO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKDAsIHV0aWxfMS5idWZmZXJUb0JpZ0ludCkoKDAsIHV0aWxfMS50b0J1ZmZlcikobWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICcnID8gJzB4JyA6IG1heFByaW9yaXR5RmVlUGVyR2FzKSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQ2Fubm90RXhjZWVkTWF4SW50ZWdlcih7XG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRoaXMubWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlVHJhbnNhY3Rpb25fMS5CYXNlVHJhbnNhY3Rpb24uX3ZhbGlkYXRlTm90QXJyYXkodHhEYXRhKTtcbiAgICAgICAgaWYgKHRoaXMuZ2FzTGltaXQgKiB0aGlzLm1heEZlZVBlckdhcyA+IHV0aWxfMS5NQVhfSU5URUdFUikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ2dhc0xpbWl0ICogbWF4RmVlUGVyR2FzIGNhbm5vdCBleGNlZWQgTUFYX0lOVEVHRVIgKDJeMjU2LTEpJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhGZWVQZXJHYXMgPCB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygnbWF4RmVlUGVyR2FzIGNhbm5vdCBiZSBsZXNzIHRoYW4gbWF4UHJpb3JpdHlGZWVQZXJHYXMgKFRoZSB0b3RhbCBtdXN0IGJlIHRoZSBsYXJnZXIgb2YgdGhlIHR3byknKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4RmVlUGVyRGF0YUdhcyA9ICgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKChtYXhGZWVQZXJEYXRhR2FzID8/ICcnKSA9PT0gJycgPyAnMHgnIDogbWF4RmVlUGVyRGF0YUdhcykpO1xuICAgICAgICB0aGlzLnZlcnNpb25lZEhhc2hlcyA9ICh0eERhdGEudmVyc2lvbmVkSGFzaGVzID8/IFtdKS5tYXAoKHZoKSA9PiAoMCwgdXRpbF8xLnRvQnVmZmVyKSh2aCkpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVlQYXJpdHkoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVIaWdoUygpO1xuICAgICAgICBpZiAodGhpcy5jb21tb24uaXNBY3RpdmF0ZWRFSVAoMzg2MCkpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzIuY2hlY2tNYXhJbml0Q29kZVNpemUpKHRoaXMuY29tbW9uLCB0aGlzLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgdGhpcy52ZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNoLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygndmVyc2lvbmVkIGhhc2ggaXMgaW52YWxpZCBsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCaWdJbnQoaGFzaFswXSkgIT09IHRoaXMuY29tbW9uLnBhcmFtQnlFSVAoJ3NoYXJkaW5nJywgJ2Jsb2JDb21taXRtZW50VmVyc2lvbkt6ZycsIDQ4NDQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ3ZlcnNpb25lZCBoYXNoIGRvZXMgbm90IHN0YXJ0IHdpdGggS1pHIGNvbW1pdG1lbnQgdmVyc2lvbicpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25lZEhhc2hlcy5sZW5ndGggPiBjb25zdGFudHNfMS5MSU1JVF9CTE9CU19QRVJfVFgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKGB0eCBjYW4gY29udGFpbiBhdCBtb3N0ICR7Y29uc3RhbnRzXzEuTElNSVRfQkxPQlNfUEVSX1RYfSBibG9ic2ApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibG9icyA9IHR4RGF0YS5ibG9icz8ubWFwKChibG9iKSA9PiAoMCwgdXRpbF8xLnRvQnVmZmVyKShibG9iKSk7XG4gICAgICAgIHRoaXMua3pnQ29tbWl0bWVudHMgPSB0eERhdGEua3pnQ29tbWl0bWVudHM/Lm1hcCgoY29tbWl0bWVudCkgPT4gKDAsIHV0aWxfMS50b0J1ZmZlcikoY29tbWl0bWVudCkpO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZUt6Z1Byb29mID0gKDAsIHV0aWxfMS50b0J1ZmZlcikodHhEYXRhLmt6Z1Byb29mKTtcbiAgICAgICAgY29uc3QgZnJlZXplID0gb3B0cz8uZnJlZXplID8/IHRydWU7XG4gICAgICAgIGlmIChmcmVlemUpIHtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21UeERhdGEodHhEYXRhLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYkVJUDQ4NDRUcmFuc2FjdGlvbih0eERhdGEsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtaW5pbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgYmxvYiB0cmFuc2FjdGlvbiBmcm9tIHRoZSBuZXR3b3JrIHdyYXBwZXIgdmVyc2lvbi5cbiAgICAgKiBUaGUgbWluaW1hbCByZXByZXNlbnRhdGlvbiBpcyB1c2VkIHdoZW4gYWRkaW5nIHRyYW5zYWN0aW9ucyB0byBhbiBleGVjdXRpb24gcGF5bG9hZC9ibG9ja1xuICAgICAqIEBwYXJhbSB0eERhdGEgYSB7QGxpbmsgQmxvYkVJUDQ4NDRUcmFuc2FjdGlvbn0gY29udGFpbmluZyBvcHRpb25hbCBibG9icy9remcgY29tbWl0bWVudHNcbiAgICAgKiBAcGFyYW0gb3B0cyAtIGRpY3Rpb25hcnkgb2Yge0BsaW5rIFR4T3B0aW9uc31cbiAgICAgKiBAcmV0dXJucyB0aGUgXCJtaW5pbWFsXCIgcmVwcmVzZW50YXRpb24gb2YgYSBCbG9iRUlQNDg0NFRyYW5zYWN0aW9uIChpLmUuIHRyYW5zYWN0aW9uIG9iamVjdCBtaW51cyBibG9icyBhbmQga3pnIGNvbW1pdG1lbnRzKVxuICAgICAqL1xuICAgIHN0YXRpYyBtaW5pbWFsRnJvbU5ldHdvcmtXcmFwcGVyKHR4RGF0YSwgb3B0cykge1xuICAgICAgICBjb25zdCB0eCA9IEJsb2JFSVA0ODQ0VHJhbnNhY3Rpb24uZnJvbVR4RGF0YSh7XG4gICAgICAgICAgICAuLi50eERhdGEsXG4gICAgICAgICAgICAuLi57IGJsb2JzOiB1bmRlZmluZWQsIGt6Z0NvbW1pdG1lbnRzOiB1bmRlZmluZWQsIGt6Z1Byb29mOiB1bmRlZmluZWQgfSxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRyYW5zYWN0aW9uIGZyb20gdGhlIG5ldHdvcmsgZW5jb2Rpbmcgb2YgYSBibG9iIHRyYW5zYWN0aW9uICh3aXRoIGJsb2JzL2NvbW1pdG1lbnRzL3Byb29mKVxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVkIGEgYnVmZmVyIHJlcHJlc2VudGluZyBhIHNlcmlhbGl6ZWQgQmxvYlRyYW5zYWN0aW9uTmV0d29ya1dyYXBwZXJcbiAgICAgKiBAcGFyYW0gb3B0cyBhbnkgVHhPcHRpb25zIGRlZmluZWRcbiAgICAgKiBAcmV0dXJucyBhIEJsb2JFSVA0ODQ0VHJhbnNhY3Rpb25cbiAgICAgKiBAdGhyb3dzIGlmIG5vIEtaRyBsaWJyYXJ5IGlzIGxvYWRlZCAtLSB1c2luZyB0aGUgYGluaXRLemdgIGhlbHBlciBtZXRob2QgLS0gb3IgaWYgYG9wdHMuY29tbW9uYCBub3QgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlcmlhbGl6ZWRCbG9iVHhOZXR3b3JrV3JhcHBlcihzZXJpYWxpemVkLCBvcHRzKSB7XG4gICAgICAgIGlmICghb3B0cyB8fCAhb3B0cy5jb21tb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29tbW9uIGluc3RhbmNlIHJlcXVpcmVkIHRvIHZhbGlkYXRlIHZlcnNpb25lZCBoYXNoZXMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSBuZXR3b3JrIHdyYXBwZXJcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHR5cGVzXzEuQmxvYk5ldHdvcmtUcmFuc2FjdGlvbldyYXBwZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZC5zbGljZSgxKSk7XG4gICAgICAgIGNvbnN0IGRlY29kZWRUeCA9IHdyYXBwZXIudHgubWVzc2FnZTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IE51bWJlcihvcHRzLmNvbW1vbi5wYXJhbUJ5RUlQKCdzaGFyZGluZycsICdibG9iQ29tbWl0bWVudFZlcnNpb25LemcnLCA0ODQ0KSk7XG4gICAgICAgIHZhbGlkYXRlQmxvYlRyYW5zYWN0aW9uTmV0d29ya1dyYXBwZXIoZGVjb2RlZFR4LmJsb2JWZXJzaW9uZWRIYXNoZXMsIHdyYXBwZXIuYmxvYnMsIHdyYXBwZXIuYmxvYkt6Z3MsIHdyYXBwZXIua3pnQWdncmVnYXRlZFByb29mLCB2ZXJzaW9uKTtcbiAgICAgICAgY29uc3QgYWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RJdGVtIG9mIGRlY29kZWRUeC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gQnVmZmVyLmZyb20obGlzdEl0ZW0uYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IGxpc3RJdGVtLnN0b3JhZ2VLZXlzLm1hcCgoa2V5KSA9PiBCdWZmZXIuZnJvbShrZXkpKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0xpc3RJdGVtID0gW2FkZHJlc3MsIHN0b3JhZ2VLZXlzXTtcbiAgICAgICAgICAgIGFjY2Vzc0xpc3QucHVzaChhY2Nlc3NMaXN0SXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG8gPSBkZWNvZGVkVHgudG8udmFsdWUgPT09IG51bGxcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHV0aWxfMS5BZGRyZXNzLmZyb21TdHJpbmcoKDAsIHV0aWxfMS5idWZmZXJUb0hleCkoQnVmZmVyLmZyb20oZGVjb2RlZFR4LnRvLnZhbHVlKSkpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBkZWNvZGVkVHguYmxvYlZlcnNpb25lZEhhc2hlcy5tYXAoKGVsKSA9PiBCdWZmZXIuZnJvbShlbCkpO1xuICAgICAgICBjb25zdCBjb21taXRtZW50cyA9IHdyYXBwZXIuYmxvYkt6Z3MubWFwKChlbCkgPT4gQnVmZmVyLmZyb20oZWwpKTtcbiAgICAgICAgY29uc3QgYmxvYnMgPSB3cmFwcGVyLmJsb2JzLm1hcCgoZWwpID0+IEJ1ZmZlci5mcm9tKGVsKSk7XG4gICAgICAgIGNvbnN0IHR4RGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmRlY29kZWRUeCxcbiAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMsXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdCxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBibG9icyxcbiAgICAgICAgICAgICAgICBremdDb21taXRtZW50czogY29tbWl0bWVudHMsXG4gICAgICAgICAgICAgICAga3pnUHJvb2Y6IEJ1ZmZlci5mcm9tKHdyYXBwZXIua3pnQWdncmVnYXRlZFByb29mKSxcbiAgICAgICAgICAgICAgICByOiB3cmFwcGVyLnR4LnNpZ25hdHVyZS5yLFxuICAgICAgICAgICAgICAgIHM6IHdyYXBwZXIudHguc2lnbmF0dXJlLnMsXG4gICAgICAgICAgICAgICAgdjogQmlnSW50KHdyYXBwZXIudHguc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgICAgICAgICAgICAgIGdhc0xpbWl0OiBkZWNvZGVkVHguZ2FzLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogZGVjb2RlZFR4Lm1heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZGVjb2RlZFR4Lm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iRUlQNDg0NFRyYW5zYWN0aW9uKHR4RGF0YSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0cmFuc2FjdGlvbiBmcm9tIHRoZSBcIm1pbmltYWxcIiBlbmNvZGluZyBvZiBhIGJsb2IgdHJhbnNhY3Rpb24gKHdpdGhvdXQgYmxvYnMvY29tbWl0bWVudHMva3pnIHByb29mKVxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVkIGEgYnVmZmVyIHJlcHJlc2VudGluZyBhIHNlcmlhbGl6ZWQgc2lnbmVkIGJsb2IgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0cyBhbnkgVHhPcHRpb25zIGRlZmluZWRcbiAgICAgKiBAcmV0dXJucyBhIEJsb2JFSVA0ODQ0VHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlcmlhbGl6ZWRUeChzZXJpYWxpemVkLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB0eXBlc18xLlNpZ25lZEJsb2JUcmFuc2FjdGlvblR5cGUuZGVzZXJpYWxpemUoc2VyaWFsaXplZC5zbGljZSgxKSk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVjb2RlZC5tZXNzYWdlO1xuICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGlzdEl0ZW0gb2YgdHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IEJ1ZmZlci5mcm9tKGxpc3RJdGVtLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSBsaXN0SXRlbS5zdG9yYWdlS2V5cy5tYXAoKGtleSkgPT4gQnVmZmVyLmZyb20oa2V5KSk7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0SXRlbSA9IFthZGRyZXNzLCBzdG9yYWdlS2V5c107XG4gICAgICAgICAgICBhY2Nlc3NMaXN0LnB1c2goYWNjZXNzTGlzdEl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvID0gdHgudG8udmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB1dGlsXzEuQWRkcmVzcy5mcm9tU3RyaW5nKCgwLCB1dGlsXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5mcm9tKHR4LnRvLnZhbHVlKSkpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzLm1hcCgoZWwpID0+IEJ1ZmZlci5mcm9tKGVsKSk7XG4gICAgICAgIGNvbnN0IHR4RGF0YSA9IHtcbiAgICAgICAgICAgIC4uLnR4LFxuICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgIHZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBhY2Nlc3NMaXN0LFxuICAgICAgICAgICAgICAgIHI6IGRlY29kZWQuc2lnbmF0dXJlLnIsXG4gICAgICAgICAgICAgICAgczogZGVjb2RlZC5zaWduYXR1cmUucyxcbiAgICAgICAgICAgICAgICB2OiBCaWdJbnQoZGVjb2RlZC5zaWduYXR1cmUueVBhcml0eSksXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQ6IGRlY29kZWQubWVzc2FnZS5nYXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEJsb2JFSVA0ODQ0VHJhbnNhY3Rpb24odHhEYXRhLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHVwIGZyb250IGFtb3VudCB0aGF0IGFuIGFjY291bnQgbXVzdCBoYXZlIGZvciB0aGlzIHRyYW5zYWN0aW9uIHRvIGJlIHZhbGlkXG4gICAgICogQHBhcmFtIGJhc2VGZWUgVGhlIGJhc2UgZmVlIG9mIHRoZSBibG9jayAod2lsbCBiZSBzZXQgdG8gMCBpZiBub3QgcHJvdmlkZWQpXG4gICAgICovXG4gICAgZ2V0VXBmcm9udENvc3QoYmFzZUZlZSA9IEJpZ0ludCgwKSkge1xuICAgICAgICBjb25zdCBwcmlvID0gdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgY29uc3QgbWF4QmFzZSA9IHRoaXMubWF4RmVlUGVyR2FzIC0gYmFzZUZlZTtcbiAgICAgICAgY29uc3QgaW5jbHVzaW9uRmVlUGVyR2FzID0gcHJpbyA8IG1heEJhc2UgPyBwcmlvIDogbWF4QmFzZTtcbiAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSBpbmNsdXNpb25GZWVQZXJHYXMgKyBiYXNlRmVlO1xuICAgICAgICByZXR1cm4gdGhpcy5nYXNMaW1pdCAqIGdhc1ByaWNlICsgdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGZvciBibG9iIHRyYW5zYWN0aW9ucyBhcyB0aGUgYHJhd2AgbWV0aG9kIGlzIHVzZWQgZXhjbHVzaXZlbHkgd2l0aFxuICAgICAqIHJscCBlbmNvZGluZyBhbmQgdGhlc2UgdHJhbnNhY3Rpb25zIHVzZSBTU1ogZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICovXG4gICAgcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHRvVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHRvID0ge1xuICAgICAgICAgICAgc2VsZWN0b3I6IHRoaXMudG8gIT09IHVuZGVmaW5lZCA/IDEgOiAwLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG8/LnRvQnVmZmVyKCkgPz8gbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLmNvbW1vbi5jaGFpbklkKCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0aGlzLm1heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBnYXM6IHRoaXMuZ2FzTGltaXQsXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IHRoaXMuYWNjZXNzTGlzdC5tYXAoKGxpc3RJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGFkZHJlc3M6IGxpc3RJdGVtWzBdLCBzdG9yYWdlS2V5czogbGlzdEl0ZW1bMV0gfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiB0aGlzLnZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJEYXRhR2FzOiB0aGlzLm1heEZlZVBlckRhdGFHYXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVE9ETzogRGVjaWRlIGhvdyB0byBzZXJpYWxpemUgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIHNpZ25hdHVyZToge1xuICAgICAgICAgICAgICAgIHI6IHRoaXMuciA/PyBCaWdJbnQoMCksXG4gICAgICAgICAgICAgICAgczogdGhpcy5zID8/IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiB0aGlzLnYgPT09IEJpZ0ludCgxKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSBhIGJsb2IgdHJhbnNhY3Rpb24gdG8gdGhlIGV4ZWN1dGlvbiBwYXlsb2FkIHZhcmlhbnRcbiAgICAgKiBAcmV0dXJucyB0aGUgbWluaW11bSAoZXhlY3V0aW9uIHBheWxvYWQpIHNlcmlhbGl6YXRpb24gb2YgYSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNzekVuY29kZWRUeCA9IHR5cGVzXzEuU2lnbmVkQmxvYlRyYW5zYWN0aW9uVHlwZS5zZXJpYWxpemUodGhpcy50b1ZhbHVlKCkpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbVFJBTlNBQ1RJT05fVFlQRV9CVUZGRVIsIHNzekVuY29kZWRUeF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIGEgYmxvYiB0cmFuc2FjdGlvbiBpbiB0aGUgbmV0d29yayB3cmFwcGVyIGZvcm1hdCAodXNlZCBmb3IgZ29zc2lwcGluZyBtZW1wb29sIHRyYW5zYWN0aW9ucyBvdmVyIGRldnAycClcbiAgICAgKi9cbiAgICBzZXJpYWxpemVOZXR3b3JrV3JhcHBlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvYnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdGhpcy5remdDb21taXRtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0ZUt6Z1Byb29mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNlcmlhbGl6ZSBuZXR3b3JrIHdyYXBwZXIgd2l0aG91dCBibG9icywgS1pHIGNvbW1pdG1lbnRzIGFuZCBhZ2dyZWdhdGUgS1pHIHByb29mIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG8gPSB7XG4gICAgICAgICAgICBzZWxlY3RvcjogdGhpcy50byAhPT0gdW5kZWZpbmVkID8gMSA6IDAsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50bz8udG9CdWZmZXIoKSA/PyBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBibG9iQXJyYXlzID0gdGhpcy5ibG9icz8ubWFwKChibG9iKSA9PiBVaW50OEFycmF5LmZyb20oYmxvYikpID8/IFtdO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkVHhXcmFwcGVyID0gdHlwZXNfMS5CbG9iTmV0d29ya1RyYW5zYWN0aW9uV3JhcHBlci5zZXJpYWxpemUoe1xuICAgICAgICAgICAgYmxvYnM6IGJsb2JBcnJheXMsXG4gICAgICAgICAgICBibG9iS3pnczogdGhpcy5remdDb21taXRtZW50cz8ubWFwKChjb21taXRtZW50KSA9PiBVaW50OEFycmF5LmZyb20oY29tbWl0bWVudCkpID8/IFtdLFxuICAgICAgICAgICAgdHg6IHsgLi4uKDAsIHV0aWxfMi5ibG9iVHhUb05ldHdvcmtXcmFwcGVyRGF0YUZvcm1hdCkodGhpcyksIC4uLnRvIH0sXG4gICAgICAgICAgICBremdBZ2dyZWdhdGVkUHJvb2Y6IFVpbnQ4QXJyYXkuZnJvbSh0aGlzLmFnZ3JlZ2F0ZUt6Z1Byb29mID8/IFtdKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMHgwNV0pLCBzZXJpYWxpemVkVHhXcmFwcGVyXSk7XG4gICAgfVxuICAgIGdldE1lc3NhZ2VUb1NpZ24oX2hhc2hNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkSGFzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoYXNoIG9mIGEgYmxvYiB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHVuc2lnbmVkSGFzaCgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gdHlwZXNfMS5CbG9iVHJhbnNhY3Rpb25UeXBlLnNlcmlhbGl6ZSh0aGlzLnRvVmFsdWUoKS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKEJ1ZmZlci5jb25jYXQoW1RSQU5TQUNUSU9OX1RZUEVfQlVGRkVSLCBzZXJpYWxpemVkVHhdKSkpO1xuICAgIH1cbiAgICBoYXNoKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikodGhpcy5zZXJpYWxpemUoKSkpO1xuICAgIH1cbiAgICBnZXRNZXNzYWdlVG9WZXJpZnlTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1lc3NhZ2VUb1NpZ24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyXG4gICAgICovXG4gICAgZ2V0U2VuZGVyUHVibGljS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ0Nhbm5vdCBjYWxsIHRoaXMgbWV0aG9kIGlmIHRyYW5zYWN0aW9uIGlzIG5vdCBzaWduZWQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZ0hhc2ggPSB0aGlzLmdldE1lc3NhZ2VUb1ZlcmlmeVNpZ25hdHVyZSgpO1xuICAgICAgICBjb25zdCB7IHYsIHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSGlnaFMoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmVjcmVjb3ZlcikobXNnSGFzaCwgdiArIEJpZ0ludCgyNyksIC8vIFJlY292ZXIgdGhlIDI3IHdoaWNoIHdhcyBzdHJpcHBlZCBmcm9tIGVjc2lnblxuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKShyKSwgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKShzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKCdJbnZhbGlkIFNpZ25hdHVyZScpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NMaXN0SlNPTiA9IHV0aWxfMi5BY2Nlc3NMaXN0cy5nZXRBY2Nlc3NMaXN0SlNPTih0aGlzLmFjY2Vzc0xpc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhaW5JZDogKDAsIHV0aWxfMS5iaWdJbnRUb0hleCkodGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIG5vbmNlOiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogKDAsIHV0aWxfMS5iaWdJbnRUb0hleCkodGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgdG86IHRoaXMudG8gIT09IHVuZGVmaW5lZCA/IHRoaXMudG8udG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbHVlOiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGRhdGE6ICcweCcgKyB0aGlzLmRhdGEudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdEpTT04sXG4gICAgICAgICAgICB2OiB0aGlzLnYgIT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMudikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByOiB0aGlzLnIgIT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMucikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzOiB0aGlzLnMgIT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMucykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtYXhGZWVQZXJEYXRhR2FzOiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLm1heEZlZVBlckRhdGFHYXMpLFxuICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzOiB0aGlzLnZlcnNpb25lZEhhc2hlcy5tYXAoKGhhc2gpID0+ICgwLCB1dGlsXzEuYnVmZmVyVG9IZXgpKGhhc2gpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3Byb2Nlc3NTaWduYXR1cmUodiwgciwgcykge1xuICAgICAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLnR4T3B0aW9ucywgY29tbW9uOiB0aGlzLmNvbW1vbiB9O1xuICAgICAgICByZXR1cm4gQmxvYkVJUDQ4NDRUcmFuc2FjdGlvbi5mcm9tVHhEYXRhKHtcbiAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZCxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRoaXMubWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRoaXMuZ2FzTGltaXQsXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdGhpcy5hY2Nlc3NMaXN0LFxuICAgICAgICAgICAgdjogdiAtIEJpZ0ludCgyNyksXG4gICAgICAgICAgICByOiAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KShyKSxcbiAgICAgICAgICAgIHM6ICgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKHMpLFxuICAgICAgICAgICAgbWF4RmVlUGVyRGF0YUdhczogdGhpcy5tYXhGZWVQZXJEYXRhR2FzLFxuICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzOiB0aGlzLnZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgIGJsb2JzOiB0aGlzLmJsb2JzLFxuICAgICAgICAgICAga3pnQ29tbWl0bWVudHM6IHRoaXMua3pnQ29tbWl0bWVudHMsXG4gICAgICAgICAgICBremdQcm9vZjogdGhpcy5hZ2dyZWdhdGVLemdQcm9vZixcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvbXBhY3QgZXJyb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBlcnJvclN0cigpIHtcbiAgICAgICAgbGV0IGVycm9yU3RyID0gdGhpcy5fZ2V0U2hhcmVkRXJyb3JQb3N0Zml4KCk7XG4gICAgICAgIGVycm9yU3RyICs9IGAgbWF4RmVlUGVyR2FzPSR7dGhpcy5tYXhGZWVQZXJHYXN9IG1heFByaW9yaXR5RmVlUGVyR2FzPSR7dGhpcy5tYXhQcmlvcml0eUZlZVBlckdhc31gO1xuICAgICAgICByZXR1cm4gZXJyb3JTdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYW4gYW5ub3RhdGVkIGVycm9yIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgQmFzZSBlcnJvciBtZXNzYWdlXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIF9lcnJvck1zZyhtc2cpIHtcbiAgICAgICAgcmV0dXJuIGAke21zZ30gKCR7dGhpcy5lcnJvclN0cigpfSlgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIG9mIGJsb2JzIGluY2x1ZGVkIHdpdGggdGhpcyB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIG51bUJsb2JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uZWRIYXNoZXMubGVuZ3RoO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYkVJUDQ4NDRUcmFuc2FjdGlvbiA9IEJsb2JFSVA0ODQ0VHJhbnNhY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1laXA0ODQ0VHJhbnNhY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZVR4UGFyYW1zID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCBub3JtYWxpemVUeFBhcmFtcyA9IChfdHhQYXJhbXMpID0+IHtcbiAgICBjb25zdCB0eFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIF90eFBhcmFtcyk7XG4gICAgdHhQYXJhbXMuZ2FzTGltaXQgPSAoMCwgdXRpbF8xLnRvVHlwZSkodHhQYXJhbXMuZ2FzTGltaXQgPz8gdHhQYXJhbXMuZ2FzLCB1dGlsXzEuVHlwZU91dHB1dC5CaWdJbnQpO1xuICAgIHR4UGFyYW1zLmRhdGEgPSB0eFBhcmFtcy5kYXRhID09PSB1bmRlZmluZWQgPyB0eFBhcmFtcy5pbnB1dCA6IHR4UGFyYW1zLmRhdGE7XG4gICAgLy8gY2hlY2sgYW5kIGNvbnZlcnQgZ2FzUHJpY2UgYW5kIHZhbHVlIHBhcmFtc1xuICAgIHR4UGFyYW1zLmdhc1ByaWNlID0gdHhQYXJhbXMuZ2FzUHJpY2UgIT09IHVuZGVmaW5lZCA/IEJpZ0ludCh0eFBhcmFtcy5nYXNQcmljZSkgOiB1bmRlZmluZWQ7XG4gICAgdHhQYXJhbXMudmFsdWUgPSB0eFBhcmFtcy52YWx1ZSAhPT0gdW5kZWZpbmVkID8gQmlnSW50KHR4UGFyYW1zLnZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBzdHJpY3QgYnl0ZSBsZW5ndGggY2hlY2tpbmdcbiAgICB0eFBhcmFtcy50byA9XG4gICAgICAgIHR4UGFyYW1zLnRvICE9PSBudWxsICYmIHR4UGFyYW1zLnRvICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gKDAsIHV0aWxfMS5zZXRMZW5ndGhMZWZ0KSgoMCwgdXRpbF8xLnRvQnVmZmVyKSh0eFBhcmFtcy50byksIDIwKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIHR4UGFyYW1zLnYgPSAoMCwgdXRpbF8xLnRvVHlwZSkodHhQYXJhbXMudiwgdXRpbF8xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICByZXR1cm4gdHhQYXJhbXM7XG59O1xuZXhwb3J0cy5ub3JtYWxpemVUeFBhcmFtcyA9IG5vcm1hbGl6ZVR4UGFyYW1zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbVJwYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wdXRlVmVyc2lvbmVkSGFzaCA9IGV4cG9ydHMuVHJhbnNhY3Rpb25GYWN0b3J5ID0gZXhwb3J0cy5UcmFuc2FjdGlvbiA9IGV4cG9ydHMua3pnID0gZXhwb3J0cy5pbml0S1pHID0gZXhwb3J0cy5CbG9iRUlQNDg0NFRyYW5zYWN0aW9uID0gZXhwb3J0cy5BY2Nlc3NMaXN0RUlQMjkzMFRyYW5zYWN0aW9uID0gZXhwb3J0cy5GZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24gPSB2b2lkIDA7XG52YXIgZWlwMTU1OVRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9laXAxNTU5VHJhbnNhY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVpcDE1NTlUcmFuc2FjdGlvbl8xLkZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbjsgfSB9KTtcbnZhciBlaXAyOTMwVHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2VpcDI5MzBUcmFuc2FjdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFjY2Vzc0xpc3RFSVAyOTMwVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVpcDI5MzBUcmFuc2FjdGlvbl8xLkFjY2Vzc0xpc3RFSVAyOTMwVHJhbnNhY3Rpb247IH0gfSk7XG52YXIgZWlwNDg0NFRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9laXA0ODQ0VHJhbnNhY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCbG9iRUlQNDg0NFRyYW5zYWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlaXA0ODQ0VHJhbnNhY3Rpb25fMS5CbG9iRUlQNDg0NFRyYW5zYWN0aW9uOyB9IH0pO1xudmFyIGt6Z18xID0gcmVxdWlyZShcIi4va3pnL2t6Z1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaXRLWkdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGt6Z18xLmluaXRLWkc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJremdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGt6Z18xLmt6ZzsgfSB9KTtcbnZhciBsZWdhY3lUcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vbGVnYWN5VHJhbnNhY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGVnYWN5VHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbjsgfSB9KTtcbnZhciB0cmFuc2FjdGlvbkZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uRmFjdG9yeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uRmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNhY3Rpb25GYWN0b3J5XzEuVHJhbnNhY3Rpb25GYWN0b3J5OyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbnZhciBibG9iSGVscGVyc18xID0gcmVxdWlyZShcIi4vdXRpbHMvYmxvYkhlbHBlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlVmVyc2lvbmVkSGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmxvYkhlbHBlcnNfMS5jb21wdXRlVmVyc2lvbmVkSGFzaDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0S1pHID0gZXhwb3J0cy5remcgPSB2b2lkIDA7XG5mdW5jdGlvbiBremdOb3RMb2FkZWQoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2t6ZyBsaWJyYXJ5IG5vdCBsb2FkZWQnKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzXG5leHBvcnRzLmt6ZyA9IHtcbiAgICBmcmVlVHJ1c3RlZFNldHVwOiBremdOb3RMb2FkZWQsXG4gICAgbG9hZFRydXN0ZWRTZXR1cDoga3pnTm90TG9hZGVkLFxuICAgIGJsb2JUb0t6Z0NvbW1pdG1lbnQ6IGt6Z05vdExvYWRlZCxcbiAgICBjb21wdXRlQWdncmVnYXRlS3pnUHJvb2Y6IGt6Z05vdExvYWRlZCxcbiAgICB2ZXJpZnlLemdQcm9vZjoga3pnTm90TG9hZGVkLFxuICAgIHZlcmlmeUFnZ3JlZ2F0ZUt6Z1Byb29mOiBremdOb3RMb2FkZWQsXG59O1xuLyoqXG4gKiBAcGFyYW0ga3pnTGliIGEgS1pHIGltcGxlbWVudGF0aW9uIChkZWZhdWx0cyB0byBjLWt6ZylcbiAqIEBwYXJhbSB0cnVzdGVkU2V0dXBQYXRoIHRoZSBmdWxsIHBhdGggKGUuZy4gXCIvaG9tZS9saW51eC9kZXZuZXQ0LnR4dFwiKSB0byBhIGt6ZyB0cnVzdGVkIHNldHVwIHRleHQgZmlsZVxuICovXG5mdW5jdGlvbiBpbml0S1pHKGt6Z0xpYiwgdHJ1c3RlZFNldHVwUGF0aCkge1xuICAgIGV4cG9ydHMua3pnID0ga3pnTGliO1xuICAgIGV4cG9ydHMua3pnLmxvYWRUcnVzdGVkU2V0dXAodHJ1c3RlZFNldHVwUGF0aCk7XG59XG5leHBvcnRzLmluaXRLWkcgPSBpbml0S1pHO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a3pnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHJscF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3JscFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IGJhc2VUcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vYmFzZVRyYW5zYWN0aW9uXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IFRSQU5TQUNUSU9OX1RZUEUgPSAwO1xuZnVuY3Rpb24gbWVldHNFSVAxNTUoX3YsIGNoYWluSWQpIHtcbiAgICBjb25zdCB2ID0gTnVtYmVyKF92KTtcbiAgICBjb25zdCBjaGFpbklkRG91YmxlZCA9IE51bWJlcihjaGFpbklkKSAqIDI7XG4gICAgcmV0dXJuIHYgPT09IGNoYWluSWREb3VibGVkICsgMzUgfHwgdiA9PT0gY2hhaW5JZERvdWJsZWQgKyAzNjtcbn1cbi8qKlxuICogQW4gRXRoZXJldW0gbm9uLXR5cGVkIChsZWdhY3kpIHRyYW5zYWN0aW9uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgYmFzZVRyYW5zYWN0aW9uXzEuQmFzZVRyYW5zYWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIHRha2VzIHRoZSB2YWx1ZXMsIHZhbGlkYXRlcyB0aGVtLCBhc3NpZ25zIHRoZW0gYW5kIGZyZWV6ZXMgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCB1c2VcbiAgICAgKiB0aGUgc3RhdGljIGZhY3RvcnkgbWV0aG9kcyB0byBhc3Npc3QgaW4gY3JlYXRpbmcgYSBUcmFuc2FjdGlvbiBvYmplY3QgZnJvbVxuICAgICAqIHZhcnlpbmcgZGF0YSB0eXBlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eERhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcih7IC4uLnR4RGF0YSwgdHlwZTogVFJBTlNBQ1RJT05fVFlQRSB9LCBvcHRzKTtcbiAgICAgICAgdGhpcy5jb21tb24gPSB0aGlzLl92YWxpZGF0ZVR4Vih0aGlzLnYsIG9wdHMuY29tbW9uKTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9ICgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKHR4RGF0YS5nYXNQcmljZSA9PT0gJycgPyAnMHgnIDogdHhEYXRhLmdhc1ByaWNlKSk7XG4gICAgICAgIGlmICh0aGlzLmdhc1ByaWNlICogdGhpcy5nYXNMaW1pdCA+IHV0aWxfMS5NQVhfSU5URUdFUikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ2dhcyBsaW1pdCAqIGdhc1ByaWNlIGNhbm5vdCBleGNlZWQgTUFYX0lOVEVHRVIgKDJeMjU2LTEpJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWxpZGF0ZUNhbm5vdEV4Y2VlZE1heEludGVnZXIoeyBnYXNQcmljZTogdGhpcy5nYXNQcmljZSB9KTtcbiAgICAgICAgYmFzZVRyYW5zYWN0aW9uXzEuQmFzZVRyYW5zYWN0aW9uLl92YWxpZGF0ZU5vdEFycmF5KHR4RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmNvbW1vbi5ndGVIYXJkZm9yaygnc3B1cmlvdXNEcmFnb24nKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNhcGFiaWxpdGllcy5wdXNoKHR5cGVzXzEuQ2FwYWJpbGl0eS5FSVAxNTVSZXBsYXlQcm90ZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVJUDE1NSBzcGVjOlxuICAgICAgICAgICAgICAgIC8vIElmIGJsb2NrLm51bWJlciA+PSAyLDY3NSwwMDAgYW5kIHYgPSBDSEFJTl9JRCAqIDIgKyAzNSBvciB2ID0gQ0hBSU5fSUQgKiAyICsgMzZcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdoZW4gY29tcHV0aW5nIHRoZSBoYXNoIG9mIGEgdHJhbnNhY3Rpb24gZm9yIHB1cnBvc2VzIG9mIHNpZ25pbmcgb3IgcmVjb3ZlcmluZ1xuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgaGFzaGluZyBvbmx5IHRoZSBmaXJzdCBzaXggZWxlbWVudHMgKGkuZS4gbm9uY2UsIGdhc3ByaWNlLCBzdGFydGdhcywgdG8sIHZhbHVlLCBkYXRhKVxuICAgICAgICAgICAgICAgIC8vIGhhc2ggbmluZSBlbGVtZW50cywgd2l0aCB2IHJlcGxhY2VkIGJ5IENIQUlOX0lELCByID0gMCBhbmQgcyA9IDAuXG4gICAgICAgICAgICAgICAgLy8gdiBhbmQgY2hhaW4gSUQgbWVldCBFSVAtMTU1IGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAobWVldHNFSVAxNTUodGhpcy52LCB0aGlzLmNvbW1vbi5jaGFpbklkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FwYWJpbGl0aWVzLnB1c2godHlwZXNfMS5DYXBhYmlsaXR5LkVJUDE1NVJlcGxheVByb3RlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21tb24uaXNBY3RpdmF0ZWRFSVAoMzg2MCkpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzIuY2hlY2tNYXhJbml0Q29kZVNpemUpKHRoaXMuY29tbW9uLCB0aGlzLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmVlemUgPSBvcHRzPy5mcmVlemUgPz8gdHJ1ZTtcbiAgICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIHRyYW5zYWN0aW9uIGZyb20gYSBkYXRhIGRpY3Rpb25hcnkuXG4gICAgICpcbiAgICAgKiBGb3JtYXQ6IHsgbm9uY2UsIGdhc1ByaWNlLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLCB2LCByLCBzIH1cbiAgICAgKlxuICAgICAqIE5vdGVzOlxuICAgICAqIC0gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsIGFuZCBoYXZlIHNvbWUgYmFzaWMgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVR4RGF0YSh0eERhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHR4RGF0YSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgdHJhbnNhY3Rpb24gZnJvbSB0aGUgc2VyaWFsaXplZCB0eC5cbiAgICAgKlxuICAgICAqIEZvcm1hdDogYHJscChbbm9uY2UsIGdhc1ByaWNlLCBnYXNMaW1pdCwgdG8sIHZhbHVlLCBkYXRhLCB2LCByLCBzXSlgXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZXJpYWxpemVkVHgoc2VyaWFsaXplZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9ICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKHJscF8xLlJMUC5kZWNvZGUoVWludDhBcnJheS5mcm9tKHNlcmlhbGl6ZWQpKSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VyaWFsaXplZCB0eCBpbnB1dC4gTXVzdCBiZSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21WYWx1ZXNBcnJheSh2YWx1ZXMsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBmcm9tIGEgdmFsdWVzIGFycmF5LlxuICAgICAqXG4gICAgICogRm9ybWF0OiBgW25vbmNlLCBnYXNQcmljZSwgZ2FzTGltaXQsIHRvLCB2YWx1ZSwgZGF0YSwgdiwgciwgc11gXG4gICAgICovXG4gICAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMsIG9wdHMgPSB7fSkge1xuICAgICAgICAvLyBJZiBsZW5ndGggaXMgbm90IDYsIGl0IGhhcyBsZW5ndGggOS4gSWYgdi9yL3MgYXJlIGVtcHR5IEJ1ZmZlcnMsIGl0IGlzIHN0aWxsIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIFRoaXMgaGFwcGVucyBpZiB5b3UgZ2V0IHRoZSBSTFAgZGF0YSBmcm9tIGByYXcoKWBcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IDYgJiYgdmFsdWVzLmxlbmd0aCAhPT0gOSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uLiBPbmx5IGV4cGVjdGluZyA2IHZhbHVlcyAoZm9yIHVuc2lnbmVkIHR4KSBvciA5IHZhbHVlcyAoZm9yIHNpZ25lZCB0eCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW25vbmNlLCBnYXNQcmljZSwgZ2FzTGltaXQsIHRvLCB2YWx1ZSwgZGF0YSwgdiwgciwgc10gPSB2YWx1ZXM7XG4gICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMpKHsgbm9uY2UsIGdhc1ByaWNlLCBnYXNMaW1pdCwgdmFsdWUsIHYsIHIsIHMgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgICAgIGdhc0xpbWl0LFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIHMsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQnVmZmVyIEFycmF5IG9mIHRoZSByYXcgQnVmZmVycyBvZiB0aGUgbGVnYWN5IHRyYW5zYWN0aW9uLCBpbiBvcmRlci5cbiAgICAgKlxuICAgICAqIEZvcm1hdDogYFtub25jZSwgZ2FzUHJpY2UsIGdhc0xpbWl0LCB0bywgdmFsdWUsIGRhdGEsIHYsIHIsIHNdYFxuICAgICAqXG4gICAgICogRm9yIGxlZ2FjeSB0eHMgdGhpcyBpcyBhbHNvIHRoZSBjb3JyZWN0IGZvcm1hdCB0byBhZGQgdHJhbnNhY3Rpb25zXG4gICAgICogdG8gYSBibG9jayB3aXRoIHtAbGluayBCbG9jay5mcm9tVmFsdWVzQXJyYXl9ICh1c2UgdGhlIGBzZXJpYWxpemUoKWAgbWV0aG9kXG4gICAgICogZm9yIHR5cGVkIHR4cykuXG4gICAgICpcbiAgICAgKiBGb3IgYW4gdW5zaWduZWQgdHggdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZW1wdHkgQnVmZmVyIHZhbHVlc1xuICAgICAqIGZvciB0aGUgc2lnbmF0dXJlIHBhcmFtZXRlcnMgYHZgLCBgcmAgYW5kIGBzYC4gRm9yIGFuIEVJUC0xNTUgY29tcGxpYW50XG4gICAgICogcmVwcmVzZW50YXRpb24gaGF2ZSBhIGxvb2sgYXQge0BsaW5rIFRyYW5zYWN0aW9uLmdldE1lc3NhZ2VUb1NpZ259LlxuICAgICAqL1xuICAgIHJhdygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5ub25jZSksXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIHRoaXMudG8gIT09IHVuZGVmaW5lZCA/IHRoaXMudG8uYnVmIDogQnVmZmVyLmZyb20oW10pLFxuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHRoaXMudiAhPT0gdW5kZWZpbmVkID8gKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLnYpIDogQnVmZmVyLmZyb20oW10pLFxuICAgICAgICAgICAgdGhpcy5yICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMucikgOiBCdWZmZXIuZnJvbShbXSksXG4gICAgICAgICAgICB0aGlzLnMgIT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5zKSA6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2VyaWFsaXplZCBlbmNvZGluZyBvZiB0aGUgbGVnYWN5IHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogRm9ybWF0OiBgcmxwKFtub25jZSwgZ2FzUHJpY2UsIGdhc0xpbWl0LCB0bywgdmFsdWUsIGRhdGEsIHYsIHIsIHNdKWBcbiAgICAgKlxuICAgICAqIEZvciBhbiB1bnNpZ25lZCB0eCB0aGlzIG1ldGhvZCB1c2VzIHRoZSBlbXB0eSBCdWZmZXIgdmFsdWVzIGZvciB0aGVcbiAgICAgKiBzaWduYXR1cmUgcGFyYW1ldGVycyBgdmAsIGByYCBhbmQgYHNgIGZvciBlbmNvZGluZy4gRm9yIGFuIEVJUC0xNTUgY29tcGxpYW50XG4gICAgICogcmVwcmVzZW50YXRpb24gZm9yIGV4dGVybmFsIHNpZ25pbmcgdXNlIHtAbGluayBUcmFuc2FjdGlvbi5nZXRNZXNzYWdlVG9TaWdufS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShybHBfMS5STFAuZW5jb2RlKCgwLCB1dGlsXzEuYnVmQXJyVG9BcnIpKHRoaXMucmF3KCkpKSk7XG4gICAgfVxuICAgIF9nZXRNZXNzYWdlVG9TaWduKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMubm9uY2UpLFxuICAgICAgICAgICAgKDAsIHV0aWxfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICB0aGlzLnRvICE9PSB1bmRlZmluZWQgPyB0aGlzLnRvLmJ1ZiA6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy52YWx1ZSksXG4gICAgICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgIF07XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzKHR5cGVzXzEuQ2FwYWJpbGl0eS5FSVAxNTVSZXBsYXlQcm90ZWN0aW9uKSkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goKDAsIHV0aWxfMS50b0J1ZmZlcikodGhpcy5jb21tb24uY2hhaW5JZCgpKSk7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCgoMCwgdXRpbF8xLnVucGFkQnVmZmVyKSgoMCwgdXRpbF8xLnRvQnVmZmVyKSgwKSkpO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goKDAsIHV0aWxfMS51bnBhZEJ1ZmZlcikoKDAsIHV0aWxfMS50b0J1ZmZlcikoMCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBnZXRNZXNzYWdlVG9TaWduKGhhc2hNZXNzYWdlID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fZ2V0TWVzc2FnZVRvU2lnbigpO1xuICAgICAgICBpZiAoaGFzaE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShybHBfMS5STFAuZW5jb2RlKCgwLCB1dGlsXzEuYnVmQXJyVG9BcnIpKG1lc3NhZ2UpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBnYXMgcGFpZCBmb3IgdGhlIGRhdGEgaW4gdGhpcyB0eFxuICAgICAqL1xuICAgIGdldERhdGFGZWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmRhdGFGZWUgJiYgdGhpcy5jYWNoZS5kYXRhRmVlLmhhcmRmb3JrID09PSB0aGlzLmNvbW1vbi5oYXJkZm9yaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5kYXRhRmVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4odGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGF0YUZlZSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3VwZXIuZ2V0RGF0YUZlZSgpLFxuICAgICAgICAgICAgICAgIGhhcmRmb3JrOiB0aGlzLmNvbW1vbi5oYXJkZm9yaygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0RGF0YUZlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdXAgZnJvbnQgYW1vdW50IHRoYXQgYW4gYWNjb3VudCBtdXN0IGhhdmUgZm9yIHRoaXMgdHJhbnNhY3Rpb24gdG8gYmUgdmFsaWRcbiAgICAgKi9cbiAgICBnZXRVcGZyb250Q29zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzTGltaXQgKiB0aGlzLmdhc1ByaWNlICsgdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSBzaGEzLTI1NiBoYXNoIG9mIHRoZSBzZXJpYWxpemVkIHR4LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBmb3Igc2lnbmVkIHR4cyAoaXQgdGhyb3dzIG90aGVyd2lzZSkuXG4gICAgICogVXNlIHtAbGluayBUcmFuc2FjdGlvbi5nZXRNZXNzYWdlVG9TaWdufSB0byBnZXQgYSB0eCBoYXNoIGZvciB0aGUgcHVycG9zZSBvZiBzaWduaW5nLlxuICAgICAqL1xuICAgIGhhc2goKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NpZ25lZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9lcnJvck1zZygnQ2Fubm90IGNhbGwgaGFzaCBtZXRob2QgaWYgdHJhbnNhY3Rpb24gaXMgbm90IHNpZ25lZCcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbih0aGlzKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmhhc2ggPSBCdWZmZXIuZnJvbSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShybHBfMS5STFAuZW5jb2RlKCgwLCB1dGlsXzEuYnVmQXJyVG9BcnIpKHRoaXMucmF3KCkpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikocmxwXzEuUkxQLmVuY29kZSgoMCwgdXRpbF8xLmJ1ZkFyclRvQXJyKSh0aGlzLnJhdygpKSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSBzaGEzLTI1NiBoYXNoIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZVRvVmVyaWZ5U2lnbmF0dXJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5fZXJyb3JNc2coJ1RoaXMgdHJhbnNhY3Rpb24gaXMgbm90IHNpZ25lZCcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2dldE1lc3NhZ2VUb1NpZ24oKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHJscF8xLlJMUC5lbmNvZGUoKDAsIHV0aWxfMS5idWZBcnJUb0FycikobWVzc2FnZSkpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlclxuICAgICAqL1xuICAgIGdldFNlbmRlclB1YmxpY0tleSgpIHtcbiAgICAgICAgY29uc3QgbXNnSGFzaCA9IHRoaXMuZ2V0TWVzc2FnZVRvVmVyaWZ5U2lnbmF0dXJlKCk7XG4gICAgICAgIGNvbnN0IHsgdiwgciwgcyB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVIaWdoUygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuZWNyZWNvdmVyKShtc2dIYXNoLCB2LCAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHIpLCAoMCwgdXRpbF8xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHMpLCB0aGlzLnN1cHBvcnRzKHR5cGVzXzEuQ2FwYWJpbGl0eS5FSVAxNTVSZXBsYXlQcm90ZWN0aW9uKSA/IHRoaXMuY29tbW9uLmNoYWluSWQoKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuX2Vycm9yTXNnKCdJbnZhbGlkIFNpZ25hdHVyZScpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgdiwgciwgcyB2YWx1ZXMgZnJvbSB0aGUgYHNpZ25gIG1ldGhvZCBvZiB0aGUgYmFzZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBfcHJvY2Vzc1NpZ25hdHVyZSh2LCByLCBzKSB7XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzKHR5cGVzXzEuQ2FwYWJpbGl0eS5FSVAxNTVSZXBsYXlQcm90ZWN0aW9uKSkge1xuICAgICAgICAgICAgdiArPSB0aGlzLmNvbW1vbi5jaGFpbklkKCkgKiBCaWdJbnQoMikgKyBCaWdJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IHsgLi4udGhpcy50eE9wdGlvbnMsIGNvbW1vbjogdGhpcy5jb21tb24gfTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb21UeERhdGEoe1xuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nYXNQcmljZSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0aGlzLmdhc0xpbWl0LFxuICAgICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICByOiAoMCwgdXRpbF8xLmJ1ZmZlclRvQmlnSW50KShyKSxcbiAgICAgICAgICAgIHM6ICgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKHMpLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9uY2U6ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMubm9uY2UpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6ICgwLCB1dGlsXzEuYmlnSW50VG9IZXgpKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgdG86IHRoaXMudG8gIT09IHVuZGVmaW5lZCA/IHRoaXMudG8udG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbHVlOiAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGRhdGE6ICcweCcgKyB0aGlzLmRhdGEudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgdjogdGhpcy52ICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnYpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcjogdGhpcy5yICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgczogdGhpcy5zICE9PSB1bmRlZmluZWQgPyAoMCwgdXRpbF8xLmJpZ0ludFRvSGV4KSh0aGlzLnMpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdHgncyBgdmAgdmFsdWVcbiAgICAgKi9cbiAgICBfdmFsaWRhdGVUeFYoX3YsIGNvbW1vbikge1xuICAgICAgICBsZXQgY2hhaW5JZEJpZ0ludDtcbiAgICAgICAgY29uc3QgdiA9IF92ICE9PSB1bmRlZmluZWQgPyBOdW1iZXIoX3YpIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBDaGVjayBmb3IgdmFsaWQgdiB2YWx1ZXMgaW4gdGhlIHNjb3BlIG9mIGEgc2lnbmVkIGxlZ2FjeSB0eFxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB2IGlzIDEuIG5vdCBtYXRjaGluZyB0aGUgRUlQLTE1NSBjaGFpbklkIGluY2x1ZGVkIGNhc2UgYW5kLi4uXG4gICAgICAgICAgICAvLyB2IGlzIDIuIG5vdCBtYXRjaGluZyB0aGUgY2xhc3NpYyB2PTI3IG9yIHY9MjggY2FzZVxuICAgICAgICAgICAgaWYgKHYgPCAzNyAmJiB2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGVnYWN5IHR4cyBuZWVkIGVpdGhlciB2ID0gMjcvMjggb3IgdiA+PSAzNyAoRUlQLTE1NSByZXBsYXkgcHJvdGVjdGlvbiksIGdvdCB2ID0gJHt2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHVuc2lnbmVkIHR4IGFuZCBFSVAtMTU1IGFjdGl2YXRlZCBhbmQgY2hhaW4gSUQgaW5jbHVkZWRcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdiAhPT0gMCAmJlxuICAgICAgICAgICAgKCFjb21tb24gfHwgY29tbW9uLmd0ZUhhcmRmb3JrKCdzcHVyaW91c0RyYWdvbicpKSAmJlxuICAgICAgICAgICAgdiAhPT0gMjcgJiZcbiAgICAgICAgICAgIHYgIT09IDI4KSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZWV0c0VJUDE1NShCaWdJbnQodiksIGNvbW1vbi5jaGFpbklkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIEVJUDE1NS1iYXNlZCBWICR7dn0gYW5kIGNoYWluIGlkICR7Y29tbW9uLmNoYWluSWQoKX0uIFNlZSB0aGUgQ29tbW9uIHBhcmFtZXRlciBvZiB0aGUgVHJhbnNhY3Rpb24gY29uc3RydWN0b3IgdG8gc2V0IHRoZSBjaGFpbiBpZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZXJpdmUgdGhlIG9yaWdpbmFsIGNoYWluIElEXG4gICAgICAgICAgICAgICAgbGV0IG51bVN1YjtcbiAgICAgICAgICAgICAgICBpZiAoKHYgLSAzNSkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVN1YiA9IDM1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtU3ViID0gMzY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVzZSBkZXJpdmVkIGNoYWluIElEIHRvIGNyZWF0ZSBhIHByb3BlciBDb21tb25cbiAgICAgICAgICAgICAgICBjaGFpbklkQmlnSW50ID0gQmlnSW50KHYgLSBudW1TdWIpIC8gQmlnSW50KDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb21tb24oY29tbW9uLCBjaGFpbklkQmlnSW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29tcGFjdCBlcnJvciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGVycm9yU3RyKCkge1xuICAgICAgICBsZXQgZXJyb3JTdHIgPSB0aGlzLl9nZXRTaGFyZWRFcnJvclBvc3RmaXgoKTtcbiAgICAgICAgZXJyb3JTdHIgKz0gYCBnYXNQcmljZT0ke3RoaXMuZ2FzUHJpY2V9YDtcbiAgICAgICAgcmV0dXJuIGVycm9yU3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGFubm90YXRlZCBlcnJvciBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXNnIEJhc2UgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfZXJyb3JNc2cobXNnKSB7XG4gICAgICAgIHJldHVybiBgJHttc2d9ICgke3RoaXMuZXJyb3JTdHIoKX0pYDtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWdhY3lUcmFuc2FjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25GYWN0b3J5ID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcnNcIik7XG5jb25zdCBlaXAxNTU5VHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2VpcDE1NTlUcmFuc2FjdGlvblwiKTtcbmNvbnN0IGVpcDI5MzBUcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vZWlwMjkzMFRyYW5zYWN0aW9uXCIpO1xuY29uc3QgZWlwNDg0NFRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9laXA0ODQ0VHJhbnNhY3Rpb25cIik7XG5jb25zdCBmcm9tUnBjXzEgPSByZXF1aXJlKFwiLi9mcm9tUnBjXCIpO1xuY29uc3QgbGVnYWN5VHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2xlZ2FjeVRyYW5zYWN0aW9uXCIpO1xuY2xhc3MgVHJhbnNhY3Rpb25GYWN0b3J5IHtcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gaW5zdGFudGlhdGUgYSBUcmFuc2FjdGlvbkZhY3Rvcnkgb2JqZWN0LlxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdHJhbnNhY3Rpb24gZnJvbSBhIGB0eERhdGFgIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHR4RGF0YSAtIFRoZSB0cmFuc2FjdGlvbiBkYXRhLiBUaGUgYHR5cGVgIGZpZWxkIHdpbGwgZGV0ZXJtaW5lIHdoaWNoIHRyYW5zYWN0aW9uIHR5cGUgaXMgcmV0dXJuZWQgKGlmIHVuZGVmaW5lZCwgY3JlYXRlcyBhIGxlZ2FjeSB0cmFuc2FjdGlvbilcbiAgICAgKiBAcGFyYW0gdHhPcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIG9uIHRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVR4RGF0YSh0eERhdGEsIHR4T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghKCd0eXBlJyBpbiB0eERhdGEpIHx8IHR4RGF0YS50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBsZWdhY3kgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIHJldHVybiBsZWdhY3lUcmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLmZyb21UeERhdGEodHhEYXRhLCB0eE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHhUeXBlID0gTnVtYmVyKCgwLCB1dGlsXzEuYnVmZmVyVG9CaWdJbnQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKHR4RGF0YS50eXBlKSkpO1xuICAgICAgICAgICAgaWYgKHR4VHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWdhY3lUcmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLmZyb21UeERhdGEodHhEYXRhLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHhUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVpcDI5MzBUcmFuc2FjdGlvbl8xLkFjY2Vzc0xpc3RFSVAyOTMwVHJhbnNhY3Rpb24uZnJvbVR4RGF0YSh0eERhdGEsIHR4T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eFR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWlwMTU1OVRyYW5zYWN0aW9uXzEuRmVlTWFya2V0RUlQMTU1OVRyYW5zYWN0aW9uLmZyb21UeERhdGEodHhEYXRhLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHhUeXBlID09PSA1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVpcDQ4NDRUcmFuc2FjdGlvbl8xLkJsb2JFSVA0ODQ0VHJhbnNhY3Rpb24uZnJvbVR4RGF0YSh0eERhdGEsIHR4T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR4IGluc3RhbnRpYXRpb24gd2l0aCB0eXBlICR7dHhUeXBlfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdHJpZXMgdG8gZGVjb2RlIHNlcmlhbGl6ZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgQnVmZmVyXG4gICAgICogQHBhcmFtIHR4T3B0aW9ucyAtIFRoZSB0cmFuc2FjdGlvbiBvcHRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZXJpYWxpemVkRGF0YShkYXRhLCB0eE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHR5cGUuXG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGFbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlaXAyOTMwVHJhbnNhY3Rpb25fMS5BY2Nlc3NMaXN0RUlQMjkzMFRyYW5zYWN0aW9uLmZyb21TZXJpYWxpemVkVHgoZGF0YSwgdHhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlaXAxNTU5VHJhbnNhY3Rpb25fMS5GZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24uZnJvbVNlcmlhbGl6ZWRUeChkYXRhLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVpcDQ4NDRUcmFuc2FjdGlvbl8xLkJsb2JFSVA0ODQ0VHJhbnNhY3Rpb24uZnJvbVNlcmlhbGl6ZWRUeChkYXRhLCB0eE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZWRUcmFuc2FjdGlvbiB3aXRoIElEICR7ZGF0YVswXX0gdW5rbm93bmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlZ2FjeVRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVNlcmlhbGl6ZWRUeChkYXRhLCB0eE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVjb2RpbmcgYSBCbG9ja0JvZHksIGluIHRoZSB0cmFuc2FjdGlvbnMgZmllbGQsIGEgZmllbGQgaXMgZWl0aGVyOlxuICAgICAqIEEgQnVmZmVyIChhIFR5cGVkVHJhbnNhY3Rpb24gLSBlbmNvZGVkIGFzIFRyYW5zYWN0aW9uVHlwZSB8fCBybHAoVHJhbnNhY3Rpb25QYXlsb2FkKSlcbiAgICAgKiBBIEJ1ZmZlcltdIChMZWdhY3kgVHJhbnNhY3Rpb24pXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgcmlnaHQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEEgQnVmZmVyIG9yIEJ1ZmZlcltdXG4gICAgICogQHBhcmFtIHR4T3B0aW9ucyAtIFRoZSB0cmFuc2FjdGlvbiBvcHRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CbG9ja0JvZHlEYXRhKGRhdGEsIHR4T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TZXJpYWxpemVkRGF0YShkYXRhLCB0eE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIGEgbGVnYWN5IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICByZXR1cm4gbGVnYWN5VHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVmFsdWVzQXJyYXkoZGF0YSwgdHhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSB0cmFuc2FjdGlvbjogdW5rbm93biB0eXBlIGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIE1ldGhvZCB0byByZXRyaWV2ZSBhIHRyYW5zYWN0aW9uIGZyb20gdGhlIHByb3ZpZGVyXG4gICAgICogQHBhcmFtIHByb3ZpZGVyIC0gQW4gRXRoZXJzIEpzb25SUENQcm92aWRlclxuICAgICAqIEBwYXJhbSB0eEhhc2ggLSBUcmFuc2FjdGlvbiBoYXNoXG4gICAgICogQHBhcmFtIHR4T3B0aW9ucyAtIFRoZSB0cmFuc2FjdGlvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHNwZWNpZmllZCBieSBgdHhIYXNoYFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tRXRoZXJzUHJvdmlkZXIocHJvdmlkZXIsIHR4SGFzaCwgdHhPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb3YgPSB0eXBlb2YgcHJvdmlkZXIgPT09ICdzdHJpbmcnID8gbmV3IHByb3ZpZGVyc18xLkpzb25ScGNQcm92aWRlcihwcm92aWRlcikgOiBwcm92aWRlcjtcbiAgICAgICAgY29uc3QgdHhEYXRhID0gYXdhaXQgcHJvdi5zZW5kKCdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLCBbdHhIYXNoXSk7XG4gICAgICAgIGNvbnN0IG5vcm1lZFR4ID0gKDAsIGZyb21ScGNfMS5ub3JtYWxpemVUeFBhcmFtcykodHhEYXRhKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKG5vcm1lZFR4LCB0eE9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNhY3Rpb25GYWN0b3J5ID0gVHJhbnNhY3Rpb25GYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb25GYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CbG9iTmV0d29ya1RyYW5zYWN0aW9uV3JhcHBlciA9IGV4cG9ydHMuS1pHUHJvb2ZUeXBlID0gZXhwb3J0cy5LWkdDb21taXRtZW50VHlwZSA9IGV4cG9ydHMuU2lnbmVkQmxvYlRyYW5zYWN0aW9uVHlwZSA9IGV4cG9ydHMuRUNEU0FTaWduYXR1cmVUeXBlID0gZXhwb3J0cy5CbG9iVHJhbnNhY3Rpb25UeXBlID0gZXhwb3J0cy5BY2Nlc3NUdXBsZVR5cGUgPSBleHBvcnRzLkFkZHJlc3NUeXBlID0gZXhwb3J0cy5pc0FjY2Vzc0xpc3QgPSBleHBvcnRzLmlzQWNjZXNzTGlzdEJ1ZmZlciA9IGV4cG9ydHMuQ2FwYWJpbGl0eSA9IHZvaWQgMDtcbmNvbnN0IHNzel8xID0gcmVxdWlyZShcIkBjaGFpbnNhZmUvc3N6XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBCeXRlczIwID0gbmV3IHNzel8xLkJ5dGVWZWN0b3JUeXBlKDIwKTtcbmNvbnN0IEJ5dGVzMzIgPSBuZXcgc3N6XzEuQnl0ZVZlY3RvclR5cGUoMzIpO1xuY29uc3QgQnl0ZXM0OCA9IG5ldyBzc3pfMS5CeXRlVmVjdG9yVHlwZSg0OCk7XG5jb25zdCBVaW50NjQgPSBuZXcgc3N6XzEuVWludEJpZ2ludFR5cGUoOCk7XG5jb25zdCBVaW50MjU2ID0gbmV3IHNzel8xLlVpbnRCaWdpbnRUeXBlKDMyKTtcbi8qKlxuICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgVHJhbnNhY3Rpb24uc3VwcG9ydHN9XG4gKiB0byBxdWVyeSBvbiB0eCBjYXBhYmlsaXRpZXNcbiAqL1xudmFyIENhcGFiaWxpdHk7XG4oZnVuY3Rpb24gKENhcGFiaWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUeCBzdXBwb3J0cyBFSVAtMTU1IHJlcGxheSBwcm90ZWN0aW9uXG4gICAgICogU2VlOiBbMTU1XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NSkgUmVwbGF5IEF0dGFjayBQcm90ZWN0aW9uIEVJUFxuICAgICAqL1xuICAgIENhcGFiaWxpdHlbQ2FwYWJpbGl0eVtcIkVJUDE1NVJlcGxheVByb3RlY3Rpb25cIl0gPSAxNTVdID0gXCJFSVAxNTVSZXBsYXlQcm90ZWN0aW9uXCI7XG4gICAgLyoqXG4gICAgICogVHggc3VwcG9ydHMgRUlQLTE1NTkgZ2FzIGZlZSBtYXJrZXQgbWVjaGFuaXNtXG4gICAgICogU2VlOiBbMTU1OV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNTU5KSBGZWUgTWFya2V0IEVJUFxuICAgICAqL1xuICAgIENhcGFiaWxpdHlbQ2FwYWJpbGl0eVtcIkVJUDE1NTlGZWVNYXJrZXRcIl0gPSAxNTU5XSA9IFwiRUlQMTU1OUZlZU1hcmtldFwiO1xuICAgIC8qKlxuICAgICAqIFR4IGlzIGEgdHlwZWQgdHJhbnNhY3Rpb24gYXMgZGVmaW5lZCBpbiBFSVAtMjcxOFxuICAgICAqIFNlZTogWzI3MThdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjcxOCkgVHJhbnNhY3Rpb24gVHlwZSBFSVBcbiAgICAgKi9cbiAgICBDYXBhYmlsaXR5W0NhcGFiaWxpdHlbXCJFSVAyNzE4VHlwZWRUcmFuc2FjdGlvblwiXSA9IDI3MThdID0gXCJFSVAyNzE4VHlwZWRUcmFuc2FjdGlvblwiO1xuICAgIC8qKlxuICAgICAqIFR4IHN1cHBvcnRzIGFjY2VzcyBsaXN0IGdlbmVyYXRpb24gYXMgZGVmaW5lZCBpbiBFSVAtMjkzMFxuICAgICAqIFNlZTogWzI5MzBdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjkzMCkgQWNjZXNzIExpc3RzIEVJUFxuICAgICAqL1xuICAgIENhcGFiaWxpdHlbQ2FwYWJpbGl0eVtcIkVJUDI5MzBBY2Nlc3NMaXN0c1wiXSA9IDI5MzBdID0gXCJFSVAyOTMwQWNjZXNzTGlzdHNcIjtcbn0pKENhcGFiaWxpdHkgPSBleHBvcnRzLkNhcGFiaWxpdHkgfHwgKGV4cG9ydHMuQ2FwYWJpbGl0eSA9IHt9KSk7XG5mdW5jdGlvbiBpc0FjY2Vzc0xpc3RCdWZmZXIoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEl0ZW0gPSBpbnB1dFswXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdEl0ZW0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzQWNjZXNzTGlzdEJ1ZmZlciA9IGlzQWNjZXNzTGlzdEJ1ZmZlcjtcbmZ1bmN0aW9uIGlzQWNjZXNzTGlzdChpbnB1dCkge1xuICAgIHJldHVybiAhaXNBY2Nlc3NMaXN0QnVmZmVyKGlucHV0KTsgLy8gVGhpcyBpcyBleGFjdGx5IHRoZSBzYW1lIG1ldGhvZCwgZXhjZXB0IHRoZSBvdXRwdXQgaXMgbmVnYXRlZC5cbn1cbmV4cG9ydHMuaXNBY2Nlc3NMaXN0ID0gaXNBY2Nlc3NMaXN0O1xuLyoqIEVJUDQ4NDQgdHlwZXMgKi9cbmV4cG9ydHMuQWRkcmVzc1R5cGUgPSBCeXRlczIwOyAvLyBTU1ogZW5jb2RlZCBhZGRyZXNzXG4vLyBTU1ogZW5jb2RlZCBjb250YWluZXIgZm9yIGFkZHJlc3MgYW5kIHN0b3JhZ2Uga2V5c1xuZXhwb3J0cy5BY2Nlc3NUdXBsZVR5cGUgPSBuZXcgc3N6XzEuQ29udGFpbmVyVHlwZSh7XG4gICAgYWRkcmVzczogZXhwb3J0cy5BZGRyZXNzVHlwZSxcbiAgICBzdG9yYWdlS2V5czogbmV3IHNzel8xLkxpc3RDb21wb3NpdGVUeXBlKEJ5dGVzMzIsIGNvbnN0YW50c18xLk1BWF9WRVJTSU9ORURfSEFTSEVTX0xJU1RfU0laRSksXG59KTtcbi8vIFNTWiBlbmNvZGVkIGJsb2IgdHJhbnNhY3Rpb25cbmV4cG9ydHMuQmxvYlRyYW5zYWN0aW9uVHlwZSA9IG5ldyBzc3pfMS5Db250YWluZXJUeXBlKHtcbiAgICBjaGFpbklkOiBVaW50MjU2LFxuICAgIG5vbmNlOiBVaW50NjQsXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFVpbnQyNTYsXG4gICAgbWF4RmVlUGVyR2FzOiBVaW50MjU2LFxuICAgIGdhczogVWludDY0LFxuICAgIHRvOiBuZXcgc3N6XzEuVW5pb25UeXBlKFtuZXcgc3N6XzEuTm9uZVR5cGUoKSwgZXhwb3J0cy5BZGRyZXNzVHlwZV0pLFxuICAgIHZhbHVlOiBVaW50MjU2LFxuICAgIGRhdGE6IG5ldyBzc3pfMS5CeXRlTGlzdFR5cGUoY29uc3RhbnRzXzEuTUFYX0NBTExEQVRBX1NJWkUpLFxuICAgIGFjY2Vzc0xpc3Q6IG5ldyBzc3pfMS5MaXN0Q29tcG9zaXRlVHlwZShleHBvcnRzLkFjY2Vzc1R1cGxlVHlwZSwgY29uc3RhbnRzXzEuTUFYX0FDQ0VTU19MSVNUX1NJWkUpLFxuICAgIG1heEZlZVBlckRhdGFHYXM6IFVpbnQyNTYsXG4gICAgYmxvYlZlcnNpb25lZEhhc2hlczogbmV3IHNzel8xLkxpc3RDb21wb3NpdGVUeXBlKEJ5dGVzMzIsIGNvbnN0YW50c18xLk1BWF9WRVJTSU9ORURfSEFTSEVTX0xJU1RfU0laRSksXG59KTtcbi8vIFNTWiBlbmNvZGVkIEVDRFNBIFNpZ25hdHVyZVxuZXhwb3J0cy5FQ0RTQVNpZ25hdHVyZVR5cGUgPSBuZXcgc3N6XzEuQ29udGFpbmVyVHlwZSh7XG4gICAgeVBhcml0eTogbmV3IHNzel8xLkJvb2xlYW5UeXBlKCksXG4gICAgcjogVWludDI1NixcbiAgICBzOiBVaW50MjU2LFxufSk7XG4vLyBTU1ogZW5jb2RlZCBzaWduZWQgYmxvYiB0cmFuc2FjdGlvblxuZXhwb3J0cy5TaWduZWRCbG9iVHJhbnNhY3Rpb25UeXBlID0gbmV3IHNzel8xLkNvbnRhaW5lclR5cGUoe1xuICAgIG1lc3NhZ2U6IGV4cG9ydHMuQmxvYlRyYW5zYWN0aW9uVHlwZSxcbiAgICBzaWduYXR1cmU6IGV4cG9ydHMuRUNEU0FTaWduYXR1cmVUeXBlLFxufSk7XG4vLyBTU1ogZW5jb2RlZCBLWkcgQ29tbWl0bWVudC9Qcm9vZiAoNDggYnl0ZXMpXG5leHBvcnRzLktaR0NvbW1pdG1lbnRUeXBlID0gQnl0ZXM0ODtcbmV4cG9ydHMuS1pHUHJvb2ZUeXBlID0gZXhwb3J0cy5LWkdDb21taXRtZW50VHlwZTtcbi8vIFNTWiBlbmNvZGVkIGJsb2IgbmV0d29yayB0cmFuc2FjdGlvbiB3cmFwcGVyXG5leHBvcnRzLkJsb2JOZXR3b3JrVHJhbnNhY3Rpb25XcmFwcGVyID0gbmV3IHNzel8xLkNvbnRhaW5lclR5cGUoe1xuICAgIHR4OiBleHBvcnRzLlNpZ25lZEJsb2JUcmFuc2FjdGlvblR5cGUsXG4gICAgYmxvYkt6Z3M6IG5ldyBzc3pfMS5MaXN0Q29tcG9zaXRlVHlwZShleHBvcnRzLktaR0NvbW1pdG1lbnRUeXBlLCBjb25zdGFudHNfMS5NQVhfVFhfV1JBUF9LWkdfQ09NTUlUTUVOVFMpLFxuICAgIGJsb2JzOiBuZXcgc3N6XzEuTGlzdENvbXBvc2l0ZVR5cGUobmV3IHNzel8xLkJ5dGVWZWN0b3JUeXBlKGNvbnN0YW50c18xLkZJRUxEX0VMRU1FTlRTX1BFUl9CTE9CICogY29uc3RhbnRzXzEuQllURVNfUEVSX0ZJRUxEX0VMRU1FTlQpLCBjb25zdGFudHNfMS5MSU1JVF9CTE9CU19QRVJfVFgpLFxuICAgIGt6Z0FnZ3JlZ2F0ZWRQcm9vZjogZXhwb3J0cy5LWkdQcm9vZlR5cGUsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ibG9iVHhUb05ldHdvcmtXcmFwcGVyRGF0YUZvcm1hdCA9IGV4cG9ydHMuQWNjZXNzTGlzdHMgPSBleHBvcnRzLmNoZWNrTWF4SW5pdENvZGVTaXplID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5mdW5jdGlvbiBjaGVja01heEluaXRDb2RlU2l6ZShjb21tb24sIGxlbmd0aCkge1xuICAgIGNvbnN0IG1heEluaXRDb2RlU2l6ZSA9IGNvbW1vbi5wYXJhbSgndm0nLCAnbWF4SW5pdENvZGVTaXplJyk7XG4gICAgaWYgKG1heEluaXRDb2RlU2l6ZSAmJiBCaWdJbnQobGVuZ3RoKSA+IG1heEluaXRDb2RlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoZSBpbml0Y29kZSBzaXplIG9mIHRoaXMgdHJhbnNhY3Rpb24gaXMgdG9vIGxhcmdlOiBpdCBpcyAke2xlbmd0aH0gd2hpbGUgdGhlIG1heCBpcyAke2NvbW1vbi5wYXJhbSgndm0nLCAnbWF4SW5pdENvZGVTaXplJyl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja01heEluaXRDb2RlU2l6ZSA9IGNoZWNrTWF4SW5pdENvZGVTaXplO1xuY2xhc3MgQWNjZXNzTGlzdHMge1xuICAgIHN0YXRpYyBnZXRBY2Nlc3NMaXN0RGF0YShhY2Nlc3NMaXN0KSB7XG4gICAgICAgIGxldCBBY2Nlc3NMaXN0SlNPTjtcbiAgICAgICAgbGV0IGJ1ZmZlckFjY2Vzc0xpc3Q7XG4gICAgICAgIGlmICgoMCwgdHlwZXNfMS5pc0FjY2Vzc0xpc3QpKGFjY2Vzc0xpc3QpKSB7XG4gICAgICAgICAgICBBY2Nlc3NMaXN0SlNPTiA9IGFjY2Vzc0xpc3Q7XG4gICAgICAgICAgICBjb25zdCBuZXdBY2Nlc3NMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY2Vzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWNjZXNzTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzQnVmZmVyID0gKDAsIHV0aWxfMS50b0J1ZmZlcikoaXRlbS5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yYWdlSXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaXRlbS5zdG9yYWdlS2V5cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZUl0ZW1zLnB1c2goKDAsIHV0aWxfMS50b0J1ZmZlcikoaXRlbS5zdG9yYWdlS2V5c1tpbmRleF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3QWNjZXNzTGlzdC5wdXNoKFthZGRyZXNzQnVmZmVyLCBzdG9yYWdlSXRlbXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlckFjY2Vzc0xpc3QgPSBuZXdBY2Nlc3NMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyQWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3QgPz8gW107XG4gICAgICAgICAgICAvLyBidWlsZCB0aGUgSlNPTlxuICAgICAgICAgICAgY29uc3QganNvbiA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJBY2Nlc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlckFjY2Vzc0xpc3RbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9ICgwLCB1dGlsXzEuYnVmZmVyVG9IZXgpKGRhdGFbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSA9IDA7IGl0ZW0gPCBkYXRhWzFdLmxlbmd0aDsgaXRlbSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VLZXlzLnB1c2goKDAsIHV0aWxfMS5idWZmZXJUb0hleCkoZGF0YVsxXVtpdGVtXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBqc29uSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZUtleXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBqc29uLnB1c2goanNvbkl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQWNjZXNzTGlzdEpTT04gPSBqc29uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBBY2Nlc3NMaXN0SlNPTixcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IGJ1ZmZlckFjY2Vzc0xpc3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyB2ZXJpZnlBY2Nlc3NMaXN0KGFjY2Vzc0xpc3QpIHtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgYWNjZXNzTGlzdC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0SXRlbSA9IGFjY2Vzc0xpc3Rba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhY2Nlc3NMaXN0SXRlbVswXTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VTbG90cyA9IGFjY2Vzc0xpc3RJdGVtWzFdO1xuICAgICAgICAgICAgaWYgKGFjY2Vzc0xpc3RJdGVtWzJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY2VzcyBsaXN0IGl0ZW0gY2Fubm90IGhhdmUgMyBlbGVtZW50cy4gSXQgY2FuIG9ubHkgaGF2ZSBhbiBhZGRyZXNzLCBhbmQgYW4gYXJyYXkgb2Ygc3RvcmFnZSBzbG90cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRyZXNzLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRUlQLTI5MzAgdHJhbnNhY3Rpb246IGFkZHJlc3MgbGVuZ3RoIHNob3VsZCBiZSAyMCBieXRlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgc3RvcmFnZVNsb3QgPSAwOyBzdG9yYWdlU2xvdCA8IHN0b3JhZ2VTbG90cy5sZW5ndGg7IHN0b3JhZ2VTbG90KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVNsb3RzW3N0b3JhZ2VTbG90XS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFSVAtMjkzMCB0cmFuc2FjdGlvbjogc3RvcmFnZSBzbG90IGxlbmd0aCBzaG91bGQgYmUgMzIgYnl0ZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldEFjY2Vzc0xpc3RKU09OKGFjY2Vzc0xpc3QpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzTGlzdEpTT04gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFjY2Vzc0xpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gYWNjZXNzTGlzdFtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBKU09OSXRlbSA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiAnMHgnICsgKDAsIHV0aWxfMS5zZXRMZW5ndGhMZWZ0KShpdGVtWzBdLCAyMCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VLZXlzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlU2xvdHMgPSBpdGVtWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgc2xvdCA9IDA7IHNsb3QgPCBzdG9yYWdlU2xvdHMubGVuZ3RoOyBzbG90KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yYWdlU2xvdCA9IHN0b3JhZ2VTbG90c1tzbG90XTtcbiAgICAgICAgICAgICAgICBKU09OSXRlbS5zdG9yYWdlS2V5cy5wdXNoKCcweCcgKyAoMCwgdXRpbF8xLnNldExlbmd0aExlZnQpKHN0b3JhZ2VTbG90LCAzMikudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY2Vzc0xpc3RKU09OLnB1c2goSlNPTkl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0SlNPTjtcbiAgICB9XG4gICAgc3RhdGljIGdldERhdGFGZWVFSVAyOTMwKGFjY2Vzc0xpc3QsIGNvbW1vbikge1xuICAgICAgICBjb25zdCBhY2Nlc3NMaXN0U3RvcmFnZUtleUNvc3QgPSBjb21tb24ucGFyYW0oJ2dhc1ByaWNlcycsICdhY2Nlc3NMaXN0U3RvcmFnZUtleUNvc3QnKTtcbiAgICAgICAgY29uc3QgYWNjZXNzTGlzdEFkZHJlc3NDb3N0ID0gY29tbW9uLnBhcmFtKCdnYXNQcmljZXMnLCAnYWNjZXNzTGlzdEFkZHJlc3NDb3N0Jyk7XG4gICAgICAgIGxldCBzbG90cyA9IDA7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhY2Nlc3NMaXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGFjY2Vzc0xpc3RbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZVNsb3RzID0gaXRlbVsxXTtcbiAgICAgICAgICAgIHNsb3RzICs9IHN0b3JhZ2VTbG90cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gYWNjZXNzTGlzdC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBhZGRyZXNzZXMgKiBOdW1iZXIoYWNjZXNzTGlzdEFkZHJlc3NDb3N0KSArIHNsb3RzICogTnVtYmVyKGFjY2Vzc0xpc3RTdG9yYWdlS2V5Q29zdCk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2Nlc3NMaXN0cyA9IEFjY2Vzc0xpc3RzO1xuY29uc3QgYmxvYlR4VG9OZXR3b3JrV3JhcHBlckRhdGFGb3JtYXQgPSAodHgpID0+IHtcbiAgICBjb25zdCB0byA9IHtcbiAgICAgICAgc2VsZWN0b3I6IHR4LnRvICE9PSB1bmRlZmluZWQgPyAxIDogMCxcbiAgICAgICAgdmFsdWU6IHR4LnRvPy50b0J1ZmZlcigpID8/IG51bGwsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICBjaGFpbklkOiB0eC5jb21tb24uY2hhaW5JZCgpLFxuICAgICAgICAgICAgbm9uY2U6IHR4Lm5vbmNlLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0eC5tYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICBnYXM6IHR4Lmdhc0xpbWl0LFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICAgICAgICBkYXRhOiB0eC5kYXRhLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdHguYWNjZXNzTGlzdC5tYXAoKGxpc3RJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYWRkcmVzczogbGlzdEl0ZW1bMF0sIHN0b3JhZ2VLZXlzOiBsaXN0SXRlbVsxXSB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiB0eC52ZXJzaW9uZWRIYXNoZXMsXG4gICAgICAgICAgICBtYXhGZWVQZXJEYXRhR2FzOiB0eC5tYXhGZWVQZXJEYXRhR2FzLFxuICAgICAgICB9LFxuICAgICAgICAvLyBJZiB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZCwgc2lnbmF0dXJlIGZpZWxkcyB3aWxsIGJlIGluaXRpYWxpemVkIHRvIHplcm9lc1xuICAgICAgICBzaWduYXR1cmU6IHtcbiAgICAgICAgICAgIHI6IHR4LnIgPz8gQmlnSW50KDApLFxuICAgICAgICAgICAgczogdHgucyA/PyBCaWdJbnQoMCksXG4gICAgICAgICAgICB5UGFyaXR5OiB0eC52ID09PSBCaWdJbnQoMSkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLmJsb2JUeFRvTmV0d29ya1dyYXBwZXJEYXRhRm9ybWF0ID0gYmxvYlR4VG9OZXR3b3JrV3JhcHBlckRhdGFGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21taXRtZW50c1RvVmVyc2lvbmVkSGFzaGVzID0gZXhwb3J0cy5jb21wdXRlVmVyc2lvbmVkSGFzaCA9IGV4cG9ydHMuYmxvYnNUb0NvbW1pdG1lbnRzID0gZXhwb3J0cy5nZXRCbG9icyA9IHZvaWQgMDtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zaGEyNTZcIik7XG5jb25zdCBremdfMSA9IHJlcXVpcmUoXCIuLi9remcva3pnXCIpO1xuLyoqXG4gKiBUaGVzZSB1dGlsaXRpZXMgZm9yIGNvbnN0cnVjdGluZyBibG9icyBhcmUgYm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vSW5waGkvZWlwNDg0NC1pbnRlcm9wLmdpdFxuICovXG5jb25zdCBCWVRFU19QRVJfRklFTERfRUxFTUVOVCA9IDMyO1xuY29uc3QgRklFTERfRUxFTUVOVFNfUEVSX0JMT0IgPSA0MDk2O1xuY29uc3QgVVNFRlVMX0JZVEVTX1BFUl9CTE9CID0gMzIgKiBGSUVMRF9FTEVNRU5UU19QRVJfQkxPQjtcbmNvbnN0IE1BWF9CTE9CU19QRVJfVFggPSAyO1xuY29uc3QgTUFYX1VTRUZVTF9CWVRFU19QRVJfVFggPSBVU0VGVUxfQllURVNfUEVSX0JMT0IgKiBNQVhfQkxPQlNfUEVSX1RYIC0gMTtcbmNvbnN0IEJMT0JfU0laRSA9IEJZVEVTX1BFUl9GSUVMRF9FTEVNRU5UICogRklFTERfRUxFTUVOVFNfUEVSX0JMT0I7XG5mdW5jdGlvbiBnZXRfcGFkZGVkKGRhdGEsIGJsb2JzX2xlbikge1xuICAgIGNvbnN0IHBkYXRhID0gQnVmZmVyLmFsbG9jKGJsb2JzX2xlbiAqIFVTRUZVTF9CWVRFU19QRVJfQkxPQik7XG4gICAgY29uc3QgZGF0YWxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgIHBkYXRhLmZpbGwoZGF0YSwgMCwgZGF0YWxlbik7XG4gICAgcGRhdGFbZGF0YWxlbl0gPSAweDgwO1xuICAgIHJldHVybiBwZGF0YTtcbn1cbmZ1bmN0aW9uIGdldF9ibG9iKGRhdGEpIHtcbiAgICBjb25zdCBibG9iID0gQnVmZmVyLmFsbG9jKEJMT0JfU0laRSwgJ2JpbmFyeScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgRklFTERfRUxFTUVOVFNfUEVSX0JMT0I7IGkrKykge1xuICAgICAgICBjb25zdCBjaHVuayA9IEJ1ZmZlci5hbGxvYygzMiwgJ2JpbmFyeScpO1xuICAgICAgICBjaHVuay5maWxsKGRhdGEuc3ViYXJyYXkoaSAqIDMxLCAoaSArIDEpICogMzEpLCAwLCAzMSk7XG4gICAgICAgIGJsb2IuZmlsbChjaHVuaywgaSAqIDMyLCAoaSArIDEpICogMzIpO1xuICAgIH1cbiAgICByZXR1cm4gYmxvYjtcbn1cbmNvbnN0IGdldEJsb2JzID0gKGlucHV0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGlucHV0LCAnYmluYXJ5Jyk7XG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBibG9iIGRhdGEnKTtcbiAgICB9XG4gICAgaWYgKGxlbiA+IE1BWF9VU0VGVUxfQllURVNfUEVSX1RYKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdibG9iIGRhdGEgaXMgdG9vIGxhcmdlJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2JzX2xlbiA9IE1hdGguY2VpbChsZW4gLyBVU0VGVUxfQllURVNfUEVSX0JMT0IpO1xuICAgIGNvbnN0IHBkYXRhID0gZ2V0X3BhZGRlZChkYXRhLCBibG9ic19sZW4pO1xuICAgIGNvbnN0IGJsb2JzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ic19sZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaHVuayA9IHBkYXRhLnN1YmFycmF5KGkgKiBVU0VGVUxfQllURVNfUEVSX0JMT0IsIChpICsgMSkgKiBVU0VGVUxfQllURVNfUEVSX0JMT0IpO1xuICAgICAgICBjb25zdCBibG9iID0gZ2V0X2Jsb2IoY2h1bmspO1xuICAgICAgICBibG9icy5wdXNoKGJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gYmxvYnM7XG59O1xuZXhwb3J0cy5nZXRCbG9icyA9IGdldEJsb2JzO1xuY29uc3QgYmxvYnNUb0NvbW1pdG1lbnRzID0gKGJsb2JzKSA9PiB7XG4gICAgY29uc3QgY29tbWl0bWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJsb2Igb2YgYmxvYnMpIHtcbiAgICAgICAgY29tbWl0bWVudHMucHVzaChCdWZmZXIuZnJvbShremdfMS5remcuYmxvYlRvS3pnQ29tbWl0bWVudChibG9iKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWl0bWVudHM7XG59O1xuZXhwb3J0cy5ibG9ic1RvQ29tbWl0bWVudHMgPSBibG9ic1RvQ29tbWl0bWVudHM7XG4vKipcbiAqIENvbnZlcnRzIGEgdmVjdG9yIGNvbW1pdG1lbnQgZm9yIGEgZ2l2ZW4gZGF0YSBibG9iIHRvIGl0cyB2ZXJzaW9uZWQgaGFzaC4gIEZvciA0ODQ0LCB0aGlzIHZlcnNpb25cbiAqIG51bWJlciB3aWxsIGJlIDB4MDEgZm9yIEtaRyB2ZWN0b3IgY29tbWl0bWVudHMgYnV0IGNvdWxkIGJlIGRpZmZlcmVudCBpZiBmdXR1cmUgdmVjdG9yIGNvbW1pdG1lbnRcbiAqIHR5cGVzIGFyZSBpbnRyb2R1Y2VkXG4gKiBAcGFyYW0gY29tbWl0bWVudCBhIHZlY3RvciBjb21taXRtZW50IHRvIGEgYmxvYlxuICogQHBhcmFtIGJsb2JDb21taXRtZW50VmVyc2lvbiB0aGUgdmVyc2lvbiBudW1iZXIgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZSBvZiB2ZWN0b3IgY29tbWl0bWVudFxuICogQHJldHVybnMgYSB2ZXJzaW9uZWQgaGFzaCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gYmxvYiB2ZWN0b3IgY29tbWl0bWVudFxuICovXG5jb25zdCBjb21wdXRlVmVyc2lvbmVkSGFzaCA9IChjb21taXRtZW50LCBibG9iQ29tbWl0bWVudFZlcnNpb24pID0+IHtcbiAgICBjb25zdCBjb21wdXRlZFZlcnNpb25lZEhhc2ggPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgY29tcHV0ZWRWZXJzaW9uZWRIYXNoLnNldChbYmxvYkNvbW1pdG1lbnRWZXJzaW9uXSwgMCk7XG4gICAgY29tcHV0ZWRWZXJzaW9uZWRIYXNoLnNldCgoMCwgc2hhMjU2XzEuc2hhMjU2KShjb21taXRtZW50KS5zbGljZSgxKSwgMSk7XG4gICAgcmV0dXJuIGNvbXB1dGVkVmVyc2lvbmVkSGFzaDtcbn07XG5leHBvcnRzLmNvbXB1dGVWZXJzaW9uZWRIYXNoID0gY29tcHV0ZVZlcnNpb25lZEhhc2g7XG4vKipcbiAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIHZlcnNpb25lZCBoYXNoZXMgZnJvbSBjb3JyZXNwb25kaW5nIGt6ZyBjb21taXRtZW50c1xuICogQHBhcmFtIGNvbW1pdG1lbnRzIGFycmF5IG9mIGt6ZyBjb21taXRtZW50c1xuICogQHJldHVybnMgYXJyYXkgb2YgdmVyc2lvbmVkIGhhc2hlc1xuICogTm90ZTogYXNzdW1lcyBLWkcgY29tbWl0bWVudHMgKHZlcnNpb24gMSB2ZXJzaW9uIGhhc2hlcylcbiAqL1xuY29uc3QgY29tbWl0bWVudHNUb1ZlcnNpb25lZEhhc2hlcyA9IChjb21taXRtZW50cykgPT4ge1xuICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tbWl0bWVudCBvZiBjb21taXRtZW50cykge1xuICAgICAgICBoYXNoZXMucHVzaChCdWZmZXIuZnJvbSgoMCwgZXhwb3J0cy5jb21wdXRlVmVyc2lvbmVkSGFzaCkoY29tbWl0bWVudCwgMHgwMSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hlcztcbn07XG5leHBvcnRzLmNvbW1pdG1lbnRzVG9WZXJzaW9uZWRIYXNoZXMgPSBjb21taXRtZW50c1RvVmVyc2lvbmVkSGFzaGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYkhlbHBlcnMuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcImdvZXJsaVwiLFxuICAgIFwiY2hhaW5JZFwiOiA1LFxuICAgIFwibmV0d29ya0lkXCI6IDUsXG4gICAgXCJkZWZhdWx0SGFyZGZvcmtcIjogXCJtZXJnZVwiLFxuICAgIFwiY29uc2Vuc3VzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwicG9hXCIsXG4gICAgICAgIFwiYWxnb3JpdGhtXCI6IFwiY2xpcXVlXCIsXG4gICAgICAgIFwiY2xpcXVlXCI6IHtcbiAgICAgICAgICAgIFwicGVyaW9kXCI6IDE1LFxuICAgICAgICAgICAgXCJlcG9jaFwiOiAzMDAwMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImNvbW1lbnRcIjogXCJDcm9zcy1jbGllbnQgUG9BIHRlc3QgbmV0d29ya1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2dvZXJsaS90ZXN0bmV0XCIsXG4gICAgXCJnZW5lc2lzXCI6IHtcbiAgICAgICAgXCJ0aW1lc3RhbXBcIjogXCIweDVjNTFhNjA3XCIsXG4gICAgICAgIFwiZ2FzTGltaXRcIjogMTA0ODU3NjAsXG4gICAgICAgIFwiZGlmZmljdWx0eVwiOiAxLFxuICAgICAgICBcIm5vbmNlXCI6IFwiMHgwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIFwiZXh0cmFEYXRhXCI6IFwiMHgyMjQ2NmM2NTc4NjkyMDY5NzMyMDYxMjA3NDY4Njk2ZTY3MjIyMDJkMjA0MTY2NzI2OTAwMDAwMDAwMDAwMDAwZTBhMmJkNDI1OGQyNzY4ODM3YmFhMjZhMjhmZTcxZGMwNzlmODRjNzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgIH0sXG4gICAgXCJoYXJkZm9ya3NcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhhM2Y1YWIwOFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImhvbWVzdGVhZFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTNmNWFiMDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0YW5nZXJpbmVXaGlzdGxlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhhM2Y1YWIwOFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNwdXJpb3VzRHJhZ29uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhhM2Y1YWIwOFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImJ5emFudGl1bVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTNmNWFiMDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb25zdGFudGlub3BsZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YTNmNWFiMDhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwZXRlcnNidXJnXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhhM2Y1YWIwOFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImlzdGFuYnVsXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDE1NjE2NTEsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhjMjVlZmE1Y1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImJlcmxpblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA0NDYwNjQ0LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NzU3YTFjNDdcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsb25kb25cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogNTA2MjYwNSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGI4YzYyOTlkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCIvL19jb21tZW50XCI6IFwiVGhlIGZvcmtIYXNoIHdpbGwgcmVtYWluIHNhbWUgYXMgbWVyZ2VGb3JrSWRUcmFuc2l0aW9uIGlzIHBvc3QgbWVyZ2UsIHRlcm1pbmFsIGJsb2NrOiBodHRwczovL2dvZXJsaS5ldGhlcnNjYW4uaW8vYmxvY2svNzM4MjgxOFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VcIixcbiAgICAgICAgICAgIFwidHRkXCI6IFwiMTA3OTAwMDBcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogNzM4MjgxOSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGI4YzYyOTlkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2hhbmdoYWlcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwidGltZXN0YW1wXCI6IFwiMTY3ODgzMjczNlwiLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4Zjk4NDNhYmZcIlxuICAgICAgICB9XG4gICAgXSxcbiAgICBcImJvb3RzdHJhcE5vZGVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUxLjE0MS43OC41M1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjAxMWY3NThlNjU1MmQxMDUxODNiMTc2MWM1ZTJkZWEwMTExYmMyMGZkNWY2NDIyYmM3ZjkxZTBmYWJiZWM5YTY1OTVjYWY2MjM5YjM3ZmViNzczZGRkZDNmODcyNDBkOTlkODU5NDMxODkxZTRhNjQyY2YyYTBhOWU2Y2JiOThhXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJVcHN0cmVhbSBib290bm9kZSAxXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjEzLjkzLjU0LjEzN1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjE3NmI5NDE3ZjUxMWQwNWI2YjJjZjNlMzRiNzU2Y2YwYTcwOTZiMzA5NDU3MmE4ZjZlZjRjZGNiOWQxZjlkMDA2ODNiZjBmODMzNDdlZWJkZjNiODFjMzUyMWMyMzMyMDg2ZDk1OTI4MDIyMzBiZjUyOGVhZjYwNmExZDk2NzdiXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJVcHN0cmVhbSBib290bm9kZSAyXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjk0LjIzNy41NC4xMTRcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMxMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCI0NmFkZDQ0YjlmMTM5NjVmN2I5ODc1YWM2Yjg1ZjAxNmYzNDEwMTJkODRmOTc1Mzc3NTczODAwYTg2MzUyNmY0ZGExOWFlMmM2MjBlYzczZDExNTkxZmE5NTEwZTk5MmVjYzAzYWQwNzUxZjUzY2MwMmY3YzdlZDZkNTVjNzI5MVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiVXBzdHJlYW0gYm9vdG5vZGUgM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxOC4yMTguMjUwLjY2XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMTMsXG4gICAgICAgICAgICBcImlkXCI6IFwiYjU5NDhhMmQzZTlkNDg2YzRkNzViZjMyNzEzMjIxYzJiZDZjZjg2NDYzMzAyMzM5Mjk5YmQyMjdkYzJlMjc2Y2Q1YTFjN2NhNGY0M2EwZTkxMjJmZTlhZjg4NGVmZWQ1NjNiZDJhMWZkMjg2NjFmM2I1ZjVhZDdiZjFkZTU5NDlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIlVwc3RyZWFtIGJvb3Rub2RlIDRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiMy4xMS4xNDcuNjdcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCJhNjEyMTU2NDFmYjg3MTRhMzczYzgwZWRiZmEwZWE4ODc4MjQzMTkzZjU3Yzk2ZWViNDRkMGJjMDE5ZWYyOTVhYmQ0ZTA0NGZkNjE5YmZjNGM1OTczMWE3M2ZiNzlhZmU4NGU5YWI2ZGEwYzc0M2NlYjQ3OWNiYjZkMjYzZmE5MVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiRXRoZXJldW0gRm91bmRhdGlvbiBib290bm9kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCI1MS4xNS4xMTYuMjI2XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiYTg2OWIwMmNlYzE2NzIxMWZiNDgxNWE4Mjk0MWRiMmU3ZWQyOTM2ZmQ5MGU3ODYxOWM1M2ViMTc3NTNmY2YwMjA3NDYzZTM0MTljMjY0ZTJhMWRkODc4NmRlMGRmN2U2OGNmOTk1NzFhYjhhZWI3YzRlNTEzNjdlZjE4NmIxZGRcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkdvZXJsaSBJbml0aWF0aXZlIGJvb3Rub2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUxLjE1LjExOS4xNTdcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCI4MDdiMzdlZTQ4MTZlY2Y0MDdlOTExMjIyNDQ5NGI3NGRkNTkzMzYyNWY2NTU5NjJkODkyZjJmMGYwMmQ3ZmJiYjNlMmE5NGNmODdhOTY2MDk1MjZmMzBjOTk4ZmQ3MWU5M2UyZjUzMDE1YzU1OGZmYzhiMDNlY2VhZjMwZWUzM1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiR29lcmxpIEluaXRpYXRpdmUgYm9vdG5vZGVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTEuMTUuMTE5LjE1N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDQwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcImE1OWUzM2NjZDJiM2U1MmQ1NzhmMWZiZDcwYzZmOWJhYmRhMjY1MGYwNzYwZDZmZjNiMzc3NDJmZGNkZmRiM2RlZmJhNWQ1NmQzMTViNDBjNDZiNzAxOThjNzYyMWU2M2ZmYTNmOTg3Mzg5YzcxMTg2MzRiMGZlZmJiZGZhN2ZkXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJHb2VybGkgSW5pdGlhdGl2ZSBib290bm9kZVwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZG5zTmV0d29ya3NcIjogW1xuICAgICAgICBcImVucnRyZWU6Ly9BS0EzQU02TFBCWUVVRE1WTlUzQlNWUUo1QUQ0NVk3WVBPSEpMRUY2VzI2UU9FNFZUVURQRUBhbGwuZ29lcmxpLmV0aGRpc2NvLm5ldFwiXG4gICAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIm1haW5uZXRcIixcbiAgICBcImNoYWluSWRcIjogMSxcbiAgICBcIm5ldHdvcmtJZFwiOiAxLFxuICAgIFwiZGVmYXVsdEhhcmRmb3JrXCI6IFwibWVyZ2VcIixcbiAgICBcImNvbnNlbnN1c1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInBvd1wiLFxuICAgICAgICBcImFsZ29yaXRobVwiOiBcImV0aGFzaFwiLFxuICAgICAgICBcImV0aGFzaFwiOiB7fVxuICAgIH0sXG4gICAgXCJjb21tZW50XCI6IFwiVGhlIEV0aGVyZXVtIG1haW4gY2hhaW5cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZXRoc3RhdHMubmV0L1wiLFxuICAgIFwiZ2VuZXNpc1wiOiB7XG4gICAgICAgIFwiZ2FzTGltaXRcIjogNTAwMCxcbiAgICAgICAgXCJkaWZmaWN1bHR5XCI6IDE3MTc5ODY5MTg0LFxuICAgICAgICBcIm5vbmNlXCI6IFwiMHgwMDAwMDAwMDAwMDAwMDQyXCIsXG4gICAgICAgIFwiZXh0cmFEYXRhXCI6IFwiMHgxMWJiZThkYjRlMzQ3YjRlOGM5MzdjMWM4MzcwZTRiNWVkMzNhZGIzZGI2OWNiZGI3YTM4ZTFlNTBiMWI4MmZhXCJcbiAgICB9LFxuICAgIFwiaGFyZGZvcmtzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4ZmM2NGVjMDRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJob21lc3RlYWRcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTE1MDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDk3YzJjMzRjXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGFvXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDE5MjAwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg5MWQxZjk0OFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRhbmdlcmluZVdoaXN0bGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMjQ2MzAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDdhNjRkYTEzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3B1cmlvdXNEcmFnb25cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMjY3NTAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDNlZGQ1YjEwXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYnl6YW50aXVtXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDQzNzAwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhhMDBiYzMyNFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnN0YW50aW5vcGxlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDcyODAwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg2NjhkYjBhZlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBldGVyc2J1cmdcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogNzI4MDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDY2OGRiMGFmXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaXN0YW5idWxcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogOTA2OTAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDg3OWQ2ZTMwXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibXVpckdsYWNpZXJcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogOTIwMDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGUwMjllOTkxXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYmVybGluXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDEyMjQ0MDAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4MGViNDQwZjZcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsb25kb25cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTI5NjUwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhiNzE1MDc3ZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImFycm93R2xhY2llclwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAxMzc3MzAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDIwYzMyN2ZjXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZ3JheUdsYWNpZXJcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTUwNTAwMDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmMGFmZDBlM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiLy9fY29tbWVudFwiOiBcIlRoZSBmb3JrSGFzaCB3aWxsIHJlbWFpbiBzYW1lIGFzIG1lcmdlRm9ya0lkVHJhbnNpdGlvbiBpcyBwb3N0IG1lcmdlLCB0ZXJtaW5hbCBibG9jazogaHR0cHM6Ly9ldGhlcnNjYW4uaW8vYmxvY2svMTU1MzczOTNcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lcmdlXCIsXG4gICAgICAgICAgICBcInR0ZFwiOiBcIjU4NzUwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDE1NTM3Mzk0LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4ZjBhZmQwZTNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZXJnZUZvcmtJZFRyYW5zaXRpb25cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogbnVsbFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzaGFuZ2hhaVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiBudWxsLFxuICAgICAgICAgICAgXCJ0aW1lc3RhbXBcIjogXCIxNjgxMzM4NDU1XCIsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhkY2U5NmMyZFwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiYm9vdHN0cmFwTm9kZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiMTguMTM4LjEwOC42N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcImQ4NjBhMDFmOTcyMmQ3ODA1MTYxOWQxZTIzNTFhYmEzZjQzZjk0M2Y2ZjAwNzE4ZDFiOWJhYTQxMDE5MzJhMWY1MDExZjE2YmIyYjFiYjM1ZGIyMGQ2ZmUyOGZhMGJmMDk2MzZkMjZhODdkMzFkZTllYzYyMDNlZWVkYjFmNjY2XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiYXAtc291dGhlYXN0LTEtMDAxXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJib290bm9kZS1hd3MtYXAtc291dGhlYXN0LTEtMDAxXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjMuMjA5LjQ1Ljc5XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiMjJhODIzMmMzYWJjNzZhMTZhZTlkNmMzYjE2NGY5ODc3NWZlMjI2ZjA5MTdiMGNhODcxMTI4YTc0YThlOTYzMGI0NTg0NjA4NjViYWI0NTcyMjFmMWQ0NDhkZDk3OTFkMjRjNGU1ZDg4Nzg2MTgwYWMxODVkZjgxM2E2OGQ0ZGVcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cy1lYXN0LTEtMDAxXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJib290bm9kZS1hd3MtdXMtZWFzdC0xLTAwMVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCI2NS4xMDguNzAuMTAxXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiMmIyNTJhYjZhMWQwZjk3MWQ5NzIyY2I4MzlhNDJjYjgxZGIwMTliYTQ0YzA4NzU0NjI4YWI0YTgyMzQ4NzA3MWI1Njk1MzE3YzhjY2QwODUyMTljM2EwM2FmMDYzNDk1YjJmMWRhOGQxODIxOGRhMmQ2YTgyOTgxYjQ1ZTZmZmNcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJldS13ZXN0LTEtMDAxXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJib290bm9kZS1oZXR6bmVyLWhlbFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxNTcuOTAuMzUuMTY2XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiNGFlYjRhYjZjMTRiMjNlMmM0Y2ZkY2U4NzljMDRiMDc0OGEyMGQ4ZTliNTllMjVkZWQyYTA4MTQzZTI2NWM2YzI1OTM2ZTc0Y2JjOGU2NDFlMzMxMmNhMjg4NjczZDkxZjJmOTNmOGUyNzdkZTNjZmE0NDRlY2RhYWY5ODIwNTJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJldS1jZW50cmFsLTEtMDAxXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJib290bm9kZS1oZXR6bmVyLWZzblwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZG5zTmV0d29ya3NcIjogW1xuICAgICAgICBcImVucnRyZWU6Ly9BS0EzQU02TFBCWUVVRE1WTlUzQlNWUUo1QUQ0NVk3WVBPSEpMRUY2VzI2UU9FNFZUVURQRUBhbGwubWFpbm5ldC5ldGhkaXNjby5uZXRcIlxuICAgIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJyaW5rZWJ5XCIsXG4gICAgXCJjaGFpbklkXCI6IDQsXG4gICAgXCJuZXR3b3JrSWRcIjogNCxcbiAgICBcImRlZmF1bHRIYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwiY29uc2Vuc3VzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwicG9hXCIsXG4gICAgICAgIFwiYWxnb3JpdGhtXCI6IFwiY2xpcXVlXCIsXG4gICAgICAgIFwiY2xpcXVlXCI6IHtcbiAgICAgICAgICAgIFwicGVyaW9kXCI6IDE1LFxuICAgICAgICAgICAgXCJlcG9jaFwiOiAzMDAwMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImNvbW1lbnRcIjogXCJQb0EgdGVzdCBuZXR3b3JrXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL3d3dy5yaW5rZWJ5LmlvXCIsXG4gICAgXCJnZW5lc2lzXCI6IHtcbiAgICAgICAgXCJ0aW1lc3RhbXBcIjogXCIweDU4ZWU0MGJhXCIsXG4gICAgICAgIFwiZ2FzTGltaXRcIjogNDcwMDAwMCxcbiAgICAgICAgXCJkaWZmaWN1bHR5XCI6IDEsXG4gICAgICAgIFwibm9uY2VcIjogXCIweDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCJleHRyYURhdGFcIjogXCIweDUyNjU3MzcwNjU2Mzc0MjA2ZDc5MjA2MTc1NzQ2ODZmNzI2OTc0NjE2ODIwN2U0NTJlNDM2MTcyNzQ2ZDYxNmU0MmViNzY4ZjIyNDRjODgxMWM2MzcyOWEyMWEzNTY5NzMxNTM1ZjA2N2ZmYzU3ODM5YjAwMjA2ZDFhZDIwYzY5YTE5ODFiNDg5Zjc3MjAzMWIyNzkxODJkOTllNjU3MDNmMDA3NmU0ODEyNjUzYWFiODVmY2EwZjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICB9LFxuICAgIFwiaGFyZGZvcmtzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4M2I4ZTA2OTFcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJob21lc3RlYWRcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDYwOTQ5Mjk1XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidGFuZ2VyaW5lV2hpc3RsZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAyLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4OGJkZTQwZGRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzcHVyaW91c0RyYWdvblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAzLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4Y2IzYTY0YmJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJieXphbnRpdW1cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTAzNTMwMSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDhkNzQ4YjU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uc3RhbnRpbm9wbGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMzY2MDY2MyxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGU0OWNhYjE0XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGV0ZXJzYnVyZ1wiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA0MzIxMjM0LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4YWZlYzZiMjdcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpc3RhbmJ1bFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA1NDM1MzQ1LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4Y2JkYjg4MzhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiZXJsaW5cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogODI5MDkyOCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDY5MTBjOGJkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9uZG9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDg4OTc5ODgsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHg4ZTI5ZjJmM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lcmdlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2hhbmdoYWlcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogbnVsbFxuICAgICAgICB9XG4gICAgXSxcbiAgICBcImJvb3RzdHJhcE5vZGVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUyLjE2OS40Mi4xMDFcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCJhMjRhYzdjNTQ4NGVmNGVkMGM1ZWIyZDM2NjIwYmE0ZTRhYTEzYjhjODQ2ODRlMWI0YWFiMGNlYmVhMmFlNDVjYjRkMzc1Yjc3ZWFiNTY1MTZkMzRiZmJkM2MxYTgzM2ZjNTEyOTZmZjA4NGI3NzBiOTRmYjkwMjhjNGQyNWNjZlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiSUVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMy4xNTguMTg0XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiMzQzMTQ5ZTRmZWVmYTE1ZDg4MmQ5ZmU0YWM3ZDg4Zjg4NWJkMDVlYmI3MzVlNTQ3ZjEyZTEyMDgwYTlmYTA3YzgwMTRjYTZmZDdmMzczMTIzNDg4MTAyZmU1ZTM0MTExZjg1MDljZjBiN2RlM2Y1YjQ0MzM5YzlmMjVlODdjYjhcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIklORlVSQVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxNTkuODkuMjguMjExXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiYjZiMjg4OTBiMDA2NzQzNjgwYzUyZTY0ZTBkMTZkYjU3ZjI4MTI0ODg1NTk1ZmEwM2E1NjJiZTFkMmJmMGYzYTFkYTI5N2Q1NmIxM2RhMjVmYjk5Mjg4OGZkNTU2ZDRjMWEyN2IxZjM5ZDUzMWJkZTdkZTE5MjFjOTAwNjFjYzZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkFLQVNIQVwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZG5zTmV0d29ya3NcIjogW1xuICAgICAgICBcImVucnRyZWU6Ly9BS0EzQU02TFBCWUVVRE1WTlUzQlNWUUo1QUQ0NVk3WVBPSEpMRUY2VzI2UU9FNFZUVURQRUBhbGwucmlua2VieS5ldGhkaXNjby5uZXRcIlxuICAgIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJyb3BzdGVuXCIsXG4gICAgXCJjaGFpbklkXCI6IDMsXG4gICAgXCJuZXR3b3JrSWRcIjogMyxcbiAgICBcImRlZmF1bHRIYXJkZm9ya1wiOiBcIm1lcmdlXCIsXG4gICAgXCJjb25zZW5zdXNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJwb3dcIixcbiAgICAgICAgXCJhbGdvcml0aG1cIjogXCJldGhhc2hcIixcbiAgICAgICAgXCJldGhhc2hcIjoge31cbiAgICB9LFxuICAgIFwiY29tbWVudFwiOiBcIlBvVyB0ZXN0IG5ldHdvcmtcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9yb3BzdGVuXCIsXG4gICAgXCJnZW5lc2lzXCI6IHtcbiAgICAgICAgXCJnYXNMaW1pdFwiOiAxNjc3NzIxNixcbiAgICAgICAgXCJkaWZmaWN1bHR5XCI6IDEwNDg1NzYsXG4gICAgICAgIFwibm9uY2VcIjogXCIweDAwMDAwMDAwMDAwMDAwNDJcIixcbiAgICAgICAgXCJleHRyYURhdGFcIjogXCIweDM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzUzNTM1MzVcIlxuICAgIH0sXG4gICAgXCJoYXJkZm9ya3NcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHgzMGM3ZGRiY1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImhvbWVzdGVhZFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4MzBjN2RkYmNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0YW5nZXJpbmVXaGlzdGxlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHgzMGM3ZGRiY1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNwdXJpb3VzRHJhZ29uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDEwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NjM3NjAxOTBcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJieXphbnRpdW1cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTcwMDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDNlYTE1OWM3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uc3RhbnRpbm9wbGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogNDIzMDAwMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDk3YjU0NGYzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGV0ZXJzYnVyZ1wiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA0OTM5Mzk0LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4ZDZlMjE0OWJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpc3RhbmJ1bFwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA2NDg1ODQ2LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NGJjNjYzOTZcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtdWlyR2xhY2llclwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiA3MTE3MTE3LFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NjcyN2VmOTBcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiZXJsaW5cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogOTgxMjE4OSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGExNTdkMzc3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9uZG9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDEwNDk5NDAxLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4NzExOWI2YjNcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIi8vX2NvbW1lbnRcIjogXCJUaGUgZm9ya0hhc2ggd2lsbCByZW1haW4gc2FtZSBhcyBtZXJnZUZvcmtJZFRyYW5zaXRpb24gaXMgcG9zdCBtZXJnZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VcIixcbiAgICAgICAgICAgIFwidHRkXCI6IFwiNTAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweDcxMTliNmIzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2hhbmdoYWlcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogbnVsbFxuICAgICAgICB9XG4gICAgXSxcbiAgICBcImJvb3RzdHJhcE5vZGVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjUyLjE3Ni43LjEwXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiMzBiN2FiMzBhMDFjMTI0YTZjY2VjYTM2ODYzZWNlMTJjNGY1ZmE2OGUzYmE5YjBiNTE0MDdjY2MwMDJlZWVkM2IzMTAyZDIwYTg4ZjFjMWQzYzMxNTRlMjQ0OTMxN2I4ZWY5NTA5MGU3N2IzMTJkNWNjMzkzNTRmODZkNWQ2MDZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIlVTLUF6dXJlIGdldGhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMTc2LjEwMC43N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjg2NWE2MzI1NWIzYmI2ODAyM2I2YmZmZDUwOTUxMThmY2MxM2U3OWRjZjAxNGZlNGU0N2UwNjVjMzUwYzdjYzcyYWYyZTUzZWZmODk1ZjExYmExYmJiNmEyYjMzMjcxYzExMTZlZTg3MGYyNjY2MThlYWRmYzJlNzhhYTczNDljXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJVUy1BenVyZSBwYXJpdHlcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMjMyLjI0My4xNTJcIixcbiAgICAgICAgICAgIFwicG9ydFwiOiAzMDMwMyxcbiAgICAgICAgICAgIFwiaWRcIjogXCI2MzMyNzkyYzRhMDBlM2U0ZWUwOTI2ZWQ4OWUwZDI3ZWY5ODU0MjRkOTdiNmE0NWJmMGYyM2U1MWYwZGNiNWU2NmI4NzU3Nzc1MDY0NThhZWE3YWY2ZjllNGZmYjY5ZjQzZjM3NzhlZTczYzgxZWQ5ZDM0YzUxYzRiMTZiMGIwZlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcIlwiLFxuICAgICAgICAgICAgXCJjb21tZW50XCI6IFwiUGFyaXR5XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjE5Mi44MS4yMDguMjIzXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiOTRjMTVkMWI5ZTJmZTdjZTU2ZTQ1OGI5YTNiNjcyZWYxMTg5NGRkZWRkMGM2ZjI0N2UwZjFkMzQ4N2Y1MmI2NjIwOGZiNGFlYjgxNzlmY2U2ZTNhNzQ5ZWE5M2VkMTQ3YzM3OTc2ZDY3YWY1NTc1MDhkMTk5ZDk1OTRjMzVmMDlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkBncGlwXCJcbiAgICAgICAgfVxuICAgIF0sXG4gICAgXCJkbnNOZXR3b3Jrc1wiOiBbXG4gICAgICAgIFwiZW5ydHJlZTovL0FLQTNBTTZMUEJZRVVETVZOVTNCU1ZRSjVBRDQ1WTdZUE9ISkxFRjZXMjZRT0U0VlRVRFBFQGFsbC5yb3BzdGVuLmV0aGRpc2NvLm5ldFwiXG4gICAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInNlcG9saWFcIixcbiAgICBcImNoYWluSWRcIjogMTExNTUxMTEsXG4gICAgXCJuZXR3b3JrSWRcIjogMTExNTUxMTEsXG4gICAgXCJkZWZhdWx0SGFyZGZvcmtcIjogXCJtZXJnZVwiLFxuICAgIFwiY29uc2Vuc3VzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwicG93XCIsXG4gICAgICAgIFwiYWxnb3JpdGhtXCI6IFwiZXRoYXNoXCIsXG4gICAgICAgIFwiZXRoYXNoXCI6IHt9XG4gICAgfSxcbiAgICBcImNvbW1lbnRcIjogXCJQb1cgdGVzdCBuZXR3b3JrIHRvIHJlcGxhY2UgUm9wc3RlblwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL3B1bGwvMjM3MzBcIixcbiAgICBcImdlbmVzaXNcIjoge1xuICAgICAgICBcInRpbWVzdGFtcFwiOiBcIjB4NjE1OWFmMTlcIixcbiAgICAgICAgXCJnYXNMaW1pdFwiOiAzMDAwMDAwMCxcbiAgICAgICAgXCJkaWZmaWN1bHR5XCI6IDEzMTA3MixcbiAgICAgICAgXCJub25jZVwiOiBcIjB4MDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICBcImV4dHJhRGF0YVwiOiBcIjB4NTM2NTcwNmY2YzY5NjEyYzIwNDE3NDY4NjU2ZTczMmMyMDQxNzQ3NDY5NjM2MTJjMjA0NzcyNjU2NTYzNjUyMVwiXG4gICAgfSxcbiAgICBcImhhcmRmb3Jrc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNoYWluc3RhcnRcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaG9tZXN0ZWFkXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRhbmdlcmluZVdoaXN0bGVcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3B1cmlvdXNEcmFnb25cIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYnl6YW50aXVtXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnN0YW50aW5vcGxlXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBldGVyc2J1cmdcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaXN0YW5idWxcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibXVpckdsYWNpZXJcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMCxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYmVybGluXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDAsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhmZTMzNjZlN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxvbmRvblwiLFxuICAgICAgICAgICAgXCJibG9ja1wiOiAwLFxuICAgICAgICAgICAgXCJmb3JrSGFzaFwiOiBcIjB4ZmUzMzY2ZTdcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcIi8vX2NvbW1lbnRcIjogXCJUaGUgZm9ya0hhc2ggd2lsbCByZW1haW4gc2FtZSBhcyBtZXJnZUZvcmtJZFRyYW5zaXRpb24gaXMgcG9zdCBtZXJnZSwgdGVybWluYWwgYmxvY2s6IGh0dHBzOi8vc2Vwb2xpYS5ldGhlcnNjYW4uaW8vYmxvY2svMTQ1MDQwOFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VcIixcbiAgICAgICAgICAgIFwidHRkXCI6IFwiMTcwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgICAgIFwiYmxvY2tcIjogMTQ1MDQwOSxcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGZlMzM2NmU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IDE3MzUzNzEsXG4gICAgICAgICAgICBcImZvcmtIYXNoXCI6IFwiMHhiOTZjYmQxM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNoYW5naGFpXCIsXG4gICAgICAgICAgICBcImJsb2NrXCI6IG51bGwsXG4gICAgICAgICAgICBcInRpbWVzdGFtcFwiOiBcIjE2Nzc1NTcwODhcIixcbiAgICAgICAgICAgIFwiZm9ya0hhc2hcIjogXCIweGY3ZjliYzA4XCJcbiAgICAgICAgfVxuICAgIF0sXG4gICAgXCJib290c3RyYXBOb2Rlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiaXBcIjogXCIxOC4xNjguMTgyLjg2XCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiOTI0NmQwMGJjOGZkMTc0MmU1YWQyNDI4YjgwZmM0ZGM0NWQ3ODYyODNlMDVlZjZlZGJkOTAwMmNiYzMzNWQ0MDk5ODQ0NDczMmZiZTkyMWNiODhlMWQyYzczZDFiMWRlNTNiYWU2YTIyMzc5OTZlOWJmZTE0Zjg3MWJhZjcwNjZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcImdldGhcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImlwXCI6IFwiNTIuMTQuMTUxLjE3N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcImVjNjZkZGNmMWE5NzQ5NTBiZDRjNzgyNzg5YTdlMDRmOGFhNzExMGE3MjU2OWI2ZTY1ZmNkNTFlOTM3ZTc0ZWVkMzAzYjFlYTczNGU0ZDE5Y2ZhZWM5ZmJmZjliNmVlNjViZjMxZGNiNTBiYTc5YWNjZTlkZDYzYTZhY2E2MWM3XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJiZXN1XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjE2NS4yMi4xOTYuMTczXCIsXG4gICAgICAgICAgICBcInBvcnRcIjogMzAzMDMsXG4gICAgICAgICAgICBcImlkXCI6IFwiY2U5NzBhZDJlOWRhYTllMTQ1OTNkZTg0YThiNDlkYTNkNTRjY2ZkZjgzY2JjNGZlNTE5Y2I4YjM2YjU5MThlZDRlYWIwODdkZWRkNGE2MjQ3OWI4ZDUwNzU2YjQ5MmQ1Zjc2MjM2N2M4ZDIwMzI5YTc4NTRlYzAxNTQ3NTY4YTZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJcIixcbiAgICAgICAgICAgIFwiY29tbWVudFwiOiBcIkVGXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJpcFwiOiBcIjY1LjEwOC45NS42N1wiLFxuICAgICAgICAgICAgXCJwb3J0XCI6IDMwMzAzLFxuICAgICAgICAgICAgXCJpZFwiOiBcIjA3NTUwM2IxM2VkNzM2MjQ0ODk2ZWZjZGUyYTk5MmVjMGI0NTEzNTdkNDZjYjdhODEzMmMwMzg0NzIxNzQyNTk3ZmM4ZjBkOTFiYmI0MGJiNTJlN2Q2ZTY2NzI4ZDM2YTFmZGEwOTE3NjI5NGU0YTMwY2ZhYzU1ZGNjZTI2YmM2XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgICBcImNvbW1lbnRcIjogXCJsb2Rlc3RhclwiXG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZG5zTmV0d29ya3NcIjogW1xuICAgICAgICBcImVucnRyZWU6Ly9BS0EzQU02TFBCWUVVRE1WTlUzQlNWUUo1QUQ0NVk3WVBPSEpMRUY2VzI2UU9FNFZUVURQRUBhbGwuc2Vwb2xpYS5ldGhkaXNjby5uZXRcIlxuICAgIF1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb24gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IGNyY18zMl8xID0gcmVxdWlyZShcImNyYy0zMlwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGdvZXJsaSA9IHJlcXVpcmUoXCIuL2NoYWlucy9nb2VybGkuanNvblwiKTtcbmNvbnN0IG1haW5uZXQgPSByZXF1aXJlKFwiLi9jaGFpbnMvbWFpbm5ldC5qc29uXCIpO1xuY29uc3Qgcmlua2VieSA9IHJlcXVpcmUoXCIuL2NoYWlucy9yaW5rZWJ5Lmpzb25cIik7XG5jb25zdCByb3BzdGVuID0gcmVxdWlyZShcIi4vY2hhaW5zL3JvcHN0ZW4uanNvblwiKTtcbmNvbnN0IHNlcG9saWEgPSByZXF1aXJlKFwiLi9jaGFpbnMvc2Vwb2xpYS5qc29uXCIpO1xuY29uc3QgZWlwc18xID0gcmVxdWlyZShcIi4vZWlwc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGhhcmRmb3Jrc18xID0gcmVxdWlyZShcIi4vaGFyZGZvcmtzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBDb21tb24gY2xhc3MgdG8gYWNjZXNzIGNoYWluIGFuZCBoYXJkZm9yayBwYXJhbWV0ZXJzIGFuZCB0byBwcm92aWRlXG4gKiBhIHVuaWZpZWQgYW5kIHNoYXJlZCB2aWV3IG9uIHRoZSBuZXR3b3JrIGFuZCBoYXJkZm9yayBzdGF0ZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayBDb21tb24uY3VzdG9tfSBzdGF0aWMgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIHNpbXBsZVxuICogY3VzdG9tIGNoYWluIHtAbGluayBDb21tb259IG9iamVjdHMgKG1vcmUgY29tcGxldGUgY3VzdG9tIGNoYWluIHNldHVwc1xuICogY2FuIGJlIGNyZWF0ZWQgdmlhIHRoZSBtYWluIGNvbnN0cnVjdG9yIGFuZCB0aGUge0BsaW5rIENvbW1vbk9wdHMuY3VzdG9tQ2hhaW5zfSBwYXJhbWV0ZXIpLlxuICovXG5jbGFzcyBDb21tb24gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZWlwcyA9IFtdO1xuICAgICAgICB0aGlzLl9jdXN0b21DaGFpbnMgPSBvcHRzLmN1c3RvbUNoYWlucyA/PyBbXTtcbiAgICAgICAgdGhpcy5fY2hhaW5QYXJhbXMgPSB0aGlzLnNldENoYWluKG9wdHMuY2hhaW4pO1xuICAgICAgICB0aGlzLkRFRkFVTFRfSEFSREZPUksgPSB0aGlzLl9jaGFpblBhcmFtcy5kZWZhdWx0SGFyZGZvcmsgPz8gZW51bXNfMS5IYXJkZm9yay5NZXJnZTtcbiAgICAgICAgLy8gQXNzaWduIGhhcmRmb3JrIGNoYW5nZXMgaW4gdGhlIHNlcXVlbmNlIG9mIHRoZSBhcHBsaWVkIGhhcmRmb3Jrc1xuICAgICAgICB0aGlzLkhBUkRGT1JLX0NIQU5HRVMgPSB0aGlzLmhhcmRmb3JrcygpLm1hcCgoaGYpID0+IFtcbiAgICAgICAgICAgIGhmLm5hbWUsXG4gICAgICAgICAgICBoYXJkZm9ya3NfMS5oYXJkZm9ya3NbaGYubmFtZV0sXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLl9oYXJkZm9yayA9IHRoaXMuREVGQVVMVF9IQVJERk9SSztcbiAgICAgICAgaWYgKG9wdHMuaGFyZGZvcmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIYXJkZm9yayhvcHRzLmhhcmRmb3JrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5laXBzKSB7XG4gICAgICAgICAgICB0aGlzLnNldEVJUHMob3B0cy5laXBzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEge0BsaW5rIENvbW1vbn0gb2JqZWN0IGZvciBhIGN1c3RvbSBjaGFpbiwgYmFzZWQgb24gYSBzdGFuZGFyZCBvbmUuXG4gICAgICpcbiAgICAgKiBJdCB1c2VzIGFsbCB0aGUge0BsaW5rIENoYWlufSBwYXJhbWV0ZXJzIGZyb20gdGhlIHtAbGluayBiYXNlQ2hhaW59IG9wdGlvbiBleGNlcHQgdGhlIG9uZXMgb3ZlcnJpZGRlblxuICAgICAqIGluIGEgcHJvdmlkZWQge0BsaW5rIGNoYWluUGFyYW1zT3JOYW1lfSBkaWN0aW9uYXJ5LiBTb21lIHVzYWdlIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogQ29tbW9uLmN1c3RvbSh7Y2hhaW5JZDogMTIzfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSBhbHNvIHNlbGVjdGVkIHN1cHBvcnRlZCBjdXN0b20gY2hhaW5zIHdoaWNoIGNhbiBiZSBpbml0aWFsaXplZCBieSB1c2luZyBvbmUgb2YgdGhlXG4gICAgICoge0BsaW5rIEN1c3RvbUNoYWluc30gZm9yIHtAbGluayBjaGFpblBhcmFtc09yTmFtZX0sIGUuZy46XG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogQ29tbW9uLmN1c3RvbShDdXN0b21DaGFpbnMuTWF0aWNNdW1iYWkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlc2Ugc3VwcG9ydGVkIGN1c3RvbSBjaGFpbnMgb25seSBwcm92aWRlIHNvbWUgYmFzZSBwYXJhbWV0ZXJzICh1c3VhbGx5IHRoZSBjaGFpbiBhbmRcbiAgICAgKiBuZXR3b3JrIElEIGFuZCBhIG5hbWUpIGFuZCBjYW4gb25seSBiZSB1c2VkIGZvciBzZWxlY3RlZCB1c2UgY2FzZXMgKGUuZy4gc2VuZGluZyBhIHR4IHdpdGhcbiAgICAgKiB0aGUgYEBldGhlcmV1bWpzL3R4YCBsaWJyYXJ5IHRvIGEgTGF5ZXItMiBjaGFpbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5QYXJhbXNPck5hbWUgQ3VzdG9tIHBhcmFtZXRlciBkaWN0IChgbmFtZWAgd2lsbCBkZWZhdWx0IHRvIGBjdXN0b20tY2hhaW5gKSBvciBzdHJpbmcgd2l0aCBuYW1lIG9mIGEgc3VwcG9ydGVkIGN1c3RvbSBjaGFpblxuICAgICAqIEBwYXJhbSBvcHRzIEN1c3RvbSBjaGFpbiBvcHRpb25zIHRvIHNldCB0aGUge0BsaW5rIEN1c3RvbUNvbW1vbk9wdHMuYmFzZUNoYWlufSwgc2VsZWN0ZWQge0BsaW5rIEN1c3RvbUNvbW1vbk9wdHMuaGFyZGZvcmt9IGFuZCBvdGhlcnNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3VzdG9tKGNoYWluUGFyYW1zT3JOYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYmFzZUNoYWluID0gb3B0cy5iYXNlQ2hhaW4gPz8gJ21haW5uZXQnO1xuICAgICAgICBjb25zdCBzdGFuZGFyZENoYWluUGFyYW1zID0geyAuLi5Db21tb24uX2dldENoYWluUGFyYW1zKGJhc2VDaGFpbikgfTtcbiAgICAgICAgc3RhbmRhcmRDaGFpblBhcmFtc1snbmFtZSddID0gJ2N1c3RvbS1jaGFpbic7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhaW5QYXJhbXNPck5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbW1vbih7XG4gICAgICAgICAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhbmRhcmRDaGFpblBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hhaW5QYXJhbXNPck5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uUG9seWdvbk1haW5uZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGVudW1zXzEuQ3VzdG9tQ2hhaW4uUG9seWdvbk1haW5uZXQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEzNyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiAxMzcsXG4gICAgICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uUG9seWdvbk11bWJhaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZW51bXNfMS5DdXN0b21DaGFpbi5Qb2x5Z29uTXVtYmFpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiA4MDAwMSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiA4MDAwMSxcbiAgICAgICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpblBhcmFtc09yTmFtZSA9PT0gZW51bXNfMS5DdXN0b21DaGFpbi5BcmJpdHJ1bVJpbmtlYnlUZXN0bmV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbnVtc18xLkN1c3RvbUNoYWluLkFyYml0cnVtUmlua2VieVRlc3RuZXQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDQyMTYxMSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiA0MjE2MTEsXG4gICAgICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uQXJiaXRydW1PbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGVudW1zXzEuQ3VzdG9tQ2hhaW4uQXJiaXRydW1PbmUsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDQyMTYxLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IDQyMTYxLFxuICAgICAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluUGFyYW1zT3JOYW1lID09PSBlbnVtc18xLkN1c3RvbUNoYWluLnhEYWlDaGFpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZW51bXNfMS5DdXN0b21DaGFpbi54RGFpQ2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiAxMDAsXG4gICAgICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5QYXJhbXNPck5hbWUgPT09IGVudW1zXzEuQ3VzdG9tQ2hhaW4uT3B0aW1pc3RpY0tvdmFuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbnVtc18xLkN1c3RvbUNoYWluLk9wdGltaXN0aWNLb3ZhbixcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogNjksXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtJZDogNjksXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pc20gaGFzIG5vdCBpbXBsZW1lbnRlZCB0aGUgTG9uZG9uIGhhcmRmb3JrIHlldCAodGFyZ2V0aW5nIFExLjIyKVxuICAgICAgICAgICAgICAgIHsgaGFyZGZvcms6IGVudW1zXzEuSGFyZGZvcmsuQmVybGluLCAuLi5vcHRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluUGFyYW1zT3JOYW1lID09PSBlbnVtc18xLkN1c3RvbUNoYWluLk9wdGltaXN0aWNFdGhlcmV1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZW51bXNfMS5DdXN0b21DaGFpbi5PcHRpbWlzdGljRXRoZXJldW0sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEwLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IDEwLFxuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXNtIGhhcyBub3QgaW1wbGVtZW50ZWQgdGhlIExvbmRvbiBoYXJkZm9yayB5ZXQgKHRhcmdldGluZyBRMS4yMilcbiAgICAgICAgICAgICAgICB7IGhhcmRmb3JrOiBlbnVtc18xLkhhcmRmb3JrLkJlcmxpbiwgLi4ub3B0cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VzdG9tIGNoYWluICR7Y2hhaW5QYXJhbXNPck5hbWV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGxvYWQgYW5kIHNldCBjb21tb24gZnJvbSBhIGdldGggZ2VuZXNpcyBqc29uXG4gICAgICogQHBhcmFtIGdlbmVzaXNKc29uIGpzb24gb2YgZ2V0aCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHsgY2hhaW4sIGVpcHMsIGdlbmVzaXNIYXNoLCBoYXJkZm9yaywgbWVyZ2VGb3JrSWRQb3N0TWVyZ2UgfSB0byBmdXJ0aGVyIGNvbmZpZ3VyZSB0aGUgY29tbW9uIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgQ29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIGZyb21HZXRoR2VuZXNpcyhnZW5lc2lzSnNvbiwgeyBjaGFpbiwgZWlwcywgZ2VuZXNpc0hhc2gsIGhhcmRmb3JrLCBtZXJnZUZvcmtJZFBvc3RNZXJnZSB9KSB7XG4gICAgICAgIGNvbnN0IGdlbmVzaXNQYXJhbXMgPSAoMCwgdXRpbHNfMS5wYXJzZUdldGhHZW5lc2lzKShnZW5lc2lzSnNvbiwgY2hhaW4sIG1lcmdlRm9ya0lkUG9zdE1lcmdlKTtcbiAgICAgICAgY29uc3QgY29tbW9uID0gbmV3IENvbW1vbih7XG4gICAgICAgICAgICBjaGFpbjogZ2VuZXNpc1BhcmFtcy5uYW1lID8/ICdjdXN0b20nLFxuICAgICAgICAgICAgY3VzdG9tQ2hhaW5zOiBbZ2VuZXNpc1BhcmFtc10sXG4gICAgICAgICAgICBlaXBzLFxuICAgICAgICAgICAgaGFyZGZvcms6IGhhcmRmb3JrID8/IGdlbmVzaXNQYXJhbXMuaGFyZGZvcmssXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZ2VuZXNpc0hhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tbW9uLnNldEZvcmtIYXNoZXMoZ2VuZXNpc0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGEge0BsaW5rIGNoYWluSWR9IGlzIHN1cHBvcnRlZCBhcyBhIHN0YW5kYXJkIGNoYWluXG4gICAgICogQHBhcmFtIGNoYWluSWQgYmlnaW50IGlkIChgMWApIG9mIGEgc3RhbmRhcmQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemVkQ2hhaW5zID0gdGhpcy5fZ2V0SW5pdGlhbGl6ZWRDaGFpbnMoKTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oaW5pdGlhbGl6ZWRDaGFpbnNbJ25hbWVzJ11bY2hhaW5JZC50b1N0cmluZygpXSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZ2V0Q2hhaW5QYXJhbXMoY2hhaW4sIGN1c3RvbUNoYWlucykge1xuICAgICAgICBjb25zdCBpbml0aWFsaXplZENoYWlucyA9IHRoaXMuX2dldEluaXRpYWxpemVkQ2hhaW5zKGN1c3RvbUNoYWlucyk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhaW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjaGFpbiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGNoYWluID0gY2hhaW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplZENoYWluc1snbmFtZXMnXVtjaGFpbl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gaW5pdGlhbGl6ZWRDaGFpbnNbJ25hbWVzJ11bY2hhaW5dO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsaXplZENoYWluc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhaW4gd2l0aCBJRCAke2NoYWlufSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxpemVkQ2hhaW5zW2NoYWluXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZWRDaGFpbnNbY2hhaW5dO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhaW4gd2l0aCBuYW1lICR7Y2hhaW59IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2hhaW5cbiAgICAgKiBAcGFyYW0gY2hhaW4gU3RyaW5nICgnbWFpbm5ldCcpIG9yIE51bWJlciAoMSkgY2hhaW4gcmVwcmVzZW50YXRpb24uXG4gICAgICogICAgICAgICAgICAgIE9yLCBhIERpY3Rpb25hcnkgb2YgY2hhaW4gcGFyYW1ldGVycyBmb3IgYSBwcml2YXRlIG5ldHdvcmsuXG4gICAgICogQHJldHVybnMgVGhlIGRpY3Rpb25hcnkgd2l0aCBwYXJhbWV0ZXJzIHNldCBhcyBjaGFpblxuICAgICAqL1xuICAgIHNldENoYWluKGNoYWluKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhaW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjaGFpbiA9PT0gJ2JpZ2ludCcgfHwgdHlwZW9mIGNoYWluID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5QYXJhbXMgPSBDb21tb24uX2dldENoYWluUGFyYW1zKGNoYWluLCB0aGlzLl9jdXN0b21DaGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGFpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXN0b21DaGFpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhaW4gbXVzdCBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBiaWdpbnQgd2hlbiBpbml0aWFsaXplZCB3aXRoIGN1c3RvbUNoYWlucyBwYXNzZWQgaW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkID0gWyduZXR3b3JrSWQnLCAnZ2VuZXNpcycsICdoYXJkZm9ya3MnLCAnYm9vdHN0cmFwTm9kZXMnXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgcmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwYXJhbSBpbiBjaGFpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGNoYWluIHBhcmFtZXRlcjogJHtwYXJhbX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGFpblBhcmFtcyA9IGNoYWluO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBpbnB1dCBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhmIG9mIHRoaXMuaGFyZGZvcmtzKCkpIHtcbiAgICAgICAgICAgIGlmIChoZi5ibG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYXJkZm9yayBjYW5ub3QgaGF2ZSB1bmRlZmluZWQgYmxvY2sgbnVtYmVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXJkZm9yayB0byBnZXQgcGFyYW1zIGZvclxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBTdHJpbmcgaWRlbnRpZmllciAoZS5nLiAnYnl6YW50aXVtJykgb3Ige0BsaW5rIEhhcmRmb3JrfSBlbnVtXG4gICAgICovXG4gICAgc2V0SGFyZGZvcmsoaGFyZGZvcmspIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgaGZDaGFuZ2VzIG9mIHRoaXMuSEFSREZPUktfQ0hBTkdFUykge1xuICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1swXSA9PT0gaGFyZGZvcmspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFyZGZvcmsgIT09IGhhcmRmb3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhcmRmb3JrID0gaGFyZGZvcms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGFyZGZvcmtDaGFuZ2VkJywgaGFyZGZvcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGlzdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYXJkZm9yayB3aXRoIG5hbWUgJHtoYXJkZm9ya30gbm90IHN1cHBvcnRlZGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhhcmRmb3JrIGJhc2VkIG9uIHRoZSBibG9jayBudW1iZXIgb3IgYW4gb3B0aW9uYWxcbiAgICAgKiB0b3RhbCBkaWZmaWN1bHR5IChNZXJnZSBIRikgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBBbiBvcHRpb25hbCBURCB0YWtlcyBwcmVjZWRlbmNlIGluIGNhc2UgdGhlIGNvcnJlc3BvbmRpbmcgSEYgYmxvY2tcbiAgICAgKiBpcyBzZXQgdG8gYG51bGxgIG9yIG90aGVyd2lzZSBuZWVkcyB0byBtYXRjaCAoaWYgbm90IGFuIGVycm9yXG4gICAgICogd2lsbCBiZSB0aHJvd24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyXG4gICAgICogQHBhcmFtIHRkIDogdG90YWwgZGlmZmljdWx0eSBvZiB0aGUgcGFyZW50IGJsb2NrIChmb3IgYmxvY2sgaGYpIE9SIG9mIHRoZSBjaGFpbiBsYXRlc3QgKGZvciBjaGFpbiBoZilcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wOiB0aW1lc3RhbXAgaW4gc2Vjb25kcyBhdCB3aGljaCBibG9jayB3YXMvaXMgdG8gYmUgbWludGVkXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIEhGXG4gICAgICovXG4gICAgZ2V0SGFyZGZvcmtCeUJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyLCB0ZCwgdGltZXN0YW1wKSB7XG4gICAgICAgIGJsb2NrTnVtYmVyID0gKDAsIHV0aWxfMS50b1R5cGUpKGJsb2NrTnVtYmVyLCB1dGlsXzEuVHlwZU91dHB1dC5CaWdJbnQpO1xuICAgICAgICB0ZCA9ICgwLCB1dGlsXzEudG9UeXBlKSh0ZCwgdXRpbF8xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICAgICAgdGltZXN0YW1wID0gKDAsIHV0aWxfMS50b1R5cGUpKHRpbWVzdGFtcCwgdXRpbF8xLlR5cGVPdXRwdXQuTnVtYmVyKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBoYXJkZm9ya3Mgd2l0aCBubyBibG9jayBudW1iZXIsIG5vIHR0ZCBvciBubyB0aW1lc3RhbXAgKGkuZS4gdW5hcHBsaWVkIGhhcmRmb3JrcylcbiAgICAgICAgY29uc3QgaGZzID0gdGhpcy5oYXJkZm9ya3MoKS5maWx0ZXIoKGhmKSA9PiBoZi5ibG9jayAhPT0gbnVsbCB8fCAoaGYudHRkICE9PSBudWxsICYmIGhmLnR0ZCAhPT0gdW5kZWZpbmVkKSB8fCBoZi50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG1lcmdlSW5kZXggPSBoZnMuZmluZEluZGV4KChoZikgPT4gaGYudHRkICE9PSBudWxsICYmIGhmLnR0ZCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgZG91YmxlVFRESEYgPSBoZnNcbiAgICAgICAgICAgIC5zbGljZShtZXJnZUluZGV4ICsgMSlcbiAgICAgICAgICAgIC5maW5kSW5kZXgoKGhmKSA9PiBoZi50dGQgIT09IG51bGwgJiYgaGYudHRkICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoZG91YmxlVFRESEYgPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1vcmUgdGhhbiBvbmUgbWVyZ2UgaGFyZGZvcmtzIGZvdW5kIHdpdGggdHRkIHNwZWNpZmllZGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGhhcmRmb3JrIHRoYXQgaGFzIGEgYmxvY2sgbnVtYmVyIGdyZWF0ZXIgdGhhbiBgYmxvY2tOdW1iZXJgXG4gICAgICAgIC8vIChza2lwcyB0aGUgbWVyZ2UgaGFyZGZvcmsgc2luY2UgaXQgY2Fubm90IGhhdmUgYSBibG9jayBudW1iZXIgc3BlY2lmaWVkKS5cbiAgICAgICAgLy8gSWYgdGltZXN0YW1wIGlzIG5vdCBwcm92aWRlZCwgaXQgYWxzbyBza2lwcyB0aW1lc3RhbXBzIGhhcmRmb3JrcyB0byBjb250aW51ZVxuICAgICAgICAvLyBkaXNjb3ZlcmluZy9jaGVja2luZyBudW1iZXIgaGFyZGZvcmtzLlxuICAgICAgICBsZXQgaGZJbmRleCA9IGhmcy5maW5kSW5kZXgoKGhmKSA9PiAoaGYuYmxvY2sgIT09IG51bGwgJiYgaGYuYmxvY2sgPiBibG9ja051bWJlcikgfHxcbiAgICAgICAgICAgICh0aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiBOdW1iZXIoaGYudGltZXN0YW1wKSA+IHRpbWVzdGFtcCkpO1xuICAgICAgICBpZiAoaGZJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGFsbCBoYXJkZm9ya3MgYXBwbHksIHNldCBoZkluZGV4IHRvIHRoZSBsYXN0IG9uZSBhcyB0aGF0J3MgdGhlIGNhbmRpZGF0ZVxuICAgICAgICAgICAgaGZJbmRleCA9IGhmcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGZJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gY2Fubm90IGhhdmUgYSBjYXNlIHdoZXJlIGEgYmxvY2sgbnVtYmVyIGlzIGJlZm9yZSBhbGwgYXBwbGllZCBoYXJkZm9ya3NcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjaGFpbiBoYXMgdG8gc3RhcnQgd2l0aCBhIGhhcmRmb3JrXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBoYXJkZm9yayBhdCBibG9jayAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGltZXN0YW1wIGlzIG5vdCBwcm92aWRlZCwgd2UgbmVlZCB0byByb2xsYmFjayB0byB0aGUgbGFzdCBoZiB3aXRoIGJsb2NrIG9yIHR0ZFxuICAgICAgICBpZiAodGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBCYWNrID0gaGZzXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGhmSW5kZXgpXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5maW5kSW5kZXgoKGhmKSA9PiBoZi5ibG9jayAhPT0gbnVsbCB8fCBoZi50dGQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBoZkluZGV4ID0gaGZJbmRleCAtIHN0ZXBCYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vdmUgaGZJbmRleCBvbmUgYmFjayB0byBhcnJpdmUgYXQgY2FuZGlkYXRlIGhhcmRmb3JrXG4gICAgICAgIGhmSW5kZXggPSBoZkluZGV4IC0gMTtcbiAgICAgICAgLy8gSWYgdGhlIHRpbWVzdGFtcCB3YXMgbm90IHByb3ZpZGVkLCB3ZSBjb3VsZCBoYXZlIHNraXBwZWQgdGltZXN0YW1wIGhhcmRmb3JrcyB0byBsb29rIGZvciBudW1iZXJcbiAgICAgICAgLy8gaGFyZGZvcmtzLiBzbyBpdCB3aWxsIG5vdyBiZSBuZWVkZWQgdG8gcm9sbGJhY2tcbiAgICAgICAgaWYgKGhmc1toZkluZGV4XS5ibG9jayA9PT0gbnVsbCAmJiBoZnNbaGZJbmRleF0udGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIG9uIHRoZSBtZXJnZSBoYXJkZm9yay4gIExldCdzIGNoZWNrIHRoZSBUVERcbiAgICAgICAgICAgIGlmICh0ZCA9PT0gdW5kZWZpbmVkIHx8IHRkID09PSBudWxsIHx8IEJpZ0ludChoZnNbaGZJbmRleF0udHRkKSA+IHRkKSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgdHRkIGdyZWF0ZXIgdGhhbiBjdXJyZW50IHRkIHNvIHdlJ3JlIG9uIGhhcmRmb3JrIGJlZm9yZSBtZXJnZVxuICAgICAgICAgICAgICAgIGhmSW5kZXggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZXJnZUluZGV4ID49IDAgJiYgdGQgIT09IHVuZGVmaW5lZCAmJiB0ZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChoZkluZGV4ID49IG1lcmdlSW5kZXggJiYgQmlnSW50KGhmc1ttZXJnZUluZGV4XS50dGQpID4gdGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01heGltdW0gSEYgZGV0ZXJtaW5lZCBieSB0b3RhbCBkaWZmaWN1bHR5IGlzIGxvd2VyIHRoYW4gdGhlIGJsb2NrIG51bWJlciBIRicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoZkluZGV4IDwgbWVyZ2VJbmRleCAmJiBCaWdJbnQoaGZzW21lcmdlSW5kZXhdLnR0ZCkgPD0gdGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0hGIGRldGVybWluZWQgYnkgYmxvY2sgbnVtYmVyIGlzIGxvd2VyIHRoYW4gdGhlIG1pbmltdW0gdG90YWwgZGlmZmljdWx0eSBIRicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZlN0YXJ0SW5kZXggPSBoZkluZGV4O1xuICAgICAgICAvLyBNb3ZlIHRoZSBoZkluZGV4IHRvIHRoZSBlbmQgb2YgdGhlIGhhcmRmb3JrcyB0aGF0IG1pZ2h0IGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSBibG9jay90aW1lc3RhbXBcbiAgICAgICAgLy8gVGhpcyB3b24ndCBhbnl3YXkgYmUgdGhlIGNhc2Ugd2l0aCBNZXJnZSBoZnNcbiAgICAgICAgZm9yICg7IGhmSW5kZXggPCBoZnMubGVuZ3RoIC0gMTsgaGZJbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBicmVhayBvdXQgaWYgaGZJbmRleCArIDEgaXMgbm90IHNjaGVkdWxlZCBhdCBoZkluZGV4XG4gICAgICAgICAgICBpZiAoaGZzW2hmSW5kZXhdLmJsb2NrICE9PSBoZnNbaGZJbmRleCArIDFdLmJsb2NrIHx8XG4gICAgICAgICAgICAgICAgaGZzW2hmSW5kZXhdLnRpbWVzdGFtcCAhPT0gaGZzW2hmSW5kZXggKyAxXS50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5UaW1lU3RhbXAgPSBoZnNcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaGZTdGFydEluZGV4KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgaGYpID0+IE1hdGgubWF4KE51bWJlcihoZi50aW1lc3RhbXAgPz8gJzAnKSwgYWNjKSwgMCk7XG4gICAgICAgICAgICBpZiAobWluVGltZVN0YW1wID4gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1heGltdW0gSEYgZGV0ZXJtaW5lZCBieSB0aW1lc3RhbXAgaXMgbG93ZXIgdGhhbiB0aGUgYmxvY2sgbnVtYmVyL3R0ZCBIRmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF4VGltZVN0YW1wID0gaGZzXG4gICAgICAgICAgICAgICAgLnNsaWNlKGhmSW5kZXggKyAxKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgaGYpID0+IE1hdGgubWluKE51bWJlcihoZi50aW1lc3RhbXAgPz8gdGltZXN0YW1wKSwgYWNjKSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lU3RhbXAgPCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgTWF4aW11bSBIRiBkZXRlcm1pbmVkIGJ5IGJsb2NrIG51bWJlci90dGQgaXMgbG93ZXIgdGhhbiB0aW1lc3RhbXAgSEZgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXJkZm9yayA9IGhmc1toZkluZGV4XTtcbiAgICAgICAgcmV0dXJuIGhhcmRmb3JrLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgaGFyZGZvcmsgYmFzZWQgb24gdGhlIGJsb2NrIG51bWJlciBvciBhbiBvcHRpb25hbFxuICAgICAqIHRvdGFsIGRpZmZpY3VsdHkgKE1lcmdlIEhGKSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEFuIG9wdGlvbmFsIFREIHRha2VzIHByZWNlZGVuY2UgaW4gY2FzZSB0aGUgY29ycmVzcG9uZGluZyBIRiBibG9ja1xuICAgICAqIGlzIHNldCB0byBgbnVsbGAgb3Igb3RoZXJ3aXNlIG5lZWRzIHRvIG1hdGNoIChpZiBub3QgYW4gZXJyb3JcbiAgICAgKiB3aWxsIGJlIHRocm93bikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXJcbiAgICAgKiBAcGFyYW0gdGRcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIEhGIHNldFxuICAgICAqL1xuICAgIHNldEhhcmRmb3JrQnlCbG9ja051bWJlcihibG9ja051bWJlciwgdGQsIHRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuZ2V0SGFyZGZvcmtCeUJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyLCB0ZCwgdGltZXN0YW1wKTtcbiAgICAgICAgdGhpcy5zZXRIYXJkZm9yayhoYXJkZm9yayk7XG4gICAgICAgIHJldHVybiBoYXJkZm9yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uLCByZXR1cm5zIHRoZSBwYXJhbXMgZm9yIHRoZSBnaXZlbiBoYXJkZm9yayBmb3IgdGhlIGNoYWluIHNldFxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lXG4gICAgICogQHJldHVybnMgRGljdGlvbmFyeSB3aXRoIGhhcmRmb3JrIHBhcmFtcyBvciBudWxsIGlmIGhhcmRmb3JrIG5vdCBvbiBjaGFpblxuICAgICAqL1xuICAgIF9nZXRIYXJkZm9yayhoYXJkZm9yaykge1xuICAgICAgICBjb25zdCBoZnMgPSB0aGlzLmhhcmRmb3JrcygpO1xuICAgICAgICBmb3IgKGNvbnN0IGhmIG9mIGhmcykge1xuICAgICAgICAgICAgaWYgKGhmWyduYW1lJ10gPT09IGhhcmRmb3JrKVxuICAgICAgICAgICAgICAgIHJldHVybiBoZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIEVJUHNcbiAgICAgKiBAcGFyYW0gZWlwc1xuICAgICAqL1xuICAgIHNldEVJUHMoZWlwcyA9IFtdKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWlwIG9mIGVpcHMpIHtcbiAgICAgICAgICAgIGlmICghKGVpcCBpbiBlaXBzXzEuRUlQcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZWlwfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5IRiA9IHRoaXMuZ3RlSGFyZGZvcmsoZWlwc18xLkVJUHNbZWlwXVsnbWluaW11bUhhcmRmb3JrJ10pO1xuICAgICAgICAgICAgaWYgKCFtaW5IRikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlaXB9IGNhbm5vdCBiZSBhY3RpdmF0ZWQgb24gaGFyZGZvcmsgJHt0aGlzLmhhcmRmb3JrKCl9LCBtaW5pbXVtSGFyZGZvcms6ICR7bWluSEZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWlwc18xLkVJUHNbZWlwXS5yZXF1aXJlZEVJUHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBlaXBzXzEuRUlQc1tlaXBdLnJlcXVpcmVkRUlQcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShlaXBzLmluY2x1ZGVzKGVsZW0pIHx8IHRoaXMuaXNBY3RpdmF0ZWRFSVAoZWxlbSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZWlwfSByZXF1aXJlcyBFSVAgJHtlbGVtfSwgYnV0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgRUlQIGxpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9laXBzID0gZWlwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcmFtZXRlciBmb3IgdGhlIGN1cnJlbnQgY2hhaW4gc2V0dXBcbiAgICAgKlxuICAgICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgcHJlc2VudCBpbiBhbiBFSVAsIHRoZSBFSVAgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICogT3RoZXJ3aXNlIHRoZSBwYXJhbWV0ZXIgaWYgdGFrZW4gZnJvbSB0aGUgbGF0ZXN0IGFwcGxpZWQgSEYgd2l0aFxuICAgICAqIGEgY2hhbmdlIG9uIHRoZSByZXNwZWN0aXZlIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b3BpYyBQYXJhbWV0ZXIgdG9waWMgKCdnYXNDb25maWcnLCAnZ2FzUHJpY2VzJywgJ3ZtJywgJ3BvdycpXG4gICAgICogQHBhcmFtIG5hbWUgUGFyYW1ldGVyIG5hbWUgKGUuZy4gJ21pbkdhc0xpbWl0JyBmb3IgJ2dhc0NvbmZpZycgdG9waWMpXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHJlcXVlc3RlZCBvciBgQmlnSW50KDApYCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBwYXJhbSh0b3BpYywgbmFtZSkge1xuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciB0aGUgY2FzZSB0aGF0IGRpZmZlcmVudCBhY3RpdmUgRUlQc1xuICAgICAgICAvLyBjYW4gY2hhbmdlIHRoZSBzYW1lIHBhcmFtZXRlclxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgZWlwIG9mIHRoaXMuX2VpcHMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJhbUJ5RUlQKHRvcGljLCBuYW1lLCBlaXApO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtQnlIYXJkZm9yayh0b3BpYywgbmFtZSwgdGhpcy5faGFyZGZvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXIgY29ycmVzcG9uZGluZyB0byBhIGhhcmRmb3JrXG4gICAgICogQHBhcmFtIHRvcGljIFBhcmFtZXRlciB0b3BpYyAoJ2dhc0NvbmZpZycsICdnYXNQcmljZXMnLCAndm0nLCAncG93JylcbiAgICAgKiBAcGFyYW0gbmFtZSBQYXJhbWV0ZXIgbmFtZSAoZS5nLiAnbWluR2FzTGltaXQnIGZvciAnZ2FzQ29uZmlnJyB0b3BpYylcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZVxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSByZXF1ZXN0ZWQgb3IgYEJpZ0ludCgwKWAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgcGFyYW1CeUhhcmRmb3JrKHRvcGljLCBuYW1lLCBoYXJkZm9yaykge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGhmQ2hhbmdlcyBvZiB0aGlzLkhBUkRGT1JLX0NIQU5HRVMpIHtcbiAgICAgICAgICAgIC8vIEVJUC1yZWZlcmVuY2luZyBIRiBmaWxlIChlLmcuIGJlcmxpbi5qc29uKVxuICAgICAgICAgICAgaWYgKCdlaXBzJyBpbiBoZkNoYW5nZXNbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZkVJUHMgPSBoZkNoYW5nZXNbMV1bJ2VpcHMnXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVpcCBvZiBoZkVJUHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVFSVAgPSB0aGlzLnBhcmFtQnlFSVAodG9waWMsIG5hbWUsIGVpcCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlRUlQID09PSAnYmlnaW50JyA/IHZhbHVlRUlQIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcmFtZXRlci1pbmxpbmluZyBIRiBmaWxlIChlLmcuIGlzdGFuYnVsLmpzb24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGZDaGFuZ2VzWzFdW3RvcGljXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9waWMgJHt0b3BpY30gbm90IGRlZmluZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1sxXVt0b3BpY11bbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhmQ2hhbmdlc1sxXVt0b3BpY11bbmFtZV0udjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGZDaGFuZ2VzWzBdID09PSBoYXJkZm9yaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlID8/IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFyYW1ldGVyIGNvcnJlc3BvbmRpbmcgdG8gYW4gRUlQXG4gICAgICogQHBhcmFtIHRvcGljIFBhcmFtZXRlciB0b3BpYyAoJ2dhc0NvbmZpZycsICdnYXNQcmljZXMnLCAndm0nLCAncG93JylcbiAgICAgKiBAcGFyYW0gbmFtZSBQYXJhbWV0ZXIgbmFtZSAoZS5nLiAnbWluR2FzTGltaXQnIGZvciAnZ2FzQ29uZmlnJyB0b3BpYylcbiAgICAgKiBAcGFyYW0gZWlwIE51bWJlciBvZiB0aGUgRUlQXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHJlcXVlc3RlZCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBwYXJhbUJ5RUlQKHRvcGljLCBuYW1lLCBlaXApIHtcbiAgICAgICAgaWYgKCEoZWlwIGluIGVpcHNfMS5FSVBzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2VpcH0gbm90IHN1cHBvcnRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVpcFBhcmFtcyA9IGVpcHNfMS5FSVBzW2VpcF07XG4gICAgICAgIGlmICghKHRvcGljIGluIGVpcFBhcmFtcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9waWMgJHt0b3BpY30gbm90IGRlZmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWlwUGFyYW1zW3RvcGljXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWlwUGFyYW1zW3RvcGljXVtuYW1lXS52O1xuICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcmFtZXRlciBmb3IgdGhlIGhhcmRmb3JrIGFjdGl2ZSBvbiBibG9jayBudW1iZXIgb3JcbiAgICAgKiBvcHRpb25hbCBwcm92aWRlZCB0b3RhbCBkaWZmaWN1bHR5IChNZXJnZSBIRilcbiAgICAgKiBAcGFyYW0gdG9waWMgUGFyYW1ldGVyIHRvcGljXG4gICAgICogQHBhcmFtIG5hbWUgUGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXIgQmxvY2sgbnVtYmVyXG4gICAgICogQHBhcmFtIHRkIFRvdGFsIGRpZmZpY3VsdHlcbiAgICAgKiAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSByZXF1ZXN0ZWQgb3IgYEJpZ0ludCgwKWAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgcGFyYW1CeUJsb2NrKHRvcGljLCBuYW1lLCBibG9ja051bWJlciwgdGQsIHRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuZ2V0SGFyZGZvcmtCeUJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyLCB0ZCwgdGltZXN0YW1wKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1CeUhhcmRmb3JrKHRvcGljLCBuYW1lLCBoYXJkZm9yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbiBFSVAgaXMgYWN0aXZhdGVkIGJ5IGVpdGhlciBiZWluZyBpbmNsdWRlZCBpbiB0aGUgRUlQc1xuICAgICAqIG1hbnVhbGx5IHBhc3NlZCBpbiB3aXRoIHRoZSB7QGxpbmsgQ29tbW9uT3B0cy5laXBzfSBvciBpbiBhXG4gICAgICogaGFyZGZvcmsgY3VycmVudGx5IGJlaW5nIGFjdGl2ZVxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2Qgb25seSB3b3JrcyBmb3IgRUlQcyBiZWluZyBzdXBwb3J0ZWRcbiAgICAgKiBieSB0aGUge0BsaW5rIENvbW1vbk9wdHMuZWlwc30gY29uc3RydWN0b3Igb3B0aW9uXG4gICAgICogQHBhcmFtIGVpcFxuICAgICAqL1xuICAgIGlzQWN0aXZhdGVkRUlQKGVpcCkge1xuICAgICAgICBpZiAodGhpcy5laXBzKCkuaW5jbHVkZXMoZWlwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBoZkNoYW5nZXMgb2YgdGhpcy5IQVJERk9SS19DSEFOR0VTKSB7XG4gICAgICAgICAgICBjb25zdCBoZiA9IGhmQ2hhbmdlc1sxXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmd0ZUhhcmRmb3JrKGhmWyduYW1lJ10pICYmICdlaXBzJyBpbiBoZikge1xuICAgICAgICAgICAgICAgIGlmIChoZlsnZWlwcyddLmluY2x1ZGVzKGVpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHNldCBvciBwcm92aWRlZCBoYXJkZm9yayBpcyBhY3RpdmUgb24gYmxvY2sgbnVtYmVyXG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWUgb3IgbnVsbCAoZm9yIEhGIHNldClcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIEhGIGlzIGFjdGl2ZSBvbiBibG9jayBudW1iZXJcbiAgICAgKi9cbiAgICBoYXJkZm9ya0lzQWN0aXZlT25CbG9jayhoYXJkZm9yaywgYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgYmxvY2tOdW1iZXIgPSAoMCwgdXRpbF8xLnRvVHlwZSkoYmxvY2tOdW1iZXIsIHV0aWxfMS5UeXBlT3V0cHV0LkJpZ0ludCk7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGFyZGZvcmspO1xuICAgICAgICBpZiAodHlwZW9mIGhmQmxvY2sgPT09ICdiaWdpbnQnICYmIGhmQmxvY2sgIT09IEJpZ0ludCgwKSAmJiBibG9ja051bWJlciA+PSBoZkJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIHRvIGhhcmRmb3JrSXNBY3RpdmVPbkJsb2NrIHdoZW4gaGFyZGZvcmsgaXMgc2V0XG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBIRiBpcyBhY3RpdmUgb24gYmxvY2sgbnVtYmVyXG4gICAgICovXG4gICAgYWN0aXZlT25CbG9jayhibG9ja051bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0lzQWN0aXZlT25CbG9jayhudWxsLCBibG9ja051bWJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcXVlbmNlIGJhc2VkIGNoZWNrIGlmIGdpdmVuIG9yIHNldCBIRjEgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIEhGMlxuICAgICAqIEBwYXJhbSBoYXJkZm9yazEgSGFyZGZvcmsgbmFtZSBvciBudWxsIChpZiBzZXQpXG4gICAgICogQHBhcmFtIGhhcmRmb3JrMiBIYXJkZm9yayBuYW1lXG4gICAgICogQHBhcmFtIG9wdHMgSGFyZGZvcmsgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgSEYxIGd0ZSBIRjJcbiAgICAgKi9cbiAgICBoYXJkZm9ya0d0ZUhhcmRmb3JrKGhhcmRmb3JrMSwgaGFyZGZvcmsyKSB7XG4gICAgICAgIGhhcmRmb3JrMSA9IGhhcmRmb3JrMSA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgY29uc3QgaGFyZGZvcmtzID0gdGhpcy5oYXJkZm9ya3MoKTtcbiAgICAgICAgbGV0IHBvc0hmMSA9IC0xLCBwb3NIZjIgPSAtMTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBoZiBvZiBoYXJkZm9ya3MpIHtcbiAgICAgICAgICAgIGlmIChoZlsnbmFtZSddID09PSBoYXJkZm9yazEpXG4gICAgICAgICAgICAgICAgcG9zSGYxID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoaGZbJ25hbWUnXSA9PT0gaGFyZGZvcmsyKVxuICAgICAgICAgICAgICAgIHBvc0hmMiA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zSGYxID49IHBvc0hmMiAmJiBwb3NIZjIgIT09IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyB0byBoYXJkZm9ya0d0ZUhhcmRmb3JrIHdoZW4gaGFyZGZvcmsgaXMgc2V0XG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGhhcmRmb3JrIHNldCBpcyBncmVhdGVyIHRoYW4gaGFyZGZvcmsgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBndGVIYXJkZm9yayhoYXJkZm9yaykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0d0ZUhhcmRmb3JrKG51bGwsIGhhcmRmb3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGFyZGZvcmsgY2hhbmdlIGJsb2NrIGZvciBoYXJkZm9yayBwcm92aWRlZCBvciBzZXRcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgQmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgdW5zY2hlZHVsZWRcbiAgICAgKi9cbiAgICBoYXJkZm9ya0Jsb2NrKGhhcmRmb3JrKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5fZ2V0SGFyZGZvcmsoaGFyZGZvcmspPy5bJ2Jsb2NrJ107XG4gICAgICAgIGlmIChibG9jayA9PT0gdW5kZWZpbmVkIHx8IGJsb2NrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KGJsb2NrKTtcbiAgICB9XG4gICAgaGFyZGZvcmtUaW1lc3RhbXAoaGFyZGZvcmspIHtcbiAgICAgICAgaGFyZGZvcmsgPSBoYXJkZm9yayA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gdGhpcy5fZ2V0SGFyZGZvcmsoaGFyZGZvcmspPy5bJ3RpbWVzdGFtcCddO1xuICAgICAgICBpZiAodGltZXN0YW1wID09PSB1bmRlZmluZWQgfHwgdGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhhcmRmb3JrIGNoYW5nZSBibG9jayBmb3IgZWlwXG4gICAgICogQHBhcmFtIGVpcCBFSVAgbnVtYmVyXG4gICAgICogQHJldHVybnMgQmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgdW5zY2hlZHVsZWRcbiAgICAgKi9cbiAgICBlaXBCbG9jayhlaXApIHtcbiAgICAgICAgZm9yIChjb25zdCBoZkNoYW5nZXMgb2YgdGhpcy5IQVJERk9SS19DSEFOR0VTKSB7XG4gICAgICAgICAgICBjb25zdCBoZiA9IGhmQ2hhbmdlc1sxXTtcbiAgICAgICAgICAgIGlmICgnZWlwcycgaW4gaGYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgaWYgKGhmWydlaXBzJ10uaW5jbHVkZXMoZWlwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0Jsb2NrKGhmQ2hhbmdlc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoYXJkZm9yayBjaGFuZ2UgdG90YWwgZGlmZmljdWx0eSAoTWVyZ2UgSEYpIGZvciBoYXJkZm9yayBwcm92aWRlZCBvciBzZXRcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgVG90YWwgZGlmZmljdWx0eSBvciBudWxsIGlmIG5vIHNldFxuICAgICAqL1xuICAgIGhhcmRmb3JrVFREKGhhcmRmb3JrKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IHR0ZCA9IHRoaXMuX2dldEhhcmRmb3JrKGhhcmRmb3JrKT8uWyd0dGQnXTtcbiAgICAgICAgaWYgKHR0ZCA9PT0gdW5kZWZpbmVkIHx8IHR0ZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0dGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGJsb2NrIG51bWJlciBwcm92aWRlZCBpcyB0aGUgaGFyZGZvcmsgKGdpdmVuIG9yIHNldCkgY2hhbmdlIGJsb2NrXG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyIE51bWJlciBvZiB0aGUgYmxvY2sgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBibG9ja051bWJlciBpcyBIRiBibG9ja1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgaXNIYXJkZm9ya0Jsb2NrKGJsb2NrTnVtYmVyLCBoYXJkZm9yaykge1xuICAgICAgICBibG9ja051bWJlciA9ICgwLCB1dGlsXzEudG9UeXBlKShibG9ja051bWJlciwgdXRpbF8xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICAgICAgaGFyZGZvcmsgPSBoYXJkZm9yayA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGFyZGZvcmspO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGJsb2NrID09PSAnYmlnaW50JyAmJiBibG9jayAhPT0gQmlnSW50KDApID8gYmxvY2sgPT09IGJsb2NrTnVtYmVyIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYW5nZSBibG9jayBmb3IgdGhlIG5leHQgaGFyZGZvcmsgYWZ0ZXIgdGhlIGhhcmRmb3JrIHByb3ZpZGVkIG9yIHNldFxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lLCBvcHRpb25hbCBpZiBIRiBzZXRcbiAgICAgKiBAcmV0dXJucyBCbG9jayB0aW1lc3RhbXAsIG51bWJlciBvciBudWxsIGlmIG5vdCBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBuZXh0SGFyZGZvcmtCbG9ja09yVGltZXN0YW1wKGhhcmRmb3JrKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGhmcyA9IHRoaXMuaGFyZGZvcmtzKCk7XG4gICAgICAgIGxldCBoZkluZGV4ID0gaGZzLmZpbmRJbmRleCgoaGYpID0+IGhmLm5hbWUgPT09IGhhcmRmb3JrKTtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaGFyZGZvcmsgaXMgbWVyZ2UsIGdvIG9uZSBiZWhpbmQgYXMgbWVyZ2UgaGYgaXMgbm90IHBhcnQgb2YgdGhlc2VcbiAgICAgICAgLy8gY2FsY3MgZXZlbiBpZiB0aGUgbWVyZ2UgaGYgYmxvY2sgaXMgc2V0XG4gICAgICAgIGlmIChoYXJkZm9yayA9PT0gZW51bXNfMS5IYXJkZm9yay5NZXJnZSkge1xuICAgICAgICAgICAgaGZJbmRleCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhcmRmb3JrIG5vdCBmb3VuZFxuICAgICAgICBpZiAoaGZJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJySGZUaW1lT3JCbG9jayA9IGhmc1toZkluZGV4XS50aW1lc3RhbXAgPz8gaGZzW2hmSW5kZXhdLmJsb2NrO1xuICAgICAgICBjdXJySGZUaW1lT3JCbG9jayA9XG4gICAgICAgICAgICBjdXJySGZUaW1lT3JCbG9jayAhPT0gbnVsbCAmJiBjdXJySGZUaW1lT3JCbG9jayAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIoY3VyckhmVGltZU9yQmxvY2spXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBuZXh0SGYgPSBoZnMuc2xpY2UoaGZJbmRleCArIDEpLmZpbmQoKGhmKSA9PiB7XG4gICAgICAgICAgICBsZXQgaGZUaW1lT3JCbG9jayA9IGhmLnRpbWVzdGFtcCA/PyBoZi5ibG9jaztcbiAgICAgICAgICAgIGhmVGltZU9yQmxvY2sgPVxuICAgICAgICAgICAgICAgIGhmVGltZU9yQmxvY2sgIT09IG51bGwgJiYgaGZUaW1lT3JCbG9jayAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKGhmVGltZU9yQmxvY2spIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiAoaGYubmFtZSAhPT0gZW51bXNfMS5IYXJkZm9yay5NZXJnZSAmJlxuICAgICAgICAgICAgICAgIGhmVGltZU9yQmxvY2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBoZlRpbWVPckJsb2NrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBoZlRpbWVPckJsb2NrICE9PSBjdXJySGZUaW1lT3JCbG9jayk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiBubyBuZXh0IGhmIGZvdW5kIHdpdGggdmFsaWQgYmxvY2sgb3IgdGltZXN0YW1wIHJldHVybiBudWxsXG4gICAgICAgIGlmIChuZXh0SGYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEhmQmxvY2sgPSBuZXh0SGYudGltZXN0YW1wID8/IG5leHRIZi5ibG9jaztcbiAgICAgICAgaWYgKG5leHRIZkJsb2NrID09PSBudWxsIHx8IG5leHRIZkJsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQobmV4dEhmQmxvY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGFuZ2UgYmxvY2sgZm9yIHRoZSBuZXh0IGhhcmRmb3JrIGFmdGVyIHRoZSBoYXJkZm9yayBwcm92aWRlZCBvciBzZXRcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgQmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgbmV4dEhhcmRmb3JrQmxvY2soaGFyZGZvcmspIHtcbiAgICAgICAgaGFyZGZvcmsgPSBoYXJkZm9yayA/PyB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgbGV0IGhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGFyZGZvcmspO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbWVyZ2UgaGFyZGZvcmsgd2l0aCBibG9jayBub3Qgc2V0LCB0aGVuIHdlIGZhbGxiYWNrIHRvIHByZXZpb3VzIGhhcmRmb3JrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIG5leHRIYXJkZm9ya0Jsb2NrXG4gICAgICAgIGlmIChoZkJsb2NrID09PSBudWxsICYmIGhhcmRmb3JrID09PSBlbnVtc18xLkhhcmRmb3JrLk1lcmdlKSB7XG4gICAgICAgICAgICBjb25zdCBoZnMgPSB0aGlzLmhhcmRmb3JrcygpO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VJbmRleCA9IGhmcy5maW5kSW5kZXgoKGhmKSA9PiBoZi50dGQgIT09IG51bGwgJiYgaGYudHRkICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1lcmdlIGhhcmRmb3JrIHNob3VsZCBoYXZlIGJlZW4gZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrQmxvY2soaGZzW21lcmdlSW5kZXggLSAxXS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGZCbG9jayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV4dCBmb3JrIGJsb2NrIG51bWJlciBvciBudWxsIGlmIG5vbmUgYXZhaWxhYmxlXG4gICAgICAgIC8vIExvZ2ljOiBpZiBhY2N1bXVsYXRvciBpcyBzdGlsbCBudWxsIGFuZCBvbiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZlxuICAgICAgICAvLyBhIGJsb2NrIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBoZkJsb2NrIHNldCB0aGUgYWNjdW11bGF0b3IsXG4gICAgICAgIC8vIHBhc3Mgb24gdGhlIGFjY3VtdWxhdG9yIGFzIHRoZSBmaW5hbCByZXN1bHQgZnJvbSB0aGlzIHRpbWUgb25cbiAgICAgICAgY29uc3QgbmV4dEhmQmxvY2sgPSB0aGlzLmhhcmRmb3JrcygpLnJlZHVjZSgoYWNjLCBoZikgPT4ge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBpZ25vcmUgdGhlIG1lcmdlIGJsb2NrIGluIG91ciBuZXh0IGhhcmRmb3JrIGNhbGNcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gQmlnSW50KGhmLmJsb2NrID09PSBudWxsIHx8IChoZi50dGQgIT09IHVuZGVmaW5lZCAmJiBoZi50dGQgIT09IG51bGwpID8gMCA6IGhmLmJsb2NrKTtcbiAgICAgICAgICAgIC8vIFR5cGVzY3JpcHQgY2FuJ3Qgc2VlbSB0byBmb2xsb3cgdGhhdCB0aGUgaGZCbG9jayBpcyBub3QgbnVsbCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICByZXR1cm4gYmxvY2sgPiBoZkJsb2NrICYmIGFjYyA9PT0gbnVsbCA/IGJsb2NrIDogYWNjO1xuICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5leHRIZkJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGJsb2NrIG51bWJlciBwcm92aWRlZCBpcyB0aGUgaGFyZGZvcmsgY2hhbmdlIGJsb2NrIGZvbGxvd2luZyB0aGUgaGFyZGZvcmsgZ2l2ZW4gb3Igc2V0XG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyIE51bWJlciBvZiB0aGUgYmxvY2sgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBibG9ja051bWJlciBpcyBIRiBibG9ja1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgaXNOZXh0SGFyZGZvcmtCbG9jayhibG9ja051bWJlciwgaGFyZGZvcmspIHtcbiAgICAgICAgYmxvY2tOdW1iZXIgPSAoMCwgdXRpbF8xLnRvVHlwZSkoYmxvY2tOdW1iZXIsIHV0aWxfMS5UeXBlT3V0cHV0LkJpZ0ludCk7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IG5leHRIYXJkZm9ya0Jsb2NrID0gdGhpcy5uZXh0SGFyZGZvcmtCbG9jayhoYXJkZm9yayk7XG4gICAgICAgIHJldHVybiBuZXh0SGFyZGZvcmtCbG9jayA9PT0gbnVsbCA/IGZhbHNlIDogbmV4dEhhcmRmb3JrQmxvY2sgPT09IGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGEgZm9yayBoYXNoXG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcGFyYW0gZ2VuZXNpc0hhc2ggR2VuZXNpcyBibG9jayBoYXNoIG9mIHRoZSBjaGFpblxuICAgICAqIEByZXR1cm5zIEZvcmsgaGFzaCBhcyBoZXggc3RyaW5nXG4gICAgICovXG4gICAgX2NhbGNGb3JrSGFzaChoYXJkZm9yaywgZ2VuZXNpc0hhc2gpIHtcbiAgICAgICAgbGV0IGhmQnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICBsZXQgcHJldkJsb2NrT3JUaW1lID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBoZiBvZiB0aGlzLmhhcmRmb3JrcygpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrLCB0aW1lc3RhbXAsIG5hbWUgfSA9IGhmO1xuICAgICAgICAgICAgLy8gVGltZXN0YW1wIHRvIGJlIHVzZWQgZm9yIHRpbWVzdGFtcCBiYXNlZCBoZnMgZXZlbiBpZiB3ZSBtYXkgYnVuZGxlXG4gICAgICAgICAgICAvLyBibG9jayBudW1iZXIgd2l0aCB0aGVtIHJldHJvc3BlY3RpdmVseVxuICAgICAgICAgICAgbGV0IGJsb2NrT3JUaW1lID0gdGltZXN0YW1wID8/IGJsb2NrO1xuICAgICAgICAgICAgYmxvY2tPclRpbWUgPSBibG9ja09yVGltZSAhPT0gbnVsbCA/IE51bWJlcihibG9ja09yVGltZSkgOiBudWxsO1xuICAgICAgICAgICAgLy8gU2tpcCBmb3IgY2hhaW5zdGFydCAoMCksIG5vdCBhcHBsaWVkIEhGcyAobnVsbCkgYW5kXG4gICAgICAgICAgICAvLyB3aGVuIGFscmVhZHkgYXBwbGllZCBvbiBzYW1lIGJsb2NrT3JUaW1lIEhGc1xuICAgICAgICAgICAgLy8gYW5kIG9uIHRoZSBtZXJnZSBzaW5jZSBmb3JraGFzaCBkb2Vzbid0IGNoYW5nZSBvbiBtZXJnZSBoZlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBibG9ja09yVGltZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBibG9ja09yVGltZSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgIGJsb2NrT3JUaW1lICE9PSBwcmV2QmxvY2tPclRpbWUgJiZcbiAgICAgICAgICAgICAgICBuYW1lICE9PSBlbnVtc18xLkhhcmRmb3JrLk1lcmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGZCbG9ja0J1ZmZlciA9IEJ1ZmZlci5mcm9tKGJsb2NrT3JUaW1lLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgxNiwgJzAnKSwgJ2hleCcpO1xuICAgICAgICAgICAgICAgIGhmQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbaGZCdWZmZXIsIGhmQmxvY2tCdWZmZXJdKTtcbiAgICAgICAgICAgICAgICBwcmV2QmxvY2tPclRpbWUgPSBibG9ja09yVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZi5uYW1lID09PSBoYXJkZm9yaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2dlbmVzaXNIYXNoLCBoZkJ1ZmZlcl0pO1xuICAgICAgICAvLyBDUkMzMiBkZWxpdmVycyByZXN1bHQgYXMgc2lnbmVkIChuZWdhdGl2ZSkgMzItYml0IGludGVnZXIsXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gaGV4IHN0cmluZ1xuICAgICAgICBjb25zdCBmb3JraGFzaCA9ICgwLCB1dGlsXzEuaW50VG9CdWZmZXIpKCgwLCBjcmNfMzJfMS5idWYpKGlucHV0QnVmZmVyKSA+Pj4gMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICByZXR1cm4gYDB4JHtmb3JraGFzaH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV0aC82NCBjb21wbGlhbnQgZm9yayBoYXNoIChFSVAtMjEyNClcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHBhcmFtIGdlbmVzaXNIYXNoIEdlbmVzaXMgYmxvY2sgaGFzaCBvZiB0aGUgY2hhaW4sIG9wdGlvbmFsIGlmIGFscmVhZHkgZGVmaW5lZCBhbmQgbm90IG5lZWRlZCB0byBiZSBjYWxjdWxhdGVkXG4gICAgICovXG4gICAgZm9ya0hhc2goaGFyZGZvcmssIGdlbmVzaXNIYXNoKSB7XG4gICAgICAgIGhhcmRmb3JrID0gaGFyZGZvcmsgPz8gdGhpcy5faGFyZGZvcms7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9nZXRIYXJkZm9yayhoYXJkZm9yayk7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8XG4gICAgICAgICAgICAoZGF0YT8uYmxvY2sgPT09IG51bGwgJiYgZGF0YT8udGltZXN0YW1wID09PSB1bmRlZmluZWQgJiYgZGF0YT8udHRkID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnTm8gZm9yayBoYXNoIGNhbGN1bGF0aW9uIHBvc3NpYmxlIGZvciBmdXR1cmUgaGFyZGZvcmsnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGE/LmZvcmtIYXNoICE9PSBudWxsICYmIGRhdGE/LmZvcmtIYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmZvcmtIYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2VuZXNpc0hhc2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVzaXNIYXNoIHJlcXVpcmVkIGZvciBmb3JrSGFzaCBjYWxjdWxhdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0ZvcmtIYXNoKGhhcmRmb3JrLCBnZW5lc2lzSGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmtIYXNoIEZvcmsgaGFzaCBhcyBhIGhleCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBBcnJheSB3aXRoIGhhcmRmb3JrIGRhdGEgKG5hbWUsIGJsb2NrLCBmb3JrSGFzaClcbiAgICAgKi9cbiAgICBoYXJkZm9ya0ZvckZvcmtIYXNoKGZvcmtIYXNoKSB7XG4gICAgICAgIGNvbnN0IHJlc0FycmF5ID0gdGhpcy5oYXJkZm9ya3MoKS5maWx0ZXIoKGhmKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaGYuZm9ya0hhc2ggPT09IGZvcmtIYXNoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc0FycmF5Lmxlbmd0aCA+PSAxID8gcmVzQXJyYXlbcmVzQXJyYXkubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFueSBtaXNzaW5nIGZvcmtIYXNoZXMgb24gdGhlIHBhc3NlZC1pbiB7QGxpbmsgQ29tbW9ufSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjb21tb24gVGhlIHtAbGluayBDb21tb259IHRvIHNldCB0aGUgZm9ya0hhc2hlcyBmb3JcbiAgICAgKiBAcGFyYW0gZ2VuZXNpc0hhc2ggVGhlIGdlbmVzaXMgYmxvY2sgaGFzaFxuICAgICAqL1xuICAgIHNldEZvcmtIYXNoZXMoZ2VuZXNpc0hhc2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBoZiBvZiB0aGlzLmhhcmRmb3JrcygpKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja09yVGltZSA9IGhmLnRpbWVzdGFtcCA/PyBoZi5ibG9jaztcbiAgICAgICAgICAgIGlmICgoaGYuZm9ya0hhc2ggPT09IG51bGwgfHwgaGYuZm9ya0hhc2ggPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICAgICAoKGJsb2NrT3JUaW1lICE9PSBudWxsICYmIGJsb2NrT3JUaW1lICE9PSB1bmRlZmluZWQpIHx8IHR5cGVvZiBoZi50dGQgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIGhmLmZvcmtIYXNoID0gdGhpcy5mb3JrSGFzaChoZi5uYW1lLCBnZW5lc2lzSGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgR2VuZXNpcyBwYXJhbWV0ZXJzIG9mIHRoZSBjdXJyZW50IGNoYWluXG4gICAgICogQHJldHVybnMgR2VuZXNpcyBkaWN0aW9uYXJ5XG4gICAgICovXG4gICAgZ2VuZXNpcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zLmdlbmVzaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhhcmRmb3JrcyBmb3IgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgd2l0aCBhcnJheXMgb2YgaGFyZGZvcmtzXG4gICAgICovXG4gICAgaGFyZGZvcmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXMuaGFyZGZvcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJvb3RzdHJhcCBub2RlcyBmb3IgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyB7RGljdGlvbmFyeX0gRGljdCB3aXRoIGJvb3RzdHJhcCBub2Rlc1xuICAgICAqL1xuICAgIGJvb3RzdHJhcE5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXMuYm9vdHN0cmFwTm9kZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgRE5TIG5ldHdvcmtzIGZvciB0aGUgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gQXJyYXkgb2YgRE5TIEVOUiB1cmxzXG4gICAgICovXG4gICAgZG5zTmV0d29ya3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpblBhcmFtcy5kbnNOZXR3b3JrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGFyZGZvcmsgc2V0XG4gICAgICogQHJldHVybnMgSGFyZGZvcmsgbmFtZVxuICAgICAqL1xuICAgIGhhcmRmb3JrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFyZGZvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElkIG9mIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyBjaGFpbiBJZFxuICAgICAqL1xuICAgIGNoYWluSWQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5fY2hhaW5QYXJhbXMuY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIGNoYWluIG5hbWUgKGxvd2VyIGNhc2UpXG4gICAgICovXG4gICAgY2hhaW5OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSWQgb2YgY3VycmVudCBuZXR3b3JrXG4gICAgICogQHJldHVybnMgbmV0d29yayBJZFxuICAgICAqL1xuICAgIG5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLl9jaGFpblBhcmFtcy5uZXR3b3JrSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgRUlQc1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgRUlQc1xuICAgICAqL1xuICAgIGVpcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9laXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25zZW5zdXMgdHlwZSBvZiB0aGUgbmV0d29ya1xuICAgICAqIFBvc3NpYmxlIHZhbHVlczogXCJwb3dcInxcInBvYVwifFwicG9zXCJcbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgdmFsdWUgY2FuIHVwZGF0ZSBhbG9uZyBhIEhhcmRmb3JrLlxuICAgICAqL1xuICAgIGNvbnNlbnN1c1R5cGUoKSB7XG4gICAgICAgIGNvbnN0IGhhcmRmb3JrID0gdGhpcy5oYXJkZm9yaygpO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgaGZDaGFuZ2VzIG9mIHRoaXMuSEFSREZPUktfQ0hBTkdFUykge1xuICAgICAgICAgICAgaWYgKCdjb25zZW5zdXMnIGluIGhmQ2hhbmdlc1sxXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaGZDaGFuZ2VzWzFdWydjb25zZW5zdXMnXVsndHlwZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1swXSA9PT0gaGFyZGZvcmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8/IHRoaXMuX2NoYWluUGFyYW1zWydjb25zZW5zdXMnXVsndHlwZSddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jcmV0ZSBjb25zZW5zdXMgaW1wbGVtZW50YXRpb25cbiAgICAgKiBhbGdvcml0aG0gb3IgcHJvdG9jb2wgZm9yIHRoZSBuZXR3b3JrXG4gICAgICogZS5nLiBcImV0aGFzaFwiIGZvciBcInBvd1wiIGNvbnNlbnN1cyB0eXBlLFxuICAgICAqIFwiY2xpcXVlXCIgZm9yIFwicG9hXCIgY29uc2Vuc3VzIHR5cGUgb3JcbiAgICAgKiBcImNhc3BlclwiIGZvciBcInBvc1wiIGNvbnNlbnN1cyB0eXBlLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyB2YWx1ZSBjYW4gdXBkYXRlIGFsb25nIGEgSGFyZGZvcmsuXG4gICAgICovXG4gICAgY29uc2Vuc3VzQWxnb3JpdGhtKCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuaGFyZGZvcmsoKTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGhmQ2hhbmdlcyBvZiB0aGlzLkhBUkRGT1JLX0NIQU5HRVMpIHtcbiAgICAgICAgICAgIGlmICgnY29uc2Vuc3VzJyBpbiBoZkNoYW5nZXNbMV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhmQ2hhbmdlc1sxXVsnY29uc2Vuc3VzJ11bJ2FsZ29yaXRobSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhmQ2hhbmdlc1swXSA9PT0gaGFyZGZvcmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8/IHRoaXMuX2NoYWluUGFyYW1zWydjb25zZW5zdXMnXVsnYWxnb3JpdGhtJ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IHdpdGggY29uc2Vuc3VzIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBwYXJhbWV0ZXJzIGJhc2VkIG9uIHRoZSBjb25zZW5zdXMgYWxnb3JpdGhtXG4gICAgICpcbiAgICAgKiBFeHBlY3RlZCByZXR1cm5zIChwYXJhbWV0ZXJzIG11c3QgYmUgcHJlc2VudCBpblxuICAgICAqIHRoZSByZXNwZWN0aXZlIGNoYWluIGpzb24gZmlsZXMpOlxuICAgICAqXG4gICAgICogZXRoYXNoOiBlbXB0eSBvYmplY3RcbiAgICAgKiBjbGlxdWU6IHBlcmlvZCwgZXBvY2hcbiAgICAgKiBjYXNwZXI6IGVtcHR5IG9iamVjdFxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyB2YWx1ZSBjYW4gdXBkYXRlIGFsb25nIGEgSGFyZGZvcmsuXG4gICAgICovXG4gICAgY29uc2Vuc3VzQ29uZmlnKCkge1xuICAgICAgICBjb25zdCBoYXJkZm9yayA9IHRoaXMuaGFyZGZvcmsoKTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGhmQ2hhbmdlcyBvZiB0aGlzLkhBUkRGT1JLX0NIQU5HRVMpIHtcbiAgICAgICAgICAgIGlmICgnY29uc2Vuc3VzJyBpbiBoZkNoYW5nZXNbMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIHBhcmFtZXRlciBpcyBuYW1lZCBhZnRlciB0aGUgcmVzcGVjdGl2ZSBjb25zZW5zdXMgYWxnb3JpdGhtXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoZkNoYW5nZXNbMV1bJ2NvbnNlbnN1cyddW2hmQ2hhbmdlc1sxXVsnY29uc2Vuc3VzJ11bJ2FsZ29yaXRobSddXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZkNoYW5nZXNbMF0gPT09IGhhcmRmb3JrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmFsdWUgPz8gdGhpcy5fY2hhaW5QYXJhbXNbJ2NvbnNlbnN1cyddW3RoaXMuY29uc2Vuc3VzQWxnb3JpdGhtKCldID8/IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGlzIHtAbGluayBDb21tb259IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKSwgdGhpcyk7XG4gICAgICAgIGNvcHkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBzdGF0aWMgX2dldEluaXRpYWxpemVkQ2hhaW5zKGN1c3RvbUNoYWlucykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBpZF0gb2YgT2JqZWN0LmVudHJpZXMoZW51bXNfMS5DaGFpbikpIHtcbiAgICAgICAgICAgIG5hbWVzW2lkXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFpbnMgPSB7IG1haW5uZXQsIHJvcHN0ZW4sIHJpbmtlYnksIGdvZXJsaSwgc2Vwb2xpYSB9O1xuICAgICAgICBpZiAoY3VzdG9tQ2hhaW5zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIGN1c3RvbUNoYWlucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gY2hhaW47XG4gICAgICAgICAgICAgICAgbmFtZXNbY2hhaW4uY2hhaW5JZC50b1N0cmluZygpXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgY2hhaW5zW25hbWVdID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhaW5zLm5hbWVzID0gbmFtZXM7XG4gICAgICAgIHJldHVybiBjaGFpbnM7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tb24gPSBDb21tb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0xMTUzXCIsXG4gICAgXCJudW1iZXJcIjogMTE1MyxcbiAgICBcImNvbW1lbnRcIjogXCJUcmFuc2llbnQgU3RvcmFnZVwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTUzXCIsXG4gICAgXCJzdGF0dXNcIjogXCJSZXZpZXdcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImNoYWluc3RhcnRcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwidHN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgVFNUT1JFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGxvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBUTE9BRCBvcGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTE1NTlcIixcbiAgICBcIm51bWJlclwiOiAxNTU5LFxuICAgIFwiY29tbWVudFwiOiBcIkZlZSBtYXJrZXQgY2hhbmdlIGZvciBFVEggMS4wIGNoYWluXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NTlcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJiZXJsaW5cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMjkzMF0sXG4gICAgXCJnYXNDb25maWdcIjoge1xuICAgICAgICBcImJhc2VGZWVNYXhDaGFuZ2VEZW5vbWluYXRvclwiOiB7XG4gICAgICAgICAgICBcInZcIjogOCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk1heGltdW0gYmFzZSBmZWUgY2hhbmdlIGRlbm9taW5hdG9yXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlbGFzdGljaXR5TXVsdGlwbGllclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIk1heGltdW0gYmxvY2sgZ2FzIHRhcmdldCBlbGFzdGljaXR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbml0aWFsQmFzZUZlZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwMDAwMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkluaXRpYWwgYmFzZSBmZWUgb24gZmlyc3QgRUlQMTU1OSBibG9ja1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjMxNVwiLFxuICAgIFwibnVtYmVyXCI6IDIzMTUsXG4gICAgXCJjb21tZW50XCI6IFwiU2ltcGxlIHN1YnJvdXRpbmVzIGZvciB0aGUgRVZNXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTIzMTVcIixcbiAgICBcInN0YXR1c1wiOiBcIkRyYWZ0XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJpc3RhbmJ1bFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJiZWdpbnN1YlwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCRUdJTlNVQiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInJldHVybnN1YlwiOiB7XG4gICAgICAgICAgICBcInZcIjogNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBSRVRVUk5TVUIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJqdW1wc3ViXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBKVU1QU1VCIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjUzN1wiLFxuICAgIFwibnVtYmVyXCI6IDI1MzcsXG4gICAgXCJjb21tZW50XCI6IFwiQkxTMTItMzgxIHByZWNvbXBpbGVzXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI1MzdcIixcbiAgICBcInN0YXR1c1wiOiBcIkRyYWZ0XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcIkJsczEyMzgxRzFBZGRHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDYwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IG9mIGEgc2luZ2xlIEJMUzEyLTM4MSBHMSBhZGRpdGlvbiBwcmVjb21waWxlLWNhbGxcIlxuICAgICAgICB9LFxuICAgICAgICBcIkJsczEyMzgxRzFNdWxHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEyMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgYSBzaW5nbGUgQkxTMTItMzgxIEcxIG11bHRpcGxpY2F0aW9uIHByZWNvbXBpbGUtY2FsbFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFHMkFkZEdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogNDUwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IG9mIGEgc2luZ2xlIEJMUzEyLTM4MSBHMiBhZGRpdGlvbiBwcmVjb21waWxlLWNhbGxcIlxuICAgICAgICB9LFxuICAgICAgICBcIkJsczEyMzgxRzJNdWxHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDU1MDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgYSBzaW5nbGUgQkxTMTItMzgxIEcyIG11bHRpcGxpY2F0aW9uIHByZWNvbXBpbGUtY2FsbFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFQYWlyaW5nQmFzZUdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMTE1MDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBnYXMgY29zdCBvZiBCTFMxMi0zODEgcGFpcmluZyBjaGVja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFQYWlyaW5nUGVyUGFpckdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMjMwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJQZXItcGFpciBnYXMgY29zdCBvZiBCTFMxMi0zODEgcGFpcmluZyBjaGVja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFNYXBHMUdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogNTUwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IG9mIEJMUzEyLTM4MSBtYXAgZmllbGQgZWxlbWVudCB0byBHMVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxzMTIzODFNYXBHMkdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMTEwMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgQkxTMTItMzgxIG1hcCBmaWVsZCBlbGVtZW50IHRvIEcyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJCbHMxMjM4MU11bHRpRXhwR2FzRGlzY291bnRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IFtcbiAgICAgICAgICAgICAgICBbMSwgMTIwMF0sXG4gICAgICAgICAgICAgICAgWzIsIDg4OF0sXG4gICAgICAgICAgICAgICAgWzMsIDc2NF0sXG4gICAgICAgICAgICAgICAgWzQsIDY0MV0sXG4gICAgICAgICAgICAgICAgWzUsIDU5NF0sXG4gICAgICAgICAgICAgICAgWzYsIDU0N10sXG4gICAgICAgICAgICAgICAgWzcsIDUwMF0sXG4gICAgICAgICAgICAgICAgWzgsIDQ1M10sXG4gICAgICAgICAgICAgICAgWzksIDQzOF0sXG4gICAgICAgICAgICAgICAgWzEwLCA0MjNdLFxuICAgICAgICAgICAgICAgIFsxMSwgNDA4XSxcbiAgICAgICAgICAgICAgICBbMTIsIDM5NF0sXG4gICAgICAgICAgICAgICAgWzEzLCAzNzldLFxuICAgICAgICAgICAgICAgIFsxNCwgMzY0XSxcbiAgICAgICAgICAgICAgICBbMTUsIDM0OV0sXG4gICAgICAgICAgICAgICAgWzE2LCAzMzRdLFxuICAgICAgICAgICAgICAgIFsxNywgMzMwXSxcbiAgICAgICAgICAgICAgICBbMTgsIDMyNl0sXG4gICAgICAgICAgICAgICAgWzE5LCAzMjJdLFxuICAgICAgICAgICAgICAgIFsyMCwgMzE4XSxcbiAgICAgICAgICAgICAgICBbMjEsIDMxNF0sXG4gICAgICAgICAgICAgICAgWzIyLCAzMTBdLFxuICAgICAgICAgICAgICAgIFsyMywgMzA2XSxcbiAgICAgICAgICAgICAgICBbMjQsIDMwMl0sXG4gICAgICAgICAgICAgICAgWzI1LCAyOThdLFxuICAgICAgICAgICAgICAgIFsyNiwgMjk0XSxcbiAgICAgICAgICAgICAgICBbMjcsIDI4OV0sXG4gICAgICAgICAgICAgICAgWzI4LCAyODVdLFxuICAgICAgICAgICAgICAgIFsyOSwgMjgxXSxcbiAgICAgICAgICAgICAgICBbMzAsIDI3N10sXG4gICAgICAgICAgICAgICAgWzMxLCAyNzNdLFxuICAgICAgICAgICAgICAgIFszMiwgMjY5XSxcbiAgICAgICAgICAgICAgICBbMzMsIDI2OF0sXG4gICAgICAgICAgICAgICAgWzM0LCAyNjZdLFxuICAgICAgICAgICAgICAgIFszNSwgMjY1XSxcbiAgICAgICAgICAgICAgICBbMzYsIDI2M10sXG4gICAgICAgICAgICAgICAgWzM3LCAyNjJdLFxuICAgICAgICAgICAgICAgIFszOCwgMjYwXSxcbiAgICAgICAgICAgICAgICBbMzksIDI1OV0sXG4gICAgICAgICAgICAgICAgWzQwLCAyNTddLFxuICAgICAgICAgICAgICAgIFs0MSwgMjU2XSxcbiAgICAgICAgICAgICAgICBbNDIsIDI1NF0sXG4gICAgICAgICAgICAgICAgWzQzLCAyNTNdLFxuICAgICAgICAgICAgICAgIFs0NCwgMjUxXSxcbiAgICAgICAgICAgICAgICBbNDUsIDI1MF0sXG4gICAgICAgICAgICAgICAgWzQ2LCAyNDhdLFxuICAgICAgICAgICAgICAgIFs0NywgMjQ3XSxcbiAgICAgICAgICAgICAgICBbNDgsIDI0NV0sXG4gICAgICAgICAgICAgICAgWzQ5LCAyNDRdLFxuICAgICAgICAgICAgICAgIFs1MCwgMjQyXSxcbiAgICAgICAgICAgICAgICBbNTEsIDI0MV0sXG4gICAgICAgICAgICAgICAgWzUyLCAyMzldLFxuICAgICAgICAgICAgICAgIFs1MywgMjM4XSxcbiAgICAgICAgICAgICAgICBbNTQsIDIzNl0sXG4gICAgICAgICAgICAgICAgWzU1LCAyMzVdLFxuICAgICAgICAgICAgICAgIFs1NiwgMjMzXSxcbiAgICAgICAgICAgICAgICBbNTcsIDIzMl0sXG4gICAgICAgICAgICAgICAgWzU4LCAyMzFdLFxuICAgICAgICAgICAgICAgIFs1OSwgMjI5XSxcbiAgICAgICAgICAgICAgICBbNjAsIDIyOF0sXG4gICAgICAgICAgICAgICAgWzYxLCAyMjZdLFxuICAgICAgICAgICAgICAgIFs2MiwgMjI1XSxcbiAgICAgICAgICAgICAgICBbNjMsIDIyM10sXG4gICAgICAgICAgICAgICAgWzY0LCAyMjJdLFxuICAgICAgICAgICAgICAgIFs2NSwgMjIxXSxcbiAgICAgICAgICAgICAgICBbNjYsIDIyMF0sXG4gICAgICAgICAgICAgICAgWzY3LCAyMTldLFxuICAgICAgICAgICAgICAgIFs2OCwgMjE5XSxcbiAgICAgICAgICAgICAgICBbNjksIDIxOF0sXG4gICAgICAgICAgICAgICAgWzcwLCAyMTddLFxuICAgICAgICAgICAgICAgIFs3MSwgMjE2XSxcbiAgICAgICAgICAgICAgICBbNzIsIDIxNl0sXG4gICAgICAgICAgICAgICAgWzczLCAyMTVdLFxuICAgICAgICAgICAgICAgIFs3NCwgMjE0XSxcbiAgICAgICAgICAgICAgICBbNzUsIDIxM10sXG4gICAgICAgICAgICAgICAgWzc2LCAyMTNdLFxuICAgICAgICAgICAgICAgIFs3NywgMjEyXSxcbiAgICAgICAgICAgICAgICBbNzgsIDIxMV0sXG4gICAgICAgICAgICAgICAgWzc5LCAyMTFdLFxuICAgICAgICAgICAgICAgIFs4MCwgMjEwXSxcbiAgICAgICAgICAgICAgICBbODEsIDIwOV0sXG4gICAgICAgICAgICAgICAgWzgyLCAyMDhdLFxuICAgICAgICAgICAgICAgIFs4MywgMjA4XSxcbiAgICAgICAgICAgICAgICBbODQsIDIwN10sXG4gICAgICAgICAgICAgICAgWzg1LCAyMDZdLFxuICAgICAgICAgICAgICAgIFs4NiwgMjA1XSxcbiAgICAgICAgICAgICAgICBbODcsIDIwNV0sXG4gICAgICAgICAgICAgICAgWzg4LCAyMDRdLFxuICAgICAgICAgICAgICAgIFs4OSwgMjAzXSxcbiAgICAgICAgICAgICAgICBbOTAsIDIwMl0sXG4gICAgICAgICAgICAgICAgWzkxLCAyMDJdLFxuICAgICAgICAgICAgICAgIFs5MiwgMjAxXSxcbiAgICAgICAgICAgICAgICBbOTMsIDIwMF0sXG4gICAgICAgICAgICAgICAgWzk0LCAxOTldLFxuICAgICAgICAgICAgICAgIFs5NSwgMTk5XSxcbiAgICAgICAgICAgICAgICBbOTYsIDE5OF0sXG4gICAgICAgICAgICAgICAgWzk3LCAxOTddLFxuICAgICAgICAgICAgICAgIFs5OCwgMTk2XSxcbiAgICAgICAgICAgICAgICBbOTksIDE5Nl0sXG4gICAgICAgICAgICAgICAgWzEwMCwgMTk1XSxcbiAgICAgICAgICAgICAgICBbMTAxLCAxOTRdLFxuICAgICAgICAgICAgICAgIFsxMDIsIDE5M10sXG4gICAgICAgICAgICAgICAgWzEwMywgMTkzXSxcbiAgICAgICAgICAgICAgICBbMTA0LCAxOTJdLFxuICAgICAgICAgICAgICAgIFsxMDUsIDE5MV0sXG4gICAgICAgICAgICAgICAgWzEwNiwgMTkxXSxcbiAgICAgICAgICAgICAgICBbMTA3LCAxOTBdLFxuICAgICAgICAgICAgICAgIFsxMDgsIDE4OV0sXG4gICAgICAgICAgICAgICAgWzEwOSwgMTg4XSxcbiAgICAgICAgICAgICAgICBbMTEwLCAxODhdLFxuICAgICAgICAgICAgICAgIFsxMTEsIDE4N10sXG4gICAgICAgICAgICAgICAgWzExMiwgMTg2XSxcbiAgICAgICAgICAgICAgICBbMTEzLCAxODVdLFxuICAgICAgICAgICAgICAgIFsxMTQsIDE4NV0sXG4gICAgICAgICAgICAgICAgWzExNSwgMTg0XSxcbiAgICAgICAgICAgICAgICBbMTE2LCAxODNdLFxuICAgICAgICAgICAgICAgIFsxMTcsIDE4Ml0sXG4gICAgICAgICAgICAgICAgWzExOCwgMTgyXSxcbiAgICAgICAgICAgICAgICBbMTE5LCAxODFdLFxuICAgICAgICAgICAgICAgIFsxMjAsIDE4MF0sXG4gICAgICAgICAgICAgICAgWzEyMSwgMTc5XSxcbiAgICAgICAgICAgICAgICBbMTIyLCAxNzldLFxuICAgICAgICAgICAgICAgIFsxMjMsIDE3OF0sXG4gICAgICAgICAgICAgICAgWzEyNCwgMTc3XSxcbiAgICAgICAgICAgICAgICBbMTI1LCAxNzZdLFxuICAgICAgICAgICAgICAgIFsxMjYsIDE3Nl0sXG4gICAgICAgICAgICAgICAgWzEyNywgMTc1XSxcbiAgICAgICAgICAgICAgICBbMTI4LCAxNzRdXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkXCI6IFwiRGlzY291bnQgZ2FzIGNvc3RzIG9mIGNhbGxzIHRvIHRoZSBNdWx0aUV4cCBwcmVjb21waWxlcyB3aXRoIGBrYCAocG9pbnQsIHNjYWxhcikgcGFpclwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjU2NVwiLFxuICAgIFwibnVtYmVyXCI6IDI1NjUsXG4gICAgXCJjb21tZW50XCI6IFwiTW9kRXhwIGdhcyBjb3N0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI1NjVcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJieXphbnRpdW1cIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwibW9kZXhwR3F1YWRkaXZpc29yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiR3F1YWRkaXZpc29yIGZyb20gbW9kZXhwIHByZWNvbXBpbGUgZm9yIGdhcyBjYWxjdWxhdGlvblwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjcxOFwiLFxuICAgIFwiY29tbWVudFwiOiBcIlR5cGVkIFRyYW5zYWN0aW9uIEVudmVsb3BlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI3MThcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0yOTI5XCIsXG4gICAgXCJjb21tZW50XCI6IFwiR2FzIGNvc3QgaW5jcmVhc2VzIGZvciBzdGF0ZSBhY2Nlc3Mgb3Bjb2Rlc1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yOTI5XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJjb2xkc2xvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIxMDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBvZiB0aGUgZmlyc3QgcmVhZCBvZiBzdG9yYWdlIGZyb20gYSBnaXZlbiBsb2NhdGlvbiAocGVyIHRyYW5zYWN0aW9uKVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sZGFjY291bnRhY2Nlc3NcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDI2MDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBvZiB0aGUgZmlyc3QgcmVhZCBvZiBhIGdpdmVuIGFkZHJlc3MgKHBlciB0cmFuc2FjdGlvbilcIlxuICAgICAgICB9LFxuICAgICAgICBcIndhcm1zdG9yYWdlcmVhZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgcmVhZGluZyBzdG9yYWdlIGxvY2F0aW9ucyB3aGljaCBoYXZlIGFscmVhZHkgbG9hZGVkICdjb2xkJ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlQ2xlYW5HYXNFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyOTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmcm9tIGNsZWFuIG5vbi16ZXJvIHRvIHNvbWV0aGluZyBlbHNlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVOb29wR2FzRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBpZiB0aGUgdmFsdWUgZG9lc24ndCBjaGFuZ2VcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZURpcnR5R2FzRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBpZiBhIGRpcnR5IHZhbHVlIGlzIGNoYW5nZWRcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZUluaXRSZWZ1bmRFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxOTkwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIHJlc2V0dGluZyB0byB0aGUgb3JpZ2luYWwgemVybyB2YWx1ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlQ2xlYW5SZWZ1bmRFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0OTAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmb3IgcmVzZXR0aW5nIHRvIHRoZSBvcmlnaW5hbCBub24temVybyB2YWx1ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbGNvZGVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTENPREUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWxlZ2F0ZWNhbGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgREVMRUdBVEVDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3RhdGljY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTVEFUSUNDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmFsYW5jZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCQUxBTkNFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRVhUQ09ERVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRjb2RlY29weVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBFWFRDT0RFQ09QWSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImV4dGNvZGVoYXNoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVIQVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2xvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0xPQUQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU1NUT1JFIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMjkzMFwiLFxuICAgIFwiY29tbWVudFwiOiBcIk9wdGlvbmFsIGFjY2VzcyBsaXN0c1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yOTMwXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwiaXN0YW5idWxcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMjcxOCwgMjkyOV0sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImFjY2Vzc0xpc3RTdG9yYWdlS2V5Q29zdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTkwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0IHBlciBzdG9yYWdlIGtleSBpbiBhbiBBY2Nlc3MgTGlzdCB0cmFuc2FjdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWNjZXNzTGlzdEFkZHJlc3NDb3N0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyNDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3QgcGVyIHN0b3JhZ2Uga2V5IGluIGFuIEFjY2VzcyBMaXN0IHRyYW5zYWN0aW9uXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zMDc0XCIsXG4gICAgXCJudW1iZXJcIjogMzA3NCxcbiAgICBcImNvbW1lbnRcIjogXCJBVVRIIGFuZCBBVVRIQ0FMTCBvcGNvZGVzXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTMwNzRcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImF1dGhcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMxMDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBvZiB0aGUgQVVUSCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImF1dGhjYWxsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgdGhlIEFVVEhDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYXV0aGNhbGxWYWx1ZVRyYW5zZmVyXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA2NzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiUGFpZCBmb3IgQ0FMTCB3aGVuIHRoZSB2YWx1ZSB0cmFuc2ZlciBpcyBub24temVyb1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzE5OFwiLFxuICAgIFwibnVtYmVyXCI6IDMxOTgsXG4gICAgXCJjb21tZW50XCI6IFwiQkFTRUZFRSBvcGNvZGVcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzE5OFwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJiYXNlZmVlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3Qgb2YgdGhlIEJBU0VGRUUgb3Bjb2RlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zNTI5XCIsXG4gICAgXCJjb21tZW50XCI6IFwiUmVkdWN0aW9uIGluIHJlZnVuZHNcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzUyOVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImJlcmxpblwiLFxuICAgIFwicmVxdWlyZWRFSVBzXCI6IFsyOTI5XSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7XG4gICAgICAgIFwibWF4UmVmdW5kUXVvdGllbnRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIHJlZnVuZCBxdW90aWVudDsgbWF4IHR4IHJlZnVuZCBpcyBtaW4odHguZ2FzVXNlZC9tYXhSZWZ1bmRRdW90aWVudCwgdHguZ2FzUmVmdW5kKVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJzZWxmZGVzdHJ1Y3RSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJSZWZ1bmRlZCBmb2xsb3dpbmcgYSBzZWxmZGVzdHJ1Y3Qgb3BlcmF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVDbGVhclJlZnVuZEVJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDQ4MDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZvciBjbGVhcmluZyBhbiBvcmlnaW5hbGx5IGV4aXN0aW5nIHN0b3JhZ2Ugc2xvdFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzU0MFwiLFxuICAgIFwibnVtYmVyXCI6IDM1NDAsXG4gICAgXCJjb21tZW50XCI6IFwiRVZNIE9iamVjdCBGb3JtYXQgKEVPRikgdjFcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzU0MFwiLFxuICAgIFwic3RhdHVzXCI6IFwiUmV2aWV3XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJsb25kb25cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMzU0MV0sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zNTQxXCIsXG4gICAgXCJjb21tZW50XCI6IFwiUmVqZWN0IG5ldyBjb250cmFjdHMgc3RhcnRpbmcgd2l0aCB0aGUgMHhFRiBieXRlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM1NDFcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJiZXJsaW5cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTM1NTRcIixcbiAgICBcImNvbW1lbnRcIjogXCJSZWR1Y3Rpb24gaW4gcmVmdW5kc1wiLFxuICAgIFwidXJsXCI6IFwiRGlmZmljdWx0eSBCb21iIERlbGF5IHRvIERlY2VtYmVyIDFzdCAyMDIxXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibXVpckdsYWNpZXJcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJkaWZmaWN1bHR5Qm9tYkRlbGF5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA5NTAwMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwidGhlIGFtb3VudCBvZiBibG9ja3MgdG8gZGVsYXkgdGhlIGRpZmZpY3VsdHkgYm9tYiB3aXRoXCJcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzYwN1wiLFxuICAgIFwibnVtYmVyXCI6IDM2MDcsXG4gICAgXCJjb21tZW50XCI6IFwiUmVqZWN0IHRyYW5zYWN0aW9ucyBmcm9tIHNlbmRlcnMgd2l0aCBkZXBsb3llZCBjb2RlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM2MDdcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogW10sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC0zNjUxXCIsXG4gICAgXCJudW1iZXJcIjogMzE5OCxcbiAgICBcImNvbW1lbnRcIjogXCJXYXJtIENPSU5CQVNFXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM2NTFcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogWzI5MjldLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzY3MFwiLFxuICAgIFwibnVtYmVyXCI6IDM2NzAsXG4gICAgXCJjb21tZW50XCI6IFwiRU9GIC0gQ29kZSBWYWxpZGF0aW9uXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM2NzBcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogWzM1NDBdLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzY3NVwiLFxuICAgIFwibnVtYmVyXCI6IDM2NzUsXG4gICAgXCJjb21tZW50XCI6IFwiVXBncmFkZSBjb25zZW5zdXMgdG8gUHJvb2Ytb2YtU3Rha2VcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzY3NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwicmVxdWlyZWRFSVBzXCI6IFtdLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzg1NVwiLFxuICAgIFwibnVtYmVyXCI6IDM4NTUsXG4gICAgXCJjb21tZW50XCI6IFwiUFVTSDAgaW5zdHJ1Y3Rpb25cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMzg1NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiUmV2aWV3XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJjaGFpbnN0YXJ0XCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogW10sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcInB1c2gwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFBVU0gwIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtMzg2MFwiLFxuICAgIFwibnVtYmVyXCI6IDM4NjAsXG4gICAgXCJjb21tZW50XCI6IFwiTGltaXQgYW5kIG1ldGVyIGluaXRjb2RlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTM4NjBcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwic3B1cmlvdXNEcmFnb25cIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwiaW5pdENvZGVXb3JkQ29zdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyB0byBwYXkgZm9yIGVhY2ggd29yZCAoMzIgYnl0ZXMpIG9mIGluaXRjb2RlIHdoZW4gY3JlYXRpbmcgYSBjb250cmFjdFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge1xuICAgICAgICBcIm1heEluaXRDb2RlU2l6ZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDkxNTIsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIGxlbmd0aCBvZiBpbml0aWFsaXphdGlvbiBjb2RlIHdoZW4gY3JlYXRpbmcgYSBjb250cmFjdFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTQzNDVcIixcbiAgICBcIm51bWJlclwiOiA0MzQ1LFxuICAgIFwiY29tbWVudFwiOiBcIkRpZmZpY3VsdHkgQm9tYiBEZWxheSB0byBKdW5lIDIwMjJcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM0NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcIm1pbmltdW1IYXJkZm9ya1wiOiBcImxvbmRvblwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge1xuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwNzAwMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwidGhlIGFtb3VudCBvZiBibG9ja3MgdG8gZGVsYXkgdGhlIGRpZmZpY3VsdHkgYm9tYiB3aXRoXCJcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtNDM5OVwiLFxuICAgIFwibnVtYmVyXCI6IDQzOTksXG4gICAgXCJjb21tZW50XCI6IFwiU3VwcGxhbnQgRElGRklDVUxUWSBvcGNvZGUgd2l0aCBQUkVWUkFOREFPXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQzOTlcIixcbiAgICBcInN0YXR1c1wiOiBcIlJldmlld1wiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibG9uZG9uXCIsXG4gICAgXCJyZXF1aXJlZEVJUHNcIjogW10sXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge30sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIkVJUC00ODQ0XCIsXG4gICAgXCJudW1iZXJcIjogNDg0NCxcbiAgICBcImNvbW1lbnRcIjogXCJTaGFyZCBCbG9iIFRyYW5zYWN0aW9uc1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC00ODQ0XCIsXG4gICAgXCJzdGF0dXNcIjogXCJEcmFmdFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwibWVyZ2VcIixcbiAgICBcInJlcXVpcmVkRUlQc1wiOiBbMTU1OSwgMjcxOCwgMjkzMCwgNDg5NV0sXG4gICAgXCJnYXNDb25maWdcIjoge1xuICAgICAgICBcImRhdGFHYXNQZXJCbG9iXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMzEwNzIsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgYmFzZSBmZWUgZm9yIGRhdGEgZ2FzIHBlciBibG9iXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0YXJnZXREYXRhR2FzUGVyQmxvY2tcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDI2MjE0NCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSB0YXJnZXQgZGF0YSBnYXMgY29uc3VtZWQgcGVyIGJsb2NrXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhEYXRhR2FzUGVyQmxvY2tcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUyNDI4OCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBtYXggZGF0YSBnYXMgYWxsb3dhYmxlIHBlciBibG9ja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YUdhc1ByaWNlVXBkYXRlRnJhY3Rpb25cIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIyMjU2NTIsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgZGVub21pbmF0b3IgdXNlZCBpbiB0aGUgZXhwb25lbnRpYWwgd2hlbiBjYWxjdWxhdGluZyBhIGRhdGEgZ2FzIHByaWNlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcInNpbXBsZUdhc1BlckJsb2JcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEyMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGhlIGJhc2ljIGdhcyBmZWUgZm9yIGVhY2ggYmxvYlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWluRGF0YUdhc1ByaWNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGhlIG1pbmltdW0gZmVlIHBlciBkYXRhIGdhc1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwia3pnUG9pbnRFdmFsdWF0aW9uR2FzUHJlY29tcGlsZVByaWNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1MDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBmZWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb2ludCBldmFsdWF0aW9uIHByZWNvbXBpbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGFoYXNoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIERBVEFIQVNIIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwic2hhcmRpbmdcIjoge1xuICAgICAgICBcImJsb2JDb21taXRtZW50VmVyc2lvbkt6Z1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMSxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBudW1iZXIgaW5kaWNhdGVkIGEgdmVyc2lvbmVkIGhhc2ggaXMgYSBLWkcgY29tbWl0bWVudFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmllbGRFbGVtZW50c1BlckJsb2JcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDQwOTYsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzIGFsbG93ZWQgcGVyIGJsb2JcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiRUlQLTQ4OTVcIixcbiAgICBcIm51bWJlclwiOiA0ODk1LFxuICAgIFwiY29tbWVudFwiOiBcIkJlYWNvbiBjaGFpbiBwdXNoIHdpdGhkcmF3YWxzIGFzIG9wZXJhdGlvbnNcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDg5NVwiLFxuICAgIFwic3RhdHVzXCI6IFwiUmV2aWV3XCIsXG4gICAgXCJtaW5pbXVtSGFyZGZvcmtcIjogXCJtZXJnZVwiLFxuICAgIFwicmVxdWlyZWRFSVBzXCI6IFtdLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJFSVAtNTEzM1wiLFxuICAgIFwibnVtYmVyXCI6IDUxMzMsXG4gICAgXCJjb21tZW50XCI6IFwiRGVsYXlpbmcgRGlmZmljdWx0eSBCb21iIHRvIG1pZC1TZXB0ZW1iZXIgMjAyMlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC01MTMzXCIsXG4gICAgXCJzdGF0dXNcIjogXCJEcmFmdFwiLFxuICAgIFwibWluaW11bUhhcmRmb3JrXCI6IFwiZ3JheUdsYWNpZXJcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJkaWZmaWN1bHR5Qm9tYkRlbGF5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMTQwMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcInRoZSBhbW91bnQgb2YgYmxvY2tzIHRvIGRlbGF5IHRoZSBkaWZmaWN1bHR5IGJvbWIgd2l0aFwiXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRUlQcyA9IHZvaWQgMDtcbmV4cG9ydHMuRUlQcyA9IHtcbiAgICAxMTUzOiByZXF1aXJlKCcuLzExNTMuanNvbicpLFxuICAgIDE1NTk6IHJlcXVpcmUoJy4vMTU1OS5qc29uJyksXG4gICAgMjMxNTogcmVxdWlyZSgnLi8yMzE1Lmpzb24nKSxcbiAgICAyNTM3OiByZXF1aXJlKCcuLzI1MzcuanNvbicpLFxuICAgIDI1NjU6IHJlcXVpcmUoJy4vMjU2NS5qc29uJyksXG4gICAgMjcxODogcmVxdWlyZSgnLi8yNzE4Lmpzb24nKSxcbiAgICAyOTI5OiByZXF1aXJlKCcuLzI5MjkuanNvbicpLFxuICAgIDI5MzA6IHJlcXVpcmUoJy4vMjkzMC5qc29uJyksXG4gICAgMzA3NDogcmVxdWlyZSgnLi8zMDc0Lmpzb24nKSxcbiAgICAzMTk4OiByZXF1aXJlKCcuLzMxOTguanNvbicpLFxuICAgIDM1Mjk6IHJlcXVpcmUoJy4vMzUyOS5qc29uJyksXG4gICAgMzU0MDogcmVxdWlyZSgnLi8zNTQwLmpzb24nKSxcbiAgICAzNTQxOiByZXF1aXJlKCcuLzM1NDEuanNvbicpLFxuICAgIDM1NTQ6IHJlcXVpcmUoJy4vMzU1NC5qc29uJyksXG4gICAgMzYwNzogcmVxdWlyZSgnLi8zNjA3Lmpzb24nKSxcbiAgICAzNjUxOiByZXF1aXJlKCcuLzM2NTEuanNvbicpLFxuICAgIDM2NzA6IHJlcXVpcmUoJy4vMzY3MC5qc29uJyksXG4gICAgMzY3NTogcmVxdWlyZSgnLi8zNjc1Lmpzb24nKSxcbiAgICAzODU1OiByZXF1aXJlKCcuLzM4NTUuanNvbicpLFxuICAgIDM4NjA6IHJlcXVpcmUoJy4vMzg2MC5qc29uJyksXG4gICAgNDM0NTogcmVxdWlyZSgnLi80MzQ1Lmpzb24nKSxcbiAgICA0Mzk5OiByZXF1aXJlKCcuLzQzOTkuanNvbicpLFxuICAgIDQ4NDQ6IHJlcXVpcmUoJy4vNDg0NC5qc29uJyksXG4gICAgNDg5NTogcmVxdWlyZSgnLi80ODk1Lmpzb24nKSxcbiAgICA1MTMzOiByZXF1aXJlKCcuLzUxMzMuanNvbicpLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DdXN0b21DaGFpbiA9IGV4cG9ydHMuQ29uc2Vuc3VzQWxnb3JpdGhtID0gZXhwb3J0cy5Db25zZW5zdXNUeXBlID0gZXhwb3J0cy5IYXJkZm9yayA9IGV4cG9ydHMuQ2hhaW4gPSB2b2lkIDA7XG52YXIgQ2hhaW47XG4oZnVuY3Rpb24gKENoYWluKSB7XG4gICAgQ2hhaW5bQ2hhaW5bXCJNYWlubmV0XCJdID0gMV0gPSBcIk1haW5uZXRcIjtcbiAgICBDaGFpbltDaGFpbltcIlJvcHN0ZW5cIl0gPSAzXSA9IFwiUm9wc3RlblwiO1xuICAgIENoYWluW0NoYWluW1wiUmlua2VieVwiXSA9IDRdID0gXCJSaW5rZWJ5XCI7XG4gICAgQ2hhaW5bQ2hhaW5bXCJHb2VybGlcIl0gPSA1XSA9IFwiR29lcmxpXCI7XG4gICAgQ2hhaW5bQ2hhaW5bXCJTZXBvbGlhXCJdID0gMTExNTUxMTFdID0gXCJTZXBvbGlhXCI7XG59KShDaGFpbiA9IGV4cG9ydHMuQ2hhaW4gfHwgKGV4cG9ydHMuQ2hhaW4gPSB7fSkpO1xudmFyIEhhcmRmb3JrO1xuKGZ1bmN0aW9uIChIYXJkZm9yaykge1xuICAgIEhhcmRmb3JrW1wiQ2hhaW5zdGFydFwiXSA9IFwiY2hhaW5zdGFydFwiO1xuICAgIEhhcmRmb3JrW1wiSG9tZXN0ZWFkXCJdID0gXCJob21lc3RlYWRcIjtcbiAgICBIYXJkZm9ya1tcIkRhb1wiXSA9IFwiZGFvXCI7XG4gICAgSGFyZGZvcmtbXCJUYW5nZXJpbmVXaGlzdGxlXCJdID0gXCJ0YW5nZXJpbmVXaGlzdGxlXCI7XG4gICAgSGFyZGZvcmtbXCJTcHVyaW91c0RyYWdvblwiXSA9IFwic3B1cmlvdXNEcmFnb25cIjtcbiAgICBIYXJkZm9ya1tcIkJ5emFudGl1bVwiXSA9IFwiYnl6YW50aXVtXCI7XG4gICAgSGFyZGZvcmtbXCJDb25zdGFudGlub3BsZVwiXSA9IFwiY29uc3RhbnRpbm9wbGVcIjtcbiAgICBIYXJkZm9ya1tcIlBldGVyc2J1cmdcIl0gPSBcInBldGVyc2J1cmdcIjtcbiAgICBIYXJkZm9ya1tcIklzdGFuYnVsXCJdID0gXCJpc3RhbmJ1bFwiO1xuICAgIEhhcmRmb3JrW1wiTXVpckdsYWNpZXJcIl0gPSBcIm11aXJHbGFjaWVyXCI7XG4gICAgSGFyZGZvcmtbXCJCZXJsaW5cIl0gPSBcImJlcmxpblwiO1xuICAgIEhhcmRmb3JrW1wiTG9uZG9uXCJdID0gXCJsb25kb25cIjtcbiAgICBIYXJkZm9ya1tcIkFycm93R2xhY2llclwiXSA9IFwiYXJyb3dHbGFjaWVyXCI7XG4gICAgSGFyZGZvcmtbXCJHcmF5R2xhY2llclwiXSA9IFwiZ3JheUdsYWNpZXJcIjtcbiAgICBIYXJkZm9ya1tcIk1lcmdlRm9ya0lkVHJhbnNpdGlvblwiXSA9IFwibWVyZ2VGb3JrSWRUcmFuc2l0aW9uXCI7XG4gICAgSGFyZGZvcmtbXCJNZXJnZVwiXSA9IFwibWVyZ2VcIjtcbiAgICBIYXJkZm9ya1tcIlNoYW5naGFpXCJdID0gXCJzaGFuZ2hhaVwiO1xuICAgIEhhcmRmb3JrW1wiU2hhcmRpbmdGb3JrRGV2XCJdID0gXCJzaGFyZGluZ0ZvcmtcIjtcbn0pKEhhcmRmb3JrID0gZXhwb3J0cy5IYXJkZm9yayB8fCAoZXhwb3J0cy5IYXJkZm9yayA9IHt9KSk7XG52YXIgQ29uc2Vuc3VzVHlwZTtcbihmdW5jdGlvbiAoQ29uc2Vuc3VzVHlwZSkge1xuICAgIENvbnNlbnN1c1R5cGVbXCJQcm9vZk9mU3Rha2VcIl0gPSBcInBvc1wiO1xuICAgIENvbnNlbnN1c1R5cGVbXCJQcm9vZk9mV29ya1wiXSA9IFwicG93XCI7XG4gICAgQ29uc2Vuc3VzVHlwZVtcIlByb29mT2ZBdXRob3JpdHlcIl0gPSBcInBvYVwiO1xufSkoQ29uc2Vuc3VzVHlwZSA9IGV4cG9ydHMuQ29uc2Vuc3VzVHlwZSB8fCAoZXhwb3J0cy5Db25zZW5zdXNUeXBlID0ge30pKTtcbnZhciBDb25zZW5zdXNBbGdvcml0aG07XG4oZnVuY3Rpb24gKENvbnNlbnN1c0FsZ29yaXRobSkge1xuICAgIENvbnNlbnN1c0FsZ29yaXRobVtcIkV0aGFzaFwiXSA9IFwiZXRoYXNoXCI7XG4gICAgQ29uc2Vuc3VzQWxnb3JpdGhtW1wiQ2xpcXVlXCJdID0gXCJjbGlxdWVcIjtcbiAgICBDb25zZW5zdXNBbGdvcml0aG1bXCJDYXNwZXJcIl0gPSBcImNhc3BlclwiO1xufSkoQ29uc2Vuc3VzQWxnb3JpdGhtID0gZXhwb3J0cy5Db25zZW5zdXNBbGdvcml0aG0gfHwgKGV4cG9ydHMuQ29uc2Vuc3VzQWxnb3JpdGhtID0ge30pKTtcbnZhciBDdXN0b21DaGFpbjtcbihmdW5jdGlvbiAoQ3VzdG9tQ2hhaW4pIHtcbiAgICAvKipcbiAgICAgKiBQb2x5Z29uIChNYXRpYykgTWFpbm5ldFxuICAgICAqXG4gICAgICogLSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm1hdGljLm5ldHdvcmsvZG9jcy9kZXZlbG9wL25ldHdvcmstZGV0YWlscy9uZXR3b3JrKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wiUG9seWdvbk1haW5uZXRcIl0gPSBcInBvbHlnb24tbWFpbm5ldFwiO1xuICAgIC8qKlxuICAgICAqIFBvbHlnb24gKE1hdGljKSBNdW1iYWkgVGVzdG5ldFxuICAgICAqXG4gICAgICogLSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm1hdGljLm5ldHdvcmsvZG9jcy9kZXZlbG9wL25ldHdvcmstZGV0YWlscy9uZXR3b3JrKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wiUG9seWdvbk11bWJhaVwiXSA9IFwicG9seWdvbi1tdW1iYWlcIjtcbiAgICAvKipcbiAgICAgKiBBcmJpdHJ1bSBSaW5rZWJ5IFRlc3RuZXRcbiAgICAgKlxuICAgICAqIC0gW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm9mZmNoYWlubGFicy5jb20vZG9jcy9wdWJsaWNfdGVzdG5ldClcbiAgICAgKi9cbiAgICBDdXN0b21DaGFpbltcIkFyYml0cnVtUmlua2VieVRlc3RuZXRcIl0gPSBcImFyYml0cnVtLXJpbmtlYnktdGVzdG5ldFwiO1xuICAgIC8qKlxuICAgICAqIEFyYml0cnVtIE9uZSAtIG1haW5uZXQgZm9yIEFyYml0cnVtIHJvbGwtdXBcbiAgICAgKlxuICAgICAqIC0gW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm9mZmNoYWlubGFicy5jb20vcHVibGljLWNoYWlucylcbiAgICAgKi9cbiAgICBDdXN0b21DaGFpbltcIkFyYml0cnVtT25lXCJdID0gXCJhcmJpdHJ1bS1vbmVcIjtcbiAgICAvKipcbiAgICAgKiB4RGFpIEVWTSBzaWRlY2hhaW4gd2l0aCBhIG5hdGl2ZSBzdGFibGUgdG9rZW5cbiAgICAgKlxuICAgICAqIC0gW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnhkYWljaGFpbi5jb20vKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wieERhaUNoYWluXCJdID0gXCJ4LWRhaS1jaGFpblwiO1xuICAgIC8qKlxuICAgICAqIE9wdGltaXN0aWMgS292YW4gLSB0ZXN0bmV0IGZvciBPcHRpbWlzbSByb2xsLXVwXG4gICAgICpcbiAgICAgKiAtIFtEb2N1bWVudGF0aW9uXShodHRwczovL2NvbW11bml0eS5vcHRpbWlzbS5pby9kb2NzL2RldmVsb3BlcnMvdHV0b3JpYWxzLmh0bWwpXG4gICAgICovXG4gICAgQ3VzdG9tQ2hhaW5bXCJPcHRpbWlzdGljS292YW5cIl0gPSBcIm9wdGltaXN0aWMta292YW5cIjtcbiAgICAvKipcbiAgICAgKiBPcHRpbWlzdGljIEV0aGVyZXVtIC0gbWFpbm5ldCBmb3IgT3B0aW1pc20gcm9sbC11cFxuICAgICAqXG4gICAgICogLSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9jb21tdW5pdHkub3B0aW1pc20uaW8vZG9jcy9kZXZlbG9wZXJzL3R1dG9yaWFscy5odG1sKVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wiT3B0aW1pc3RpY0V0aGVyZXVtXCJdID0gXCJvcHRpbWlzdGljLWV0aGVyZXVtXCI7XG59KShDdXN0b21DaGFpbiA9IGV4cG9ydHMuQ3VzdG9tQ2hhaW4gfHwgKGV4cG9ydHMuQ3VzdG9tQ2hhaW4gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bXMuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcImFycm93R2xhY2llclwiLFxuICAgIFwiY29tbWVudFwiOiBcIkhGIHRvIGRlbGF5IHRoZSBkaWZmaWN1bHR5IGJvbWJcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9leGVjdXRpb24tc3BlY3MvYmxvYi9tYXN0ZXIvbmV0d29yay11cGdyYWRlcy9tYWlubmV0LXVwZ3JhZGVzL2Fycm93LWdsYWNpZXIubWRcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJlaXBzXCI6IFs0MzQ1XSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiYmVybGluXCIsXG4gICAgXCJjb21tZW50XCI6IFwiSEYgdGFyZ2V0ZWQgZm9yIEp1bHkgMjAyMCBmb2xsb3dpbmcgdGhlIE11aXIgR2xhY2llciBIRlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yMDcwXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZWlwc1wiOiBbMjU2NSwgMjkyOSwgMjcxOCwgMjkzMF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJieXphbnRpdW1cIixcbiAgICBcImNvbW1lbnRcIjogXCJIYXJkZm9yayB3aXRoIG5ldyBwcmVjb21waWxlcywgaW5zdHJ1Y3Rpb25zIGFuZCBvdGhlciBwcm90b2NvbCBjaGFuZ2VzXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTYwOVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwibW9kZXhwR3F1YWRkaXZpc29yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdxdWFkZGl2aXNvciBmcm9tIG1vZGV4cCBwcmVjb21waWxlIGZvciBnYXMgY2FsY3VsYXRpb25cIlxuICAgICAgICB9LFxuICAgICAgICBcImVjQWRkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1MDAsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdHMgZm9yIGN1cnZlIGFkZGl0aW9uIHByZWNvbXBpbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImVjTXVsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0MDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0cyBmb3IgY3VydmUgbXVsdGlwbGljYXRpb24gcHJlY29tcGlsZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZWNQYWlyaW5nXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGdhcyBjb3N0cyBmb3IgY3VydmUgcGFpcmluZyBwcmVjb21waWxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlY1BhaXJpbmdXb3JkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA4MDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0cyByZWdhcmRpbmcgY3VydmUgcGFpcmluZyBwcmVjb21waWxlIGlucHV0IGxlbmd0aFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmV2ZXJ0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFJFVkVSVCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInN0YXRpY2NhbGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDcwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTVEFUSUNDQUxMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmV0dXJuZGF0YXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgUkVUVVJOREFUQVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXR1cm5kYXRhY29weVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBSRVRVUk5EQVRBQ09QWSBvcGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJtaW5lclJld2FyZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogXCIzMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IGEgbWluZXIgZ2V0IHJld2FyZGVkIGZvciBtaW5pbmcgYSBibG9ja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlmZmljdWx0eUJvbWJEZWxheVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzAwMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcInRoZSBhbW91bnQgb2YgYmxvY2tzIHRvIGRlbGF5IHRoZSBkaWZmaWN1bHR5IGJvbWIgd2l0aFwiXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiY2hhaW5zdGFydFwiLFxuICAgIFwiY29tbWVudFwiOiBcIlN0YXJ0IG9mIHRoZSBFdGhlcmV1bSBtYWluIGNoYWluXCIsXG4gICAgXCJ1cmxcIjogXCJcIixcbiAgICBcInN0YXR1c1wiOiBcIlwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHtcbiAgICAgICAgXCJtaW5HYXNMaW1pdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk1pbmltdW0gdGhlIGdhcyBsaW1pdCBtYXkgZXZlciBiZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2FzTGltaXRCb3VuZERpdmlzb3JcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwMjQsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgYm91bmQgZGl2aXNvciBvZiB0aGUgZ2FzIGxpbWl0LCB1c2VkIGluIHVwZGF0ZSBjYWxjdWxhdGlvbnNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1heFJlZnVuZFF1b3RpZW50XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiTWF4aW11bSByZWZ1bmQgcXVvdGllbnQ7IG1heCB0eCByZWZ1bmQgaXMgbWluKHR4Lmdhc1VzZWQvbWF4UmVmdW5kUXVvdGllbnQsIHR4Lmdhc1JlZnVuZClcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwiYmFzZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBiYXNlIGNvc3QsIHVzZWQgZS5nLiBmb3IgQ2hhaW5JRCBvcGNvZGUgKElzdGFuYnVsKVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGllclN0ZXBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IFswLCAyLCAzLCA1LCA4LCAxMCwgMjBdLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgb3BlcmF0aW9uLCBmb3IgYSBzZWxlY3Rpb24gb2YgdGhlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBFWFAgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHBCeXRlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRpbWVzIGNlaWwobG9nMjU2KGV4cG9uZW50KSkgZm9yIHRoZSBFWFAgaW5zdHJ1Y3Rpb25cIlxuICAgICAgICB9LFxuICAgICAgICBcInNoYTNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNIQTMgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGEzV29yZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNixcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIHdvcmQgb2YgdGhlIFNIQTMgb3BlcmF0aW9uJ3MgZGF0YVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2xvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNMT0FEIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlU2V0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgdGhlIHplcm9uZXNzIGNoYW5nZXMgZnJvbSB6ZXJvXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVSZXNldFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgdGhlIHplcm9uZXNzIGRvZXMgbm90IGNoYW5nZSBmcm9tIHplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZVJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGlmIHRoZSB6ZXJvbmVzcyBjaGFuZ2VzIHRvIHplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcImp1bXBkZXN0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEpVTVBERVNUIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibG9nXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzNzUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTE9HIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibG9nRGF0YVwiOiB7XG4gICAgICAgICAgICBcInZcIjogOCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlBlciBieXRlIGluIGEgTE9HKiBvcGVyYXRpb24ncyBkYXRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsb2dUb3BpY1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMzc1LFxuICAgICAgICAgICAgXCJkXCI6IFwiTXVsdGlwbGllZCBieSB0aGUgKiBvZiB0aGUgTE9HKiwgcGVyIExPRyB0cmFuc2FjdGlvbi4gZS5nLiBMT0cwIGluY3VycyAwICogY190eExvZ1RvcGljR2FzLCBMT0c0IGluY3VycyA0ICogY190eExvZ1RvcGljR2FzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMyMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIENSRUFURSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDQwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIENBTEwgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsU3RpcGVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjMwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkZyZWUgZ2FzIGdpdmVuIGF0IGJlZ2lubmluZyBvZiBjYWxsXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsVmFsdWVUcmFuc2ZlclwiOiB7XG4gICAgICAgICAgICBcInZcIjogOTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlBhaWQgZm9yIENBTEwgd2hlbiB0aGUgdmFsdWUgdHJhbnNmb3IgaXMgbm9uLXplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxOZXdBY2NvdW50XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlBhaWQgZm9yIENBTEwgd2hlbiB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyBkaWRuJ3QgZXhpc3QgcHJpb3JcIlxuICAgICAgICB9LFxuICAgICAgICBcInNlbGZkZXN0cnVjdFJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjQwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJSZWZ1bmRlZCBmb2xsb3dpbmcgYSBzZWxmZGVzdHJ1Y3Qgb3BlcmF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZW1vcnlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJUaW1lcyB0aGUgYWRkcmVzcyBvZiB0aGUgKGhpZ2hlc3QgcmVmZXJlbmNlZCBieXRlIGluIG1lbW9yeSArIDEpLiBOT1RFOiByZWZlcmVuY2luZyBoYXBwZW5zIG9uIHJlYWQsIHdyaXRlIGFuZCBpbiBpbnN0cnVjdGlvbnMgc3VjaCBhcyBSRVRVUk4gYW5kIENBTExcIlxuICAgICAgICB9LFxuICAgICAgICBcInF1YWRDb2VmZkRpdlwiOiB7XG4gICAgICAgICAgICBcInZcIjogNTEyLFxuICAgICAgICAgICAgXCJkXCI6IFwiRGl2aXNvciBmb3IgdGhlIHF1YWRyYXRpYyBwYXJ0aWNsZSBvZiB0aGUgbWVtb3J5IGNvc3QgZXF1YXRpb25cIlxuICAgICAgICB9LFxuICAgICAgICBcImNyZWF0ZURhdGFcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidHhcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIxMDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiUGVyIHRyYW5zYWN0aW9uLiBOT1RFOiBOb3QgcGF5YWJsZSBvbiBkYXRhIG9mIGNhbGxzIGJldHdlZW4gdHJhbnNhY3Rpb25zXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eENyZWF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzMjAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBjb3N0IG9mIGNyZWF0aW5nIGEgY29udHJhY3QgdmlhIHR4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eERhdGFaZXJvXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0LFxuICAgICAgICAgICAgXCJkXCI6IFwiUGVyIGJ5dGUgb2YgZGF0YSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRoYXQgZXF1YWxzIHplcm8uIE5PVEU6IE5vdCBwYXlhYmxlIG9uIGRhdGEgb2YgY2FsbHMgYmV0d2VlbiB0cmFuc2FjdGlvbnNcIlxuICAgICAgICB9LFxuICAgICAgICBcInR4RGF0YU5vblplcm9cIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDY4LFxuICAgICAgICAgICAgXCJkXCI6IFwiUGVyIGJ5dGUgb2YgZGF0YSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRoYXQgaXMgbm90IGVxdWFsIHRvIHplcm8uIE5PVEU6IE5vdCBwYXlhYmxlIG9uIGRhdGEgb2YgY2FsbHMgYmV0d2VlbiB0cmFuc2FjdGlvbnNcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvcHlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJNdWx0aXBsaWVkIGJ5IHRoZSBudW1iZXIgb2YgMzItYnl0ZSB3b3JkcyB0aGF0IGFyZSBjb3BpZWQgKHJvdW5kIHVwKSBmb3IgYW55ICpDT1BZIG9wZXJhdGlvbiBhbmQgYWRkZWRcIlxuICAgICAgICB9LFxuICAgICAgICBcImVjUmVjb3ZlclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhMjU2XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA2MCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hhMjU2V29yZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTIsXG4gICAgICAgICAgICBcImRcIjogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBcInJpcGVtZDE2MFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNjAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyaXBlbWQxNjBXb3JkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMjAsXG4gICAgICAgICAgICBcImRcIjogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBcImlkZW50aXR5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRlbnRpdHlXb3JkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzdG9wXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNUT1Agb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhZGRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQUREIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibXVsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1LFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE1VTCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInN1YlwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTVUIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkaXZcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRElWIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2RpdlwiOiB7XG4gICAgICAgICAgICBcInZcIjogNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTRElWIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibW9kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA1LFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE1PRCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNtb2RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU01PRCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImFkZG1vZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogOCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBBRERNT0Qgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtdWxtb2RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTVVMTU9EIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2lnbmV4dGVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNSxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTSUdORVhURU5EIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibHRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTFQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJndFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBHVCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNsdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTTFQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZ3RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0dUIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXFcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRVEgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpc3plcm9cIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgSVNaRVJPIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYW5kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEFORCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm9yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE9SIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwieG9yXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFhPUiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5vdFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBOT1Qgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJieXRlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEJZVEUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEFERFJFU1Mgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCQUxBTkNFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwib3JpZ2luXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIE9SSUdJTiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxlclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMRVIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsdmFsdWVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTFZBTFVFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbGRhdGFsb2FkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIENBTExEQVRBTE9BRCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxkYXRhc2l6ZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMREFUQVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsZGF0YWNvcHlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTERBVEFDT1BZIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ09ERVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2RlY29weVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDT0RFQ09QWSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImdhc3ByaWNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEdBU1BSSUNFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVTSVpFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZWNvcHlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVDT1BZIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmxvY2toYXNoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBCTE9DS0hBU0ggb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2luYmFzZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDT0lOQkFTRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInRpbWVzdGFtcFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBUSU1FU1RBTVAgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJudW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTlVNQkVSIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlmZmljdWx0eVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBESUZGSUNVTFRZIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2FzbGltaXRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgR0FTTElNSVQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3BcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgUE9QIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWxvYWRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTUxPQUQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTVNUT1JFIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibXN0b3JlOFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBNU1RPUkU4IG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNTVE9SRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImp1bXBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgSlVNUCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImp1bXBpXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBKVU1QSSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInBjXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFBDIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgTVNJWkUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJnYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDIsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgR0FTIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicHVzaFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBQVVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZHVwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIERVUCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInN3YXBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU1dBUCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxjb2RlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0MCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDQUxMQ09ERSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInJldHVyblwiOiB7XG4gICAgICAgICAgICBcInZcIjogMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBSRVRVUk4gb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbnZhbGlkXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIElOVkFMSUQgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZWxmZGVzdHJ1Y3RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0VMRkRFU1RSVUNUIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge1xuICAgICAgICBcInN0YWNrTGltaXRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEwMjQsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIHNpemUgb2YgVk0gc3RhY2sgYWxsb3dlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FsbENyZWF0ZURlcHRoXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDI0LFxuICAgICAgICAgICAgXCJkXCI6IFwiTWF4aW11bSBkZXB0aCBvZiBjYWxsL2NyZWF0ZSBzdGFja1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4RXh0cmFEYXRhU2l6ZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzIsXG4gICAgICAgICAgICBcImRcIjogXCJNYXhpbXVtIHNpemUgZXh0cmEgZGF0YSBtYXkgYmUgYWZ0ZXIgR2VuZXNpc1wiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJtaW5pbXVtRGlmZmljdWx0eVwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTMxMDcyLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGhlIG1pbmltdW0gdGhhdCB0aGUgZGlmZmljdWx0eSBtYXkgZXZlciBiZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlmZmljdWx0eUJvdW5kRGl2aXNvclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjA0OCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBib3VuZCBkaXZpc29yIG9mIHRoZSBkaWZmaWN1bHR5LCB1c2VkIGluIHRoZSB1cGRhdGUgY2FsY3VsYXRpb25zXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkdXJhdGlvbkxpbWl0XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIlRoZSBkZWNpc2lvbiBib3VuZGFyeSBvbiB0aGUgYmxvY2t0aW1lIGR1cmF0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgZGlmZmljdWx0eSBzaG91bGQgZ28gdXAgb3Igbm90XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlcG9jaER1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzMDAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkR1cmF0aW9uIGJldHdlZW4gcHJvb2Ytb2Ytd29yayBlcG9jaHNcIlxuICAgICAgICB9LFxuICAgICAgICBcInRpbWVib21iUGVyaW9kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJFeHBvbmVudGlhbCBkaWZmaWN1bHR5IHRpbWVib21iIHBlcmlvZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWluZXJSZXdhcmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IFwiNTAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgICAgXCJkXCI6IFwidGhlIGFtb3VudCBhIG1pbmVyIGdldCByZXdhcmRlZCBmb3IgbWluaW5nIGEgYmxvY2tcIlxuICAgICAgICB9LFxuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDAsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IG9mIGJsb2NrcyB0byBkZWxheSB0aGUgZGlmZmljdWx0eSBib21iIHdpdGhcIlxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcImNvbnN0YW50aW5vcGxlXCIsXG4gICAgXCJjb21tZW50XCI6IFwiUG9zdHBvbmVkIGhhcmRmb3JrIGluY2x1ZGluZyBFSVAtMTI4MyAoU1NUT1JFIGdhcyBtZXRlcmluZyBjaGFuZ2VzKVwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMDEzXCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJuZXRTc3RvcmVOb29wR2FzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGlmIHRoZSB2YWx1ZSBkb2Vzbid0IGNoYW5nZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibmV0U3N0b3JlSW5pdEdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogMjAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gemVyb1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibmV0U3N0b3JlQ2xlYW5HYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gbm9uLXplcm9cIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZURpcnR5R2FzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gZGlydHlcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZUNsZWFyUmVmdW5kXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxNTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIGNsZWFyaW5nIGFuIG9yaWdpbmFsbHkgZXhpc3Rpbmcgc3RvcmFnZSBzbG90XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZXRTc3RvcmVSZXNldFJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDgwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIHJlc2V0dGluZyB0byB0aGUgb3JpZ2luYWwgbm9uLXplcm8gdmFsdWVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZVJlc2V0Q2xlYXJSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDE5ODAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmb3IgcmVzZXR0aW5nIHRvIHRoZSBvcmlnaW5hbCB6ZXJvIHZhbHVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaGxcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDMsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0hMIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2hyXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAzLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNIUiBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNhclwiOiB7XG4gICAgICAgICAgICBcInZcIjogMyxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBTQVIgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRjb2RlaGFzaFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVIQVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY3JlYXRlMlwiOiB7XG4gICAgICAgICAgICBcInZcIjogMzIwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ1JFQVRFMiBvcGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHtcbiAgICAgICAgXCJtaW5lclJld2FyZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogXCIyMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgICBcImRcIjogXCJUaGUgYW1vdW50IGEgbWluZXIgZ2V0cyByZXdhcmRlZCBmb3IgbWluaW5nIGEgYmxvY2tcIlxuICAgICAgICB9LFxuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IG9mIGJsb2NrcyB0byBkZWxheSB0aGUgZGlmZmljdWx0eSBib21iIHdpdGhcIlxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcImRhb1wiLFxuICAgIFwiY29tbWVudFwiOiBcIkRBTyByZXNjdWUgaGFyZGZvcmtcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzc5XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJncmF5R2xhY2llclwiLFxuICAgIFwiY29tbWVudFwiOiBcIkRlbGF5aW5nIHRoZSBkaWZmaWN1bHR5IGJvbWIgdG8gTWlkIFNlcHRlbWJlciAyMDIyXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZXhlY3V0aW9uLXNwZWNzL2Jsb2IvbWFzdGVyL25ldHdvcmstdXBncmFkZXMvbWFpbm5ldC11cGdyYWRlcy9ncmF5LWdsYWNpZXIubWRcIixcbiAgICBcInN0YXR1c1wiOiBcIkRyYWZ0XCIsXG4gICAgXCJlaXBzXCI6IFs1MTMzXSxcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7fSxcbiAgICBcInZtXCI6IHt9LFxuICAgIFwicG93XCI6IHt9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiaG9tZXN0ZWFkXCIsXG4gICAgXCJjb21tZW50XCI6IFwiSG9tZXN0ZWFkIGhhcmRmb3JrIHdpdGggcHJvdG9jb2wgYW5kIG5ldHdvcmsgY2hhbmdlc1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02MDZcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImRlbGVnYXRlY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgREVMRUdBVEVDQUxMIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXJkZm9ya3MgPSB2b2lkIDA7XG5leHBvcnRzLmhhcmRmb3JrcyA9IHtcbiAgICBjaGFpbnN0YXJ0OiByZXF1aXJlKCcuL2NoYWluc3RhcnQuanNvbicpLFxuICAgIGhvbWVzdGVhZDogcmVxdWlyZSgnLi9ob21lc3RlYWQuanNvbicpLFxuICAgIGRhbzogcmVxdWlyZSgnLi9kYW8uanNvbicpLFxuICAgIHRhbmdlcmluZVdoaXN0bGU6IHJlcXVpcmUoJy4vdGFuZ2VyaW5lV2hpc3RsZS5qc29uJyksXG4gICAgc3B1cmlvdXNEcmFnb246IHJlcXVpcmUoJy4vc3B1cmlvdXNEcmFnb24uanNvbicpLFxuICAgIGJ5emFudGl1bTogcmVxdWlyZSgnLi9ieXphbnRpdW0uanNvbicpLFxuICAgIGNvbnN0YW50aW5vcGxlOiByZXF1aXJlKCcuL2NvbnN0YW50aW5vcGxlLmpzb24nKSxcbiAgICBwZXRlcnNidXJnOiByZXF1aXJlKCcuL3BldGVyc2J1cmcuanNvbicpLFxuICAgIGlzdGFuYnVsOiByZXF1aXJlKCcuL2lzdGFuYnVsLmpzb24nKSxcbiAgICBtdWlyR2xhY2llcjogcmVxdWlyZSgnLi9tdWlyR2xhY2llci5qc29uJyksXG4gICAgYmVybGluOiByZXF1aXJlKCcuL2Jlcmxpbi5qc29uJyksXG4gICAgbG9uZG9uOiByZXF1aXJlKCcuL2xvbmRvbi5qc29uJyksXG4gICAgc2hhbmdoYWk6IHJlcXVpcmUoJy4vc2hhbmdoYWkuanNvbicpLFxuICAgIGFycm93R2xhY2llcjogcmVxdWlyZSgnLi9hcnJvd0dsYWNpZXIuanNvbicpLFxuICAgIGdyYXlHbGFjaWVyOiByZXF1aXJlKCcuL2dyYXlHbGFjaWVyLmpzb24nKSxcbiAgICBtZXJnZUZvcmtJZFRyYW5zaXRpb246IHJlcXVpcmUoJy4vbWVyZ2VGb3JrSWRUcmFuc2l0aW9uLmpzb24nKSxcbiAgICBtZXJnZTogcmVxdWlyZSgnLi9tZXJnZS5qc29uJyksXG4gICAgc2hhcmRpbmdGb3JrOiByZXF1aXJlKCcuL3NoYXJkaW5nLmpzb24nKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwiaXN0YW5idWxcIixcbiAgICBcImNvbW1lbnRcIjogXCJIRiB0YXJnZXRlZCBmb3IgRGVjZW1iZXIgMjAxOSBmb2xsb3dpbmcgdGhlIENvbnN0YW50aW5vcGxlL1BldGVyc2J1cmcgSEZcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTY3OVwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwiYmxha2UyUm91bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDEsXG4gICAgICAgICAgICBcImRcIjogXCJHYXMgY29zdCBwZXIgcm91bmQgZm9yIHRoZSBCbGFrZTIgRiBwcmVjb21waWxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlY0FkZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTUwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3RzIGZvciBjdXJ2ZSBhZGRpdGlvbiBwcmVjb21waWxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlY011bFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNjAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkdhcyBjb3N0cyBmb3IgY3VydmUgbXVsdGlwbGljYXRpb24gcHJlY29tcGlsZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZWNQYWlyaW5nXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0NTAwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZ2FzIGNvc3RzIGZvciBjdXJ2ZSBwYWlyaW5nIHByZWNvbXBpbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImVjUGFpcmluZ1dvcmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDM0MDAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiR2FzIGNvc3RzIHJlZ2FyZGluZyBjdXJ2ZSBwYWlyaW5nIHByZWNvbXBpbGUgaW5wdXQgbGVuZ3RoXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eERhdGFOb25aZXJvXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAxNixcbiAgICAgICAgICAgIFwiZFwiOiBcIlBlciBieXRlIG9mIGRhdGEgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0aGF0IGlzIG5vdCBlcXVhbCB0byB6ZXJvLiBOT1RFOiBOb3QgcGF5YWJsZSBvbiBkYXRhIG9mIGNhbGxzIGJldHdlZW4gdHJhbnNhY3Rpb25zXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVTZW50cnlHYXNFSVAyMjAwXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyMzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiTWluaW11bSBnYXMgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgYW4gU1NUT1JFIGNhbGwsIG5vdCBjb25zdW1lZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlTm9vcEdhc0VJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgdGhlIHZhbHVlIGRvZXNuJ3QgY2hhbmdlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVEaXJ0eUdhc0VJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDgwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gaWYgYSBkaXJ0eSB2YWx1ZSBpcyBjaGFuZ2VkXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVJbml0R2FzRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gemVybyB0byBub24temVyb1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3N0b3JlSW5pdFJlZnVuZEVJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDE5MjAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU1NUT1JFIG9wZXJhdGlvbiBmb3IgcmVzZXR0aW5nIHRvIHRoZSBvcmlnaW5hbCB6ZXJvIHZhbHVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc3RvcmVDbGVhbkdhc0VJUDIyMDBcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZyb20gY2xlYW4gbm9uLXplcm8gdG8gc29tZXRoaW5nIGVsc2VcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZUNsZWFuUmVmdW5kRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNDIwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIk9uY2UgcGVyIFNTVE9SRSBvcGVyYXRpb24gZm9yIHJlc2V0dGluZyB0byB0aGUgb3JpZ2luYWwgbm9uLXplcm8gdmFsdWVcIlxuICAgICAgICB9LFxuICAgICAgICBcInNzdG9yZUNsZWFyUmVmdW5kRUlQMjIwMFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMTUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBTU1RPUkUgb3BlcmF0aW9uIGZvciBjbGVhcmluZyBhbiBvcmlnaW5hbGx5IGV4aXN0aW5nIHN0b3JhZ2Ugc2xvdFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmFsYW5jZVwiOiB7XG4gICAgICAgICAgICBcInZcIjogNzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEJBTEFOQ0Ugb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRjb2RlaGFzaFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIEVYVENPREVIQVNIIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2hhaW5pZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMixcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBDSEFJTklEIG9wY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2VsZmJhbGFuY2VcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0VMRkJBTEFOQ0Ugb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzbG9hZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogODAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIFNMT0FEIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJsb25kb25cIixcbiAgICBcImNvbW1lbnRcIjogXCJIRiB0YXJnZXRlZCBmb3IgSnVseSAyMDIxIGZvbGxvd2luZyB0aGUgQmVybGluIGZvcmtcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9ldGgxLjAtc3BlY3MvYmxvYi9tYXN0ZXIvbmV0d29yay11cGdyYWRlcy9tYWlubmV0LXVwZ3JhZGVzL2xvbmRvbi5tZFwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImVpcHNcIjogWzE1NTksIDMxOTgsIDM1MjksIDM1NDFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJuYW1lXCI6IFwibWVyZ2VcIixcbiAgICBcImNvbW1lbnRcIjogXCJIYXJkZm9yayB0byB1cGdyYWRlIHRoZSBjb25zZW5zdXMgbWVjaGFuaXNtIHRvIFByb29mLW9mLVN0YWtlXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZXhlY3V0aW9uLXNwZWNzL2Jsb2IvbWFzdGVyL25ldHdvcmstdXBncmFkZXMvbWFpbm5ldC11cGdyYWRlcy9tZXJnZS5tZFwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImNvbnNlbnN1c1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInBvc1wiLFxuICAgICAgICBcImFsZ29yaXRobVwiOiBcImNhc3BlclwiLFxuICAgICAgICBcImNhc3BlclwiOiB7fVxuICAgIH0sXG4gICAgXCJlaXBzXCI6IFszNjc1LCA0Mzk5XVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIm1lcmdlRm9ya0lkVHJhbnNpdGlvblwiLFxuICAgIFwiY29tbWVudFwiOiBcIlByZS1tZXJnZSBoYXJkZm9yayB0byBmb3JrIG9mZiBub24tdXBncmFkZWQgY2xpZW50c1wiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0zNjc1XCIsXG4gICAgXCJzdGF0dXNcIjogXCJEcmFmdFwiLFxuICAgIFwiZWlwc1wiOiBbXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcIm11aXJHbGFjaWVyXCIsXG4gICAgXCJjb21tZW50XCI6IFwiSEYgdG8gZGVsYXkgdGhlIGRpZmZpY3VsdHkgYm9tYlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yMzg0XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHt9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge1xuICAgICAgICBcImRpZmZpY3VsdHlCb21iRGVsYXlcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDkwMDAwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJ0aGUgYW1vdW50IG9mIGJsb2NrcyB0byBkZWxheSB0aGUgZGlmZmljdWx0eSBib21iIHdpdGhcIlxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInBldGVyc2J1cmdcIixcbiAgICBcImNvbW1lbnRcIjogXCJBa2EgY29uc3RhbnRpbm9wbGVGaXgsIHJlbW92ZXMgRUlQLTEyODMsIGFjdGl2YXRlIHRvZ2V0aGVyIHdpdGggb3IgYWZ0ZXIgY29uc3RhbnRpbm9wbGVcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTcxNlwiLFxuICAgIFwic3RhdHVzXCI6IFwiRmluYWxcIixcbiAgICBcImdhc0NvbmZpZ1wiOiB7fSxcbiAgICBcImdhc1ByaWNlc1wiOiB7XG4gICAgICAgIFwibmV0U3N0b3JlTm9vcEdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlJlbW92ZWQgYWxvbmcgRUlQLTEyODNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZUluaXRHYXNcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IG51bGwsXG4gICAgICAgICAgICBcImRcIjogXCJSZW1vdmVkIGFsb25nIEVJUC0xMjgzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZXRTc3RvcmVDbGVhbkdhc1wiOiB7XG4gICAgICAgICAgICBcInZcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlJlbW92ZWQgYWxvbmcgRUlQLTEyODNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZURpcnR5R2FzXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiBudWxsLFxuICAgICAgICAgICAgXCJkXCI6IFwiUmVtb3ZlZCBhbG9uZyBFSVAtMTI4M1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibmV0U3N0b3JlQ2xlYXJSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IG51bGwsXG4gICAgICAgICAgICBcImRcIjogXCJSZW1vdmVkIGFsb25nIEVJUC0xMjgzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZXRTc3RvcmVSZXNldFJlZnVuZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZFwiOiBcIlJlbW92ZWQgYWxvbmcgRUlQLTEyODNcIlxuICAgICAgICB9LFxuICAgICAgICBcIm5ldFNzdG9yZVJlc2V0Q2xlYXJSZWZ1bmRcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IG51bGwsXG4gICAgICAgICAgICBcImRcIjogXCJSZW1vdmVkIGFsb25nIEVJUC0xMjgzXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ2bVwiOiB7fSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInNoYW5naGFpXCIsXG4gICAgXCJjb21tZW50XCI6IFwiTmV4dCBmZWF0dXJlIGhhcmRmb3JrIGFmdGVyIHRoZSBtZXJnZSBoYXJkZm9yayBoYXZpbmcgd2l0aGRyYXdhbHMsIHdhcm0gY29pbmJhc2UsIHB1c2gwLCBsaW1pdC9tZXRlciBpbml0Y29kZVwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1zcGVjcy9ibG9iL21hc3Rlci9uZXR3b3JrLXVwZ3JhZGVzL21haW5uZXQtdXBncmFkZXMvc2hhbmdoYWkubWRcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJlaXBzXCI6IFszNjUxLCAzODU1LCAzODYwLCA0ODk1XVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInNoYXJkaW5nRm9ya1wiLFxuICAgIFwiY29tbWVudFwiOiBcIkludGVybmFsIGhhcmRmb3JrIHRvIHRlc3QgcHJvdG8tZGFua3NoYXJkaW5nIChkbyBub3QgdXNlIGluIHByb2R1Y3Rpb24pXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQ4NDRcIixcbiAgICBcInN0YXR1c1wiOiBcIkV4cGVyaW1lbnRhbFwiLFxuICAgIFwiZWlwc1wiOiBbNDg0NF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm5hbWVcIjogXCJzcHVyaW91c0RyYWdvblwiLFxuICAgIFwiY29tbWVudFwiOiBcIkhGIHdpdGggRUlQcyBmb3Igc2ltcGxlIHJlcGxheSBhdHRhY2sgcHJvdGVjdGlvbiwgRVhQIGNvc3QgaW5jcmVhc2UsIHN0YXRlIHRyaWUgY2xlYXJpbmcsIGNvbnRyYWN0IGNvZGUgc2l6ZSBsaW1pdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02MDdcIixcbiAgICBcInN0YXR1c1wiOiBcIkZpbmFsXCIsXG4gICAgXCJnYXNDb25maWdcIjoge30sXG4gICAgXCJnYXNQcmljZXNcIjoge1xuICAgICAgICBcImV4cEJ5dGVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwLFxuICAgICAgICAgICAgXCJkXCI6IFwiVGltZXMgY2VpbChsb2cyNTYoZXhwb25lbnQpKSBmb3IgdGhlIEVYUCBpbnN0cnVjdGlvblwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge1xuICAgICAgICBcIm1heENvZGVTaXplXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiAyNDU3NixcbiAgICAgICAgICAgIFwiZFwiOiBcIk1heGltdW0gbGVuZ3RoIG9mIGNvbnRyYWN0IGNvZGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInBvd1wiOiB7fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibmFtZVwiOiBcInRhbmdlcmluZVdoaXN0bGVcIixcbiAgICBcImNvbW1lbnRcIjogXCJIYXJkZm9yayB3aXRoIGdhcyBjb3N0IGNoYW5nZXMgZm9yIElPLWhlYXZ5IG9wZXJhdGlvbnNcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjA4XCIsXG4gICAgXCJzdGF0dXNcIjogXCJGaW5hbFwiLFxuICAgIFwiZ2FzQ29uZmlnXCI6IHt9LFxuICAgIFwiZ2FzUHJpY2VzXCI6IHtcbiAgICAgICAgXCJzbG9hZFwiOiB7XG4gICAgICAgICAgICBcInZcIjogMjAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiT25jZSBwZXIgU0xPQUQgb3BlcmF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA3MDAsXG4gICAgICAgICAgICBcImRcIjogXCJPbmNlIHBlciBDQUxMIG9wZXJhdGlvbiAmIG1lc3NhZ2UgY2FsbCB0cmFuc2FjdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0Y29kZXNpemVcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDcwMCxcbiAgICAgICAgICAgIFwiZFwiOiBcIkJhc2UgZmVlIG9mIHRoZSBFWFRDT0RFU0laRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImV4dGNvZGVjb3B5XCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA3MDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgRVhUQ09ERUNPUFkgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJiYWxhbmNlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA0MDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQkFMQU5DRSBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImRlbGVnYXRlY2FsbFwiOiB7XG4gICAgICAgICAgICBcInZcIjogNzAwLFxuICAgICAgICAgICAgXCJkXCI6IFwiQmFzZSBmZWUgb2YgdGhlIERFTEVHQVRFQ0FMTCBvcGNvZGVcIlxuICAgICAgICB9LFxuICAgICAgICBcImNhbGxjb2RlXCI6IHtcbiAgICAgICAgICAgIFwidlwiOiA3MDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgQ0FMTENPREUgb3Bjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZWxmZGVzdHJ1Y3RcIjoge1xuICAgICAgICAgICAgXCJ2XCI6IDUwMDAsXG4gICAgICAgICAgICBcImRcIjogXCJCYXNlIGZlZSBvZiB0aGUgU0VMRkRFU1RSVUNUIG9wY29kZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwidm1cIjoge30sXG4gICAgXCJwb3dcIjoge31cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlR2V0aEdlbmVzaXMgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbi8qKlxuICogVHJhbnNmb3JtcyBHZXRoIGZvcm1hdHRlZCBub25jZSAoaS5lLiBoZXggc3RyaW5nKSB0byA4IGJ5dGUgMHgtcHJlZml4ZWQgc3RyaW5nIHVzZWQgaW50ZXJuYWxseVxuICogQHBhcmFtIG5vbmNlIHN0cmluZyBwYXJzZWQgZnJvbSB0aGUgR2V0aCBnZW5lc2lzIGZpbGVcbiAqIEByZXR1cm5zIG5vbmNlIGFzIGEgMHgtcHJlZml4ZWQgOCBieXRlIHN0cmluZ1xuICovXG5mdW5jdGlvbiBmb3JtYXROb25jZShub25jZSkge1xuICAgIGlmICghbm9uY2UgfHwgbm9uY2UgPT09ICcweDAnKSB7XG4gICAgICAgIHJldHVybiAnMHgwMDAwMDAwMDAwMDAwMDAwJztcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsXzEuaXNIZXhQcmVmaXhlZCkobm9uY2UpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgKDAsIHV0aWxfMS5zdHJpcEhleFByZWZpeCkobm9uY2UpLnBhZFN0YXJ0KDE2LCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gJzB4JyArIG5vbmNlLnBhZFN0YXJ0KDE2LCAnMCcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBHZXRoIGdlbmVzaXMgcGFyYW1ldGVycyB0byBhbiBFdGhlcmV1bUpTIGNvbXBhdGlibGUgYENvbW1vbk9wdHNgIG9iamVjdFxuICogQHBhcmFtIGpzb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgR2V0aCBnZW5lc2lzIGZpbGVcbiAqIEBwYXJhbSBvcHRpb25hbCBtZXJnZUZvcmtJZFBvc3RNZXJnZSB3aGljaCBjbGFyaWZpZXMgdGhlIHBsYWNlbWVudCBvZiBNZXJnZUZvcmtJZFRyYW5zaXRpb25cbiAqIGhhcmRmb3JrLCB3aGljaCBieSBkZWZhdWx0IGlzIHBvc3QgbWVyZ2UgYXMgd2l0aCB0aGUgbWVyZ2VkIGV0aCBuZXR3b3JrcyBidXQgY291bGQgYWxzbyBjb21lXG4gKiBiZWZvcmUgbWVyZ2UgbGlrZSBpbiBraWxuIGdlbmVzaXNcbiAqIEByZXR1cm5zIGdlbmVzaXMgcGFyYW1ldGVycyBpbiBhIGBDb21tb25PcHRzYCBjb21wbGlhbnQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlR2V0aFBhcmFtcyhqc29uLCBtZXJnZUZvcmtJZFBvc3RNZXJnZSA9IHRydWUpIHtcbiAgICBjb25zdCB7IG5hbWUsIGNvbmZpZywgZGlmZmljdWx0eSwgbWl4SGFzaCwgZ2FzTGltaXQsIGNvaW5iYXNlLCBiYXNlRmVlUGVyR2FzLCB9ID0ganNvbjtcbiAgICBsZXQgeyBleHRyYURhdGEsIHRpbWVzdGFtcCwgbm9uY2UgfSA9IGpzb247XG4gICAgY29uc3QgZ2VuZXNpc1RpbWVzdGFtcCA9IE51bWJlcih0aW1lc3RhbXApO1xuICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gY29uZmlnO1xuICAgIC8vIGdldGggaXMgbm90IHN0cmljdGx5IHB1dHRpbmcgZW1wdHkgZmllbGRzIHdpdGggYSAweCBwcmVmaXhcbiAgICBpZiAoZXh0cmFEYXRhID09PSAnJykge1xuICAgICAgICBleHRyYURhdGEgPSAnMHgnO1xuICAgIH1cbiAgICAvLyBnZXRoIG1heSB1c2UgbnVtYmVyIGZvciB0aW1lc3RhbXBcbiAgICBpZiAoISgwLCB1dGlsXzEuaXNIZXhQcmVmaXhlZCkodGltZXN0YW1wKSkge1xuICAgICAgICB0aW1lc3RhbXAgPSAoMCwgdXRpbF8xLmludFRvSGV4KShwYXJzZUludCh0aW1lc3RhbXApKTtcbiAgICB9XG4gICAgLy8gZ2V0aCBtYXkgbm90IGdpdmUgdXMgYSBub25jZSBzdHJpY3RseSBmb3JtYXR0ZWQgdG8gYW4gOCBieXRlIGhleCBzdHJpbmdcbiAgICBpZiAobm9uY2UubGVuZ3RoICE9PSAxOCkge1xuICAgICAgICBub25jZSA9IGZvcm1hdE5vbmNlKG5vbmNlKTtcbiAgICB9XG4gICAgLy8gRUlQMTU1IGFuZCBFSVAxNTggYXJlIGJvdGggcGFydCBvZiBTcHVyaW91cyBEcmFnb24gaGFyZGZvcmsgYW5kIG11c3Qgb2NjdXIgYXQgdGhlIHNhbWUgdGltZVxuICAgIC8vIGJ1dCBoYXZlIGRpZmZlcmVudCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgaW4gZ2V0aCBnZW5lc2lzIHBhcmFtZXRlcnNcbiAgICBpZiAoY29uZmlnLmVpcDE1NUJsb2NrICE9PSBjb25maWcuZWlwMTU4QmxvY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFSVAxNTUgYmxvY2sgbnVtYmVyIG11c3QgZXF1YWwgRUlQIDE1OCBibG9jayBudW1iZXIgc2luY2UgYm90aCBhcmUgcGFydCBvZiBTcHVyaW91c0RyYWdvbiBoYXJkZm9yayBhbmQgdGhlIGNsaWVudCBvbmx5IHN1cHBvcnRzIGFjdGl2YXRpbmcgdGhlIGZ1bGwgaGFyZGZvcmsnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICBuZXR3b3JrSWQ6IGNoYWluSWQsXG4gICAgICAgIGdlbmVzaXM6IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBwYXJzZUludChnYXNMaW1pdCksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBwYXJzZUludChkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgbWl4SGFzaCxcbiAgICAgICAgICAgIGNvaW5iYXNlLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhcyxcbiAgICAgICAgfSxcbiAgICAgICAgaGFyZGZvcms6IHVuZGVmaW5lZCxcbiAgICAgICAgaGFyZGZvcmtzOiBbXSxcbiAgICAgICAgYm9vdHN0cmFwTm9kZXM6IFtdLFxuICAgICAgICBjb25zZW5zdXM6IGNvbmZpZy5jbGlxdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BvYScsXG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiAnY2xpcXVlJyxcbiAgICAgICAgICAgICAgICBjbGlxdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlY2VudCBnZXRoIGdlbmVzaXMgc2VlbXMgdG8gYmUgdXNpbmcgYmxvY2twZXJpb2RzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBlcG9jaGxlbmd0aCBmb3IgY2xpcXVlIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2hhY2ttZC5pby9QcVpnTXBua1NXQ1d2NWpvSm9GeW1RXG4gICAgICAgICAgICAgICAgICAgIHBlcmlvZDogY29uZmlnLmNsaXF1ZS5wZXJpb2QgPz8gY29uZmlnLmNsaXF1ZS5ibG9ja3BlcmlvZHNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIGVwb2NoOiBjb25maWcuY2xpcXVlLmVwb2NoID8/IGNvbmZpZy5jbGlxdWUuZXBvY2hsZW5ndGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb3cnLFxuICAgICAgICAgICAgICAgIGFsZ29yaXRobTogJ2V0aGFzaCcsXG4gICAgICAgICAgICAgICAgZXRoYXNoOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBmb3JrTWFwID0ge1xuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5Ib21lc3RlYWRdOiB7IG5hbWU6ICdob21lc3RlYWRCbG9jaycgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuRGFvXTogeyBuYW1lOiAnZGFvRm9ya0Jsb2NrJyB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5UYW5nZXJpbmVXaGlzdGxlXTogeyBuYW1lOiAnZWlwMTUwQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLlNwdXJpb3VzRHJhZ29uXTogeyBuYW1lOiAnZWlwMTU1QmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLkJ5emFudGl1bV06IHsgbmFtZTogJ2J5emFudGl1bUJsb2NrJyB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5Db25zdGFudGlub3BsZV06IHsgbmFtZTogJ2NvbnN0YW50aW5vcGxlQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLlBldGVyc2J1cmddOiB7IG5hbWU6ICdwZXRlcnNidXJnQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLklzdGFuYnVsXTogeyBuYW1lOiAnaXN0YW5idWxCbG9jaycgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuTXVpckdsYWNpZXJdOiB7IG5hbWU6ICdtdWlyR2xhY2llckJsb2NrJyB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5CZXJsaW5dOiB7IG5hbWU6ICdiZXJsaW5CbG9jaycgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuTG9uZG9uXTogeyBuYW1lOiAnbG9uZG9uQmxvY2snIH0sXG4gICAgICAgIFtlbnVtc18xLkhhcmRmb3JrLk1lcmdlRm9ya0lkVHJhbnNpdGlvbl06IHsgbmFtZTogJ21lcmdlRm9ya0Jsb2NrJywgcG9zdE1lcmdlOiBtZXJnZUZvcmtJZFBvc3RNZXJnZSB9LFxuICAgICAgICBbZW51bXNfMS5IYXJkZm9yay5TaGFuZ2hhaV06IHsgbmFtZTogJ3NoYW5naGFpVGltZScsIHBvc3RNZXJnZTogdHJ1ZSwgaXNUaW1lc3RhbXA6IHRydWUgfSxcbiAgICAgICAgW2VudW1zXzEuSGFyZGZvcmsuU2hhcmRpbmdGb3JrRGV2XTogeyBuYW1lOiAnc2hhcmRpbmdGb3JrVGltZScsIHBvc3RNZXJnZTogdHJ1ZSwgaXNUaW1lc3RhbXA6IHRydWUgfSxcbiAgICB9O1xuICAgIC8vIGZvcmtNYXBSZXYgaXMgdGhlIG1hcCBmcm9tIGNvbmZpZyBmaWVsZCBuYW1lIHRvIEhhcmRmb3JrXG4gICAgY29uc3QgZm9ya01hcFJldiA9IE9iamVjdC5rZXlzKGZvcmtNYXApLnJlZHVjZSgoYWNjLCBlbGVtKSA9PiB7XG4gICAgICAgIGFjY1tmb3JrTWFwW2VsZW1dLm5hbWVdID0gZWxlbTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgY29uZmlnSGFyZGZvcmtOYW1lcyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKChrZXkpID0+IGZvcmtNYXBSZXZba2V5XSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ1trZXldICE9PSB1bmRlZmluZWQgJiYgY29uZmlnW2tleV0gIT09IG51bGwpO1xuICAgIHBhcmFtcy5oYXJkZm9ya3MgPSBjb25maWdIYXJkZm9ya05hbWVzXG4gICAgICAgIC5tYXAoKG5hbWVCbG9jaykgPT4gKHtcbiAgICAgICAgbmFtZTogZm9ya01hcFJldltuYW1lQmxvY2tdLFxuICAgICAgICBibG9jazogZm9ya01hcFtmb3JrTWFwUmV2W25hbWVCbG9ja11dLmlzVGltZXN0YW1wID09PSB0cnVlIHx8IHR5cGVvZiBjb25maWdbbmFtZUJsb2NrXSAhPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBjb25maWdbbmFtZUJsb2NrXSxcbiAgICAgICAgdGltZXN0YW1wOiBmb3JrTWFwW2ZvcmtNYXBSZXZbbmFtZUJsb2NrXV0uaXNUaW1lc3RhbXAgPT09IHRydWUgJiYgdHlwZW9mIGNvbmZpZ1tuYW1lQmxvY2tdID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBjb25maWdbbmFtZUJsb2NrXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfSkpXG4gICAgICAgIC5maWx0ZXIoKGZvcmspID0+IGZvcmsuYmxvY2sgIT09IG51bGwgfHwgZm9yay50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCk7XG4gICAgcGFyYW1zLmhhcmRmb3Jrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS5ibG9jayA/PyBJbmZpbml0eSkgLSAoYi5ibG9jayA/PyBJbmZpbml0eSk7XG4gICAgfSk7XG4gICAgcGFyYW1zLmhhcmRmb3Jrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS50aW1lc3RhbXAgPz8gZ2VuZXNpc1RpbWVzdGFtcCkgLSAoYi50aW1lc3RhbXAgPz8gZ2VuZXNpc1RpbWVzdGFtcCk7XG4gICAgfSk7XG4gICAgaWYgKGNvbmZpZy50ZXJtaW5hbFRvdGFsRGlmZmljdWx0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEZvbGxvd2luZyBwb2ludHMgbmVlZCB0byBiZSBjb25zaWRlcmVkIGZvciBwbGFjZW1lbnQgb2YgbWVyZ2UgaGZcbiAgICAgICAgLy8gLSBNZXJnZSBoYXJkZm9yayBjYW4ndCBiZSBwbGFjZWQgYXQgZ2VuZXNpc1xuICAgICAgICAvLyAtIFBsYWNlIG1lcmdlIGhmIGJlZm9yZSBhbnkgaGFyZGZvcmtzIHRoYXQgcmVxdWlyZSBDTCBwYXJ0aWNpcGF0aW9uIGZvciBlLmcuIHdpdGhkcmF3YWxzXG4gICAgICAgIC8vIC0gTWVyZ2UgaGFyZGZvcmsgaGFzIHRvIGJlIHBsYWNlZCBqdXN0IGFmdGVyIGdlbmVzaXMgaWYgYW55IG9mIHRoZSBnZW5lc2lzIGhhcmRmb3JrcyBtYWtlIENMXG4gICAgICAgIC8vICAgbmVjZXNzYXJ5IGZvciBlLmcuIHdpdGhkcmF3YWxzXG4gICAgICAgIGNvbnN0IG1lcmdlQ29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogZW51bXNfMS5IYXJkZm9yay5NZXJnZSxcbiAgICAgICAgICAgIHR0ZDogY29uZmlnLnRlcm1pbmFsVG90YWxEaWZmaWN1bHR5LFxuICAgICAgICAgICAgYmxvY2s6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE1lcmdlIGhhcmRmb3JrIGhhcyB0byBiZSBwbGFjZWQgYmVmb3JlIGZpcnN0IGhhcmRmb3JrIHRoYXQgaXMgZGVwZW5kZW50IG9uIG1lcmdlXG4gICAgICAgIGNvbnN0IHBvc3RNZXJnZUluZGV4ID0gcGFyYW1zLmhhcmRmb3Jrcy5maW5kSW5kZXgoKGhmKSA9PiBmb3JrTWFwW2hmLm5hbWVdPy5wb3N0TWVyZ2UgPT09IHRydWUpO1xuICAgICAgICBpZiAocG9zdE1lcmdlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBwYXJhbXMuaGFyZGZvcmtzLnNwbGljZShwb3N0TWVyZ2VJbmRleCwgMCwgbWVyZ2VDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLmhhcmRmb3Jrcy5wdXNoKG1lcmdlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXRlc3RIYXJkZm9yayA9IHBhcmFtcy5oYXJkZm9ya3MubGVuZ3RoID4gMCA/IHBhcmFtcy5oYXJkZm9ya3Muc2xpY2UoLTEpWzBdIDogdW5kZWZpbmVkO1xuICAgIHBhcmFtcy5oYXJkZm9yayA9IGxhdGVzdEhhcmRmb3JrPy5uYW1lO1xuICAgIHBhcmFtcy5oYXJkZm9ya3MudW5zaGlmdCh7IG5hbWU6IGVudW1zXzEuSGFyZGZvcmsuQ2hhaW5zdGFydCwgYmxvY2s6IDAgfSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbi8qKlxuICogUGFyc2VzIGEgZ2VuZXNpcy5qc29uIGV4cG9ydGVkIGZyb20gR2V0aCBpbnRvIHBhcmFtZXRlcnMgZm9yIENvbW1vbiBpbnN0YW5jZVxuICogQHBhcmFtIGpzb24gcmVwcmVzZW50aW5nIHRoZSBHZXRoIGdlbmVzaXMgZmlsZVxuICogQHBhcmFtIG5hbWUgb3B0aW9uYWwgY2hhaW4gbmFtZVxuICogQHJldHVybnMgcGFyc2VkIHBhcmFtc1xuICovXG5mdW5jdGlvbiBwYXJzZUdldGhHZW5lc2lzKGpzb24sIG5hbWUsIG1lcmdlRm9ya0lkUG9zdE1lcmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKFsnY29uZmlnJywgJ2RpZmZpY3VsdHknLCAnZ2FzTGltaXQnLCAnYWxsb2MnXS5zb21lKChmaWVsZCkgPT4gIShmaWVsZCBpbiBqc29uKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQsIGV4cGVjdGVkIGdldGggZ2VuZXNpcyBmaWVsZHMgbWlzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzb24ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlR2V0aFBhcmFtcyhqc29uLCBtZXJnZUZvcmtJZFBvc3RNZXJnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcGFyc2luZyBwYXJhbWV0ZXJzIGZpbGU6ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbn1cbmV4cG9ydHMucGFyc2VHZXRoR2VuZXNpcyA9IHBhcnNlR2V0aEdlbmVzaXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJlY2gzMm0gPSBleHBvcnRzLmJlY2gzMiA9IHZvaWQgMDtcbmNvbnN0IEFMUEhBQkVUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJztcbmNvbnN0IEFMUEhBQkVUX01BUCA9IHt9O1xuZm9yIChsZXQgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuICAgIGNvbnN0IHggPSBBTFBIQUJFVC5jaGFyQXQoeik7XG4gICAgQUxQSEFCRVRfTUFQW3hdID0gejtcbn1cbmZ1bmN0aW9uIHBvbHltb2RTdGVwKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgcmV0dXJuICgoKHByZSAmIDB4MWZmZmZmZikgPDwgNSkgXlxuICAgICAgICAoLSgoYiA+PiAwKSAmIDEpICYgMHgzYjZhNTdiMikgXlxuICAgICAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuICAgICAgICAoLSgoYiA+PiAyKSAmIDEpICYgMHgxZWExMTlmYSkgXlxuICAgICAgICAoLSgoYiA+PiAzKSAmIDEpICYgMHgzZDQyMzNkZCkgXlxuICAgICAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMykpO1xufVxuZnVuY3Rpb24gcHJlZml4Q2hrKHByZWZpeCkge1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgcmV0dXJuICdJbnZhbGlkIHByZWZpeCAoJyArIHByZWZpeCArICcpJztcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHYgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeICh2ICYgMHgxZik7XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBjb252ZXJ0KGRhdGEsIGluQml0cywgb3V0Qml0cywgcGFkKSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgY29uc3QgbWF4ViA9ICgxIDw8IG91dEJpdHMpIC0gMTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgaW5CaXRzKSB8IGRhdGFbaV07XG4gICAgICAgIGJpdHMgKz0gaW5CaXRzO1xuICAgICAgICB3aGlsZSAoYml0cyA+PSBvdXRCaXRzKSB7XG4gICAgICAgICAgICBiaXRzIC09IG91dEJpdHM7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPj4gYml0cykgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFkKSB7XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4Vik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChiaXRzID49IGluQml0cylcbiAgICAgICAgICAgIHJldHVybiAnRXhjZXNzIHBhZGRpbmcnO1xuICAgICAgICBpZiAoKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4VilcbiAgICAgICAgICAgIHJldHVybiAnTm9uLXplcm8gcGFkZGluZyc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1dvcmRzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpO1xufVxuZnVuY3Rpb24gZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSB7XG4gICAgY29uc3QgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpXG4gICAgICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmcm9tV29yZHMod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbn1cbmZ1bmN0aW9uIGdldExpYnJhcnlGcm9tRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBsZXQgRU5DT0RJTkdfQ09OU1Q7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmVjaDMyJykge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDB4MmJjODMwYTM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0Jyk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBkZXRlcm1pbmUgY2hrIG1vZFxuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjaGspO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZml4ICsgJzEnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gd29yZHNbaV07XG4gICAgICAgICAgICBpZiAoeCA+PiA1ICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uIDUtYml0IHdvcmQnKTtcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB4O1xuICAgICAgICAgICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh4KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKTtcbiAgICAgICAgfVxuICAgICAgICBjaGsgXj0gRU5DT0RJTkdfQ09OU1Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGNoayA+PiAoKDUgLSBpKSAqIDUpKSAmIDB4MWY7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9fZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgTElNSVQgPSBMSU1JVCB8fCA5MDtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4KVxuICAgICAgICAgICAgcmV0dXJuIHN0ciArICcgdG9vIHNob3J0JztcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHJldHVybiAnRXhjZWVkcyBsZW5ndGggbGltaXQnO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdXBwZXJlZCA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gdXBwZXJlZClcbiAgICAgICAgICAgIHJldHVybiAnTWl4ZWQtY2FzZSBzdHJpbmcgJyArIHN0cjtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnTm8gc2VwYXJhdG9yIGNoYXJhY3RlciBmb3IgJyArIHN0cjtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICdNaXNzaW5nIHByZWZpeCBmb3IgJyArIHN0cjtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNwbGl0KTtcbiAgICAgICAgY29uc3Qgd29yZENoYXJzID0gc3RyLnNsaWNlKHNwbGl0ICsgMSk7XG4gICAgICAgIGlmICh3b3JkQ2hhcnMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHJldHVybiAnRGF0YSB0b28gc2hvcnQnO1xuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBjaGs7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gd29yZENoYXJzLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBBTFBIQUJFVF9NQVBbY107XG4gICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93biBjaGFyYWN0ZXIgJyArIGM7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gdjtcbiAgICAgICAgICAgIC8vIG5vdCBpbiB0aGUgY2hlY2tzdW0/XG4gICAgICAgICAgICBpZiAoaSArIDYgPj0gd29yZENoYXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoayAhPT0gRU5DT0RJTkdfQ09OU1QpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgY2hlY2tzdW0gZm9yICcgKyBzdHI7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIExJTUlUKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZGVjb2RlKHN0ciwgTElNSVQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlVW5zYWZlLFxuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgdG9Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICBmcm9tV29yZHMsXG4gICAgfTtcbn1cbmV4cG9ydHMuYmVjaDMyID0gZ2V0TGlicmFyeUZyb21FbmNvZGluZygnYmVjaDMyJyk7XG5leHBvcnRzLmJlY2gzMm0gPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzJtJyk7XG4iLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4xLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IG4ucyAqICgyIC0gaXNPZGQobikpIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIHhjID0geWM7XHJcbiAgICAgICAgeWMgPSB0O1xyXG4gICAgICAgIHkucyA9IC15LnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgICAgemMgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gemM7XHJcbiAgICAgICAgaSA9IHhjTDtcclxuICAgICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgICAgeWNMID0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkge1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgICB5YyA9IHhjO1xyXG4gICAgICAgIHhjID0gdDtcclxuICAgICAgICBiID0gYTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tID4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikge1xyXG4gICAgICAgICAgaSA9IGcxO1xyXG4gICAgICAgICAgZzEgPSBnMjtcclxuICAgICAgICAgIGcyID0gaTtcclxuICAgICAgICAgIGxlbiAtPSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSEEyID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuY2xhc3MgU0hBMiBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKG91dCk7XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaCgodiwgaSkgPT4gb3ZpZXcuc2V0VWludDMyKDQgKiBpLCB2LCBpc0xFKSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLlNIQTIgPSBTSEEyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZCA9IGV4cG9ydHMudG9CaWcgPSBleHBvcnRzLnNwbGl0ID0gZXhwb3J0cy5mcm9tQmlnID0gdm9pZCAwO1xuY29uc3QgVTMyX01BU0s2NCA9IEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIGwsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKGgsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIGwpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG4vLyBSZW1vdmluZyBcImV4cG9ydFwiIGhhcyA1JSBwZXJmIHBlbmFsdHkgLV8tXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZzogZXhwb3J0cy50b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gdm9pZCAwO1xuZXhwb3J0cy5jcnlwdG8gPSB7XG4gICAgbm9kZTogdW5kZWZpbmVkLFxuICAgIHdlYjogdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIHNlbGYgPyBzZWxmLmNyeXB0byA6IHVuZGVmaW5lZCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjU2ID0gdm9pZCAwO1xuY29uc3QgX3NoYTJfanNfMSA9IHJlcXVpcmUoXCIuL19zaGEyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZXhwb3J0cy5zaGFrZTEyOCA9IGV4cG9ydHMua2VjY2FrXzUxMiA9IGV4cG9ydHMua2VjY2FrXzM4NCA9IGV4cG9ydHMua2VjY2FrXzI1NiA9IGV4cG9ydHMua2VjY2FrXzIyNCA9IGV4cG9ydHMuc2hhM181MTIgPSBleHBvcnRzLnNoYTNfMzg0ID0gZXhwb3J0cy5zaGEzXzI1NiA9IGV4cG9ydHMuc2hhM18yMjQgPSBleHBvcnRzLktlY2NhayA9IGV4cG9ydHMua2VjY2FrUCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gX3U2NF9qc18xLmRlZmF1bHQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCSChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTSChoLCBsLCBzKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCTChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTTChoLCBsLCBzKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5udW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5ieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFRoZSBpbXBvcnQgaGVyZSBpcyB2aWEgdGhlIHBhY2thZ2UgbmFtZS4gVGhpcyBpcyB0byBlbnN1cmVcbi8vIHRoYXQgZXhwb3J0cyBtYXBwaW5nL3Jlc29sdXRpb24gZG9lcyBmYWxsIGludG8gcGxhY2UuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlcmUgaXMgYWxtb3N0IG5vIGJpZyBlbmRpYW4gaGFyZHdhcmUsIGJ1dCBqcyB0eXBlZCBhcnJheXMgdXNlcyBwbGF0Zm9ybSBzcGVjaWZpYyBlbmRpYW5uZXNzLlxuLy8gU28sIGp1c3QgdG8gYmUgc3VyZSBub3QgdG8gY29ycnVwdCBhbnl0aGluZy5cbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKVxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGlmICghKHVpbnQ4YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdkZWFkYmVlZicpXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4Jyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuIEhvd2V2ZXIsIGNhbGwgdG8gYXN5bmMgZnVuY3Rpb24gd2lsbCByZXR1cm4gUHJvbWlzZVxuLy8gd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvbiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHR5cGUgaXMgVWludDhBcnJheSAoZ290ICR7dHlwZW9mIGRhdGF9KWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobWVzc2FnZSkgPT4gaGFzaENvbnN0cnVjdG9yKCkudXBkYXRlKHRvQnl0ZXMobWVzc2FnZSkpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbi8qKlxuICogU2VjdXJlIFBSTkdcbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8ud2ViKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8ud2ViLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjcnlwdG9fMS5jcnlwdG8ubm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvXzEuY3J5cHRvLm5vZGUucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpLmJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTI1Nl8xLnNoYTI1Nik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gZXhwb3J0cy53cmFwSGFzaCA9IGV4cG9ydHMuZXF1YWxzQnl0ZXMgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9VdGY4ID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnRvSGV4ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRCeXRlcyA9IGV4cG9ydHMuYXNzZXJ0Qm9vbCA9IHZvaWQgMDtcbi8vIGJ1Zi50b1N0cmluZygnaGV4JykgLT4gdG9IZXgoYnVmKVxuY29uc3QgX2Fzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL19hc3NlcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgYXNzZXJ0Qm9vbCA9IF9hc3NlcnRfMS5kZWZhdWx0LmJvb2w7XG5leHBvcnRzLmFzc2VydEJvb2wgPSBhc3NlcnRCb29sO1xuY29uc3QgYXNzZXJ0Qnl0ZXMgPSBfYXNzZXJ0XzEuZGVmYXVsdC5ieXRlcztcbmV4cG9ydHMuYXNzZXJ0Qnl0ZXMgPSBhc3NlcnRCeXRlcztcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJieXRlc1RvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0hleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5ieXRlc1RvSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY29uY2F0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVWaWV3XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmNyZWF0ZVZpZXc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dGY4VG9CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi51dGY4VG9CeXRlczsgfSB9KTtcbi8vIGJ1Zi50b1N0cmluZygndXRmOCcpIC0+IGJ5dGVzVG9VdGY4KGJ1ZilcbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGRhdGEpIHtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYnl0ZXNUb1V0ZjggZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSk7XG59XG5leHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGRhdGEpIHtcbiAgICBjb25zdCBzbGljZWQgPSBkYXRhLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGRhdGEuc3Vic3RyaW5nKDIpIDogZGF0YTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoc2xpY2VkKTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBidWYuZXF1YWxzKGJ1ZjIpIC0+IGVxdWFsc0J5dGVzKGJ1ZiwgYnVmMilcbmZ1bmN0aW9uIGVxdWFsc0J5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmVxdWFsc0J5dGVzID0gZXF1YWxzQnl0ZXM7XG4vLyBJbnRlcm5hbCB1dGlsc1xuZnVuY3Rpb24gd3JhcEhhc2goaGFzaCkge1xuICAgIHJldHVybiAobXNnKSA9PiB7XG4gICAgICAgIF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzKG1zZyk7XG4gICAgICAgIHJldHVybiBoYXNoKG1zZyk7XG4gICAgfTtcbn1cbmV4cG9ydHMud3JhcEhhc2ggPSB3cmFwSGFzaDtcbmV4cG9ydHMuY3J5cHRvID0gKCgpID0+IHtcbiAgICBjb25zdCB3ZWJDcnlwdG8gPSB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIHNlbGYgPyBzZWxmLmNyeXB0byA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub2RlUmVxdWlyZSA9IHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZS5yZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgbW9kdWxlLnJlcXVpcmUuYmluZChtb2R1bGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IG5vZGVSZXF1aXJlICYmICF3ZWJDcnlwdG8gPyBub2RlUmVxdWlyZShcImNyeXB0b1wiKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgd2ViOiB3ZWJDcnlwdG9cbiAgICB9O1xufSkoKTtcbiIsIi8qKlxuICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cbiAqXG4gKiBAdmVyc2lvbiAwLjguMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJTlBVVF9FUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgRklOQUxJWkVfRVJST1IgPSAnZmluYWxpemUgYWxyZWFkeSBjYWxsZWQnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTNfTk9fV0lORE9XKSB7XG4gICAgV0lORE9XID0gZmFsc2U7XG4gIH1cbiAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuICBpZiAoTk9ERV9KUykge1xuICAgIHJvb3QgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoV0VCX1dPUktFUikge1xuICAgIHJvb3QgPSBzZWxmO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5KU19TSEEzX05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuICB2YXIgU0hBS0VfUEFERElORyA9IFszMSwgNzkzNiwgMjAzMTYxNiwgNTIwMDkzNjk2XTtcbiAgdmFyIENTSEFLRV9QQURESU5HID0gWzQsIDEwMjQsIDI2MjE0NCwgNjcxMDg4NjRdO1xuICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xuICB2YXIgUEFERElORyA9IFs2LCAxNTM2LCAzOTMyMTYsIDEwMDY2MzI5Nl07XG4gIHZhciBTSElGVCA9IFswLCA4LCAxNiwgMjRdO1xuICB2YXIgUkMgPSBbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSxcbiAgICAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsXG4gICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXG4gICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXG4gICAgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xuICB2YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xuICB2YXIgU0hBS0VfQklUUyA9IFsxMjgsIDI1Nl07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdidWZmZXInLCAnYXJyYXlCdWZmZXInLCAnYXJyYXknLCAnZGlnZXN0J107XG4gIHZhciBDU0hBS0VfQllURVBBRCA9IHtcbiAgICAnMTI4JzogMTY4LFxuICAgICcyNTYnOiAxMzZcbiAgfTtcblxuICBpZiAocm9vdC5KU19TSEEzX05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcgfHwgIUFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmJ1ZmZlciAmJiBvYmouYnVmZmVyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2NzaGFrZScgKyBiaXRzXS51cGRhdGUobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2ttYWMnICsgYml0c10udXBkYXRlKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZCwgY3JlYXRlTWV0aG9kLCBiaXRzLCBwYWRkaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlTWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAob3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlU2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICBpZiAoIW4gJiYgIXMpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHNbJ3NoYWtlJyArIGJpdHNdLmNyZWF0ZShvdXRwdXRCaXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoW24sIHNdLCB3KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cywgbiwgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdO1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG5ldyBLbWFjKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoWydLTUFDJywgc10sIHcpLmJ5dGVwYWQoW2tleV0sIHcpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UsIG91dHB1dEJpdHMsIHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKGtleSwgb3V0cHV0Qml0cywgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtcyA9IFtcbiAgICB7IG5hbWU6ICdrZWNjYWsnLCBwYWRkaW5nOiBLRUNDQUtfUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGEzJywgcGFkZGluZzogUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdjc2hha2UnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVDc2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdrbWFjJywgcGFkZGluZzogQ1NIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlS21hY01ldGhvZCB9XG4gIF07XG5cbiAgdmFyIG1ldGhvZHMgPSB7fSwgbWV0aG9kTmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZ29yaXRobXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tpXTtcbiAgICB2YXIgYml0cyA9IGFsZ29yaXRobS5iaXRzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYml0cy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArICdfJyArIGJpdHNbal07XG4gICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGFsZ29yaXRobS5jcmVhdGVNZXRob2QoYml0c1tqXSwgYWxnb3JpdGhtLnBhZGRpbmcpO1xuICAgICAgaWYgKGFsZ29yaXRobS5uYW1lICE9PSAnc2hhMycpIHtcbiAgICAgICAgdmFyIG5ld01ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArIGJpdHNbal07XG4gICAgICAgIG1ldGhvZE5hbWVzLnB1c2gobmV3TWV0aG9kTmFtZSk7XG4gICAgICAgIG1ldGhvZHNbbmV3TWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICB0aGlzLnMgPSBbXTtcbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIHRoaXMub3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XG4gICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJsb2NrID0gMDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gdGhpcy5ibG9ja0NvdW50IDw8IDI7XG4gICAgdGhpcy5vdXRwdXRCbG9ja3MgPSBvdXRwdXRCaXRzID4+IDU7XG4gICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkge1xuICAgICAgdGhpcy5zW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRklOQUxJWkVfRVJST1IpO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsXG4gICAgICBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBpbmRleCA9IDAsIHMgPSB0aGlzLnMsIGksIGNvZGU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLnJlc2V0KSB7XG4gICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgZihzKTtcbiAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoeCwgcmlnaHQpIHtcbiAgICB2YXIgbyA9IHggJiAyNTUsIG4gPSAxO1xuICAgIHZhciBieXRlcyA9IFtvXTtcbiAgICB4ID0geCA+PiA4O1xuICAgIG8gPSB4ICYgMjU1O1xuICAgIHdoaWxlIChvID4gMCkge1xuICAgICAgYnl0ZXMudW5zaGlmdChvKTtcbiAgICAgIHggPSB4ID4+IDg7XG4gICAgICBvID0geCAmIDI1NTtcbiAgICAgICsrbjtcbiAgICB9XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICBieXRlcy5wdXNoKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG4pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzLmxlbmd0aDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIHN0cjtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgc3RyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHN0ciA9IG5ldyBVaW50OEFycmF5KHN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc3RyKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYnl0ZXMgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgIGJ5dGVzID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICBieXRlcyArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpKTtcbiAgICAgICAgICBieXRlcyArPSA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlKGJ5dGVzICogOCk7XG4gICAgdGhpcy51cGRhdGUoc3RyKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5ieXRlcGFkID0gZnVuY3Rpb24gKHN0cnMsIHcpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmVuY29kZSh3KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlU3RyaW5nKHN0cnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcGFkZGluZ0J5dGVzID0gdyAtIGJ5dGVzICUgdztcbiAgICB2YXIgemVyb3MgPSBbXTtcbiAgICB6ZXJvcy5sZW5ndGggPSBwYWRkaW5nQnl0ZXM7XG4gICAgdGhpcy51cGRhdGUoemVyb3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnM7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gdGhpcy5wYWRkaW5nW2kgJiAzXTtcbiAgICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgYmxvY2tzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xuICAgIH1cbiAgICBmKHMpO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUudG9TdHJpbmcgPSBLZWNjYWsucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGhleCA9ICcnLCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAyNCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgICBpID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXTtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5vdXRwdXRCaXRzID4+IDM7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKChvdXRwdXRCbG9ja3MgKyAxKSA8PCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICAgIGFycmF5W2pdID0gc1tpXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYXJyYXlbaV0gPSBzW2ldO1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5kaWdlc3QgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSAoYmxvY2sgPj4gMjQpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xuICAgIEtlY2Nhay5jYWxsKHRoaXMsIGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpO1xuICB9XG5cbiAgS21hYy5wcm90b3R5cGUgPSBuZXcgS2VjY2FrKCk7XG5cbiAgS21hYy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmNvZGUodGhpcy5vdXRwdXRCaXRzLCB0cnVlKTtcbiAgICByZXR1cm4gS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHZhciBmID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksXG4gICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXG4gICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXG4gICAgICBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XG4gICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcbiAgICAgIGMwID0gc1swXSBeIHNbMTBdIF4gc1syMF0gXiBzWzMwXSBeIHNbNDBdO1xuICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XG4gICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcbiAgICAgIGMzID0gc1szXSBeIHNbMTNdIF4gc1syM10gXiBzWzMzXSBeIHNbNDNdO1xuICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XG4gICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcbiAgICAgIGM2ID0gc1s2XSBeIHNbMTZdIF4gc1syNl0gXiBzWzM2XSBeIHNbNDZdO1xuICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XG4gICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcbiAgICAgIGM5ID0gc1s5XSBeIHNbMTldIF4gc1syOV0gXiBzWzM5XSBeIHNbNDldO1xuXG4gICAgICBoID0gYzggXiAoKGMyIDw8IDEpIHwgKGMzID4+PiAzMSkpO1xuICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcbiAgICAgIHNbMF0gXj0gaDtcbiAgICAgIHNbMV0gXj0gbDtcbiAgICAgIHNbMTBdIF49IGg7XG4gICAgICBzWzExXSBePSBsO1xuICAgICAgc1syMF0gXj0gaDtcbiAgICAgIHNbMjFdIF49IGw7XG4gICAgICBzWzMwXSBePSBoO1xuICAgICAgc1szMV0gXj0gbDtcbiAgICAgIHNbNDBdIF49IGg7XG4gICAgICBzWzQxXSBePSBsO1xuICAgICAgaCA9IGMwIF4gKChjNCA8PCAxKSB8IChjNSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XG4gICAgICBzWzJdIF49IGg7XG4gICAgICBzWzNdIF49IGw7XG4gICAgICBzWzEyXSBePSBoO1xuICAgICAgc1sxM10gXj0gbDtcbiAgICAgIHNbMjJdIF49IGg7XG4gICAgICBzWzIzXSBePSBsO1xuICAgICAgc1szMl0gXj0gaDtcbiAgICAgIHNbMzNdIF49IGw7XG4gICAgICBzWzQyXSBePSBoO1xuICAgICAgc1s0M10gXj0gbDtcbiAgICAgIGggPSBjMiBeICgoYzYgPDwgMSkgfCAoYzcgPj4+IDMxKSk7XG4gICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xuICAgICAgc1s0XSBePSBoO1xuICAgICAgc1s1XSBePSBsO1xuICAgICAgc1sxNF0gXj0gaDtcbiAgICAgIHNbMTVdIF49IGw7XG4gICAgICBzWzI0XSBePSBoO1xuICAgICAgc1syNV0gXj0gbDtcbiAgICAgIHNbMzRdIF49IGg7XG4gICAgICBzWzM1XSBePSBsO1xuICAgICAgc1s0NF0gXj0gaDtcbiAgICAgIHNbNDVdIF49IGw7XG4gICAgICBoID0gYzQgXiAoKGM4IDw8IDEpIHwgKGM5ID4+PiAzMSkpO1xuICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcbiAgICAgIHNbNl0gXj0gaDtcbiAgICAgIHNbN10gXj0gbDtcbiAgICAgIHNbMTZdIF49IGg7XG4gICAgICBzWzE3XSBePSBsO1xuICAgICAgc1syNl0gXj0gaDtcbiAgICAgIHNbMjddIF49IGw7XG4gICAgICBzWzM2XSBePSBoO1xuICAgICAgc1szN10gXj0gbDtcbiAgICAgIHNbNDZdIF49IGg7XG4gICAgICBzWzQ3XSBePSBsO1xuICAgICAgaCA9IGM2IF4gKChjMCA8PCAxKSB8IChjMSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XG4gICAgICBzWzhdIF49IGg7XG4gICAgICBzWzldIF49IGw7XG4gICAgICBzWzE4XSBePSBoO1xuICAgICAgc1sxOV0gXj0gbDtcbiAgICAgIHNbMjhdIF49IGg7XG4gICAgICBzWzI5XSBePSBsO1xuICAgICAgc1szOF0gXj0gaDtcbiAgICAgIHNbMzldIF49IGw7XG4gICAgICBzWzQ4XSBePSBoO1xuICAgICAgc1s0OV0gXj0gbDtcblxuICAgICAgYjAgPSBzWzBdO1xuICAgICAgYjEgPSBzWzFdO1xuICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XG4gICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTtcbiAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpO1xuICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XG4gICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTtcbiAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpO1xuICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xuICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpO1xuICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpO1xuICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xuICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7XG4gICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTtcbiAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcbiAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTtcbiAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTtcbiAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcbiAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApO1xuICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7XG4gICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XG4gICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7XG4gICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTtcbiAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xuICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7XG4gICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTtcbiAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcbiAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTtcbiAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpO1xuICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XG4gICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7XG4gICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7XG4gICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcbiAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpO1xuICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7XG4gICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcbiAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpO1xuICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7XG4gICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcbiAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpO1xuICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpO1xuICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xuICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpO1xuICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpO1xuICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XG4gICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTtcbiAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpO1xuICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XG4gICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTtcbiAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpO1xuXG4gICAgICBzWzBdID0gYjAgXiAofmIyICYgYjQpO1xuICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcbiAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xuICAgICAgc1sxMV0gPSBiMTEgXiAofmIxMyAmIGIxNSk7XG4gICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcbiAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xuICAgICAgc1szMF0gPSBiMzAgXiAofmIzMiAmIGIzNCk7XG4gICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcbiAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xuICAgICAgc1s0MV0gPSBiNDEgXiAofmI0MyAmIGI0NSk7XG4gICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xuICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcbiAgICAgIHNbMTJdID0gYjEyIF4gKH5iMTQgJiBiMTYpO1xuICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XG4gICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcbiAgICAgIHNbMjNdID0gYjIzIF4gKH5iMjUgJiBiMjcpO1xuICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XG4gICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcbiAgICAgIHNbNDJdID0gYjQyIF4gKH5iNDQgJiBiNDYpO1xuICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XG4gICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xuICAgICAgc1s1XSA9IGI1IF4gKH5iNyAmIGI5KTtcbiAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xuICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XG4gICAgICBzWzI0XSA9IGIyNCBeICh+YjI2ICYgYjI4KTtcbiAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xuICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XG4gICAgICBzWzM1XSA9IGIzNSBeICh+YjM3ICYgYjM5KTtcbiAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xuICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XG4gICAgICBzWzZdID0gYjYgXiAofmI4ICYgYjApO1xuICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcbiAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xuICAgICAgc1sxN10gPSBiMTcgXiAofmIxOSAmIGIxMSk7XG4gICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcbiAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xuICAgICAgc1szNl0gPSBiMzYgXiAofmIzOCAmIGIzMCk7XG4gICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcbiAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xuICAgICAgc1s0N10gPSBiNDcgXiAofmI0OSAmIGI0MSk7XG4gICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xuICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcbiAgICAgIHNbMThdID0gYjE4IF4gKH5iMTAgJiBiMTIpO1xuICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XG4gICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcbiAgICAgIHNbMjldID0gYjI5IF4gKH5iMjEgJiBiMjMpO1xuICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XG4gICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcbiAgICAgIHNbNDhdID0gYjQ4IF4gKH5iNDAgJiBiNDIpO1xuICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XG5cbiAgICAgIHNbMF0gXj0gUkNbbl07XG4gICAgICBzWzFdIF49IFJDW24gKyAxXTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJvb3RbbWV0aG9kTmFtZXNbaV1dID0gbWV0aG9kc1ttZXRob2ROYW1lc1tpXV07XG4gICAgfVxuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0aWxzID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbi8qKlxuICogUkxQIEVuY29kaW5nIGJhc2VkIG9uIGh0dHBzOi8vZXRoLndpa2kvZW4vZnVuZGFtZW50YWxzL3JscFxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiBkYXRhLCBjb252ZXJ0cyBpdCB0byBVaW50OEFycmF5IGlmIG5vdCxcbiAqIGFuZCBhZGRzIGEgbGVuZ3RoIGZvciByZWN1cnNpb24uXG4gKiBAcGFyYW0gaW5wdXQgV2lsbCBiZSBjb252ZXJ0ZWQgdG8gVWludDhBcnJheVxuICogQHJldHVybnMgVWludDhBcnJheSBvZiBlbmNvZGVkIGRhdGFcbiAqKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goZW5jb2RlKGlucHV0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gY29uY2F0Qnl0ZXMoLi4ub3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKGVuY29kZUxlbmd0aChidWYubGVuZ3RoLCAxOTIpLCBidWYpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEJ1ZiA9IHRvQnl0ZXMoaW5wdXQpO1xuICAgIGlmIChpbnB1dEJ1Zi5sZW5ndGggPT09IDEgJiYgaW5wdXRCdWZbMF0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0QnVmO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKGlucHV0QnVmLmxlbmd0aCwgMTI4KSwgaW5wdXRCdWYpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFNsaWNlcyBhIFVpbnQ4QXJyYXksIHRocm93cyBpZiB0aGUgc2xpY2UgZ29lcyBvdXQtb2YtYm91bmRzIG9mIHRoZSBVaW50OEFycmF5LlxuICogRS5nLiBgc2FmZVNsaWNlKGhleFRvQnl0ZXMoJ2FhJyksIDEsIDIpYCB3aWxsIHRocm93LlxuICogQHBhcmFtIGlucHV0XG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqL1xuZnVuY3Rpb24gc2FmZVNsaWNlKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQIChzYWZlU2xpY2UpOiBlbmQgc2xpY2Ugb2YgVWludDhBcnJheSBvdXQtb2YtYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5zbGljZShzdGFydCwgZW5kKTtcbn1cbi8qKlxuICogUGFyc2UgaW50ZWdlcnMuIENoZWNrIGlmIHRoZXJlIGlzIG5vIGxlYWRpbmcgemVyb3NcbiAqIEBwYXJhbSB2IFRoZSB2YWx1ZSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgodikge1xuICAgIGlmICh2WzBdID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4dHJhIHplcm9zJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUhleEJ5dGUoYnl0ZXNUb0hleCh2KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcbiAgICBpZiAobGVuIDwgNTYpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbbGVuICsgb2Zmc2V0XSk7XG4gICAgfVxuICAgIGNvbnN0IGhleExlbmd0aCA9IG51bWJlclRvSGV4KGxlbik7XG4gICAgY29uc3QgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IG51bWJlclRvSGV4KG9mZnNldCArIDU1ICsgbExlbmd0aCk7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoZXhUb0J5dGVzKGZpcnN0Qnl0ZSArIGhleExlbmd0aCkpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBzdHJlYW0gPSBmYWxzZSkge1xuICAgIGlmICghaW5wdXQgfHwgaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEJ5dGVzID0gdG9CeXRlcyhpbnB1dCk7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoaW5wdXRCeXRlcyk7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG4gICAgaWYgKGRlY29kZWQucmVtYWluZGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiByZW1haW5kZXIgbXVzdCBiZSB6ZXJvJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLmRhdGE7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKiBEZWNvZGUgYW4gaW5wdXQgd2l0aCBSTFAgKi9cbmZ1bmN0aW9uIF9kZWNvZGUoaW5wdXQpIHtcbiAgICBsZXQgbGVuZ3RoLCBsbGVuZ3RoLCBkYXRhLCBpbm5lclJlbWFpbmRlciwgZDtcbiAgICBjb25zdCBkZWNvZGVkID0gW107XG4gICAgY29uc3QgZmlyc3RCeXRlID0gaW5wdXRbMF07XG4gICAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgICAgIC8vIGEgc2luZ2xlIGJ5dGUgd2hvc2UgdmFsdWUgaXMgaW4gdGhlIFsweDAwLCAweDdmXSByYW5nZSwgdGhhdCBieXRlIGlzIGl0cyBvd24gUkxQIGVuY29kaW5nLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogaW5wdXQuc2xpY2UoMCwgMSksXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiNykge1xuICAgICAgICAvLyBzdHJpbmcgaXMgMC01NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdmFsdWUgMHg4MCBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgICAgIC8vIFRoZSByYW5nZSBvZiB0aGUgZmlyc3QgYnl0ZSBpcyBbMHg4MCwgMHhiN11cbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHg3ZjtcbiAgICAgICAgLy8gc2V0IDB4ODAgbnVsbCB0byAwXG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDB4ODApIHtcbiAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHNhZmVTbGljZShpbnB1dCwgMSwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSAyICYmIGRhdGFbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQIGVuY29kaW5nOiBpbnZhbGlkIHByZWZpeCwgc2luZ2xlIGJ5dGUgPCAweDgwIGFyZSBub3QgcHJlZml4ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YmYpIHtcbiAgICAgICAgLy8gc3RyaW5nIGlzIGdyZWF0ZXIgdGhhbiA1NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdGhlIHZhbHVlICgweGI3IHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgbGVuZ3RoKSxcbiAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhlIGxlbmd0aCwgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiNjtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCAtIDEgPCBsbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBub3QgZW5vdWdoIGJ5dGVzIGZvciBzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gZGVjb2RlTGVuZ3RoKHNhZmVTbGljZShpbnB1dCwgMSwgbGxlbmd0aCkpO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHBlY3RlZCBzdHJpbmcgbGVuZ3RoIHRvIGJlIGdyZWF0ZXIgdGhhbiA1NScpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBzYWZlU2xpY2UoaW5wdXQsIGxsZW5ndGgsIGxlbmd0aCArIGxsZW5ndGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoICsgbGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGY3KSB7XG4gICAgICAgIC8vIGEgbGlzdCBiZXR3ZWVuIDAtNTUgYnl0ZXMgbG9uZ1xuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGJmO1xuICAgICAgICBpbm5lclJlbWFpbmRlciA9IHNhZmVTbGljZShpbnB1dCwgMSwgbGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYSBsaXN0IG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcbiAgICAgICAgbGVuZ3RoID0gZGVjb2RlTGVuZ3RoKHNhZmVTbGljZShpbnB1dCwgMSwgbGxlbmd0aCkpO1xuICAgICAgICBpZiAobGVuZ3RoIDwgNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGVuY29kZWQgbGlzdCB0b28gc2hvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IGxsZW5ndGggKyBsZW5ndGg7XG4gICAgICAgIGlmICh0b3RhbExlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogdG90YWwgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIHRoZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBzYWZlU2xpY2UoaW5wdXQsIGxsZW5ndGgsIHRvdGFsTGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSh0b3RhbExlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3QgY2FjaGVkSGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF92LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgLy8gUHJlLWNhY2hpbmcgY2hhcnMgd2l0aCBgY2FjaGVkSGV4ZXNgIHNwZWVkcyB0aGlzIHVwIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBjYWNoZWRIZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gcGFyc2VIZXhCeXRlKGhleEJ5dGUpIHtcbiAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgIHJldHVybiBieXRlO1xufVxuLy8gQ2FjaGluZyBzbG93cyBpdCBkb3duIDItM3hcbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4Jyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGFycmF5W2ldID0gcGFyc2VIZXhCeXRlKGhleC5zbGljZShqLCBqICsgMikpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vKiogQ29uY2F0ZW5hdGVzIHR3byBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyh1dGYpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHV0Zik7XG59XG4vKiogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBpdHMgaGV4YWRlY2ltYWwgdmFsdWUgKi9cbmZ1bmN0aW9uIG51bWJlclRvSGV4KGludGVnZXIpIHtcbiAgICBpZiAoaW50ZWdlciA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgYXMgYXJndW1lbnQsIG11c3QgYmUgdW5zaWduZWQhJyk7XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbi8qKiBQYWQgYSBzdHJpbmcgdG8gYmUgZXZlbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKGEpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggJSAyID8gYDAke2F9YCA6IGE7XG59XG4vKiogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgcHJlZml4ZWQgYnkgMHggKi9cbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPj0gMiAmJiBzdHJbMF0gPT09ICcwJyAmJiBzdHJbMV0gPT09ICd4Jztcbn1cbi8qKiBSZW1vdmVzIDB4IGZyb20gYSBnaXZlbiBTdHJpbmcgKi9cbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufVxuLyoqIFRyYW5zZm9ybSBhbnl0aGluZyBpbnRvIGEgVWludDhBcnJheSAqL1xuZnVuY3Rpb24gdG9CeXRlcyh2KSB7XG4gICAgaWYgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChpc0hleFByZWZpeGVkKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyhwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgodikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXModik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXgodikpO1xuICAgIH1cbiAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndG9CeXRlczogcmVjZWl2ZWQgdW5zdXBwb3J0ZWQgdHlwZSAnICsgdHlwZW9mIHYpO1xufVxuZXhwb3J0cy51dGlscyA9IHtcbiAgICBieXRlc1RvSGV4LFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIGhleFRvQnl0ZXMsXG4gICAgdXRmOFRvQnl0ZXMsXG59O1xuY29uc3QgUkxQID0geyBlbmNvZGUsIGRlY29kZSB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gUkxQO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpKHJlcXVpcmUoJy4vbGliL2VsbGlwdGljJykpXG4iLCJjb25zdCBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcblxuY29uc3QgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpXG5jb25zdCBlY3BhcmFtcyA9IGVjLmN1cnZlXG5cbi8vIEhhY2ssIHdlIGNhbiBub3QgdXNlIGJuLmpzQDUsIHdoaWxlIGVsbGlwdGljIHVzZXMgYm4uanNANFxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljL2lzc3Vlcy8xOTEjaXNzdWVjb21tZW50LTU2OTg4ODc1OFxuY29uc3QgQk4gPSBlY3BhcmFtcy5uLmNvbnN0cnVjdG9yXG5cbmZ1bmN0aW9uIGxvYWRDb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeGJ1Zikge1xuICBsZXQgeCA9IG5ldyBCTih4YnVmKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwKSByZXR1cm4gbnVsbFxuICB4ID0geC50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gY29tcHV0ZSBjb3JyZXNwb25kaW5nIFlcbiAgbGV0IHkgPSB4LnJlZFNxcigpLnJlZElNdWwoeCkucmVkSUFkZChlY3BhcmFtcy5iKS5yZWRTcXJ0KClcbiAgaWYgKChmaXJzdCA9PT0gMHgwMykgIT09IHkuaXNPZGQoKSkgeSA9IHkucmVkTmVnKClcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleSAoZmlyc3QsIHhidWYsIHlidWYpIHtcbiAgbGV0IHggPSBuZXcgQk4oeGJ1ZilcbiAgbGV0IHkgPSBuZXcgQk4oeWJ1ZilcblxuICAvLyBvdmVyZmxvd1xuICBpZiAoeC5jbXAoZWNwYXJhbXMucCkgPj0gMCB8fCB5LmNtcChlY3BhcmFtcy5wKSA+PSAwKSByZXR1cm4gbnVsbFxuXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcbiAgeSA9IHkudG9SZWQoZWNwYXJhbXMucmVkKVxuXG4gIC8vIGlzIG9kZCBmbGFnXG4gIGlmICgoZmlyc3QgPT09IDB4MDYgfHwgZmlyc3QgPT09IDB4MDcpICYmIHkuaXNPZGQoKSAhPT0gKGZpcnN0ID09PSAweDA3KSkgcmV0dXJuIG51bGxcblxuICAvLyB4KngqeCArIGIgPSB5KnlcbiAgY29uc3QgeDMgPSB4LnJlZFNxcigpLnJlZElNdWwoeClcbiAgaWYgKCF5LnJlZFNxcigpLnJlZElTdWIoeDMucmVkSUFkZChlY3BhcmFtcy5iKSkuaXNaZXJvKCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkgKHB1YmtleSkge1xuICAvLyBsZW5ndGggc2hvdWxkIGJlIHZhbGlkYXRlZCBpbiBpbnRlcmZhY2VcbiAgY29uc3QgZmlyc3QgPSBwdWJrZXlbMF1cbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHgwMjpcbiAgICBjYXNlIDB4MDM6XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCAhPT0gMzMpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmtleS5zdWJhcnJheSgxLCAzMykpXG4gICAgY2FzZSAweDA0OlxuICAgIGNhc2UgMHgwNjpcbiAgICBjYXNlIDB4MDc6XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCAhPT0gNjUpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVia2V5LnN1YmFycmF5KDEsIDMzKSwgcHVia2V5LnN1YmFycmF5KDMzLCA2NSkpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZVB1YmxpY0tleSAob3V0cHV0LCBwb2ludCkge1xuICBjb25zdCBwdWJrZXkgPSBwb2ludC5lbmNvZGUobnVsbCwgb3V0cHV0Lmxlbmd0aCA9PT0gMzMpXG4gIC8vIExvb3Agc2hvdWxkIGJlIGZhc3RlciBiZWNhdXNlIHdlIGRvIG5vdCBuZWVkIGNyZWF0ZSBleHRyYSBVaW50OEFycmF5XG4gIC8vIG91dHB1dC5zZXQobmV3IFVpbnQ4QXJyYXkocHVia2V5KSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyArK2kpIG91dHB1dFtpXSA9IHB1YmtleVtpXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGV4dFJhbmRvbWl6ZSAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VmVyaWZ5IChzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgcmV0dXJuIGJuLmNtcChlY3BhcmFtcy5uKSA8IDAgJiYgIWJuLmlzWmVybygpID8gMCA6IDFcbiAgfSxcblxuICBwcml2YXRlS2V5TmVnYXRlIChzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgY29uc3QgbmVnYXRlID0gZWNwYXJhbXMubi5zdWIoYm4pLnVtb2QoZWNwYXJhbXMubikudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldChuZWdhdGUpXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VHdlYWtBZGQgKHNlY2tleSwgdHdlYWspIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBibi5pYWRkKG5ldyBCTihzZWNrZXkpKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4uaXN1YihlY3BhcmFtcy5uKVxuICAgIGlmIChibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHR3ZWFrZWQgPSBibi50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KHR3ZWFrZWQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlUd2Vha011bCAoc2Vja2V5LCB0d2Vhaykge1xuICAgIGxldCBibiA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBibi5pbXVsKG5ldyBCTihzZWNrZXkpKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4gPSBibi51bW9kKGVjcGFyYW1zLm4pXG5cbiAgICBjb25zdCB0d2Vha2VkID0gYm4udG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldCh0d2Vha2VkKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlWZXJpZnkgKHB1YmtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICByZXR1cm4gcGFpciA9PT0gbnVsbCA/IDEgOiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q3JlYXRlIChvdXRwdXQsIHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IGVjLmtleUZyb21Qcml2YXRlKHNlY2tleSkuZ2V0UHVibGljKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleUNvbnZlcnQgKG91dHB1dCwgcHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlOZWdhdGUgKG91dHB1dCwgcHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgcG9pbnQueSA9IHBvaW50LnkucmVkTmVnKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleUNvbWJpbmUgKG91dHB1dCwgcHVia2V5cykge1xuICAgIGNvbnN0IHBhaXJzID0gbmV3IEFycmF5KHB1YmtleXMubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVia2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgcGFpcnNbaV0gPSBsb2FkUHVibGljS2V5KHB1YmtleXNbaV0pXG4gICAgICBpZiAocGFpcnNbaV0gPT09IG51bGwpIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGV0IHBvaW50ID0gcGFpcnNbMF0uZ2V0UHVibGljKClcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhaXJzLmxlbmd0aDsgKytpKSBwb2ludCA9IHBvaW50LmFkZChwYWlyc1tpXS5wdWIpXG4gICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgcmV0dXJuIDJcblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VHdlYWtBZGQgKG91dHB1dCwgcHVia2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5hZGQoZWNwYXJhbXMuZy5tdWwodHdlYWspKVxuICAgIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHJldHVybiAyXG5cbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVR3ZWFrTXVsIChvdXRwdXQsIHB1YmtleSwgdHdlYWspIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAodHdlYWsuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgdHdlYWsuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkubXVsKHR3ZWFrKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgc2lnbmF0dXJlTm9ybWFsaXplIChzaWcpIHtcbiAgICBjb25zdCByID0gbmV3IEJOKHNpZy5zdWJhcnJheSgwLCAzMikpXG4gICAgY29uc3QgcyA9IG5ldyBCTihzaWcuc3ViYXJyYXkoMzIsIDY0KSlcbiAgICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgaWYgKHMuY21wKGVjLm5oKSA9PT0gMSkge1xuICAgICAgc2lnLnNldChlY3BhcmFtcy5uLnN1YihzKS50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgLy8gQ29waWVkIDEtdG8tMSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYmlwNjYvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgLy8gQWRhcHRlZCBmb3IgVWludDhBcnJheSBpbnN0ZWFkIEJ1ZmZlclxuICBzaWduYXR1cmVFeHBvcnQgKG9iaiwgc2lnKSB7XG4gICAgY29uc3Qgc2lnUiA9IHNpZy5zdWJhcnJheSgwLCAzMilcbiAgICBjb25zdCBzaWdTID0gc2lnLnN1YmFycmF5KDMyLCA2NClcbiAgICBpZiAobmV3IEJOKHNpZ1IpLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuICAgIGlmIChuZXcgQk4oc2lnUykuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBjb25zdCB7IG91dHB1dCB9ID0gb2JqXG5cbiAgICAvLyBQcmVwYXJlIFJcbiAgICBsZXQgciA9IG91dHB1dC5zdWJhcnJheSg0LCA0ICsgMzMpXG4gICAgclswXSA9IDB4MDBcbiAgICByLnNldChzaWdSLCAxKVxuXG4gICAgbGV0IGxlblIgPSAzM1xuICAgIGxldCBwb3NSID0gMFxuICAgIGZvciAoOyBsZW5SID4gMSAmJiByW3Bvc1JdID09PSAweDAwICYmICEocltwb3NSICsgMV0gJiAweDgwKTsgLS1sZW5SLCArK3Bvc1IpO1xuXG4gICAgciA9IHIuc3ViYXJyYXkocG9zUilcbiAgICBpZiAoclswXSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblIgPiAxICYmIChyWzBdID09PSAweDAwKSAmJiAhKHJbMV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIC8vIFByZXBhcmUgU1xuICAgIGxldCBzID0gb3V0cHV0LnN1YmFycmF5KDYgKyAzMywgNiArIDMzICsgMzMpXG4gICAgc1swXSA9IDB4MDBcbiAgICBzLnNldChzaWdTLCAxKVxuXG4gICAgbGV0IGxlblMgPSAzM1xuICAgIGxldCBwb3NTID0gMFxuICAgIGZvciAoOyBsZW5TID4gMSAmJiBzW3Bvc1NdID09PSAweDAwICYmICEoc1twb3NTICsgMV0gJiAweDgwKTsgLS1sZW5TLCArK3Bvc1MpO1xuXG4gICAgcyA9IHMuc3ViYXJyYXkocG9zUylcbiAgICBpZiAoc1swXSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblMgPiAxICYmIChzWzBdID09PSAweDAwKSAmJiAhKHNbMV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIC8vIFNldCBvdXRwdXQgbGVuZ3RoIGZvciByZXR1cm5cbiAgICBvYmoub3V0cHV0bGVuID0gNiArIGxlblIgKyBsZW5TXG5cbiAgICAvLyBPdXRwdXQgaW4gc3BlY2lmaWVkIGZvcm1hdFxuICAgIC8vIDB4MzAgW3RvdGFsLWxlbmd0aF0gMHgwMiBbUi1sZW5ndGhdIFtSXSAweDAyIFtTLWxlbmd0aF0gW1NdXG4gICAgb3V0cHV0WzBdID0gMHgzMFxuICAgIG91dHB1dFsxXSA9IG9iai5vdXRwdXRsZW4gLSAyXG4gICAgb3V0cHV0WzJdID0gMHgwMlxuICAgIG91dHB1dFszXSA9IHIubGVuZ3RoXG4gICAgb3V0cHV0LnNldChyLCA0KVxuICAgIG91dHB1dFs0ICsgbGVuUl0gPSAweDAyXG4gICAgb3V0cHV0WzUgKyBsZW5SXSA9IHMubGVuZ3RoXG4gICAgb3V0cHV0LnNldChzLCA2ICsgbGVuUilcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgLy8gQ29waWVkIDEtdG8tMSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYmlwNjYvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgLy8gQWRhcHRlZCBmb3IgVWludDhBcnJheSBpbnN0ZWFkIEJ1ZmZlclxuICBzaWduYXR1cmVJbXBvcnQgKG91dHB1dCwgc2lnKSB7XG4gICAgaWYgKHNpZy5sZW5ndGggPCA4KSByZXR1cm4gMVxuICAgIGlmIChzaWcubGVuZ3RoID4gNzIpIHJldHVybiAxXG4gICAgaWYgKHNpZ1swXSAhPT0gMHgzMCkgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzFdICE9PSBzaWcubGVuZ3RoIC0gMikgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzJdICE9PSAweDAyKSByZXR1cm4gMVxuXG4gICAgY29uc3QgbGVuUiA9IHNpZ1szXVxuICAgIGlmIChsZW5SID09PSAwKSByZXR1cm4gMVxuICAgIGlmICg1ICsgbGVuUiA+PSBzaWcubGVuZ3RoKSByZXR1cm4gMVxuICAgIGlmIChzaWdbNCArIGxlblJdICE9PSAweDAyKSByZXR1cm4gMVxuXG4gICAgY29uc3QgbGVuUyA9IHNpZ1s1ICsgbGVuUl1cbiAgICBpZiAobGVuUyA9PT0gMCkgcmV0dXJuIDFcbiAgICBpZiAoKDYgKyBsZW5SICsgbGVuUykgIT09IHNpZy5sZW5ndGgpIHJldHVybiAxXG5cbiAgICBpZiAoc2lnWzRdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUiA+IDEgJiYgKHNpZ1s0XSA9PT0gMHgwMCkgJiYgIShzaWdbNV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdbbGVuUiArIDZdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUyA+IDEgJiYgKHNpZ1tsZW5SICsgNl0gPT09IDB4MDApICYmICEoc2lnW2xlblIgKyA3XSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1IgPSBzaWcuc3ViYXJyYXkoNCwgNCArIGxlblIpXG4gICAgaWYgKHNpZ1IubGVuZ3RoID09PSAzMyAmJiBzaWdSWzBdID09PSAweDAwKSBzaWdSID0gc2lnUi5zdWJhcnJheSgxKVxuICAgIGlmIChzaWdSLmxlbmd0aCA+IDMyKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoNiArIGxlblIpXG4gICAgaWYgKHNpZ1MubGVuZ3RoID09PSAzMyAmJiBzaWdTWzBdID09PSAweDAwKSBzaWdTID0gc2lnUy5zbGljZSgxKVxuICAgIGlmIChzaWdTLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJylcblxuICAgIGxldCByID0gbmV3IEJOKHNpZ1IpXG4gICAgaWYgKHIuY21wKGVjcGFyYW1zLm4pID49IDApIHIgPSBuZXcgQk4oMClcblxuICAgIGxldCBzID0gbmV3IEJOKHNpZy5zdWJhcnJheSg2ICsgbGVuUikpXG4gICAgaWYgKHMuY21wKGVjcGFyYW1zLm4pID49IDApIHMgPSBuZXcgQk4oMClcblxuICAgIG91dHB1dC5zZXQoci50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDApXG4gICAgb3V0cHV0LnNldChzLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZHNhU2lnbiAob2JqLCBtZXNzYWdlLCBzZWNrZXksIGRhdGEsIG5vbmNlZm4pIHtcbiAgICBpZiAobm9uY2Vmbikge1xuICAgICAgY29uc3QgX25vbmNlZm4gPSBub25jZWZuXG4gICAgICBub25jZWZuID0gKGNvdW50ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBfbm9uY2VmbihtZXNzYWdlLCBzZWNrZXksIG51bGwsIGRhdGEsIGNvdW50ZXIpXG5cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IG5vbmNlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBub25jZS5sZW5ndGggPT09IDMyXG4gICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIHRoZSB3YXknKVxuXG4gICAgICAgIHJldHVybiBuZXcgQk4obm9uY2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IG5ldyBCTihzZWNrZXkpXG4gICAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGxldCBzaWdcbiAgICB0cnkge1xuICAgICAgc2lnID0gZWMuc2lnbihtZXNzYWdlLCBzZWNrZXksIHsgY2Fub25pY2FsOiB0cnVlLCBrOiBub25jZWZuLCBwZXJzOiBkYXRhIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIG9iai5zaWduYXR1cmUuc2V0KHNpZy5yLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMClcbiAgICBvYmouc2lnbmF0dXJlLnNldChzaWcucy50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuICAgIG9iai5yZWNpZCA9IHNpZy5yZWNvdmVyeVBhcmFtXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZHNhVmVyaWZ5IChzaWcsIG1zZzMyLCBwdWJrZXkpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IHNpZy5zdWJhcnJheSgwLCAzMiksIHM6IHNpZy5zdWJhcnJheSgzMiwgNjQpIH1cblxuICAgIGNvbnN0IHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gICAgY29uc3Qgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuICAgIGlmIChzaWdzLmNtcChlYy5uaCkgPT09IDEgfHwgc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSByZXR1cm4gM1xuXG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgY29uc3QgaXNWYWxpZCA9IGVjLnZlcmlmeShtc2czMiwgc2lnT2JqLCBwb2ludClcbiAgICByZXR1cm4gaXNWYWxpZCA/IDAgOiAzXG4gIH0sXG5cbiAgZWNkc2FSZWNvdmVyIChvdXRwdXQsIHNpZywgcmVjaWQsIG1zZzMyKSB7XG4gICAgY29uc3Qgc2lnT2JqID0geyByOiBzaWcuc2xpY2UoMCwgMzIpLCBzOiBzaWcuc2xpY2UoMzIsIDY0KSB9XG5cbiAgICBjb25zdCBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICAgIGNvbnN0IHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gICAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICAvLyBDYW4gdGhyb3cgYHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7YFxuICAgIGxldCBwb2ludFxuICAgIHRyeSB7XG4gICAgICBwb2ludCA9IGVjLnJlY292ZXJQdWJLZXkobXNnMzIsIHNpZ09iaiwgcmVjaWQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkaCAob3V0cHV0LCBwdWJrZXksIHNlY2tleSwgZGF0YSwgaGFzaGZuLCB4YnVmLCB5YnVmKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3Qgc2NhbGFyID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoc2NhbGFyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5tdWwoc2NhbGFyKVxuXG4gICAgaWYgKGhhc2hmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gcG9pbnQuZW5jb2RlKG51bGwsIHRydWUpXG4gICAgICBjb25zdCBzaGEyNTYgPSBlYy5oYXNoKCkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIG91dHB1dFtpXSA9IHNoYTI1NltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXhidWYpIHhidWYgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNvbnN0IHggPSBwb2ludC5nZXRYKCkudG9BcnJheSgnYmUnLCAzMilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgeGJ1ZltpXSA9IHhbaV1cblxuICAgICAgaWYgKCF5YnVmKSB5YnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICBjb25zdCB5ID0gcG9pbnQuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgMzIpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIHlidWZbaV0gPSB5W2ldXG5cbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZm4oeGJ1ZiwgeWJ1ZiwgZGF0YSlcblxuICAgICAgY29uc3QgaXNWYWxpZCA9IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGhhc2gubGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoXG4gICAgICBpZiAoIWlzVmFsaWQpIHJldHVybiAyXG5cbiAgICAgIG91dHB1dC5zZXQoaGFzaClcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9XG59XG4iLCJjb25zdCBlcnJvcnMgPSB7XG4gIElNUE9TU0lCTEVfQ0FTRTogJ0ltcG9zc2libGUgY2FzZS4gUGxlYXNlIGNyZWF0ZSBpc3N1ZS4nLFxuICBUV0VBS19BREQ6XG4gICAgJ1RoZSB0d2VhayB3YXMgb3V0IG9mIHJhbmdlIG9yIHRoZSByZXN1bHRlZCBwcml2YXRlIGtleSBpcyBpbnZhbGlkJyxcbiAgVFdFQUtfTVVMOiAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgZXF1YWwgdG8gemVybycsXG4gIENPTlRFWFRfUkFORE9NSVpFX1VOS05PVzogJ1Vua25vdyBlcnJvciBvbiBjb250ZXh0IHJhbmRvbWl6YXRpb24nLFxuICBTRUNLRVlfSU5WQUxJRDogJ1ByaXZhdGUgS2V5IGlzIGludmFsaWQnLFxuICBQVUJLRVlfUEFSU0U6ICdQdWJsaWMgS2V5IGNvdWxkIG5vdCBiZSBwYXJzZWQnLFxuICBQVUJLRVlfU0VSSUFMSVpFOiAnUHVibGljIEtleSBzZXJpYWxpemF0aW9uIGVycm9yJyxcbiAgUFVCS0VZX0NPTUJJTkU6ICdUaGUgc3VtIG9mIHRoZSBwdWJsaWMga2V5cyBpcyBub3QgdmFsaWQnLFxuICBTSUdfUEFSU0U6ICdTaWduYXR1cmUgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFNJR046ICdUaGUgbm9uY2UgZ2VuZXJhdGlvbiBmdW5jdGlvbiBmYWlsZWQsIG9yIHRoZSBwcml2YXRlIGtleSB3YXMgaW52YWxpZCcsXG4gIFJFQ09WRVI6ICdQdWJsaWMga2V5IGNvdWxkIG5vdCBiZSByZWNvdmVyJyxcbiAgRUNESDogJ1NjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdyknXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkgdGhyb3cgbmV3IEVycm9yKG1zZylcbn1cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5IChuYW1lLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIGBFeHBlY3RlZCAke25hbWV9IHRvIGJlIGFuIFVpbnQ4QXJyYXlgKVxuXG4gIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlbmd0aCkpIHtcbiAgICAgIGNvbnN0IG51bWJlcnMgPSBsZW5ndGguam9pbignLCAnKVxuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCBbJHtudW1iZXJzfV1gXG4gICAgICBhc3NlcnQobGVuZ3RoLmluY2x1ZGVzKHZhbHVlLmxlbmd0aCksIG1zZylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCAke2xlbmd0aH1gXG4gICAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSBsZW5ndGgsIG1zZylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb21wcmVzc2VkICh2YWx1ZSkge1xuICBhc3NlcnQodG9UeXBlU3RyaW5nKHZhbHVlKSA9PT0gJ0Jvb2xlYW4nLCAnRXhwZWN0ZWQgY29tcHJlc3NlZCB0byBiZSBhIEJvb2xlYW4nKVxufVxuXG5mdW5jdGlvbiBnZXRBc3NlcnRlZE91dHB1dCAob3V0cHV0ID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSBvdXRwdXQgPSBvdXRwdXQobGVuZ3RoKVxuICBpc1VpbnQ4QXJyYXkoJ291dHB1dCcsIG91dHB1dCwgbGVuZ3RoKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIHRvVHlwZVN0cmluZyAodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHNlY3AyNTZrMSkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRSYW5kb21pemUgKHNlZWQpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgc2VlZCA9PT0gbnVsbCB8fCBzZWVkIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICAgICAgJ0V4cGVjdGVkIHNlZWQgdG8gYmUgYW4gVWludDhBcnJheSBvciBudWxsJ1xuICAgICAgKVxuICAgICAgaWYgKHNlZWQgIT09IG51bGwpIGlzVWludDhBcnJheSgnc2VlZCcsIHNlZWQsIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5jb250ZXh0UmFuZG9taXplKHNlZWQpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkNPTlRFWFRfUkFORE9NSVpFX1VOS05PVylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVZlcmlmeSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHNlY2tleSkgPT09IDBcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU5lZ2F0ZSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShzZWNrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrQWRkIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19BREQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha011bCAoc2Vja2V5LCB0d2Vhaykge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoc2Vja2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlWZXJpZnkgKHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVia2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDcmVhdGUgKHNlY2tleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShvdXRwdXQsIHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0VDS0VZX0lOVkFMSUQpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNvbnZlcnQgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29udmVydChvdXRwdXQsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlOZWdhdGUgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5TmVnYXRlKG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29tYmluZSAocHVia2V5cywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocHVia2V5cyksICdFeHBlY3RlZCBwdWJsaWMga2V5cyB0byBiZSBhbiBBcnJheScpXG4gICAgICBhc3NlcnQocHVia2V5cy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgcHVibGljIGtleXMgYXJyYXkgd2lsbCBoYXZlIG1vcmUgdGhhbiB6ZXJvIGl0ZW1zJylcbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHB1YmtleXMpIHtcbiAgICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIH1cbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShvdXRwdXQsIHB1YmtleXMpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX0NPTUJJTkUpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrQWRkIChwdWJrZXksIHR3ZWFrLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtNdWwgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVOb3JtYWxpemUgKHNpZykge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVOb3JtYWxpemUoc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNpZ1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUV4cG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNzIpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgb3V0cHV0LCBvdXRwdXRsZW46IDcyIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChvYmosIHNpZykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXQuc2xpY2UoMCwgb2JqLm91dHB1dGxlbilcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUltcG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KG91dHB1dCwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FTaWduIChtc2czMiwgc2Vja2V5LCBvcHRpb25zID0ge30sIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5ub25jZWZuICE9PSB1bmRlZmluZWQpIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5ub25jZWZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMubm9uY2VmbiB0byBiZSBhIEZ1bmN0aW9uJylcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNjQpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgc2lnbmF0dXJlOiBvdXRwdXQsIHJlY2lkOiBudWxsIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhU2lnbihvYmosIG1zZzMyLCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5ub25jZWZuKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdOKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhVmVyaWZ5IChzaWcsIG1zZzMyLCBwdWJrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KHNpZywgbXNnMzIsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhUmVjb3ZlciAoc2lnLCByZWNpZCwgbXNnMzIsIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGFzc2VydChcbiAgICAgICAgdG9UeXBlU3RyaW5nKHJlY2lkKSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICByZWNpZCA+PSAwICYmXG4gICAgICAgICAgcmVjaWQgPD0gMyxcbiAgICAgICAgJ0V4cGVjdGVkIHJlY292ZXJ5IGlkIHRvIGJlIGEgTnVtYmVyIHdpdGhpbiBpbnRlcnZhbCBbMCwgM10nXG4gICAgICApXG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihvdXRwdXQsIHNpZywgcmVjaWQsIG1zZzMyKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlJFQ09WRVIpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkaCAocHVia2V5LCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5oYXNoZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMuaGFzaGZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMuaGFzaGZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgICBpZiAob3B0aW9ucy54YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy54YnVmJywgb3B0aW9ucy54YnVmLCAzMilcbiAgICAgICAgaWYgKG9wdGlvbnMueWJ1ZiAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMueWJ1ZicsIG9wdGlvbnMueWJ1ZiwgMzIpXG4gICAgICAgIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCAzMilcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkaChvdXRwdXQsIHB1YmtleSwgc2Vja2V5LCBvcHRpb25zLmRhdGEsIG9wdGlvbnMuaGFzaGZuLCBvcHRpb25zLnhidWYsIG9wdGlvbnMueWJ1ZikpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5FQ0RIKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOSUxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX25pbC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wYXJzZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjFcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2M1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsaWRhdGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92ZXJzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YxLmpzXCIpKTtcblxudmFyIF92MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjMuanNcIikpO1xuXG52YXIgX3YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NC5qc1wiKSk7XG5cbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y1LmpzXCIpKTtcblxudmFyIF9uaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25pbC5qc1wiKSk7XG5cbnZhciBfdmVyc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKSk7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIGNvbnN0IGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICBjb25zdCB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICBjb25zdCBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIGxldCBhID0gMTczMjU4NDE5MztcbiAgbGV0IGIgPSAtMjcxNzMzODc5O1xuICBsZXQgYyA9IC0xNzMyNTg0MTk0O1xuICBsZXQgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgY29uc3Qgb2xkYSA9IGE7XG4gICAgY29uc3Qgb2xkYiA9IGI7XG4gICAgY29uc3Qgb2xkYyA9IGM7XG4gICAgY29uc3Qgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIGNvbnN0IGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgY29uc3QgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG1kNTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuY29uc3QgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbnZhciBfZGVmYXVsdCA9IHtcbiAgcmFuZG9tVVVJRFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0ID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBfZGVmYXVsdCA9IHBhcnNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJuZztcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBjb25zdCBLID0gWzB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4Y2E2MmMxZDZdO1xuICBjb25zdCBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIGNvbnN0IGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgY29uc3QgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICBjb25zdCBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgYXJyW2pdID0gYnl0ZXNbaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtpXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICBjb25zdCBXID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcblxuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMTY7ICsrdCkge1xuICAgICAgV1t0XSA9IE1baV1bdF07XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdCA9IDE2OyB0IDwgODA7ICsrdCkge1xuICAgICAgV1t0XSA9IFJPVEwoV1t0IC0gM10gXiBXW3QgLSA4XSBeIFdbdCAtIDE0XSBeIFdbdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgbGV0IGEgPSBIWzBdO1xuICAgIGxldCBiID0gSFsxXTtcbiAgICBsZXQgYyA9IEhbMl07XG4gICAgbGV0IGQgPSBIWzNdO1xuICAgIGxldCBlID0gSFs0XTtcblxuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgODA7ICsrdCkge1xuICAgICAgY29uc3QgcyA9IE1hdGguZmxvb3IodCAvIDIwKTtcbiAgICAgIGNvbnN0IFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1t0XSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG52YXIgX2RlZmF1bHQgPSBzaGExO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5leHBvcnRzLnVuc2FmZVN0cmluZ2lmeSA9IHVuc2FmZVN0cmluZ2lmeTtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbnZhciBfZGVmYXVsdCA9IHN0cmluZ2lmeTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkudW5zYWZlU3RyaW5naWZ5KShiKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX21kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZDUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2MyA9ICgwLCBfdi5kZWZhdWx0KSgndjMnLCAweDMwLCBfbWQuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2MztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcbmV4cG9ydHMuZGVmYXVsdCA9IHYzNTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLkROUyA9IEROUztcbmNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5VUkwgPSBVUkw7XG5cbmZ1bmN0aW9uIHYzNShuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgX25hbWVzcGFjZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gKDAsIF9wYXJzZS5kZWZhdWx0KShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmICgoKF9uYW1lc3BhY2UgPSBuYW1lc3BhY2UpID09PSBudWxsIHx8IF9uYW1lc3BhY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uYW1lc3BhY2UubGVuZ3RoKSAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX25hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbmF0aXZlLmpzXCIpKTtcblxudmFyIF9ybmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JuZy5qc1wiKSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAoX25hdGl2ZS5kZWZhdWx0LnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBfbmF0aXZlLmRlZmF1bHQucmFuZG9tVVVJRCgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkocm5kcyk7XG59XG5cbnZhciBfZGVmYXVsdCA9IHY0O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjM1LmpzXCIpKTtcblxudmFyIF9zaGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NoYTEuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2NSA9ICgwLCBfdi5kZWZhdWx0KSgndjUnLCAweDUwLCBfc2hhLmRlZmF1bHQpO1xudmFyIF9kZWZhdWx0ID0gdjU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVnZXguanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgX3JlZ2V4LmRlZmF1bHQudGVzdCh1dWlkKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmFsaWRhdGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCEoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxNSksIDE2KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmVyc2lvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIi8vIGludDY0LWJ1ZmZlci5qc1xuXG4vKmpzaGludCAtVzAxOCAqLyAvLyBDb25mdXNpbmcgdXNlIG9mICchJy5cbi8qanNoaW50IC1XMDMwICovIC8vIEV4cGVjdGVkIGFuIGFzc2lnbm1lbnQgb3IgZnVuY3Rpb24gY2FsbCBhbmQgaW5zdGVhZCBzYXcgYW4gZXhwcmVzc2lvbi5cbi8qanNoaW50IC1XMDkzICovIC8vIERpZCB5b3UgbWVhbiB0byByZXR1cm4gYSBjb25kaXRpb25hbCBpbnN0ZWFkIG9mIGFuIGFzc2lnbm1lbnQ/XG5cbnZhciBVaW50NjRCRSwgSW50NjRCRSwgVWludDY0TEUsIEludDY0TEU7XG5cbiFmdW5jdGlvbihleHBvcnRzKSB7XG4gIC8vIGNvbnN0YW50c1xuXG4gIHZhciBVTkRFRklORUQgPSBcInVuZGVmaW5lZFwiO1xuICB2YXIgQlVGRkVSID0gKFVOREVGSU5FRCAhPT0gdHlwZW9mIEJ1ZmZlcikgJiYgQnVmZmVyO1xuICB2YXIgVUlOVDhBUlJBWSA9IChVTkRFRklORUQgIT09IHR5cGVvZiBVaW50OEFycmF5KSAmJiBVaW50OEFycmF5O1xuICB2YXIgQVJSQVlCVUZGRVIgPSAoVU5ERUZJTkVEICE9PSB0eXBlb2YgQXJyYXlCdWZmZXIpICYmIEFycmF5QnVmZmVyO1xuICB2YXIgWkVSTyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IF9pc0FycmF5O1xuICB2YXIgQklUMzIgPSA0Mjk0OTY3Mjk2O1xuICB2YXIgQklUMjQgPSAxNjc3NzIxNjtcblxuICAvLyBzdG9yYWdlIGNsYXNzXG5cbiAgdmFyIHN0b3JhZ2U7IC8vIEFycmF5O1xuXG4gIC8vIGdlbmVyYXRlIGNsYXNzZXNcblxuICBVaW50NjRCRSA9IGZhY3RvcnkoXCJVaW50NjRCRVwiLCB0cnVlLCB0cnVlKTtcbiAgSW50NjRCRSA9IGZhY3RvcnkoXCJJbnQ2NEJFXCIsIHRydWUsIGZhbHNlKTtcbiAgVWludDY0TEUgPSBmYWN0b3J5KFwiVWludDY0TEVcIiwgZmFsc2UsIHRydWUpO1xuICBJbnQ2NExFID0gZmFjdG9yeShcIkludDY0TEVcIiwgZmFsc2UsIGZhbHNlKTtcblxuICAvLyBjbGFzcyBmYWN0b3J5XG5cbiAgZnVuY3Rpb24gZmFjdG9yeShuYW1lLCBiaWdlbmRpYW4sIHVuc2lnbmVkKSB7XG4gICAgdmFyIHBvc0ggPSBiaWdlbmRpYW4gPyAwIDogNDtcbiAgICB2YXIgcG9zTCA9IGJpZ2VuZGlhbiA/IDQgOiAwO1xuICAgIHZhciBwb3MwID0gYmlnZW5kaWFuID8gMCA6IDM7XG4gICAgdmFyIHBvczEgPSBiaWdlbmRpYW4gPyAxIDogMjtcbiAgICB2YXIgcG9zMiA9IGJpZ2VuZGlhbiA/IDIgOiAxO1xuICAgIHZhciBwb3MzID0gYmlnZW5kaWFuID8gMyA6IDA7XG4gICAgdmFyIGZyb21Qb3NpdGl2ZSA9IGJpZ2VuZGlhbiA/IGZyb21Qb3NpdGl2ZUJFIDogZnJvbVBvc2l0aXZlTEU7XG4gICAgdmFyIGZyb21OZWdhdGl2ZSA9IGJpZ2VuZGlhbiA/IGZyb21OZWdhdGl2ZUJFIDogZnJvbU5lZ2F0aXZlTEU7XG4gICAgdmFyIHByb3RvID0gSW50NjQucHJvdG90eXBlO1xuICAgIHZhciBpc05hbWUgPSBcImlzXCIgKyBuYW1lO1xuICAgIHZhciBfaXNJbnQ2NCA9IFwiX1wiICsgaXNOYW1lO1xuXG4gICAgLy8gcHJvcGVydGllc1xuICAgIHByb3RvLmJ1ZmZlciA9IHZvaWQgMDtcbiAgICBwcm90by5vZmZzZXQgPSAwO1xuICAgIHByb3RvW19pc0ludDY0XSA9IHRydWU7XG5cbiAgICAvLyBtZXRob2RzXG4gICAgcHJvdG8udG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBwcm90by50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnRvSlNPTiA9IHRvTnVtYmVyO1xuICAgIHByb3RvLnRvQXJyYXkgPSB0b0FycmF5O1xuXG4gICAgLy8gYWRkIC50b0J1ZmZlcigpIG1ldGhvZCBvbmx5IHdoZW4gQnVmZmVyIGF2YWlsYWJsZVxuICAgIGlmIChCVUZGRVIpIHByb3RvLnRvQnVmZmVyID0gdG9CdWZmZXI7XG5cbiAgICAvLyBhZGQgLnRvQXJyYXlCdWZmZXIoKSBtZXRob2Qgb25seSB3aGVuIFVpbnQ4QXJyYXkgYXZhaWxhYmxlXG4gICAgaWYgKFVJTlQ4QVJSQVkpIHByb3RvLnRvQXJyYXlCdWZmZXIgPSB0b0FycmF5QnVmZmVyO1xuXG4gICAgLy8gaXNVaW50NjRCRSwgaXNJbnQ2NEJFXG4gICAgSW50NjRbaXNOYW1lXSA9IGlzSW50NjQ7XG5cbiAgICAvLyBDb21tb25KU1xuICAgIGV4cG9ydHNbbmFtZV0gPSBJbnQ2NDtcblxuICAgIHJldHVybiBJbnQ2NDtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gSW50NjQoYnVmZmVyLCBvZmZzZXQsIHZhbHVlLCByYWRkaXgpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnQ2NCkpIHJldHVybiBuZXcgSW50NjQoYnVmZmVyLCBvZmZzZXQsIHZhbHVlLCByYWRkaXgpO1xuICAgICAgcmV0dXJuIGluaXQodGhpcywgYnVmZmVyLCBvZmZzZXQsIHZhbHVlLCByYWRkaXgpO1xuICAgIH1cblxuICAgIC8vIGlzVWludDY0QkUsIGlzSW50NjRCRVxuICAgIGZ1bmN0aW9uIGlzSW50NjQoYikge1xuICAgICAgcmV0dXJuICEhKGIgJiYgYltfaXNJbnQ2NF0pO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemVyXG4gICAgZnVuY3Rpb24gaW5pdCh0aGF0LCBidWZmZXIsIG9mZnNldCwgdmFsdWUsIHJhZGRpeCkge1xuICAgICAgaWYgKFVJTlQ4QVJSQVkgJiYgQVJSQVlCVUZGRVIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFSUkFZQlVGRkVSKSBidWZmZXIgPSBuZXcgVUlOVDhBUlJBWShidWZmZXIpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBUlJBWUJVRkZFUikgdmFsdWUgPSBuZXcgVUlOVDhBUlJBWSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEludDY0QkUoKSBzdHlsZVxuICAgICAgaWYgKCFidWZmZXIgJiYgIW9mZnNldCAmJiAhdmFsdWUgJiYgIXN0b3JhZ2UpIHtcbiAgICAgICAgLy8gc2hvcnRjdXQgdG8gaW5pdGlhbGl6ZSB3aXRoIHplcm9cbiAgICAgICAgdGhhdC5idWZmZXIgPSBuZXdBcnJheShaRVJPLCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnQ2NEJFKHZhbHVlLCByYWRkaXgpIHN0eWxlXG4gICAgICBpZiAoIWlzVmFsaWRCdWZmZXIoYnVmZmVyLCBvZmZzZXQpKSB7XG4gICAgICAgIHZhciBfc3RvcmFnZSA9IHN0b3JhZ2UgfHwgQXJyYXk7XG4gICAgICAgIHJhZGRpeCA9IG9mZnNldDtcbiAgICAgICAgdmFsdWUgPSBidWZmZXI7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGJ1ZmZlciA9IChzdG9yYWdlID09PSBCVUZGRVIpID8gQlVGRkVSLmFsbG9jKDgpIDogbmV3IF9zdG9yYWdlKDgpO1xuICAgICAgfVxuXG4gICAgICB0aGF0LmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoYXQub2Zmc2V0ID0gb2Zmc2V0IHw9IDA7XG5cbiAgICAgIC8vIEludDY0QkUoYnVmZmVyLCBvZmZzZXQpIHN0eWxlXG4gICAgICBpZiAoVU5ERUZJTkVEID09PSB0eXBlb2YgdmFsdWUpIHJldHVybjtcblxuICAgICAgLy8gSW50NjRCRShidWZmZXIsIG9mZnNldCwgdmFsdWUsIHJhZGRpeCkgc3R5bGVcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgZnJvbVN0cmluZyhidWZmZXIsIG9mZnNldCwgdmFsdWUsIHJhZGRpeCB8fCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRCdWZmZXIodmFsdWUsIHJhZGRpeCkpIHtcbiAgICAgICAgZnJvbUFycmF5KGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSwgcmFkZGl4KTtcbiAgICAgIH0gZWxzZSBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJhZGRpeCkge1xuICAgICAgICB3cml0ZUludDMyKGJ1ZmZlciwgb2Zmc2V0ICsgcG9zSCwgdmFsdWUpOyAvLyBoaWdoXG4gICAgICAgIHdyaXRlSW50MzIoYnVmZmVyLCBvZmZzZXQgKyBwb3NMLCByYWRkaXgpOyAvLyBsb3dcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgIGZyb21Qb3NpdGl2ZShidWZmZXIsIG9mZnNldCwgdmFsdWUpOyAvLyBwb3NpdGl2ZVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgZnJvbU5lZ2F0aXZlKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSk7IC8vIG5lZ2F0aXZlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tQXJyYXkoYnVmZmVyLCBvZmZzZXQsIFpFUk8sIDApOyAvLyB6ZXJvLCBOYU4gYW5kIG90aGVyc1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoYnVmZmVyLCBvZmZzZXQsIHN0ciwgcmFkZGl4KSB7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgdmFyIGhpZ2ggPSAwO1xuICAgICAgdmFyIGxvdyA9IDA7XG4gICAgICBpZiAoc3RyWzBdID09PSBcIi1cIikgcG9zKys7XG4gICAgICB2YXIgc2lnbiA9IHBvcztcbiAgICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgICAgdmFyIGNociA9IHBhcnNlSW50KHN0cltwb3MrK10sIHJhZGRpeCk7XG4gICAgICAgIGlmICghKGNociA+PSAwKSkgYnJlYWs7IC8vIE5hTlxuICAgICAgICBsb3cgPSBsb3cgKiByYWRkaXggKyBjaHI7XG4gICAgICAgIGhpZ2ggPSBoaWdoICogcmFkZGl4ICsgTWF0aC5mbG9vcihsb3cgLyBCSVQzMik7XG4gICAgICAgIGxvdyAlPSBCSVQzMjtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpZ2ggPSB+aGlnaDtcbiAgICAgICAgaWYgKGxvdykge1xuICAgICAgICAgIGxvdyA9IEJJVDMyIC0gbG93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2grKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd3JpdGVJbnQzMihidWZmZXIsIG9mZnNldCArIHBvc0gsIGhpZ2gpO1xuICAgICAgd3JpdGVJbnQzMihidWZmZXIsIG9mZnNldCArIHBvc0wsIGxvdyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIoKSB7XG4gICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICB2YXIgaGlnaCA9IHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCArIHBvc0gpO1xuICAgICAgdmFyIGxvdyA9IHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCArIHBvc0wpO1xuICAgICAgaWYgKCF1bnNpZ25lZCkgaGlnaCB8PSAwOyAvLyBhIHRyaWNrIHRvIGdldCBzaWduZWRcbiAgICAgIHJldHVybiBoaWdoID8gKGhpZ2ggKiBCSVQzMiArIGxvdykgOiBsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgIHZhciBoaWdoID0gcmVhZEludDMyKGJ1ZmZlciwgb2Zmc2V0ICsgcG9zSCk7XG4gICAgICB2YXIgbG93ID0gcmVhZEludDMyKGJ1ZmZlciwgb2Zmc2V0ICsgcG9zTCk7XG4gICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgIHZhciBzaWduID0gIXVuc2lnbmVkICYmIChoaWdoICYgMHg4MDAwMDAwMCk7XG4gICAgICBpZiAoc2lnbikge1xuICAgICAgICBoaWdoID0gfmhpZ2g7XG4gICAgICAgIGxvdyA9IEJJVDMyIC0gbG93O1xuICAgICAgfVxuICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHZhciBtb2QgPSAoaGlnaCAlIHJhZGl4KSAqIEJJVDMyICsgbG93O1xuICAgICAgICBoaWdoID0gTWF0aC5mbG9vcihoaWdoIC8gcmFkaXgpO1xuICAgICAgICBsb3cgPSBNYXRoLmZsb29yKG1vZCAvIHJhZGl4KTtcbiAgICAgICAgc3RyID0gKG1vZCAlIHJhZGl4KS50b1N0cmluZyhyYWRpeCkgKyBzdHI7XG4gICAgICAgIGlmICghaGlnaCAmJiAhbG93KSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaWduKSB7XG4gICAgICAgIHN0ciA9IFwiLVwiICsgc3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cml0ZUludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgYnVmZmVyW29mZnNldCArIHBvczNdID0gdmFsdWUgJiAyNTU7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+IDg7XG4gICAgICBidWZmZXJbb2Zmc2V0ICsgcG9zMl0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4gODtcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyBwb3MxXSA9IHZhbHVlICYgMjU1O1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA4O1xuICAgICAgYnVmZmVyW29mZnNldCArIHBvczBdID0gdmFsdWUgJiAyNTU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEludDMyKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gKGJ1ZmZlcltvZmZzZXQgKyBwb3MwXSAqIEJJVDI0KSArXG4gICAgICAgIChidWZmZXJbb2Zmc2V0ICsgcG9zMV0gPDwgMTYpICtcbiAgICAgICAgKGJ1ZmZlcltvZmZzZXQgKyBwb3MyXSA8PCA4KSArXG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBwb3MzXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b0FycmF5KHJhdykge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgc3RvcmFnZSA9IG51bGw7IC8vIEFycmF5XG5cbiAgICBpZiAocmF3ICE9PSBmYWxzZSAmJiBpc0FycmF5KGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiAoYnVmZmVyLmxlbmd0aCA9PT0gOCkgPyBidWZmZXIgOiBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9CdWZmZXIocmF3KSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICBzdG9yYWdlID0gQlVGRkVSO1xuXG4gICAgaWYgKHJhdyAhPT0gZmFsc2UgJiYgQlVGRkVSLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiAoYnVmZmVyLmxlbmd0aCA9PT0gOCkgPyBidWZmZXIgOiBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA4KTtcbiAgICB9XG5cbiAgICAvLyBCdWZmZXIuZnJvbShhcnJheWJ1ZmZlcikgYXZhaWxhYmxlIHNpbmNlIE5vZGUgdjQuNS4wXG4gICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2VuL2Jsb2cvcmVsZWFzZS92NC41LjAvXG4gICAgcmV0dXJuIEJVRkZFUi5mcm9tKHRvQXJyYXlCdWZmZXIuY2FsbCh0aGlzLCByYXcpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIocmF3KSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICB2YXIgYXJyYnVmID0gYnVmZmVyLmJ1ZmZlcjtcbiAgICBzdG9yYWdlID0gVUlOVDhBUlJBWTtcblxuICAgIC8vIGFycmJ1Zi5zbGljZSgpIGlnbm9yZXMgYnVmZmVyLm9mZnNldCB1bnRpbCBOb2RlIHY4LjAuMFxuICAgIGlmIChyYXcgIT09IGZhbHNlICYmICFidWZmZXIub2Zmc2V0ICYmIChhcnJidWYgaW5zdGFuY2VvZiBBUlJBWUJVRkZFUikpIHtcbiAgICAgIHJldHVybiAoYXJyYnVmLmJ5dGVMZW5ndGggPT09IDgpID8gYXJyYnVmIDogYXJyYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgOCk7XG4gICAgfVxuXG4gICAgdmFyIGRlc3QgPSBuZXcgVUlOVDhBUlJBWSg4KTtcbiAgICBmcm9tQXJyYXkoZGVzdCwgMCwgYnVmZmVyLCBvZmZzZXQpO1xuICAgIHJldHVybiBkZXN0LmJ1ZmZlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRCdWZmZXIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgbGVuID0gYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGg7XG4gICAgb2Zmc2V0IHw9IDA7XG4gICAgcmV0dXJuIGxlbiAmJiAob2Zmc2V0ICsgOCA8PSBsZW4pICYmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgYnVmZmVyW29mZnNldF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUFycmF5KGRlc3RidWYsIGRlc3RvZmYsIHNyY2J1Ziwgc3Jjb2ZmKSB7XG4gICAgZGVzdG9mZiB8PSAwO1xuICAgIHNyY29mZiB8PSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBkZXN0YnVmW2Rlc3RvZmYrK10gPSBzcmNidWZbc3Jjb2ZmKytdICYgMjU1O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld0FycmF5KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ1ZmZlciwgb2Zmc2V0LCBvZmZzZXQgKyA4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21Qb3NpdGl2ZUJFKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIHZhciBwb3MgPSBvZmZzZXQgKyA4O1xuICAgIHdoaWxlIChwb3MgPiBvZmZzZXQpIHtcbiAgICAgIGJ1ZmZlclstLXBvc10gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHZhbHVlIC89IDI1NjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tTmVnYXRpdmVCRShidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICB2YXIgcG9zID0gb2Zmc2V0ICsgODtcbiAgICB2YWx1ZSsrO1xuICAgIHdoaWxlIChwb3MgPiBvZmZzZXQpIHtcbiAgICAgIGJ1ZmZlclstLXBvc10gPSAoKC12YWx1ZSkgJiAyNTUpIF4gMjU1O1xuICAgICAgdmFsdWUgLz0gMjU2O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21Qb3NpdGl2ZUxFKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIHZhciBlbmQgPSBvZmZzZXQgKyA4O1xuICAgIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHZhbHVlIC89IDI1NjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tTmVnYXRpdmVMRShidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgODtcbiAgICB2YWx1ZSsrO1xuICAgIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAoKC12YWx1ZSkgJiAyNTUpIF4gMjU1O1xuICAgICAgdmFsdWUgLz0gMjU2O1xuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXRyb2ZveC9pcy1hcnJheVxuICBmdW5jdGlvbiBfaXNBcnJheSh2YWwpIHtcbiAgICByZXR1cm4gISF2YWwgJiYgXCJbb2JqZWN0IEFycmF5XVwiID09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpO1xuICB9XG5cbn0odHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzLm5vZGVOYW1lICE9PSAnc3RyaW5nJyA/IGV4cG9ydHMgOiAodGhpcyB8fCB7fSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZW55TGlzdCA9IG5ldyBTZXQoW1xuXHQnRU5PVEZPVU5EJyxcblx0J0VORVRVTlJFQUNIJyxcblxuXHQvLyBTU0wgZXJyb3JzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZmM4ZTNlMmNkYzUyMTk3ODM1MWRlMjU3MDMwZGIwMDc2ZDc5ZTBhYi9zcmMvY3J5cHRvL2NyeXB0b19jb21tb24uY2MjTDMwMS1MMzI4XG5cdCdVTkFCTEVfVE9fR0VUX0lTU1VFUl9DRVJUJyxcblx0J1VOQUJMRV9UT19HRVRfQ1JMJyxcblx0J1VOQUJMRV9UT19ERUNSWVBUX0NFUlRfU0lHTkFUVVJFJyxcblx0J1VOQUJMRV9UT19ERUNSWVBUX0NSTF9TSUdOQVRVUkUnLFxuXHQnVU5BQkxFX1RPX0RFQ09ERV9JU1NVRVJfUFVCTElDX0tFWScsXG5cdCdDRVJUX1NJR05BVFVSRV9GQUlMVVJFJyxcblx0J0NSTF9TSUdOQVRVUkVfRkFJTFVSRScsXG5cdCdDRVJUX05PVF9ZRVRfVkFMSUQnLFxuXHQnQ0VSVF9IQVNfRVhQSVJFRCcsXG5cdCdDUkxfTk9UX1lFVF9WQUxJRCcsXG5cdCdDUkxfSEFTX0VYUElSRUQnLFxuXHQnRVJST1JfSU5fQ0VSVF9OT1RfQkVGT1JFX0ZJRUxEJyxcblx0J0VSUk9SX0lOX0NFUlRfTk9UX0FGVEVSX0ZJRUxEJyxcblx0J0VSUk9SX0lOX0NSTF9MQVNUX1VQREFURV9GSUVMRCcsXG5cdCdFUlJPUl9JTl9DUkxfTkVYVF9VUERBVEVfRklFTEQnLFxuXHQnT1VUX09GX01FTScsXG5cdCdERVBUSF9aRVJPX1NFTEZfU0lHTkVEX0NFUlQnLFxuXHQnU0VMRl9TSUdORURfQ0VSVF9JTl9DSEFJTicsXG5cdCdVTkFCTEVfVE9fR0VUX0lTU1VFUl9DRVJUX0xPQ0FMTFknLFxuXHQnVU5BQkxFX1RPX1ZFUklGWV9MRUFGX1NJR05BVFVSRScsXG5cdCdDRVJUX0NIQUlOX1RPT19MT05HJyxcblx0J0NFUlRfUkVWT0tFRCcsXG5cdCdJTlZBTElEX0NBJyxcblx0J1BBVEhfTEVOR1RIX0VYQ0VFREVEJyxcblx0J0lOVkFMSURfUFVSUE9TRScsXG5cdCdDRVJUX1VOVFJVU1RFRCcsXG5cdCdDRVJUX1JFSkVDVEVEJyxcblx0J0hPU1ROQU1FX01JU01BVENIJ1xuXSk7XG5cbi8vIFRPRE86IFVzZSBgZXJyb3I/LmNvZGVgIHdoZW4gdGFyZ2V0aW5nIE5vZGUuanMgMTRcbm1vZHVsZS5leHBvcnRzID0gZXJyb3IgPT4gIWRlbnlMaXN0LmhhcyhlcnJvciAmJiBlcnJvci5jb2RlKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICAgIFVSTFdpdGhMZWdhY3lTdXBwb3J0LFxuICAgIGZvcm1hdCxcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgZGVmYXVsdEJhc2Vcbn0gPSByZXF1aXJlKCcuL3NyYy91cmwnKTtcbmNvbnN0IHJlbGF0aXZlID0gcmVxdWlyZSgnLi9zcmMvcmVsYXRpdmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgVVJMOiBVUkxXaXRoTGVnYWN5U3VwcG9ydCxcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgZm9ybWF0LFxuICAgIHJlbGF0aXZlLFxuICAgIGRlZmF1bHRCYXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFVSTFdpdGhMZWdhY3lTdXBwb3J0LCBmb3JtYXQgfSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHVybCwgbG9jYXRpb24gPSB7fSwgcHJvdG9jb2xNYXAgPSB7fSwgZGVmYXVsdFByb3RvY29sKSA9PiB7XG4gICAgbGV0IHByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wgP1xuICAgICAgICBsb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpIDpcbiAgICAgICAgJ2h0dHAnO1xuXG4gICAgLy8gQ2hlY2sgcHJvdG9jb2wgbWFwXG4gICAgcHJvdG9jb2wgPSAocHJvdG9jb2xNYXBbcHJvdG9jb2xdIHx8IGRlZmF1bHRQcm90b2NvbCB8fCBwcm90b2NvbCkgKyAnOic7XG4gICAgbGV0IHVybFBhcnNlZDtcblxuICAgIHRyeSB7XG4gICAgICAgIHVybFBhcnNlZCA9IG5ldyBVUkxXaXRoTGVnYWN5U3VwcG9ydCh1cmwpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB1cmxQYXJzZWQgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlID0gT2JqZWN0LmFzc2lnbih7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sIHx8IHVybFBhcnNlZC5wcm90b2NvbCxcbiAgICAgICAgaG9zdDogbG9jYXRpb24uaG9zdCB8fCB1cmxQYXJzZWQuaG9zdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBVUkxXaXRoTGVnYWN5U3VwcG9ydCh1cmwsIGZvcm1hdChiYXNlKSkudG9TdHJpbmcoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRCYXNlID0gc2VsZi5sb2NhdGlvbiA/XG4gICAgc2VsZi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBzZWxmLmxvY2F0aW9uLmhvc3QgOlxuICAgICcnO1xuY29uc3QgVVJMID0gc2VsZi5VUkw7XG5cbmNsYXNzIFVSTFdpdGhMZWdhY3lTdXBwb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwgPSAnJywgYmFzZSA9IGRlZmF1bHRCYXNlKSB7XG4gICAgICAgIHRoaXMuc3VwZXIgPSBuZXcgVVJMKHVybCwgYmFzZSk7XG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMucGF0aG5hbWUgKyB0aGlzLnNlYXJjaDtcbiAgICAgICAgdGhpcy5hdXRoID1cbiAgICAgICAgICAgIHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCA/XG4gICAgICAgICAgICAgICAgdGhpcy51c2VybmFtZSArICc6JyArIHRoaXMucGFzc3dvcmQgOlxuICAgICAgICAgICAgICAgIG51bGw7XG5cbiAgICAgICAgdGhpcy5xdWVyeSA9XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCAmJiB0aGlzLnNlYXJjaC5zdGFydHNXaXRoKCc/JykgP1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnNsaWNlKDEpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5oYXNoO1xuICAgIH1cbiAgICBnZXQgaG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuaG9zdDtcbiAgICB9XG4gICAgZ2V0IGhvc3RuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5ob3N0bmFtZTtcbiAgICB9XG4gICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmhyZWY7XG4gICAgfVxuICAgIGdldCBvcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLm9yaWdpbjtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wYXNzd29yZDtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHBvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnBvcnQ7XG4gICAgfVxuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIucHJvdG9jb2w7XG4gICAgfVxuICAgIGdldCBzZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnNlYXJjaDtcbiAgICB9XG4gICAgZ2V0IHNlYXJjaFBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnVzZXJuYW1lO1xuICAgIH1cblxuICAgIHNldCBoYXNoKGhhc2gpIHtcbiAgICAgICAgdGhpcy5zdXBlci5oYXNoID0gaGFzaDtcbiAgICB9XG4gICAgc2V0IGhvc3QoaG9zdCkge1xuICAgICAgICB0aGlzLnN1cGVyLmhvc3QgPSBob3N0O1xuICAgIH1cbiAgICBzZXQgaG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgICAgICAgdGhpcy5zdXBlci5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuICAgIH1cbiAgICBzZXQgaHJlZihocmVmKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIHNldCBvcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMuc3VwZXIub3JpZ2luID0gb3JpZ2luO1xuICAgIH1cbiAgICBzZXQgcGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIH1cbiAgICBzZXQgcGF0aG5hbWUocGF0aG5hbWUpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgIH1cbiAgICBzZXQgcG9ydChwb3J0KSB7XG4gICAgICAgIHRoaXMuc3VwZXIucG9ydCA9IHBvcnQ7XG4gICAgfVxuICAgIHNldCBwcm90b2NvbChwcm90b2NvbCkge1xuICAgICAgICB0aGlzLnN1cGVyLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuICAgIHNldCBzZWFyY2goc2VhcmNoKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuc2VhcmNoID0gc2VhcmNoO1xuICAgIH1cbiAgICBzZXQgc2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcykge1xuICAgICAgICB0aGlzLnN1cGVyLnNlYXJjaFBhcmFtcyA9IHNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgc2V0IHVzZXJuYW1lKHVzZXJuYW1lKSB7XG4gICAgICAgIHRoaXMuc3VwZXIudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICB9XG5cbiAgICBjcmVhdGVPYmplY3RVUkwobykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5jcmVhdGVPYmplY3RVUkwobyk7XG4gICAgfVxuICAgIHJldm9rZU9iamVjdFVSTChvKSB7XG4gICAgICAgIHRoaXMuc3VwZXIucmV2b2tlT2JqZWN0VVJMKG8pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnRvSlNPTigpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9iaik7XG5cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgY29uc3QgdXNlclBhc3MgPVxuICAgICAgICAgICAgb2JqLnVzZXJuYW1lICYmIG9iai5wYXNzd29yZCA/XG4gICAgICAgICAgICAgICAgYCR7b2JqLnVzZXJuYW1lfToke29iai5wYXNzd29yZH1AYCA6XG4gICAgICAgICAgICAgICAgJyc7XG4gICAgICAgIGNvbnN0IGF1dGggPSBvYmouYXV0aCA/IG9iai5hdXRoICsgJ0AnIDogJyc7XG4gICAgICAgIGNvbnN0IHBvcnQgPSBvYmoucG9ydCA/ICc6JyArIG9iai5wb3J0IDogJyc7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gb2JqLnByb3RvY29sID8gb2JqLnByb3RvY29sICsgJy8vJyA6ICcnO1xuICAgICAgICBjb25zdCBob3N0ID0gb2JqLmhvc3QgfHwgJyc7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gb2JqLmhvc3RuYW1lIHx8ICcnO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChvYmoucXVlcnkgPyAnPycgKyBvYmoucXVlcnkgOiAnJyk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBvYmouaGFzaCB8fCAnJztcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBvYmoucGF0aG5hbWUgfHwgJyc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBvYmoucGF0aCB8fCBwYXRobmFtZSArIHNlYXJjaDtcblxuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHt1c2VyUGFzcyB8fCBhdXRofSR7aG9zdCB8fFxuICAgICAgICAgICAgaG9zdG5hbWUgKyBwb3J0fSR7cGF0aH0ke2hhc2h9YDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFVSTFdpdGhMZWdhY3lTdXBwb3J0LFxuICAgIFVSTFNlYXJjaFBhcmFtczogc2VsZi5VUkxTZWFyY2hQYXJhbXMsXG4gICAgZGVmYXVsdEJhc2UsXG4gICAgZm9ybWF0XG59O1xuIiwiLy8gdGhlIHdoYXR3Zy1mZXRjaCBwb2x5ZmlsbCBpbnN0YWxscyB0aGUgZmV0Y2goKSBmdW5jdGlvblxuLy8gb24gdGhlIGdsb2JhbCBvYmplY3QgKHdpbmRvdyBvciBzZWxmKVxuLy9cbi8vIFJldHVybiB0aGF0IGFzIHRoZSBleHBvcnQgZm9yIHVzZSBpbiBXZWJwYWNrLCBCcm93c2VyaWZ5IGV0Yy5cbnJlcXVpcmUoJ3doYXR3Zy1mZXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBzZWxmLmZldGNoLmJpbmQoc2VsZik7XG4iLCJcbi8qKlxuICogSm9pbiBgYXJyYCB3aXRoIHRoZSB0cmFpbGluZyBgc3RyYCBkZWZhdWx0aW5nIHRvIFwiYW5kXCIsXG4gKiBhbmQgYHNlcGAgc3RyaW5nIGRlZmF1bHRpbmcgdG8gXCIsIFwiLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHNlcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgc3RyLCBzZXApe1xuICBzdHIgPSBzdHIgfHwgJ2FuZCc7XG4gIHNlcCA9IHNlcCB8fCAnLCAnO1xuXG4gIGlmIChhcnIubGVuZ3RoIDwgMikgcmV0dXJuIGFyclswXSB8fCAnJztcblxuICB2YXIgb3hmb3JkID0gc3RyLnNsaWNlKDAsIDIpID09PSBzZXA7XG5cbiAgaWYgKCFveGZvcmQpIHtcbiAgICBzdHIgPSAnICcgKyBzdHI7XG4gIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PSAyKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFyci5zbGljZSgwLCAtMSkuam9pbihzZXApICsgc3RyICsgJyAnICsgYXJyW2Fyci5sZW5ndGggLSAxXTtcbn07XG4iLCJcblxuLy9cbi8vIFRISVMgRklMRSBJUyBBVVRPTUFUSUNBTExZIEdFTkVSQVRFRCEgRE8gTk9UIEVESVQgQlkgSEFORCFcbi8vXG47KGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXG4gICAgICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgICAgID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzExOVxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICAgICAgICAgIGNvbnN0IF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICAgICAgY29uc3QgZ0Jhc2U2NCA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgIGdCYXNlNjQubm9Db25mbGljdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ0Jhc2U2NDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLk1ldGVvcikgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgICAgICAgICBCYXNlNjQgPSBnQmFzZTY0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmFsLkJhc2U2NCA9IGdCYXNlNjQ7XG4gICAgICAgIH0pKCk7XG59KCh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFxuICAgICAgICA6IHRoaXNcbiksIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiAgYmFzZTY0LnRzXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbiAqICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiAgUmVmZXJlbmNlczpcbiAqICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0XG4gKlxuICogQGF1dGhvciBEYW4gS29nYWkgKGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaSlcbiAqL1xuY29uc3QgdmVyc2lvbiA9ICczLjYuMSc7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBsb3dlcmNhc2UgYHZlcnNpb25gLlxuICovXG5jb25zdCBWRVJTSU9OID0gdmVyc2lvbjtcbmNvbnN0IF9oYXNhdG9iID0gdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbic7XG5jb25zdCBfaGFzYnRvYSA9IHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nO1xuY29uc3QgX2hhc0J1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5jb25zdCBfVEQgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgVGV4dERlY29kZXIoKSA6IHVuZGVmaW5lZDtcbmNvbnN0IF9URSA9IHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RW5jb2RlcigpIDogdW5kZWZpbmVkO1xuY29uc3QgYjY0Y2ggPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuY29uc3QgYjY0Y2hzID0gWy4uLmI2NGNoXTtcbmNvbnN0IGI2NHRhYiA9ICgoYSkgPT4ge1xuICAgIGxldCB0YWIgPSB7fTtcbiAgICBhLmZvckVhY2goKGMsIGkpID0+IHRhYltjXSA9IGkpO1xuICAgIHJldHVybiB0YWI7XG59KShiNjRjaHMpO1xuY29uc3QgYjY0cmUgPSAvXig/OltBLVphLXpcXGQrXFwvXXs0fSkqPyg/OltBLVphLXpcXGQrXFwvXXsyfSg/Oj09KT98W0EtWmEtelxcZCtcXC9dezN9PT8pPyQvO1xuY29uc3QgX2Zyb21DQyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYmluZChTdHJpbmcpO1xuY29uc3QgX1U4QWZyb20gPSB0eXBlb2YgVWludDhBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nXG4gICAgPyBVaW50OEFycmF5LmZyb20uYmluZChVaW50OEFycmF5KVxuICAgIDogKGl0LCBmbiA9ICh4KSA9PiB4KSA9PiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpdCwgMCkubWFwKGZuKSk7XG5jb25zdCBfbWtVcmlTYWZlID0gKHNyYykgPT4gc3JjXG4gICAgLnJlcGxhY2UoL1srXFwvXS9nLCAobTApID0+IG0wID09ICcrJyA/ICctJyA6ICdfJylcbiAgICAucmVwbGFjZSgvPSskL20sICcnKTtcbmNvbnN0IF90aWR5QjY0ID0gKHMpID0+IHMucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTtcbi8qKlxuICogcG9seWZpbGwgdmVyc2lvbiBvZiBgYnRvYWBcbiAqL1xuY29uc3QgYnRvYVBvbHlmaWxsID0gKGJpbikgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgbGV0IHUzMiwgYzAsIGMxLCBjMiwgYXNjID0gJyc7XG4gICAgY29uc3QgcGFkID0gYmluLmxlbmd0aCAlIDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOykge1xuICAgICAgICBpZiAoKGMwID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUgfHxcbiAgICAgICAgICAgIChjMSA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAoYzIgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgICAgIHUzMiA9IChjMCA8PCAxNikgfCAoYzEgPDwgOCkgfCBjMjtcbiAgICAgICAgYXNjICs9IGI2NGNoc1t1MzIgPj4gMTggJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiA+PiAxMiAmIDYzXVxuICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDYgJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiAmIDYzXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZCA/IGFzYy5zbGljZSgwLCBwYWQgLSAzKSArIFwiPT09XCIuc3Vic3RyaW5nKHBhZCkgOiBhc2M7XG59O1xuLyoqXG4gKiBkb2VzIHdoYXQgYHdpbmRvdy5idG9hYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gYmluIGJpbmFyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICovXG5jb25zdCBfYnRvYSA9IF9oYXNidG9hID8gKGJpbikgPT4gYnRvYShiaW4pXG4gICAgOiBfaGFzQnVmZmVyID8gKGJpbikgPT4gQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIDogYnRvYVBvbHlmaWxsO1xuY29uc3QgX2Zyb21VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgID8gKHU4YSkgPT4gQnVmZmVyLmZyb20odThhKS50b1N0cmluZygnYmFzZTY0JylcbiAgICA6ICh1OGEpID0+IHtcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNzEwMDAxL2hvdy10by1jb252ZXJ0LXVpbnQ4LWFycmF5LXRvLWJhc2U2NC1lbmNvZGVkLXN0cmluZy8xMjcxMzMyNiMxMjcxMzMyNlxuICAgICAgICBjb25zdCBtYXhhcmdzID0gMHgxMDAwO1xuICAgICAgICBsZXQgc3RycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHU4YS5sZW5ndGg7IGkgPCBsOyBpICs9IG1heGFyZ3MpIHtcbiAgICAgICAgICAgIHN0cnMucHVzaChfZnJvbUNDLmFwcGx5KG51bGwsIHU4YS5zdWJhcnJheShpLCBpICsgbWF4YXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2J0b2Eoc3Rycy5qb2luKCcnKSk7XG4gICAgfTtcbi8qKlxuICogY29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIFVSTC1hbmQtZmlsZW5hbWUtc2FmZSBhIGxhIFJGQzQ2NDggwqc1XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGZyb21VaW50OEFycmF5ID0gKHU4YSwgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlID8gX21rVXJpU2FmZShfZnJvbVVpbnQ4QXJyYXkodThhKSkgOiBfZnJvbVVpbnQ4QXJyYXkodThhKTtcbi8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuLy8gY29uc3QgdXRvYiA9IChzcmM6IHN0cmluZykgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgY2JfdXRvYiA9IChjKSA9PiB7XG4gICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBjYyA8IDB4ODAgPyBjXG4gICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoX2Zyb21DQygweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSlcbiAgICAgICAgICAgICAgICA6IChfZnJvbUNDKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgIHJldHVybiAoX2Zyb21DQygweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgIH1cbn07XG5jb25zdCByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4vKipcbiAqIEBkZXByZWNhdGVkIHNob3VsZCBoYXZlIGJlZW4gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFVURi04IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTE2IHN0cmluZ1xuICovXG5jb25zdCB1dG9iID0gKHUpID0+IHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTtcbi8vXG5jb25zdCBfZW5jb2RlID0gX2hhc0J1ZmZlclxuICAgID8gKHMpID0+IEJ1ZmZlci5mcm9tKHMsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgOiBfVEVcbiAgICAgICAgPyAocykgPT4gX2Zyb21VaW50OEFycmF5KF9URS5lbmNvZGUocykpXG4gICAgICAgIDogKHMpID0+IF9idG9hKHV0b2IocykpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIGlmIGB0cnVlYCBtYWtlIHRoZSByZXN1bHQgVVJMLXNhZmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgZW5jb2RlID0gKHNyYywgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlXG4gICAgPyBfbWtVcmlTYWZlKF9lbmNvZGUoc3JjKSlcbiAgICA6IF9lbmNvZGUoc3JjKTtcbi8qKlxuICogY29udmVydHMgYSBVVEYtOC1lbmNvZGVkIHN0cmluZyB0byBVUkwtc2FmZSBCYXNlNjQgUkZDNDY0OCDCpzUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGVuY29kZVVSSSA9IChzcmMpID0+IGVuY29kZShzcmMsIHRydWUpO1xuLy8gVGhpcyB0cmljayBpcyBmb3VuZCBicm9rZW4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTMwXG4vLyBjb25zdCBidG91ID0gKHNyYzogc3RyaW5nKSA9PiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuY29uc3QgY2JfYnRvdSA9IChjY2NjKSA9PiB7XG4gICAgc3dpdGNoIChjY2NjLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgY3AgPSAoKDB4MDcgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDE4KVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCAxMilcbiAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSwgb2Zmc2V0ID0gY3AgLSAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIChfZnJvbUNDKChvZmZzZXQgPj4+IDEwKSArIDB4RDgwMClcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoKG9mZnNldCAmIDB4M0ZGKSArIDB4REMwMCkpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2Zyb21DQygoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCA2KVxuICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSk7XG4gICAgfVxufTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgc2hvdWxkIGhhdmUgYmVlbiBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTE2IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gKi9cbmNvbnN0IGJ0b3UgPSAoYikgPT4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuLyoqXG4gKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBhdG9iYFxuICovXG5jb25zdCBhdG9iUG9seWZpbGwgPSAoYXNjKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ3BvbHlmaWxsZWQnKTtcbiAgICBhc2MgPSBhc2MucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgaWYgKCFiNjRyZS50ZXN0KGFzYykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBiYXNlNjQuJyk7XG4gICAgYXNjICs9ICc9PScuc2xpY2UoMiAtIChhc2MubGVuZ3RoICYgMykpO1xuICAgIGxldCB1MjQsIGJpbiA9ICcnLCByMSwgcjI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc2MubGVuZ3RoOykge1xuICAgICAgICB1MjQgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxOFxuICAgICAgICAgICAgfCBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxMlxuICAgICAgICAgICAgfCAocjEgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSkgPDwgNlxuICAgICAgICAgICAgfCAocjIgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSk7XG4gICAgICAgIGJpbiArPSByMSA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSlcbiAgICAgICAgICAgIDogcjIgPT09IDY0ID8gX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1KVxuICAgICAgICAgICAgICAgIDogX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1LCB1MjQgJiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gYmluO1xufTtcbi8qKlxuICogZG9lcyB3aGF0IGB3aW5kb3cuYXRvYmAgb2Ygd2ViIGJyb3dzZXJzIGRvLlxuICogQHBhcmFtIHtTdHJpbmd9IGFzYyBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGJpbmFyeSBzdHJpbmdcbiAqL1xuY29uc3QgX2F0b2IgPSBfaGFzYXRvYiA/IChhc2MpID0+IGF0b2IoX3RpZHlCNjQoYXNjKSlcbiAgICA6IF9oYXNCdWZmZXIgPyAoYXNjKSA9PiBCdWZmZXIuZnJvbShhc2MsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5JylcbiAgICAgICAgOiBhdG9iUG9seWZpbGw7XG4vL1xuY29uc3QgX3RvVWludDhBcnJheSA9IF9oYXNCdWZmZXJcbiAgICA/IChhKSA9PiBfVThBZnJvbShCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykpXG4gICAgOiAoYSkgPT4gX1U4QWZyb20oX2F0b2IoYSksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcbi8qKlxuICogY29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqL1xuY29uc3QgdG9VaW50OEFycmF5ID0gKGEpID0+IF90b1VpbnQ4QXJyYXkoX3VuVVJJKGEpKTtcbi8vXG5jb25zdCBfZGVjb2RlID0gX2hhc0J1ZmZlclxuICAgID8gKGEpID0+IEJ1ZmZlci5mcm9tKGEsICdiYXNlNjQnKS50b1N0cmluZygndXRmOCcpXG4gICAgOiBfVERcbiAgICAgICAgPyAoYSkgPT4gX1RELmRlY29kZShfdG9VaW50OEFycmF5KGEpKVxuICAgICAgICA6IChhKSA9PiBidG91KF9hdG9iKGEpKTtcbmNvbnN0IF91blVSSSA9IChhKSA9PiBfdGlkeUI2NChhLnJlcGxhY2UoL1stX10vZywgKG0wKSA9PiBtMCA9PSAnLScgPyAnKycgOiAnLycpKTtcbi8qKlxuICogY29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgVVRGLTggc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHNyYyBCYXNlNjQgc3RyaW5nLiAgQm90aCBub3JtYWwgYW5kIFVSTC1zYWZlIGFyZSBzdXBwb3J0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi04IHN0cmluZ1xuICovXG5jb25zdCBkZWNvZGUgPSAoc3JjKSA9PiBfZGVjb2RlKF91blVSSShzcmMpKTtcbi8qKlxuICogY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIEJhc2U2NCBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgYSB2YWx1ZSB0byBjaGVja1xuICAqL1xuY29uc3QgaXNWYWxpZCA9IChzcmMpID0+IHtcbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzID0gc3JjLnJlcGxhY2UoL1xccysvZywgJycpLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICByZXR1cm4gIS9bXlxcczAtOWEtekEtWlxcKy9dLy50ZXN0KHMpIHx8ICEvW15cXHMwLTlhLXpBLVpcXC1fXS8udGVzdChzKTtcbn07XG4vL1xuY29uc3QgX25vRW51bSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHYsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbn07XG4vKipcbiAqIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICovXG5jb25zdCBleHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7XG4gICAgX2FkZCgnZnJvbUJhc2U2NCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZSh0aGlzKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjRVUkwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSk7IH0pO1xuICAgIF9hZGQoJ3RvVWludDhBcnJheScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzKTsgfSk7XG59O1xuLyoqXG4gKiBleHRlbmQgVWludDhBcnJheS5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZFVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDhBcnJheS5wcm90b3R5cGUsIG5hbWUsIF9ub0VudW0oYm9keSkpO1xuICAgIF9hZGQoJ3RvQmFzZTY0JywgZnVuY3Rpb24gKHVybHNhZmUpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbn07XG4vKipcbiAqIGV4dGVuZCBCdWlsdGluIHByb3RvdHlwZXMgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZEJ1aWx0aW5zID0gKCkgPT4ge1xuICAgIGV4dGVuZFN0cmluZygpO1xuICAgIGV4dGVuZFVpbnQ4QXJyYXkoKTtcbn07XG5jb25zdCBnQmFzZTY0ID0ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgVkVSU0lPTjogVkVSU0lPTixcbiAgICBhdG9iOiBfYXRvYixcbiAgICBhdG9iUG9seWZpbGw6IGF0b2JQb2x5ZmlsbCxcbiAgICBidG9hOiBfYnRvYSxcbiAgICBidG9hUG9seWZpbGw6IGJ0b2FQb2x5ZmlsbCxcbiAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICBlbmNvZGVVUkw6IGVuY29kZVVSSSxcbiAgICB1dG9iOiB1dG9iLFxuICAgIGJ0b3U6IGJ0b3UsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBmcm9tVWludDhBcnJheTogZnJvbVVpbnQ4QXJyYXksXG4gICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXksXG4gICAgZXh0ZW5kU3RyaW5nOiBleHRlbmRTdHJpbmcsXG4gICAgZXh0ZW5kVWludDhBcnJheTogZXh0ZW5kVWludDhBcnJheSxcbiAgICBleHRlbmRCdWlsdGluczogZXh0ZW5kQnVpbHRpbnMsXG59O1xuXG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIC8vIEVTNSBpcyB5ZXQgdG8gaGF2ZSBPYmplY3QuYXNzaWduKCkgdGhhdCBtYXkgbWFrZSB0cmFuc3BpbGVycyB1bmhhcHB5LlxuICAgIC8vIGdCYXNlNjQuQmFzZTY0ID0gT2JqZWN0LmFzc2lnbih7fSwgZ0Jhc2U2NCk7XG4gICAgZ0Jhc2U2NC5CYXNlNjQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhnQmFzZTY0KS5mb3JFYWNoKGsgPT4gZ0Jhc2U2NC5CYXNlNjRba10gPSBnQmFzZTY0W2tdKTtcbiAgICByZXR1cm4gZ0Jhc2U2NDtcbn0pKTtcblxuXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWRhYmxlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcbi8qKlxuICogVGFrZXMgYSBKc29uUnBjRW5naW5lIGFuZCByZXR1cm5zIGEgRHVwbGV4IHN0cmVhbSB3cmFwcGluZyBpdC5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdHMuZW5naW5lIC0gVGhlIEpzb25ScGNFbmdpbmUgdG8gd3JhcCBpbiBhIHN0cmVhbS5cbiAqIEByZXR1cm5zIFRoZSBzdHJlYW0gd3JhcHBpbmcgdGhlIGVuZ2luZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW5naW5lU3RyZWFtKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuZW5naW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlbmdpbmUgcGFyYW1ldGVyIScpO1xuICAgIH1cbiAgICBjb25zdCB7IGVuZ2luZSB9ID0gb3B0cztcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgcmVhZGFibGVfc3RyZWFtXzEuRHVwbGV4KHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZDogKCkgPT4gdW5kZWZpbmVkLCB3cml0ZSB9KTtcbiAgICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgICBpZiAoZW5naW5lLm9uKSB7XG4gICAgICAgIGVuZ2luZS5vbignbm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIEpTT04tUlBDIHJlcXVlc3QgdG8gdGhlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgSlNPTi1ycGMgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gX2VuY29kaW5nIC0gVGhlIHN0cmVhbSBlbmNvZGluZywgbm90IHVzZWQuXG4gICAgICogQHBhcmFtIGNiIC0gVGhlIHN0cmVhbSB3cml0ZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cml0ZShyZXEsIF9lbmNvZGluZywgY2IpIHtcbiAgICAgICAgZW5naW5lLmhhbmRsZShyZXEsIChfZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5wdXNoKHJlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUVuZ2luZVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUVuZ2luZVN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNvbnN0IHJlYWRhYmxlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIEpzb25ScGNFbmdpbmUgbWlkZGxld2FyZSB3aXRoIGFuIGFzc29jaWF0ZWQgRHVwbGV4IHN0cmVhbSBhbmRcbiAqIEV2ZW50RW1pdHRlci4gVGhlIG1pZGRsZXdhcmUsIGFuZCBieSBleHRlbnNpb24gc3RyZWFtLCBhc3N1bWUgdGhhdCBtaWRkbGV3YXJlXG4gKiBwYXJhbWV0ZXJzIGFyZSBwcm9wZXJseSBmb3JtYXR0ZWQuIE5vIHJ1bnRpbWUgdHlwZSBjaGVja2luZyBvciB2YWxpZGF0aW9uIGlzXG4gKiBwZXJmb3JtZWQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIG1pZGRsZXdhcmUuXG4gKiBAcmV0dXJucyBUaGUgZXZlbnQgZW1pdHRlciwgbWlkZGxld2FyZSwgYW5kIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtTWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpZE1hcCA9IHt9OyAvLyBUT0RPOiByZXBsYWNlIHdpdGggYWN0dWFsIE1hcFxuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyByZWFkYWJsZV9zdHJlYW1fMS5EdXBsZXgoe1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICByZWFkOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgIHdyaXRlOiBwcm9jZXNzTWVzc2FnZSxcbiAgICB9KTtcbiAgICBjb25zdCBldmVudHMgPSBuZXcgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCgpO1xuICAgIGNvbnN0IG1pZGRsZXdhcmUgPSAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgICAvLyB3cml0ZSByZXEgdG8gc3RyZWFtXG4gICAgICAgIHNlbmRUb1N0cmVhbShyZXEpO1xuICAgICAgICAvLyByZWdpc3RlciByZXF1ZXN0IG9uIGlkIG1hcFxuICAgICAgICBpZE1hcFtyZXEuaWRdID0geyByZXEsIHJlcywgbmV4dCwgZW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBldmVudHMsIG1pZGRsZXdhcmUsIHN0cmVhbSB9O1xuICAgIC8qKlxuICAgICAqIEZvcndhcmRzIEpTT04tUlBDIHJlcXVlc3QgdG8gdGhlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZFRvU3RyZWFtKHJlcSkge1xuICAgICAgICAvLyBUT0RPOiBsaW1pdGluZyByZXRyaWVzIGNvdWxkIGJlIGltcGxlbWVudGVkIGhlcmVcbiAgICAgICAgc3RyZWFtLnB1c2gocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgSlNPTi1SUEMgb2JqZWN0IHRvIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gX2VuY29kaW5nIC0gVGhlIHN0cmVhbSBlbmNvZGluZywgbm90IHVzZWQuXG4gICAgICogQHBhcmFtIGNiIC0gVGhlIHN0cmVhbSB3cml0ZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShyZXMsIF9lbmNvZGluZywgY2IpIHtcbiAgICAgICAgbGV0IGVyciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc05vdGlmaWNhdGlvbiA9ICFyZXMuaWQ7XG4gICAgICAgICAgICBpZiAoaXNOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzUmVzcG9uc2UocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nIHN0cmVhbVxuICAgICAgICBjYihlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBKU09OLVJQQyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXMgLSBUaGUgcmVzcG9uc2UgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2UocmVzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBpZE1hcFtyZXMuaWRdO1xuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU3RyZWFtTWlkZGxld2FyZSAtIFVua25vd24gcmVzcG9uc2UgaWQgXCIke3Jlcy5pZH1cImApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBpZE1hcFtyZXMuaWRdO1xuICAgICAgICAvLyBjb3B5IHdob2xlIHJlcyBvbnRvIG9yaWdpbmFsIHJlc1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbnRleHQucmVzLCByZXMpO1xuICAgICAgICAvLyBydW4gY2FsbGJhY2sgb24gZW1wdHkgc3RhY2ssXG4gICAgICAgIC8vIHByZXZlbnQgaW50ZXJuYWwgc3RyZWFtLWhhbmRsZXIgZnJvbSBjYXRjaGluZyBlcnJvcnNcbiAgICAgICAgc2V0VGltZW91dChjb250ZXh0LmVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIEpTT04tUlBDIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub3RpZiAtIFRoZSBub3RpZmljYXRpb24gdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzTm90aWZpY2F0aW9uKG5vdGlmKSB7XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJldHJ5T25NZXNzYWdlKSAmJiBub3RpZi5tZXRob2QgPT09IG9wdGlvbnMucmV0cnlPbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHJ5U3R1Y2tSZXF1ZXN0cygpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50cy5lbWl0KCdub3RpZmljYXRpb24nLCBub3RpZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJ5IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cnlTdHVja1JlcXVlc3RzKCkge1xuICAgICAgICBPYmplY3QudmFsdWVzKGlkTWFwKS5mb3JFYWNoKCh7IHJlcSwgcmV0cnlDb3VudCA9IDAgfSkgPT4ge1xuICAgICAgICAgICAgLy8gQXZvaWQgcmV0cnlpbmcgcmVxdWVzdHMgd2l0aG91dCBhbiBpZCAtIHRoZXkgY2Fubm90IGhhdmUgbWF0Y2hpbmcgcmVzcG9uc2VzIHNvIHJldHJ5IGxvZ2ljIGRvZXNuJ3QgYXBwbHlcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciByZXRyeSBjb3VudCBiZWxvdyBlbnN1cmUgdGhhdCBhIHJlcXVlc3QgaXMgbm90IHJldHJpZWQgbW9yZSB0aGFuIDMgdGltZXNcbiAgICAgICAgICAgIGlmICghcmVxLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHJ5Q291bnQgPj0gMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyZWFtTWlkZGxld2FyZSAtIFJldHJ5IGxpbWl0IGV4Y2VlZGVkIGZvciByZXF1ZXN0IGlkIFwiJHtyZXEuaWR9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkTWFwW3JlcS5pZF0ucmV0cnlDb3VudCA9IHJldHJ5Q291bnQgKyAxO1xuICAgICAgICAgICAgc2VuZFRvU3RyZWFtKHJlcSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVTdHJlYW1NaWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVTdHJlYW1NaWRkbGV3YXJlID0gZXhwb3J0cy5jcmVhdGVFbmdpbmVTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBjcmVhdGVFbmdpbmVTdHJlYW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jcmVhdGVFbmdpbmVTdHJlYW1cIikpO1xuZXhwb3J0cy5jcmVhdGVFbmdpbmVTdHJlYW0gPSBjcmVhdGVFbmdpbmVTdHJlYW1fMS5kZWZhdWx0O1xuY29uc3QgY3JlYXRlU3RyZWFtTWlkZGxld2FyZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NyZWF0ZVN0cmVhbU1pZGRsZXdhcmVcIikpO1xuZXhwb3J0cy5jcmVhdGVTdHJlYW1NaWRkbGV3YXJlID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZV8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBqc29uID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnID8gSlNPTiA6IHJlcXVpcmUoJ2pzb25pZnknKTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG5cdHZhciBrZXlzID0gW107XG5cdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7IGtleXMucHVzaChrZXkpOyB9XG5cdH1cblx0cmV0dXJuIGtleXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcblx0aWYgKCFvcHRzKSB7IG9wdHMgPSB7fTsgfVxuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHsgb3B0cyA9IHsgY21wOiBvcHRzIH07IH1cblx0dmFyIHNwYWNlID0gb3B0cy5zcGFjZSB8fCAnJztcblx0aWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHsgc3BhY2UgPSBBcnJheShzcGFjZSArIDEpLmpvaW4oJyAnKTsgfVxuXHR2YXIgY3ljbGVzID0gdHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicgPyBvcHRzLmN5Y2xlcyA6IGZhbHNlO1xuXHR2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuXHR2YXIgY21wID0gb3B0cy5jbXAgJiYgKGZ1bmN0aW9uIChmKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0dmFyIGFvYmogPSB7IGtleTogYSwgdmFsdWU6IG5vZGVbYV0gfTtcblx0XHRcdFx0dmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcblx0XHRcdFx0cmV0dXJuIGYoYW9iaiwgYm9iaik7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0ob3B0cy5jbXApKTtcblxuXHR2YXIgc2VlbiA9IFtdO1xuXHRyZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeShwYXJlbnQsIGtleSwgbm9kZSwgbGV2ZWwpIHtcblx0XHR2YXIgaW5kZW50ID0gc3BhY2UgPyAnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpIDogJyc7XG5cdFx0dmFyIGNvbG9uU2VwYXJhdG9yID0gc3BhY2UgPyAnOiAnIDogJzonO1xuXG5cdFx0aWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRub2RlID0gbm9kZS50b0pTT04oKTtcblx0XHR9XG5cblx0XHRub2RlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgbm9kZSk7XG5cblx0XHRpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGpzb24uc3RyaW5naWZ5KG5vZGUpO1xuXHRcdH1cblx0XHRpZiAoaXNBcnJheShub2RlKSkge1xuXHRcdFx0dmFyIG91dCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsICsgMSkgfHwganNvbi5zdHJpbmdpZnkobnVsbCk7XG5cdFx0XHRcdG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcblx0XHR9XG5cblx0XHRpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuXHRcdFx0aWYgKGN5Y2xlcykgeyByZXR1cm4ganNvbi5zdHJpbmdpZnkoJ19fY3ljbGVfXycpOyB9XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG5cdFx0fSBlbHNlIHsgc2Vlbi5wdXNoKG5vZGUpOyB9XG5cblx0XHR2YXIga2V5cyA9IG9iamVjdEtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhciB2YWx1ZSA9IHN0cmluZ2lmeShub2RlLCBrZXksIG5vZGVba2V5XSwgbGV2ZWwgKyAxKTtcblxuXHRcdFx0aWYgKCF2YWx1ZSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIga2V5VmFsdWUgPSBqc29uLnN0cmluZ2lmeShrZXkpXG5cdFx0XHRcdFx0KyBjb2xvblNlcGFyYXRvclxuXHRcdFx0XHRcdCsgdmFsdWU7XG5cblx0XHRcdG91dC5wdXNoKGluZGVudCArIHNwYWNlICsga2V5VmFsdWUpO1xuXHRcdH1cblx0XHRzZWVuLnNwbGljZShzZWVuLmluZGV4T2Yobm9kZSksIDEpO1xuXHRcdHJldHVybiAneycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ30nO1xuXG5cdH0oeyAnJzogb2JqIH0sICcnLCBvYmosIDApKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGF0OyAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG52YXIgY2g7IC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxudmFyIGVzY2FwZWUgPSB7XG5cdCdcIic6ICdcIicsXG5cdCdcXFxcJzogJ1xcXFwnLFxuXHQnLyc6ICcvJyxcblx0YjogJ1xcYicsXG5cdGY6ICdcXGYnLFxuXHRuOiAnXFxuJyxcblx0cjogJ1xccicsXG5cdHQ6ICdcXHQnXG59O1xudmFyIHRleHQ7XG5cbi8vIENhbGwgZXJyb3Igd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcuXG5mdW5jdGlvbiBlcnJvcihtKSB7XG5cdHRocm93IHtcblx0XHRuYW1lOiAnU3ludGF4RXJyb3InLFxuXHRcdG1lc3NhZ2U6IG0sXG5cdFx0YXQ6IGF0LFxuXHRcdHRleHQ6IHRleHRcblx0fTtcbn1cblxuZnVuY3Rpb24gbmV4dChjKSB7XG5cdC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuXHRpZiAoYyAmJiBjICE9PSBjaCkge1xuXHRcdGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBpbnN0ZWFkIG9mICdcIiArIGNoICsgXCInXCIpO1xuXHR9XG5cblx0Ly8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLCByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuXHRjaCA9IHRleHQuY2hhckF0KGF0KTtcblx0YXQgKz0gMTtcblx0cmV0dXJuIGNoO1xufVxuXG5mdW5jdGlvbiBudW1iZXIoKSB7XG5cdC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuXHR2YXIgbnVtO1xuXHR2YXIgc3RyID0gJyc7XG5cblx0aWYgKGNoID09PSAnLScpIHtcblx0XHRzdHIgPSAnLSc7XG5cdFx0bmV4dCgnLScpO1xuXHR9XG5cdHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG5cdFx0c3RyICs9IGNoO1xuXHRcdG5leHQoKTtcblx0fVxuXHRpZiAoY2ggPT09ICcuJykge1xuXHRcdHN0ciArPSAnLic7XG5cdFx0d2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG5cdFx0XHRzdHIgKz0gY2g7XG5cdFx0fVxuXHR9XG5cdGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcblx0XHRzdHIgKz0gY2g7XG5cdFx0bmV4dCgpO1xuXHRcdGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcblx0XHRcdHN0ciArPSBjaDtcblx0XHRcdG5leHQoKTtcblx0XHR9XG5cdFx0d2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcblx0XHRcdHN0ciArPSBjaDtcblx0XHRcdG5leHQoKTtcblx0XHR9XG5cdH1cblx0bnVtID0gTnVtYmVyKHN0cik7XG5cdGlmICghaXNGaW5pdGUobnVtKSkge1xuXHRcdGVycm9yKCdCYWQgbnVtYmVyJyk7XG5cdH1cblx0cmV0dXJuIG51bTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nKCkge1xuXHQvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cblx0dmFyIGhleDtcblx0dmFyIGk7XG5cdHZhciBzdHIgPSAnJztcblx0dmFyIHVmZmZmO1xuXG5cdC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cblx0aWYgKGNoID09PSAnXCInKSB7XG5cdFx0d2hpbGUgKG5leHQoKSkge1xuXHRcdFx0aWYgKGNoID09PSAnXCInKSB7XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdGlmIChjaCA9PT0gJ3UnKSB7XG5cdFx0XHRcdFx0dWZmZmYgPSAwO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcblx0XHRcdFx0XHRcdGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuXHRcdFx0XHRcdFx0aWYgKCFpc0Zpbml0ZShoZXgpKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dWZmZmYgPSAodWZmZmYgKiAxNikgKyBoZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0c3RyICs9IGVzY2FwZWVbY2hdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHIgKz0gY2g7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGVycm9yKCdCYWQgc3RyaW5nJyk7XG59XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cbmZ1bmN0aW9uIHdoaXRlKCkge1xuXHR3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG5cdFx0bmV4dCgpO1xuXHR9XG59XG5cbi8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuZnVuY3Rpb24gd29yZCgpIHtcblx0c3dpdGNoIChjaCkge1xuXHRcdGNhc2UgJ3QnOlxuXHRcdFx0bmV4dCgndCcpO1xuXHRcdFx0bmV4dCgncicpO1xuXHRcdFx0bmV4dCgndScpO1xuXHRcdFx0bmV4dCgnZScpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnZic6XG5cdFx0XHRuZXh0KCdmJyk7XG5cdFx0XHRuZXh0KCdhJyk7XG5cdFx0XHRuZXh0KCdsJyk7XG5cdFx0XHRuZXh0KCdzJyk7XG5cdFx0XHRuZXh0KCdlJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0Y2FzZSAnbic6XG5cdFx0XHRuZXh0KCduJyk7XG5cdFx0XHRuZXh0KCd1Jyk7XG5cdFx0XHRuZXh0KCdsJyk7XG5cdFx0XHRuZXh0KCdsJyk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRkZWZhdWx0OlxuXHRcdFx0ZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIGNoICsgXCInXCIpO1xuXHR9XG59XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuZnVuY3Rpb24gYXJyYXkoKSB7XG5cdHZhciBhcnIgPSBbXTtcblxuXHRpZiAoY2ggPT09ICdbJykge1xuXHRcdG5leHQoJ1snKTtcblx0XHR3aGl0ZSgpO1xuXHRcdGlmIChjaCA9PT0gJ10nKSB7XG5cdFx0XHRuZXh0KCddJyk7XG5cdFx0XHRyZXR1cm4gYXJyOyAvLyBlbXB0eSBhcnJheVxuXHRcdH1cblx0XHR3aGlsZSAoY2gpIHtcblx0XHRcdGFyci5wdXNoKHZhbHVlKCkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG5cdFx0XHR3aGl0ZSgpO1xuXHRcdFx0aWYgKGNoID09PSAnXScpIHtcblx0XHRcdFx0bmV4dCgnXScpO1xuXHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0fVxuXHRcdFx0bmV4dCgnLCcpO1xuXHRcdFx0d2hpdGUoKTtcblx0XHR9XG5cdH1cblx0ZXJyb3IoJ0JhZCBhcnJheScpO1xufVxuXG4vLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG5mdW5jdGlvbiBvYmplY3QoKSB7XG5cdHZhciBrZXk7XG5cdHZhciBvYmogPSB7fTtcblxuXHRpZiAoY2ggPT09ICd7Jykge1xuXHRcdG5leHQoJ3snKTtcblx0XHR3aGl0ZSgpO1xuXHRcdGlmIChjaCA9PT0gJ30nKSB7XG5cdFx0XHRuZXh0KCd9Jyk7XG5cdFx0XHRyZXR1cm4gb2JqOyAvLyBlbXB0eSBvYmplY3Rcblx0XHR9XG5cdFx0d2hpbGUgKGNoKSB7XG5cdFx0XHRrZXkgPSBzdHJpbmcoKTtcblx0XHRcdHdoaXRlKCk7XG5cdFx0XHRuZXh0KCc6Jyk7XG5cdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuXHRcdFx0XHRlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcblx0XHRcdH1cblx0XHRcdG9ialtrZXldID0gdmFsdWUoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuXHRcdFx0d2hpdGUoKTtcblx0XHRcdGlmIChjaCA9PT0gJ30nKSB7XG5cdFx0XHRcdG5leHQoJ30nKTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdG5leHQoJywnKTtcblx0XHRcdHdoaXRlKCk7XG5cdFx0fVxuXHR9XG5cdGVycm9yKCdCYWQgb2JqZWN0Jyk7XG59XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLCBvciBhIHdvcmQuXG5mdW5jdGlvbiB2YWx1ZSgpIHtcblx0d2hpdGUoKTtcblx0c3dpdGNoIChjaCkge1xuXHRcdGNhc2UgJ3snOlxuXHRcdFx0cmV0dXJuIG9iamVjdCgpO1xuXHRcdGNhc2UgJ1snOlxuXHRcdFx0cmV0dXJuIGFycmF5KCk7XG5cdFx0Y2FzZSAnXCInOlxuXHRcdFx0cmV0dXJuIHN0cmluZygpO1xuXHRcdGNhc2UgJy0nOlxuXHRcdFx0cmV0dXJuIG51bWJlcigpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuXHR9XG59XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG5cdHZhciByZXN1bHQ7XG5cblx0dGV4dCA9IHNvdXJjZTtcblx0YXQgPSAwO1xuXHRjaCA9ICcgJztcblx0cmVzdWx0ID0gdmFsdWUoKTtcblx0d2hpdGUoKTtcblx0aWYgKGNoKSB7XG5cdFx0ZXJyb3IoJ1N5bnRheCBlcnJvcicpO1xuXHR9XG5cblx0Ly8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuXHQvLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuXHQvLyB0cmFuc2Zvcm1hdGlvbiwgc3RhcnRpbmcgd2l0aCBhIHRlbXBvcmFyeSByb290IG9iamVjdCB0aGF0IGhvbGRzIHRoZSByZXN1bHRcblx0Ly8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuXHQvLyByZXN1bHQuXG5cblx0cmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcblx0XHR2YXIgaztcblx0XHR2YXIgdjtcblx0XHR2YXIgdmFsID0gaG9sZGVyW2tleV07XG5cdFx0aWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yIChrIGluIHZhbHVlKSB7XG5cdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsLCBrKSkge1xuXHRcdFx0XHRcdHYgPSB3YWxrKHZhbCwgayk7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHZhbFtrXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFsW2tdID0gdjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsKTtcblx0fSh7ICcnOiByZXN1bHQgfSwgJycpKSA6IHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGFibGUgPSAvW1xcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcbnZhciBnYXA7XG52YXIgaW5kZW50O1xudmFyIG1ldGEgPSB7IC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG5cdCdcXGInOiAnXFxcXGInLFxuXHQnXFx0JzogJ1xcXFx0Jyxcblx0J1xcbic6ICdcXFxcbicsXG5cdCdcXGYnOiAnXFxcXGYnLFxuXHQnXFxyJzogJ1xcXFxyJyxcblx0J1wiJzogJ1xcXFxcIicsXG5cdCdcXFxcJzogJ1xcXFxcXFxcJ1xufTtcbnZhciByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXHQvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG5cdC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG5cdC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZSBzZXF1ZW5jZXMuXG5cblx0ZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG5cdHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcblx0XHR2YXIgYyA9IG1ldGFbYV07XG5cdFx0cmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGNcblx0XHRcdDogJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG5cdH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcblx0Ly8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuXHR2YXIgaTsgLy8gVGhlIGxvb3AgY291bnRlci5cblx0dmFyIGs7IC8vIFRoZSBtZW1iZXIga2V5LlxuXHR2YXIgdjsgLy8gVGhlIG1lbWJlciB2YWx1ZS5cblx0dmFyIGxlbmd0aDtcblx0dmFyIG1pbmQgPSBnYXA7XG5cdHZhciBwYXJ0aWFsO1xuXHR2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuXHQvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG5cdH1cblxuXHQvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cdGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuXHR9XG5cblx0Ly8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXHRzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuXHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRyZXR1cm4gcXVvdGUodmFsdWUpO1xuXG5cdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRcdC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuXHRcdFx0cmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cblx0XHRjYXNlICdib29sZWFuJzpcblx0XHRjYXNlICdudWxsJzpcblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcblx0XHRcdC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG5cdFx0XHQvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXHRcdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cblx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gJ251bGwnO1xuXHRcdFx0fVxuXHRcdFx0Z2FwICs9IGluZGVudDtcblx0XHRcdHBhcnRpYWwgPSBbXTtcblxuXHRcdFx0Ly8gQXJyYXkuaXNBcnJheVxuXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdFx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0cGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG5cdFx0XHRcdHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXBcblx0XHRcdFx0XHQ/ICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nXG5cdFx0XHRcdFx0OiAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcblx0XHRcdFx0Z2FwID0gbWluZDtcblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzdHJpbmdpZmllZC5cblx0XHRcdGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0bGVuZ3RoID0gcmVwLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0ayA9IHJlcFtpXTtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHR2ID0gc3RyKGssIHZhbHVlKTtcblx0XHRcdFx0XHRcdGlmICh2KSB7XG5cdFx0XHRcdFx0XHRcdHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cdFx0XHRcdGZvciAoayBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG5cdFx0XHRcdFx0XHR2ID0gc3RyKGssIHZhbHVlKTtcblx0XHRcdFx0XHRcdGlmICh2KSB7XG5cdFx0XHRcdFx0XHRcdHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG5cdFx0XHR2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwXG5cdFx0XHRcdD8gJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfSdcblx0XHRcdFx0OiAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9Jztcblx0XHRcdGdhcCA9IG1pbmQ7XG5cdFx0XHRyZXR1cm4gdjtcblx0XHRkZWZhdWx0OlxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblx0dmFyIGk7XG5cdGdhcCA9ICcnO1xuXHRpbmRlbnQgPSAnJztcblxuXHQvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0IG1hbnkgc3BhY2VzLlxuXHRpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG5cdFx0XHRpbmRlbnQgKz0gJyAnO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG5cdFx0Ly8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXHRcdGluZGVudCA9IHNwYWNlO1xuXHR9XG5cblx0Ly8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LiBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXHRyZXAgPSByZXBsYWNlcjtcblx0aWYgKFxuXHRcdHJlcGxhY2VyXG5cdFx0JiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG5cdFx0JiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpXG5cdCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcblx0fVxuXG5cdC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cdHJldHVybiBzdHIoJycsIHsgJyc6IHZhbHVlIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLyoqIEB0eXBlIFZhbGlkYXRvclJlc3VsdCAqL1xudmFyIFZhbGlkYXRvclJlc3VsdCA9IGhlbHBlcnMuVmFsaWRhdG9yUmVzdWx0O1xuLyoqIEB0eXBlIFNjaGVtYUVycm9yICovXG52YXIgU2NoZW1hRXJyb3IgPSBoZWxwZXJzLlNjaGVtYUVycm9yO1xuXG52YXIgYXR0cmlidXRlID0ge307XG5cbmF0dHJpYnV0ZS5pZ25vcmVQcm9wZXJ0aWVzID0ge1xuICAvLyBpbmZvcm1hdGl2ZSBwcm9wZXJ0aWVzXG4gICdpZCc6IHRydWUsXG4gICdkZWZhdWx0JzogdHJ1ZSxcbiAgJ2Rlc2NyaXB0aW9uJzogdHJ1ZSxcbiAgJ3RpdGxlJzogdHJ1ZSxcbiAgLy8gYXJndW1lbnRzIHRvIG90aGVyIHByb3BlcnRpZXNcbiAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiB0cnVlLFxuICAnZXhjbHVzaXZlTWF4aW11bSc6IHRydWUsXG4gICdhZGRpdGlvbmFsSXRlbXMnOiB0cnVlLFxuICAvLyBzcGVjaWFsLWhhbmRsZWQgcHJvcGVydGllc1xuICAnJHNjaGVtYSc6IHRydWUsXG4gICckcmVmJzogdHJ1ZSxcbiAgJ2V4dGVuZHMnOiB0cnVlXG59O1xuXG4vKipcbiAqIEBuYW1lIHZhbGlkYXRvcnNcbiAqL1xudmFyIHZhbGlkYXRvcnMgPSBhdHRyaWJ1dGUudmFsaWRhdG9ycyA9IHt9O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBpZiBvZiBhIGNlcnRhaW4gdHlwZVxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7VmFsaWRhdG9yUmVzdWx0fG51bGx9XG4gKi9cbnZhbGlkYXRvcnMudHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIC8vIElnbm9yZSB1bmRlZmluZWQgaW5zdGFuY2VzXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHR5cGVzID0gQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkgPyBzY2hlbWEudHlwZSA6IFtzY2hlbWEudHlwZV07XG4gIGlmICghdHlwZXMuc29tZSh0aGlzLnRlc3RUeXBlLmJpbmQodGhpcywgaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSkpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYuaWQgJiYgKCc8JyArIHYuaWQgKyAnPicpIHx8ICh2KycnKTtcbiAgICB9KTtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ3R5cGUnLFxuICAgICAgYXJndW1lbnQ6IGxpc3QsXG4gICAgICBtZXNzYWdlOiBcImlzIG5vdCBvZiBhIHR5cGUocykgXCIgKyBsaXN0LFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiB0ZXN0U2NoZW1hKGluc3RhbmNlLCBvcHRpb25zLCBjdHgsIGNhbGxiYWNrLCBzY2hlbWEpe1xuICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoISByZXMudmFsaWQgJiYgY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIGNhbGxiYWNrKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlcy52YWxpZDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgbWF0Y2hlcyBzb21lIG9mIHRoZSBnaXZlbiBzY2hlbWFzXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtWYWxpZGF0b3JSZXN1bHR8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5hbnlPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQW55T2YgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICAvLyBJZ25vcmUgdW5kZWZpbmVkIGluc3RhbmNlc1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBpbm5lciA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpe1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcImFueU9mIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gIH1cbiAgaWYgKCFzY2hlbWEuYW55T2Yuc29tZShcbiAgICB0ZXN0U2NoZW1hLmJpbmQoXG4gICAgICB0aGlzLCBpbnN0YW5jZSwgb3B0aW9ucywgY3R4LCBmdW5jdGlvbihyZXMpe2lubmVyLmltcG9ydEVycm9ycyhyZXMpO31cbiAgICAgICkpKSB7XG4gICAgdmFyIGxpc3QgPSBzY2hlbWEuYW55T2YubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICByZXR1cm4gKHYuaWQgJiYgKCc8JyArIHYuaWQgKyAnPicpKSB8fCAodi50aXRsZSAmJiBKU09OLnN0cmluZ2lmeSh2LnRpdGxlKSkgfHwgKHZbJyRyZWYnXSAmJiAoJzwnICsgdlsnJHJlZiddICsgJz4nKSkgfHwgJ1tzdWJzY2hlbWEgJytpKyddJztcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5uZXN0ZWRFcnJvcnMpIHtcbiAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMoaW5uZXIpO1xuICAgIH1cbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2FueU9mJyxcbiAgICAgIGFyZ3VtZW50OiBsaXN0LFxuICAgICAgbWVzc2FnZTogXCJpcyBub3QgYW55IG9mIFwiICsgbGlzdC5qb2luKCcsJyksXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIG1hdGNoZXMgZXZlcnkgZ2l2ZW4gc2NoZW1hXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5hbGxPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsT2YgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICAvLyBJZ25vcmUgdW5kZWZpbmVkIGluc3RhbmNlc1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKXtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJhbGxPZiBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2NoZW1hLmFsbE9mLmZvckVhY2goZnVuY3Rpb24odiwgaSl7XG4gICAgdmFyIHZhbGlkID0gc2VsZi52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgdiwgb3B0aW9ucywgY3R4KTtcbiAgICBpZighdmFsaWQudmFsaWQpe1xuICAgICAgdmFyIG1zZyA9ICh2LmlkICYmICgnPCcgKyB2LmlkICsgJz4nKSkgfHwgKHYudGl0bGUgJiYgSlNPTi5zdHJpbmdpZnkodi50aXRsZSkpIHx8ICh2WyckcmVmJ10gJiYgKCc8JyArIHZbJyRyZWYnXSArICc+JykpIHx8ICdbc3Vic2NoZW1hICcraSsnXSc7XG4gICAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgICBuYW1lOiAnYWxsT2YnLFxuICAgICAgICBhcmd1bWVudDogeyBpZDogbXNnLCBsZW5ndGg6IHZhbGlkLmVycm9ycy5sZW5ndGgsIHZhbGlkOiB2YWxpZCB9LFxuICAgICAgICBtZXNzYWdlOiAnZG9lcyBub3QgbWF0Y2ggYWxsT2Ygc2NoZW1hICcgKyBtc2cgKyAnIHdpdGggJyArIHZhbGlkLmVycm9ycy5sZW5ndGggKyAnIGVycm9yW3NdOicsXG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnModmFsaWQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBtYXRjaGVzIGV4YWN0bHkgb25lIG9mIHRoZSBnaXZlbiBzY2hlbWFzXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5vbmVPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICAvLyBJZ25vcmUgdW5kZWZpbmVkIGluc3RhbmNlc1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKXtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJvbmVPZiBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBpbm5lciA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIGNvdW50ID0gc2NoZW1hLm9uZU9mLmZpbHRlcihcbiAgICB0ZXN0U2NoZW1hLmJpbmQoXG4gICAgICB0aGlzLCBpbnN0YW5jZSwgb3B0aW9ucywgY3R4LCBmdW5jdGlvbihyZXMpIHtpbm5lci5pbXBvcnRFcnJvcnMocmVzKTt9XG4gICAgICApICkubGVuZ3RoO1xuICB2YXIgbGlzdCA9IHNjaGVtYS5vbmVPZi5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICByZXR1cm4gKHYuaWQgJiYgKCc8JyArIHYuaWQgKyAnPicpKSB8fCAodi50aXRsZSAmJiBKU09OLnN0cmluZ2lmeSh2LnRpdGxlKSkgfHwgKHZbJyRyZWYnXSAmJiAoJzwnICsgdlsnJHJlZiddICsgJz4nKSkgfHwgJ1tzdWJzY2hlbWEgJytpKyddJztcbiAgfSk7XG4gIGlmIChjb3VudCE9PTEpIHtcbiAgICBpZiAob3B0aW9ucy5uZXN0ZWRFcnJvcnMpIHtcbiAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMoaW5uZXIpO1xuICAgIH1cbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ29uZU9mJyxcbiAgICAgIGFyZ3VtZW50OiBsaXN0LFxuICAgICAgbWVzc2FnZTogXCJpcyBub3QgZXhhY3RseSBvbmUgZnJvbSBcIiArIGxpc3Quam9pbignLCcpLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMucHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmKGluc3RhbmNlID09PSB1bmRlZmluZWQgfHwgIShpbnN0YW5jZSBpbnN0YW5jZW9mIE9iamVjdCkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyB8fCB7fTtcbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmVWYWxpZGF0ZVByb3BlcnR5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHksIHByb3BlcnRpZXNbcHJvcGVydHldLCBvcHRpb25zLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBwcm9wID0gKGluc3RhbmNlIHx8IHVuZGVmaW5lZCkgJiYgaW5zdGFuY2VbcHJvcGVydHldO1xuICAgIHZhciByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKHByb3AsIHByb3BlcnRpZXNbcHJvcGVydHldLCBvcHRpb25zLCBjdHgubWFrZUNoaWxkKHByb3BlcnRpZXNbcHJvcGVydHldLCBwcm9wZXJ0eSkpO1xuICAgIGlmKHJlcy5pbnN0YW5jZSAhPT0gcmVzdWx0Lmluc3RhbmNlW3Byb3BlcnR5XSkgcmVzdWx0Lmluc3RhbmNlW3Byb3BlcnR5XSA9IHJlcy5pbnN0YW5jZTtcbiAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGVzdCBhIHNwZWNpZmljIHByb3BlcnR5IHdpdGhpbiBpbiBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBhZGRpdGlvbmFsUHJvcGVydGllcyBzY2hlbWEgYXR0cmlidXRlXG4gKiBUaGlzIGlnbm9yZXMgcHJvcGVydGllcyB3aXRoIGRlZmluaXRpb25zIGluIHRoZSBwcm9wZXJ0aWVzIHNjaGVtYSBhdHRyaWJ1dGUsIGJ1dCBubyBvdGhlciBhdHRyaWJ1dGVzLlxuICogSWYgdG9vIG1hbnkgbW9yZSB0eXBlcyBvZiBwcm9wZXJ0eS1leGlzdGFuY2UgdGVzdHMgcG9wIHVwIHRoZXkgbWF5IG5lZWQgdGhlaXIgb3duIGNsYXNzIG9mIHRlc3RzIChsaWtlIGB0eXBlYCBoYXMpXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdGVzdEFkZGl0aW9uYWxQcm9wZXJ0eSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4LCBwcm9wZXJ0eSwgcmVzdWx0KSB7XG4gIGlmIChzY2hlbWEucHJvcGVydGllcyAmJiBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAgICAgYXJndW1lbnQ6IHByb3BlcnR5LFxuICAgICAgbWVzc2FnZTogXCJhZGRpdGlvbmFsUHJvcGVydHkgXCIgKyBKU09OLnN0cmluZ2lmeShwcm9wZXJ0eSkgKyBcIiBleGlzdHMgaW4gaW5zdGFuY2Ugd2hlbiBub3QgYWxsb3dlZFwiLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmVWYWxpZGF0ZVByb3BlcnR5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHksIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBvcHRpb25zLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlW3Byb3BlcnR5XSwgYWRkaXRpb25hbFByb3BlcnRpZXMsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoYWRkaXRpb25hbFByb3BlcnRpZXMsIHByb3BlcnR5KSk7XG4gICAgaWYocmVzLmluc3RhbmNlICE9PSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldKSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldID0gcmVzLmluc3RhbmNlO1xuICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBwYXR0ZXJuUHJvcGVydGllc1xuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7U3RyaW5nfG51bGx8VmFsaWRhdG9yUmVzdWx0fVxuICovXG52YWxpZGF0b3JzLnBhdHRlcm5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYoIXRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgcGF0dGVyblByb3BlcnRpZXMgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMgfHwge307XG5cbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gaW5zdGFuY2UpIHtcbiAgICB2YXIgdGVzdCA9IHRydWU7XG4gICAgZm9yICh2YXIgcGF0dGVybiBpbiBwYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgdmFyIGV4cHIgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgaWYgKCFleHByLnRlc3QocHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHksIHBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dLCBvcHRpb25zLCBjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZVtwcm9wZXJ0eV0sIHBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dLCBvcHRpb25zLCBjdHgubWFrZUNoaWxkKHBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dLCBwcm9wZXJ0eSkpO1xuICAgICAgaWYocmVzLmluc3RhbmNlICE9PSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldKSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldID0gcmVzLmluc3RhbmNlO1xuICAgICAgcmVzdWx0LmltcG9ydEVycm9ycyhyZXMpO1xuICAgIH1cbiAgICBpZiAodGVzdCkge1xuICAgICAgdGVzdEFkZGl0aW9uYWxQcm9wZXJ0eS5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgcHJvcGVydHksIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMuYWRkaXRpb25hbFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZighdGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpKSByZXR1cm47XG4gIC8vIGlmIHBhdHRlcm5Qcm9wZXJ0aWVzIGlzIGRlZmluZWQgdGhlbiB3ZSdsbCB0ZXN0IHdoZW4gdGhhdCBvbmUgaXMgY2FsbGVkIGluc3RlYWRcbiAgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGZvciAodmFyIHByb3BlcnR5IGluIGluc3RhbmNlKSB7XG4gICAgdGVzdEFkZGl0aW9uYWxQcm9wZXJ0eS5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgcHJvcGVydHksIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIHZhbHVlIGlzIGF0IGxlYXN0IG9mIGEgY2VydGFpbiBsZW5ndGgsIHdoZW4gdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5taW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVNaW5Qcm9wZXJ0aWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCFpbnN0YW5jZSB8fCB0eXBlb2YgaW5zdGFuY2UgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZSk7XG4gIGlmICghKGtleXMubGVuZ3RoID49IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWluUHJvcGVydGllcycsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLm1pblByb3BlcnRpZXMsXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1lZXQgbWluaW11bSBwcm9wZXJ0eSBsZW5ndGggb2YgXCIgKyBzY2hlbWEubWluUHJvcGVydGllcyxcbiAgICB9KVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhdCBtb3N0IG9mIGEgY2VydGFpbiBsZW5ndGgsIHdoZW4gdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5tYXhQcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVNYXhQcm9wZXJ0aWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCFpbnN0YW5jZSB8fCB0eXBlb2YgaW5zdGFuY2UgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZSk7XG4gIGlmICghKGtleXMubGVuZ3RoIDw9IHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWF4UHJvcGVydGllcycsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLm1heFByb3BlcnRpZXMsXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1lZXQgbWF4aW11bSBwcm9wZXJ0eSBsZW5ndGggb2YgXCIgKyBzY2hlbWEubWF4UHJvcGVydGllcyxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgaXRlbXMgd2hlbiBpbnN0YW5jZSBpcyBhbiBhcnJheVxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7U3RyaW5nfG51bGx8VmFsaWRhdG9yUmVzdWx0fVxuICovXG52YWxpZGF0b3JzLml0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkIHx8ICFzY2hlbWEuaXRlbXMpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGluc3RhbmNlLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgIHZhciBpdGVtcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSA/IChzY2hlbWEuaXRlbXNbaV0gfHwgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcykgOiBzY2hlbWEuaXRlbXM7XG4gICAgaWYgKGl0ZW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgICBuYW1lOiAnaXRlbXMnLFxuICAgICAgICBtZXNzYWdlOiBcImFkZGl0aW9uYWxJdGVtcyBub3QgcGVybWl0dGVkXCIsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHNlbGYudmFsaWRhdGVTY2hlbWEodmFsdWUsIGl0ZW1zLCBvcHRpb25zLCBjdHgubWFrZUNoaWxkKGl0ZW1zLCBpKSk7XG4gICAgaWYocmVzLmluc3RhbmNlICE9PSByZXN1bHQuaW5zdGFuY2VbaV0pIHJlc3VsdC5pbnN0YW5jZVtpXSA9IHJlcy5pbnN0YW5jZTtcbiAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgbWluaW11bSBhbmQgZXhjbHVzaXZlTWluaW11bSB3aGVuIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWluaW11bSA9IGZ1bmN0aW9uIHZhbGlkYXRlTWluaW11bSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtICYmIHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtID09PSB0cnVlKSB7XG4gICAgdmFsaWQgPSBpbnN0YW5jZSA+IHNjaGVtYS5taW5pbXVtO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gaW5zdGFuY2UgPj0gc2NoZW1hLm1pbmltdW07XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWluaW11bScsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLm1pbmltdW0sXG4gICAgICBtZXNzYWdlOiBcIm11c3QgaGF2ZSBhIG1pbmltdW0gdmFsdWUgb2YgXCIgKyBzY2hlbWEubWluaW11bSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgbWF4aW11bSBhbmQgZXhjbHVzaXZlTWF4aW11bSB3aGVuIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWF4aW11bSA9IGZ1bmN0aW9uIHZhbGlkYXRlTWF4aW11bSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHZhbGlkO1xuICBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gJiYgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUpIHtcbiAgICB2YWxpZCA9IGluc3RhbmNlIDwgc2NoZW1hLm1heGltdW07XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSBpbnN0YW5jZSA8PSBzY2hlbWEubWF4aW11bTtcbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdtYXhpbXVtJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWF4aW11bSxcbiAgICAgIG1lc3NhZ2U6IFwibXVzdCBoYXZlIGEgbWF4aW11bSB2YWx1ZSBvZiBcIiArIHNjaGVtYS5tYXhpbXVtLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gdmFsaWRhdGlvbiBmb3IgbXVsdGlwbGVPZiBhbmQgZGl2aXNpYmxlQnksIHdoaWNoIGFyZSBlc3NlbnRpYWxseSB0aGUgc2FtZS5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIHZhbGlkYXRpb25UeXBlXG4gKiBAcGFyYW0gZXJyb3JNZXNzYWdlXG4gKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gKi9cbnZhciB2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkgPSBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgdmFsaWRhdGlvblR5cGUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGluc3RhbmNlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHZhbGlkYXRpb25Bcmd1bWVudCA9IHNjaGVtYVt2YWxpZGF0aW9uVHlwZV07XG4gIGlmICh2YWxpZGF0aW9uQXJndW1lbnQgPT0gMCkge1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcih2YWxpZGF0aW9uVHlwZSArIFwiIGNhbm5vdCBiZSB6ZXJvXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcblxuICB2YXIgaW5zdGFuY2VEZWNpbWFscyA9IGhlbHBlcnMuZ2V0RGVjaW1hbFBsYWNlcyhpbnN0YW5jZSk7XG4gIHZhciBkaXZpc29yRGVjaW1hbHMgPSBoZWxwZXJzLmdldERlY2ltYWxQbGFjZXModmFsaWRhdGlvbkFyZ3VtZW50KTtcblxuICB2YXIgbWF4RGVjaW1hbHMgPSBNYXRoLm1heChpbnN0YW5jZURlY2ltYWxzICwgZGl2aXNvckRlY2ltYWxzKTtcbiAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgbWF4RGVjaW1hbHMpO1xuXG4gIGlmIChNYXRoLnJvdW5kKGluc3RhbmNlICogbXVsdGlwbGllcikgJSBNYXRoLnJvdW5kKHZhbGlkYXRpb25Bcmd1bWVudCAqIG11bHRpcGxpZXIpICE9PSAwKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6IHZhbGlkYXRpb25UeXBlLFxuICAgICAgYXJndW1lbnQ6ICB2YWxpZGF0aW9uQXJndW1lbnQsXG4gICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UgKyBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uQXJndW1lbnQpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgZGl2aXNpYmxlQnkgd2hlbiB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLm11bHRpcGxlT2YgPSBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlT2YgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuIHJldHVybiB2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4LCBcIm11bHRpcGxlT2ZcIiwgXCJpcyBub3QgYSBtdWx0aXBsZSBvZiAoZGl2aXNpYmxlIGJ5KSBcIik7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBtdWx0aXBsZU9mIHdoZW4gdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5kaXZpc2libGVCeSA9IGZ1bmN0aW9uIHZhbGlkYXRlRGl2aXNpYmxlQnkgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICByZXR1cm4gdmFsaWRhdGVNdWx0aXBsZU9mT3JEaXZpc2JsZUJ5KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgXCJkaXZpc2libGVCeVwiLCBcImlzIG5vdCBkaXZpc2libGUgYnkgKG11bHRpcGxlIG9mKSBcIik7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBwcmVzZW50LlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5yZXF1aXJlZCA9IGZ1bmN0aW9uIHZhbGlkYXRlUmVxdWlyZWQgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCAmJiBzY2hlbWEucmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAvLyBBIGJvb2xlYW4gZm9ybSBpcyBpbXBsZW1lbnRlZCBmb3IgcmV2ZXJzZS1jb21wYXRhYmlsaXR5IHdpdGggc2NoZW1hcyB3cml0dGVuIGFnYWluc3Qgb2xkZXIgZHJhZnRzXG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdyZXF1aXJlZCcsXG4gICAgICBtZXNzYWdlOiBcImlzIHJlcXVpcmVkXCJcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpbnN0YW5jZSAmJiB0eXBlb2YgaW5zdGFuY2U9PT0nb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkpIHtcbiAgICBzY2hlbWEucmVxdWlyZWQuZm9yRWFjaChmdW5jdGlvbihuKXtcbiAgICAgIGlmKGluc3RhbmNlW25dPT09dW5kZWZpbmVkKXtcbiAgICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgICBuYW1lOiAncmVxdWlyZWQnLFxuICAgICAgICAgIGFyZ3VtZW50OiBuLFxuICAgICAgICAgIG1lc3NhZ2U6IFwicmVxdWlyZXMgcHJvcGVydHkgXCIgKyBKU09OLnN0cmluZ2lmeShuKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIHZhbHVlIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgd2hlbiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLnBhdHRlcm4gPSBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm4gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAodHlwZW9mIGluc3RhbmNlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghaW5zdGFuY2UubWF0Y2goc2NoZW1hLnBhdHRlcm4pKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdwYXR0ZXJuJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEucGF0dGVybixcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgbWF0Y2ggcGF0dGVybiBcIiArIEpTT04uc3RyaW5naWZ5KHNjaGVtYS5wYXR0ZXJuKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgb2YgYSBjZXJ0YWluIGRlZmluZWQgZm9ybWF0IG9yIGEgY3VzdG9tXG4gKiBmb3JtYXQuXG4gKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBmb3Igc3RyaW5nIHR5cGVzOlxuICogICAtIGRhdGUtdGltZVxuICogICAtIGRhdGVcbiAqICAgLSB0aW1lXG4gKiAgIC0gaXAtYWRkcmVzc1xuICogICAtIGlwdjZcbiAqICAgLSB1cmlcbiAqICAgLSBjb2xvclxuICogICAtIGhvc3QtbmFtZVxuICogICAtIGFscGhhXG4gKiAgIC0gYWxwaGEtbnVtZXJpY1xuICogICAtIHV0Yy1taWxsaXNlY1xuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gW29wdGlvbnNdXG4gKiBAcGFyYW0gW2N0eF1cbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLmZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0IChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFyZXN1bHQuZGlzYWJsZUZvcm1hdCAmJiAhaGVscGVycy5pc0Zvcm1hdChpbnN0YW5jZSwgc2NoZW1hLmZvcm1hdCwgdGhpcykpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2Zvcm1hdCcsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLmZvcm1hdCxcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgY29uZm9ybSB0byB0aGUgXCIgKyBKU09OLnN0cmluZ2lmeShzY2hlbWEuZm9ybWF0KSArIFwiIGZvcm1hdFwiLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhdCBsZWFzdCBvZiBhIGNlcnRhaW4gbGVuZ3RoLCB3aGVuIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWluTGVuZ3RoID0gZnVuY3Rpb24gdmFsaWRhdGVNaW5MZW5ndGggKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoISh0eXBlb2YgaW5zdGFuY2UgPT09ICdzdHJpbmcnKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghKGluc3RhbmNlLmxlbmd0aCA+PSBzY2hlbWEubWluTGVuZ3RoKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWluTGVuZ3RoJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWluTGVuZ3RoLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1pbmltdW0gbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1pbkxlbmd0aCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYXQgbW9zdCBvZiBhIGNlcnRhaW4gbGVuZ3RoLCB3aGVuIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWF4TGVuZ3RoID0gZnVuY3Rpb24gdmFsaWRhdGVNYXhMZW5ndGggKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoISh0eXBlb2YgaW5zdGFuY2UgPT09ICdzdHJpbmcnKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghKGluc3RhbmNlLmxlbmd0aCA8PSBzY2hlbWEubWF4TGVuZ3RoKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWF4TGVuZ3RoJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWF4TGVuZ3RoLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1heGltdW0gbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1heExlbmd0aCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciBpbnN0YW5jZSBjb250YWlucyBhdCBsZWFzdCBhIG1pbmltdW0gbnVtYmVyIG9mIGl0ZW1zLCB3aGVuIHRoZSBpbnN0YW5jZSBpcyBhbiBBcnJheS5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWluSXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU1pbkl0ZW1zIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghKGluc3RhbmNlLmxlbmd0aCA+PSBzY2hlbWEubWluSXRlbXMpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdtaW5JdGVtcycsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1pbmltdW0gbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1pbkl0ZW1zLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIGluc3RhbmNlIGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBhIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zLCB3aGVuIHRoZSBpbnN0YW5jZSBpcyBhbiBBcnJheS5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWF4SXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU1heEl0ZW1zIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghKGluc3RhbmNlLmxlbmd0aCA8PSBzY2hlbWEubWF4SXRlbXMpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdtYXhJdGVtcycsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLm1heEl0ZW1zLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1heGltdW0gbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1heEl0ZW1zLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGV2ZXJ5IGl0ZW0gaW4gYW4gaW5zdGFuY2UgYXJyYXkgaXMgdW5pcXVlLCB3aGVuIGluc3RhbmNlIGlzIGFuIGFycmF5XG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMudW5pcXVlSXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZVVuaXF1ZUl0ZW1zIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlKSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gdGVzdEFycmF5cyAodiwgaSwgYSkge1xuICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGEubGVuZ3RoOyBqKyspIGlmIChoZWxwZXJzLmRlZXBDb21wYXJlU3RyaWN0KHYsIGFbal0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaW5zdGFuY2UuZXZlcnkodGVzdEFycmF5cykpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ3VuaXF1ZUl0ZW1zJyxcbiAgICAgIG1lc3NhZ2U6IFwiY29udGFpbnMgZHVwbGljYXRlIGl0ZW1cIixcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEZWVwIGNvbXBhcmVzIGFycmF5cyBmb3IgZHVwbGljYXRlc1xuICogQHBhcmFtIHZcbiAqIEBwYXJhbSBpXG4gKiBAcGFyYW0gYVxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHRlc3RBcnJheXMgKHYsIGksIGEpIHtcbiAgdmFyIGosIGxlbiA9IGEubGVuZ3RoO1xuICBmb3IgKGogPSBpICsgMSwgbGVuOyBqIDwgbGVuOyBqKyspIHtcbiAgICBpZiAoaGVscGVycy5kZWVwQ29tcGFyZVN0cmljdCh2LCBhW2pdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcywgd2hlbiB0aGUgaW5zdGFuY2UgaXMgYW4gQXJyYXkuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLnVuaXF1ZUl0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoIWluc3RhbmNlLmV2ZXJ5KHRlc3RBcnJheXMpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICd1bmlxdWVJdGVtcycsXG4gICAgICBtZXNzYWdlOiBcImNvbnRhaW5zIGR1cGxpY2F0ZSBpdGVtXCIsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgZm9yIHRoZSBwcmVzZW5jZSBvZiBkZXBlbmRlbmN5IHByb3BlcnRpZXMsIGlmIHRoZSBpbnN0YW5jZSBpcyBhbiBvYmplY3QuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5kZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZURlcGVuZGVuY2llcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghaW5zdGFuY2UgfHwgdHlwZW9mIGluc3RhbmNlICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gc2NoZW1hLmRlcGVuZGVuY2llcykge1xuICAgIGlmIChpbnN0YW5jZVtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBkZXAgPSBzY2hlbWEuZGVwZW5kZW5jaWVzW3Byb3BlcnR5XTtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gY3R4Lm1ha2VDaGlsZChkZXAsIHByb3BlcnR5KTtcbiAgICBpZiAodHlwZW9mIGRlcCA9PSAnc3RyaW5nJykge1xuICAgICAgZGVwID0gW2RlcF07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlcCkpIHtcbiAgICAgIGRlcC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgICAgIC8vIEZJWE1FIHRoZXJlJ3MgdHdvIGRpZmZlcmVudCBcImRlcGVuZGVuY2llc1wiIGVycm9ycyBoZXJlIHdpdGggc2xpZ2h0bHkgZGlmZmVyZW50IG91dHB1dHNcbiAgICAgICAgICAgIC8vIENhbiB3ZSBtYWtlIHRoZXNlIHRoZSBzYW1lPyBPciBzaG91bGQgd2UgY3JlYXRlIGRpZmZlcmVudCBlcnJvciB0eXBlcz9cbiAgICAgICAgICAgIG5hbWU6ICdkZXBlbmRlbmNpZXMnLFxuICAgICAgICAgICAgYXJndW1lbnQ6IGNoaWxkQ29udGV4dC5wcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBcInByb3BlcnR5IFwiICsgcHJvcCArIFwiIG5vdCBmb3VuZCwgcmVxdWlyZWQgYnkgXCIgKyBjaGlsZENvbnRleHQucHJvcGVydHlQYXRoLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIGRlcCwgb3B0aW9ucywgY2hpbGRDb250ZXh0KTtcbiAgICAgIGlmKHJlc3VsdC5pbnN0YW5jZSAhPT0gcmVzLmluc3RhbmNlKSByZXN1bHQuaW5zdGFuY2UgPSByZXMuaW5zdGFuY2U7XG4gICAgICBpZiAocmVzICYmIHJlcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgICAgbmFtZTogJ2RlcGVuZGVuY2llcycsXG4gICAgICAgICAgYXJndW1lbnQ6IGNoaWxkQ29udGV4dC5wcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IGRlcGVuZGVuY3kgcmVxdWlyZWQgYnkgXCIgKyBjaGlsZENvbnRleHQucHJvcGVydHlQYXRoLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LmltcG9ydEVycm9ycyhyZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgb25lIG9mIHRoZSBlbnVtZXJhdGVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1ZhbGlkYXRvclJlc3VsdHxudWxsfVxuICovXG52YWxpZGF0b3JzWydlbnVtJ10gPSBmdW5jdGlvbiB2YWxpZGF0ZUVudW0gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hWydlbnVtJ10pKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKFwiZW51bSBleHBlY3RzIGFuIGFycmF5XCIsIHNjaGVtYSk7XG4gIH1cbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoIXNjaGVtYVsnZW51bSddLnNvbWUoaGVscGVycy5kZWVwQ29tcGFyZVN0cmljdC5iaW5kKG51bGwsIGluc3RhbmNlKSkpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2VudW0nLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYVsnZW51bSddLFxuICAgICAgbWVzc2FnZTogXCJpcyBub3Qgb25lIG9mIGVudW0gdmFsdWVzOiBcIiArIHNjaGVtYVsnZW51bSddLmpvaW4oJywnKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgZXhhY3RseSBtYXRjaGVzIGEgZ2l2ZW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1ZhbGlkYXRvclJlc3VsdHxudWxsfVxuICovXG52YWxpZGF0b3JzWydjb25zdCddID0gZnVuY3Rpb24gdmFsaWRhdGVFbnVtIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFoZWxwZXJzLmRlZXBDb21wYXJlU3RyaWN0KHNjaGVtYVsnY29uc3QnXSwgaW5zdGFuY2UpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdjb25zdCcsXG4gICAgICBhcmd1bWVudDogc2NoZW1hWydjb25zdCddLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBleGFjdGx5IG1hdGNoIGV4cGVjdGVkIGNvbnN0YW50OiBcIiArIHNjaGVtYVsnY29uc3QnXSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgaWYgb2YgYSBwcm9oaWJpdGVkIHR5cGUuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5ub3QgPSB2YWxpZGF0b3JzLmRpc2FsbG93ID0gZnVuY3Rpb24gdmFsaWRhdGVOb3QgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmKGluc3RhbmNlPT09dW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIG5vdFR5cGVzID0gc2NoZW1hLm5vdCB8fCBzY2hlbWEuZGlzYWxsb3c7XG4gIGlmKCFub3RUeXBlcykgcmV0dXJuIG51bGw7XG4gIGlmKCFBcnJheS5pc0FycmF5KG5vdFR5cGVzKSkgbm90VHlwZXM9W25vdFR5cGVzXTtcbiAgbm90VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmIChzZWxmLnRlc3RUeXBlKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgdHlwZSkpIHtcbiAgICAgIHZhciBzY2hlbWFJZCA9IHR5cGUgJiYgdHlwZS5pZCAmJiAoJzwnICsgdHlwZS5pZCArICc+JykgfHwgdHlwZTtcbiAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgIG5hbWU6ICdub3QnLFxuICAgICAgICBhcmd1bWVudDogc2NoZW1hSWQsXG4gICAgICAgIG1lc3NhZ2U6IFwiaXMgb2YgcHJvaGliaXRlZCB0eXBlIFwiICsgc2NoZW1hSWQsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdHRyaWJ1dGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1cmkgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yIChtZXNzYWdlLCBpbnN0YW5jZSwgc2NoZW1hLCBwcm9wZXJ0eVBhdGgsIG5hbWUsIGFyZ3VtZW50KSB7XG4gIGlmIChwcm9wZXJ0eVBhdGgpIHtcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHlQYXRoO1xuICB9XG4gIGlmIChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBpZiAoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYS5pZCkge1xuICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWEuaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbiAgfVxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIH1cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB0aGlzLnN0YWNrID0gdGhpcy50b1N0cmluZygpO1xufTtcblxuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5wcm9wZXJ0eSArICcgJyArIHRoaXMubWVzc2FnZTtcbn07XG5cbnZhciBWYWxpZGF0b3JSZXN1bHQgPSBleHBvcnRzLlZhbGlkYXRvclJlc3VsdCA9IGZ1bmN0aW9uIFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5wcm9wZXJ0eVBhdGggPSBjdHgucHJvcGVydHlQYXRoO1xuICB0aGlzLmVycm9ycyA9IFtdO1xuICB0aGlzLnRocm93RXJyb3IgPSBvcHRpb25zICYmIG9wdGlvbnMudGhyb3dFcnJvcjtcbiAgdGhpcy5kaXNhYmxlRm9ybWF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmRpc2FibGVGb3JtYXQgPT09IHRydWU7XG59O1xuXG5WYWxpZGF0b3JSZXN1bHQucHJvdG90eXBlLmFkZEVycm9yID0gZnVuY3Rpb24gYWRkRXJyb3IoZGV0YWlsKSB7XG4gIHZhciBlcnI7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09ICdzdHJpbmcnKSB7XG4gICAgZXJyID0gbmV3IFZhbGlkYXRpb25FcnJvcihkZXRhaWwsIHRoaXMuaW5zdGFuY2UsIHRoaXMuc2NoZW1hLCB0aGlzLnByb3BlcnR5UGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFkZXRhaWwpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlcnJvciBkZXRhaWwnKTtcbiAgICBpZiAoIWRldGFpbC5tZXNzYWdlKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZXJyb3IgbWVzc2FnZScpO1xuICAgIGlmICghZGV0YWlsLm5hbWUpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWxpZGF0b3IgdHlwZScpO1xuICAgIGVyciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoZGV0YWlsLm1lc3NhZ2UsIHRoaXMuaW5zdGFuY2UsIHRoaXMuc2NoZW1hLCB0aGlzLnByb3BlcnR5UGF0aCwgZGV0YWlsLm5hbWUsIGRldGFpbC5hcmd1bWVudCk7XG4gIH1cblxuICBpZiAodGhpcy50aHJvd0Vycm9yKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHRoaXMuZXJyb3JzLnB1c2goZXJyKTtcbiAgcmV0dXJuIGVycjtcbn07XG5cblZhbGlkYXRvclJlc3VsdC5wcm90b3R5cGUuaW1wb3J0RXJyb3JzID0gZnVuY3Rpb24gaW1wb3J0RXJyb3JzKHJlcykge1xuICBpZiAodHlwZW9mIHJlcyA9PSAnc3RyaW5nJyB8fCAocmVzICYmIHJlcy52YWxpZGF0b3JUeXBlKSkge1xuICAgIHRoaXMuYWRkRXJyb3IocmVzKTtcbiAgfSBlbHNlIGlmIChyZXMgJiYgcmVzLmVycm9ycykge1xuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuZXJyb3JzLCByZXMuZXJyb3JzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5naXplciAodixpKXtcbiAgcmV0dXJuIGkrJzogJyt2LnRvU3RyaW5nKCkrJ1xcbic7XG59XG5WYWxpZGF0b3JSZXN1bHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmVzKSB7XG4gIHJldHVybiB0aGlzLmVycm9ycy5tYXAoc3RyaW5naXplcikuam9pbignJyk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsaWRhdG9yUmVzdWx0LnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5lcnJvcnMubGVuZ3RoO1xufSB9KTtcblxuLyoqXG4gKiBEZXNjcmliZXMgYSBwcm9ibGVtIHdpdGggYSBTY2hlbWEgd2hpY2ggcHJldmVudHMgdmFsaWRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICogQG5hbWUgU2NoZW1hRXJyb3JcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2NoZW1hRXJyb3IgPSBleHBvcnRzLlNjaGVtYUVycm9yID0gZnVuY3Rpb24gU2NoZW1hRXJyb3IgKG1zZywgc2NoZW1hKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIEVycm9yLmNhbGwodGhpcywgbXNnKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU2NoZW1hRXJyb3IpO1xufTtcblNjaGVtYUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLFxuICB7IGNvbnN0cnVjdG9yOiB7dmFsdWU6IFNjaGVtYUVycm9yLCBlbnVtZXJhYmxlOiBmYWxzZX1cbiAgLCBuYW1lOiB7dmFsdWU6ICdTY2hlbWFFcnJvcicsIGVudW1lcmFibGU6IGZhbHNlfVxuICB9KTtcblxudmFyIFNjaGVtYUNvbnRleHQgPSBleHBvcnRzLlNjaGVtYUNvbnRleHQgPSBmdW5jdGlvbiBTY2hlbWFDb250ZXh0IChzY2hlbWEsIG9wdGlvbnMsIHByb3BlcnR5UGF0aCwgYmFzZSwgc2NoZW1hcykge1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5wcm9wZXJ0eVBhdGggPSBwcm9wZXJ0eVBhdGg7XG4gIHRoaXMuYmFzZSA9IGJhc2U7XG4gIHRoaXMuc2NoZW1hcyA9IHNjaGVtYXM7XG59O1xuXG5TY2hlbWFDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAodGFyZ2V0KSB7XG4gIHJldHVybiB1cmkucmVzb2x2ZSh0aGlzLmJhc2UsIHRhcmdldCk7XG59O1xuXG5TY2hlbWFDb250ZXh0LnByb3RvdHlwZS5tYWtlQ2hpbGQgPSBmdW5jdGlvbiBtYWtlQ2hpbGQoc2NoZW1hLCBwcm9wZXJ0eU5hbWUpe1xuICB2YXIgcHJvcGVydHlQYXRoID0gKHByb3BlcnR5TmFtZT09PXVuZGVmaW5lZCkgPyB0aGlzLnByb3BlcnR5UGF0aCA6IHRoaXMucHJvcGVydHlQYXRoK21ha2VTdWZmaXgocHJvcGVydHlOYW1lKTtcbiAgdmFyIGJhc2UgPSB1cmkucmVzb2x2ZSh0aGlzLmJhc2UsIHNjaGVtYS5pZHx8JycpO1xuICB2YXIgY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQoc2NoZW1hLCB0aGlzLm9wdGlvbnMsIHByb3BlcnR5UGF0aCwgYmFzZSwgT2JqZWN0LmNyZWF0ZSh0aGlzLnNjaGVtYXMpKTtcbiAgaWYoc2NoZW1hLmlkICYmICFjdHguc2NoZW1hc1tiYXNlXSl7XG4gICAgY3R4LnNjaGVtYXNbYmFzZV0gPSBzY2hlbWE7XG4gIH1cbiAgcmV0dXJuIGN0eDtcbn1cblxudmFyIEZPUk1BVF9SRUdFWFBTID0gZXhwb3J0cy5GT1JNQVRfUkVHRVhQUyA9IHtcbiAgJ2RhdGUtdGltZSc6IC9eXFxkezR9LSg/OjBbMC05XXsxfXwxWzAtMl17MX0pLSgzWzAxXXwwWzEtOV18WzEyXVswLTldKVt0VCBdKDJbMC00XXxbMDFdWzAtOV0pOihbMC01XVswLTldKTooNjB8WzAtNV1bMC05XSkoXFwuXFxkKyk/KFt6Wl18WystXShbMC01XVswLTldKTooNjB8WzAtNV1bMC05XSkpJC8sXG4gICdkYXRlJzogL15cXGR7NH0tKD86MFswLTldezF9fDFbMC0yXXsxfSktKDNbMDFdfDBbMS05XXxbMTJdWzAtOV0pJC8sXG4gICd0aW1lJzogL14oMlswLTRdfFswMV1bMC05XSk6KFswLTVdWzAtOV0pOig2MHxbMC01XVswLTldKSQvLFxuXG4gICdlbWFpbCc6IC9eKD86W1xcd1xcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcLVxcL1xcPVxcP1xcXlxcYFxce1xcfFxcfVxcfl0rXFwuKSpbXFx3XFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwtXFwvXFw9XFw/XFxeXFxgXFx7XFx8XFx9XFx+XStAKD86KD86KD86W2EtekEtWjAtOV0oPzpbYS16QS1aMC05XFwtXSg/IVxcLikpezAsNjF9W2EtekEtWjAtOV0/XFwuKStbYS16QS1aMC05XSg/OlthLXpBLVowLTlcXC1dKD8hJCkpezAsNjF9W2EtekEtWjAtOV0/KXwoPzpcXFsoPzooPzpbMDFdP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKVxcLil7M30oPzpbMDFdP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKVxcXSkpJC8sXG4gICdpcC1hZGRyZXNzJzogL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykkLyxcbiAgJ2lwdjYnOiAvXlxccyooKChbMC05QS1GYS1mXXsxLDR9Oil7N30oWzAtOUEtRmEtZl17MSw0fXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7Nn0oOlswLTlBLUZhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs1fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs0fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05QS1GYS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7M30oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXsyfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezF9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNn0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoJS4rKT9cXHMqJC8sXG4gICd1cmknOiAvXlthLXpBLVpdW2EtekEtWjAtOSstLl0qOlteXFxzXSokLyxcblxuICAnY29sb3InOiAvXigjPyhbMC05QS1GYS1mXXszfSl7MSwyfVxcYnxhcXVhfGJsYWNrfGJsdWV8ZnVjaHNpYXxncmF5fGdyZWVufGxpbWV8bWFyb29ufG5hdnl8b2xpdmV8b3JhbmdlfHB1cnBsZXxyZWR8c2lsdmVyfHRlYWx8d2hpdGV8eWVsbG93fChyZ2JcXChcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqLFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccyosXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKlxcKSl8KHJnYlxcKFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKixcXHMqKFxcZD9cXGQlfDEwMCUpK1xccyosXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqXFwpKSkkLyxcblxuICAvLyBob3N0bmFtZSByZWdleCBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDIwMjI1LzU2MjhcbiAgJ2hvc3RuYW1lJzogL14oPz0uezEsMjU1fSQpWzAtOUEtWmEtel0oPzooPzpbMC05QS1aYS16XXwtKXswLDYxfVswLTlBLVphLXpdKT8oPzpcXC5bMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPykqXFwuPyQvLFxuICAnaG9zdC1uYW1lJzogL14oPz0uezEsMjU1fSQpWzAtOUEtWmEtel0oPzooPzpbMC05QS1aYS16XXwtKXswLDYxfVswLTlBLVphLXpdKT8oPzpcXC5bMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPykqXFwuPyQvLFxuXG4gICdhbHBoYSc6IC9eW2EtekEtWl0rJC8sXG4gICdhbHBoYW51bWVyaWMnOiAvXlthLXpBLVowLTldKyQvLFxuICAndXRjLW1pbGxpc2VjJzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSAmJiBwYXJzZUZsb2F0KGlucHV0KSA9PT0gcGFyc2VJbnQoaW5wdXQsIDEwKSAmJiAhaXNOYU4oaW5wdXQpO1xuICB9LFxuICAncmVnZXgnOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgbmV3IFJlZ0V4cChpbnB1dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gICdzdHlsZSc6IC9cXHMqKC4rPyk6XFxzKihbXjtdKyk7Py9nLFxuICAncGhvbmUnOiAvXlxcKyg/OlswLTldID8pezYsMTR9WzAtOV0kL1xufTtcblxuRk9STUFUX1JFR0VYUFMucmVnZXhwID0gRk9STUFUX1JFR0VYUFMucmVnZXg7XG5GT1JNQVRfUkVHRVhQUy5wYXR0ZXJuID0gRk9STUFUX1JFR0VYUFMucmVnZXg7XG5GT1JNQVRfUkVHRVhQUy5pcHY0ID0gRk9STUFUX1JFR0VYUFNbJ2lwLWFkZHJlc3MnXTtcblxuZXhwb3J0cy5pc0Zvcm1hdCA9IGZ1bmN0aW9uIGlzRm9ybWF0IChpbnB1dCwgZm9ybWF0LCB2YWxpZGF0b3IpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgRk9STUFUX1JFR0VYUFNbZm9ybWF0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEZPUk1BVF9SRUdFWFBTW2Zvcm1hdF0gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBGT1JNQVRfUkVHRVhQU1tmb3JtYXRdLnRlc3QoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEZPUk1BVF9SRUdFWFBTW2Zvcm1hdF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBGT1JNQVRfUkVHRVhQU1tmb3JtYXRdKGlucHV0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsaWRhdG9yICYmIHZhbGlkYXRvci5jdXN0b21Gb3JtYXRzICYmXG4gICAgICB0eXBlb2YgdmFsaWRhdG9yLmN1c3RvbUZvcm1hdHNbZm9ybWF0XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWxpZGF0b3IuY3VzdG9tRm9ybWF0c1tmb3JtYXRdKGlucHV0KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBtYWtlU3VmZml4ID0gZXhwb3J0cy5tYWtlU3VmZml4ID0gZnVuY3Rpb24gbWFrZVN1ZmZpeCAoa2V5KSB7XG4gIGtleSA9IGtleS50b1N0cmluZygpO1xuICAvLyBUaGlzIGZ1bmN0aW9uIGNvdWxkIGJlIGNhcGFibGUgb2Ygb3V0cHV0dGluZyB2YWxpZCBhIEVDTUFTY3JpcHQgc3RyaW5nLCBidXQgdGhlXG4gIC8vIHJlc3VsdGluZyBjb2RlIGZvciB0ZXN0aW5nIHdoaWNoIGZvcm0gdG8gdXNlIHdvdWxkIGJlIHRlbnMgb2YgdGhvdXNhbmRzIG9mIGNoYXJhY3RlcnMgbG9uZ1xuICAvLyBUaGF0IG1lYW5zIHRoaXMgd2lsbCB1c2UgdGhlIG5hbWUgZm9ybSBmb3Igc29tZSBpbGxlZ2FsIGZvcm1zXG4gIGlmICgha2V5Lm1hdGNoKC9bLlxcc1xcW1xcXV0vKSAmJiAha2V5Lm1hdGNoKC9eW1xcZF0vKSkge1xuICAgIHJldHVybiAnLicgKyBrZXk7XG4gIH1cbiAgaWYgKGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICByZXR1cm4gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIHJldHVybiAnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xufTtcblxuZXhwb3J0cy5kZWVwQ29tcGFyZVN0cmljdCA9IGZ1bmN0aW9uIGRlZXBDb21wYXJlU3RyaWN0IChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYS5ldmVyeShmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIGRlZXBDb21wYXJlU3RyaWN0KGFbaV0sIGJbaV0pO1xuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH1cbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gZGVlcENvbXBhcmVTdHJpY3QoYVt2XSwgYlt2XSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGEgPT09IGI7XG59O1xuXG5mdW5jdGlvbiBkZWVwTWVyZ2VyICh0YXJnZXQsIGRzdCwgZSwgaSkge1xuICBpZiAodHlwZW9mIGUgPT09ICdvYmplY3QnKSB7XG4gICAgZHN0W2ldID0gZGVlcE1lcmdlKHRhcmdldFtpXSwgZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAodGFyZ2V0LmluZGV4T2YoZSkgPT09IC0xKSB7XG4gICAgICBkc3QucHVzaChlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5aXN0IChzcmMsIGRzdCwga2V5KSB7XG4gIGRzdFtrZXldID0gc3JjW2tleV07XG59XG5cbmZ1bmN0aW9uIGNvcHlpc3RXaXRoRGVlcE1lcmdlICh0YXJnZXQsIHNyYywgZHN0LCBrZXkpIHtcbiAgaWYgKHR5cGVvZiBzcmNba2V5XSAhPT0gJ29iamVjdCcgfHwgIXNyY1trZXldKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBkc3Rba2V5XSA9IGRlZXBNZXJnZSh0YXJnZXRba2V5XSwgc3JjW2tleV0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZXBNZXJnZSAodGFyZ2V0LCBzcmMpIHtcbiAgdmFyIGFycmF5ID0gQXJyYXkuaXNBcnJheShzcmMpO1xuICB2YXIgZHN0ID0gYXJyYXkgJiYgW10gfHwge307XG5cbiAgaWYgKGFycmF5KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IFtdO1xuICAgIGRzdCA9IGRzdC5jb25jYXQodGFyZ2V0KTtcbiAgICBzcmMuZm9yRWFjaChkZWVwTWVyZ2VyLmJpbmQobnVsbCwgdGFyZ2V0LCBkc3QpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goY29weWlzdC5iaW5kKG51bGwsIHRhcmdldCwgZHN0KSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChjb3B5aXN0V2l0aERlZXBNZXJnZS5iaW5kKG51bGwsIHRhcmdldCwgc3JjLCBkc3QpKTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWVwTWVyZ2UgPSBkZWVwTWVyZ2U7XG5cbi8qKlxuICogVmFsaWRhdGVzIGluc3RhbmNlIGFnYWluc3QgdGhlIHByb3ZpZGVkIHNjaGVtYVxuICogSW1wbGVtZW50cyBVUkkrSlNPTiBQb2ludGVyIGVuY29kaW5nLCBlLmcuIFwiJTdlXCI9XCJ+MFwiPT5cIn5cIiwgXCJ+MVwiPVwiJTJmXCI9PlwiL1wiXG4gKiBAcGFyYW0gb1xuICogQHBhcmFtIHMgVGhlIHBhdGggdG8gd2FsayBvIGFsb25nXG4gKiBAcmV0dXJuIGFueVxuICovXG5leHBvcnRzLm9iamVjdEdldFBhdGggPSBmdW5jdGlvbiBvYmplY3RHZXRQYXRoKG8sIHMpIHtcbiAgdmFyIHBhcnRzID0gcy5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICB2YXIgaztcbiAgd2hpbGUgKHR5cGVvZiAoaz1wYXJ0cy5zaGlmdCgpKSA9PSAnc3RyaW5nJykge1xuICAgIHZhciBuID0gZGVjb2RlVVJJQ29tcG9uZW50KGsucmVwbGFjZSgvfjAvLCd+JykucmVwbGFjZSgvfjEvZywnLycpKTtcbiAgICBpZiAoIShuIGluIG8pKSByZXR1cm47XG4gICAgbyA9IG9bbl07XG4gIH1cbiAgcmV0dXJuIG87XG59O1xuXG5mdW5jdGlvbiBwYXRoRW5jb2RlciAodikge1xuICByZXR1cm4gJy8nK2VuY29kZVVSSUNvbXBvbmVudCh2KS5yZXBsYWNlKC9+L2csJyU3RScpO1xufVxuLyoqXG4gKiBBY2NlcHQgYW4gQXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHJldHVybiBhIEpTT04gUG9pbnRlciBVUkkgZnJhZ21lbnRcbiAqIEBwYXJhbSBBcnJheSBhXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuZW5jb2RlUGF0aCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50ZXIoYSl7XG5cdC8vIH4gbXVzdCBiZSBlbmNvZGVkIGV4cGxpY2l0bHkgYmVjYXVzZSBoYWNrc1xuXHQvLyB0aGUgc2xhc2ggaXMgZW5jb2RlZCBieSBlbmNvZGVVUklDb21wb25lbnRcblx0cmV0dXJuIGEubWFwKHBhdGhFbmNvZGVyKS5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBhIG51bWJlciB1c2VzXG4gKiBXZSBuZWVkIHRoaXMgdG8gZ2V0IGNvcnJlY3QgcmVzdWx0cyBvdXQgb2YgbXVsdGlwbGVPZiBhbmQgZGl2aXNpYmxlQnlcbiAqIHdoZW4gZWl0aGVyIGZpZ3VyZSBpcyBoYXMgZGVjaW1hbCBwbGFjZXMsIGR1ZSB0byBJRUVFLTc1NCBmbG9hdCBpc3N1ZXMuXG4gKiBAcGFyYW0gbnVtYmVyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldERlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbiBnZXREZWNpbWFsUGxhY2VzKG51bWJlcikge1xuXG4gIHZhciBkZWNpbWFsUGxhY2VzID0gMDtcbiAgaWYgKGlzTmFOKG51bWJlcikpIHJldHVybiBkZWNpbWFsUGxhY2VzO1xuXG4gIGlmICh0eXBlb2YgbnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgIG51bWJlciA9IE51bWJlcihudW1iZXIpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gbnVtYmVyLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChwYXJ0c1sxXVswXSAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gZGVjaW1hbFBsYWNlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjaW1hbFBsYWNlcyA9IE51bWJlcihwYXJ0c1sxXS5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlY2ltYWxQYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcuJyk7XG4gIGlmIChkZWNpbWFsUGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgZGVjaW1hbFBsYWNlcyArPSBkZWNpbWFsUGFydHNbMV0ubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGRlY2ltYWxQbGFjZXM7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0b3IgPSBtb2R1bGUuZXhwb3J0cy5WYWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0b3JSZXN1bHQgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5WYWxpZGF0b3JSZXN1bHQ7XG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5WYWxpZGF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycycpLlNjaGVtYUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIHZhciB2ID0gbmV3IFZhbGlkYXRvcigpO1xuICByZXR1cm4gdi52YWxpZGF0ZShpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1cmlsaWIgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIGF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vYXR0cmlidXRlJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xudmFyIFZhbGlkYXRvclJlc3VsdCA9IGhlbHBlcnMuVmFsaWRhdG9yUmVzdWx0O1xudmFyIFNjaGVtYUVycm9yID0gaGVscGVycy5TY2hlbWFFcnJvcjtcbnZhciBTY2hlbWFDb250ZXh0ID0gaGVscGVycy5TY2hlbWFDb250ZXh0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVmFsaWRhdG9yIG9iamVjdFxuICogQG5hbWUgVmFsaWRhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvciAoKSB7XG4gIC8vIEFsbG93IGEgdmFsaWRhdG9yIGluc3RhbmNlIHRvIG92ZXJyaWRlIGdsb2JhbCBjdXN0b20gZm9ybWF0cyBvciB0byBoYXZlIHRoZWlyXG4gIC8vIG93biBjdXN0b20gZm9ybWF0cy5cbiAgdGhpcy5jdXN0b21Gb3JtYXRzID0gT2JqZWN0LmNyZWF0ZShWYWxpZGF0b3IucHJvdG90eXBlLmN1c3RvbUZvcm1hdHMpO1xuICB0aGlzLnNjaGVtYXMgPSB7fTtcbiAgdGhpcy51bnJlc29sdmVkUmVmcyA9IFtdO1xuXG4gIC8vIFVzZSBPYmplY3QuY3JlYXRlIHRvIG1ha2UgdGhpcyBleHRlbnNpYmxlIHdpdGhvdXQgVmFsaWRhdG9yIGluc3RhbmNlcyBzdGVwcGluZyBvbiBlYWNoIG90aGVyJ3MgdG9lcy5cbiAgdGhpcy50eXBlcyA9IE9iamVjdC5jcmVhdGUodHlwZXMpO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKGF0dHJpYnV0ZS52YWxpZGF0b3JzKTtcbn07XG5cbi8vIEFsbG93IGZvcm1hdHMgdG8gYmUgcmVnaXN0ZXJlZCBnbG9iYWxseS5cblZhbGlkYXRvci5wcm90b3R5cGUuY3VzdG9tRm9ybWF0cyA9IHt9O1xuXG4vLyBIaW50IGF0IHRoZSBwcmVzZW5jZSBvZiBhIHByb3BlcnR5XG5WYWxpZGF0b3IucHJvdG90eXBlLnNjaGVtYXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS50eXBlcyA9IG51bGw7XG5WYWxpZGF0b3IucHJvdG90eXBlLmF0dHJpYnV0ZXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS51bnJlc29sdmVkUmVmcyA9IG51bGw7XG5cbi8qKlxuICogQWRkcyBhIHNjaGVtYSB3aXRoIGEgY2VydGFpbiB1cm4gdG8gdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSB1cm5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5hZGRTY2hlbWEgPSBmdW5jdGlvbiBhZGRTY2hlbWEgKHNjaGVtYSwgdXJpKSB7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG91clVyaSA9IHVyaSB8fCBzY2hlbWEuaWQ7XG4gIHRoaXMuYWRkU3ViU2NoZW1hKG91clVyaSwgc2NoZW1hKTtcbiAgaWYgKG91clVyaSkge1xuICAgIHRoaXMuc2NoZW1hc1tvdXJVcmldID0gc2NoZW1hO1xuICB9XG4gIHJldHVybiB0aGlzLnNjaGVtYXNbb3VyVXJpXTtcbn07XG5cblZhbGlkYXRvci5wcm90b3R5cGUuYWRkU3ViU2NoZW1hID0gZnVuY3Rpb24gYWRkU3ViU2NoZW1hKGJhc2V1cmksIHNjaGVtYSkge1xuICBpZighc2NoZW1hIHx8IHR5cGVvZiBzY2hlbWEhPSdvYmplY3QnKSByZXR1cm47XG4gIC8vIE1hcmsgYWxsIHJlZmVyZW5jZWQgc2NoZW1hcyBzbyB3ZSBjYW4gdGVsbCBsYXRlciB3aGljaCBzY2hlbWFzIGFyZSByZWZlcnJlZCB0bywgYnV0IG5ldmVyIGRlZmluZWRcbiAgaWYoc2NoZW1hLiRyZWYpe1xuICAgIHZhciByZXNvbHZlZFVyaSA9IHVyaWxpYi5yZXNvbHZlKGJhc2V1cmksIHNjaGVtYS4kcmVmKTtcbiAgICAvLyBPbmx5IG1hcmsgdW5rbm93biBzY2hlbWFzIGFzIHVucmVzb2x2ZWRcbiAgICBpZiAodGhpcy5zY2hlbWFzW3Jlc29sdmVkVXJpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNjaGVtYXNbcmVzb2x2ZWRVcmldID0gbnVsbDtcbiAgICAgIHRoaXMudW5yZXNvbHZlZFJlZnMucHVzaChyZXNvbHZlZFVyaSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3VyVXJpID0gc2NoZW1hLmlkICYmIHVyaWxpYi5yZXNvbHZlKGJhc2V1cmksIHNjaGVtYS5pZCk7XG4gIHZhciBvdXJCYXNlID0gb3VyVXJpIHx8IGJhc2V1cmk7XG4gIGlmIChvdXJVcmkpIHtcbiAgICBpZih0aGlzLnNjaGVtYXNbb3VyVXJpXSl7XG4gICAgICBpZighaGVscGVycy5kZWVwQ29tcGFyZVN0cmljdCh0aGlzLnNjaGVtYXNbb3VyVXJpXSwgc2NoZW1hKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NoZW1hIDwnK3NjaGVtYSsnPiBhbHJlYWR5IGV4aXN0cyB3aXRoIGRpZmZlcmVudCBkZWZpbml0aW9uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zY2hlbWFzW291clVyaV07XG4gICAgfVxuICAgIHRoaXMuc2NoZW1hc1tvdXJVcmldID0gc2NoZW1hO1xuICAgIHZhciBkb2N1bWVudFVyaSA9IG91clVyaS5yZXBsYWNlKC9eKFteI10qKSMkLywgJyQxJyk7XG4gICAgdGhpcy5zY2hlbWFzW2RvY3VtZW50VXJpXSA9IHNjaGVtYTtcbiAgfVxuICB0aGlzLmFkZFN1YlNjaGVtYUFycmF5KG91ckJhc2UsICgoc2NoZW1hLml0ZW1zIGluc3RhbmNlb2YgQXJyYXkpP3NjaGVtYS5pdGVtczpbc2NoZW1hLml0ZW1zXSkpO1xuICB0aGlzLmFkZFN1YlNjaGVtYUFycmF5KG91ckJhc2UsICgoc2NoZW1hLmV4dGVuZHMgaW5zdGFuY2VvZiBBcnJheSk/c2NoZW1hLmV4dGVuZHM6W3NjaGVtYS5leHRlbmRzXSkpO1xuICB0aGlzLmFkZFN1YlNjaGVtYShvdXJCYXNlLCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zKTtcbiAgdGhpcy5hZGRTdWJTY2hlbWFPYmplY3Qob3VyQmFzZSwgc2NoZW1hLnByb3BlcnRpZXMpO1xuICB0aGlzLmFkZFN1YlNjaGVtYShvdXJCYXNlLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICB0aGlzLmFkZFN1YlNjaGVtYU9iamVjdChvdXJCYXNlLCBzY2hlbWEuZGVmaW5pdGlvbnMpO1xuICB0aGlzLmFkZFN1YlNjaGVtYU9iamVjdChvdXJCYXNlLCBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpO1xuICB0aGlzLmFkZFN1YlNjaGVtYU9iamVjdChvdXJCYXNlLCBzY2hlbWEuZGVwZW5kZW5jaWVzKTtcbiAgdGhpcy5hZGRTdWJTY2hlbWFBcnJheShvdXJCYXNlLCBzY2hlbWEuZGlzYWxsb3cpO1xuICB0aGlzLmFkZFN1YlNjaGVtYUFycmF5KG91ckJhc2UsIHNjaGVtYS5hbGxPZik7XG4gIHRoaXMuYWRkU3ViU2NoZW1hQXJyYXkob3VyQmFzZSwgc2NoZW1hLmFueU9mKTtcbiAgdGhpcy5hZGRTdWJTY2hlbWFBcnJheShvdXJCYXNlLCBzY2hlbWEub25lT2YpO1xuICB0aGlzLmFkZFN1YlNjaGVtYShvdXJCYXNlLCBzY2hlbWEubm90KTtcbiAgcmV0dXJuIHRoaXMuc2NoZW1hc1tvdXJVcmldO1xufTtcblxuVmFsaWRhdG9yLnByb3RvdHlwZS5hZGRTdWJTY2hlbWFBcnJheSA9IGZ1bmN0aW9uIGFkZFN1YlNjaGVtYUFycmF5KGJhc2V1cmksIHNjaGVtYXMpIHtcbiAgaWYoIShzY2hlbWFzIGluc3RhbmNlb2YgQXJyYXkpKSByZXR1cm47XG4gIGZvcih2YXIgaT0wOyBpPHNjaGVtYXMubGVuZ3RoOyBpKyspe1xuICAgIHRoaXMuYWRkU3ViU2NoZW1hKGJhc2V1cmksIHNjaGVtYXNbaV0pO1xuICB9XG59O1xuXG5WYWxpZGF0b3IucHJvdG90eXBlLmFkZFN1YlNjaGVtYU9iamVjdCA9IGZ1bmN0aW9uIGFkZFN1YlNjaGVtYUFycmF5KGJhc2V1cmksIHNjaGVtYXMpIHtcbiAgaWYoIXNjaGVtYXMgfHwgdHlwZW9mIHNjaGVtYXMhPSdvYmplY3QnKSByZXR1cm47XG4gIGZvcih2YXIgcCBpbiBzY2hlbWFzKXtcbiAgICB0aGlzLmFkZFN1YlNjaGVtYShiYXNldXJpLCBzY2hlbWFzW3BdKTtcbiAgfVxufTtcblxuXG5cbi8qKlxuICogU2V0cyBhbGwgdGhlIHNjaGVtYXMgb2YgdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzY2hlbWFzXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuc2V0U2NoZW1hcyA9IGZ1bmN0aW9uIHNldFNjaGVtYXMgKHNjaGVtYXMpIHtcbiAgdGhpcy5zY2hlbWFzID0gc2NoZW1hcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2NoZW1hIG9mIGEgY2VydGFpbiB1cm5cbiAqIEBwYXJhbSB1cm5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRTY2hlbWEgPSBmdW5jdGlvbiBnZXRTY2hlbWEgKHVybikge1xuICByZXR1cm4gdGhpcy5zY2hlbWFzW3Vybl07XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBwcm92aWRlZCBzY2hlbWFcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIFtvcHRpb25zXVxuICogQHBhcmFtIFtjdHhdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBvcHRpb25zLnByb3BlcnR5TmFtZSB8fCAnaW5zdGFuY2UnO1xuICAvLyBUaGlzIHdpbGwgd29yayBzbyBsb25nIGFzIHRoZSBmdW5jdGlvbiBhdCB1cmkucmVzb2x2ZSgpIHdpbGwgcmVzb2x2ZSBhIHJlbGF0aXZlIFVSSSB0byBhIHJlbGF0aXZlIFVSSVxuICB2YXIgYmFzZSA9IHVyaWxpYi5yZXNvbHZlKG9wdGlvbnMuYmFzZXx8Jy8nLCBzY2hlbWEuaWR8fCcnKTtcbiAgaWYoIWN0eCl7XG4gICAgY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQoc2NoZW1hLCBvcHRpb25zLCBwcm9wZXJ0eU5hbWUsIGJhc2UsIE9iamVjdC5jcmVhdGUodGhpcy5zY2hlbWFzKSk7XG4gICAgaWYgKCFjdHguc2NoZW1hc1tiYXNlXSkge1xuICAgICAgY3R4LnNjaGVtYXNbYmFzZV0gPSBzY2hlbWE7XG4gICAgfVxuICB9XG4gIGlmIChzY2hlbWEpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3VsdCB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoJ25vIHNjaGVtYSBzcGVjaWZpZWQnLCBzY2hlbWEpO1xufTtcblxuLyoqXG4qIEBwYXJhbSBPYmplY3Qgc2NoZW1hXG4qIEByZXR1cm4gbWl4ZWQgc2NoZW1hIHVyaSBvciBmYWxzZVxuKi9cbmZ1bmN0aW9uIHNob3VsZFJlc29sdmUoc2NoZW1hKSB7XG4gIHZhciByZWYgPSAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpID8gc2NoZW1hIDogc2NoZW1hLiRyZWY7XG4gIGlmICh0eXBlb2YgcmVmPT0nc3RyaW5nJykgcmV0dXJuIHJlZjtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhbiBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBzY2hlbWEgKHRoZSBhY3R1YWwgd29yayBob3JzZSlcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtWYWxpZGF0b3JSZXN1bHR9XG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVTY2hlbWEgPSBmdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIGlzIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIGlmIChzY2hlbWFbJ2V4dGVuZHMnXSkge1xuICAgIGlmIChzY2hlbWFbJ2V4dGVuZHMnXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YXIgc2NoZW1hb2JqID0ge3NjaGVtYTogc2NoZW1hLCBjdHg6IGN0eH07XG4gICAgICBzY2hlbWFbJ2V4dGVuZHMnXS5mb3JFYWNoKHRoaXMuc2NoZW1hVHJhdmVyc2VyLmJpbmQodGhpcywgc2NoZW1hb2JqKSk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWFvYmouc2NoZW1hO1xuICAgICAgc2NoZW1hb2JqLnNjaGVtYSA9IG51bGw7XG4gICAgICBzY2hlbWFvYmouY3R4ID0gbnVsbDtcbiAgICAgIHNjaGVtYW9iaiA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVtYSA9IGhlbHBlcnMuZGVlcE1lcmdlKHNjaGVtYSwgdGhpcy5zdXBlclJlc29sdmUoc2NoZW1hWydleHRlbmRzJ10sIGN0eCkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzd2l0Y2hTY2hlbWE7XG4gIGlmIChzd2l0Y2hTY2hlbWEgPSBzaG91bGRSZXNvbHZlKHNjaGVtYSkpIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmUoc2NoZW1hLCBzd2l0Y2hTY2hlbWEsIGN0eCk7XG4gICAgdmFyIHN1YmN0eCA9IG5ldyBTY2hlbWFDb250ZXh0KHJlc29sdmVkLnN1YnNjaGVtYSwgb3B0aW9ucywgY3R4LnByb3BlcnR5UGF0aCwgcmVzb2x2ZWQuc3dpdGNoU2NoZW1hLCBjdHguc2NoZW1hcyk7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIHJlc29sdmVkLnN1YnNjaGVtYSwgb3B0aW9ucywgc3ViY3R4KTtcbiAgfVxuXG4gIHZhciBza2lwQXR0cmlidXRlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQXR0cmlidXRlcyB8fCBbXTtcbiAgLy8gVmFsaWRhdGUgZWFjaCBzY2hlbWEgYXR0cmlidXRlIGFnYWluc3QgdGhlIGluc3RhbmNlXG4gIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZS5pZ25vcmVQcm9wZXJ0aWVzW2tleV0gJiYgc2tpcEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgdmFyIHZhbGlkYXRvckVyciA9IG51bGw7XG4gICAgICB2YXIgdmFsaWRhdG9yID0gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgIHZhbGlkYXRvckVyciA9IHZhbGlkYXRvci5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dVbmtub3duQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gVGhpcyByZXByZXNlbnRzIGFuIGVycm9yIHdpdGggdGhlIHNjaGVtYSBpdHNlbGYsIG5vdCBhbiBpbnZhbGlkIGluc3RhbmNlXG4gICAgICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZTogXCIgKyBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdG9yRXJyKSB7XG4gICAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnModmFsaWRhdG9yRXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV3cml0ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy5yZXdyaXRlLmNhbGwodGhpcywgaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgICByZXN1bHQuaW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qIEBwYXJhbSBPYmplY3Qgc2NoZW1hXG4qIEBwYXJhbSBTY2hlbWFDb250ZXh0IGN0eFxuKiBAcmV0dXJucyBPYmplY3Qgc2NoZW1hIG9yIHJlc29sdmVkIHNjaGVtYVxuKi9cblZhbGlkYXRvci5wcm90b3R5cGUuc2NoZW1hVHJhdmVyc2VyID0gZnVuY3Rpb24gc2NoZW1hVHJhdmVyc2VyIChzY2hlbWFvYmosIHMpIHtcbiAgc2NoZW1hb2JqLnNjaGVtYSA9IGhlbHBlcnMuZGVlcE1lcmdlKHNjaGVtYW9iai5zY2hlbWEsIHRoaXMuc3VwZXJSZXNvbHZlKHMsIHNjaGVtYW9iai5jdHgpKTtcbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qIEBwYXJhbSBPYmplY3Qgc2NoZW1hXG4qIEBwYXJhbSBTY2hlbWFDb250ZXh0IGN0eFxuKiBAcmV0dXJucyBPYmplY3Qgc2NoZW1hIG9yIHJlc29sdmVkIHNjaGVtYVxuKi9cblZhbGlkYXRvci5wcm90b3R5cGUuc3VwZXJSZXNvbHZlID0gZnVuY3Rpb24gc3VwZXJSZXNvbHZlIChzY2hlbWEsIGN0eCkge1xuICB2YXIgcmVmO1xuICBpZihyZWYgPSBzaG91bGRSZXNvbHZlKHNjaGVtYSkpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKHNjaGVtYSwgcmVmLCBjdHgpLnN1YnNjaGVtYTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vKipcbiogQHByaXZhdGVcbiogQHBhcmFtIE9iamVjdCBzY2hlbWFcbiogQHBhcmFtIE9iamVjdCBzd2l0Y2hTY2hlbWFcbiogQHBhcmFtIFNjaGVtYUNvbnRleHQgY3R4XG4qIEByZXR1cm4gT2JqZWN0IHJlc29sdmVkIHNjaGVtYXMge3N1YnNjaGVtYTpTdHJpbmcsIHN3aXRjaFNjaGVtYTogU3RyaW5nfVxuKiBAdGhyb3dzIFNjaGVtYUVycm9yXG4qL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoc2NoZW1hLCBzd2l0Y2hTY2hlbWEsIGN0eCkge1xuICBzd2l0Y2hTY2hlbWEgPSBjdHgucmVzb2x2ZShzd2l0Y2hTY2hlbWEpO1xuICAvLyBGaXJzdCBzZWUgaWYgdGhlIHNjaGVtYSBleGlzdHMgdW5kZXIgdGhlIHByb3ZpZGVkIFVSSVxuICBpZiAoY3R4LnNjaGVtYXNbc3dpdGNoU2NoZW1hXSkge1xuICAgIHJldHVybiB7c3Vic2NoZW1hOiBjdHguc2NoZW1hc1tzd2l0Y2hTY2hlbWFdLCBzd2l0Y2hTY2hlbWE6IHN3aXRjaFNjaGVtYX07XG4gIH1cbiAgLy8gRWxzZSB0cnkgd2Fsa2luZyB0aGUgcHJvcGVydHkgcG9pbnRlclxuICB2YXIgcGFyc2VkID0gdXJpbGliLnBhcnNlKHN3aXRjaFNjaGVtYSk7XG4gIHZhciBmcmFnbWVudCA9IHBhcnNlZCAmJiBwYXJzZWQuaGFzaDtcbiAgdmFyIGRvY3VtZW50ID0gZnJhZ21lbnQgJiYgZnJhZ21lbnQubGVuZ3RoICYmIHN3aXRjaFNjaGVtYS5zdWJzdHIoMCwgc3dpdGNoU2NoZW1hLmxlbmd0aCAtIGZyYWdtZW50Lmxlbmd0aCk7XG4gIGlmICghZG9jdW1lbnQgfHwgIWN0eC5zY2hlbWFzW2RvY3VtZW50XSkge1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcIm5vIHN1Y2ggc2NoZW1hIDxcIiArIHN3aXRjaFNjaGVtYSArIFwiPlwiLCBzY2hlbWEpO1xuICB9XG4gIHZhciBzdWJzY2hlbWEgPSBoZWxwZXJzLm9iamVjdEdldFBhdGgoY3R4LnNjaGVtYXNbZG9jdW1lbnRdLCBmcmFnbWVudC5zdWJzdHIoMSkpO1xuICBpZihzdWJzY2hlbWE9PT11bmRlZmluZWQpe1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcIm5vIHN1Y2ggc2NoZW1hIFwiICsgZnJhZ21lbnQgKyBcIiBsb2NhdGVkIGluIDxcIiArIGRvY3VtZW50ICsgXCI+XCIsIHNjaGVtYSk7XG4gIH1cbiAgcmV0dXJuIHtzdWJzY2hlbWE6IHN1YnNjaGVtYSwgc3dpdGNoU2NoZW1hOiBzd2l0Y2hTY2hlbWF9O1xufTtcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBpZiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS50ZXN0VHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4LCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgdGhpcy50eXBlc1t0eXBlXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZXNbdHlwZV0uY2FsbCh0aGlzLCBpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKHR5cGUgJiYgdHlwZW9mIHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgdHlwZSwgb3B0aW9ucywgY3R4KTtcbiAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgfHwgIShyZXMgJiYgcmVzLmVycm9ycy5sZW5ndGgpO1xuICB9XG4gIC8vIFVuZGVmaW5lZCBvciBwcm9wZXJ0aWVzIG5vdCBvbiB0aGUgbGlzdCBhcmUgYWNjZXB0YWJsZSwgc2FtZSBhcyBub3QgYmVpbmcgZGVmaW5lZFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB0eXBlcyA9IFZhbGlkYXRvci5wcm90b3R5cGUudHlwZXMgPSB7fTtcbnR5cGVzLnN0cmluZyA9IGZ1bmN0aW9uIHRlc3RTdHJpbmcgKGluc3RhbmNlKSB7XG4gIHJldHVybiB0eXBlb2YgaW5zdGFuY2UgPT0gJ3N0cmluZyc7XG59O1xudHlwZXMubnVtYmVyID0gZnVuY3Rpb24gdGVzdE51bWJlciAoaW5zdGFuY2UpIHtcbiAgLy8gaXNGaW5pdGUgcmV0dXJucyBmYWxzZSBmb3IgTmFOLCBJbmZpbml0eSwgYW5kIC1JbmZpbml0eVxuICByZXR1cm4gdHlwZW9mIGluc3RhbmNlID09ICdudW1iZXInICYmIGlzRmluaXRlKGluc3RhbmNlKTtcbn07XG50eXBlcy5pbnRlZ2VyID0gZnVuY3Rpb24gdGVzdEludGVnZXIgKGluc3RhbmNlKSB7XG4gIHJldHVybiAodHlwZW9mIGluc3RhbmNlID09ICdudW1iZXInKSAmJiBpbnN0YW5jZSAlIDEgPT09IDA7XG59O1xudHlwZXMuYm9vbGVhbiA9IGZ1bmN0aW9uIHRlc3RCb29sZWFuIChpbnN0YW5jZSkge1xuICByZXR1cm4gdHlwZW9mIGluc3RhbmNlID09ICdib29sZWFuJztcbn07XG50eXBlcy5hcnJheSA9IGZ1bmN0aW9uIHRlc3RBcnJheSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5zdGFuY2UpO1xufTtcbnR5cGVzWydudWxsJ10gPSBmdW5jdGlvbiB0ZXN0TnVsbCAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlID09PSBudWxsO1xufTtcbnR5cGVzLmRhdGUgPSBmdW5jdGlvbiB0ZXN0RGF0ZSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlIGluc3RhbmNlb2YgRGF0ZTtcbn07XG50eXBlcy5hbnkgPSBmdW5jdGlvbiB0ZXN0QW55IChpbnN0YW5jZSkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG50eXBlcy5vYmplY3QgPSBmdW5jdGlvbiB0ZXN0T2JqZWN0IChpbnN0YW5jZSkge1xuICAvLyBUT0RPOiBmaXggdGhpcyAtIHNlZSAjMTVcbiAgcmV0dXJuIGluc3RhbmNlICYmICh0eXBlb2YgaW5zdGFuY2UpID09PSAnb2JqZWN0JyAmJiAhKGluc3RhbmNlIGluc3RhbmNlb2YgQXJyYXkpICYmICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBEYXRlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdG9yO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJblJhbmdlO1xuIiwidmFyIHRyaW1tZWRFbmRJbmRleCA9IHJlcXVpcmUoJy4vX3RyaW1tZWRFbmRJbmRleCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRyaW07XG4iLCIvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbnZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICByZXR1cm4gaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJpbW1lZEVuZEluZGV4O1xuIiwidmFyIGJhc2VJblJhbmdlID0gcmVxdWlyZSgnLi9fYmFzZUluUmFuZ2UnKSxcbiAgICB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICogbmVnYXRpdmUgcmFuZ2VzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4zLjBcbiAqIEBjYXRlZ29yeSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pblJhbmdlKDQsIDgpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5SYW5nZSg0LCAyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pblJhbmdlKDIsIDIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gIH1cbiAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5SYW5nZTtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzSW50ZWdlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzSW50ZWdlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcbiIsInZhciBiYXNlVHJpbSA9IHJlcXVpcmUoJy4vX2Jhc2VUcmltJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBMb25nO1xyXG5cclxuLyoqXHJcbiAqIHdhc20gb3B0aW1pemF0aW9ucywgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXHJcbiAqL1xyXG52YXIgd2FzbSA9IG51bGw7XHJcblxyXG50cnkge1xyXG4gIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbXHJcbiAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMVxyXG4gIF0pKSwge30pLmV4cG9ydHM7XHJcbn0gY2F0Y2ggKGUpIHtcclxuICAvLyBubyB3YXNtIHN1cHBvcnQgOihcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gKiBAZXhwb3J0cyBMb25nXHJcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbn1cclxuXHJcbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbi8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbi8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4vL1xyXG4vLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuLy9cclxuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXHJcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4vKipcclxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcclxuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIGlmIChpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgcmFkaXggPSB1bnNpZ25lZCxcclxuICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB1bnNpZ25lZCA9ICEhIHVuc2lnbmVkO1xyXG4gICAgfVxyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgIHZhciBwO1xyXG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcclxuICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XHJcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4vLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk9ORSA9IE9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4vKipcclxuICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxyXG4gICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXHJcbiAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxyXG4gICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuaGlnaCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xyXG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcclxuICAgICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XHJcbiAgICAgICAgcmVzID0gWkVSTztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXHJcbiAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcclxuICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgcmVtID0gdGhpcztcclxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7XHJcblxyXG4gICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgbnVtQml0cyAmPSA2MztcclxuICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAyNFxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBoaSA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmZcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1swXSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1szXSA8PCAyNCxcclxuICAgICAgICBieXRlc1s0XSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s3XSA8PCAyNCxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzRdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1s1XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzddLFxyXG4gICAgICAgIGJ5dGVzWzBdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1sxXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzNdLFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlTmFtZX0gQmFzZU5hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZUNvZGV9IEJhc2VDb2RlICovXG5cbi8qKlxuICogQ2xhc3MgdG8gZW5jb2RlL2RlY29kZSBpbiB0aGUgc3VwcG9ydGVkIEJhc2VzXG4gKlxuICovXG5jbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZU5hbWV9IG5hbWVcbiAgICogQHBhcmFtIHtCYXNlQ29kZX0gY29kZVxuICAgKiBAcGFyYW0ge0NvZGVjRmFjdG9yeX0gZmFjdG9yeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBmYWN0b3J5LCBhbHBoYWJldCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgdGhpcy5jb2RlQnVmID0gZW5jb2RlVGV4dCh0aGlzLmNvZGUpXG4gICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0XG4gICAgdGhpcy5jb2RlYyA9IGZhY3RvcnkoYWxwaGFiZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuY29kZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZWMuZW5jb2RlKGJ1ZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZGVjb2RlIChzdHJpbmcpIHtcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAodGhpcy5hbHBoYWJldCAmJiB0aGlzLmFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjaGFyYWN0ZXIgJyR7Y2hhcn0nIGluICcke3N0cmluZ30nYClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29kZWMuZGVjb2RlKHN0cmluZylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlWCA9IHJlcXVpcmUoJ0BtdWx0aWZvcm1hdHMvYmFzZS14JylcbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKVxuY29uc3QgeyByZmM0NjQ4IH0gPSByZXF1aXJlKCcuL3JmYzQ2NDgnKVxuY29uc3QgeyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWN9IENvZGVjICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5CYXNlTmFtZX0gQmFzZU5hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkJhc2VDb2RlfSBCYXNlQ29kZSAqL1xuXG4vKiogQHR5cGUge0NvZGVjRmFjdG9yeX0gKi9cbmNvbnN0IGlkZW50aXR5ID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZGVjb2RlVGV4dCxcbiAgICBkZWNvZGU6IGVuY29kZVRleHRcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXRcbiAqXG4gKiBAdHlwZSB7QXJyYXk8W0Jhc2VOYW1lLCBCYXNlQ29kZSwgQ29kZWNGYWN0b3J5LCBzdHJpbmddPn1cbiAqL1xuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2lkZW50aXR5JywgJ1xceDAwJywgaWRlbnRpdHksICcnXSxcbiAgWydiYXNlMicsICcwJywgcmZjNDY0OCgxKSwgJzAxJ10sXG4gIFsnYmFzZTgnLCAnNycsIHJmYzQ2NDgoMyksICcwMTIzNDU2NyddLFxuICBbJ2Jhc2UxMCcsICc5JywgYmFzZVgsICcwMTIzNDU2Nzg5J10sXG4gIFsnYmFzZTE2JywgJ2YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OWFiY2RlZiddLFxuICBbJ2Jhc2UxNnVwcGVyJywgJ0YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OUFCQ0RFRiddLFxuICBbJ2Jhc2UzMmhleCcsICd2JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4dXBwZXInLCAnVicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVViddLFxuICBbJ2Jhc2UzMmhleHBhZCcsICd0JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PSddLFxuICBbJ2Jhc2UzMmhleHBhZHVwcGVyJywgJ1QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9J10sXG4gIFsnYmFzZTMyJywgJ2InLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnXSxcbiAgWydiYXNlMzJ1cHBlcicsICdCJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9J10sXG4gIFsnYmFzZTMycGFkdXBwZXInLCAnQycsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCByZmM0NjQ4KDUpLCAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknXSxcbiAgWydiYXNlMzYnLCAnaycsIGJhc2VYLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTM2dXBwZXInLCAnSycsIGJhc2VYLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNThmbGlja3InLCAnWicsIGJhc2VYLCAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U2NCcsICdtJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSddLFxuICBbJ2Jhc2U2NHVybCcsICd1JywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nXSxcbiAgWydiYXNlNjR1cmxwYWQnLCAnVScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbi8qKiBAdHlwZSB7UmVjb3JkPEJhc2VOYW1lLEJhc2U+fSAqL1xuY29uc3QgbmFtZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMF1dID0gbmV3IEJhc2UodHVwcGxlWzBdLCB0dXBwbGVbMV0sIHR1cHBsZVsyXSwgdHVwcGxlWzNdKVxuICByZXR1cm4gcHJldlxufSwgLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZU5hbWUsQmFzZT59ICovKHt9KSlcblxuLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZUNvZGUsQmFzZT59ICovXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCAvKiogQHR5cGUge1JlY29yZDxCYXNlQ29kZSxCYXNlPn0gKi8oe30pKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZXMsXG4gIGNvZGVzXG59XG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbbXVsdGliYXNlXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYmFzZSkgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGVuY29kZVRleHQsIGRlY29kZVRleHQsIGNvbmNhdCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2Jhc2UnKX0gQmFzZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlTmFtZU9yQ29kZX0gQmFzZU5hbWVPckNvZGUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZUNvZGV9IEJhc2VDb2RlICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VOYW1lfSBCYXNlTmFtZSAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBVaW50OEFycmF5IHdpdGggdGhlIG11bHRpYmFzZSB2YXJpbnQrY29kZS5cbiAqXG4gKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgLSBUaGUgZGF0YSB0byBiZSBwcmVmaXhlZCB3aXRoIG11bHRpYmFzZS5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gbXVsdGliYXNlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgaWYgKCFidWYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGFuIGVuY29kZWQgVWludDhBcnJheScpXG4gIH1cbiAgY29uc3QgeyBuYW1lLCBjb2RlQnVmIH0gPSBlbmNvZGluZyhuYW1lT3JDb2RlKVxuICB2YWxpZEVuY29kZShuYW1lLCBidWYpXG5cbiAgcmV0dXJuIGNvbmNhdChbY29kZUJ1ZiwgYnVmXSwgY29kZUJ1Zi5sZW5ndGggKyBidWYubGVuZ3RoKVxufVxuXG4vKipcbiAqIEVuY29kZSBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBiYXNlIGFuZCBhZGQgdGhlIG11bHRpYmFzZSBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtCYXNlTmFtZU9yQ29kZX0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKG5hbWVPckNvZGUpXG4gIGNvbnN0IGRhdGEgPSBlbmNvZGVUZXh0KGVuYy5lbmNvZGUoYnVmKSlcblxuICByZXR1cm4gY29uY2F0KFtlbmMuY29kZUJ1ZiwgZGF0YV0sIGVuYy5jb2RlQnVmLmxlbmd0aCArIGRhdGEubGVuZ3RoKVxufVxuXG4vKipcbiAqIFRha2VzIGEgVWludDhBcnJheSBvciBzdHJpbmcgZW5jb2RlZCB3aXRoIG11bHRpYmFzZSBoZWFkZXIsIGRlY29kZXMgaXQgYW5kXG4gKiByZXR1cm5zIHRoZSBkZWNvZGVkIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGFbMF1cblxuICAvLyBNYWtlIGFsbCBlbmNvZGluZ3MgY2FzZS1pbnNlbnNpdGl2ZSBleGNlcHQgdGhlIG9uZXMgdGhhdCBpbmNsdWRlIHVwcGVyIGFuZCBsb3dlciBjaGFycyBpbiB0aGUgYWxwaGFiZXRcbiAgaWYgKFsnZicsICdGJywgJ3YnLCAnVicsICd0JywgJ1QnLCAnYicsICdCJywgJ2MnLCAnQycsICdoJywgJ2snLCAnSyddLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICBkYXRhID0gZGF0YS50b0xvd2VyQ2FzZSgpXG4gIH1cbiAgY29uc3QgZW5jID0gZW5jb2RpbmcoLyoqIEB0eXBlIHtCYXNlQ29kZX0gKi8oZGF0YVswXSkpXG4gIHJldHVybiBlbmMuZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEpKVxufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBkYXRhIG11bHRpYmFzZSBlbmNvZGVkP1xuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGRhdGFcbiAqL1xuZnVuY3Rpb24gaXNFbmNvZGVkIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cblxuICAvLyBFbnN1cmUgYnVmT3JTdHJpbmcgaXMgYSBzdHJpbmdcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZW5jID0gZW5jb2RpbmcoLyoqIEB0eXBlIHtCYXNlQ29kZX0gKi8oZGF0YVswXSkpXG4gICAgcmV0dXJuIGVuYy5uYW1lXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgZW5jb2RlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtCYXNlTmFtZU9yQ29kZX0gbmFtZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRFbmNvZGUgKG5hbWUsIGJ1Zikge1xuICBjb25zdCBlbmMgPSBlbmNvZGluZyhuYW1lKVxuICBlbmMuZGVjb2RlKGRlY29kZVRleHQoYnVmKSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGVuY29kaW5nIGJ5IG5hbWUgb3IgY29kZVxuICpcbiAqIEBwYXJhbSB7QmFzZU5hbWVPckNvZGV9IG5hbWVPckNvZGVcbiAqIEByZXR1cm5zIHtCYXNlfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RpbmcgKG5hbWVPckNvZGUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25zdGFudHMubmFtZXMsIC8qKiBAdHlwZSB7QmFzZU5hbWV9ICovKG5hbWVPckNvZGUpKSkge1xuICAgIHJldHVybiBjb25zdGFudHMubmFtZXNbLyoqIEB0eXBlIHtCYXNlTmFtZX0gKi8obmFtZU9yQ29kZSldXG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnN0YW50cy5jb2RlcywgLyoqIEB0eXBlIHtCYXNlQ29kZX0gKi8obmFtZU9yQ29kZSkpKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5jb2Rlc1svKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhuYW1lT3JDb2RlKV1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nOiAke25hbWVPckNvZGV9YClcbiAgfVxufVxuXG4vKipcbiAqIEdldCBlbmNvZGluZyBmcm9tIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7QmFzZX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGVuY29kaW5nRnJvbURhdGEgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuXG4gIHJldHVybiBlbmNvZGluZygvKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhkYXRhWzBdKSlcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbXVsdGliYXNlXG5leHBvcnRzLmVuY29kZSA9IGVuY29kZVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVcbmV4cG9ydHMuaXNFbmNvZGVkID0gaXNFbmNvZGVkXG5leHBvcnRzLmVuY29kaW5nID0gZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RpbmdGcm9tRGF0YSA9IGVuY29kaW5nRnJvbURhdGFcbmNvbnN0IG5hbWVzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMubmFtZXMpXG5jb25zdCBjb2RlcyA9IE9iamVjdC5mcmVlemUoY29uc3RhbnRzLmNvZGVzKVxuZXhwb3J0cy5uYW1lcyA9IG5hbWVzXG5leHBvcnRzLmNvZGVzID0gY29kZXNcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZGVjb2RlID0gKHN0cmluZywgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIC8vIEJ1aWxkIHRoZSBjaGFyYWN0ZXIgbG9va3VwIHRhYmxlOlxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIG51bWJlcj59ICovXG4gIGNvbnN0IGNvZGVzID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7ICsraSkge1xuICAgIGNvZGVzW2FscGhhYmV0W2ldXSA9IGlcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBwYWRkaW5nIGJ5dGVzOlxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aFxuICB3aGlsZSAoc3RyaW5nW2VuZCAtIDFdID09PSAnPScpIHtcbiAgICAtLWVuZFxuICB9XG5cbiAgLy8gQWxsb2NhdGUgdGhlIG91dHB1dDpcbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoKGVuZCAqIGJpdHNQZXJDaGFyIC8gOCkgfCAwKVxuXG4gIC8vIFBhcnNlIHRoZSBkYXRhOlxuICBsZXQgYml0cyA9IDAgLy8gTnVtYmVyIG9mIGJpdHMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgbGV0IGJ1ZmZlciA9IDAgLy8gQml0cyB3YWl0aW5nIHRvIGJlIHdyaXR0ZW4gb3V0LCBNU0IgZmlyc3RcbiAgbGV0IHdyaXR0ZW4gPSAwIC8vIE5leHQgYnl0ZSB0byB3cml0ZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKytpKSB7XG4gICAgLy8gUmVhZCBvbmUgY2hhcmFjdGVyIGZyb20gdGhlIHN0cmluZzpcbiAgICBjb25zdCB2YWx1ZSA9IGNvZGVzW3N0cmluZ1tpXV1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciAnICsgc3RyaW5nW2ldKVxuICAgIH1cblxuICAgIC8vIEFwcGVuZCB0aGUgYml0cyB0byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgYml0c1BlckNoYXIpIHwgdmFsdWVcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyXG5cbiAgICAvLyBXcml0ZSBvdXQgc29tZSBiaXRzIGlmIHRoZSBidWZmZXIgaGFzIGEgYnl0ZSdzIHdvcnRoOlxuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gOFxuICAgICAgb3V0W3dyaXR0ZW4rK10gPSAweGZmICYgKGJ1ZmZlciA+PiBiaXRzKVxuICAgIH1cbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHdlIGhhdmUgcmVjZWl2ZWQganVzdCBlbm91Z2ggYml0czpcbiAgaWYgKGJpdHMgPj0gYml0c1BlckNoYXIgfHwgMHhmZiAmIChidWZmZXIgPDwgKDggLSBiaXRzKSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVuY29kZSA9IChkYXRhLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgY29uc3QgcGFkID0gYWxwaGFiZXRbYWxwaGFiZXQubGVuZ3RoIC0gMV0gPT09ICc9J1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMVxuICBsZXQgb3V0ID0gJydcblxuICBsZXQgYml0cyA9IDAgLy8gTnVtYmVyIG9mIGJpdHMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgbGV0IGJ1ZmZlciA9IDAgLy8gQml0cyB3YWl0aW5nIHRvIGJlIHdyaXR0ZW4gb3V0LCBNU0IgZmlyc3RcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gU2x1cnAgZGF0YSBpbnRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCA4KSB8IGRhdGFbaV1cbiAgICBiaXRzICs9IDhcblxuICAgIC8vIFdyaXRlIG91dCBhcyBtdWNoIGFzIHdlIGNhbjpcbiAgICB3aGlsZSAoYml0cyA+IGJpdHNQZXJDaGFyKSB7XG4gICAgICBiaXRzIC09IGJpdHNQZXJDaGFyXG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPj4gYml0cyldXG4gICAgfVxuICB9XG5cbiAgLy8gUGFydGlhbCBjaGFyYWN0ZXI6XG4gIGlmIChiaXRzKSB7XG4gICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyIDw8IChiaXRzUGVyQ2hhciAtIGJpdHMpKV1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nIGNoYXJhY3RlcnMgdW50aWwgd2UgaGl0IGEgYnl0ZSBib3VuZGFyeTpcbiAgaWYgKHBhZCkge1xuICAgIHdoaWxlICgob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyKSAmIDcpIHtcbiAgICAgIG91dCArPSAnPSdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogUkZDNDY0OCBGYWN0b3J5XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7Q29kZWNGYWN0b3J5fVxuICovXG5jb25zdCByZmM0NjQ4ID0gKGJpdHNQZXJDaGFyKSA9PiAoYWxwaGFiZXQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBlbmNvZGUgKGlucHV0KSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBkZWNvZGUgKGlucHV0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyByZmM0NjQ4IH1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfSBieXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZGVjb2RlVGV4dCA9IChieXRlcykgPT4gdGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzKVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlVGV4dCA9ICh0ZXh0KSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUodGV4dClcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFVpbnQ4QXJyYXkgY3JlYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXNzZWQgQXJyYXlzXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheUxpa2U8bnVtYmVyPj59IGFycnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBjb25jYXQgKGFycnMsIGxlbmd0aCkge1xuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJycykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlY29kZVRleHQsIGVuY29kZVRleHQsIGNvbmNhdCB9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCB8fCBzaGlmdCA+IDQ5KSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZW5jb2RlXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcbiAgLCBNU0JBTEwgPSB+UkVTVFxuICAsIElOVCA9IE1hdGgucG93KDIsIDMxKVxuXG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBpZiAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgbnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICBlbmNvZGUuYnl0ZXMgPSAwXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBlbmNvZGUgdmFyaW50JylcbiAgfVxuICBvdXQgPSBvdXQgfHwgW11cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuXG4gIHdoaWxlKG51bSA+PSBJTlQpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtIC89IDEyOFxuICB9XG4gIHdoaWxlKG51bSAmIE1TQkFMTCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gPj4+PSA3XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwXG4gIFxuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxXG4gIFxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IHJlcXVpcmUoJy4vZW5jb2RlLmpzJylcbiAgLCBkZWNvZGU6IHJlcXVpcmUoJy4vZGVjb2RlLmpzJylcbiAgLCBlbmNvZGluZ0xlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGguanMnKVxufVxuIiwiXG52YXIgTjEgPSBNYXRoLnBvdygyLCAgNylcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KVxudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpXG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOClcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KVxudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpXG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSlcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KVxudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPCBOMSA/IDFcbiAgOiB2YWx1ZSA8IE4yID8gMlxuICA6IHZhbHVlIDwgTjMgPyAzXG4gIDogdmFsdWUgPCBONCA/IDRcbiAgOiB2YWx1ZSA8IE41ID8gNVxuICA6IHZhbHVlIDwgTjYgPyA2XG4gIDogdmFsdWUgPCBONyA/IDdcbiAgOiB2YWx1ZSA8IE44ID8gOFxuICA6IHZhbHVlIDwgTjkgPyA5XG4gIDogICAgICAgICAgICAgIDEwXG4gIClcbn1cbiIsIi8vIERPIE5PVCBDSEFOR0UgVEhJUyBGSUxFLiBJVCBJUyBHRU5FUkFURUQgQlkgdG9vbHMvdXBkYXRlLXRhYmxlLmpzXG4vKiBlc2xpbnQgcXVvdGUtcHJvcHM6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHR5cGUge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuTmFtZUNvZGVNYXB9XG4gKi9cbmNvbnN0IGJhc2VUYWJsZSA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnY2lkdjEnOiAweDAxLFxuICAnY2lkdjInOiAweDAyLFxuICAnY2lkdjMnOiAweDAzLFxuICAnaXA0JzogMHgwNCxcbiAgJ3RjcCc6IDB4MDYsXG4gICdzaGExJzogMHgxMSxcbiAgJ3NoYTItMjU2JzogMHgxMixcbiAgJ3NoYTItNTEyJzogMHgxMyxcbiAgJ3NoYTMtNTEyJzogMHgxNCxcbiAgJ3NoYTMtMzg0JzogMHgxNSxcbiAgJ3NoYTMtMjU2JzogMHgxNixcbiAgJ3NoYTMtMjI0JzogMHgxNyxcbiAgJ3NoYWtlLTEyOCc6IDB4MTgsXG4gICdzaGFrZS0yNTYnOiAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MWEsXG4gICdrZWNjYWstMjU2JzogMHgxYixcbiAgJ2tlY2Nhay0zODQnOiAweDFjLFxuICAna2VjY2FrLTUxMic6IDB4MWQsXG4gICdibGFrZTMnOiAweDFlLFxuICAnZGNjcCc6IDB4MjEsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogMHgyMyxcbiAgJ2lwNic6IDB4MjksXG4gICdpcDZ6b25lJzogMHgyYSxcbiAgJ3BhdGgnOiAweDJmLFxuICAnbXVsdGljb2RlYyc6IDB4MzAsXG4gICdtdWx0aWhhc2gnOiAweDMxLFxuICAnbXVsdGlhZGRyJzogMHgzMixcbiAgJ211bHRpYmFzZSc6IDB4MzMsXG4gICdkbnMnOiAweDM1LFxuICAnZG5zNCc6IDB4MzYsXG4gICdkbnM2JzogMHgzNyxcbiAgJ2Ruc2FkZHInOiAweDM4LFxuICAncHJvdG9idWYnOiAweDUwLFxuICAnY2Jvcic6IDB4NTEsXG4gICdyYXcnOiAweDU1LFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ3JscCc6IDB4NjAsXG4gICdiZW5jb2RlJzogMHg2MyxcbiAgJ2RhZy1wYic6IDB4NzAsXG4gICdkYWctY2Jvcic6IDB4NzEsXG4gICdsaWJwMnAta2V5JzogMHg3MixcbiAgJ2dpdC1yYXcnOiAweDc4LFxuICAndG9ycmVudC1pbmZvJzogMHg3YixcbiAgJ3RvcnJlbnQtZmlsZSc6IDB4N2MsXG4gICdsZW9mY29pbi1ibG9jayc6IDB4ODEsXG4gICdsZW9mY29pbi10eCc6IDB4ODIsXG4gICdsZW9mY29pbi1wcic6IDB4ODMsXG4gICdzY3RwJzogMHg4NCxcbiAgJ2RhZy1qb3NlJzogMHg4NSxcbiAgJ2RhZy1jb3NlJzogMHg4NixcbiAgJ2V0aC1ibG9jayc6IDB4OTAsXG4gICdldGgtYmxvY2stbGlzdCc6IDB4OTEsXG4gICdldGgtdHgtdHJpZSc6IDB4OTIsXG4gICdldGgtdHgnOiAweDkzLFxuICAnZXRoLXR4LXJlY2VpcHQtdHJpZSc6IDB4OTQsXG4gICdldGgtdHgtcmVjZWlwdCc6IDB4OTUsXG4gICdldGgtc3RhdGUtdHJpZSc6IDB4OTYsXG4gICdldGgtYWNjb3VudC1zbmFwc2hvdCc6IDB4OTcsXG4gICdldGgtc3RvcmFnZS10cmllJzogMHg5OCxcbiAgJ2JpdGNvaW4tYmxvY2snOiAweGIwLFxuICAnYml0Y29pbi10eCc6IDB4YjEsXG4gICdiaXRjb2luLXdpdG5lc3MtY29tbWl0bWVudCc6IDB4YjIsXG4gICd6Y2FzaC1ibG9jayc6IDB4YzAsXG4gICd6Y2FzaC10eCc6IDB4YzEsXG4gICdkb2NpZCc6IDB4Y2UsXG4gICdzdGVsbGFyLWJsb2NrJzogMHhkMCxcbiAgJ3N0ZWxsYXItdHgnOiAweGQxLFxuICAnbWQ0JzogMHhkNCxcbiAgJ21kNSc6IDB4ZDUsXG4gICdibXQnOiAweGQ2LFxuICAnZGVjcmVkLWJsb2NrJzogMHhlMCxcbiAgJ2RlY3JlZC10eCc6IDB4ZTEsXG4gICdpcGxkLW5zJzogMHhlMixcbiAgJ2lwZnMtbnMnOiAweGUzLFxuICAnc3dhcm0tbnMnOiAweGU0LFxuICAnaXBucy1ucyc6IDB4ZTUsXG4gICd6ZXJvbmV0JzogMHhlNixcbiAgJ3NlY3AyNTZrMS1wdWInOiAweGU3LFxuICAnYmxzMTJfMzgxLWcxLXB1Yic6IDB4ZWEsXG4gICdibHMxMl8zODEtZzItcHViJzogMHhlYixcbiAgJ3gyNTUxOS1wdWInOiAweGVjLFxuICAnZWQyNTUxOS1wdWInOiAweGVkLFxuICAnYmxzMTJfMzgxLWcxZzItcHViJzogMHhlZSxcbiAgJ2Rhc2gtYmxvY2snOiAweGYwLFxuICAnZGFzaC10eCc6IDB4ZjEsXG4gICdzd2FybS1tYW5pZmVzdCc6IDB4ZmEsXG4gICdzd2FybS1mZWVkJzogMHhmYixcbiAgJ3VkcCc6IDB4MDExMSxcbiAgJ3AycC13ZWJydGMtc3Rhcic6IDB4MDExMyxcbiAgJ3AycC13ZWJydGMtZGlyZWN0JzogMHgwMTE0LFxuICAncDJwLXN0YXJkdXN0JzogMHgwMTE1LFxuICAncDJwLWNpcmN1aXQnOiAweDAxMjIsXG4gICdkYWctanNvbic6IDB4MDEyOSxcbiAgJ3VkdCc6IDB4MDEyZCxcbiAgJ3V0cCc6IDB4MDEyZSxcbiAgJ3VuaXgnOiAweDAxOTAsXG4gICd0aHJlYWQnOiAweDAxOTYsXG4gICdwMnAnOiAweDAxYTUsXG4gICdpcGZzJzogMHgwMWE1LFxuICAnaHR0cHMnOiAweDAxYmIsXG4gICdvbmlvbic6IDB4MDFiYyxcbiAgJ29uaW9uMyc6IDB4MDFiZCxcbiAgJ2dhcmxpYzY0JzogMHgwMWJlLFxuICAnZ2FybGljMzInOiAweDAxYmYsXG4gICd0bHMnOiAweDAxYzAsXG4gICdxdWljJzogMHgwMWNjLFxuICAnd3MnOiAweDAxZGQsXG4gICd3c3MnOiAweDAxZGUsXG4gICdwMnAtd2Vic29ja2V0LXN0YXInOiAweDAxZGYsXG4gICdodHRwJzogMHgwMWUwLFxuICAnanNvbic6IDB4MDIwMCxcbiAgJ21lc3NhZ2VwYWNrJzogMHgwMjAxLFxuICAnbGlicDJwLXBlZXItcmVjb3JkJzogMHgwMzAxLFxuICAnc2hhMi0yNTYtdHJ1bmMyNTQtcGFkZGVkJzogMHgxMDEyLFxuICAncmlwZW1kLTEyOCc6IDB4MTA1MixcbiAgJ3JpcGVtZC0xNjAnOiAweDEwNTMsXG4gICdyaXBlbWQtMjU2JzogMHgxMDU0LFxuICAncmlwZW1kLTMyMCc6IDB4MTA1NSxcbiAgJ3gxMSc6IDB4MTEwMCxcbiAgJ3AyNTYtcHViJzogMHgxMjAwLFxuICAncDM4NC1wdWInOiAweDEyMDEsXG4gICdwNTIxLXB1Yic6IDB4MTIwMixcbiAgJ2VkNDQ4LXB1Yic6IDB4MTIwMyxcbiAgJ3g0NDgtcHViJzogMHgxMjA0LFxuICAnZWQyNTUxOS1wcml2JzogMHgxMzAwLFxuICAna2FuZ2Fyb290d2VsdmUnOiAweDFkMDEsXG4gICdzbTMtMjU2JzogMHg1MzRkLFxuICAnYmxha2UyYi04JzogMHhiMjAxLFxuICAnYmxha2UyYi0xNic6IDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogMHhiMjA0LFxuICAnYmxha2UyYi00MCc6IDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogMHhiMjA3LFxuICAnYmxha2UyYi02NCc6IDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAweGIyMDksXG4gICdibGFrZTJiLTgwJzogMHhiMjBhLFxuICAnYmxha2UyYi04OCc6IDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6IDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogMHhiMjQzLFxuICAnYmxha2Uycy0zMic6IDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogMHhiMjQ2LFxuICAnYmxha2Uycy01Nic6IDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogMHhiMjQ5LFxuICAnYmxha2Uycy04MCc6IDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogMHhiMjRjLFxuICAnYmxha2Uycy0xMDQnOiAweGIyNGQsXG4gICdibGFrZTJzLTExMic6IDB4YjI0ZSxcbiAgJ2JsYWtlMnMtMTIwJzogMHhiMjRmLFxuICAnYmxha2Uycy0xMjgnOiAweGIyNTAsXG4gICdibGFrZTJzLTEzNic6IDB4YjI1MSxcbiAgJ2JsYWtlMnMtMTQ0JzogMHhiMjUyLFxuICAnYmxha2Uycy0xNTInOiAweGIyNTMsXG4gICdibGFrZTJzLTE2MCc6IDB4YjI1NCxcbiAgJ2JsYWtlMnMtMTY4JzogMHhiMjU1LFxuICAnYmxha2Uycy0xNzYnOiAweGIyNTYsXG4gICdibGFrZTJzLTE4NCc6IDB4YjI1NyxcbiAgJ2JsYWtlMnMtMTkyJzogMHhiMjU4LFxuICAnYmxha2Uycy0yMDAnOiAweGIyNTksXG4gICdibGFrZTJzLTIwOCc6IDB4YjI1YSxcbiAgJ2JsYWtlMnMtMjE2JzogMHhiMjViLFxuICAnYmxha2Uycy0yMjQnOiAweGIyNWMsXG4gICdibGFrZTJzLTIzMic6IDB4YjI1ZCxcbiAgJ2JsYWtlMnMtMjQwJzogMHhiMjVlLFxuICAnYmxha2Uycy0yNDgnOiAweGIyNWYsXG4gICdibGFrZTJzLTI1Nic6IDB4YjI2MCxcbiAgJ3NrZWluMjU2LTgnOiAweGIzMDEsXG4gICdza2VpbjI1Ni0xNic6IDB4YjMwMixcbiAgJ3NrZWluMjU2LTI0JzogMHhiMzAzLFxuICAnc2tlaW4yNTYtMzInOiAweGIzMDQsXG4gICdza2VpbjI1Ni00MCc6IDB4YjMwNSxcbiAgJ3NrZWluMjU2LTQ4JzogMHhiMzA2LFxuICAnc2tlaW4yNTYtNTYnOiAweGIzMDcsXG4gICdza2VpbjI1Ni02NCc6IDB4YjMwOCxcbiAgJ3NrZWluMjU2LTcyJzogMHhiMzA5LFxuICAnc2tlaW4yNTYtODAnOiAweGIzMGEsXG4gICdza2VpbjI1Ni04OCc6IDB4YjMwYixcbiAgJ3NrZWluMjU2LTk2JzogMHhiMzBjLFxuICAnc2tlaW4yNTYtMTA0JzogMHhiMzBkLFxuICAnc2tlaW4yNTYtMTEyJzogMHhiMzBlLFxuICAnc2tlaW4yNTYtMTIwJzogMHhiMzBmLFxuICAnc2tlaW4yNTYtMTI4JzogMHhiMzEwLFxuICAnc2tlaW4yNTYtMTM2JzogMHhiMzExLFxuICAnc2tlaW4yNTYtMTQ0JzogMHhiMzEyLFxuICAnc2tlaW4yNTYtMTUyJzogMHhiMzEzLFxuICAnc2tlaW4yNTYtMTYwJzogMHhiMzE0LFxuICAnc2tlaW4yNTYtMTY4JzogMHhiMzE1LFxuICAnc2tlaW4yNTYtMTc2JzogMHhiMzE2LFxuICAnc2tlaW4yNTYtMTg0JzogMHhiMzE3LFxuICAnc2tlaW4yNTYtMTkyJzogMHhiMzE4LFxuICAnc2tlaW4yNTYtMjAwJzogMHhiMzE5LFxuICAnc2tlaW4yNTYtMjA4JzogMHhiMzFhLFxuICAnc2tlaW4yNTYtMjE2JzogMHhiMzFiLFxuICAnc2tlaW4yNTYtMjI0JzogMHhiMzFjLFxuICAnc2tlaW4yNTYtMjMyJzogMHhiMzFkLFxuICAnc2tlaW4yNTYtMjQwJzogMHhiMzFlLFxuICAnc2tlaW4yNTYtMjQ4JzogMHhiMzFmLFxuICAnc2tlaW4yNTYtMjU2JzogMHhiMzIwLFxuICAnc2tlaW41MTItOCc6IDB4YjMyMSxcbiAgJ3NrZWluNTEyLTE2JzogMHhiMzIyLFxuICAnc2tlaW41MTItMjQnOiAweGIzMjMsXG4gICdza2VpbjUxMi0zMic6IDB4YjMyNCxcbiAgJ3NrZWluNTEyLTQwJzogMHhiMzI1LFxuICAnc2tlaW41MTItNDgnOiAweGIzMjYsXG4gICdza2VpbjUxMi01Nic6IDB4YjMyNyxcbiAgJ3NrZWluNTEyLTY0JzogMHhiMzI4LFxuICAnc2tlaW41MTItNzInOiAweGIzMjksXG4gICdza2VpbjUxMi04MCc6IDB4YjMyYSxcbiAgJ3NrZWluNTEyLTg4JzogMHhiMzJiLFxuICAnc2tlaW41MTItOTYnOiAweGIzMmMsXG4gICdza2VpbjUxMi0xMDQnOiAweGIzMmQsXG4gICdza2VpbjUxMi0xMTInOiAweGIzMmUsXG4gICdza2VpbjUxMi0xMjAnOiAweGIzMmYsXG4gICdza2VpbjUxMi0xMjgnOiAweGIzMzAsXG4gICdza2VpbjUxMi0xMzYnOiAweGIzMzEsXG4gICdza2VpbjUxMi0xNDQnOiAweGIzMzIsXG4gICdza2VpbjUxMi0xNTInOiAweGIzMzMsXG4gICdza2VpbjUxMi0xNjAnOiAweGIzMzQsXG4gICdza2VpbjUxMi0xNjgnOiAweGIzMzUsXG4gICdza2VpbjUxMi0xNzYnOiAweGIzMzYsXG4gICdza2VpbjUxMi0xODQnOiAweGIzMzcsXG4gICdza2VpbjUxMi0xOTInOiAweGIzMzgsXG4gICdza2VpbjUxMi0yMDAnOiAweGIzMzksXG4gICdza2VpbjUxMi0yMDgnOiAweGIzM2EsXG4gICdza2VpbjUxMi0yMTYnOiAweGIzM2IsXG4gICdza2VpbjUxMi0yMjQnOiAweGIzM2MsXG4gICdza2VpbjUxMi0yMzInOiAweGIzM2QsXG4gICdza2VpbjUxMi0yNDAnOiAweGIzM2UsXG4gICdza2VpbjUxMi0yNDgnOiAweGIzM2YsXG4gICdza2VpbjUxMi0yNTYnOiAweGIzNDAsXG4gICdza2VpbjUxMi0yNjQnOiAweGIzNDEsXG4gICdza2VpbjUxMi0yNzInOiAweGIzNDIsXG4gICdza2VpbjUxMi0yODAnOiAweGIzNDMsXG4gICdza2VpbjUxMi0yODgnOiAweGIzNDQsXG4gICdza2VpbjUxMi0yOTYnOiAweGIzNDUsXG4gICdza2VpbjUxMi0zMDQnOiAweGIzNDYsXG4gICdza2VpbjUxMi0zMTInOiAweGIzNDcsXG4gICdza2VpbjUxMi0zMjAnOiAweGIzNDgsXG4gICdza2VpbjUxMi0zMjgnOiAweGIzNDksXG4gICdza2VpbjUxMi0zMzYnOiAweGIzNGEsXG4gICdza2VpbjUxMi0zNDQnOiAweGIzNGIsXG4gICdza2VpbjUxMi0zNTInOiAweGIzNGMsXG4gICdza2VpbjUxMi0zNjAnOiAweGIzNGQsXG4gICdza2VpbjUxMi0zNjgnOiAweGIzNGUsXG4gICdza2VpbjUxMi0zNzYnOiAweGIzNGYsXG4gICdza2VpbjUxMi0zODQnOiAweGIzNTAsXG4gICdza2VpbjUxMi0zOTInOiAweGIzNTEsXG4gICdza2VpbjUxMi00MDAnOiAweGIzNTIsXG4gICdza2VpbjUxMi00MDgnOiAweGIzNTMsXG4gICdza2VpbjUxMi00MTYnOiAweGIzNTQsXG4gICdza2VpbjUxMi00MjQnOiAweGIzNTUsXG4gICdza2VpbjUxMi00MzInOiAweGIzNTYsXG4gICdza2VpbjUxMi00NDAnOiAweGIzNTcsXG4gICdza2VpbjUxMi00NDgnOiAweGIzNTgsXG4gICdza2VpbjUxMi00NTYnOiAweGIzNTksXG4gICdza2VpbjUxMi00NjQnOiAweGIzNWEsXG4gICdza2VpbjUxMi00NzInOiAweGIzNWIsXG4gICdza2VpbjUxMi00ODAnOiAweGIzNWMsXG4gICdza2VpbjUxMi00ODgnOiAweGIzNWQsXG4gICdza2VpbjUxMi00OTYnOiAweGIzNWUsXG4gICdza2VpbjUxMi01MDQnOiAweGIzNWYsXG4gICdza2VpbjUxMi01MTInOiAweGIzNjAsXG4gICdza2VpbjEwMjQtOCc6IDB4YjM2MSxcbiAgJ3NrZWluMTAyNC0xNic6IDB4YjM2MixcbiAgJ3NrZWluMTAyNC0yNCc6IDB4YjM2MyxcbiAgJ3NrZWluMTAyNC0zMic6IDB4YjM2NCxcbiAgJ3NrZWluMTAyNC00MCc6IDB4YjM2NSxcbiAgJ3NrZWluMTAyNC00OCc6IDB4YjM2NixcbiAgJ3NrZWluMTAyNC01Nic6IDB4YjM2NyxcbiAgJ3NrZWluMTAyNC02NCc6IDB4YjM2OCxcbiAgJ3NrZWluMTAyNC03Mic6IDB4YjM2OSxcbiAgJ3NrZWluMTAyNC04MCc6IDB4YjM2YSxcbiAgJ3NrZWluMTAyNC04OCc6IDB4YjM2YixcbiAgJ3NrZWluMTAyNC05Nic6IDB4YjM2YyxcbiAgJ3NrZWluMTAyNC0xMDQnOiAweGIzNmQsXG4gICdza2VpbjEwMjQtMTEyJzogMHhiMzZlLFxuICAnc2tlaW4xMDI0LTEyMCc6IDB4YjM2ZixcbiAgJ3NrZWluMTAyNC0xMjgnOiAweGIzNzAsXG4gICdza2VpbjEwMjQtMTM2JzogMHhiMzcxLFxuICAnc2tlaW4xMDI0LTE0NCc6IDB4YjM3MixcbiAgJ3NrZWluMTAyNC0xNTInOiAweGIzNzMsXG4gICdza2VpbjEwMjQtMTYwJzogMHhiMzc0LFxuICAnc2tlaW4xMDI0LTE2OCc6IDB4YjM3NSxcbiAgJ3NrZWluMTAyNC0xNzYnOiAweGIzNzYsXG4gICdza2VpbjEwMjQtMTg0JzogMHhiMzc3LFxuICAnc2tlaW4xMDI0LTE5Mic6IDB4YjM3OCxcbiAgJ3NrZWluMTAyNC0yMDAnOiAweGIzNzksXG4gICdza2VpbjEwMjQtMjA4JzogMHhiMzdhLFxuICAnc2tlaW4xMDI0LTIxNic6IDB4YjM3YixcbiAgJ3NrZWluMTAyNC0yMjQnOiAweGIzN2MsXG4gICdza2VpbjEwMjQtMjMyJzogMHhiMzdkLFxuICAnc2tlaW4xMDI0LTI0MCc6IDB4YjM3ZSxcbiAgJ3NrZWluMTAyNC0yNDgnOiAweGIzN2YsXG4gICdza2VpbjEwMjQtMjU2JzogMHhiMzgwLFxuICAnc2tlaW4xMDI0LTI2NCc6IDB4YjM4MSxcbiAgJ3NrZWluMTAyNC0yNzInOiAweGIzODIsXG4gICdza2VpbjEwMjQtMjgwJzogMHhiMzgzLFxuICAnc2tlaW4xMDI0LTI4OCc6IDB4YjM4NCxcbiAgJ3NrZWluMTAyNC0yOTYnOiAweGIzODUsXG4gICdza2VpbjEwMjQtMzA0JzogMHhiMzg2LFxuICAnc2tlaW4xMDI0LTMxMic6IDB4YjM4NyxcbiAgJ3NrZWluMTAyNC0zMjAnOiAweGIzODgsXG4gICdza2VpbjEwMjQtMzI4JzogMHhiMzg5LFxuICAnc2tlaW4xMDI0LTMzNic6IDB4YjM4YSxcbiAgJ3NrZWluMTAyNC0zNDQnOiAweGIzOGIsXG4gICdza2VpbjEwMjQtMzUyJzogMHhiMzhjLFxuICAnc2tlaW4xMDI0LTM2MCc6IDB4YjM4ZCxcbiAgJ3NrZWluMTAyNC0zNjgnOiAweGIzOGUsXG4gICdza2VpbjEwMjQtMzc2JzogMHhiMzhmLFxuICAnc2tlaW4xMDI0LTM4NCc6IDB4YjM5MCxcbiAgJ3NrZWluMTAyNC0zOTInOiAweGIzOTEsXG4gICdza2VpbjEwMjQtNDAwJzogMHhiMzkyLFxuICAnc2tlaW4xMDI0LTQwOCc6IDB4YjM5MyxcbiAgJ3NrZWluMTAyNC00MTYnOiAweGIzOTQsXG4gICdza2VpbjEwMjQtNDI0JzogMHhiMzk1LFxuICAnc2tlaW4xMDI0LTQzMic6IDB4YjM5NixcbiAgJ3NrZWluMTAyNC00NDAnOiAweGIzOTcsXG4gICdza2VpbjEwMjQtNDQ4JzogMHhiMzk4LFxuICAnc2tlaW4xMDI0LTQ1Nic6IDB4YjM5OSxcbiAgJ3NrZWluMTAyNC00NjQnOiAweGIzOWEsXG4gICdza2VpbjEwMjQtNDcyJzogMHhiMzliLFxuICAnc2tlaW4xMDI0LTQ4MCc6IDB4YjM5YyxcbiAgJ3NrZWluMTAyNC00ODgnOiAweGIzOWQsXG4gICdza2VpbjEwMjQtNDk2JzogMHhiMzllLFxuICAnc2tlaW4xMDI0LTUwNCc6IDB4YjM5ZixcbiAgJ3NrZWluMTAyNC01MTInOiAweGIzYTAsXG4gICdza2VpbjEwMjQtNTIwJzogMHhiM2ExLFxuICAnc2tlaW4xMDI0LTUyOCc6IDB4YjNhMixcbiAgJ3NrZWluMTAyNC01MzYnOiAweGIzYTMsXG4gICdza2VpbjEwMjQtNTQ0JzogMHhiM2E0LFxuICAnc2tlaW4xMDI0LTU1Mic6IDB4YjNhNSxcbiAgJ3NrZWluMTAyNC01NjAnOiAweGIzYTYsXG4gICdza2VpbjEwMjQtNTY4JzogMHhiM2E3LFxuICAnc2tlaW4xMDI0LTU3Nic6IDB4YjNhOCxcbiAgJ3NrZWluMTAyNC01ODQnOiAweGIzYTksXG4gICdza2VpbjEwMjQtNTkyJzogMHhiM2FhLFxuICAnc2tlaW4xMDI0LTYwMCc6IDB4YjNhYixcbiAgJ3NrZWluMTAyNC02MDgnOiAweGIzYWMsXG4gICdza2VpbjEwMjQtNjE2JzogMHhiM2FkLFxuICAnc2tlaW4xMDI0LTYyNCc6IDB4YjNhZSxcbiAgJ3NrZWluMTAyNC02MzInOiAweGIzYWYsXG4gICdza2VpbjEwMjQtNjQwJzogMHhiM2IwLFxuICAnc2tlaW4xMDI0LTY0OCc6IDB4YjNiMSxcbiAgJ3NrZWluMTAyNC02NTYnOiAweGIzYjIsXG4gICdza2VpbjEwMjQtNjY0JzogMHhiM2IzLFxuICAnc2tlaW4xMDI0LTY3Mic6IDB4YjNiNCxcbiAgJ3NrZWluMTAyNC02ODAnOiAweGIzYjUsXG4gICdza2VpbjEwMjQtNjg4JzogMHhiM2I2LFxuICAnc2tlaW4xMDI0LTY5Nic6IDB4YjNiNyxcbiAgJ3NrZWluMTAyNC03MDQnOiAweGIzYjgsXG4gICdza2VpbjEwMjQtNzEyJzogMHhiM2I5LFxuICAnc2tlaW4xMDI0LTcyMCc6IDB4YjNiYSxcbiAgJ3NrZWluMTAyNC03MjgnOiAweGIzYmIsXG4gICdza2VpbjEwMjQtNzM2JzogMHhiM2JjLFxuICAnc2tlaW4xMDI0LTc0NCc6IDB4YjNiZCxcbiAgJ3NrZWluMTAyNC03NTInOiAweGIzYmUsXG4gICdza2VpbjEwMjQtNzYwJzogMHhiM2JmLFxuICAnc2tlaW4xMDI0LTc2OCc6IDB4YjNjMCxcbiAgJ3NrZWluMTAyNC03NzYnOiAweGIzYzEsXG4gICdza2VpbjEwMjQtNzg0JzogMHhiM2MyLFxuICAnc2tlaW4xMDI0LTc5Mic6IDB4YjNjMyxcbiAgJ3NrZWluMTAyNC04MDAnOiAweGIzYzQsXG4gICdza2VpbjEwMjQtODA4JzogMHhiM2M1LFxuICAnc2tlaW4xMDI0LTgxNic6IDB4YjNjNixcbiAgJ3NrZWluMTAyNC04MjQnOiAweGIzYzcsXG4gICdza2VpbjEwMjQtODMyJzogMHhiM2M4LFxuICAnc2tlaW4xMDI0LTg0MCc6IDB4YjNjOSxcbiAgJ3NrZWluMTAyNC04NDgnOiAweGIzY2EsXG4gICdza2VpbjEwMjQtODU2JzogMHhiM2NiLFxuICAnc2tlaW4xMDI0LTg2NCc6IDB4YjNjYyxcbiAgJ3NrZWluMTAyNC04NzInOiAweGIzY2QsXG4gICdza2VpbjEwMjQtODgwJzogMHhiM2NlLFxuICAnc2tlaW4xMDI0LTg4OCc6IDB4YjNjZixcbiAgJ3NrZWluMTAyNC04OTYnOiAweGIzZDAsXG4gICdza2VpbjEwMjQtOTA0JzogMHhiM2QxLFxuICAnc2tlaW4xMDI0LTkxMic6IDB4YjNkMixcbiAgJ3NrZWluMTAyNC05MjAnOiAweGIzZDMsXG4gICdza2VpbjEwMjQtOTI4JzogMHhiM2Q0LFxuICAnc2tlaW4xMDI0LTkzNic6IDB4YjNkNSxcbiAgJ3NrZWluMTAyNC05NDQnOiAweGIzZDYsXG4gICdza2VpbjEwMjQtOTUyJzogMHhiM2Q3LFxuICAnc2tlaW4xMDI0LTk2MCc6IDB4YjNkOCxcbiAgJ3NrZWluMTAyNC05NjgnOiAweGIzZDksXG4gICdza2VpbjEwMjQtOTc2JzogMHhiM2RhLFxuICAnc2tlaW4xMDI0LTk4NCc6IDB4YjNkYixcbiAgJ3NrZWluMTAyNC05OTInOiAweGIzZGMsXG4gICdza2VpbjEwMjQtMTAwMCc6IDB4YjNkZCxcbiAgJ3NrZWluMTAyNC0xMDA4JzogMHhiM2RlLFxuICAnc2tlaW4xMDI0LTEwMTYnOiAweGIzZGYsXG4gICdza2VpbjEwMjQtMTAyNCc6IDB4YjNlMCxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEnOiAweGI0MDEsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxLXNjJzogMHhiNDAyLFxuICAnemVyb3hjZXJ0LWltcHJpbnQtMjU2JzogMHhjZTExLFxuICAnZmlsLWNvbW1pdG1lbnQtdW5zZWFsZWQnOiAweGYxMDEsXG4gICdmaWwtY29tbWl0bWVudC1zZWFsZWQnOiAweGYxMDIsXG4gICdob2xvY2hhaW4tYWRyLXYwJzogMHg4MDcxMjQsXG4gICdob2xvY2hhaW4tYWRyLXYxJzogMHg4MTcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYwJzogMHg5NDcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYxJzogMHg5NTcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYwJzogMHhhMjcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYxJzogMHhhMzcxMjQsXG4gICdza3luZXQtbnMnOiAweGIxOTkxMFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IGJhc2VUYWJsZSB9XG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBtdWx0aWNvZGVjIHNwZWNpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBtdWx0aWNvZGVjXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuICpcbiAqIGNvbnN0IHByZWZpeGVkUHJvdG9idWYgPSBtdWx0aWNvZGVjLmFkZFByZWZpeCgncHJvdG9idWYnLCBwcm90b2J1ZkJ1ZmZlcilcbiAqIC8vIHByZWZpeGVkUHJvdG9idWYgMHg1MC4uLlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjQ29kZX0gQ29kZWNDb2RlICovXG5cbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCB1aW50OEFycmF5Q29uY2F0ID0gcmVxdWlyZSgndWludDhhcnJheXMvY29uY2F0JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBuYW1lVG9WYXJpbnQsIGNvbnN0YW50VG9Db2RlLCBuYW1lVG9Db2RlLCBjb2RlVG9OYW1lIH0gPSByZXF1aXJlKCcuL21hcHMnKVxuXG4vKipcbiAqIFByZWZpeCBhIGJ1ZmZlciB3aXRoIGEgbXVsdGljb2RlYy1wYWNrZWQuXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV8VWludDhBcnJheX0gbXVsdGljb2RlY1N0ck9yQ29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gYWRkUHJlZml4IChtdWx0aWNvZGVjU3RyT3JDb2RlLCBkYXRhKSB7XG4gIGxldCBwcmVmaXhcblxuICBpZiAobXVsdGljb2RlY1N0ck9yQ29kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBwcmVmaXggPSB1dGlsLnZhcmludFVpbnQ4QXJyYXlFbmNvZGUobXVsdGljb2RlY1N0ck9yQ29kZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAobmFtZVRvVmFyaW50W211bHRpY29kZWNTdHJPckNvZGVdKSB7XG4gICAgICBwcmVmaXggPSBuYW1lVG9WYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWNvZGVjIG5vdCByZWNvZ25pemVkJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbcHJlZml4LCBkYXRhXSwgcHJlZml4Lmxlbmd0aCArIGRhdGEubGVuZ3RoKVxufVxuXG4vKipcbiAqIERlY2Fwc3VsYXRlIHRoZSBtdWx0aWNvZGVjLXBhY2tlZCBwcmVmaXggZnJvbSB0aGUgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBybVByZWZpeCAoZGF0YSkge1xuICB2YXJpbnQuZGVjb2RlKC8qKiBAdHlwZSB7QnVmZmVyfSAqLyhkYXRhKSlcbiAgcmV0dXJuIGRhdGEuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGVjIG5hbWUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV9XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWVGcm9tRGF0YSAocHJlZml4ZWREYXRhKSB7XG4gIGNvbnN0IGNvZGUgPSAvKiogQHR5cGUge0NvZGVjQ29kZX0gKi8odmFyaW50LmRlY29kZSgvKiogQHR5cGUge0J1ZmZlcn0gKi8ocHJlZml4ZWREYXRhKSkpXG4gIGNvbnN0IG5hbWUgPSBjb2RlVG9OYW1lW2NvZGVdXG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGUgXCIke2NvZGV9XCIgbm90IGZvdW5kYClcbiAgfVxuICByZXR1cm4gbmFtZVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZWMgbmFtZSBmcm9tIGEgY29kZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjQ29kZX0gY29kZWNcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV9XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWVGcm9tQ29kZSAoY29kZWMpIHtcbiAgcmV0dXJuIGNvZGVUb05hbWVbY29kZWNdXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBjb2RlY1xuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBuYW1lXG4gKiBAcmV0dXJucyB7Q29kZWNDb2RlfVxuICovXG5mdW5jdGlvbiBnZXRDb2RlRnJvbU5hbWUgKG5hbWUpIHtcbiAgY29uc3QgY29kZSA9IG5hbWVUb0NvZGVbbmFtZV1cbiAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29kZWMgXCIke25hbWV9XCIgbm90IGZvdW5kYClcbiAgfVxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjQ29kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZUZyb21EYXRhIChwcmVmaXhlZERhdGEpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZSB7Q29kZWNDb2RlfSAqLyh2YXJpbnQuZGVjb2RlKC8qKiBAdHlwZSB7QnVmZmVyfSAqLyhwcmVmaXhlZERhdGEpKSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgYXMgdmFyaW50IG9mIGEgY29kZWMgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gbmFtZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldFZhcmludEZyb21OYW1lIChuYW1lKSB7XG4gIGNvbnN0IGNvZGUgPSBuYW1lVG9WYXJpbnRbbmFtZV1cbiAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29kZWMgXCIke25hbWV9XCIgbm90IGZvdW5kYClcbiAgfVxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFyaW50IG9mIGEgY29kZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjQ29kZX0gY29kZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldFZhcmludEZyb21Db2RlIChjb2RlKSB7XG4gIHJldHVybiB1dGlsLnZhcmludEVuY29kZShjb2RlKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZWMgbmFtZSBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZ2V0TmFtZUZyb21EYXRhIGluc3RlYWQuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjTmFtZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZWMgKHByZWZpeGVkRGF0YSkge1xuICByZXR1cm4gZ2V0TmFtZUZyb21EYXRhKHByZWZpeGVkRGF0YSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGVjIG5hbWUgZnJvbSBhIGNvZGUuXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIGdldE5hbWVGcm9tQ29kZSBpbnN0ZWFkLlxuICogQHBhcmFtIHtDb2RlY0NvZGV9IGNvZGVjXG4gKiBAcmV0dXJucyB7Q29kZWNOYW1lfVxuICovXG5mdW5jdGlvbiBnZXROYW1lIChjb2RlYykge1xuICByZXR1cm4gZ2V0TmFtZUZyb21Db2RlKGNvZGVjKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgY29kZWNcbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZ2V0Q29kZUZyb21OYW1lIGluc3RlYWQuXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gbmFtZVxuICogQHJldHVybnMge0NvZGVjQ29kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TnVtYmVyIChuYW1lKSB7XG4gIHJldHVybiBnZXRDb2RlRnJvbU5hbWUobmFtZSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIGdldENvZGVGcm9tRGF0YSBpbnN0ZWFkLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY0NvZGV9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGUgKHByZWZpeGVkRGF0YSkge1xuICByZXR1cm4gZ2V0Q29kZUZyb21EYXRhKHByZWZpeGVkRGF0YSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgYXMgdmFyaW50IG9mIGEgY29kZWMgbmFtZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZ2V0VmFyaW50RnJvbU5hbWUgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBuYW1lXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZVZhcmludCAobmFtZSkge1xuICByZXR1cm4gZ2V0VmFyaW50RnJvbU5hbWUobmFtZSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhcmludCBvZiBhIGNvZGUuXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIGdldFZhcmludEZyb21Db2RlIGluc3RlYWQuXG4gKiBAcGFyYW0ge0NvZGVjQ29kZX0gY29kZVxuICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICovXG5mdW5jdGlvbiBnZXRWYXJpbnQgKGNvZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZ2V0VmFyaW50RnJvbUNvZGUoY29kZSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRQcmVmaXgsXG4gIHJtUHJlZml4LFxuICBnZXROYW1lRnJvbURhdGEsXG4gIGdldE5hbWVGcm9tQ29kZSxcbiAgZ2V0Q29kZUZyb21OYW1lLFxuICBnZXRDb2RlRnJvbURhdGEsXG4gIGdldFZhcmludEZyb21OYW1lLFxuICBnZXRWYXJpbnRGcm9tQ29kZSxcbiAgLy8gRGVwcmVjYXRlZFxuICBnZXRDb2RlYyxcbiAgZ2V0TmFtZSxcbiAgZ2V0TnVtYmVyLFxuICBnZXRDb2RlLFxuICBnZXRDb2RlVmFyaW50LFxuICBnZXRWYXJpbnQsXG4gIC8vIE1ha2UgdGhlIGNvbnN0YW50cyB0b3AtbGV2ZWwgY29uc3RhbnRzXG4gIC4uLmNvbnN0YW50VG9Db2RlLFxuICAvLyBFeHBvcnQgdGhlIG1hcHNcbiAgbmFtZVRvVmFyaW50LFxuICBuYW1lVG9Db2RlLFxuICBjb2RlVG9OYW1lXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvbnN0YW50Q29kZU1hcH0gQ29uc3RhbnRDb2RlTWFwICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuTmFtZVVpbnQ4QXJyYXlNYXB9IE5hbWVVaW50OEFycmF5TWFwICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZU5hbWVNYXB9IENvZGVOYW1lTWFwICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY0NvbnN0YW50fSBDb2RlY0NvbnN0YW50ICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2dlbmVyYXRlZC10YWJsZScpXG5jb25zdCB2YXJpbnRFbmNvZGUgPSByZXF1aXJlKCcuL3V0aWwnKS52YXJpbnRFbmNvZGVcblxuY29uc3QgbmFtZVRvVmFyaW50ID0gLyoqIEB0eXBlIHtOYW1lVWludDhBcnJheU1hcH0gKi8gKHt9KVxuY29uc3QgY29uc3RhbnRUb0NvZGUgPSAvKiogQHR5cGUge0NvbnN0YW50Q29kZU1hcH0gKi8oe30pXG5jb25zdCBjb2RlVG9OYW1lID0gLyoqIEB0eXBlIHtDb2RlTmFtZU1hcH0gKi8oe30pXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbmZvciAoY29uc3QgbmFtZSBpbiBiYXNlVGFibGUpIHtcbiAgY29uc3QgY29kZWNOYW1lID0gLyoqIEB0eXBlIHtDb2RlY05hbWV9ICovKG5hbWUpXG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbY29kZWNOYW1lXVxuICBuYW1lVG9WYXJpbnRbY29kZWNOYW1lXSA9IHZhcmludEVuY29kZShjb2RlKVxuXG4gIGNvbnN0IGNvbnN0YW50ID0gLyoqIEB0eXBlIHtDb2RlY0NvbnN0YW50fSAqLyhjb2RlY05hbWUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJykpXG4gIGNvbnN0YW50VG9Db2RlW2NvbnN0YW50XSA9IGNvZGVcblxuICBpZiAoIWNvZGVUb05hbWVbY29kZV0pIHtcbiAgICBjb2RlVG9OYW1lW2NvZGVdID0gY29kZWNOYW1lXG4gIH1cbn1cblxuT2JqZWN0LmZyZWV6ZShuYW1lVG9WYXJpbnQpXG5PYmplY3QuZnJlZXplKGNvbnN0YW50VG9Db2RlKVxuT2JqZWN0LmZyZWV6ZShjb2RlVG9OYW1lKVxuY29uc3QgbmFtZVRvQ29kZSA9IE9iamVjdC5mcmVlemUoYmFzZVRhYmxlKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVUb1ZhcmludCxcbiAgY29uc3RhbnRUb0NvZGUsXG4gIG5hbWVUb0NvZGUsXG4gIGNvZGVUb05hbWVcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgdWludDhBcnJheVRvU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcbmNvbnN0IHVpbnQ4QXJyYXlGcm9tU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnVtYmVyVG9VaW50OEFycmF5LFxuICB1aW50OEFycmF5VG9OdW1iZXIsXG4gIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUsXG4gIHZhcmludEVuY29kZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb051bWJlciAoYnVmKSB7XG4gIHJldHVybiBwYXJzZUludCh1aW50OEFycmF5VG9TdHJpbmcoYnVmLCAnYmFzZTE2JyksIDE2KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9VaW50OEFycmF5IChudW0pIHtcbiAgbGV0IGhleFN0cmluZyA9IG51bS50b1N0cmluZygxNilcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgaGV4U3RyaW5nID0gJzAnICsgaGV4U3RyaW5nXG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGhleFN0cmluZywgJ2Jhc2UxNicpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICovXG5mdW5jdGlvbiB2YXJpbnRVaW50OEFycmF5RW5jb2RlIChpbnB1dCkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUodWludDhBcnJheVRvTnVtYmVyKGlucHV0KSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5mdW5jdGlvbiB2YXJpbnRFbmNvZGUgKG51bSkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUobnVtKSlcbn1cbiIsIi8vIFRoaXMgZmlsZSByZXBsYWNlcyBgaW5kZXguanNgIGluIGJ1bmRsZXJzIGxpa2Ugd2VicGFjayBvciBSb2xsdXAsXG4vLyBhY2NvcmRpbmcgdG8gYGJyb3dzZXJgIGNvbmZpZyBpbiBgcGFja2FnZS5qc29uYC5cblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIEFsbCBidW5kbGVycyB3aWxsIHJlbW92ZSB0aGlzIGJsb2NrIGluIHByb2R1Y3Rpb24gYnVuZGxlXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdSZWFjdCBOYXRpdmUgZG9lcyBub3QgaGF2ZSBhIGJ1aWx0LWluIHNlY3VyZSByYW5kb20gZ2VuZXJhdG9yLiAnICtcbiAgICAgICdJZiB5b3UgZG9u4oCZdCBuZWVkIHVucHJlZGljdGFibGUgSURzLCB5b3UgY2FuIHVzZSBgbmFub2lkL25vbi1zZWN1cmVgLiAnICtcbiAgICAgICdGb3Igc2VjdXJlIElEIGluc3RhbGwgYGV4cG8tcmFuZG9tYCBsb2NhbGx5IGFuZCB1c2UgYG5hbm9pZC9hc3luY2AuJ1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8ICghc2VsZi5jcnlwdG8gJiYgIXNlbGYubXNDcnlwdG8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1lvdXIgYnJvd3NlciBkb2VzIG5vdCBoYXZlIHNlY3VyZSByYW5kb20gZ2VuZXJhdG9yLiAnICtcbiAgICAgICdJZiB5b3UgZG9u4oCZdCBuZWVkIHVucHJlZGljdGFibGUgSURzLCB5b3UgY2FuIHVzZSBuYW5vaWQvbm9uLXNlY3VyZS4nXG4gICAgKVxuICB9XG59XG5cbnZhciBjcnlwdG8gPSBzZWxmLmNyeXB0byB8fCBzZWxmLm1zQ3J5cHRvXG5cbi8vIFRoaXMgYWxwaGFiZXQgdXNlcyBhLXogQS1aIDAtOSBfLSBzeW1ib2xzLlxuLy8gU3ltYm9scyBhcmUgZ2VuZXJhdGVkIGZvciBzbWFsbGVyIHNpemUuXG4vLyAtX3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhOTg3NjU0MzIxMFpZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBXG52YXIgdXJsID0gJy1fJ1xuLy8gTG9vcCBmcm9tIDM2IHRvIDAgKGZyb20geiB0byBhIGFuZCA5IHRvIDAgaW4gQmFzZTM2KS5cbnZhciBpID0gMzZcbndoaWxlIChpLS0pIHtcbiAgLy8gMzYgaXMgcmFkaXguIE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcoMzYpIHJldHVybnMgbnVtYmVyXG4gIC8vIGluIEJhc2UzNiByZXByZXNlbnRhdGlvbi4gQmFzZTM2IGlzIGxpa2UgaGV4LCBidXQgaXQgdXNlcyAw4oCTOSBhbmQgYS16LlxuICB1cmwgKz0gaS50b1N0cmluZygzNilcbn1cbi8vIExvb3AgZnJvbSAzNiB0byAxMCAoZnJvbSBaIHRvIEEgaW4gQmFzZTM2KS5cbmkgPSAzNlxud2hpbGUgKGktLSAtIDEwKSB7XG4gIHVybCArPSBpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgdmFyIGlkID0gJydcbiAgdmFyIGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplIHx8IDIxKSlcbiAgaSA9IHNpemUgfHwgMjFcblxuICAvLyBDb21wYWN0IGFsdGVybmF0aXZlIGZvciBgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspYFxuICB3aGlsZSAoaS0tKSB7XG4gICAgLy8gV2UgY2Fu4oCZdCB1c2UgYnl0ZXMgYmlnZ2VyIHRoYW4gdGhlIGFscGhhYmV0LiA2MyBpcyAwMDExMTExMSBiaXRtYXNrLlxuICAgIC8vIFRoaXMgbWFzayByZWR1Y2VzIHJhbmRvbSBieXRlIDAtMjU1IHRvIDAtNjMgdmFsdWVzLlxuICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgaW4gYHx8ICcnYCBhbmQgYCogMS42YCBoYWNrcyBpbiBoZXJlLFxuICAgIC8vIGJlY2F1c2UgYml0bWFzayB0cmltIGJ5dGVzIGV4YWN0IHRvIGFscGhhYmV0IHNpemUuXG4gICAgaWQgKz0gdXJsW2J5dGVzW2ldICYgNjNdXG4gIH1cbiAgcmV0dXJuIGlkXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuXHQvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0Ly8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG5cdGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cblx0dGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbE9iamVjdCA9IGdldEdsb2JhbCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBnbG9iYWxPYmplY3QuZmV0Y2g7XG5cbi8vIE5lZWRlZCBmb3IgVHlwZVNjcmlwdCBhbmQgV2VicGFjay5cbmlmIChnbG9iYWxPYmplY3QuZmV0Y2gpIHtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsT2JqZWN0LmZldGNoLmJpbmQoZ2xvYmFsT2JqZWN0KTtcbn1cblxuZXhwb3J0cy5IZWFkZXJzID0gZ2xvYmFsT2JqZWN0LkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBnbG9iYWxPYmplY3QuUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBnbG9iYWxPYmplY3QuUmVzcG9uc2U7XG4iLCJjb25zdCBFdGhRdWVyeSA9IHJlcXVpcmUoJ2V0aGpzLXF1ZXJ5JylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBNdXRleCA9IHJlcXVpcmUoJ2F3YWl0LXNlbWFwaG9yZScpLk11dGV4XG4vKipcbiAgQHBhcmFtIG9wdHMge09iamVjdH1cbiAgICBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm92aWRlciBhIGV0aGVyZXVtIHByb3ZpZGVyXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIHR4TWV0YVxuICAgIHdob3NlZSBzdGF0dXMgaXMgYHN1Ym1pdHRlZGBcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmdldENvbmZpcm1lZFRyYW5zYWN0aW9ucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZiB0eE1ldGFcbiAgICB3aG9zZSBzdGF0dXMgaXMgYGNvbmZpcm1lZGBcbiAgQGNsYXNzXG4qL1xuY2xhc3MgTm9uY2VUcmFja2VyIHtcblxuICBjb25zdHJ1Y3RvciAoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyLCBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zLCBnZXRDb25maXJtZWRUcmFuc2FjdGlvbnMgfSkge1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlclxuICAgIHRoaXMuYmxvY2tUcmFja2VyID0gYmxvY2tUcmFja2VyXG4gICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBFdGhRdWVyeShwcm92aWRlcilcbiAgICB0aGlzLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMgPSBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zXG4gICAgdGhpcy5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMgPSBnZXRDb25maXJtZWRUcmFuc2FjdGlvbnNcbiAgICB0aGlzLmxvY2tNYXAgPSB7fVxuICB9XG5cbiAgLyoqXG4gICAgQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gd2l0aCB0aGUga2V5IHJlbGVhc2VMb2NrICh0aGUgZ2xvYWJsIG11dGV4KVxuICAqL1xuICBhc3luYyBnZXRHbG9iYWxMb2NrICgpIHtcbiAgICBjb25zdCBnbG9iYWxNdXRleCA9IHRoaXMuX2xvb2t1cE11dGV4KCdnbG9iYWwnKVxuICAgIC8vIGF3YWl0IGdsb2JhbCBtdXRleCBmcmVlXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCBnbG9iYWxNdXRleC5hY3F1aXJlKClcbiAgICByZXR1cm4geyByZWxlYXNlTG9jayB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgTm9uY2VEZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZCAtIEEgaGV4IHN0cmluZyBvZiB0aGUgaGlnaGVzdCBub25jZSBvbiBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvbi5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5leHROZXR3b3JrTm9uY2UgLSBUaGUgbmV4dCBub25jZSBzdWdnZXN0ZWQgYnkgdGhlIGV0aF9nZXRUcmFuc2FjdGlvbkNvdW50IG1ldGhvZC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2hlc3RTdWdnZXN0ZWQgLSBUaGUgbWF4aW11bSBiZXR3ZWVuIHRoZSBvdGhlciB0d28sIHRoZSBudW1iZXIgcmV0dXJuZWQuXG4gICAqL1xuXG4gIC8qKlxuICB0aGlzIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBgbmV4dE5vbmNlYCBgbm9uY2VEZXRhaWxzYCwgYW5kIHRoZSByZWxlYXNlTG9ja1xuICBOb3RlOiByZWxlYXNlTG9jayBtdXN0IGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgYSBzaWduZWQgdHggdG8gcGVuZGluZyB0cmFuc2FjdGlvbnMgKG9yIGRpc2NhcmRpbmcpLlxuXG4gIEBwYXJhbSBhZGRyZXNzIHtzdHJpbmd9IHRoZSBoZXggc3RyaW5nIGZvciB0aGUgYWRkcmVzcyB3aG9zZSBub25jZSB3ZSBhcmUgY2FsY3VsYXRpbmdcbiAgQHJldHVybnMge1Byb21pc2U8Tm9uY2VEZXRhaWxzPn1cbiAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2VMb2NrIChhZGRyZXNzKSB7XG4gICAgLy8gYXdhaXQgZ2xvYmFsIG11dGV4IGZyZWVcbiAgICBhd2FpdCB0aGlzLl9nbG9iYWxNdXRleEZyZWUoKVxuICAgIC8vIGF3YWl0IGxvY2sgZnJlZSwgdGhlbiB0YWtlIGxvY2tcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IHRoaXMuX3Rha2VNdXRleChhZGRyZXNzKVxuICAgIHRyeSB7XG4gICAgICAvLyBldmFsdWF0ZSBtdWx0aXBsZSBuZXh0Tm9uY2Ugc3RyYXRlZ2llc1xuICAgICAgY29uc3Qgbm9uY2VEZXRhaWxzID0ge31cbiAgICAgIGNvbnN0IG5ldHdvcmtOb25jZVJlc3VsdCA9IGF3YWl0IHRoaXMuX2dldE5ldHdvcmtOZXh0Tm9uY2UoYWRkcmVzcylcbiAgICAgIGNvbnN0IGhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkID0gdGhpcy5fZ2V0SGlnaGVzdExvY2FsbHlDb25maXJtZWQoYWRkcmVzcylcbiAgICAgIGNvbnN0IG5leHROZXR3b3JrTm9uY2UgPSBuZXR3b3JrTm9uY2VSZXN1bHQubm9uY2VcbiAgICAgIGNvbnN0IGhpZ2hlc3RTdWdnZXN0ZWQgPSBNYXRoLm1heChuZXh0TmV0d29ya05vbmNlLCBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZClcblxuICAgICAgY29uc3QgcGVuZGluZ1R4cyA9IHRoaXMuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyhhZGRyZXNzKVxuICAgICAgY29uc3QgbG9jYWxOb25jZVJlc3VsdCA9IHRoaXMuX2dldEhpZ2hlc3RDb250aW51b3VzRnJvbShwZW5kaW5nVHhzLCBoaWdoZXN0U3VnZ2VzdGVkKSB8fCAwXG5cbiAgICAgIG5vbmNlRGV0YWlscy5wYXJhbXMgPSB7XG4gICAgICAgIGhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkLFxuICAgICAgICBoaWdoZXN0U3VnZ2VzdGVkLFxuICAgICAgICBuZXh0TmV0d29ya05vbmNlLFxuICAgICAgfVxuICAgICAgbm9uY2VEZXRhaWxzLmxvY2FsID0gbG9jYWxOb25jZVJlc3VsdFxuICAgICAgbm9uY2VEZXRhaWxzLm5ldHdvcmsgPSBuZXR3b3JrTm9uY2VSZXN1bHRcblxuICAgICAgY29uc3QgbmV4dE5vbmNlID0gTWF0aC5tYXgobmV0d29ya05vbmNlUmVzdWx0Lm5vbmNlLCBsb2NhbE5vbmNlUmVzdWx0Lm5vbmNlKVxuICAgICAgYXNzZXJ0KE51bWJlci5pc0ludGVnZXIobmV4dE5vbmNlKSwgYG5vbmNlLXRyYWNrZXIgLSBuZXh0Tm9uY2UgaXMgbm90IGFuIGludGVnZXIgLSBnb3Q6ICgke3R5cGVvZiBuZXh0Tm9uY2V9KSBcIiR7bmV4dE5vbmNlfVwiYClcblxuICAgICAgLy8gcmV0dXJuIG5vbmNlIGFuZCByZWxlYXNlIGNiXG4gICAgICByZXR1cm4geyBuZXh0Tm9uY2UsIG5vbmNlRGV0YWlscywgcmVsZWFzZUxvY2sgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gcmVsZWFzZSBsb2NrIGlmIHdlIGVuY291bnRlciBhbiBlcnJvclxuICAgICAgcmVsZWFzZUxvY2soKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2dsb2JhbE11dGV4RnJlZSAoKSB7XG4gICAgY29uc3QgZ2xvYmFsTXV0ZXggPSB0aGlzLl9sb29rdXBNdXRleCgnZ2xvYmFsJylcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IGdsb2JhbE11dGV4LmFjcXVpcmUoKVxuICAgIHJlbGVhc2VMb2NrKClcbiAgfVxuXG4gIGFzeW5jIF90YWtlTXV0ZXggKGxvY2tJZCkge1xuICAgIGNvbnN0IG11dGV4ID0gdGhpcy5fbG9va3VwTXV0ZXgobG9ja0lkKVxuICAgIGNvbnN0IHJlbGVhc2VMb2NrID0gYXdhaXQgbXV0ZXguYWNxdWlyZSgpXG4gICAgcmV0dXJuIHJlbGVhc2VMb2NrXG4gIH1cblxuICBfbG9va3VwTXV0ZXggKGxvY2tJZCkge1xuICAgIGxldCBtdXRleCA9IHRoaXMubG9ja01hcFtsb2NrSWRdXG4gICAgaWYgKCFtdXRleCkge1xuICAgICAgbXV0ZXggPSBuZXcgTXV0ZXgoKVxuICAgICAgdGhpcy5sb2NrTWFwW2xvY2tJZF0gPSBtdXRleFxuICAgIH1cbiAgICByZXR1cm4gbXV0ZXhcbiAgfVxuXG4gIGFzeW5jIF9nZXROZXR3b3JrTmV4dE5vbmNlIChhZGRyZXNzKSB7XG4gICAgLy8gY2FsY3VsYXRlIG5leHQgbm9uY2VcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBvdXIgYmFzZSBjb3VudFxuICAgIC8vIGFuZCBwZW5kaW5nIGNvdW50IGFyZSBmcm9tIHRoZSBzYW1lIGJsb2NrXG4gICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLmJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpXG4gICAgY29uc3QgYmFzZUNvdW50Qk4gPSBhd2FpdCB0aGlzLmV0aFF1ZXJ5LmdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tOdW1iZXIpXG4gICAgY29uc3QgYmFzZUNvdW50ID0gYmFzZUNvdW50Qk4udG9OdW1iZXIoKVxuICAgIGFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKGJhc2VDb3VudCksIGBub25jZS10cmFja2VyIC0gYmFzZUNvdW50IGlzIG5vdCBhbiBpbnRlZ2VyIC0gZ290OiAoJHt0eXBlb2YgYmFzZUNvdW50fSkgXCIke2Jhc2VDb3VudH1cImApXG4gICAgY29uc3Qgbm9uY2VEZXRhaWxzID0geyBibG9ja051bWJlciwgYmFzZUNvdW50IH1cbiAgICByZXR1cm4geyBuYW1lOiAnbmV0d29yaycsIG5vbmNlOiBiYXNlQ291bnQsIGRldGFpbHM6IG5vbmNlRGV0YWlscyB9XG4gIH1cblxuICBfZ2V0SGlnaGVzdExvY2FsbHlDb25maXJtZWQgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjb25maXJtZWRUcmFuc2FjdGlvbnMgPSB0aGlzLmdldENvbmZpcm1lZFRyYW5zYWN0aW9ucyhhZGRyZXNzKVxuICAgIGNvbnN0IGhpZ2hlc3QgPSB0aGlzLl9nZXRIaWdoZXN0Tm9uY2UoY29uZmlybWVkVHJhbnNhY3Rpb25zKVxuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGhpZ2hlc3QpID8gaGlnaGVzdCArIDEgOiAwXG4gIH1cblxuICBfZ2V0SGlnaGVzdE5vbmNlICh0eExpc3QpIHtcbiAgICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGNvbnN0IG5vbmNlID0gdHhNZXRhLnR4UGFyYW1zLm5vbmNlXG4gICAgICBhc3NlcnQodHlwZW9mIG5vbmNlLCAnc3RyaW5nJywgJ25vbmNlcyBzaG91bGQgYmUgaGV4IHN0cmluZ3MnKVxuICAgICAgcmV0dXJuIHBhcnNlSW50KG5vbmNlLCAxNilcbiAgICB9KVxuICAgIGNvbnN0IGhpZ2hlc3ROb25jZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG5vbmNlcylcbiAgICByZXR1cm4gaGlnaGVzdE5vbmNlXG4gIH1cblxuICAvKipcbiAgICBAdHlwZWRlZiB7b2JqZWN0fSBoaWdoZXN0Q29udGludW91c0Zyb21cbiAgICBAcHJvcGVydHkge3N0cmluZ30gLSBuYW1lIHRoZSBuYW1lIGZvciBob3cgdGhlIG5vbmNlIHdhcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkYXRhIHVzZWRcbiAgICBAcHJvcGVydHkge251bWJlcn0gLSBub25jZSB0aGUgbmV4dCBzdWdnZXN0ZWQgbm9uY2VcbiAgICBAcHJvcGVydHkge29iamVjdH0gLSBkZXRhaWxzIHRoZSBwcm92aWRlZCBzdGFydGluZyBub25jZSB0aGF0IHdhcyB1c2VkIChmb3IgZGVidWdnaW5nKVxuICAqL1xuICAvKipcbiAgICBAcGFyYW0gdHhMaXN0IHthcnJheX0gLSBsaXN0IG9mIHR4TWV0YSdzXG4gICAgQHBhcmFtIHN0YXJ0UG9pbnQge251bWJlcn0gLSB0aGUgaGlnaGVzdCBrbm93biBsb2NhbGx5IGNvbmZpcm1lZCBub25jZVxuICAgIEByZXR1cm5zIHtoaWdoZXN0Q29udGludW91c0Zyb219XG4gICovXG4gIF9nZXRIaWdoZXN0Q29udGludW91c0Zyb20gKHR4TGlzdCwgc3RhcnRQb2ludCkge1xuICAgIGNvbnN0IG5vbmNlcyA9IHR4TGlzdC5tYXAoKHR4TWV0YSkgPT4ge1xuICAgICAgY29uc3Qgbm9uY2UgPSB0eE1ldGEudHhQYXJhbXMubm9uY2VcbiAgICAgIGFzc2VydCh0eXBlb2Ygbm9uY2UsICdzdHJpbmcnLCAnbm9uY2VzIHNob3VsZCBiZSBoZXggc3RyaW5ncycpXG4gICAgICByZXR1cm4gcGFyc2VJbnQobm9uY2UsIDE2KVxuICAgIH0pXG5cbiAgICBsZXQgaGlnaGVzdCA9IHN0YXJ0UG9pbnRcbiAgICB3aGlsZSAobm9uY2VzLmluY2x1ZGVzKGhpZ2hlc3QpKSB7XG4gICAgICBoaWdoZXN0KytcbiAgICB9XG5cbiAgICByZXR1cm4geyBuYW1lOiAnbG9jYWwnLCBub25jZTogaGlnaGVzdCwgZGV0YWlsczogeyBzdGFydFBvaW50LCBoaWdoZXN0IH0gfVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb25jZVRyYWNrZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5jb25zdCBTYWZlRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnc2FmZS1ldmVudC1lbWl0dGVyJylcblxuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKGluaXRTdGF0ZSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIC8vIHNldCBpbml0IHN0YXRlXG4gICAgdGhpcy5fc3RhdGUgPSBpbml0U3RhdGVcbiAgfVxuXG4gIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIGdldFN0YXRlXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKVxuICB9XG4gIFxuICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBwdXRTdGF0ZVxuICBwdXRTdGF0ZSAobmV3U3RhdGUpIHtcbiAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSlcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ld1N0YXRlKVxuICB9XG5cbiAgdXBkYXRlU3RhdGUgKHBhcnRpYWxTdGF0ZSkge1xuICAgIC8vIGlmIG5vbi1udWxsIG9iamVjdCwgbWVyZ2VcbiAgICBpZiAocGFydGlhbFN0YXRlICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgcGFydGlhbFN0YXRlKVxuICAgICAgdGhpcy5wdXRTdGF0ZShuZXdTdGF0ZSlcbiAgICAvLyBpZiBub3Qgb2JqZWN0LCB1c2UgbmV3IHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzXG4gIHN1YnNjcmliZSAoaGFuZGxlcikge1xuICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpXG4gIH1cblxuICAvLyB1bnN1YnNjcmliZSB0byBjaGFuZ2VzXG4gIHVuc3Vic2NyaWJlIChoYW5kbGVyKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgaGFuZGxlcilcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgX2dldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVcbiAgfVxuXG4gIC8vIHdyaXRlIHRvIHBlcnNpc3RlbmNlXG4gIF9wdXRTdGF0ZSAobmV3U3RhdGUpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9ic2VydmFibGVTdG9yZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gKHN0ciwgb3B0cyA9IHt9KSA9PiB7XG4gIGlmICghc3RyKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgbyA9IHtcbiAgICBrZXk6IFtcbiAgICAgICdzb3VyY2UnLFxuICAgICAgJ3Byb3RvY29sJyxcbiAgICAgICdhdXRob3JpdHknLFxuICAgICAgJ3VzZXJJbmZvJyxcbiAgICAgICd1c2VyJyxcbiAgICAgICdwYXNzd29yZCcsXG4gICAgICAnaG9zdCcsXG4gICAgICAncG9ydCcsXG4gICAgICAncmVsYXRpdmUnLFxuICAgICAgJ3BhdGgnLFxuICAgICAgJ2RpcmVjdG9yeScsXG4gICAgICAnZmlsZScsXG4gICAgICAncXVlcnknLFxuICAgICAgJ2FuY2hvcidcbiAgICBdLFxuICAgIHE6IHtcbiAgICAgIG5hbWU6ICdxdWVyeUtleScsXG4gICAgICBwYXJzZXI6IC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZ1xuICAgIH0sXG4gICAgcGFyc2VyOiB7XG4gICAgICBzdHJpY3Q6IC9eKD86KFteOi8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOi8/I10qKSg/OjooXFxkKikpPykpPygoKCg/OltePyMvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS8sXG4gICAgICBsb29zZTogL14oPzooPyFbXjpAXSs6W146QC9dKkApKFteOi8/Iy5dKyk6KT8oPzpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOi8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyMvXSpcXC5bXj8jLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/Iy9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbSA9IG8ucGFyc2VyW29wdHMuc3RyaWN0TW9kZSA/ICdzdHJpY3QnIDogJ2xvb3NlJ10uZXhlYyhzdHIpXG4gIGNvbnN0IHVyaSA9IHt9XG4gIGxldCBpID0gMTRcblxuICB3aGlsZSAoaS0tKSB1cmlbby5rZXlbaV1dID0gbVtpXSB8fCAnJ1xuXG4gIHVyaVtvLnEubmFtZV0gPSB7fVxuICB1cmlbby5rZXlbMTJdXS5yZXBsYWNlKG8ucS5wYXJzZXIsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgaWYgKCQxKSB1cmlbby5xLm5hbWVdWyQxXSA9ICQyXG4gIH0pXG5cbiAgcmV0dXJuIHVyaVxufVxuIiwiLy8gbGlnaHQgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1saWdodFwiKTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogUnVudGltZSBtZXNzYWdlIGZyb20vdG8gcGxhaW4gb2JqZWN0IGNvbnZlcnRlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBjb252ZXJ0ZXIgPSBleHBvcnRzO1xuXG52YXIgRW51bSA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSBmcm9tT2JqZWN0IGNvbnZldGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCBwcm9wKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goZCVzKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBmb3IgKHZhciB2YWx1ZXMgPSBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzLCBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkICYmIHZhbHVlc1trZXlzW2ldXSA9PT0gZmllbGQudHlwZURlZmF1bHQpIGdlblxuICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImNhc2UlajpcIiwga2V5c1tpXSlcbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz0lalwiLCBwcm9wLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpO1xuICAgICAgICAgICAgfSBnZW5cbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBnZW5cbiAgICAgICAgICAgIChcImlmKHR5cGVvZiBkJXMhPT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAgICAgKFwibSVzPXR5cGVzWyVpXS5mcm9tT2JqZWN0KGQlcylcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzVW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPU51bWJlcihkJXMpXCIsIHByb3AsIHByb3ApOyAvLyBhbHNvIGNhdGNoZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzPj4+MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXN8MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgICAgICBpc1Vuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodXRpbC5Mb25nKVwiKVxuICAgICAgICAgICAgICAgICAgICAoXCIobSVzPXV0aWwuTG9uZy5mcm9tVmFsdWUoZCVzKSkudW5zaWduZWQ9JWpcIiwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwic3RyaW5nXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPXBhcnNlSW50KGQlcywxMClcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwibnVtYmVyXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJvYmplY3RcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9bmV3IHV0aWwuTG9uZ0JpdHMoZCVzLmxvdz4+PjAsZCVzLmhpZ2g+Pj4wKS50b051bWJlciglcylcIiwgcHJvcCwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZCA/IFwidHJ1ZVwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJ1dGlsLmJhc2U2NC5kZWNvZGUoZCVzLG0lcz11dGlsLm5ld0J1ZmZlcih1dGlsLmJhc2U2NC5sZW5ndGgoZCVzKSksMClcIiwgcHJvcCwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKGQlcy5sZW5ndGgpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1kJXNcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1TdHJpbmcoZCVzKVwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1Cb29sZWFuKGQlcylcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBkZWZhdWx0OiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGxhaW4gb2JqZWN0IHRvIHJ1bnRpbWUgbWVzc2FnZSBjb252ZXJ0ZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuY29udmVydGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBmaWVsZHMgPSBtdHlwZS5maWVsZHNBcnJheTtcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcImRcIl0sIG10eXBlLm5hbWUgKyBcIiRmcm9tT2JqZWN0XCIpXG4gICAgKFwiaWYoZCBpbnN0YW5jZW9mIHRoaXMuY3RvcilcIilcbiAgICAgICAgKFwicmV0dXJuIGRcIik7XG4gICAgaWYgKCFmaWVsZHMubGVuZ3RoKSByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG5ldyB0aGlzLmN0b3JcIik7XG4gICAgZ2VuXG4gICAgKFwidmFyIG09bmV3IHRoaXMuY3RvclwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHByb3AgICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxuICAgIChcImlmKGQlcyl7XCIsIHByb3ApXG4gICAgICAgIChcImlmKHR5cGVvZiBkJXMhPT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgIChcInRocm93IFR5cGVFcnJvciglailcIiwgZmllbGQuZnVsbE5hbWUgKyBcIjogb2JqZWN0IGV4cGVjdGVkXCIpXG4gICAgICAgIChcIm0lcz17fVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGtzPU9iamVjdC5rZXlzKGQlcyksaT0wO2k8a3MubGVuZ3RoOysraSl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wICsgXCJba3NbaV1dXCIpXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKGQlcyl7XCIsIHByb3ApXG4gICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KGQlcykpXCIsIHByb3ApXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IGFycmF5IGV4cGVjdGVkXCIpXG4gICAgICAgIChcIm0lcz1bXVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGQlcy5sZW5ndGg7KytpKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCAvKiBub3Qgc29ydGVkICovIGksIHByb3AgKyBcIltpXVwiKVxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBOb24tcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSkgZ2VuIC8vIG5vIG5lZWQgdG8gdGVzdCBmb3IgbnVsbC91bmRlZmluZWQgaWYgYW4gZW51bSAodXNlcyBzd2l0Y2gpXG4gICAgKFwiaWYoZCVzIT1udWxsKXtcIiwgcHJvcCk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wKTtcbiAgICAgICAgICAgIGlmICghKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKSBnZW5cbiAgICAoXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfSByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG1cIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgdG9PYmplY3QgY29udmVydGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcHJvcCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmVudW1zPT09U3RyaW5nP3R5cGVzWyVpXS52YWx1ZXNbbSVzXTptJXNcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCwgcHJvcCk7XG4gICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCJkJXM9dHlwZXNbJWldLnRvT2JqZWN0KG0lcyxvKVwiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXNVbnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOiBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmpzb24mJiFpc0Zpbml0ZShtJXMpP1N0cmluZyhtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgICAgICBpc1Vuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZih0eXBlb2YgbSVzPT09XFxcIm51bWJlclxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAoXCJlbHNlXCIpIC8vIExvbmctbGlrZVxuICAgICAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP3V0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtJXMpOm8ubG9uZ3M9PT1OdW1iZXI/bmV3IHV0aWwuTG9uZ0JpdHMobSVzLmxvdz4+PjAsbSVzLmhpZ2g+Pj4wKS50b051bWJlciglcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIGlzVW5zaWduZWQgPyBcInRydWVcIjogXCJcIiwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5ieXRlcz09PVN0cmluZz91dGlsLmJhc2U2NC5lbmNvZGUobSVzLDAsbSVzLmxlbmd0aCk6by5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9bSVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcnVudGltZSBtZXNzYWdlIHRvIHBsYWluIG9iamVjdCBjb252ZXJ0ZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuY29udmVydGVyLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGZpZWxkcyA9IG10eXBlLmZpZWxkc0FycmF5LnNsaWNlKCkuc29ydCh1dGlsLmNvbXBhcmVGaWVsZHNCeUlkKTtcbiAgICBpZiAoIWZpZWxkcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiB1dGlsLmNvZGVnZW4oKShcInJldHVybiB7fVwiKTtcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIiwgXCJvXCJdLCBtdHlwZS5uYW1lICsgXCIkdG9PYmplY3RcIilcbiAgICAoXCJpZighbylcIilcbiAgICAgICAgKFwibz17fVwiKVxuICAgIChcInZhciBkPXt9XCIpO1xuXG4gICAgdmFyIHJlcGVhdGVkRmllbGRzID0gW10sXG4gICAgICAgIG1hcEZpZWxkcyA9IFtdLFxuICAgICAgICBub3JtYWxGaWVsZHMgPSBbXSxcbiAgICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICghZmllbGRzW2ldLnBhcnRPZilcbiAgICAgICAgICAgICggZmllbGRzW2ldLnJlc29sdmUoKS5yZXBlYXRlZCA/IHJlcGVhdGVkRmllbGRzXG4gICAgICAgICAgICA6IGZpZWxkc1tpXS5tYXAgPyBtYXBGaWVsZHNcbiAgICAgICAgICAgIDogbm9ybWFsRmllbGRzKS5wdXNoKGZpZWxkc1tpXSk7XG5cbiAgICBpZiAocmVwZWF0ZWRGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8uYXJyYXlzfHxvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBlYXRlZEZpZWxkcy5sZW5ndGg7ICsraSkgZ2VuXG4gICAgICAgIChcImQlcz1bXVwiLCB1dGlsLnNhZmVQcm9wKHJlcGVhdGVkRmllbGRzW2ldLm5hbWUpKTtcbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWFwRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLm9iamVjdHN8fG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hcEZpZWxkcy5sZW5ndGg7ICsraSkgZ2VuXG4gICAgICAgIChcImQlcz17fVwiLCB1dGlsLnNhZmVQcm9wKG1hcEZpZWxkc1tpXS5uYW1lKSk7XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9ybWFsRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBub3JtYWxGaWVsZHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvcCAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIGdlblxuICAgICAgICAoXCJkJXM9by5lbnVtcz09PVN0cmluZz8lajolalwiLCBwcm9wLCBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzQnlJZFtmaWVsZC50eXBlRGVmYXVsdF0sIGZpZWxkLnR5cGVEZWZhdWx0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmxvbmcpIGdlblxuICAgICAgICAoXCJpZih1dGlsLkxvbmcpe1wiKVxuICAgICAgICAgICAgKFwidmFyIG49bmV3IHV0aWwuTG9uZyglaSwlaSwlailcIiwgZmllbGQudHlwZURlZmF1bHQubG93LCBmaWVsZC50eXBlRGVmYXVsdC5oaWdoLCBmaWVsZC50eXBlRGVmYXVsdC51bnNpZ25lZClcbiAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP24udG9TdHJpbmcoKTpvLmxvbmdzPT09TnVtYmVyP24udG9OdW1iZXIoKTpuXCIsIHByb3ApXG4gICAgICAgIChcIn1lbHNlXCIpXG4gICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz8lajolaVwiLCBwcm9wLCBmaWVsZC50eXBlRGVmYXVsdC50b1N0cmluZygpLCBmaWVsZC50eXBlRGVmYXVsdC50b051bWJlcigpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5RGVmYXVsdCA9IFwiW1wiICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmllbGQudHlwZURlZmF1bHQpLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgIChcImlmKG8uYnl0ZXM9PT1TdHJpbmcpZCVzPSVqXCIsIHByb3AsIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBmaWVsZC50eXBlRGVmYXVsdCkpXG4gICAgICAgIChcImVsc2V7XCIpXG4gICAgICAgICAgICAoXCJkJXM9JXNcIiwgcHJvcCwgYXJyYXlEZWZhdWx0KVxuICAgICAgICAgICAgKFwiaWYoby5ieXRlcyE9PUFycmF5KWQlcz11dGlsLm5ld0J1ZmZlcihkJXMpXCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgZ2VuXG4gICAgICAgIChcImQlcz0lalwiLCBwcm9wLCBmaWVsZC50eXBlRGVmYXVsdCk7IC8vIGFsc28gbWVzc2FnZXMgKD1udWxsKVxuICAgICAgICB9IGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuICAgIHZhciBoYXNLczIgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXSxcbiAgICAgICAgICAgIGluZGV4ID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxuICAgICAgICAgICAgcHJvcCAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0tzMikgeyBoYXNLczIgPSB0cnVlOyBnZW5cbiAgICAoXCJ2YXIga3MyXCIpO1xuICAgICAgICAgICAgfSBnZW5cbiAgICAoXCJpZihtJXMmJihrczI9T2JqZWN0LmtleXMobSVzKSkubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwiZCVzPXt9XCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIgaj0wO2o8a3MyLmxlbmd0aDsrK2ope1wiKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltrczJbal1dXCIpXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgKFwiaWYobSVzJiZtJXMubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwiZCVzPVtdXCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIgaj0wO2o8bSVzLmxlbmd0aDsrK2ope1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltqXVwiKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgeyBnZW5cbiAgICAoXCJpZihtJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcHJvcCwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIC8qIHNvcnRlZCAqLyBpbmRleCwgcHJvcCk7XG4gICAgICAgIGlmIChmaWVsZC5wYXJ0T2YpIGdlblxuICAgICAgICAoXCJpZihvLm9uZW9mcylcIilcbiAgICAgICAgICAgIChcImQlcz0lalwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLnBhcnRPZi5uYW1lKSwgZmllbGQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBkXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGVyO1xuXG52YXIgRW51bSAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBtaXNzaW5nKGZpZWxkKSB7XG4gICAgcmV0dXJuIFwibWlzc2luZyByZXF1aXJlZCAnXCIgKyBmaWVsZC5uYW1lICsgXCInXCI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZGVjb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBkZWNvZGVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcInJcIiwgXCJsXCJdLCBtdHlwZS5uYW1lICsgXCIkZGVjb2RlXCIpXG4gICAgKFwiaWYoIShyIGluc3RhbmNlb2YgUmVhZGVyKSlcIilcbiAgICAgICAgKFwicj1SZWFkZXIuY3JlYXRlKHIpXCIpXG4gICAgKFwidmFyIGM9bD09PXVuZGVmaW5lZD9yLmxlbjpyLnBvcytsLG09bmV3IHRoaXMuY3RvclwiICsgKG10eXBlLmZpZWxkc0FycmF5LmZpbHRlcihmdW5jdGlvbihmaWVsZCkgeyByZXR1cm4gZmllbGQubWFwOyB9KS5sZW5ndGggPyBcIixrLHZhbHVlXCIgOiBcIlwiKSlcbiAgICAoXCJ3aGlsZShyLnBvczxjKXtcIilcbiAgICAgICAgKFwidmFyIHQ9ci51aW50MzIoKVwiKTtcbiAgICBpZiAobXR5cGUuZ3JvdXApIGdlblxuICAgICAgICAoXCJpZigodCY3KT09PTQpXCIpXG4gICAgICAgICAgICAoXCJicmVha1wiKTtcbiAgICBnZW5cbiAgICAgICAgKFwic3dpdGNoKHQ+Pj4zKXtcIik7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgdHlwZSAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHJlZiAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpOyBnZW5cbiAgICAgICAgICAgIChcImNhc2UgJWk6XCIsIGZpZWxkLmlkKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoJXM9PT11dGlsLmVtcHR5T2JqZWN0KVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPXt9XCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJ2YXIgYzIgPSByLnVpbnQzMigpK3IucG9zXCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMuZGVmYXVsdHNbZmllbGQua2V5VHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaz0lalwiLCB0eXBlcy5kZWZhdWx0c1tmaWVsZC5rZXlUeXBlXSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIms9bnVsbFwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW3R5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcInZhbHVlPSVqXCIsIHR5cGVzLmRlZmF1bHRzW3R5cGVdKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwidmFsdWU9bnVsbFwiKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgdGFnMj1yLnVpbnQzMigpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcInN3aXRjaCh0YWcyPj4+Myl7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJjYXNlIDE6IGs9ci4lcygpOyBicmVha1wiLCBmaWVsZC5rZXlUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY2FzZSAyOlwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKVwiLCBpKTsgLy8gY2FuJ3QgYmUgZ3JvdXBzXG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXIuJXMoKVwiLCB0eXBlKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0YWcyJjcpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwifVwiKVxuICAgICAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5sb25nW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW3R5cGVvZiBrPT09XFxcIm9iamVjdFxcXCI/dXRpbC5sb25nVG9IYXNoKGspOmtdPXZhbHVlXCIsIHJlZik7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW2tdPXZhbHVlXCIsIHJlZik7XG5cbiAgICAgICAgLy8gUmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG5cbiAgICAgICAgICAgICAgICAoXCJpZighKCVzJiYlcy5sZW5ndGgpKVwiLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwiJXM9W11cIiwgcmVmKTtcblxuICAgICAgICAgICAgLy8gUGFja2FibGUgKGFsd2F5cyBjaGVjayBmb3IgZm9yd2FyZCBhbmQgYmFja3dhcmQgY29tcGF0aWJsaXR5KVxuICAgICAgICAgICAgaWYgKHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZigodCY3KT09PTIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgYzI9ci51aW50MzIoKStyLnBvc1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ3aGlsZShyLnBvczxjMilcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpXG4gICAgICAgICAgICAgICAgKFwifWVsc2VcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW4oZmllbGQucmVzb2x2ZWRUeXBlLmdyb3VwXG4gICAgICAgICAgICAgICAgICAgID8gXCIlcy5wdXNoKHR5cGVzWyVpXS5kZWNvZGUocikpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiVzLnB1c2godHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpKVwiLCByZWYsIGkpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiJXMucHVzaChyLiVzKCkpXCIsIHJlZiwgdHlwZSk7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuKGZpZWxkLnJlc29sdmVkVHlwZS5ncm91cFxuICAgICAgICAgICAgICAgID8gXCIlcz10eXBlc1slaV0uZGVjb2RlKHIpXCJcbiAgICAgICAgICAgICAgICA6IFwiJXM9dHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpXCIsIHJlZiwgaSk7XG4gICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwiJXM9ci4lcygpXCIsIHJlZiwgdHlwZSk7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImJyZWFrXCIpO1xuICAgIC8vIFVua25vd24gZmllbGRzXG4gICAgfSBnZW5cbiAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0JjcpXCIpXG4gICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcblxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgIC8vIEZpZWxkIHByZXNlbmNlXG4gICAgZm9yIChpID0gMDsgaSA8IG10eXBlLl9maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldO1xuICAgICAgICBpZiAocmZpZWxkLnJlcXVpcmVkKSBnZW5cbiAgICAoXCJpZighbS5oYXNPd25Qcm9wZXJ0eSglaikpXCIsIHJmaWVsZC5uYW1lKVxuICAgICAgICAoXCJ0aHJvdyB1dGlsLlByb3RvY29sRXJyb3IoJWose2luc3RhbmNlOm19KVwiLCBtaXNzaW5nKHJmaWVsZCkpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlcjtcblxudmFyIEVudW0gICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIG1lc3NhZ2UgdHlwZSBlbmNvZGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHJlZikge1xuICAgIHJldHVybiBmaWVsZC5yZXNvbHZlZFR5cGUuZ3JvdXBcbiAgICAgICAgPyBnZW4oXCJ0eXBlc1slaV0uZW5jb2RlKCVzLHcudWludDMyKCVpKSkudWludDMyKCVpKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMykgPj4+IDAsIChmaWVsZC5pZCA8PCAzIHwgNCkgPj4+IDApXG4gICAgICAgIDogZ2VuKFwidHlwZXNbJWldLmVuY29kZSglcyx3LnVpbnQzMiglaSkuZm9yaygpKS5sZGVsaW0oKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBlbmNvZGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZXIobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCIsIFwid1wiXSwgbXR5cGUubmFtZSArIFwiJGVuY29kZVwiKVxuICAgIChcImlmKCF3KVwiKVxuICAgICAgICAoXCJ3PVdyaXRlci5jcmVhdGUoKVwiKTtcblxuICAgIHZhciBpLCByZWY7XG5cbiAgICAvLyBcIndoZW4gYSBtZXNzYWdlIGlzIHNlcmlhbGl6ZWQgaXRzIGtub3duIGZpZWxkcyBzaG91bGQgYmUgd3JpdHRlbiBzZXF1ZW50aWFsbHkgYnkgZmllbGQgbnVtYmVyXCJcbiAgICB2YXIgZmllbGRzID0gLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUZpZWxkc0J5SWQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICAgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIGluZGV4ICAgID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxuICAgICAgICAgICAgdHlwZSAgICAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHdpcmVUeXBlID0gdHlwZXMuYmFzaWNbdHlwZV07XG4gICAgICAgICAgICByZWYgICAgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHtcbiAgICAgICAgICAgIGdlblxuICAgIChcImlmKCVzIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSkgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuICAgICAgICAoXCJmb3IodmFyIGtzPU9iamVjdC5rZXlzKCVzKSxpPTA7aTxrcy5sZW5ndGg7KytpKXtcIiwgcmVmKVxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLmZvcmsoKS51aW50MzIoJWkpLiVzKGtzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwLCA4IHwgdHlwZXMubWFwS2V5W2ZpZWxkLmtleVR5cGVdLCBmaWVsZC5rZXlUeXBlKTtcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgIChcInR5cGVzWyVpXS5lbmNvZGUoJXNba3NbaV1dLHcudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLmxkZWxpbSgpXCIsIGluZGV4LCByZWYpOyAvLyBjYW4ndCBiZSBncm91cHNcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCIudWludDMyKCVpKS4lcyglc1trc1tpXV0pLmxkZWxpbSgpXCIsIDE2IHwgd2lyZVR5cGUsIHR5cGUsIHJlZik7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKCVzIT1udWxsJiYlcy5sZW5ndGgpe1wiLCByZWYsIHJlZik7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgLy8gUGFja2VkIHJlcGVhdGVkXG4gICAgICAgICAgICBpZiAoZmllbGQucGFja2VkICYmIHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSB7IGdlblxuXG4gICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKClcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKVwiLCByZWYpXG4gICAgICAgICAgICAoXCJ3LiVzKCVzW2ldKVwiLCB0eXBlLCByZWYpXG4gICAgICAgIChcIncubGRlbGltKClcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIH0gZWxzZSB7IGdlblxuXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSlcIiwgcmVmKTtcbiAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYgKyBcIltpXVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICAgICAgfSBnZW5cbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwlaikpXCIsIHJlZiwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiB3XCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEVudW07XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gRW51bSkuY2xhc3NOYW1lID0gXCJFbnVtXCI7XG5cbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBlbnVtIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgZW51bS5cbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gW3ZhbHVlc10gRW51bSB2YWx1ZXMgYXMgYW4gb2JqZWN0LCBieSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBUaGUgY29tbWVudCBmb3IgdGhpcyBlbnVtXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IFtjb21tZW50c10gVGhlIHZhbHVlIGNvbW1lbnRzIGZvciB0aGlzIGVudW1cbiAqL1xuZnVuY3Rpb24gRW51bShuYW1lLCB2YWx1ZXMsIG9wdGlvbnMsIGNvbW1lbnQsIGNvbW1lbnRzKSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlcyAmJiB0eXBlb2YgdmFsdWVzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ2YWx1ZXMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG5cbiAgICAvKipcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlc0J5SWQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEVudW0gdmFsdWVzIGJ5IG5hbWUuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHRoaXMudmFsdWVzQnlJZCk7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBFbnVtIGNvbW1lbnQgdGV4dC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGNvbW1lbnQgdGV4dHMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvLyBOb3RlIHRoYXQgdmFsdWVzIGluaGVyaXQgdmFsdWVzQnlJZCBvbiB0aGVpciBwcm90b3R5cGUgd2hpY2ggbWFrZXMgdGhlbSBhIFR5cGVTY3JpcHQtXG4gICAgLy8gY29tcGF0aWJsZSBlbnVtLiBUaGlzIGlzIHVzZWQgYnkgcGJ0cyB0byB3cml0ZSBhY3R1YWwgZW51bSBkZWZpbml0aW9ucyB0aGF0IHdvcmsgZm9yXG4gICAgLy8gc3RhdGljIGFuZCByZWZsZWN0aW9uIGNvZGUgYWxpa2UgaW5zdGVhZCBvZiBlbWl0dGluZyBnZW5lcmljIG9iamVjdCBkZWZpbml0aW9ucy5cblxuICAgIGlmICh2YWx1ZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlc1trZXlzW2ldXSA9PT0gXCJudW1iZXJcIikgLy8gdXNlIGZvcndhcmQgZW50cmllcyBvbmx5XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNCeUlkWyB0aGlzLnZhbHVlc1trZXlzW2ldXSA9IHZhbHVlc1trZXlzW2ldXSBdID0ga2V5c1tpXTtcbn1cblxuLyoqXG4gKiBFbnVtIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElFbnVtXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLG51bWJlcj59IHZhbHVlcyBFbnVtIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIEVudW0gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtIGZyb20gYW4gZW51bSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXG4gKiBAcGFyYW0ge0lFbnVtfSBqc29uIEVudW0gZGVzY3JpcHRvclxuICogQHJldHVybnMge0VudW19IENyZWF0ZWQgZW51bVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuRW51bS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgZW5tID0gbmV3IEVudW0obmFtZSwganNvbi52YWx1ZXMsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLmNvbW1lbnRzKTtcbiAgICBlbm0ucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIHJldHVybiBlbm07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgZW51bSB0byBhbiBlbnVtIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJRW51bX0gRW51bSBkZXNjcmlwdG9yXG4gKi9cbkVudW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcInZhbHVlc1wiICAgLCB0aGlzLnZhbHVlcyxcbiAgICAgICAgXCJyZXNlcnZlZFwiICwgdGhpcy5yZXNlcnZlZCAmJiB0aGlzLnJlc2VydmVkLmxlbmd0aCA/IHRoaXMucmVzZXJ2ZWQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50c1wiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50cyA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gdGhpcyBlbnVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVmFsdWUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFZhbHVlIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQsIGlmIGFueVxuICogQHJldHVybnMge0VudW19IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgdmFsdWUgd2l0aCB0aGlzIG5hbWUgb3IgaWRcbiAqL1xuRW51bS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGlkLCBjb21tZW50KSB7XG4gICAgLy8gdXRpbGl6ZWQgYnkgdGhlIHBhcnNlciBidXQgbm90IGJ5IC5mcm9tSlNPTlxuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzW25hbWVdICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuaXNSZXNlcnZlZElkKGlkKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpZCBcIiArIGlkICsgXCIgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWROYW1lKG5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzQnlJZFtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmFsbG93X2FsaWFzKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlc1tuYW1lXSA9IGlkO1xuICAgIH0gZWxzZVxuICAgICAgICB0aGlzLnZhbHVlc0J5SWRbdGhpcy52YWx1ZXNbbmFtZV0gPSBpZF0gPSBuYW1lO1xuXG4gICAgdGhpcy5jb21tZW50c1tuYW1lXSA9IGNvbW1lbnQgfHwgbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhpcyBlbnVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXG4gKiBAcmV0dXJucyB7RW51bX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBuYW1lYCBpcyBub3QgYSBuYW1lIG9mIHRoaXMgZW51bVxuICovXG5FbnVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICB2YXIgdmFsID0gdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMudmFsdWVzQnlJZFt2YWxdO1xuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc1tuYW1lXTtcbiAgICBkZWxldGUgdGhpcy5jb21tZW50c1tuYW1lXTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbkVudW0ucHJvdG90eXBlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChpZCkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5FbnVtLnByb3RvdHlwZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBGaWVsZDtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gRmllbGQpLmNsYXNzTmFtZSA9IFwiRmllbGRcIjtcblxudmFyIEVudW0gID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGU7IC8vIGN5Y2xpY1xuXG52YXIgcnVsZVJlID0gL15yZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZCQvO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWVzc2FnZSBmaWVsZCBpbnN0YW5jZS4gTm90ZSB0aGF0IHtAbGluayBNYXBGaWVsZHxtYXAgZmllbGRzfSBoYXZlIHRoZWlyIG93biBjbGFzcy5cbiAqIEBuYW1lIEZpZWxkXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkLlxuICogQGV4dGVuZHMgRmllbGRCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZmllbGQgZnJvbSBhIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0lGaWVsZH0ganNvbiBGaWVsZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7RmllbGR9IENyZWF0ZWQgZmllbGRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbkZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgRmllbGQobmFtZSwganNvbi5pZCwganNvbi50eXBlLCBqc29uLnJ1bGUsIGpzb24uZXh0ZW5kLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIE5vdCBhbiBhY3R1YWwgY29uc3RydWN0b3IuIFVzZSB7QGxpbmsgRmllbGR9IGluc3RlYWQuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkcy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxuICogQGV4cG9ydHMgRmllbGRCYXNlXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gRmllbGQobmFtZSwgaWQsIHR5cGUsIHJ1bGUsIGV4dGVuZCwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgaWYgKHV0aWwuaXNPYmplY3QocnVsZSkpIHtcbiAgICAgICAgY29tbWVudCA9IGV4dGVuZDtcbiAgICAgICAgb3B0aW9ucyA9IHJ1bGU7XG4gICAgICAgIHJ1bGUgPSBleHRlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGV4dGVuZCkpIHtcbiAgICAgICAgY29tbWVudCA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQ7XG4gICAgICAgIGV4dGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlkKSB8fCBpZCA8IDApXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlclwiKTtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyh0eXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKHJ1bGUgIT09IHVuZGVmaW5lZCAmJiAhcnVsZVJlLnRlc3QocnVsZSA9IHJ1bGUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnVsZSBtdXN0IGJlIGEgc3RyaW5nIHJ1bGVcIik7XG5cbiAgICBpZiAoZXh0ZW5kICE9PSB1bmRlZmluZWQgJiYgIXV0aWwuaXNTdHJpbmcoZXh0ZW5kKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZXh0ZW5kIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAocnVsZSA9PT0gXCJwcm90bzNfb3B0aW9uYWxcIikge1xuICAgICAgICBydWxlID0gXCJvcHRpb25hbFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWVsZCBydWxlLCBpZiBhbnkuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5ydWxlID0gcnVsZSAmJiBydWxlICE9PSBcIm9wdGlvbmFsXCIgPyBydWxlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBmaWVsZCBpZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5kID0gZXh0ZW5kIHx8IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlZCA9IHJ1bGUgPT09IFwicmVxdWlyZWRcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBvcHRpb25hbC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbmFsID0gIXRoaXMucmVxdWlyZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVwZWF0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT09IFwicmVwZWF0ZWRcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBhIG1hcCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgdGhpcyBmaWVsZCBiZWxvbmdzIHRvLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE9uZU9mIHRoaXMgZmllbGQgYmVsb25ncyB0bywgaWYgYW55LFxuICAgICAqIEB0eXBlIHtPbmVPZnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFydE9mID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCB0eXBlJ3MgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCdzIGRlZmF1bHQgdmFsdWUgb24gcHJvdG90eXBlcy5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxvbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb25nID0gdXRpbC5Mb25nID8gdHlwZXMubG9uZ1t0eXBlXSAhPT0gdW5kZWZpbmVkIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBpcyBhIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJ5dGVzID0gdHlwZSA9PT0gXCJieXRlc1wiO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfEVudW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaXN0ZXItZmllbGQgd2l0aGluIHRoZSBleHRlbmRlZCB0eXBlIGlmIGEgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZC5cbiAgICAgKiBAdHlwZSB7RmllbGR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbkZpZWxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNpc3Rlci1maWVsZCB3aXRoaW4gdGhlIGRlY2xhcmluZyBuYW1lc3BhY2UgaWYgYW4gZXh0ZW5kZWQgZmllbGQuXG4gICAgICogQHR5cGUge0ZpZWxkfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kZWNsYXJpbmdGaWVsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHJlbWVtYmVycyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcGFja2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYWNrZWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBmaWVsZCBpcyBwYWNrZWQuIE9ubHkgcmVsZXZhbnQgd2hlbiByZXBlYXRlZCBhbmQgd29ya2luZyB3aXRoIHByb3RvMi5cbiAqIEBuYW1lIEZpZWxkI3BhY2tlZFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpZWxkLnByb3RvdHlwZSwgXCJwYWNrZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlIGlmIG5vdCBleHBsaWNpdHkgc2V0IHRvIGZhbHNlXG4gICAgICAgIGlmICh0aGlzLl9wYWNrZWQgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZWQgPSB0aGlzLmdldE9wdGlvbihcInBhY2tlZFwiKSAhPT0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWNrZWQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIGlmTm90U2V0KSB7XG4gICAgaWYgKG5hbWUgPT09IFwicGFja2VkXCIpIC8vIGNsZWFyIGNhY2hlZCBiZWZvcmUgc2V0dGluZ1xuICAgICAgICB0aGlzLl9wYWNrZWQgPSBudWxsO1xuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb24uY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpO1xufTtcblxuLyoqXG4gKiBGaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIEZpZWxkIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBGaWVsZCBpZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIEZpZWxkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEV4dGVuc2lvbiBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uRmllbGRcbiAqIEBleHRlbmRzIElGaWVsZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV4dGVuZCBFeHRlbmRlZCB0eXBlXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGZpZWxkIHRvIGEgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lGaWVsZH0gRmllbGQgZGVzY3JpcHRvclxuICovXG5GaWVsZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcInJ1bGVcIiAgICAsIHRoaXMucnVsZSAhPT0gXCJvcHRpb25hbFwiICYmIHRoaXMucnVsZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwidHlwZVwiICAgICwgdGhpcy50eXBlLFxuICAgICAgICBcImlkXCIgICAgICAsIHRoaXMuaWQsXG4gICAgICAgIFwiZXh0ZW5kXCIgICwgdGhpcy5leHRlbmQsXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIGZpZWxkJ3MgdHlwZSByZWZlcmVuY2VzLlxuICogQHJldHVybnMge0ZpZWxkfSBgdGhpc2BcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgcmVmZXJlbmNlIGNhbm5vdCBiZSByZXNvbHZlZFxuICovXG5GaWVsZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG5cbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoKHRoaXMudHlwZURlZmF1bHQgPSB0eXBlcy5kZWZhdWx0c1t0aGlzLnR5cGVdKSA9PT0gdW5kZWZpbmVkKSB7IC8vIGlmIG5vdCBhIGJhc2ljIHR5cGUsIHJlc29sdmUgaXRcbiAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUgPSAodGhpcy5kZWNsYXJpbmdGaWVsZCA/IHRoaXMuZGVjbGFyaW5nRmllbGQucGFyZW50IDogdGhpcy5wYXJlbnQpLmxvb2t1cFR5cGVPckVudW0odGhpcy50eXBlKTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBudWxsO1xuICAgICAgICBlbHNlIC8vIGluc3RhbmNlb2YgRW51bVxuICAgICAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlc1tPYmplY3Qua2V5cyh0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXMpWzBdXTsgLy8gZmlyc3QgZGVmaW5lZFxuICAgIH1cblxuICAgIC8vIHVzZSBleHBsaWNpdGx5IHNldCBkZWZhdWx0IHZhbHVlIGlmIHByZXNlbnRcbiAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5vcHRpb25zW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSAmJiB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbdGhpcy50eXBlRGVmYXVsdF07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IG9wdGlvbnNcbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFja2VkID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5wYWNrZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlc29sdmVkVHlwZSAmJiAhKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnBhY2tlZDtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGludGVybmFsIGRhdGEgdHlwZSBpZiBuZWNlc3NzYXJ5XG4gICAgaWYgKHRoaXMubG9uZykge1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdXRpbC5Mb25nLmZyb21OdW1iZXIodGhpcy50eXBlRGVmYXVsdCwgdGhpcy50eXBlLmNoYXJBdCgwKSA9PT0gXCJ1XCIpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChPYmplY3QuZnJlZXplKVxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLnR5cGVEZWZhdWx0KTsgLy8gbG9uZyBpbnN0YW5jZXMgYXJlIG1lYW50IHRvIGJlIGltbXV0YWJsZSBhbnl3YXkgKGkuZS4gdXNlIHNtYWxsIGludCBjYWNoZSB0aGF0IGV2ZW4gcmVxdWlyZXMgaXQpXG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXMgJiYgdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgaWYgKHV0aWwuYmFzZTY0LnRlc3QodGhpcy50eXBlRGVmYXVsdCkpXG4gICAgICAgICAgICB1dGlsLmJhc2U2NC5kZWNvZGUodGhpcy50eXBlRGVmYXVsdCwgYnVmID0gdXRpbC5uZXdCdWZmZXIodXRpbC5iYXNlNjQubGVuZ3RoKHRoaXMudHlwZURlZmF1bHQpKSwgMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHV0aWwudXRmOC53cml0ZSh0aGlzLnR5cGVEZWZhdWx0LCBidWYgPSB1dGlsLm5ld0J1ZmZlcih1dGlsLnV0ZjgubGVuZ3RoKHRoaXMudHlwZURlZmF1bHQpKSwgMCk7XG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBidWY7XG4gICAgfVxuXG4gICAgLy8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgbWFwcyBhbmQgcmVwZWF0ZWQgZmllbGRzXG4gICAgaWYgKHRoaXMubWFwKVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHV0aWwuZW1wdHlPYmplY3Q7XG4gICAgZWxzZSBpZiAodGhpcy5yZXBlYXRlZClcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB1dGlsLmVtcHR5QXJyYXk7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMudHlwZURlZmF1bHQ7XG5cbiAgICAvLyBlbnN1cmUgcHJvcGVyIHZhbHVlIG9uIHByb3RvdHlwZVxuICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgIHRoaXMucGFyZW50LmN0b3IucHJvdG90eXBlW3RoaXMubmFtZV0gPSB0aGlzLmRlZmF1bHRWYWx1ZTtcblxuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiBhcyByZXR1cm5lZCBieSB7QGxpbmsgRmllbGQuZH0gYW5kIHtAbGluayBNYXBGaWVsZC5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBGaWVsZERlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgcHJvdG90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBGaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcInN0cmluZ1wifFwiYm9vbFwifFwiYnl0ZXNcInxPYmplY3R9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXG4gKiBAcGFyYW0ge1wib3B0aW9uYWxcInxcInJlcXVpcmVkXCJ8XCJyZXBlYXRlZFwifSBbZmllbGRSdWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtUfSBbZGVmYXVsdFZhbHVlXSBEZWZhdWx0IHZhbHVlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBudW1iZXIgfCBudW1iZXJbXSB8IExvbmcgfCBMb25nW10gfCBzdHJpbmcgfCBzdHJpbmdbXSB8IGJvb2xlYW4gfCBib29sZWFuW10gfCBVaW50OEFycmF5IHwgVWludDhBcnJheVtdIHwgQnVmZmVyIHwgQnVmZmVyW11cbiAqL1xuRmllbGQuZCA9IGZ1bmN0aW9uIGRlY29yYXRlRmllbGQoZmllbGRJZCwgZmllbGRUeXBlLCBmaWVsZFJ1bGUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgLy8gc3VibWVzc2FnZTogZGVjb3JhdGUgdGhlIHN1Ym1lc3NhZ2UgYW5kIHVzZSBpdHMgbmFtZSBhcyB0aGUgdHlwZVxuICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZpZWxkVHlwZSA9IHV0aWwuZGVjb3JhdGVUeXBlKGZpZWxkVHlwZSkubmFtZTtcblxuICAgIC8vIGVudW0gcmVmZXJlbmNlOiBjcmVhdGUgYSByZWZsZWN0ZWQgY29weSBvZiB0aGUgZW51bSBhbmQga2VlcCByZXVzZWluZyBpdFxuICAgIGVsc2UgaWYgKGZpZWxkVHlwZSAmJiB0eXBlb2YgZmllbGRUeXBlID09PSBcIm9iamVjdFwiKVxuICAgICAgICBmaWVsZFR5cGUgPSB1dGlsLmRlY29yYXRlRW51bShmaWVsZFR5cGUpLm5hbWU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZmllbGREZWNvcmF0b3IocHJvdG90eXBlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgRmllbGQoZmllbGROYW1lLCBmaWVsZElkLCBmaWVsZFR5cGUsIGZpZWxkUnVsZSwgeyBcImRlZmF1bHRcIjogZGVmYXVsdFZhbHVlIH0pKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBGaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPnxzdHJpbmd9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXG4gKiBAcGFyYW0ge1wib3B0aW9uYWxcInxcInJlcXVpcmVkXCJ8XCJyZXBlYXRlZFwifSBbZmllbGRSdWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGxpa2UgRmllbGQuZCBidXQgd2l0aG91dCBhIGRlZmF1bHQgdmFsdWVcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5GaWVsZC5fY29uZmlndXJlID0gZnVuY3Rpb24gY29uZmlndXJlKFR5cGVfKSB7XG4gICAgVHlwZSA9IFR5cGVfO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pbmRleC1taW5pbWFsXCIpO1xuXG5wcm90b2J1Zi5idWlsZCA9IFwibGlnaHRcIjtcblxuLyoqXG4gKiBBIG5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgbG9hZH0gYW5kIHtAbGluayBSb290I2xvYWR9LlxuICogQHR5cGVkZWYgTG9hZENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QsIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqL1xuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgcm9vdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHJvb3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIH0gZWxzZSBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIHJldHVybiByb290LmxvYWQoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAbmFtZSBsb2FkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQG5hbWUgbG9hZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSb290Pn0gUHJvbWlzZVxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxuICogQHZhcmlhdGlvbiAzXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBbcm9vdDpSb290XSk6UHJvbWlzZTxSb290PlxuXG5wcm90b2J1Zi5sb2FkID0gbG9hZDtcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgKG5vZGUgb25seSkuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkU3luY31cbiAqL1xuZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIHJvb3QpIHtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIHJldHVybiByb290LmxvYWRTeW5jKGZpbGVuYW1lKTtcbn1cblxucHJvdG9idWYubG9hZFN5bmMgPSBsb2FkU3luYztcblxuLy8gU2VyaWFsaXphdGlvblxucHJvdG9idWYuZW5jb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIik7XG5wcm90b2J1Zi5kZWNvZGVyICAgICAgICAgID0gcmVxdWlyZShcIi4vZGVjb2RlclwiKTtcbnByb3RvYnVmLnZlcmlmaWVyICAgICAgICAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKTtcbnByb3RvYnVmLmNvbnZlcnRlciAgICAgICAgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIik7XG5cbi8vIFJlZmxlY3Rpb25cbnByb3RvYnVmLlJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG5wcm90b2J1Zi5OYW1lc3BhY2UgICAgICAgID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xucHJvdG9idWYuUm9vdCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RcIik7XG5wcm90b2J1Zi5FbnVtICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbnByb3RvYnVmLlR5cGUgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xucHJvdG9idWYuRmllbGQgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpO1xucHJvdG9idWYuT25lT2YgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xucHJvdG9idWYuTWFwRmllbGQgICAgICAgICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpO1xucHJvdG9idWYuU2VydmljZSAgICAgICAgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5wcm90b2J1Zi5NZXRob2QgICAgICAgICAgID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpO1xuXG4vLyBSdW50aW1lXG5wcm90b2J1Zi5NZXNzYWdlICAgICAgICAgID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcbnByb3RvYnVmLndyYXBwZXJzICAgICAgICAgPSByZXF1aXJlKFwiLi93cmFwcGVyc1wiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudHlwZXMgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xucHJvdG9idWYudXRpbCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8vIFNldCB1cCBwb3NzaWJseSBjeWNsaWMgcmVmbGVjdGlvbiBkZXBlbmRlbmNpZXNcbnByb3RvYnVmLlJlZmxlY3Rpb25PYmplY3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5Sb290KTtcbnByb3RvYnVmLk5hbWVzcGFjZS5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUsIHByb3RvYnVmLlNlcnZpY2UsIHByb3RvYnVmLkVudW0pO1xucHJvdG9idWYuUm9vdC5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUpO1xucHJvdG9idWYuRmllbGQuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWFwRmllbGQ7XG5cbi8vIGV4dGVuZHMgRmllbGRcbnZhciBGaWVsZCA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpO1xuKChNYXBGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpZWxkLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTWFwRmllbGQpLmNsYXNzTmFtZSA9IFwiTWFwRmllbGRcIjtcblxudmFyIHR5cGVzICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1hcCBmaWVsZCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG1hcCBmaWVsZC5cbiAqIEBleHRlbmRzIEZpZWxkQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVR5cGUgS2V5IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFZhbHVlIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gTWFwRmllbGQobmFtZSwgaWQsIGtleVR5cGUsIHR5cGUsIG9wdGlvbnMsIGNvbW1lbnQpIHtcbiAgICBGaWVsZC5jYWxsKHRoaXMsIG5hbWUsIGlkLCB0eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucywgY29tbWVudCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcoa2V5VHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImtleVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIEtleSB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5rZXlUeXBlID0ga2V5VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIGtleSB0eXBlIGlmIG5vdCBhIGJhc2ljIHR5cGUuXG4gICAgICogQHR5cGUge1JlZmxlY3Rpb25PYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkS2V5VHlwZSA9IG51bGw7XG5cbiAgICAvLyBPdmVycmlkZXMgRmllbGQjbWFwXG4gICAgdGhpcy5tYXAgPSB0cnVlO1xufVxuXG4vKipcbiAqIE1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJTWFwRmllbGRcbiAqIEBleHRlbmRzIHtJRmllbGR9XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5VHlwZSBLZXkgdHlwZVxuICovXG5cbi8qKlxuICogRXh0ZW5zaW9uIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uTWFwRmllbGRcbiAqIEBleHRlbmRzIElNYXBGaWVsZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV4dGVuZCBFeHRlbmRlZCB0eXBlXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbWFwIGZpZWxkIGZyb20gYSBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAqIEBwYXJhbSB7SU1hcEZpZWxkfSBqc29uIE1hcCBmaWVsZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7TWFwRmllbGR9IENyZWF0ZWQgbWFwIGZpZWxkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5NYXBGaWVsZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE1hcEZpZWxkKG5hbWUsIGpzb24uaWQsIGpzb24ua2V5VHlwZSwganNvbi50eXBlLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWFwIGZpZWxkIHRvIGEgbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJTWFwRmllbGR9IE1hcCBmaWVsZCBkZXNjcmlwdG9yXG4gKi9cbk1hcEZpZWxkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwia2V5VHlwZVwiICwgdGhpcy5rZXlUeXBlLFxuICAgICAgICBcInR5cGVcIiAgICAsIHRoaXMudHlwZSxcbiAgICAgICAgXCJpZFwiICAgICAgLCB0aGlzLmlkLFxuICAgICAgICBcImV4dGVuZFwiICAsIHRoaXMuZXh0ZW5kLFxuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk1hcEZpZWxkLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBCZXNpZGVzIGEgdmFsdWUgdHlwZSwgbWFwIGZpZWxkcyBoYXZlIGEga2V5IHR5cGUgdGhhdCBtYXkgYmUgXCJhbnkgc2NhbGFyIHR5cGUgZXhjZXB0IGZvciBmbG9hdGluZyBwb2ludCB0eXBlcyBhbmQgYnl0ZXNcIlxuICAgIGlmICh0eXBlcy5tYXBLZXlbdGhpcy5rZXlUeXBlXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQga2V5IHR5cGU6IFwiICsgdGhpcy5rZXlUeXBlKTtcblxuICAgIHJldHVybiBGaWVsZC5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBNYXAgZmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIE1hcEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJib29sXCJ8XCJzdHJpbmdcIn0gZmllbGRLZXlUeXBlIEZpZWxkIGtleSB0eXBlXG4gKiBAcGFyYW0ge1wiZG91YmxlXCJ8XCJmbG9hdFwifFwiaW50MzJcInxcInVpbnQzMlwifFwic2ludDMyXCJ8XCJmaXhlZDMyXCJ8XCJzZml4ZWQzMlwifFwiaW50NjRcInxcInVpbnQ2NFwifFwic2ludDY0XCJ8XCJmaXhlZDY0XCJ8XCJzZml4ZWQ2NFwifFwiYm9vbFwifFwic3RyaW5nXCJ8XCJieXRlc1wifE9iamVjdHxDb25zdHJ1Y3Rvcjx7fT59IGZpZWxkVmFsdWVUeXBlIEZpZWxkIHZhbHVlIHR5cGVcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgTG9uZyB8IHN0cmluZyB8IGJvb2xlYW4gfCBVaW50OEFycmF5IHwgQnVmZmVyIHwgbnVtYmVyW10gfCBNZXNzYWdlPHt9PiB9XG4gKi9cbk1hcEZpZWxkLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZU1hcEZpZWxkKGZpZWxkSWQsIGZpZWxkS2V5VHlwZSwgZmllbGRWYWx1ZVR5cGUpIHtcblxuICAgIC8vIHN1Ym1lc3NhZ2UgdmFsdWU6IGRlY29yYXRlIHRoZSBzdWJtZXNzYWdlIGFuZCB1c2UgaXRzIG5hbWUgYXMgdGhlIHR5cGVcbiAgICBpZiAodHlwZW9mIGZpZWxkVmFsdWVUeXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZpZWxkVmFsdWVUeXBlID0gdXRpbC5kZWNvcmF0ZVR5cGUoZmllbGRWYWx1ZVR5cGUpLm5hbWU7XG5cbiAgICAvLyBlbnVtIHJlZmVyZW5jZSB2YWx1ZTogY3JlYXRlIGEgcmVmbGVjdGVkIGNvcHkgb2YgdGhlIGVudW0gYW5kIGtlZXAgcmV1c2VpbmcgaXRcbiAgICBlbHNlIGlmIChmaWVsZFZhbHVlVHlwZSAmJiB0eXBlb2YgZmllbGRWYWx1ZVR5cGUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIGZpZWxkVmFsdWVUeXBlID0gdXRpbC5kZWNvcmF0ZUVudW0oZmllbGRWYWx1ZVR5cGUpLm5hbWU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwRmllbGREZWNvcmF0b3IocHJvdG90eXBlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgTWFwRmllbGQoZmllbGROYW1lLCBmaWVsZElkLCBmaWVsZEtleVR5cGUsIGZpZWxkVmFsdWVUeXBlKSk7XG4gICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBtZXNzYWdlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBYnN0cmFjdCBydW50aW1lIG1lc3NhZ2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UHJvcGVydGllczxUPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIG9iamVjdCA9IG9iamVjdFxuICovXG5mdW5jdGlvbiBNZXNzYWdlKHByb3BlcnRpZXMpIHtcbiAgICAvLyBub3QgdXNlZCBpbnRlcm5hbGx5XG4gICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG59XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSByZWZsZWN0ZWQgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UuJHR5cGVcbiAqIEB0eXBlIHtUeXBlfVxuICogQHJlYWRvbmx5XG4gKi9cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIHJlZmxlY3RlZCB0eXBlLlxuICogQG5hbWUgTWVzc2FnZSMkdHlwZVxuICogQHR5cGUge1R5cGV9XG4gKiBAcmVhZG9ubHlcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICogQHJldHVybnMge01lc3NhZ2U8VD59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmNyZWF0ZShwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQHBhcmFtIHtUfE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIHVzZVxuICogQHJldHVybnMge1dyaXRlcn0gV3JpdGVyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge1R8T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSB0byBlbmNvZGVcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gdXNlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBXcml0ZXJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcik7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UuZGVjb2RlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZVxuICogQHJldHVybnMge1R9IERlY29kZWQgbWVzc2FnZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5kZWNvZGUocmVhZGVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7VH0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmRlY29kZURlbGltaXRlZChyZWFkZXIpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS52ZXJpZnlcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICovXG5NZXNzYWdlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudmVyaWZ5KG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gKiBAcmV0dXJucyB7VH0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmZyb21PYmplY3Qob2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7VH0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtZXNzYWdlIHRvIEpTT04uXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS50b09iamVjdCh0aGlzLCB1dGlsLnRvSlNPTk9wdGlvbnMpO1xufTtcblxuLyplc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jKi8iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTWV0aG9kKS5jbGFzc05hbWUgPSBcIk1ldGhvZFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIG1ldGhvZCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UgbWV0aG9kLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB0eXBlIE1ldGhvZCB0eXBlLCB1c3VhbGx5IGBcInJwY1wiYFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgbWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIG1lc3NhZ2UgdHlwZVxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVxdWVzdFN0cmVhbV0gV2hldGhlciB0aGUgcmVxdWVzdCBpcyBzdHJlYW1lZFxuICogQHBhcmFtIHtib29sZWFufE9iamVjdC48c3RyaW5nLCo+fSBbcmVzcG9uc2VTdHJlYW1dIFdoZXRoZXIgdGhlIHJlc3BvbnNlIGlzIHN0cmVhbWVkXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBUaGUgY29tbWVudCBmb3IgdGhpcyBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zLCBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTWV0aG9kKG5hbWUsIHR5cGUsIHJlcXVlc3RUeXBlLCByZXNwb25zZVR5cGUsIHJlcXVlc3RTdHJlYW0sIHJlc3BvbnNlU3RyZWFtLCBvcHRpb25zLCBjb21tZW50LCBwYXJzZWRPcHRpb25zKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh1dGlsLmlzT2JqZWN0KHJlcXVlc3RTdHJlYW0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXF1ZXN0U3RyZWFtO1xuICAgICAgICByZXF1ZXN0U3RyZWFtID0gcmVzcG9uc2VTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KHJlc3BvbnNlU3RyZWFtKSkge1xuICAgICAgICBvcHRpb25zID0gcmVzcG9uc2VTdHJlYW07XG4gICAgICAgIHJlc3BvbnNlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB1dGlsLmlzU3RyaW5nKHR5cGUpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHJlcXVlc3RUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdFR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXNwb25zZVR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXNwb25zZVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZSB8fCBcInJwY1wiOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdFR5cGUgPSByZXF1ZXN0VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0U3RyZWFtID0gcmVxdWVzdFN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2UgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VTdHJlYW0gPSByZXNwb25zZVN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgcmVxdWVzdCB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgbWV0aG9kXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHByb3Blcmx5IHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IHBhcnNlZE9wdGlvbnM7XG59XG5cbi8qKlxuICogTWV0aG9kIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElNZXRob2RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT1cInJwY1wiXSBNZXRob2QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc3BvbnNlVHlwZSBSZXNwb25zZSB0eXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1ZXN0U3RyZWFtPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzcG9uc2VTdHJlYW09ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE1ldGhvZCBvcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29tbWVudCBNZXRob2QgY29tbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBNZXRob2Qgb3B0aW9ucyBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtZXRob2QgZnJvbSBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7SU1ldGhvZH0ganNvbiBNZXRob2QgZGVzY3JpcHRvclxuICogQHJldHVybnMge01ldGhvZH0gQ3JlYXRlZCBtZXRob2RcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1ldGhvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE1ldGhvZChuYW1lLCBqc29uLnR5cGUsIGpzb24ucmVxdWVzdFR5cGUsIGpzb24ucmVzcG9uc2VUeXBlLCBqc29uLnJlcXVlc3RTdHJlYW0sIGpzb24ucmVzcG9uc2VTdHJlYW0sIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLnBhcnNlZE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1ldGhvZCB0byBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1ldGhvZH0gTWV0aG9kIGRlc2NyaXB0b3JcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgICAsIHRoaXMudHlwZSAhPT0gXCJycGNcIiAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLnR5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInJlcXVlc3RUeXBlXCIgICAgLCB0aGlzLnJlcXVlc3RUeXBlLFxuICAgICAgICBcInJlcXVlc3RTdHJlYW1cIiAgLCB0aGlzLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIFwicmVzcG9uc2VUeXBlXCIgICAsIHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBcInJlc3BvbnNlU3RyZWFtXCIgLCB0aGlzLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICAgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJwYXJzZWRPcHRpb25zXCIgICwgdGhpcy5wYXJzZWRPcHRpb25zLFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXF1ZXN0VHlwZSk7XG4gICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXNwb25zZVR5cGUpO1xuXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTmFtZXNwYWNlO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChOYW1lc3BhY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTmFtZXNwYWNlKS5jbGFzc05hbWUgPSBcIk5hbWVzcGFjZVwiO1xuXG52YXIgRmllbGQgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBPbmVPZiAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGUsICAgIC8vIGN5Y2xpY1xuICAgIFNlcnZpY2UsXG4gICAgRW51bTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG5hbWVzcGFjZSBpbnN0YW5jZS5cbiAqIEBuYW1lIE5hbWVzcGFjZVxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbmFtZXNwYWNlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuYW1lc3BhY2UgZnJvbSBKU09OLlxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0ganNvbiBKU09OIG9iamVjdFxuICogQHJldHVybnMge05hbWVzcGFjZX0gQ3JlYXRlZCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk5hbWVzcGFjZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE5hbWVzcGFjZShuYW1lLCBqc29uLm9wdGlvbnMpLmFkZEpTT04oanNvbi5uZXN0ZWQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiByZWZsZWN0aW9uIG9iamVjdHMgdG8gSlNPTi5cbiAqIEBtZW1iZXJvZiBOYW1lc3BhY2VcbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdFtdfSBhcnJheSBPYmplY3QgYXJyYXlcbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fHVuZGVmaW5lZH0gSlNPTiBvYmplY3Qgb3IgYHVuZGVmaW5lZGAgd2hlbiBhcnJheSBpcyBlbXB0eVxuICovXG5mdW5jdGlvbiBhcnJheVRvSlNPTihhcnJheSwgdG9KU09OT3B0aW9ucykge1xuICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIG9ialthcnJheVtpXS5uYW1lXSA9IGFycmF5W2ldLnRvSlNPTih0b0pTT05PcHRpb25zKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5OYW1lc3BhY2UuYXJyYXlUb0pTT04gPSBhcnJheVRvSlNPTjtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyW118c3RyaW5nPnx1bmRlZmluZWR9IHJlc2VydmVkIEFycmF5IG9mIHJlc2VydmVkIHJhbmdlcyBhbmQgbmFtZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5OYW1lc3BhY2UuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKHJlc2VydmVkLCBpZCkge1xuICAgIGlmIChyZXNlcnZlZClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNlcnZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzZXJ2ZWRbaV0gIT09IFwic3RyaW5nXCIgJiYgcmVzZXJ2ZWRbaV1bMF0gPD0gaWQgJiYgcmVzZXJ2ZWRbaV1bMV0gPiBpZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz58dW5kZWZpbmVkfSByZXNlcnZlZCBBcnJheSBvZiByZXNlcnZlZCByYW5nZXMgYW5kIG5hbWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbk5hbWVzcGFjZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKHJlc2VydmVkLCBuYW1lKSB7XG4gICAgaWYgKHJlc2VydmVkKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHJlc2VydmVkW2ldID09PSBuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogTm90IGFuIGFjdHVhbCBjb25zdHJ1Y3Rvci4gVXNlIHtAbGluayBOYW1lc3BhY2V9IGluc3RlYWQuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3Rpb24gb2JqZWN0cyBjb250YWluaW5nIG5lc3RlZCBvYmplY3RzLiBUaGlzIGlzIG5vdCBhbiBhY3R1YWwgY2xhc3MgYnV0IGhlcmUgZm9yIHRoZSBzYWtlIG9mIGhhdmluZyBjb25zaXN0ZW50IHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAZXhwb3J0cyBOYW1lc3BhY2VCYXNlXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAYWJzdHJhY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAc2VlIHtAbGluayBOYW1lc3BhY2V9XG4gKi9cbmZ1bmN0aW9uIE5hbWVzcGFjZShuYW1lLCBvcHRpb25zKSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTmVzdGVkIG9iamVjdHMgYnkgbmFtZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUmVmbGVjdGlvbk9iamVjdD58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBuZXN0ZWQgb2JqZWN0cyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdFtdfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9uZXN0ZWRBcnJheSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQ2FjaGUobmFtZXNwYWNlKSB7XG4gICAgbmFtZXNwYWNlLl9uZXN0ZWRBcnJheSA9IG51bGw7XG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcbn1cblxuLyoqXG4gKiBOZXN0ZWQgb2JqZWN0cyBvZiB0aGlzIG5hbWVzcGFjZSBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICogQG5hbWUgTmFtZXNwYWNlQmFzZSNuZXN0ZWRBcnJheVxuICogQHR5cGUge1JlZmxlY3Rpb25PYmplY3RbXX1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTmFtZXNwYWNlLnByb3RvdHlwZSwgXCJuZXN0ZWRBcnJheVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25lc3RlZEFycmF5IHx8ICh0aGlzLl9uZXN0ZWRBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLm5lc3RlZCkpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIE5hbWVzcGFjZSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gTmFtZXNwYWNlIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsQW55TmVzdGVkT2JqZWN0Pn0gW25lc3RlZF0gTmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yc1xuICovXG5cbi8qKlxuICogQW55IGV4dGVuc2lvbiBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHR5cGVkZWYgQW55RXh0ZW5zaW9uRmllbGRcbiAqIEB0eXBlIHtJRXh0ZW5zaW9uRmllbGR8SUV4dGVuc2lvbk1hcEZpZWxkfVxuICovXG5cbi8qKlxuICogQW55IG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvci5cbiAqIEB0eXBlZGVmIEFueU5lc3RlZE9iamVjdFxuICogQHR5cGUge0lFbnVtfElUeXBlfElTZXJ2aWNlfEFueUV4dGVuc2lvbkZpZWxkfElOYW1lc3BhY2V9XG4gKi9cbi8vIF4gQkVXQVJFOiBWU0NvZGUgaGFuZ3MgZm9yZXZlciB3aGVuIHVzaW5nIG1vcmUgdGhhbiA1IHR5cGVzICh0aGF0J3Mgd2h5IEFueUV4dGVuc2lvbkZpZWxkIGV4aXN0cyBpbiB0aGUgZmlyc3QgcGxhY2UpXG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBuYW1lc3BhY2UgdG8gYSBuYW1lc3BhY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lOYW1lc3BhY2V9IE5hbWVzcGFjZSBkZXNjcmlwdG9yXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcIm5lc3RlZFwiICAsIGFycmF5VG9KU09OKHRoaXMubmVzdGVkQXJyYXksIHRvSlNPTk9wdGlvbnMpXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEFkZHMgbmVzdGVkIG9iamVjdHMgdG8gdGhpcyBuYW1lc3BhY2UgZnJvbSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBuZXN0ZWRKc29uIEFueSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5hZGRKU09OID0gZnVuY3Rpb24gYWRkSlNPTihuZXN0ZWRKc29uKSB7XG4gICAgdmFyIG5zID0gdGhpcztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChuZXN0ZWRKc29uKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWVzID0gT2JqZWN0LmtleXMobmVzdGVkSnNvbiksIGkgPSAwLCBuZXN0ZWQ7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmVzdGVkID0gbmVzdGVkSnNvbltuYW1lc1tpXV07XG4gICAgICAgICAgICBucy5hZGQoIC8vIG1vc3QgdG8gbGVhc3QgbGlrZWx5XG4gICAgICAgICAgICAgICAgKCBuZXN0ZWQuZmllbGRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFR5cGUuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC52YWx1ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRW51bS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLm1ldGhvZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gU2VydmljZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLmlkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEZpZWxkLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBOYW1lc3BhY2UuZnJvbUpTT04gKShuYW1lc1tpXSwgbmVzdGVkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbmVzdGVkIG9iamVjdCBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOZXN0ZWQgb2JqZWN0IG5hbWVcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IFRoZSByZWZsZWN0aW9uIG9iamVjdCBvciBgbnVsbGAgaWYgaXQgZG9lc24ndCBleGlzdFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdXG4gICAgICAgIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlcyBvZiB0aGUgbmVzdGVkIHtAbGluayBFbnVtfGVudW19IG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqIFRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNnZXR8Z2V0fSBpbiB0aGF0IGl0IHJldHVybnMgYW4gZW51bSdzIHZhbHVlcyBkaXJlY3RseSBhbmQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5lc3RlZCBlbnVtIG5hbWVcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSBFbnVtIHZhbHVlc1xuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIG5vIHN1Y2ggZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmdldEVudW0gPSBmdW5jdGlvbiBnZXRFbnVtKG5hbWUpIHtcbiAgICBpZiAodGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV0gaW5zdGFuY2VvZiBFbnVtKVxuICAgICAgICByZXR1cm4gdGhpcy5uZXN0ZWRbbmFtZV0udmFsdWVzO1xuICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBlbnVtOiBcIiArIG5hbWUpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbmVzdGVkIG9iamVjdCB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5lc3RlZCBvYmplY3Qgd2l0aCB0aGlzIG5hbWVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG5cbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgVHlwZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBFbnVtIHx8IG9iamVjdCBpbnN0YW5jZW9mIFNlcnZpY2UgfHwgb2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlIHx8IG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib2JqZWN0IG11c3QgYmUgYSB2YWxpZCBuZXN0ZWQgb2JqZWN0XCIpO1xuXG4gICAgaWYgKCF0aGlzLm5lc3RlZClcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLmdldChvYmplY3QubmFtZSk7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAocHJldiBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiBvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgIShwcmV2IGluc3RhbmNlb2YgVHlwZSB8fCBwcmV2IGluc3RhbmNlb2YgU2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHBsYWluIG5hbWVzcGFjZSBidXQga2VlcCBleGlzdGluZyBuZXN0ZWQgZWxlbWVudHMgYW5kIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkID0gcHJldi5uZXN0ZWRBcnJheTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lc3RlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmFkZChuZXN0ZWRbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHByZXYpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkID0ge307XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNldE9wdGlvbnMocHJldi5vcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIG5hbWVzcGFjZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIFJlZmxlY3Rpb25PYmplY3QpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIFJlZmxlY3Rpb25PYmplY3RcIik7XG4gICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IHRoaXMpXG4gICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubmVzdGVkKS5sZW5ndGgpXG4gICAgICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkO1xuXG4gICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGFkZGl0aWFsIG5hbWVzcGFjZXMgd2l0aGluIHRoaXMgb25lIGlmIG5vdCB5ZXQgZXhpc3RpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGNyZWF0ZVxuICogQHBhcmFtIHsqfSBbanNvbl0gTmVzdGVkIHR5cGVzIHRvIGNyZWF0ZSBmcm9tIEpTT05cbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IFBvaW50ZXIgdG8gdGhlIGxhc3QgbmFtZXNwYWNlIGNyZWF0ZWQgb3IgYHRoaXNgIGlmIHBhdGggaXMgZW1wdHlcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUocGF0aCwganNvbikge1xuXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkpXG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWxsZWdhbCBwYXRoXCIpO1xuICAgIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoICYmIHBhdGhbMF0gPT09IFwiXCIpXG4gICAgICAgIHRocm93IEVycm9yKFwicGF0aCBtdXN0IGJlIHJlbGF0aXZlXCIpO1xuXG4gICAgdmFyIHB0ciA9IHRoaXM7XG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgaWYgKHB0ci5uZXN0ZWQgJiYgcHRyLm5lc3RlZFtwYXJ0XSkge1xuICAgICAgICAgICAgcHRyID0gcHRyLm5lc3RlZFtwYXJ0XTtcbiAgICAgICAgICAgIGlmICghKHB0ciBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIGNvbmZsaWN0cyB3aXRoIG5vbi1uYW1lc3BhY2Ugb2JqZWN0c1wiKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBwdHIuYWRkKHB0ciA9IG5ldyBOYW1lc3BhY2UocGFydCkpO1xuICAgIH1cbiAgICBpZiAoanNvbilcbiAgICAgICAgcHRyLmFkZEpTT04oanNvbik7XG4gICAgcmV0dXJuIHB0cjtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBuYW1lc3BhY2UncyBhbmQgYWxsIGl0cyBuZXN0ZWQgb2JqZWN0cycgdHlwZSByZWZlcmVuY2VzLiBVc2VmdWwgdG8gdmFsaWRhdGUgYSByZWZsZWN0aW9uIHRyZWUsIGJ1dCBjb21lcyBhdCBhIGNvc3QuXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgbmVzdGVkID0gdGhpcy5uZXN0ZWRBcnJheSwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBuZXN0ZWQubGVuZ3RoKVxuICAgICAgICBpZiAobmVzdGVkW2ldIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxuICAgICAgICAgICAgbmVzdGVkW2krK10ucmVzb2x2ZUFsbCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXN0ZWRbaSsrXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZSgpO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBsb29rcyB1cCB0aGUgcmVmbGVjdGlvbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBwYXRoIGluIHRoZSBzY29wZSBvZiB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHBhcmFtIHsqfEFycmF5LjwqPn0gZmlsdGVyVHlwZXMgRmlsdGVyIHR5cGVzLCBhbnkgY29tYmluYXRpb24gb2YgdGhlIGNvbnN0cnVjdG9ycyBvZiBgcHJvdG9idWYuVHlwZWAsIGBwcm90b2J1Zi5FbnVtYCwgYHByb3RvYnVmLlNlcnZpY2VgIGV0Yy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBJZiBrbm93biwgd2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcywgcGFyZW50QWxyZWFkeUNoZWNrZWQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJUeXBlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcGFyZW50QWxyZWFkeUNoZWNrZWQgPSBmaWx0ZXJUeXBlcztcbiAgICAgICAgZmlsdGVyVHlwZXMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJUeXBlcyAmJiAhQXJyYXkuaXNBcnJheShmaWx0ZXJUeXBlcykpXG4gICAgICAgIGZpbHRlclR5cGVzID0gWyBmaWx0ZXJUeXBlcyBdO1xuXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkgJiYgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IFwiLlwiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIFN0YXJ0IGF0IHJvb3QgaWYgcGF0aCBpcyBhYnNvbHV0ZVxuICAgIGlmIChwYXRoWzBdID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmxvb2t1cChwYXRoLnNsaWNlKDEpLCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCBwYXJ0IG1hdGNoZXMgYW55IG5lc3RlZCBvYmplY3QsIGFuZCBpZiBzbywgdHJhdmVyc2UgaWYgcGF0aCBjb250YWlucyBtb3JlXG4gICAgdmFyIGZvdW5kID0gdGhpcy5nZXQocGF0aFswXSk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJUeXBlcyB8fCBmaWx0ZXJUeXBlcy5pbmRleE9mKGZvdW5kLmNvbnN0cnVjdG9yKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAoZm91bmQgPSBmb3VuZC5sb29rdXAocGF0aC5zbGljZSgxKSwgZmlsdGVyVHlwZXMsIHRydWUpKSlcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcblxuICAgIC8vIE90aGVyd2lzZSB0cnkgZWFjaCBuZXN0ZWQgbmFtZXNwYWNlXG4gICAgfSBlbHNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAoZm91bmQgPSB0aGlzLl9uZXN0ZWRBcnJheVtpXS5sb29rdXAocGF0aCwgZmlsdGVyVHlwZXMsIHRydWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG5cbiAgICAvLyBJZiB0aGVyZSBoYXNuJ3QgYmVlbiBhIG1hdGNoLCB0cnkgYWdhaW4gYXQgdGhlIHBhcmVudFxuICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnRBbHJlYWR5Q2hlY2tlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Lmxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcyk7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSByZWZsZWN0aW9uIG9iamVjdCBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQG5hbWUgTmFtZXNwYWNlQmFzZSNsb29rdXBcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJlbnRBbHJlYWR5Q2hlY2tlZD1mYWxzZV0gV2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGxvb2t1cChwYXRoOiBzdHJpbmcsIFtwYXJlbnRBbHJlYWR5Q2hlY2tlZDogYm9vbGVhbl0pXG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBUeXBlfHR5cGV9IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtUeXBlfSBMb29rZWQgdXAgdHlwZVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBUeXBlID0gZnVuY3Rpb24gbG9va3VwVHlwZShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBUeXBlIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCB0eXBlOiBcIiArIHBhdGgpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHZhbHVlcyBvZiB0aGUge0BsaW5rIEVudW18ZW51bX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge0VudW19IExvb2tlZCB1cCBlbnVtXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGFuIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBFbnVtID0gZnVuY3Rpb24gbG9va3VwRW51bShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBFbnVtIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBFbnVtICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBvciB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGUgb3IgZW51bVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGUgb3IgZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFR5cGVPckVudW0gPSBmdW5jdGlvbiBsb29rdXBUeXBlT3JFbnVtKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFR5cGUsIEVudW0gXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFR5cGUgb3IgRW51bSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFNlcnZpY2V8c2VydmljZX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1NlcnZpY2V9IExvb2tlZCB1cCBzZXJ2aWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgc2VydmljZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFNlcnZpY2UgPSBmdW5jdGlvbiBsb29rdXBTZXJ2aWNlKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFNlcnZpY2UgXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFNlcnZpY2UgJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuTmFtZXNwYWNlLl9jb25maWd1cmUgPSBmdW5jdGlvbihUeXBlXywgU2VydmljZV8sIEVudW1fKSB7XG4gICAgVHlwZSAgICA9IFR5cGVfO1xuICAgIFNlcnZpY2UgPSBTZXJ2aWNlXztcbiAgICBFbnVtICAgID0gRW51bV87XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3Rpb25PYmplY3Q7XG5cblJlZmxlY3Rpb25PYmplY3QuY2xhc3NOYW1lID0gXCJSZWZsZWN0aW9uT2JqZWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFJvb3Q7IC8vIGN5Y2xpY1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVmbGVjdGlvbiBvYmplY3QgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3Rpb24gb2JqZWN0cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAYWJzdHJhY3RcbiAqL1xuZnVuY3Rpb24gUmVmbGVjdGlvbk9iamVjdChuYW1lLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcobmFtZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIGlmIChvcHRpb25zICYmICF1dGlsLmlzT2JqZWN0KG9wdGlvbnMpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUGFyc2VkIE9wdGlvbnMuXG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3QuPHN0cmluZywqPj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBQYXJlbnQgbmFtZXNwYWNlLlxuICAgICAqIEB0eXBlIHtOYW1lc3BhY2V8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFscmVhZHkgcmVzb2x2ZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgdGV4dCwgaWYgYW55LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5pbmcgZmlsZSBuYW1lLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcm9vdCBuYW1lc3BhY2UuXG4gICAgICogQG5hbWUgUmVmbGVjdGlvbk9iamVjdCNyb290XG4gICAgICogQHR5cGUge1Jvb3R9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgcm9vdDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHB0ciA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAocHRyLnBhcmVudCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdWxsIG5hbWUgaW5jbHVkaW5nIGxlYWRpbmcgZG90LlxuICAgICAqIEBuYW1lIFJlZmxlY3Rpb25PYmplY3QjZnVsbE5hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGZ1bGxOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFsgdGhpcy5uYW1lIF0sXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocHRyKSB7XG4gICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHB0ci5uYW1lKTtcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHJlZmxlY3Rpb24gb2JqZWN0IHRvIGl0cyBkZXNjcmlwdG9yIHJlcHJlc2VudGF0aW9uLlxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXNjcmlwdG9yXG4gKiBAYWJzdHJhY3RcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUudG9KU09OID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHRocm93IEVycm9yKCk7IC8vIG5vdCBpbXBsZW1lbnRlZCwgc2hvdWxkbid0IGhhcHBlblxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGlzIG9iamVjdCBpcyBhZGRlZCB0byBhIHBhcmVudC5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gcGFyZW50IFBhcmVudCBhZGRlZCB0b1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiBvbkFkZChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQgIT09IHBhcmVudClcbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgcm9vdCA9IHBhcmVudC5yb290O1xuICAgIGlmIChyb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgcm9vdC5faGFuZGxlQWRkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGlzIG9iamVjdCBpcyByZW1vdmVkIGZyb20gYSBwYXJlbnQuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IHBhcmVudCBQYXJlbnQgcmVtb3ZlZCBmcm9tXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uIG9uUmVtb3ZlKHBhcmVudCkge1xuICAgIHZhciByb290ID0gcGFyZW50LnJvb3Q7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBSb290KVxuICAgICAgICByb290Ll9oYW5kbGVSZW1vdmUodGhpcyk7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBvYmplY3RzIHR5cGUgcmVmZXJlbmNlcy5cbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJvb3QgaW5zdGFuY2VvZiBSb290KVxuICAgICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZTsgLy8gb25seSBpZiBwYXJ0IG9mIGEgcm9vdFxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG9wdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbiBuYW1lXG4gKiBAcmV0dXJucyB7Kn0gT3B0aW9uIHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBzZXRcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zKVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gb3B0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT3B0aW9uIG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uIHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldF0gU2V0cyB0aGUgb3B0aW9uIG9ubHkgaWYgaXQgaXNuJ3QgY3VycmVudGx5IHNldFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIGlmTm90U2V0KSB7XG4gICAgaWYgKCFpZk5vdFNldCB8fCAhdGhpcy5vcHRpb25zIHx8IHRoaXMub3B0aW9uc1tuYW1lXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAodGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSkpW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSBwYXJzZWQgb3B0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgcGFyc2VkIE9wdGlvbiBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbiB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIGRvdCAnLicgZGVsaW1pdGVkIGZ1bGwgcGF0aCBvZiBwcm9wZXJ0eSB3aXRoaW4gdGhlIG9wdGlvbiB0byBzZXQuIGlmIHVuZGVmaW5lZFxcZW1wdHksIHdpbGwgYWRkIGEgbmV3IG9wdGlvbiB3aXRoIHRoYXQgdmFsdWVcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0UGFyc2VkT3B0aW9uID0gZnVuY3Rpb24gc2V0UGFyc2VkT3B0aW9uKG5hbWUsIHZhbHVlLCBwcm9wTmFtZSkge1xuICAgIGlmICghdGhpcy5wYXJzZWRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IFtdO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkT3B0aW9ucyA9IHRoaXMucGFyc2VkT3B0aW9ucztcbiAgICBpZiAocHJvcE5hbWUpIHtcbiAgICAgICAgLy8gSWYgc2V0dGluZyBhIHN1YiBwcm9wZXJ0eSBvZiBhbiBvcHRpb24gdGhlbiB0cnkgdG8gbWVyZ2UgaXRcbiAgICAgICAgLy8gd2l0aCBhbiBleGlzdGluZyBvcHRpb25cbiAgICAgICAgdmFyIG9wdCA9IHBhcnNlZE9wdGlvbnMuZmluZChmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdCwgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhbiBleGlzdGluZyBvcHRpb24gLSBqdXN0IG1lcmdlIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gb3B0W25hbWVdO1xuICAgICAgICAgICAgdXRpbC5zZXRQcm9wZXJ0eShuZXdWYWx1ZSwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IG9wdGlvbiwgc2V0IGl0J3MgcHJvcGVydHkgYW5kIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgICAgb3B0ID0ge307XG4gICAgICAgICAgICBvcHRbbmFtZV0gPSB1dGlsLnNldFByb3BlcnR5KHt9LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgcGFyc2VkT3B0aW9ucy5wdXNoKG9wdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbHdheXMgY3JlYXRlIGEgbmV3IG9wdGlvbiB3aGVuIHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gaXRzZWxmXG4gICAgICAgIHZhciBuZXdPcHQgPSB7fTtcbiAgICAgICAgbmV3T3B0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIHBhcnNlZE9wdGlvbnMucHVzaChuZXdPcHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBtdWx0aXBsZSBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb3B0aW9ucyBPcHRpb25zIHRvIHNldFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXRdIFNldHMgYW4gb3B0aW9uIG9ubHkgaWYgaXQgaXNuJ3QgY3VycmVudGx5IHNldFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBpZk5vdFNldCkge1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9uKGtleXNbaV0sIG9wdGlvbnNba2V5c1tpXV0sIGlmTm90U2V0KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBpbnN0YW5jZSB0byBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICogQHJldHVybnMge3N0cmluZ30gQ2xhc3MgbmFtZVssIHNwYWNlLCBmdWxsIG5hbWVdXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lLFxuICAgICAgICBmdWxsTmFtZSAgPSB0aGlzLmZ1bGxOYW1lO1xuICAgIGlmIChmdWxsTmFtZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjbGFzc05hbWUgKyBcIiBcIiArIGZ1bGxOYW1lO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG59O1xuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcblJlZmxlY3Rpb25PYmplY3QuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFJvb3RfKSB7XG4gICAgUm9vdCA9IFJvb3RfO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBPbmVPZjtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoT25lT2YucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gT25lT2YpLmNsYXNzTmFtZSA9IFwiT25lT2ZcIjtcblxudmFyIEZpZWxkID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgdXRpbCAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgb25lb2YgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBvbmVvZi5cbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT25lb2YgbmFtZVxuICogQHBhcmFtIHtzdHJpbmdbXXxPYmplY3QuPHN0cmluZywqPn0gW2ZpZWxkTmFtZXNdIEZpZWxkIG5hbWVzXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIE9uZU9mKG5hbWUsIGZpZWxkTmFtZXMsIG9wdGlvbnMsIGNvbW1lbnQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmllbGROYW1lcykpIHtcbiAgICAgICAgb3B0aW9ucyA9IGZpZWxkTmFtZXM7XG4gICAgICAgIGZpZWxkTmFtZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKGZpZWxkTmFtZXMgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGZpZWxkTmFtZXMpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGROYW1lcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xuXG4gICAgLyoqXG4gICAgICogRmllbGQgbmFtZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBvbmVvZi5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5vbmVvZiA9IGZpZWxkTmFtZXMgfHwgW107IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBGaWVsZHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBvbmVvZiBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRzQXJyYXkgPSBbXTsgLy8gZGVjbGFyZWQgcmVhZG9ubHkgZm9yIGNvbmZvcm1hbmNlLCBwb3NzaWJseSBub3QgeWV0IGFkZGVkIHRvIHBhcmVudFxuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbn1cblxuLyoqXG4gKiBPbmVvZiBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJT25lT2ZcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IG9uZW9mIE9uZW9mIGZpZWxkIG5hbWVzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gT25lb2Ygb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG9uZW9mIGZyb20gYSBvbmVvZiBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT25lb2YgbmFtZVxuICogQHBhcmFtIHtJT25lT2Z9IGpzb24gT25lb2YgZGVzY3JpcHRvclxuICogQHJldHVybnMge09uZU9mfSBDcmVhdGVkIG9uZW9mXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5PbmVPZi5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE9uZU9mKG5hbWUsIGpzb24ub25lb2YsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBvbmVvZiB0byBhIG9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJT25lT2Z9IE9uZW9mIGRlc2NyaXB0b3JcbiAqL1xuT25lT2YucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwib25lb2ZcIiAgICwgdGhpcy5vbmVvZixcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgZmllbGRzIG9mIHRoZSBzcGVjaWZpZWQgb25lb2YgdG8gdGhlIHBhcmVudCBpZiBub3QgYWxyZWFkeSBkb25lIHNvLlxuICogQHBhcmFtIHtPbmVPZn0gb25lb2YgVGhlIG9uZW9mXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGlubmVyXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGFkZEZpZWxkc1RvUGFyZW50KG9uZW9mKSB7XG4gICAgaWYgKG9uZW9mLnBhcmVudClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbmVvZi5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICghb25lb2YuZmllbGRzQXJyYXlbaV0ucGFyZW50KVxuICAgICAgICAgICAgICAgIG9uZW9mLnBhcmVudC5hZGQob25lb2YuZmllbGRzQXJyYXlbaV0pO1xufVxuXG4vKipcbiAqIEFkZHMgYSBmaWVsZCB0byB0aGlzIG9uZW9mIGFuZCByZW1vdmVzIGl0IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50LCBpZiBhbnkuXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBGaWVsZCB0byBhZGRcbiAqIEByZXR1cm5zIHtPbmVPZn0gYHRoaXNgXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoZmllbGQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgRmllbGQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZCBtdXN0IGJlIGEgRmllbGRcIik7XG5cbiAgICBpZiAoZmllbGQucGFyZW50ICYmIGZpZWxkLnBhcmVudCAhPT0gdGhpcy5wYXJlbnQpXG4gICAgICAgIGZpZWxkLnBhcmVudC5yZW1vdmUoZmllbGQpO1xuICAgIHRoaXMub25lb2YucHVzaChmaWVsZC5uYW1lKTtcbiAgICB0aGlzLmZpZWxkc0FycmF5LnB1c2goZmllbGQpO1xuICAgIGZpZWxkLnBhcnRPZiA9IHRoaXM7IC8vIGZpZWxkLnBhcmVudCByZW1haW5zIG51bGxcbiAgICBhZGRGaWVsZHNUb1BhcmVudCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGZpZWxkIGZyb20gdGhpcyBvbmVvZiBhbmQgcHV0cyBpdCBiYWNrIHRvIHRoZSBvbmVvZidzIHBhcmVudC5cbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIEZpZWxkIHRvIHJlbW92ZVxuICogQHJldHVybnMge09uZU9mfSBgdGhpc2BcbiAqL1xuT25lT2YucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShmaWVsZCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkIG11c3QgYmUgYSBGaWVsZFwiKTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuZmllbGRzQXJyYXkuaW5kZXhPZihmaWVsZCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICB0aHJvdyBFcnJvcihmaWVsZCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgdGhpcy5maWVsZHNBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0gdGhpcy5vbmVvZi5pbmRleE9mKGZpZWxkLm5hbWUpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5kZXggPiAtMSkgLy8gdGhlb3JldGljYWxcbiAgICAgICAgdGhpcy5vbmVvZi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgZmllbGQucGFydE9mID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIG9uQWRkKHBhcmVudCkge1xuICAgIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gQ29sbGVjdCBwcmVzZW50IGZpZWxkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vbmVvZi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBwYXJlbnQuZ2V0KHRoaXMub25lb2ZbaV0pO1xuICAgICAgICBpZiAoZmllbGQgJiYgIWZpZWxkLnBhcnRPZikge1xuICAgICAgICAgICAgZmllbGQucGFydE9mID0gc2VsZjtcbiAgICAgICAgICAgIHNlbGYuZmllbGRzQXJyYXkucHVzaChmaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIG5vdCB5ZXQgcHJlc2VudCBmaWVsZHNcbiAgICBhZGRGaWVsZHNUb1BhcmVudCh0aGlzKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uIG9uUmVtb3ZlKHBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICgoZmllbGQgPSB0aGlzLmZpZWxkc0FycmF5W2ldKS5wYXJlbnQpXG4gICAgICAgICAgICBmaWVsZC5wYXJlbnQucmVtb3ZlKGZpZWxkKTtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIHBhcmVudCk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiBhcyByZXR1cm5lZCBieSB7QGxpbmsgT25lT2YuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgT25lT2ZEZWNvcmF0b3JcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IHByb3RvdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG9uZW9mTmFtZSBPbmVPZiBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogT25lT2YgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkRlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIHN0cmluZ1xuICovXG5PbmVPZi5kID0gZnVuY3Rpb24gZGVjb3JhdGVPbmVPZigpIHtcbiAgICB2YXIgZmllbGROYW1lcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIGZpZWxkTmFtZXNbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbmVPZkRlY29yYXRvcihwcm90b3R5cGUsIG9uZW9mTmFtZSkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZShwcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuYWRkKG5ldyBPbmVPZihvbmVvZk5hbWUsIGZpZWxkTmFtZXMpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgb25lb2ZOYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IHV0aWwub25lT2ZHZXR0ZXIoZmllbGROYW1lcyksXG4gICAgICAgICAgICBzZXQ6IHV0aWwub25lT2ZTZXR0ZXIoZmllbGROYW1lcylcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSb290O1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoUm9vdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFJvb3QpLmNsYXNzTmFtZSA9IFwiUm9vdFwiO1xuXG52YXIgRmllbGQgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIEVudW0gICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIE9uZU9mICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGUsICAgLy8gY3ljbGljXG4gICAgcGFyc2UsICAvLyBtaWdodCBiZSBleGNsdWRlZFxuICAgIGNvbW1vbjsgLy8gXCJcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJvb3QgbmFtZXNwYWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSb290IG5hbWVzcGFjZSB3cmFwcGluZyBhbGwgdHlwZXMsIGVudW1zLCBzZXJ2aWNlcywgc3ViLW5hbWVzcGFjZXMgZXRjLiB0aGF0IGJlbG9uZyB0b2dldGhlci5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFRvcCBsZXZlbCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJvb3Qob3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIFwiXCIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogRGVmZXJyZWQgZXh0ZW5zaW9uIGZpZWxkcy5cbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmVycmVkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBmaWxlIG5hbWVzIG9mIGxvYWRlZCBmaWxlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5maWxlcyA9IFtdO1xufVxuXG4vKipcbiAqIExvYWRzIGEgbmFtZXNwYWNlIGRlc2NyaXB0b3IgaW50byBhIHJvb3QgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtJTmFtZXNwYWNlfSBqc29uIE5hbWVlc3BhY2UgZGVzY3JpcHRvclxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZFxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKi9cblJvb3QuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihqc29uLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IFJvb3QoKTtcbiAgICBpZiAoanNvbi5vcHRpb25zKVxuICAgICAgICByb290LnNldE9wdGlvbnMoanNvbi5vcHRpb25zKTtcbiAgICByZXR1cm4gcm9vdC5hZGRKU09OKGpzb24ubmVzdGVkKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGggb2YgYW4gaW1wb3J0ZWQgZmlsZSwgcmVsYXRpdmUgdG8gdGhlIGltcG9ydGluZyBvcmlnaW4uXG4gKiBUaGlzIG1ldGhvZCBleGlzdHMgc28geW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duIGxvZ2ljIGluIGNhc2UgeW91ciBpbXBvcnRzIGFyZSBzY2F0dGVyZWQgb3ZlciBtdWx0aXBsZSBkaXJlY3Rvcmllcy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiBUaGUgZmlsZSBuYW1lIG9mIHRoZSBpbXBvcnRpbmcgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUaGUgZmlsZSBuYW1lIGJlaW5nIGltcG9ydGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFJlc29sdmVkIHBhdGggdG8gYHRhcmdldGAgb3IgYG51bGxgIHRvIHNraXAgdGhlIGZpbGVcbiAqL1xuUm9vdC5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSB1dGlsLnBhdGgucmVzb2x2ZTtcblxuLyoqXG4gKiBGZXRjaCBjb250ZW50IGZyb20gZmlsZSBwYXRoIG9yIHVybFxuICogVGhpcyBtZXRob2QgZXhpc3RzIHNvIHlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93biBsb2dpYy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggRmlsZSBwYXRoIG9yIHVybFxuICogQHBhcmFtIHtGZXRjaENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUm9vdC5wcm90b3R5cGUuZmV0Y2ggPSB1dGlsLmZldGNoO1xuXG4vLyBBIHN5bWJvbC1saWtlIGZ1bmN0aW9uIHRvIHNhZmVseSBzaWduYWwgc3luY2hyb25vdXMgbG9hZGluZ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIFNZTkMoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gb3B0aW9ucyBQYXJzZSBvcHRpb25zXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJvb3QucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShsb2FkLCBzZWxmLCBmaWxlbmFtZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgc3luYyA9IGNhbGxiYWNrID09PSBTWU5DOyAvLyB1bmRvY3VtZW50ZWRcblxuICAgIC8vIEZpbmlzaGVzIGxvYWRpbmcgYnkgY2FsbGluZyB0aGUgY2FsbGJhY2sgKGV4YWN0bHkgb25jZSlcbiAgICBmdW5jdGlvbiBmaW5pc2goZXJyLCByb290KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgY2IoZXJyLCByb290KTtcbiAgICB9XG5cbiAgICAvLyBCdW5kbGVkIGRlZmluaXRpb24gZXhpc3RlbmNlIGNoZWNraW5nXG4gICAgZnVuY3Rpb24gZ2V0QnVuZGxlZEZpbGVOYW1lKGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBpZHggPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcImdvb2dsZS9wcm90b2J1Zi9cIik7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgdmFyIGFsdG5hbWUgPSBmaWxlbmFtZS5zdWJzdHJpbmcoaWR4KTtcbiAgICAgICAgICAgIGlmIChhbHRuYW1lIGluIGNvbW1vbikgcmV0dXJuIGFsdG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gUHJvY2Vzc2VzIGEgc2luZ2xlIGZpbGVcbiAgICBmdW5jdGlvbiBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHNvdXJjZSkgJiYgc291cmNlLmNoYXJBdCgwKSA9PT0gXCJ7XCIpXG4gICAgICAgICAgICAgICAgc291cmNlID0gSlNPTi5wYXJzZShzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHNvdXJjZSkpXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRPcHRpb25zKHNvdXJjZS5vcHRpb25zKS5hZGRKU09OKHNvdXJjZS5uZXN0ZWQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2UuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBzZWxmLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuaW1wb3J0cylcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBwYXJzZWQuaW1wb3J0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9IGdldEJ1bmRsZWRGaWxlTmFtZShwYXJzZWQuaW1wb3J0c1tpXSkgfHwgc2VsZi5yZXNvbHZlUGF0aChmaWxlbmFtZSwgcGFyc2VkLmltcG9ydHNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLndlYWtJbXBvcnRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2VkLndlYWtJbXBvcnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID0gZ2V0QnVuZGxlZEZpbGVOYW1lKHBhcnNlZC53ZWFrSW1wb3J0c1tpXSkgfHwgc2VsZi5yZXNvbHZlUGF0aChmaWxlbmFtZSwgcGFyc2VkLndlYWtJbXBvcnRzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaChyZXNvbHZlZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzeW5jICYmICFxdWV1ZWQpXG4gICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7IC8vIG9ubHkgb25jZSBhbnl3YXlcbiAgICB9XG5cbiAgICAvLyBGZXRjaGVzIGEgc2luZ2xlIGZpbGVcbiAgICBmdW5jdGlvbiBmZXRjaChmaWxlbmFtZSwgd2Vhaykge1xuXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBsb2FkZWQgLyBhdHRlbXB0ZWRcbiAgICAgICAgaWYgKHNlbGYuZmlsZXMuaW5kZXhPZihmaWxlbmFtZSkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VsZi5maWxlcy5wdXNoKGZpbGVuYW1lKTtcblxuICAgICAgICAvLyBTaG9ydGN1dCBidW5kbGVkIGRlZmluaXRpb25zXG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiBjb21tb24pIHtcbiAgICAgICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIGNvbW1vbltmaWxlbmFtZV0pO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKytxdWV1ZWQ7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1xdWV1ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIGNvbW1vbltmaWxlbmFtZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZldGNoIGZyb20gZGlzayBvciBuZXR3b3JrXG4gICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3ZWFrKVxuICAgICAgICAgICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytxdWV1ZWQ7XG4gICAgICAgICAgICBzZWxmLmZldGNoKGZpbGVuYW1lLCBmdW5jdGlvbihlcnIsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIC0tcXVldWVkO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gdGVybWluYXRlZCBtZWFud2hpbGVcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2VhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcXVldWVkKSAvLyBjYW4ndCBiZSBjb3ZlcmVkIHJlbGlhYmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBxdWV1ZWQgPSAwO1xuXG4gICAgLy8gQXNzZW1ibGluZyB0aGUgcm9vdCBuYW1lc3BhY2UgZG9lc24ndCByZXF1aXJlIHdvcmtpbmcgdHlwZVxuICAgIC8vIHJlZmVyZW5jZXMgYW55bW9yZSwgc28gd2UgY2FuIGxvYWQgZXZlcnl0aGluZyBpbiBwYXJhbGxlbFxuICAgIGlmICh1dGlsLmlzU3RyaW5nKGZpbGVuYW1lKSlcbiAgICAgICAgZmlsZW5hbWUgPSBbIGZpbGVuYW1lIF07XG4gICAgZm9yICh2YXIgaSA9IDAsIHJlc29sdmVkOyBpIDwgZmlsZW5hbWUubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChyZXNvbHZlZCA9IHNlbGYucmVzb2x2ZVBhdGgoXCJcIiwgZmlsZW5hbWVbaV0pKVxuICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQpO1xuXG4gICAgaWYgKHN5bmMpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICghcXVldWVkKVxuICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgb3B0aW9uczpJUGFyc2VPcHRpb25zLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBmdW5jdGlvbiBSb290I2xvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSb290Pn0gUHJvbWlzZVxuICogQHZhcmlhdGlvbiAzXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBbb3B0aW9uczpJUGFyc2VPcHRpb25zXSk6UHJvbWlzZTxSb290PlxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFN5bmNcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxuICovXG5Sb290LnByb3RvdHlwZS5sb2FkU3luYyA9IGZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCF1dGlsLmlzTm9kZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub3Qgc3VwcG9ydGVkXCIpO1xuICAgIHJldHVybiB0aGlzLmxvYWQoZmlsZW5hbWUsIG9wdGlvbnMsIFNZTkMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuUm9vdC5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgaWYgKHRoaXMuZGVmZXJyZWQubGVuZ3RoKVxuICAgICAgICB0aHJvdyBFcnJvcihcInVucmVzb2x2YWJsZSBleHRlbnNpb25zOiBcIiArIHRoaXMuZGVmZXJyZWQubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCInZXh0ZW5kIFwiICsgZmllbGQuZXh0ZW5kICsgXCInIGluIFwiICsgZmllbGQucGFyZW50LmZ1bGxOYW1lO1xuICAgICAgICB9KS5qb2luKFwiLCBcIikpO1xuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbn07XG5cbi8vIG9ubHkgdXBwZXJjYXNlZCAoYW5kIHRodXMgY29uZmxpY3QtZnJlZSkgY2hpbGRyZW4gYXJlIGV4cG9zZWQsIHNlZSBiZWxvd1xudmFyIGV4cG9zZVJlID0gL15bQS1aXS87XG5cbi8qKlxuICogSGFuZGxlcyBhIGRlZmVycmVkIGRlY2xhcmluZyBleHRlbnNpb24gZmllbGQgYnkgY3JlYXRpbmcgYSBzaXN0ZXIgZmllbGQgdG8gcmVwcmVzZW50IGl0IHdpdGhpbiBpdHMgZXh0ZW5kZWQgdHlwZS5cbiAqIEBwYXJhbSB7Um9vdH0gcm9vdCBSb290IGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBEZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkIHdpdGluIHRoZSBkZWNsYXJpbmcgdHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBzdWNjZXNzZnVsbHkgYWRkZWQgdG8gdGhlIGV4dGVuZGVkIHR5cGUsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAaW5uZXJcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gdHJ5SGFuZGxlRXh0ZW5zaW9uKHJvb3QsIGZpZWxkKSB7XG4gICAgdmFyIGV4dGVuZGVkVHlwZSA9IGZpZWxkLnBhcmVudC5sb29rdXAoZmllbGQuZXh0ZW5kKTtcbiAgICBpZiAoZXh0ZW5kZWRUeXBlKSB7XG4gICAgICAgIHZhciBzaXN0ZXJGaWVsZCA9IG5ldyBGaWVsZChmaWVsZC5mdWxsTmFtZSwgZmllbGQuaWQsIGZpZWxkLnR5cGUsIGZpZWxkLnJ1bGUsIHVuZGVmaW5lZCwgZmllbGQub3B0aW9ucyk7XG4gICAgICAgIHNpc3RlckZpZWxkLmRlY2xhcmluZ0ZpZWxkID0gZmllbGQ7XG4gICAgICAgIGZpZWxkLmV4dGVuc2lvbkZpZWxkID0gc2lzdGVyRmllbGQ7XG4gICAgICAgIGV4dGVuZGVkVHlwZS5hZGQoc2lzdGVyRmllbGQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuIGFueSBvYmplY3QgaXMgYWRkZWQgdG8gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCBhZGRlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cblJvb3QucHJvdG90eXBlLl9oYW5kbGVBZGQgPSBmdW5jdGlvbiBfaGFuZGxlQWRkKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCkge1xuXG4gICAgICAgIGlmICgvKiBhbiBleHRlbnNpb24gZmllbGQgKGltcGxpZXMgbm90IHBhcnQgb2YgYSBvbmVvZikgKi8gb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkICYmIC8qIG5vdCBhbHJlYWR5IGhhbmRsZWQgKi8gIW9iamVjdC5leHRlbnNpb25GaWVsZClcbiAgICAgICAgICAgIGlmICghdHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIG9iamVjdCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5wdXNoKG9iamVjdCk7XG5cbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEVudW0pIHtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXSA9IG9iamVjdC52YWx1ZXM7IC8vIGV4cG9zZSBlbnVtIHZhbHVlcyBhcyBwcm9wZXJ0eSBvZiBpdHMgcGFyZW50XG5cbiAgICB9IGVsc2UgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpKSAvKiBldmVyeXRoaW5nIGVsc2UgaXMgYSBuYW1lc3BhY2UgKi8ge1xuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUeXBlKSAvLyBUcnkgdG8gaGFuZGxlIGFueSBkZWZlcnJlZCBleHRlbnNpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVmZXJyZWQubGVuZ3RoOylcbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIHRoaXMuZGVmZXJyZWRbaV0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2opIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBZGQob2JqZWN0Ll9uZXN0ZWRBcnJheVtqXSk7XG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0OyAvLyBleHBvc2UgbmFtZXNwYWNlIGFzIHByb3BlcnR5IG9mIGl0cyBwYXJlbnRcbiAgICB9XG5cbiAgICAvLyBUaGUgYWJvdmUgYWxzbyBhZGRzIHVwcGVyY2FzZWQgKGFuZCB0aHVzIGNvbmZsaWN0LWZyZWUpIG5lc3RlZCB0eXBlcywgc2VydmljZXMgYW5kIGVudW1zIGFzXG4gICAgLy8gcHJvcGVydGllcyBvZiBuYW1lc3BhY2VzIGp1c3QgbGlrZSBzdGF0aWMgY29kZSBkb2VzLiBUaGlzIGFsbG93cyB1c2luZyBhIC5kLnRzIGdlbmVyYXRlZCBmb3JcbiAgICAvLyBhIHN0YXRpYyBtb2R1bGUgd2l0aCByZWZsZWN0aW9uLWJhc2VkIHNvbHV0aW9ucyB3aGVyZSB0aGUgY29uZGl0aW9uIGlzIG1ldC5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYW55IG9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCByZW1vdmVkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuUm9vdC5wcm90b3R5cGUuX2hhbmRsZVJlbW92ZSA9IGZ1bmN0aW9uIF9oYW5kbGVSZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XG5cbiAgICAgICAgaWYgKC8qIGFuIGV4dGVuc2lvbiBmaWVsZCAqLyBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgvKiBhbHJlYWR5IGhhbmRsZWQgKi8gb2JqZWN0LmV4dGVuc2lvbkZpZWxkKSB7IC8vIHJlbW92ZSBpdHMgc2lzdGVyIGZpZWxkXG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVuc2lvbkZpZWxkLnBhcmVudC5yZW1vdmUob2JqZWN0LmV4dGVuc2lvbkZpZWxkKTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uRmllbGQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2FuY2VsIHRoZSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmRlZmVycmVkLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRW51bSkge1xuXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXTsgLy8gdW5leHBvc2UgZW51bSB2YWx1ZXNcblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVSZW1vdmUob2JqZWN0Ll9uZXN0ZWRBcnJheVtpXSk7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBuYW1lc3BhY2VzXG5cbiAgICB9XG59O1xuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcblJvb3QuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBwYXJzZV8sIGNvbW1vbl8pIHtcbiAgICBUeXBlICAgPSBUeXBlXztcbiAgICBwYXJzZSAgPSBwYXJzZV87XG4gICAgY29tbW9uID0gY29tbW9uXztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2UpLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpLFxuICAgIHV0aWwgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgcnBjICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFNlcnZpY2Ugb3B0aW9uc1xuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShuYW1lLCBvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXJ2aWNlIG1ldGhvZHMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLE1ldGhvZD59XG4gICAgICovXG4gICAgdGhpcy5tZXRob2RzID0ge307IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgbWV0aG9kcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7TWV0aG9kW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21ldGhvZHNBcnJheSA9IG51bGw7XG59XG5cbi8qKlxuICogU2VydmljZSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJU2VydmljZVxuICogQGV4dGVuZHMgSU5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJTWV0aG9kPn0gbWV0aG9kcyBNZXRob2QgZGVzY3JpcHRvcnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzZXJ2aWNlIGZyb20gYSBzZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSB7SVNlcnZpY2V9IGpzb24gU2VydmljZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7U2VydmljZX0gQ3JlYXRlZCBzZXJ2aWNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5TZXJ2aWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciBzZXJ2aWNlID0gbmV3IFNlcnZpY2UobmFtZSwganNvbi5vcHRpb25zKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChqc29uLm1ldGhvZHMpXG4gICAgICAgIGZvciAodmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5tZXRob2RzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHNlcnZpY2UuYWRkKE1ldGhvZC5mcm9tSlNPTihuYW1lc1tpXSwganNvbi5tZXRob2RzW25hbWVzW2ldXSkpO1xuICAgIGlmIChqc29uLm5lc3RlZClcbiAgICAgICAgc2VydmljZS5hZGRKU09OKGpzb24ubmVzdGVkKTtcbiAgICBzZXJ2aWNlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgcmV0dXJuIHNlcnZpY2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgc2VydmljZSB0byBhIHNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lTZXJ2aWNlfSBTZXJ2aWNlIGRlc2NyaXB0b3JcbiAqL1xuU2VydmljZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwibWV0aG9kc1wiICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMubWV0aG9kc0FycmF5LCB0b0pTT05PcHRpb25zKSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fSxcbiAgICAgICAgXCJuZXN0ZWRcIiAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZHMgb2YgdGhpcyBzZXJ2aWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBTZXJ2aWNlI21ldGhvZHNBcnJheVxuICogQHR5cGUge01ldGhvZFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCJtZXRob2RzQXJyYXlcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2RzQXJyYXkgfHwgKHRoaXMuX21ldGhvZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLm1ldGhvZHMpKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gY2xlYXJDYWNoZShzZXJ2aWNlKSB7XG4gICAgc2VydmljZS5fbWV0aG9kc0FycmF5ID0gbnVsbDtcbiAgICByZXR1cm4gc2VydmljZTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RzW25hbWVdXG4gICAgICAgIHx8IE5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbmFtZSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kc0FycmF5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSlcbiAgICAgICAgbWV0aG9kc1tpXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5tZXRob2RzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJ1bnRpbWUgc2VydmljZSB1c2luZyB0aGUgc3BlY2lmaWVkIHJwYyBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBSUEMgc2VydmljZS4gVXNlZnVsIHdoZXJlIHJlcXVlc3RzIGFuZC9vciByZXNwb25zZXMgYXJlIHN0cmVhbWVkLlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcbiAgICB2YXIgcnBjU2VydmljZSA9IG5ldyBycGMuU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG1ldGhvZDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMubWV0aG9kc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gdXRpbC5sY0ZpcnN0KChtZXRob2QgPSB0aGlzLl9tZXRob2RzQXJyYXlbaV0pLnJlc29sdmUoKS5uYW1lKS5yZXBsYWNlKC9bXiRcXHdfXS9nLCBcIlwiKTtcbiAgICAgICAgcnBjU2VydmljZVttZXRob2ROYW1lXSA9IHV0aWwuY29kZWdlbihbXCJyXCIsXCJjXCJdLCB1dGlsLmlzUmVzZXJ2ZWQobWV0aG9kTmFtZSkgPyBtZXRob2ROYW1lICsgXCJfXCIgOiBtZXRob2ROYW1lKShcInJldHVybiB0aGlzLnJwY0NhbGwobSxxLHMscixjKVwiKSh7XG4gICAgICAgICAgICBtOiBtZXRob2QsXG4gICAgICAgICAgICBxOiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jdG9yLFxuICAgICAgICAgICAgczogbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBycGNTZXJ2aWNlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFR5cGUpLmNsYXNzTmFtZSA9IFwiVHlwZVwiO1xuXG52YXIgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBPbmVPZiAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcbiAgICBTZXJ2aWNlICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpLFxuICAgIE1lc3NhZ2UgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIiksXG4gICAgUmVhZGVyICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpLFxuICAgIFdyaXRlciAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKSxcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIGVuY29kZXIgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIiksXG4gICAgZGVjb2RlciAgID0gcmVxdWlyZShcIi4vZGVjb2RlclwiKSxcbiAgICB2ZXJpZmllciAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKSxcbiAgICBjb252ZXJ0ZXIgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIiksXG4gICAgd3JhcHBlcnMgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0ZWQgbWVzc2FnZSB0eXBlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSB0eXBlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFR5cGUobmFtZSwgb3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBmaWVsZHMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLEZpZWxkPn1cbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkcyA9IHt9OyAgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIE9uZW9mcyBkZWNsYXJlZCB3aXRoaW4gdGhpcyBuYW1lc3BhY2UsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsT25lT2Y+fVxuICAgICAqL1xuICAgIHRoaXMub25lb2ZzID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbiByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyW11bXX1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzZXJ2ZWQgcmFuZ2VzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMucmVzZXJ2ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyo/XG4gICAgICogV2hldGhlciB0aGlzIHR5cGUgaXMgYSBsZWdhY3kgZ3JvdXAuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXAgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZHNCeUlkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBmaWVsZHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge0ZpZWxkW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBvbmVvZnMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge09uZU9mW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29uZW9mc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAdHlwZSB7Q29uc3RydWN0b3I8e30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3RvciA9IG51bGw7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFR5cGUucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0J5SWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGZpZWxkc0J5SWQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQnlJZDtcblxuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkc1tuYW1lc1tpXV0sXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZmllbGQuaWQ7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZFtpZF0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZFtpZF0gPSBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpZWxkcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0FycmF5XG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZmllbGRzQXJyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNBcnJheSB8fCAodGhpcy5fZmllbGRzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5maWVsZHMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbmVvZnMgb2YgdGhpcyBtZXNzYWdlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQG5hbWUgVHlwZSNvbmVvZnNBcnJheVxuICAgICAqIEB0eXBlIHtPbmVPZltdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIG9uZW9mc0FycmF5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lb2ZzQXJyYXkgfHwgKHRoaXMuX29uZW9mc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMub25lb2ZzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgY29uc3RydWN0b3IsIGlmIGFueSByZWdpc3RlcmVkLCBvdGhlcndpc2UgYSBnZW5lcmljIGNvbnN0cnVjdG9yLlxuICAgICAqIEFzc2lnbmluZyBhIGZ1bmN0aW9uIHJlcGxhY2VzIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGV4dGVuZCB7QGxpbmsgTWVzc2FnZX0geWV0LCBpdHMgcHJvdG90eXBlIHdpbGwgYmUgc2V0dXAgYWNjb3JkaW5nbHkgYW5kIHN0YXRpYyBtZXRob2RzIHdpbGwgYmUgcG9wdWxhdGVkLiBJZiBpdCBhbHJlYWR5IGV4dGVuZHMge0BsaW5rIE1lc3NhZ2V9LCBpdCB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgaW50ZXJuYWwgY29uc3RydWN0b3IuXG4gICAgICogQG5hbWUgVHlwZSNjdG9yXG4gICAgICogQHR5cGUge0NvbnN0cnVjdG9yPHt9Pn1cbiAgICAgKi9cbiAgICBjdG9yOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3RvciB8fCAodGhpcy5jdG9yID0gVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yKHRoaXMpKCkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHByb3BlciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGlmICghKHByb3RvdHlwZSBpbnN0YW5jZW9mIE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgKGN0b3IucHJvdG90eXBlID0gbmV3IE1lc3NhZ2UoKSkuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UoY3Rvci5wcm90b3R5cGUsIHByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsYXNzZXMgYW5kIG1lc3NhZ2VzIHJlZmVyZW5jZSB0aGVpciByZWZsZWN0ZWQgdHlwZVxuICAgICAgICAgICAgY3Rvci4kdHlwZSA9IGN0b3IucHJvdG90eXBlLiR0eXBlID0gdGhpcztcblxuICAgICAgICAgICAgLy8gTWl4IGluIHN0YXRpYyBtZXRob2RzXG4gICAgICAgICAgICB1dGlsLm1lcmdlKGN0b3IsIE1lc3NhZ2UsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9jdG9yID0gY3RvcjtcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBkZWZhdWx0IHZhbHVlcyBvbiB0aGVpciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCk7IC8vIGVuc3VyZXMgYSBwcm9wZXIgdmFsdWVcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBlYWNoIHZpcnR1YWwgb25lb2YgZmllbGRcbiAgICAgICAgICAgIHZhciBjdG9yUHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMub25lb2ZzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY3RvclByb3BlcnRpZXNbdGhpcy5fb25lb2ZzQXJyYXlbaV0ucmVzb2x2ZSgpLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IHV0aWwub25lT2ZHZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHV0aWwub25lT2ZTZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN0b3IucHJvdG90eXBlLCBjdG9yUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cblR5cGUuZ2VuZXJhdGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGdlbmVyYXRlQ29uc3RydWN0b3IobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wicFwiXSwgbXR5cGUubmFtZSk7XG4gICAgLy8gZXhwbGljaXRseSBpbml0aWFsaXplIG11dGFibGUgb2JqZWN0L2FycmF5IGZpZWxkcyBzbyB0aGF0IHRoZXNlIGFyZW4ndCBqdXN0IGluaGVyaXRlZCBmcm9tIHRoZSBwcm90b3R5cGVcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXSkubWFwKSBnZW5cbiAgICAgICAgICAgIChcInRoaXMlcz17fVwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpKTtcbiAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIGdlblxuICAgICAgICAgICAgKFwidGhpcyVzPVtdXCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xuICAgIHJldHVybiBnZW5cbiAgICAoXCJpZihwKWZvcih2YXIga3M9T2JqZWN0LmtleXMocCksaT0wO2k8a3MubGVuZ3RoOysraSlpZihwW2tzW2ldXSE9bnVsbClcIikgLy8gb21pdCB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAoXCJ0aGlzW2tzW2ldXT1wW2tzW2ldXVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59O1xuXG5mdW5jdGlvbiBjbGVhckNhY2hlKHR5cGUpIHtcbiAgICB0eXBlLl9maWVsZHNCeUlkID0gdHlwZS5fZmllbGRzQXJyYXkgPSB0eXBlLl9vbmVvZnNBcnJheSA9IG51bGw7XG4gICAgZGVsZXRlIHR5cGUuZW5jb2RlO1xuICAgIGRlbGV0ZSB0eXBlLmRlY29kZTtcbiAgICBkZWxldGUgdHlwZS52ZXJpZnk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbi8qKlxuICogTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElUeXBlXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElPbmVPZj59IFtvbmVvZnNdIE9uZW9mIGRlc2NyaXB0b3JzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElGaWVsZD59IGZpZWxkcyBGaWVsZCBkZXNjcmlwdG9yc1xuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbZXh0ZW5zaW9uc10gRXh0ZW5zaW9uIHJhbmdlc1xuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbcmVzZXJ2ZWRdIFJlc2VydmVkIHJhbmdlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXA9ZmFsc2VdIFdoZXRoZXIgYSBsZWdhY3kgZ3JvdXAgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWVzc2FnZSB0eXBlIGZyb20gYSBtZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxuICogQHBhcmFtIHtJVHlwZX0ganNvbiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge1R5cGV9IENyZWF0ZWQgbWVzc2FnZSB0eXBlXG4gKi9cblR5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lLCBqc29uLm9wdGlvbnMpO1xuICAgIHR5cGUuZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucztcbiAgICB0eXBlLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLmZpZWxkcyksXG4gICAgICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGUuYWRkKFxuICAgICAgICAgICAgKCB0eXBlb2YganNvbi5maWVsZHNbbmFtZXNbaV1dLmtleVR5cGUgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gTWFwRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgIDogRmllbGQuZnJvbUpTT04gKShuYW1lc1tpXSwganNvbi5maWVsZHNbbmFtZXNbaV1dKVxuICAgICAgICApO1xuICAgIGlmIChqc29uLm9uZW9mcylcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ub25lb2ZzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKE9uZU9mLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm9uZW9mc1tuYW1lc1tpXV0pKTtcbiAgICBpZiAoanNvbi5uZXN0ZWQpXG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm5lc3RlZCksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWQgPSBqc29uLm5lc3RlZFtuYW1lc1tpXV07XG4gICAgICAgICAgICB0eXBlLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5pZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLmZpZWxkcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBUeXBlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQudmFsdWVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEVudW0uZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5tZXRob2RzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFNlcnZpY2UuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnMubGVuZ3RoKVxuICAgICAgICB0eXBlLmV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnM7XG4gICAgaWYgKGpzb24ucmVzZXJ2ZWQgJiYganNvbi5yZXNlcnZlZC5sZW5ndGgpXG4gICAgICAgIHR5cGUucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIGlmIChqc29uLmdyb3VwKVxuICAgICAgICB0eXBlLmdyb3VwID0gdHJ1ZTtcbiAgICBpZiAoanNvbi5jb21tZW50KVxuICAgICAgICB0eXBlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0eXBlIHRvIGEgbWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJVHlwZX0gTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3JcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAgICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwib25lb2ZzXCIgICAgICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMub25lb2ZzQXJyYXksIHRvSlNPTk9wdGlvbnMpLFxuICAgICAgICBcImZpZWxkc1wiICAgICAsIE5hbWVzcGFjZS5hcnJheVRvSlNPTih0aGlzLmZpZWxkc0FycmF5LmZpbHRlcihmdW5jdGlvbihvYmopIHsgcmV0dXJuICFvYmouZGVjbGFyaW5nRmllbGQ7IH0pLCB0b0pTT05PcHRpb25zKSB8fCB7fSxcbiAgICAgICAgXCJleHRlbnNpb25zXCIgLCB0aGlzLmV4dGVuc2lvbnMgJiYgdGhpcy5leHRlbnNpb25zLmxlbmd0aCA/IHRoaXMuZXh0ZW5zaW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJyZXNlcnZlZFwiICAgLCB0aGlzLnJlc2VydmVkICYmIHRoaXMucmVzZXJ2ZWQubGVuZ3RoID8gdGhpcy5yZXNlcnZlZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJncm91cFwiICAgICAgLCB0aGlzLmdyb3VwIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJuZXN0ZWRcIiAgICAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UeXBlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHNBcnJheSwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoKVxuICAgICAgICBmaWVsZHNbaSsrXS5yZXNvbHZlKCk7XG4gICAgdmFyIG9uZW9mcyA9IHRoaXMub25lb2ZzQXJyYXk7IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgb25lb2ZzLmxlbmd0aClcbiAgICAgICAgb25lb2ZzW2krK10ucmVzb2x2ZSgpO1xuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW25hbWVdXG4gICAgICAgIHx8IHRoaXMub25lb2ZzICYmIHRoaXMub25lb2ZzW25hbWVdXG4gICAgICAgIHx8IHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdXG4gICAgICAgIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lIG9yLCBpZiBhIGZpZWxkLCB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYSBmaWVsZCB3aXRoIHRoaXMgaWRcbiAqL1xuVHlwZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOT1RFOiBFeHRlbnNpb24gZmllbGRzIGFyZW4ndCBhY3R1YWwgZmllbGRzIG9uIHRoZSBkZWNsYXJpbmcgdHlwZSwgYnV0IG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAvLyBUaGUgcm9vdCBvYmplY3QgdGFrZXMgY2FyZSBvZiBhZGRpbmcgZGlzdGluY3Qgc2lzdGVyLWZpZWxkcyB0byB0aGUgcmVzcGVjdGl2ZSBleHRlbmRlZFxuICAgICAgICAvLyB0eXBlIGluc3RlYWQuXG5cbiAgICAgICAgLy8gYXZvaWRzIGNhbGxpbmcgdGhlIGdldHRlciBpZiBub3QgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIGNhbGxlZCBxdWl0ZSBmcmVxdWVudGx5XG4gICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdGhpcy5fZmllbGRzQnlJZFtvYmplY3QuaWRdIDogdGhpcy5maWVsZHNCeUlkW29iamVjdC5pZF0pXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIG9iamVjdC5pZCArIFwiIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChvYmplY3QuaWQpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpZCBcIiArIG9iamVjdC5pZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWROYW1lKG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGlmIChvYmplY3QucGFyZW50KVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QubWVzc2FnZSA9IHRoaXM7XG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzKVxuICAgICAgICAgICAgdGhpcy5vbmVvZnMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbmVzdGVkIG9iamVjdCBmcm9tIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIHR5cGVcbiAqL1xuVHlwZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU2VlIFR5cGUjYWRkIGZvciB0aGUgcmVhc29uIHdoeSBleHRlbnNpb24gZmllbGRzIGFyZSBleGNsdWRlZCBoZXJlLlxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzIHx8IHRoaXMuZmllbGRzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzIHx8IHRoaXMub25lb2ZzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMub25lb2ZzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuVHlwZS5wcm90b3R5cGUuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKGlkKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkSWQodGhpcy5yZXNlcnZlZCwgaWQpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cblR5cGUucHJvdG90eXBlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUodGhpcy5yZXNlcnZlZCwgbmFtZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqL1xuVHlwZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCB7QGxpbmsgVHlwZSNlbmNvZGV8ZW5jb2RlfSwge0BsaW5rIFR5cGUjZGVjb2RlfGRlY29kZX0gYW5kIHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9LlxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICovXG5UeXBlLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIC8vIFNldHMgdXAgZXZlcnl0aGluZyBhdCBvbmNlIHNvIHRoYXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkb2VzIG5vdCBoYXZlIHRvIGJlIHJlLWV2YWx1YXRlZFxuICAgIC8vIG11bHRpcGxlIHRpbWVzIChWOCwgc29mdC1kZW9wdCBwcm90b3R5cGUtY2hlY2spLlxuXG4gICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5mdWxsTmFtZSxcbiAgICAgICAgdHlwZXMgICAgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGVzLnB1c2godGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLnJlc29sdmVkVHlwZSk7XG5cbiAgICAvLyBSZXBsYWNlIHNldHVwIG1ldGhvZHMgd2l0aCB0eXBlLXNwZWNpZmljIGdlbmVyYXRlZCBmdW5jdGlvbnNcbiAgICB0aGlzLmVuY29kZSA9IGVuY29kZXIodGhpcykoe1xuICAgICAgICBXcml0ZXIgOiBXcml0ZXIsXG4gICAgICAgIHR5cGVzICA6IHR5cGVzLFxuICAgICAgICB1dGlsICAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy5kZWNvZGUgPSBkZWNvZGVyKHRoaXMpKHtcbiAgICAgICAgUmVhZGVyIDogUmVhZGVyLFxuICAgICAgICB0eXBlcyAgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudmVyaWZ5ID0gdmVyaWZpZXIodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLmZyb21PYmplY3QgPSBjb252ZXJ0ZXIuZnJvbU9iamVjdCh0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudG9PYmplY3QgPSBjb252ZXJ0ZXIudG9PYmplY3QodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcblxuICAgIC8vIEluamVjdCBjdXN0b20gd3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlc1xuICAgIHZhciB3cmFwcGVyID0gd3JhcHBlcnNbZnVsbE5hbWVdO1xuICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFRoaXMgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAvLyBpZiAod3JhcHBlci5mcm9tT2JqZWN0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbFRoaXMuZnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuZnJvbU9iamVjdCA9IHdyYXBwZXIuZnJvbU9iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHdyYXBwZXIudG9PYmplY3QpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsVGhpcy50b09iamVjdCA9IHRoaXMudG9PYmplY3Q7XG4gICAgICAgICAgICB0aGlzLnRvT2JqZWN0ID0gd3JhcHBlci50b09iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGVfc2V0dXAobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciAmJiB3cml0ZXIubGVuID8gd3JpdGVyLmZvcmsoKSA6IHdyaXRlcikubGRlbGltKCk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIG9mIHRoZSBtZXNzYWdlLCBpZiBrbm93biBiZWZvcmVoYW5kXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcjx7fT59IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICovXG5UeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGVfc2V0dXAocmVhZGVyLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmRlY29kZShyZWFkZXIsIGxlbmd0aCk7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKi9cblR5cGUucHJvdG90eXBlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiBSZWFkZXIpKVxuICAgICAgICByZWFkZXIgPSBSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBmaWVsZCB2YWx1ZXMgYXJlIHZhbGlkIGFuZCB0aGF0IHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge251bGx8c3RyaW5nfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAqL1xuVHlwZS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5X3NldHVwKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnZlcmlmeShtZXNzYWdlKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKi9cblR5cGUucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZnJvbU9iamVjdChvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9wdGlvbnMgYXMgdXNlZCBieSB7QGxpbmsgVHlwZSN0b09iamVjdH0gYW5kIHtAbGluayBNZXNzYWdlLnRvT2JqZWN0fS5cbiAqIEBpbnRlcmZhY2UgSUNvbnZlcnNpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbG9uZ3NdIExvbmcgY29udmVyc2lvbiB0eXBlLlxuICogVmFsaWQgdmFsdWVzIGFyZSBgU3RyaW5nYCBhbmQgYE51bWJlcmAgKHRoZSBnbG9iYWwgdHlwZXMpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggaXMgYSBwb3NzaWJseSB1bnNhZmUgbnVtYmVyIHdpdGhvdXQgYW5kIGEge0BsaW5rIExvbmd9IHdpdGggYSBsb25nIGxpYnJhcnkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZW51bXNdIEVudW0gdmFsdWUgY29udmVyc2lvbiB0eXBlLlxuICogT25seSB2YWxpZCB2YWx1ZSBpcyBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIGlzIHRoZSBudW1lcmljIGlkLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2J5dGVzXSBCeXRlcyB2YWx1ZSBjb252ZXJzaW9uIHR5cGUuXG4gKiBWYWxpZCB2YWx1ZXMgYXJlIGBBcnJheWAgYW5kIChhIGJhc2U2NCBlbmNvZGVkKSBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlcykuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCB1c3VhbGx5IGlzIGEgQnVmZmVyIHVuZGVyIG5vZGUgYW5kIGFuIFVpbnQ4QXJyYXkgaW4gdGhlIGJyb3dzZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWZhdWx0cz1mYWxzZV0gQWxzbyBzZXRzIGRlZmF1bHQgdmFsdWVzIG9uIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJheXM9ZmFsc2VdIFNldHMgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIHJlcGVhdGVkIGZpZWxkcyBldmVuIGlmIGBkZWZhdWx0cz1mYWxzZWBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29iamVjdHM9ZmFsc2VdIFNldHMgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBtYXAgZmllbGRzIGV2ZW4gaWYgYGRlZmF1bHRzPWZhbHNlYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25lb2ZzPWZhbHNlXSBJbmNsdWRlcyB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgc2V0IHRvIHRoZSBwcmVzZW50IGZpZWxkJ3MgbmFtZSwgaWYgYW55XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqc29uPWZhbHNlXSBQZXJmb3JtcyBhZGRpdGlvbmFsIEpTT04gY29tcGF0aWJpbGl0eSBjb252ZXJzaW9ucywgaS5lLiBOYU4gYW5kIEluZmluaXR5IHRvIHN0cmluZ3NcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICovXG5UeXBlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIFR5cGUuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgVHlwZURlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPn0gdGFyZ2V0IFRhcmdldCBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICovXG5cbi8qKlxuICogVHlwZSBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXG4gKiBAcmV0dXJucyB7VHlwZURlY29yYXRvcjxUPn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqL1xuVHlwZS5kID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHR5cGVEZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHRhcmdldCwgdHlwZU5hbWUpO1xuICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29tbW9uIHR5cGUgY29uc3RhbnRzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgdHlwZXMgPSBleHBvcnRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBzID0gW1xuICAgIFwiZG91YmxlXCIsICAgLy8gMFxuICAgIFwiZmxvYXRcIiwgICAgLy8gMVxuICAgIFwiaW50MzJcIiwgICAgLy8gMlxuICAgIFwidWludDMyXCIsICAgLy8gM1xuICAgIFwic2ludDMyXCIsICAgLy8gNFxuICAgIFwiZml4ZWQzMlwiLCAgLy8gNVxuICAgIFwic2ZpeGVkMzJcIiwgLy8gNlxuICAgIFwiaW50NjRcIiwgICAgLy8gN1xuICAgIFwidWludDY0XCIsICAgLy8gOFxuICAgIFwic2ludDY0XCIsICAgLy8gOVxuICAgIFwiZml4ZWQ2NFwiLCAgLy8gMTBcbiAgICBcInNmaXhlZDY0XCIsIC8vIDExXG4gICAgXCJib29sXCIsICAgICAvLyAxMlxuICAgIFwic3RyaW5nXCIsICAgLy8gMTNcbiAgICBcImJ5dGVzXCIgICAgIC8vIDE0XG5dO1xuXG5mdW5jdGlvbiBiYWtlKHZhbHVlcywgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSAwLCBvID0ge307XG4gICAgb2Zmc2V0IHw9IDA7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZXMubGVuZ3RoKSBvW3NbaSArIG9mZnNldF1dID0gdmFsdWVzW2krK107XG4gICAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogQmFzaWMgdHlwZSB3aXJlIHR5cGVzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBieXRlcz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqL1xudHlwZXMuYmFzaWMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwLFxuICAgIC8qIHN0cmluZyAgICovIDIsXG4gICAgLyogYnl0ZXMgICAgKi8gMlxuXSk7XG5cbi8qKlxuICogQmFzaWMgdHlwZSBkZWZhdWx0cy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRvdWJsZT0wIERvdWJsZSBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9MCBGbG9hdCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBJbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVWludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBTaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9MCBGaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj0wIFNmaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIEludDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBVaW50NjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFNpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0wIEZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTAgU2ZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBib29sPWZhbHNlIEJvb2wgZGVmYXVsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0cmluZz1cIlwiIFN0cmluZyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBieXRlcz1BcnJheSgwKSBCeXRlcyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bGx9IG1lc3NhZ2U9bnVsbCBNZXNzYWdlIGRlZmF1bHRcbiAqL1xudHlwZXMuZGVmYXVsdHMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAwLFxuICAgIC8qIGZsb2F0ICAgICovIDAsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gMCxcbiAgICAvKiBzZml4ZWQzMiAqLyAwLFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDAsXG4gICAgLyogc2ZpeGVkNjQgKi8gMCxcbiAgICAvKiBib29sICAgICAqLyBmYWxzZSxcbiAgICAvKiBzdHJpbmcgICAqLyBcIlwiLFxuICAgIC8qIGJ5dGVzICAgICovIHV0aWwuZW1wdHlBcnJheSxcbiAgICAvKiBtZXNzYWdlICAqLyBudWxsXG5dKTtcblxuLyoqXG4gKiBCYXNpYyBsb25nIHR5cGUgd2lyZSB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKi9cbnR5cGVzLmxvbmcgPSBiYWtlKFtcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDFcbl0sIDcpO1xuXG4vKipcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIG1hcCBrZXlzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCB3aXJlIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvb2w9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RyaW5nPTIgTGRlbGltIHdpcmUgdHlwZVxuICovXG50eXBlcy5tYXBLZXkgPSBiYWtlKFtcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxuICAgIC8qIHVpbnQzMiAgICovIDAsXG4gICAgLyogc2ludDMyICAgKi8gMCxcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxuICAgIC8qIHNmaXhlZDMyICovIDUsXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxuICAgIC8qIGJvb2wgICAgICovIDAsXG4gICAgLyogc3RyaW5nICAgKi8gMlxuXSwgMik7XG5cbi8qKlxuICogQWxsb3dlZCB0eXBlcyBmb3IgcGFja2VkIHJlcGVhdGVkIGZpZWxkcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd2lyZSB0eXBlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICovXG50eXBlcy5wYWNrZWQgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwXG5dKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciByb290cyA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xuXG52YXIgVHlwZSwgLy8gY3ljbGljXG4gICAgRW51bTtcblxudXRpbC5jb2RlZ2VuID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2NvZGVnZW5cIik7XG51dGlsLmZldGNoICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmV0Y2hcIik7XG51dGlsLnBhdGggICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcGF0aFwiKTtcblxuLyoqXG4gKiBOb2RlJ3MgZnMgbW9kdWxlIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqL1xudXRpbC5mcyA9IHV0aWwuaW5xdWlyZShcImZzXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCdzIHZhbHVlcyB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBPYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge0FycmF5LjwqPn0gQ29udmVydGVkIGFycmF5XG4gKi9cbnV0aWwudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIga2V5cyAgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IG9iamVjdFtrZXlzW2luZGV4KytdXTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGtleXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZSB0byBhbiBvYmplY3QsIG9taXR0aW5nIHVuZGVmaW5lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyYXkgQXJyYXkgdG8gY29udmVydFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBDb252ZXJ0ZWQgb2JqZWN0XG4gKi9cbnV0aWwudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChhcnJheSkge1xuICAgIHZhciBvYmplY3QgPSB7fSxcbiAgICAgICAgaW5kZXggID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGFycmF5W2luZGV4KytdLFxuICAgICAgICAgICAgdmFsID0gYXJyYXlbaW5kZXgrK107XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIHNhZmVQcm9wQmFja3NsYXNoUmUgPSAvXFxcXC9nLFxuICAgIHNhZmVQcm9wUXVvdGVSZSAgICAgPSAvXCIvZztcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSlMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNSZXNlcnZlZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWQobmFtZSkge1xuICAgIHJldHVybiAvXig/OmRvfGlmfGlufGZvcnxsZXR8bmV3fHRyeXx2YXJ8Y2FzZXxlbHNlfGVudW18ZXZhbHxmYWxzZXxudWxsfHRoaXN8dHJ1ZXx2b2lkfHdpdGh8YnJlYWt8Y2F0Y2h8Y2xhc3N8Y29uc3R8c3VwZXJ8dGhyb3d8d2hpbGV8eWllbGR8ZGVsZXRlfGV4cG9ydHxpbXBvcnR8cHVibGljfHJldHVybnxzdGF0aWN8c3dpdGNofHR5cGVvZnxkZWZhdWx0fGV4dGVuZHN8ZmluYWxseXxwYWNrYWdlfHByaXZhdGV8Y29udGludWV8ZGVidWdnZXJ8ZnVuY3Rpb258YXJndW1lbnRzfGludGVyZmFjZXxwcm90ZWN0ZWR8aW1wbGVtZW50c3xpbnN0YW5jZW9mKSQvLnRlc3QobmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzYWZlIHByb3BlcnR5IGFjY2Vzc29yIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYWZlIGFjY2Vzc29yXG4gKi9cbnV0aWwuc2FmZVByb3AgPSBmdW5jdGlvbiBzYWZlUHJvcChwcm9wKSB7XG4gICAgaWYgKCEvXlskXFx3X10rJC8udGVzdChwcm9wKSB8fCB1dGlsLmlzUmVzZXJ2ZWQocHJvcCkpXG4gICAgICAgIHJldHVybiBcIltcXFwiXCIgKyBwcm9wLnJlcGxhY2Uoc2FmZVByb3BCYWNrc2xhc2hSZSwgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKHNhZmVQcm9wUXVvdGVSZSwgXCJcXFxcXFxcIlwiKSArIFwiXFxcIl1cIjtcbiAgICByZXR1cm4gXCIuXCIgKyBwcm9wO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIHVwcGVyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwudWNGaXJzdCA9IGZ1bmN0aW9uIHVjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG52YXIgY2FtZWxDYXNlUmUgPSAvXyhbYS16XSkvZztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKVxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAucmVwbGFjZShjYW1lbENhc2VSZSwgZnVuY3Rpb24oJDAsICQxKSB7IHJldHVybiAkMS50b1VwcGVyQ2FzZSgpOyB9KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgcmVmbGVjdGVkIGZpZWxkcyBieSBpZC5cbiAqIEBwYXJhbSB7RmllbGR9IGEgRmlyc3QgZmllbGRcbiAqIEBwYXJhbSB7RmllbGR9IGIgU2Vjb25kIGZpZWxkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBDb21wYXJpc29uIHZhbHVlXG4gKi9cbnV0aWwuY29tcGFyZUZpZWxkc0J5SWQgPSBmdW5jdGlvbiBjb21wYXJlRmllbGRzQnlJZChhLCBiKSB7XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciB0eXBlcyAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVOYW1lXSBUeXBlIG5hbWUsIGRlZmF1bHRzIHRvIHRoZSBjb25zdHJ1Y3RvcidzIG5hbWVcbiAqIEByZXR1cm5zIHtUeXBlfSBSZWZsZWN0ZWQgdHlwZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAcHJvcGVydHkge1Jvb3R9IHJvb3QgRGVjb3JhdG9ycyByb290XG4gKi9cbnV0aWwuZGVjb3JhdGVUeXBlID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKGN0b3IsIHR5cGVOYW1lKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY3Rvci4kdHlwZSkge1xuICAgICAgICBpZiAodHlwZU5hbWUgJiYgY3Rvci4kdHlwZS5uYW1lICE9PSB0eXBlTmFtZSkge1xuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QucmVtb3ZlKGN0b3IuJHR5cGUpO1xuICAgICAgICAgICAgY3Rvci4kdHlwZS5uYW1lID0gdHlwZU5hbWU7XG4gICAgICAgICAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoY3Rvci4kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0b3IuJHR5cGU7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIVR5cGUpXG4gICAgICAgIFR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuXG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZSh0eXBlTmFtZSB8fCBjdG9yLm5hbWUpO1xuICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZCh0eXBlKTtcbiAgICB0eXBlLmN0b3IgPSBjdG9yOyAvLyBzZXRzIHVwIC5lbmNvZGUsIC5kZWNvZGUgZXRjLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLCBcIiR0eXBlXCIsIHsgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gdHlwZTtcbn07XG5cbnZhciBkZWNvcmF0ZUVudW1JbmRleCA9IDA7XG5cbi8qKlxuICogRGVjb3JhdG9yIGhlbHBlciBmb3IgZW51bXMgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBFbnVtIG9iamVjdFxuICogQHJldHVybnMge0VudW19IFJlZmxlY3RlZCBlbnVtXG4gKi9cbnV0aWwuZGVjb3JhdGVFbnVtID0gZnVuY3Rpb24gZGVjb3JhdGVFbnVtKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9iamVjdC4kdHlwZSlcbiAgICAgICAgcmV0dXJuIG9iamVjdC4kdHlwZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFFbnVtKVxuICAgICAgICBFbnVtID0gcmVxdWlyZShcIi4vZW51bVwiKTtcblxuICAgIHZhciBlbm0gPSBuZXcgRW51bShcIkVudW1cIiArIGRlY29yYXRlRW51bUluZGV4KyssIG9iamVjdCk7XG4gICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKGVubSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgXCIkdHlwZVwiLCB7IHZhbHVlOiBlbm0sIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiBlbm07XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBieSBwcm9wZXJ0eSBwYXRoLiBJZiBhIHZhbHVlIGFscmVhZHkgZXhpc3RzLCBpdCBpcyB0dXJuZWQgdG8gYW4gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGRvdCAnLicgZGVsaW1pdGVkIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbnV0aWwuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAocGFydCA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgICAgIHJldHVybiBkc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZHN0W3BhcnRdID0gc2V0UHJvcChkc3RbcGFydF0gfHwge30sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBkc3RbcGFydF07XG4gICAgICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KHByZXZWYWx1ZSkuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgIGRzdFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImRzdCBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICBpZiAoIXBhdGgpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInBhdGggbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIHNldFByb3AoZHN0LCBwYXRoLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciByb290IChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIHV0aWwuZGVjb3JhdGVSb290XG4gKiBAdHlwZSB7Um9vdH1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodXRpbCwgXCJkZWNvcmF0ZVJvb3RcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByb290c1tcImRlY29yYXRlZFwiXSB8fCAocm9vdHNbXCJkZWNvcmF0ZWRcIl0gPSBuZXcgKHJlcXVpcmUoXCIuL3Jvb3RcIikpKCkpO1xuICAgIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJhbmNoTm9kZVN0cnVjdC5qcy5tYXAifQ==
